# baseURI: http://topbraid.org/swa/ontologyapp
# imports: http://teamwork.topbraidlive.org/ontologyprojects
# imports: http://topbraid.org/swa
# imports: http://topbraid.org/swawizards
# imports: http://topbraid.org/teamwork.ui
# prefix: ontologyapp

@prefix acjob: <http://evn.topbraidlive.org/tagger/acjob#> .
@prefix acpp: <http://topbraid.org/nlp/autoclassifier-preproc#> .
@prefix adminguide: <http://server.topbraidlive.org/doc/adminguide#> .
@prefix afn: <http://jena.hpl.hp.com/ARQ/function#> .
@prefix arg: <http://spinrdf.org/arg#> .
@prefix autotagger: <http://evn.topbraidlive.org/autotagger#> .
@prefix cfg: <http://server.topbraidlive.org/web/2009/config#> .
@prefix charts: <http://uispin.org/charts#> .
@prefix compliance: <http://topbraid.org/compliance#> .
@prefix composite: <http://www.topbraid.org/2007/05/composite.owl#> .
@prefix conceptmatch: <http://topbraid.org/conceptmatch#> .
@prefix config: <http://server.topbraidlive.org/dynamic/config#> .
@prefix config-importers: <http://edg.topbraidlive.org/config/importers#> .
@prefix contact: <http://www.w3.org/2000/10/swap/pim/contact#> .
@prefix core-soa: <http://www.semanticweb.org/ontologies/2010/01/core-soa.owl#> .
@prefix corpus: <http://topbraid.org/corpus#> .
@prefix corpusprojects: <http://topbraid.org/corpus-projects#> .
@prefix crosswalk: <http://topbraid.org/crosswalk#> .
@prefix crosswalk.spin: <http://topbraid.org/crosswalk.spin#> .
@prefix crosswalkapp: <http://topbraid.org/swa/crosswalkapp#> .
@prefix crosswalkprojects: <http://teamwork.topbraidlive.org/crosswalkprojects#> .
@prefix css: <http://uispin.org/css#> .
@prefix daml: <http://www.daml.org/2001/03/daml+oil#> .
@prefix dash: <http://datashapes.org/dash#> .
@prefix dashboard: <http://example.org/dashboard#> .
@prefix datagraph: <http://teamwork.topbraidlive.org/datagraph/datagraphprojects#> .
@prefix dataset: <http://teamwork.topbraidlive.org/dataset#> .
@prefix datasetapp: <http://topbraid.org/swa/datasetapp#> .
@prefix datasetviewer: <http://topbraid.org/swa/datasetviewer#> .
@prefix datatype: <http://qudt.org/vocab/datatype/> .
@prefix dc: <http://purl.org/dc/elements/1.1/> .
@prefix dcam: <http://purl.org/dc/dcam/> .
@prefix dcterms: <http://purl.org/dc/terms/> .
@prefix ddl: <http://edg.topbraidlive.org/1.0/importers/ddl#> .
@prefix default: <http://uispin.org/default#> .
@prefix defaultapp: <http://topbraid.org/swa/defaultapp#> .
@prefix deployProjectToServer: <http://server.topbraidlive.org/doc/deployProjectToServer#> .
@prefix devguide: <http://evn.topbraidlive.org/evndoc.www/devguide#> .
@prefix doap: <http://usefulinc.com/ns/doap#> .
@prefix doc: <http://www.w3.org/2000/10/swap/pim/doc#> .
@prefix document: <http://topbraid.org/document#> .
@prefix documents: <http://edg.topbraid.solutions/1.0/shapes/documents#> .
@prefix dtype: <http://www.linkedmodel.org/schema/dtype#> .
@prefix edg: <http://edg.topbraid.solutions/model/> .
@prefix edg-config: <http://edg.ext.topbraidlive.org/schema/config/importers#> .
@prefix edg-importer: <http://edg.topbraidlive.org/importer/> .
@prefix edg-qa: <http://edg.topbraidlive.org/utility/qa/> .
@prefix edg.c: <http://edg.topbraid.solutions/controller/> .
@prefix edg.global: <urn:x-evn-global:> .
@prefix edg.glossary: <http://edg.topbraid.solutions/glossary/> .
@prefix edg.sqoop: <http://edg.topbraid.solutions/model/sqoop/> .
@prefix edg.v: <http://edg.topbraid.solutions/view/> .
@prefix edgproduct: <http://edg.topbraidlive.org/edgproduct#> .
@prefix eeh-lib: <http://www.environmenthub.no/spin/1.0/eeh-lib#> .
@prefix eeh-reportlib: <http://www.environmenthub.no/spin/1.0/eeh-reportlib#> .
@prefix elements: <http://purl.org/dc/elements/1.1/> .
@prefix email: <http://topbraid.org/email#> .
@prefix evn: <http://topbraid.org/evn/evn#> .
@prefix evnAdminIndex: <http://evn.topbraidlive.org/evnAdminIndex#> .
@prefix evnIntro: <http://evn.topbraidlive.org/evndoc.www/evnIntro#> .
@prefix evndoc: <http://evn.topbraidlive.org/evndoc.www/evndoc#> .
@prefix evnimport: <http://evn.topbraidlive.org/uispin/evnimport#> .
@prefix evninstallguide: <http://teamwork.topbraidlive.org/doc/evninstallguide#> .
@prefix evnui: <http://evn.topbraidlive.org/ui#> .
@prefix ex: <http://example.org/> .
@prefix extjs: <http://uispin.com/extjs#> .
@prefix flow: <http://www.w3.org/2005/01/wf/flow#> .
@prefix fn: <http://www.w3.org/2005/xpath-functions#> .
@prefix foaf: <http://xmlns.com/foaf/0.1/> .
@prefix formTemplate: <http://teamwork.topbraidlive.org/system/formTemplate#> .
@prefix forms: <http://www.topbraid.org/2007/01/forms.owl#> .
@prefix geo: <http://www.w3.org/2003/01/geo/wgs84_pos#> .
@prefix gettingstarted: <http://evn.topbraidlive.org/evndoc.www/gettingstarted#> .
@prefix glossary: <http://evn.topbraidlive.org/evndoc.www/glossary#> .
@prefix governance: <http://topbraid.org/teamworkgovernance.ui#> .
@prefix gr: <http://purl.org/goodrelations/v1#> .
@prefix graphql: <http://datashapes.org/graphql#> .
@prefix graphql.search: <http://teamwork.topbraidlive.org/graphql.search#> .
@prefix html: <http://uispin.org/html#> .
@prefix imported: <http://topbraid.org/imported#> .
@prefix inference: <http://www.topbraid.org/2007/06/inference.owl#> .
@prefix jdbc: <http://edg.topbraidlive.org/1.0/importers/jdbc#> .
@prefix json: <http://topbraid.org/json#> .
@prefix kennedys: <http://topbraid.org/examples/kennedys#> .
@prefix let: <http://uispin.org/let#> .
@prefix letrs: <http://uispin.org/letrs#> .
@prefix lib-importer: <http://edg.topbraid.solutions/importer/lib#> .
@prefix lineage-transform: <http://edg.topbraid.solutions/transform/importer/lineage#> .
@prefix list: <http://jena.hpl.hp.com/ARQ/list#> .
@prefix log: <http://www.w3.org/2000/10/swap/log#> .
@prefix metadata: <http://topbraid.org/metadata#> .
@prefix ontologyapp: <http://topbraid.org/swa/ontologyapp#> .
@prefix ontologyprojects: <http://teamwork.topbraidlive.org/ontologyprojects#> .
@prefix ontologyviewer: <http://topbraid.org/swa/ontologyviewer#> .
@prefix org: <http://www.w3.org/ns/org#> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix permissionGroupMgmt: <http://server.topbraidlive.org/doc/permissionGroupMgmt#> .
@prefix pg: <http://server.topbraidlive.org/web/2013/permissiongroups#> .
@prefix prov: <http://www.w3.org/ns/prov#> .
@prefix provo: <http://www.w3.org/ns/prov#> .
@prefix proxy-lineage: <http://edg.topbraid.solutions/proxy/importer/lineage#> .
@prefix quantity: <http://qudt.org/vocab/quantity/> .
@prefix qudd: <http://qudt.org/schema/datastructure/> .
@prefix quds: <http://qudt.org/schema/datastructure/> .
@prefix qudt: <http://qudt.org/schema/qudt/> .
@prefix qudt-refdata: <http://qudt.org/vocab/refdata/> .
@prefix qudt.type: <http://qudt.org/vocab/type/> .
@prefix raci: <http://topbraid.org/raci#> .
@prefix raci.spin: <http://topbraid.org/raci.spin#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix rdm: <http://rdm.topbraidlive.org/rdm/> .
@prefix rdmapp: <http://rdm.topbraidlive.org/rdmapp#> .
@prefix rdmfact: <http://topbraid.org/rdmfact#> .
@prefix rdmprojects: <http://rdm.topbraidlive.org/rdmprojects#> .
@prefix rdmviewer: <http://rdm.topbraidlive.org/rdmviewer#> .
@prefix saf: <http://topbraid.org/saf/> .
@prefix safconfig: <http://topbraid.org/safconfig/> .
@prefix safindex: <http://topbraid.org/safindex#> .
@prefix safm: <http://saf.topbraidlive.org/metaschema/> .
@prefix savedQueries: <http://teamwork.topbraidlive.org/ui/savedQueries#> .
@prefix scheduler: <http://topbraid.org/scheduler#> .
@prefix sd: <http://www.w3.org/ns/sparql-service-description#> .
@prefix search: <http://topbraid.org/search#> .
@prefix search.spin: <http://topbraid.org/search.spin#> .
@prefix server: <http://server.topbraidlive.org/server.ui#> .
@prefix sh: <http://www.w3.org/ns/shacl#> .
@prefix shapesgraph: <http://teamwork.topbraidlive.org/shapesgraph/shapesgraphprojects#> .
@prefix sharepoint: <http://topbraid.org/sharepoint#> .
@prefix sharepoint.spin: <http://topbraid.org/sharepoint.spin#> .
@prefix sioc: <http://rdfs.org/sioc/ns#> .
@prefix skos: <http://www.w3.org/2004/02/skos/core#> .
@prefix skosapp: <http://evn.topbraidlive.org/uiplugins#> .
@prefix skosshapes: <http://topbraid.org/skos.shapes#> .
@prefix skostemplate: <http://topbraid.org/spin/skostemplates#> .
@prefix skosxl: <http://www.w3.org/2008/05/skos-xl#> .
@prefix sm: <http://topbraid.org/sparqlmotion#> .
@prefix smf: <http://topbraid.org/sparqlmotionfunctions#> .
@prefix sml: <http://topbraid.org/sparqlmotionlib#> .
@prefix soa: <http://www.semanticweb.org/ontologies/2010/01/core-soa.owl#> .
@prefix softwareprojects: <http://teamwork.topbraidlive.org/software/softwareprojects#> .
@prefix solr: <http://topbraid.org/solr#> .
@prefix sp: <http://spinrdf.org/sp#> .
@prefix sparqlmotionlib-swp: <http://topbraid.org/sparqlmotionlib-swp#> .
@prefix sparqlmotionlib-tbc: <http://topbraid.org/sparqlmotionlib-tbc#> .
@prefix spell: <http://topbraid.org/spellcheckresults#> .
@prefix spif: <http://spinrdf.org/spif#> .
@prefix spin: <http://spinrdf.org/spin#> .
@prefix spin.ui: <http://spinrdf.org/spin.ui#> .
@prefix spinmap: <http://spinrdf.org/spinmap#> .
@prefix spinmapl: <http://topbraid.org/spin/spinmapl#> .
@prefix spinx: <http://spinrdf.org/spinx#> .
@prefix spl: <http://spinrdf.org/spl#> .
@prefix spl-dynamic-ranges: <http://spinrdf.org/spl-dynamic-ranges#> .
@prefix spr: <http://spinrdf.org/spr#> .
@prefix spra: <http://spinrdf.org/spra#> .
@prefix ss: <http://www.topbraidcomposer.org/owl/2006/08/spreadsheets.owl#> .
@prefix stats: <http://topbraid.org/statistics#> .
@prefix status: <http://topbraid.org/status#> .
@prefix style: <http://uispin.org/style#> .
@prefix svg: <http://uispin.org/svg#> .
@prefix swa: <http://topbraid.org/swa#> .
@prefix swaclasses: <http://topbraid.org/swaclasses#> .
@prefix swadoc: <http://topbraid.org/swadoc#> .
@prefix swaeditor: <http://topbraid.org/swaeditor#> .
@prefix swaowl: <http://topbraid.org/swaowl#> .
@prefix swash: <http://topbraid.org/swash#> .
@prefix swashacl: <http://topbraid.org/swashacl#> .
@prefix swauml: <http://topbraid.org/swauml#> .
@prefix swon: <http://uispin.org/swon#> .
@prefix sxml: <http://topbraid.org/sxml#> .
@prefix tables: <http://topbraid.org/tables#> .
@prefix tablesmap: <http://topbraid.org/spin/tablesmap#> .
@prefix tagger: <http://evn.topbraidlive.org/tagger#> .
@prefix taggerprojects: <http://evn.topbraidlive.org/taggerprojects#> .
@prefix taggerspin: <http://evn.topbraidlive.org/taggerspin#> .
@prefix taggerui: <http://evn.topbraidlive.org/taggerui#> .
@prefix task: <http://topbraid.org/task#> .
@prefix tasks: <http://topbraid.org/tasks#> .
@prefix tasks.spin: <http://topbraid.org/tasks.spin#> .
@prefix taxonomies: <http://evn.topbraidlive.org/evnprojects#> .
@prefix tbl: <http://topbraidlive.org/functions#> .
@prefix tbladmin: <http://server.topbraidlive.org/system-applications/tbladmin#> .
@prefix tbladmindoc: <http://server.topbraidlive.org/doc/adminguide#> .
@prefix tblinstallguide: <http://server.topbraidlive.org/doc/tblinstallguide#> .
@prefix tblui: <http://server.topbraidlive.org/tblui#> .
@prefix teaminstallsec: <http://teamwork.topbraidlive.org/doc/teamworkInstallGuideSections#> .
@prefix teamwork: <http://topbraid.org/teamwork#> .
@prefix teamworkAdmin: <http://teamwork.topbraidlive.org/doc/teamworkAdmin#> .
@prefix teamworkconfig: <http://server.topbraidlive.org/system-applications/teamworkconfig#> .
@prefix teamworkconstraints: <http://topbraid.org/teamworkconstraints#> .
@prefix teamworkdashboard: <http://topbraid.org/teamworkdashboard#> .
@prefix teamworknotifications: <http://topbraid.org/teamworknotifications#> .
@prefix teamworkrules: <http://topbraid.org/teamworkrules#> .
@prefix teamworkscripts: <http://topbraid.org/teamworkscripts#> .
@prefix teamworkupdate: <http://teamworkAPI.topbraid.com/teamworkUpdate#> .
@prefix textindex: <http://topbraid.org/textindex#> .
@prefix tika-importer: <http://teamwork.topbraidlive.org/corpus/tika-importer#> .
@prefix tops: <http://www.topbraid.org/tops#> .
@prefix tosh: <http://topbraid.org/tosh#> .
@prefix tosh.ui: <http://topbraid.org/tosh.ui#> .
@prefix tracker: <http://teamwork.topbraidlive.org/ui/tracker#> .
@prefix ui: <http://uispin.org/ui#> .
@prefix uitest: <http://uispin.org/test#> .
@prefix uix: <http://topbraidlive.org/uix#> .
@prefix unit: <http://qudt.org/vocab/unit/> .
@prefix userAdminIndex: <http://evn.topbraidlive.org/userAdminIndex#> .
@prefix userIndex: <http://evn.topbraidlive.org/evndoc.www/userIndex#> .
@prefix userdat: <http://teamwork.topbraidlive.org/ui/userdata> .
@prefix userdata: <http://teamwork.topbraidlive.org/ui/userdata#> .
@prefix usingtagger: <http://evn.topbraidlive.org/taggerdoc.www/usingtagger#> .
@prefix vaem: <http://www.linkedmodel.org/schema/vaem#> .
@prefix victory: <http://edg.topbraid.solutions/victory/> .
@prefix visual: <http://topbraid.org/visual#> .
@prefix voag: <http://voag.linkedmodel.org/voag/> .
@prefix vs: <http://www.w3.org/2003/06/sw-vocab-status/ns#> .
@prefix wf: <http://www.w3.org/2005/01/wf/flow#> .
@prefix wot: <http://xmlns.com/wot/0.1/> .
@prefix xhtml: <http://topbraid.org/xhtml#> .
@prefix xlink: <http://www.w3.org/1999/xlink#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

arg:rootClass
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
<http://topbraid.org/swa/ontologyapp>
  a owl:Ontology ;
  rdfs:comment "An Ontology editor application." ;
  owl:imports <http://teamwork.topbraidlive.org/ontologyprojects> ;
  owl:imports <http://topbraid.org/swa> ;
  owl:imports <http://topbraid.org/swawizards> ;
  owl:imports <http://topbraid.org/teamwork.ui> ;
.
ontologyapp:AddNodeShapeTypeToNewClassesPlugin
  a swa:AddDefaultValuesPlugin ;
  ui:prototype """
<ui:if ui:condition=\"{= teamwork:isSHACLPreferred() &amp;&amp; spl:instanceOf(?resource, rdfs:Class) }\">
    <ui:update ui:updateQuery=\"{!
            INSERT {
                ?resource a sh:NodeShape .
            }
            WHERE {
            } }\"/>
</ui:if>
"""^^ui:Literal ;
  rdfs:comment "Adds rdf:type sh:NodeShape to newly created classes, if the SHACL preferred mode is activated." ;
  rdfs:label "Add node shape type to new classes plugin" ;
  rdfs:subClassOf swa:AddDefaultValuesPlugins ;
.
ontologyapp:AddPropertyShapesFromWikidataSampleAction
  a swa:ResourceAction ;
  arg:appName "Ontology" ;
  arg:condition [
      a sp:if ;
      sp:arg1 [
          a sp:and ;
          sp:arg1 [
              a spl:instanceOf ;
              sp:arg1 [
                  sp:varName "resource" ;
                ] ;
              sp:arg2 sh:NodeShape ;
            ] ;
          sp:arg2 [
              a sp:isIRI ;
              sp:arg1 [
                  sp:varName "resource" ;
                ] ;
            ] ;
        ] ;
      sp:arg2 true ;
      sp:arg3 [
          sp:varName "none" ;
        ] ;
    ] ;
  arg:group "form" ;
  arg:onSelect "teamworkreports.addPropertyShapesFromWikidataSample(resourceURI);" ;
  rdfs:label "Add property shapes from Wikidata sample..." ;
.
ontologyapp:AddPropertyShapesFromWikidataSampleService
  a ui:Service ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:json ;
      spl:valueType xsd:string ;
      rdfs:comment """A JSON array such as

[
	{
		\"path\": \"http://example.org/property\",
		\"name\": \"example\"
	}
]""" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:nodeShape ;
      spl:valueType sh:NodeShape ;
      rdfs:comment "The target shape." ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:json ui:str=\"{= ?json }\" ui:varName=\"array\">
    <ui:transaction ui:logMessage=\"Add property shapes from wikidata sample\">
        <ui:forEach ui:resultSet='{#
                SELECT ?path ?name ?ps ?datatype ?count
                WHERE {
                    ?array ui:jsonArrayMembers ?item .
                    BIND (IRI(ui:jsonString(ui:jsonValue(?item, \"datatype\"))) AS ?datatype) .
                    BIND (IRI(ui:jsonString(ui:jsonValue(?item, \"path\"))) AS ?path) .
                    BIND (ui:jsonString(ui:jsonValue(?item, \"name\")) AS ?name) .
                    BIND (ui:jsonString(ui:jsonValue(?item, \"count\")) AS ?count) .
                    BIND (BNODE() AS ?ps) .
                } }'>
            <ui:update ui:updateQuery=\"{!
                    INSERT {
                        ?ps a sh:PropertyShape .
                        ?ps sh:path ?path .
                        ?ps sh:name ?name .
                        ?ps sh:datatype ?datatype .
                        ?ps sh:minCount ?minCount .
                        ?ps sh:maxCount ?maxCount .
                        ?ps graphql:name ?gqlName .
                        ?nodeShape sh:property ?ps .
                    }
                    WHERE {
                        BIND (IF((?path = rdfs:label), &quot;rdfs_label&quot;, IF((?path = rdf:type), &quot;rdf_type&quot;, ?none)) AS ?gqlName) .
                        BIND (IF(((?count = &quot;1..1&quot;) || (?count = &quot;1..*&quot;)), 1, ?none) AS ?minCount) .
                        BIND (IF(((?count = &quot;0..1&quot;) || (?count = &quot;1..1&quot;)), 1, ?none) AS ?maxCount) .
                    } }\"/>
        </ui:forEach>
    </ui:transaction>
</ui:json>
"""^^ui:Literal ;
  rdfs:comment "Used by the 'Add property shapes from wikidate sample instance' dialog, when OK is clicked." ;
  rdfs:label "Add property shapes from Wikidata sample service" ;
  rdfs:subClassOf ui:JSONServices ;
.
ontologyapp:Application
  a ui:NodeClass ;
  teamwork:faIcon "list" ;
  ui:headIncludes """
<ui:group>
    <title>{= teamwork:graphLabel(teamwork:masterGraph(teamwork:currentGraphId())) } Editor</title>
    <script>(function(){ teamwork.initRichTextEditors(); })();</script>
</ui:group>
"""^^ui:Literal ;
  ui:prototype """
<teamwork:EditorChrome arg:projectType=\"{= teamwork:getProjectType(teamwork:currentMasterGraph()) }\">
    <ui:setContext ui:varName=\"canLinkBNodeFunction\" ui:varValue=\"{= ontologyapp:canLinkBNodeFunction }\">
        <ui:setContext let:classSelectedEvent=\"org.ontologyapp.classSelected\" let:frozen=\"{= teamwork:isExplorerUser(smf:userWithName(smf:currentUserName())) || teamwork:isCurrentGraphFrozen() }\" let:instanceSelectedEvent=\"org.ontologyapp.instanceSelected\" ui:varName=\"swaAppName\" ui:varValue=\"Ontology,Editor{= IF(teamwork:isCurrentGraphFrozen(), &quot;,ReadOnly&quot;, ?none) }\">
            <ui:setContext ui:varName=\"swaOnOpenResource\" ui:varValue=\"{= teamwork:onOpenResource(?instanceSelectedEvent) }\">
                <ui:setContext ui:varName=\"swaCategoryFunction\" ui:varValue=\"{= swa:categoryByNamespace }\">
                    <ui:insert ui:into=\"header\">
                        <teamwork:EditorHeader arg:frozen=\"{= ?frozen }\" arg:pageType=\"search-app\">
                            <teamwork:TemplateQueryButton arg:resourceSelectedEvent=\"{= ?instanceSelectedEvent }\"/>
                            <teamwork:UndoButton arg:hidden=\"{= ?frozen }\"/>
                        </teamwork:EditorHeader>
                    </ui:insert>
                    <ui:insert ui:into=\"main\">
                        <teamwork:ChromeBorderLayout arg:deepLinkingEvent=\"{= ?instanceSelectedEvent }\" arg:eastClosed=\"{= true }\" arg:eastSize=\"{= 400 }\" arg:storageKey=\"org.topbraidlive.teamwork.OntologyEditor.5.2\" arg:westSize=\"{= 380 }\" default:editable=\"{= !?frozen }\" let:rootClass=\"{= COALESCE(spl:object(teamwork:currentMasterGraph(), teamwork:rootClass), owl:Thing) }\">
                            <ui:if ui:condition=\"{= ontologyprojects:isNoInstancesMode() }\">
                                <swa:Window arg:id=\"treeWindow\" arg:layoutPanel=\"west\" arg:title=\"Class Hierarchy\">
                                    <swa:ClassPropertyTreeGadget arg:resourceSelectedEvent=\"{= ?instanceSelectedEvent }\" ui:args=\"*\"/>
                                </swa:Window>
                            </ui:if>
                            <ui:else>
                                <swa:BorderLayout arg:layoutPanel=\"west\" arg:southSize=\"{= 200 }\" arg:storageKey=\"org.topbraidlive.teamwork.OntologyEditor.west\">
                                    <swa:Window arg:id=\"treeWindow\" arg:layoutPanel=\"center\" arg:title=\"Class Hierarchy\">
                                        <swa:ClassPropertyTreeGadget arg:resourceSelectedEvent=\"{= ?instanceSelectedEvent }\" arg:showNodeShapesButton=\"{= true }\" ui:args=\"*\"/>
                                    </swa:Window>
                                    <swa:Window arg:id=\"ontologyappInstancesWindow\" arg:layoutPanel=\"south\" arg:title=\"Instances\">
                                        <swa:InstancesGridGadget arg:editButton=\"{= true }\" ui:args=\"*\"/>
                                    </swa:Window>
                                </swa:BorderLayout>
                            </ui:else>
                            <swa:Window arg:id=\"ontologyappFormWindow\" arg:layoutPanel=\"center\" arg:title=\"Selected Resource\">
                                <teamwork:SwitchableFormGadget arg:resourceSelectedEvent=\"{= ?instanceSelectedEvent }\" ui:args=\"*\"/>
                            </swa:Window>
                            <swa:BorderLayout arg:layoutPanel=\"east\" arg:southSize=\"{= 200 }\" arg:storageKey=\"org.topbraidlive.teamwork.OntologyEditor.east\">
                                <ui:setContext ui:varName=\"suppressViewpointClass\" ui:varValue=\"{= true }\">
                                    <ui:setContext ui:varName=\"suppressHierarchyViewButton\" ui:varValue=\"{= true }\">
                                        <ui:if ui:condition=\"{= ontologyprojects:isNoInstancesMode() }\">
                                            <swa:MultiGadgetWindow arg:id=\"searchWindow\" arg:layoutPanel=\"center\">
                                                <swa:MultiGadgetChild arg:iconClass=\"swa-icon-class\" arg:title=\"Class Search\">
                                                    <swa:FormSearchGadget arg:cacheId=\"ontology.classes\" arg:classSelectedEvent=\"\" arg:footerPlugin=\"{= teamwork:SavedSearchesFooterPlugin }\" arg:localSearch=\"{= teamwork:isAlwaysLocalSearch() }\" arg:resourceType=\"{= rdfs:Class }\" ui:args=\"*\"/>
                                                </swa:MultiGadgetChild>
                                                <swa:MultiGadgetChild arg:iconClass=\"swa-icon-shape\" arg:title=\"Node Shape Search\">
                                                    <swa:FormSearchGadget arg:cacheId=\"ontology.nodeshapes\" arg:classSelectedEvent=\"\" arg:footerPlugin=\"{= teamwork:SavedSearchesFooterPlugin }\" arg:localSearch=\"{= teamwork:isAlwaysLocalSearch() }\" arg:resourceType=\"{= sh:NodeShape }\" ui:args=\"*\"/>
                                                </swa:MultiGadgetChild>
                                                <swa:MultiGadgetChild arg:iconClass=\"swa-icon-property\" arg:title=\"Property Search\">
                                                    <swa:FormSearchGadget arg:cacheId=\"ontology.properties\" arg:classSelectedEvent=\"\" arg:footerPlugin=\"{= teamwork:SavedSearchesFooterPlugin }\" arg:localSearch=\"{= teamwork:isAlwaysLocalSearch() }\" arg:resourceType=\"{= rdf:Property }\" ui:args=\"*\"/>
                                                </swa:MultiGadgetChild>
                                            </swa:MultiGadgetWindow>
                                            <swa:Window arg:id=\"ontologyappSearchResultsWindow\" arg:layoutPanel=\"south\" arg:title=\"Search Results\">
                                                <swa:DataTableSearchResultsGadget arg:multiSelect=\"{= false }\" arg:resourceSelectedEvent=\"{= ?instanceSelectedEvent }\" ui:args=\"*\"/>
                                            </swa:Window>
                                        </ui:if>
                                        <ui:else>
                                            <swa:Window arg:id=\"ontologyappSearchWindow\" arg:layoutPanel=\"center\" arg:title=\"Search\">
                                                <teamwork:FilterSearchGadget arg:cacheId=\"ontology.main\" arg:containerId=\"ontologyappSearchWindow\" arg:localSearch=\"{= teamwork:isAlwaysLocalSearch() }\" arg:qname=\"{= smf:qname(COALESCE(?resourceType, ?rootClass)) }\" arg:resourceSelectedEvent=\"{= ?instanceSelectedEvent }\" arg:resourceType=\"{= COALESCE(?resourceType, ?rootClass) }\" arg:rootClass=\"{= ?rootClass }\" arg:suppressAdvancedSearch=\"{= true }\" arg:suppressHierarchyViewButton=\"{= ui:contextValue(&quot;suppressHierarchyViewButton&quot;) }\" arg:suppressViewpointSelector=\"{= ui:contextValue(&quot;suppressViewpointClass&quot;) }\" ui:args=\"*\"/>
                                            </swa:Window>
                                        </ui:else>
                                    </ui:setContext>
                                </ui:setContext>
                            </swa:BorderLayout>
                        </teamwork:ChromeBorderLayout>
                    </ui:insert>
                </ui:setContext>
            </ui:setContext>
        </ui:setContext>
    </ui:setContext>
</teamwork:EditorChrome>
"""^^ui:Literal ;
  ui:responseType ui:HTML ;
  rdfs:label "Ontology Application" ;
  rdfs:subClassOf swa:ClosableSearchBarEast ;
  rdfs:subClassOf teamwork:EditorApplications ;
.
ontologyapp:CloneClassAction
  a swa:EditHandlerClass ;
  a swa:ResourceAction ;
  arg:appName "Ontology" ;
  arg:condition [
      a sp:if ;
      sp:arg1 [
          a spl:instanceOf ;
          sp:arg1 [
              sp:varName "resource" ;
            ] ;
          sp:arg2 rdfs:Class ;
        ] ;
      sp:arg2 [
          a sp:isIRI ;
          sp:arg1 [
              sp:varName "resource" ;
            ] ;
        ] ;
      sp:arg3 [
          sp:varName "none" ;
        ] ;
    ] ;
  arg:group "main" ;
  arg:iconClass "ontologyapp-icon-clone-class" ;
  ui:prototype """
<ui:transaction let:new=\"{= swa:newResource(spl:object(?resource, rdf:type)) }\" ui:logMessage=\"Clone class {= ui:label(?resource) }\">
    <ui:update ui:updateQuery=\"{!
            INSERT {
                ?new ?p ?newObject .
            }
            WHERE {
                ?resource ?p ?oldObject .
                FILTER (!isBlank(?oldObject)) .
                BIND (IF((rdfs:label = ?p), teamwork:cloneLabel(?oldObject), ?oldObject) AS ?newObject) .
            } }\"/>
    <ui:forEach ui:resultSet=\"{#
            SELECT ?p ?oldObject
            WHERE {
                ?resource ?p ?oldObject .
                FILTER isBlank(?oldObject) .
            } }\">
        <teamwork:cloneBlankNode arg:oldObject=\"{= ?oldObject }\" arg:predicate=\"{= ?p }\" arg:subject=\"{= ?new }\"/>
    </ui:forEach>
    <ui:forEach ui:resultSet=\"{#
            SELECT ?oldProperty
            WHERE {
                ?oldProperty rdfs:domain ?resource .
            } }\">
        <ui:update ui:updateQuery=\"{!
                INSERT {
                    ?newProperty ?p ?newObject .
                }
                WHERE {
                    ?oldProperty ?p ?oldObject .
                    BIND (IF((rdfs:label = ?p), teamwork:cloneLabel(?oldObject), IF((rdfs:domain = ?p), ?new, ?oldObject)) AS ?newObject) .
                    BIND (swa:newResource(spl:object(?oldProperty, rdf:type)) AS ?newProperty) .
                } }\"/>
    </ui:forEach>
</ui:transaction>
"""^^ui:Literal ;
  rdfs:label "Clone class" ;
  rdfs:subClassOf swa:ResourceEditHandlers ;
.
ontologyapp:CloneInstanceAction
  a swa:ResourceAction ;
  a ui:NodeClass ;
  arg:appName "Ontology" ;
  arg:condition [
      a sp:if ;
      sp:arg1 [
          a sp:and ;
          sp:arg1 [
              a sp:not ;
              sp:arg1 [
                  a spl:instanceOf ;
                  sp:arg1 [
                      sp:varName "resource" ;
                    ] ;
                  sp:arg2 rdfs:Class ;
                ] ;
            ] ;
          sp:arg2 [
              a sp:not ;
              sp:arg1 [
                  a spl:instanceOf ;
                  sp:arg1 [
                      sp:varName "resource" ;
                    ] ;
                  sp:arg2 rdf:Property ;
                ] ;
            ] ;
        ] ;
      sp:arg2 [
          a sp:isIRI ;
          sp:arg1 [
              sp:varName "resource" ;
            ] ;
        ] ;
      sp:arg3 [
          sp:varName "none" ;
        ] ;
    ] ;
  arg:group "main" ;
  arg:iconClass "ontologyapp-icon-clone-instance" ;
  ui:prototype """
<ui:transaction ui:logMessage=\"Clone {= ui:label(?resource) }\">
    <teamwork:cloneResource arg:resource=\"{= ?resource }\"/>
</ui:transaction>
"""^^ui:Literal ;
  rdfs:label "Clone" ;
  rdfs:subClassOf swa:ResourceEditHandlers ;
.
ontologyapp:ClonePropertyAction
  a swa:ResourceAction ;
  a ui:NodeClass ;
  arg:appName "Ontology" ;
  arg:condition [
      a sp:if ;
      sp:arg1 [
          a spl:instanceOf ;
          sp:arg1 [
              sp:varName "resource" ;
            ] ;
          sp:arg2 rdf:Property ;
        ] ;
      sp:arg2 [
          a sp:isIRI ;
          sp:arg1 [
              sp:varName "resource" ;
            ] ;
        ] ;
      sp:arg3 [
          sp:varName "none" ;
        ] ;
    ] ;
  arg:group "main" ;
  arg:iconClass "ontologyapp-icon-clone-property" ;
  ui:prototype """
<ui:transaction ui:logMessage=\"Clone property {= ui:label(?resource) }\">
    <teamwork:cloneResource arg:resource=\"{= ?resource }\"/>
</ui:transaction>
"""^^ui:Literal ;
  rdfs:label "Clone property" ;
  rdfs:subClassOf swa:ResourceEditHandlers ;
.
ontologyapp:CopyIndirectValuesPropertyValueRuleWizard
  a ontologyapp:PropertyValueRuleWizard ;
  swa:valueWizardUpdate ontologyapp:CopyIndirectValuesPropertyValueRuleWizardUpdate ;
  ui:private true ;
  ui:prototype """
<ontologyapp:IndirectPropertySelectors arg:focusNode=\"{= ?focusNode }\"/>
"""^^ui:Literal ;
  rdfs:comment "Produces a property values rule that copies the value of another value ('one hop away'). For example, if you are at a Country object that links to a similar object from Wikidata, then you could copy the population from the Wikidata object." ;
  rdfs:label "Copy indirect values (one hop away)" ;
  rdfs:subClassOf ontologyapp:PropertyValueRuleWizards ;
.
ontologyapp:CopyIndirectValuesPropertyValueRuleWizardUpdate
  a swa:ValueWizardUpdate ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:firstProperty ;
      spl:valueType rdf:Property ;
      rdfs:comment "The first property." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:secondProperty ;
      spl:valueType rdf:Property ;
      rdfs:comment "The second property." ;
    ] ;
  ui:mutationFieldName "CopyIndirectValuesPropertyValueRuleWizardUpdate" ;
  ui:private true ;
  ui:prototype """
<ui:transaction ui:logMessage=\"Create property rule to copy indirect values\">
    <ui:update ui:updateQuery=\"{!
            INSERT {
                ?focusNode sh:values ?secondPath .
                ?secondPath sh:path ?secondProperty .
                ?secondPath sh:nodes ?firstPath .
                ?firstPath sh:path ?firstProperty .
            }
            WHERE {
                BIND (BNODE() AS ?firstPath) .
                BIND (BNODE() AS ?secondPath) .
            } }\"/>
</ui:transaction>
"""^^ui:Literal ;
  rdfs:subClassOf ontologyapp:PropertyValueRuleWizardUpdates ;
.
ontologyapp:CountPropertyValueRuleWizard
  a ontologyapp:PropertyValueRuleWizard ;
  swa:valueWizardUpdate ontologyapp:CountPropertyValueRuleWizardUpdate ;
  ui:private true ;
  ui:prototype """
<ui:group let:nodeShape=\"{= spl:subject(sh:property, ?focusNode) }\">
    <ontologyapp:PropertySelector arg:label=\"Property to count the values of\" arg:name=\"property\" arg:nodeShape=\"{= ?nodeShape }\" arg:onChange=\"swa.setWizardCanFinish(true)\"/>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "Produces a property value rule that counts the values of another property. An example is if you have a property \"child\" and you want to compute \"child count\"." ;
  rdfs:label "Count number of property values" ;
  rdfs:subClassOf ontologyapp:PropertyValueRuleWizards ;
.
ontologyapp:CountPropertyValueRuleWizardUpdate
  a swa:ValueWizardUpdate ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property of which we are counting the values." ;
    ] ;
  ui:mutationFieldName "CountPropertyValueRuleWizardUpdate" ;
  ui:private true ;
  ui:prototype """
<ui:transaction ui:logMessage=\"Create property rule to count property values\">
    <ui:update ui:updateQuery=\"{!
            INSERT {
                ?focusNode sh:values ?count .
                ?count sh:count ?path .
                ?path sh:path ?property .
                ?focusNode sh:datatype xsd:integer .
            }
            WHERE {
                BIND (BNODE() AS ?count) .
                BIND (BNODE() AS ?path) .
            } }\"/>
</ui:transaction>
"""^^ui:Literal ;
  rdfs:subClassOf ontologyapp:PropertyValueRuleWizardUpdates ;
.
ontologyapp:DeriveSuggestedURI
  a ui:Service ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:label ;
      spl:valueType xsd:string ;
      rdfs:comment "The label to turn into a URI." ;
    ] ;
  ui:private true ;
  ui:prototype """
<swon:Object let:uri=\"{= swa:newResourceByLabel(?label) }\">
    <swon:Value arg:name=\"uri\" arg:value=\"{= ?uri }\"/>
</swon:Object>
"""^^ui:Literal ;
  rdfs:label "Derive suggested URI" ;
  rdfs:subClassOf ui:JSONServices ;
.
ontologyapp:DeriveViewShape
  a ui:Service ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:baseShape ;
      spl:valueType sh:Shape ;
      rdfs:comment "The base shape to derive a new shape from." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:newShapeLabel ;
      spl:valueType xsd:string ;
      rdfs:comment "The label of the new shape." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:newShapeURI ;
      spl:valueType xsd:string ;
      rdfs:comment "The URI of the new shape." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:paths ;
      spl:valueType xsd:string ;
      rdfs:comment "A space-separated string of predicate URIs to copy. URIs starting with '^' are interpreted as sh:inversePath." ;
    ] ;
  ui:private true ;
  ui:prototype """
<swon:Object let:newShape=\"{= IRI(?newShapeURI) }\">
    <ui:if ui:condition=\"{= !spif:isValidURI(?newShapeURI) }\">
        <swon:Value arg:name=\"error\" arg:value=\"Invalid URI: {= ?newShapeURI }\"/>
    </ui:if>
    <ui:elseif ui:condition=\"{= EXISTS {
        ?newShape ?anyP ?anyO .
    } }\">
        <swon:Value arg:name=\"error\" arg:value=\"URI already used: {= ?newShapeURI }\"/>
    </ui:elseif>
    <ui:else>
        <ui:setContext ui:silentTransactions=\"{= true }\">
            <ui:transaction ui:logMessage=\"Derive view shape {= ?newShapeLabel }\">
                <ui:update ui:updateQuery=\"{!
                        INSERT {
                            ?newShape a sh:NodeShape .
                            ?newShape rdfs:label ?newShapeLabel .
                        }
                        WHERE {
                        } }\"/>
                <ui:update ui:updateQuery=\"{!
                        INSERT {
                            ?newShape dash:applicableToClass ?targetClass .
                        }
                        WHERE {
                            ?baseShape sh:targetClass ?targetClass .
                        } }\"/>
                <ui:update ui:updateQuery=\"{!
                        INSERT {
                            ?newShape dash:applicableToClass ?baseShape .
                        }
                        WHERE {
                            FILTER spl:instanceOf(?baseShape, rdfs:Class) .
                        } }\"/>
                <teamwork:ClonePropertyShapesFrom arg:paths=\"{= ?paths }\" arg:sourceShape=\"{= ?baseShape }\" arg:targetShape=\"{= ?newShape }\"/>
            </ui:transaction>
        </ui:setContext>
    </ui:else>
</swon:Object>
"""^^ui:Literal ;
  rdfs:label "Derive view shape" ;
  rdfs:subClassOf ui:JSONServices ;
.
ontologyapp:DeriveViewShapeAction
  a swa:ResourceAction ;
  arg:appName "Ontology" ;
  arg:condition [
      a sp:if ;
      sp:arg1 [
          a spl:instanceOf ;
          sp:arg1 [
              sp:varName "resource" ;
            ] ;
          sp:arg2 sh:NodeShape ;
        ] ;
      sp:arg2 true ;
      sp:arg3 [
          sp:varName "none" ;
        ] ;
    ] ;
  arg:group "form" ;
  arg:onSelect "ontologyapp.openDeriveViewShapeDialog(resourceURI);" ;
  rdfs:label "Derive view shape..." ;
.
ontologyapp:EditListMemberShapeAction
  a swa:ResourceAction ;
  arg:appName "Ontology" ;
  arg:condition [
      a sp:if ;
      sp:arg1 [
          a sp:exists ;
          sp:elements (
              [
                sp:object dash:ListShape ;
                sp:predicate sh:node ;
                sp:subject [
                    sp:varName "resource" ;
                  ] ;
              ]
            ) ;
        ] ;
      sp:arg2 true ;
      sp:arg3 [
          sp:varName "none" ;
        ] ;
    ] ;
  arg:group "main" ;
  arg:onSelect "swa.editListMemberShape(resourceURI)" ;
  rdfs:label "Edit shape of list members" ;
.
ontologyapp:EditPropertyGroupsAction
  a swa:ResourceAction ;
  arg:appName "Ontology" ;
  arg:condition [
      a sp:if ;
      sp:arg1 [
          a spl:instanceOf ;
          sp:arg1 [
              sp:varName "resource" ;
            ] ;
          sp:arg2 sh:NodeShape ;
        ] ;
      sp:arg2 true ;
      sp:arg3 [
          sp:varName "none" ;
        ] ;
    ] ;
  arg:group "form" ;
  arg:iconClass "create-window" ;
  arg:onSelect "swa.openPropertyGroupsEditor(resourceURI);" ;
  rdfs:label "View/Edit property layout groups..." ;
.
ontologyapp:EditableGenericTreeDesktopWindowForClassResourceAction
  a swa:ResourceAction ;
  arg:appName "Ontology" ;
  arg:condition [
      a sp:if ;
      sp:arg1 [
          a spl:instanceOf ;
          sp:arg1 [
              sp:varName "resource" ;
            ] ;
          sp:arg2 rdfs:Class ;
        ] ;
      sp:arg2 true ;
      sp:arg3 [
          sp:varName "none" ;
        ] ;
    ] ;
  arg:onSelect "swa.openGadgetWindow('swa:GenericTreeGadgetWindow', { resourceType: \"<\" + resourceURI + \">\", editable: true, resourceSelectedEvent: 'org.ontologyapp.instanceSelected' }, \"west\")" ;
  swa:readOnly true ;
  rdfs:label "Open hierarchy of instances" ;
.
ontologyapp:GetLearnPropertyValuesRuleInfo
  a ui:Service ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:nodeShape ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The node shape that was selected by the user." ;
    ] ;
  ui:private true ;
  ui:prototype """
<swon:Object let:projectGraph=\"{= teamwork:currentMasterGraph() }\" let:tag=\"{= teamwork:currentTag() }\">
    <swon:Value arg:name=\"serviceURL\" arg:value=\"{= teamwork:graphQLPageLinkForShape(?projectGraph, ?nodeShape, ?tag) }\"/>
    <swon:Value arg:name=\"nodeShapeLabel\" arg:value=\"{= ui:label(?nodeShape) }\"/>
    <swon:Value arg:name=\"graphs\">
        <swon:RSObjectArray arg:resultSet='{#
                SELECT ?uri ?label
                WHERE {
                    rdf:nil teamwork:graphsUnderTeamControl ( ?otherProjectGraph ?tch ) .
                    FILTER EXISTS {
                        GRAPH ?otherProjectGraph {
                            ?otherProjectGraph (owl:imports)* ?projectGraph .
                        } .
                    } .
                    BIND (str(?otherProjectGraph) AS ?uri) .
                    BIND (teamwork:singularProjectTypeLabel(teamwork:getProjectType(?otherProjectGraph)) AS ?ptLabel) .
                    BIND (teamwork:graphLabel(?otherProjectGraph) AS ?graphLabel) .
                    BIND (CONCAT(?graphLabel, \" (\", ?ptLabel, \")\") AS ?label) .
                }
                ORDER BY (?label) }'/>
    </swon:Value>
</swon:Object>
"""^^ui:Literal ;
  rdfs:comment """For a given property shape this returns something like

{
	serviceURL: \"...\",
	nodeShapeLabel: (the display label of the node shape),
	graphs: [
		{ uri: \"...\", label: \"...\" },
		...
	]
}

which is enough info for the dialog in ontologyApp.js to continue its job.""" ;
  rdfs:subClassOf ui:JSONServices ;
.
ontologyapp:IndirectPropertySelectors
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:focusNode ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:group let:nodeShape=\"{= spl:subject(sh:property, ?focusNode) }\">
    <ontologyapp:PropertySelector arg:label=\"Property that links to the other objects\" arg:name=\"firstProperty\" arg:nodeShape=\"{= ?nodeShape }\" arg:onChange=\"swa.loadWithResource('load-second', 'firstProperty', selectedProperty)\"/>
    <p/>
    <ui:loadable ui:loadId=\"load-second\" ui:loadOnDemand=\"{= true }\">
        <ui:group let:ns=\"{#
                SELECT ?ns
                WHERE {
                    ?ps sh:path ?firstProperty .
                    ?ps sh:node|sh:class ?ns .
                    ?nodeShape sh:property ?ps .
                } }\">
            <ui:if ui:condition=\"{= bound(?ns) }\">
                <ontologyapp:PropertySelector arg:label=\"Property that holds the values in the other objects\" arg:name=\"secondProperty\" arg:nodeShape=\"{= ?ns }\" arg:onChange=\"swa.setWizardCanFinish(true)\"/>
            </ui:if>
            <ui:else>
                <span class=\"text-danger\">Sorry, no suitable node shape or class found for this property.</span>
            </ui:else>
        </ui:group>
    </ui:loadable>
</ui:group>
"""^^ui:Literal ;
  rdfs:label "Indirect property selectors" ;
  rdfs:subClassOf swa:WizardElements ;
.
ontologyapp:LearnPropertyValuesRule
  a ui:Service ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:graphs ;
      spl:valueType xsd:string ;
      rdfs:comment "A space-separated list of graphs to include." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:maxInstanceCount ;
      spl:valueType xsd:integer ;
      rdfs:comment "The maximum number of instances to send." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:nodeShape ;
      spl:valueType sh:NodeShape ;
      rdfs:comment "The node shape that will receive the new property and rule." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:paths ;
      spl:valueType xsd:string ;
      rdfs:comment "A space-separated list of predicates, possibly starting with ^ for the inverse direction." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:targetPredicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The target predicate that holds the sample result values." ;
    ] ;
  ui:errorPrototype """
<ui:group let:maui=\"{= autotagger:checkMauiServerConnectionProblem() }\">
    <ui:if ui:condition=\"{= ?maui != false }\">
        <swon:Object>
            <swon:Value arg:name=\"error\" arg:value=\"{= ?maui }\"/>
        </swon:Object>
    </ui:if>
</ui:group>
"""^^ui:Literal ;
  ui:private true ;
  ui:prototype """
<swon:Object let:newPredicate=\"{= IRI(CONCAT(str(?targetPredicate), &quot;Suggested&quot;)) }\" let:newPredicateLabel=\"{= swa:propertyLabelAtClassOrShape(?targetPredicate, ?nodeShape) } (suggested)\" let:targetGraph=\"{= ui:currentQueryGraph() }\" letrs:graphs='{#
        SELECT ?graph
        WHERE {
            {
                ?uri spif:split ( ?graphs \" \" ) .
                BIND (ui:graphWithImports(IRI(?uri)) AS ?graph) .
            }
            UNION
            {
                BIND (ui:tempGraph AS ?graph) .
            } .
        } }'>
    <ui:group let:inputShape=\"{= sh:TestShape }\" let:union=\"{= ui:unionOfGraphsFromResultSet(?graphs) }\">
        <ui:setContext ui:queryGraph=\"{= ui:tempGraph }\">
            <ui:update ui:updateQuery=\"{!
                    INSERT {
                        ?inputShape a sh:NodeShape .
                        ?inputShape sh:targetClass ?nodeShape .
                    }
                    WHERE {
                    } }\"/>
            <ui:forEach ui:resultSet='{#
                    SELECT ?p
                    WHERE {
                        {
                            BIND (str(?targetPredicate) AS ?p) .
                        }
                        UNION
                        {
                            ?p spif:split ( ?paths \" \" ) .
                        } .
                    } }'>
                <ui:update ui:updateQuery=\"{!
                        INSERT {
                            ?inputShape sh:property ?ps .
                        }
                        WHERE {
                            GRAPH ?union {
                                ?nodeShape (rdfs:subClassOf)* ?s .
                                ?s sh:property ?ps .
                                ?ps sh:path ?path .
                                FILTER (?path = IRI(?p)) .
                            } .
                        } }\"/>
            </ui:forEach>
        </ui:setContext>
        <ui:setContext let:key=\"learn-{= STRUUID() }\" ui:queryGraph=\"{= ?union }\">
            <sml:CreateWekaClassifier sml:key=\"{= ?key }\" sml:maxInstanceCount=\"{= ?maxInstanceCount }\" sml:predicate=\"{= ?targetPredicate }\" sml:shape=\"{= ?inputShape }\">
                <ui:if ui:condition=\"{= bound(?nodeExpressionError) }\">
                    <swon:Value arg:name=\"error\" arg:value=\"{= ?nodeExpressionError }\"/>
                </ui:if>
                <ui:else>
                    <sml:ConvertTextToRDF sml:replace=\"{= true }\" sml:text=\"{= ?nodeExpressionTTL }\">
                        <ui:update ui:updateQuery=\"{!
                                INSERT {
                                    GRAPH ui:tempGraph2 {
                                        ?s ?p ?o .
                                    } .
                                }
                                WHERE {
                                    ?s ?p ?o .
                                } }\"/>
                    </sml:ConvertTextToRDF>
                    <ui:setContext ui:queryGraph=\"{= ?targetGraph }\" ui:silentTransactions=\"{= true }\">
                        <ui:transaction let:ps=\"{= BNODE() }\" ui:logMessage=\"Learn property values rule for {= ?newPredicateLabel }\">
                            <ui:update ui:updateQuery=\"{!
                                    INSERT {
                                        ?nodeShape sh:property ?ps .
                                        ?ps a sh:PropertyShape .
                                        ?ps sh:path ?newPredicate .
                                        ?ps sh:name ?newPredicateLabel .
                                        ?ps sh:maxCount 1 .
                                    }
                                    WHERE {
                                    } }\"/>
                            <ui:update ui:updateQuery=\"{!
                                    INSERT {
                                        ?newPredicate a rdf:Property .
                                        ?newPredicate rdfs:label ?newPredicateLabel .
                                    }
                                    WHERE {
                                    } }\"/>
                            <ui:update ui:updateQuery=\"{!
                                    INSERT {
                                        ?ps sh:datatype ?datatype .
                                    }
                                    WHERE {
                                        ?nodeShape (rdfs:subClassOf)* ?sh .
                                        ?sh sh:property ?px .
                                        ?px sh:path ?targetPredicate .
                                        ?px sh:datatype ?datatype .
                                    } }\"/>
                            <ui:update ui:updateQuery=\"{!
                                    INSERT {
                                        ?s ?p ?o .
                                    }
                                    WHERE {
                                        GRAPH ui:tempGraph2 {
                                            ?s ?p ?o .
                                        } .
                                    } }\"/>
                            <ui:update ui:updateQuery=\"{!
                                    INSERT {
                                        ?ps sh:values ?root .
                                    }
                                    WHERE {
                                        GRAPH ui:tempGraph2 {
                                            ?root ?p ?o .
                                            FILTER NOT EXISTS {
                                                ?anyone ?anyP ?root .
                                            } .
                                        } .
                                    } }\"/>
                        </ui:transaction>
                    </ui:setContext>
                    <swon:Value arg:name=\"newPredicate\" arg:value=\"{= ?newPredicate }\"/>
                    <swon:Value arg:name=\"newPredicateLabel\" arg:value=\"{= ?newPredicateLabel }\"/>
                </ui:else>
            </sml:CreateWekaClassifier>
            <sml:DeleteWekaClassifier sml:key=\"{= ?key }\"/>
        </ui:setContext>
    </ui:group>
</swon:Object>
"""^^ui:Literal ;
  rdfs:label "Learn property values rule" ;
  rdfs:subClassOf ui:JSONServices ;
.
ontologyapp:LearnPropertyValuesRuleAction
  a swa:ResourceAction ;
  arg:appName "Ontology" ;
  arg:condition [
      a sp:if ;
      sp:arg1 [
          a sp:and ;
          sp:arg1 [
              a sp:and ;
              sp:arg1 [
                  a sp:isIRI ;
                  sp:arg1 [
                      sp:varName "resource" ;
                    ] ;
                ] ;
              sp:arg2 [
                  a spl:instanceOf ;
                  sp:arg1 [
                      sp:varName "resource" ;
                    ] ;
                  sp:arg2 rdfs:Class ;
                ] ;
            ] ;
          sp:arg2 [
              a spl:instanceOf ;
              sp:arg1 [
                  sp:varName "resource" ;
                ] ;
              sp:arg2 sh:NodeShape ;
            ] ;
        ] ;
      sp:arg2 [
          a sp:eq ;
          sp:arg1 [
              a autotagger:checkMauiServerConnectionProblem ;
              sp:arg1 true ;
            ] ;
          sp:arg2 false ;
        ] ;
      sp:arg3 [
          sp:varName "none" ;
        ] ;
    ] ;
  arg:group "form" ;
  arg:onSelect "ontologyapp.openLearnPropertyValuesRuleDialog(resourceURI);" ;
  rdfs:label "Learn property values rule... (EXPERIMENTAL)" ;
.
ontologyapp:MakeShapeClassAction
  a swa:EditHandlerClass ;
  a swa:ResourceAction ;
  arg:appName "Ontology" ;
  arg:condition [
      a sp:if ;
      sp:arg1 [
          a sp:and ;
          sp:arg1 [
              a spl:instanceOf ;
              sp:arg1 [
                  sp:varName "resource" ;
                ] ;
              sp:arg2 rdfs:Class ;
            ] ;
          sp:arg2 [
              a sp:not ;
              sp:arg1 [
                  a spl:instanceOf ;
                  sp:arg1 [
                      sp:varName "resource" ;
                    ] ;
                  sp:arg2 sh:Shape ;
                ] ;
            ] ;
        ] ;
      sp:arg2 true ;
      sp:arg3 [
          sp:varName "none" ;
        ] ;
    ] ;
  arg:group "main" ;
  arg:iconClass "ontologyapp-icon-make-shape-class" ;
  ui:prototype """
<ui:transaction ui:logMessage=\"Enable SHACL constraints for class {= ui:label(?resource) }\">
    <ui:update ui:updateQuery=\"{!
            INSERT {
                ?ontology owl:imports &lt;http://datashapes.org/dash&gt; .
            }
            WHERE {
                FILTER (!tosh:shaclExists()) .
                BIND (teamwork:currentMasterGraph() AS ?ontology) .
            } }\"/>
    <ui:update ui:updateQuery=\"{!
            INSERT {
                ?resource a sh:NodeShape .
            }
            WHERE {
            } }\"/>
</ui:transaction>
"""^^ui:Literal ;
  rdfs:label "Enable SHACL constraints for this class" ;
  rdfs:subClassOf swa:ResourceEditHandlers ;
.
ontologyapp:MakeWikidataLinkAction
  a swa:EditHandlerClass ;
  a swa:ResourceAction ;
  arg:appName "Ontology" ;
  arg:condition [
      a sp:if ;
      sp:arg1 [
          a sp:exists ;
          sp:elements (
              [
                sp:object [
                    sp:varName "resource" ;
                  ] ;
                sp:predicate sh:property ;
                sp:subject [
                    sp:varName "nodeShape" ;
                  ] ;
              ]
              [
                sp:object [
                    sp:varName "path" ;
                  ] ;
                sp:predicate sh:path ;
                sp:subject [
                    sp:varName "resource" ;
                  ] ;
              ]
              [
                a sp:Filter ;
                sp:expression [
                    a sp:notExists ;
                    sp:elements (
                        [
                          sp:object [
                              sp:varName "any" ;
                            ] ;
                          sp:predicate dash:detailsEndpoint ;
                          sp:subject [
                              sp:varName "resource" ;
                            ] ;
                        ]
                      ) ;
                  ] ;
              ]
              [
                a sp:Filter ;
                sp:expression [
                    a sp:isIRI ;
                    sp:arg1 [
                        sp:varName "path" ;
                      ] ;
                  ] ;
              ]
            ) ;
        ] ;
      sp:arg2 true ;
      sp:arg3 [
          sp:varName "none" ;
        ] ;
    ] ;
  arg:group "main" ;
  ui:prototype """
<ui:transaction ui:logMessage=\"Make Wikidata link property\">
    <ui:update ui:updateQuery=\"{!
            INSERT {
                ?resource dash:detailsEndpoint &quot;https://query.wikidata.org/sparql&quot; .
                ?resource sh:nodeKind sh:IRI .
            }
            WHERE {
            } }\"/>
    <ui:setPrefix ui:namespace=\"http://www.wikidata.org/prop/direct/\" ui:prefix=\"wdt\"/>
</ui:transaction>
"""^^ui:Literal ;
  rdfs:label "Make this property a Wikidata link" ;
  rdfs:subClassOf swa:ResourceEditHandlers ;
.
ontologyapp:MaxIndirectValuesRuleWizard
  a ontologyapp:PropertyValueRuleWizard ;
  swa:valueWizardUpdate ontologyapp:MaxIndirectValuesRuleWizardUpdate ;
  ui:private true ;
  ui:prototype """
<ontologyapp:IndirectPropertySelectors arg:focusNode=\"{= ?focusNode }\"/>
"""^^ui:Literal ;
  rdfs:comment "Produces a property value rule that computes the maximum of all values of the values of another property (one hop away). For example if you have a property \"purchase\" that points at instances that have a property \"amount\" then you can compute the maximum of these amounts across all purchases of the current instance." ;
  rdfs:label "Compute maximum of indirect values (one hop away)" ;
  rdfs:subClassOf ontologyapp:PropertyValueRuleWizards ;
.
ontologyapp:MaxIndirectValuesRuleWizardUpdate
  a swa:ValueWizardUpdate ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:firstProperty ;
      spl:valueType rdf:Property ;
      rdfs:comment "The first property." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:secondProperty ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property of which the values are summed up." ;
    ] ;
  ui:mutationFieldName "MaxIndirectValuesRuleWizardUpdate" ;
  ui:private true ;
  ui:prototype """
<ui:transaction ui:logMessage=\"Create property rule to compute maximum of indirect values\">
    <ui:update ui:updateQuery=\"{!
            INSERT {
                ?focusNode sh:values ?max .
                ?max sh:max ?secondPath .
                ?secondPath sh:path ?secondProperty .
                ?secondPath sh:nodes ?firstPath .
                ?firstPath sh:path ?firstProperty .
            }
            WHERE {
                BIND (BNODE() AS ?max) .
                BIND (BNODE() AS ?firstPath) .
                BIND (BNODE() AS ?secondPath) .
            } }\"/>
</ui:transaction>
"""^^ui:Literal ;
  rdfs:subClassOf ontologyapp:PropertyValueRuleWizardUpdates ;
.
ontologyapp:MinIndirectValuesRuleWizard
  a ontologyapp:PropertyValueRuleWizard ;
  swa:valueWizardUpdate ontologyapp:MinIndirectValuesRuleWizardUpdate ;
  ui:private true ;
  ui:prototype """
<ontologyapp:IndirectPropertySelectors arg:focusNode=\"{= ?focusNode }\"/>
"""^^ui:Literal ;
  rdfs:comment "Produces a property value rule that computes the minimum of all values of the values of another property (one hop away). For example if you have a property \"purchase\" that points at instances that have a property \"amount\" then you can compute the minimum of these amounts across all purchases of the current instance." ;
  rdfs:label "Compute minimum of indirect values (one hop away)" ;
  rdfs:subClassOf ontologyapp:PropertyValueRuleWizards ;
.
ontologyapp:MinIndirectValuesRuleWizardUpdate
  a swa:ValueWizardUpdate ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:firstProperty ;
      spl:valueType rdf:Property ;
      rdfs:comment "The first property." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:secondProperty ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property of which the values are summed up." ;
    ] ;
  ui:mutationFieldName "MinIndirectValuesRuleWizardUpdate" ;
  ui:private true ;
  ui:prototype """
<ui:transaction ui:logMessage=\"Create property rule to compute minimum of indirect values\">
    <ui:update ui:updateQuery=\"{!
            INSERT {
                ?focusNode sh:values ?min .
                ?min sh:min ?secondPath .
                ?secondPath sh:path ?secondProperty .
                ?secondPath sh:nodes ?firstPath .
                ?firstPath sh:path ?firstProperty .
            }
            WHERE {
                BIND (BNODE() AS ?min) .
                BIND (BNODE() AS ?firstPath) .
                BIND (BNODE() AS ?secondPath) .
            } }\"/>
</ui:transaction>
"""^^ui:Literal ;
  rdfs:subClassOf ontologyapp:PropertyValueRuleWizardUpdates ;
.
ontologyapp:OpenSearchDialogAction
  a swa:SearchResultsAction ;
  arg:appName "Ontology" ;
  arg:condition true ;
  arg:onSelect "swa.openDerivedSearchDialog(formId, 'org.ontologyapp.instanceSelected')" ;
  rdfs:label "Open search window..." ;
.
ontologyapp:PropertySelector
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:label ;
      spl:valueType xsd:string ;
      rdfs:comment "The display label of the select field." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:name ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the resulting field - must match an argument of the update." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:nodeShape ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The parent node shape." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:onChange ;
      spl:valueType xsd:string ;
      rdfs:comment "JS to execute when the property is selected." ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:group let:id=\"{= ui:uniqueId() }\">
    <div class=\"form-group\">
        <label for=\"{= ?id }\">{= ?label }</label>
        <br/>
        <select class=\"value-wizard-input form-control\" id=\"{= ?id }\" name=\"{= ?name }\">
            <option disabled=\"disabled\" selected=\"selected\"/>
            <ui:forEach ui:resultSet=\"{#
                    SELECT DISTINCT ?path ?pathLabel
                    WHERE {
                        ?nodeShape (rdfs:subClassOf)* ?ns .
                        ?ns sh:property ?ps .
                        ?ps sh:path ?path .
                        FILTER isIRI(?path) .
                        BIND (swa:propertyLabelAtClassOrShape(?path, ?nodeShape) AS ?pathLabel) .
                    }
                    ORDER BY (?pathLabel) }\">
                <option value=\"{= ?path }\">{= ?pathLabel }</option>
            </ui:forEach>
        </select>
    </div>
    <script>$('#{= ?id }').change(function() {
			var selectedProperty = $(this).val();
			if(selectedProperty) {
				{= ?onChange } 
			}
			else {
				swa.setWizardCanFinish(false);
			}
		});</script>
</ui:group>
"""^^ui:Literal ;
  rdfs:label "Property selector" ;
  rdfs:subClassOf swa:WizardElements ;
.
ontologyapp:PropertyValueRuleWizard
  a rdfs:Class ;
  a sh:NodeShape ;
  rdfs:comment "This wizard can produce a SHACL property value rule (using sh:values) based on some common design patterns." ;
  rdfs:label "Create Property Value Rule" ;
  rdfs:subClassOf swa:ValueWizard ;
.
ontologyapp:PropertyValueRuleWizardAction
  a swa:ResourceAction ;
  arg:appName "Ontology" ;
  arg:condition [
      a sp:if ;
      sp:arg1 [
          a teamwork:isPropertyValueRuleWizardSuitable ;
          arg:resource [
              sp:varName "resource" ;
            ] ;
        ] ;
      sp:arg2 true ;
      sp:arg3 [
          sp:varName "none" ;
        ] ;
    ] ;
  arg:group "wizard" ;
  arg:onSelect "swa.openWizardDialog('http://topbraid.org/swa/ontologyapp#PropertyValueRuleWizard', '<' + resourceURI + '>');" ;
  rdfs:label "Create property value rule from template..." ;
.
ontologyapp:PropertyValueRuleWizardUpdates
  a swa:ValueWizardUpdate ;
  ui:abstract true ;
  rdfs:label "Property value rule wizard updates" ;
  rdfs:subClassOf swa:ValueWizardUpdates ;
.
ontologyapp:PropertyValueRuleWizards
  a ontologyapp:PropertyValueRuleWizard ;
  ui:abstract true ;
  rdfs:comment "Base class of wizards that produce a sh:values node (structure) for a given property shape." ;
  rdfs:label "Property value rule wizards" ;
  rdfs:subClassOf swa:ValueWizards ;
.
ontologyapp:Script
  a ui:Script ;
  rdfs:label "Script" ;
  rdfs:subClassOf ui:Scripts ;
.
ontologyapp:Style
  a ui:Style ;
  ui:prototype """
<link href=\"{= ui:lib() }/ontologyapp/css/ontologyapp.css\" rel=\"stylesheet\" type=\"text/css\"/>
"""^^ui:Literal ;
  rdfs:label "Style" ;
  rdfs:subClassOf ui:Styles ;
.
ontologyapp:SumIndirectValuesRuleWizard
  a ontologyapp:PropertyValueRuleWizard ;
  swa:valueWizardUpdate ontologyapp:SumIndirectValuesRuleWizardUpdate ;
  ui:private true ;
  ui:prototype """
<ontologyapp:IndirectPropertySelectors arg:focusNode=\"{= ?focusNode }\"/>
"""^^ui:Literal ;
  rdfs:comment "Produces a property value rule that computes the sum of all values of the values of another property (one hop away). For example if you have a property \"purchase\" that points at instances that have a property \"amount\" then you can compute the sum of these amounts across all purchases of the current instance." ;
  rdfs:label "Compute sum of indirect values (one hop away)" ;
  rdfs:subClassOf ontologyapp:PropertyValueRuleWizards ;
.
ontologyapp:SumIndirectValuesRuleWizardUpdate
  a swa:ValueWizardUpdate ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:firstProperty ;
      spl:valueType rdf:Property ;
      rdfs:comment "The first property." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:secondProperty ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property of which the values are summed up." ;
    ] ;
  ui:mutationFieldName "SumIndirectValuesRuleWizardUpdate" ;
  ui:private true ;
  ui:prototype """
<ui:transaction ui:logMessage=\"Create property rule to sum indirect values\">
    <ui:update ui:updateQuery=\"{!
            INSERT {
                ?focusNode sh:values ?sum .
                ?sum sh:sum ?secondPath .
                ?secondPath sh:path ?secondProperty .
                ?secondPath sh:nodes ?firstPath .
                ?firstPath sh:path ?firstProperty .
            }
            WHERE {
                BIND (BNODE() AS ?sum) .
                BIND (BNODE() AS ?firstPath) .
                BIND (BNODE() AS ?secondPath) .
            } }\"/>
</ui:transaction>
"""^^ui:Literal ;
  rdfs:subClassOf ontologyapp:PropertyValueRuleWizardUpdates ;
.
ontologyapp:canLinkBNodeFunction
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            a sp:TriplePath ;
            sp:object [
                sp:varName "node" ;
              ] ;
            sp:path [
                a sp:AltPath ;
                sp:path1 sh:property ;
                sp:path2 sh:parameter ;
              ] ;
            sp:subject [
                sp:varName "shape" ;
              ] ;
          ]
        ) ;
    ] ;
  rdfs:comment "Allows links to be produced for values of predicates such as sh:property." ;
  rdfs:subClassOf swa:CanLinkBNodeFunctions ;
.
rdf:Property
  ui:instanceView """
<teamwork:SimplePropertyFormBody arg:resource=\"{= ?this }\" ui:id=\"form\" ui:priority=\"{= IF(swa:hasCurrentAppName(&quot;Ontology&quot;), 0, ?none) }\"/>
"""^^ui:Literal ;
.
owl:DatatypeProperty
  ui:instanceView """
<teamwork:SimpleDatatypePropertyFormBody arg:resource=\"{= ?this }\" ui:id=\"form\" ui:priority=\"{= IF(swa:hasCurrentAppName(&quot;Ontology&quot;), 0, ?none) }\"/>
"""^^ui:Literal ;
.
owl:Thing
  ui:instanceView """
<div ui:id=\"details\" ui:priority=\"{= IF(swa:hasCurrentAppName(&quot;Ontology&quot;), 0, ?none) }\">
    <teamwork:ExpandableSectionContainer arg:additionalClasses=\"property-group-container\" arg:headingLabel=\"Metadata\">
        <teamwork:SimpleResourceFormBody arg:resource=\"{= ?this }\"/>
    </teamwork:ExpandableSectionContainer>
</div>
"""^^ui:Literal ;
.
sh:NodeShape
  ui:instanceView """
<teamwork:NodeShapeFormBody arg:resource=\"{= ?this }\" ui:id=\"form\" ui:priority=\"{= 0 }\"/>
"""^^ui:Literal ;
.
