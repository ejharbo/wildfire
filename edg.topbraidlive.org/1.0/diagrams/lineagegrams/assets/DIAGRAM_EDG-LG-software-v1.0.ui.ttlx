# baseURI: http://edg.topbraid.solutions/1.0/diagram/lg/software
# imports: http://edg.topbraid.solutions/1.0/diagram/lg/data-asset
# imports: http://edg.topbraid.solutions/1.0/diagram/lg/library-common
# imports: http://edg.topbraid.solutions/1.0/schema/lineage-models
# imports: http://edg.topbraid.solutions/1.0/schema/technical-assets
# imports: http://edg.topbraid.solutions/1.0/spin/jsfunctions
# imports: http://edg.topbraid.solutions/1.0/spin/library
# imports: http://spinrdf.org/spinx
# imports: http://topbraid.org/swa
# imports: http://topbraid.org/teamwork.ui

@prefix acjob: <http://evn.topbraidlive.org/tagger/acjob#> .
@prefix acpp: <http://topbraid.org/nlp/autoclassifier-preproc#> .
@prefix adminguide: <http://server.topbraidlive.org/doc/adminguide#> .
@prefix afn: <http://jena.hpl.hp.com/ARQ/function#> .
@prefix arg: <http://spinrdf.org/arg#> .
@prefix autotagger: <http://evn.topbraidlive.org/autotagger#> .
@prefix cfg: <http://server.topbraidlive.org/web/2009/config#> .
@prefix charts: <http://uispin.org/charts#> .
@prefix compliance: <http://topbraid.org/compliance#> .
@prefix composite: <http://www.topbraid.org/2007/05/composite.owl#> .
@prefix conceptmatch: <http://topbraid.org/conceptmatch#> .
@prefix config: <http://server.topbraidlive.org/dynamic/config#> .
@prefix config-importers: <http://edg.topbraidlive.org/config/importers#> .
@prefix contact: <http://www.w3.org/2000/10/swap/pim/contact#> .
@prefix core-soa: <http://www.semanticweb.org/ontologies/2010/01/core-soa.owl#> .
@prefix corpus: <http://topbraid.org/corpus#> .
@prefix corpusprojects: <http://topbraid.org/corpus-projects#> .
@prefix crosswalk: <http://topbraid.org/crosswalk#> .
@prefix crosswalk.spin: <http://topbraid.org/crosswalk.spin#> .
@prefix crosswalkapp: <http://topbraid.org/swa/crosswalkapp#> .
@prefix crosswalkprojects: <http://teamwork.topbraidlive.org/crosswalkprojects#> .
@prefix css: <http://uispin.org/css#> .
@prefix daml: <http://www.daml.org/2001/03/daml+oil#> .
@prefix dash: <http://datashapes.org/dash#> .
@prefix dashboard: <http://example.org/dashboard#> .
@prefix datagraph: <http://teamwork.topbraidlive.org/datagraph/datagraphprojects#> .
@prefix dataset: <http://teamwork.topbraidlive.org/dataset#> .
@prefix datasetapp: <http://topbraid.org/swa/datasetapp#> .
@prefix datasetviewer: <http://topbraid.org/swa/datasetviewer#> .
@prefix datatype: <http://qudt.org/vocab/datatype/> .
@prefix dc: <http://purl.org/dc/elements/1.1/> .
@prefix dcam: <http://purl.org/dc/dcam/> .
@prefix dcterms: <http://purl.org/dc/terms/> .
@prefix ddl: <http://edg.topbraidlive.org/1.0/importers/ddl#> .
@prefix debug-swa: <http://debug.topbraidlive.org/1.0/swa/> .
@prefix default: <http://uispin.org/default#> .
@prefix defaultapp: <http://topbraid.org/swa/defaultapp#> .
@prefix deployProjectToServer: <http://server.topbraidlive.org/doc/deployProjectToServer#> .
@prefix devguide: <http://evn.topbraidlive.org/evndoc.www/devguide#> .
@prefix doap: <http://usefulinc.com/ns/doap#> .
@prefix doc: <http://www.w3.org/2000/10/swap/pim/doc#> .
@prefix document: <http://topbraid.org/document#> .
@prefix documents: <http://edg.topbraid.solutions/1.0/shapes/documents#> .
@prefix dtype: <http://www.linkedmodel.org/schema/dtype#> .
@prefix edg: <http://edg.topbraid.solutions/model/> .
@prefix edg-config: <http://edg.ext.topbraidlive.org/schema/config/importers#> .
@prefix edg-importer: <http://edg.topbraidlive.org/importer/> .
@prefix edg-qa: <http://edg.topbraidlive.org/utility/qa/> .
@prefix edg.c: <http://edg.topbraid.solutions/controller/> .
@prefix edg.global: <urn:x-evn-global:> .
@prefix edg.glossary: <http://edg.topbraid.solutions/glossary/> .
@prefix edg.sqoop: <http://edg.topbraid.solutions/model/sqoop/> .
@prefix edg.v: <http://edg.topbraid.solutions/view/> .
@prefix edgproduct: <http://edg.topbraidlive.org/edgproduct#> .
@prefix eeh-lib: <http://www.environmenthub.no/spin/1.0/eeh-lib#> .
@prefix eeh-reportlib: <http://www.environmenthub.no/spin/1.0/eeh-reportlib#> .
@prefix elements: <http://purl.org/dc/elements/1.1/> .
@prefix email: <http://topbraid.org/email#> .
@prefix evn: <http://topbraid.org/evn/evn#> .
@prefix evnAdminIndex: <http://evn.topbraidlive.org/evnAdminIndex#> .
@prefix evnIntro: <http://evn.topbraidlive.org/evndoc.www/evnIntro#> .
@prefix evndoc: <http://evn.topbraidlive.org/evndoc.www/evndoc#> .
@prefix evnimport: <http://evn.topbraidlive.org/uispin/evnimport#> .
@prefix evninstallguide: <http://teamwork.topbraidlive.org/doc/evninstallguide#> .
@prefix evnui: <http://evn.topbraidlive.org/ui#> .
@prefix ex: <http://example.org/> .
@prefix extjs: <http://uispin.com/extjs#> .
@prefix flow: <http://www.w3.org/2005/01/wf/flow#> .
@prefix fn: <http://www.w3.org/2005/xpath-functions#> .
@prefix foaf: <http://xmlns.com/foaf/0.1/> .
@prefix formTemplate: <http://teamwork.topbraidlive.org/system/formTemplate#> .
@prefix forms: <http://www.topbraid.org/2007/01/forms.owl#> .
@prefix frbr: <http://purl.org/vocab/frbr/core#> .
@prefix geo: <http://www.w3.org/2003/01/geo/wgs84_pos#> .
@prefix gettingstarted: <http://evn.topbraidlive.org/evndoc.www/gettingstarted#> .
@prefix glossary: <http://evn.topbraidlive.org/evndoc.www/glossary#> .
@prefix governance: <http://topbraid.org/teamworkgovernance.ui#> .
@prefix gr: <http://purl.org/goodrelations/v1#> .
@prefix graphql: <http://datashapes.org/graphql#> .
@prefix graphql.search: <http://teamwork.topbraidlive.org/graphql.search#> .
@prefix html: <http://uispin.org/html#> .
@prefix imported: <http://topbraid.org/imported#> .
@prefix inference: <http://www.topbraid.org/2007/06/inference.owl#> .
@prefix jdbc: <http://edg.topbraidlive.org/1.0/importers/jdbc#> .
@prefix json: <http://topbraid.org/json#> .
@prefix kennedys: <http://topbraid.org/examples/kennedys#> .
@prefix let: <http://uispin.org/let#> .
@prefix letrs: <http://uispin.org/letrs#> .
@prefix lib-importer: <http://edg.topbraid.solutions/importer/lib#> .
@prefix lineage-transform: <http://edg.topbraid.solutions/transform/importer/lineage#> .
@prefix list: <http://jena.hpl.hp.com/ARQ/list#> .
@prefix log: <http://www.w3.org/2000/10/swap/log#> .
@prefix metadata: <http://topbraid.org/metadata#> .
@prefix o2o: <http://lib.topquadrant.com/owl/srg/o2o#> .
@prefix ontologyprojects: <http://teamwork.topbraidlive.org/ontologyprojects#> .
@prefix ontologyviewer: <http://topbraid.org/swa/ontologyviewer#> .
@prefix org: <http://www.w3.org/ns/org#> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix permissionGroupMgmt: <http://server.topbraidlive.org/doc/permissionGroupMgmt#> .
@prefix pg: <http://server.topbraidlive.org/web/2013/permissiongroups#> .
@prefix prov: <http://www.w3.org/ns/prov#> .
@prefix provo: <http://www.w3.org/ns/prov#> .
@prefix proxy-lineage: <http://edg.topbraid.solutions/proxy/importer/lineage#> .
@prefix quantity: <http://qudt.org/vocab/quantity/> .
@prefix qudd: <http://qudt.org/schema/datastructure/> .
@prefix quds: <http://qudt.org/schema/datastructure/> .
@prefix qudt: <http://qudt.org/schema/qudt/> .
@prefix qudt-refdata: <http://qudt.org/vocab/refdata/> .
@prefix qudt.type: <http://qudt.org/vocab/type/> .
@prefix raci: <http://topbraid.org/raci#> .
@prefix raci.spin: <http://topbraid.org/raci.spin#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix rdm: <http://rdm.topbraidlive.org/rdm/> .
@prefix rdmapp: <http://rdm.topbraidlive.org/rdmapp#> .
@prefix rdmfact: <http://topbraid.org/rdmfact#> .
@prefix rdmprojects: <http://rdm.topbraidlive.org/rdmprojects#> .
@prefix rdmviewer: <http://rdm.topbraidlive.org/rdmviewer#> .
@prefix saf: <http://topbraid.org/saf/> .
@prefix safconfig: <http://topbraid.org/safconfig/> .
@prefix safindex: <http://topbraid.org/safindex#> .
@prefix safm: <http://saf.topbraidlive.org/metaschema/> .
@prefix savedQueries: <http://teamwork.topbraidlive.org/ui/savedQueries#> .
@prefix scheduler: <http://topbraid.org/scheduler#> .
@prefix sd: <http://www.w3.org/ns/sparql-service-description#> .
@prefix search: <http://topbraid.org/search#> .
@prefix search.spin: <http://topbraid.org/search.spin#> .
@prefix server: <http://server.topbraidlive.org/server.ui#> .
@prefix sh: <http://www.w3.org/ns/shacl#> .
@prefix shapesgraph: <http://teamwork.topbraidlive.org/shapesgraph/shapesgraphprojects#> .
@prefix sharepoint: <http://topbraid.org/sharepoint#> .
@prefix sharepoint.spin: <http://topbraid.org/sharepoint.spin#> .
@prefix sioc: <http://rdfs.org/sioc/ns#> .
@prefix skos: <http://www.w3.org/2004/02/skos/core#> .
@prefix skosapp: <http://evn.topbraidlive.org/uiplugins#> .
@prefix skosshapes: <http://topbraid.org/skos.shapes#> .
@prefix skostemplate: <http://topbraid.org/spin/skostemplates#> .
@prefix skosxl: <http://www.w3.org/2008/05/skos-xl#> .
@prefix sm: <http://topbraid.org/sparqlmotion#> .
@prefix smf: <http://topbraid.org/sparqlmotionfunctions#> .
@prefix sml: <http://topbraid.org/sparqlmotionlib#> .
@prefix soa: <http://www.semanticweb.org/ontologies/2010/01/core-soa.owl#> .
@prefix softwareprojects: <http://teamwork.topbraidlive.org/software/softwareprojects#> .
@prefix solr: <http://topbraid.org/solr#> .
@prefix sp: <http://spinrdf.org/sp#> .
@prefix sparql: <http://datashapes.org/sparql#> .
@prefix sparqlmotionlib-swp: <http://topbraid.org/sparqlmotionlib-swp#> .
@prefix sparqlmotionlib-tbc: <http://topbraid.org/sparqlmotionlib-tbc#> .
@prefix spell: <http://topbraid.org/spellcheckresults#> .
@prefix spif: <http://spinrdf.org/spif#> .
@prefix spin: <http://spinrdf.org/spin#> .
@prefix spin.ui: <http://spinrdf.org/spin.ui#> .
@prefix spinmap: <http://spinrdf.org/spinmap#> .
@prefix spinmapl: <http://topbraid.org/spin/spinmapl#> .
@prefix spinx: <http://spinrdf.org/spinx#> .
@prefix spl: <http://spinrdf.org/spl#> .
@prefix spl-dynamic-ranges: <http://spinrdf.org/spl-dynamic-ranges#> .
@prefix spr: <http://spinrdf.org/spr#> .
@prefix spra: <http://spinrdf.org/spra#> .
@prefix ss: <http://www.topbraidcomposer.org/owl/2006/08/spreadsheets.owl#> .
@prefix stats: <http://topbraid.org/statistics#> .
@prefix status: <http://topbraid.org/status#> .
@prefix style: <http://uispin.org/style#> .
@prefix svg: <http://uispin.org/svg#> .
@prefix swa: <http://topbraid.org/swa#> .
@prefix swaclasses: <http://topbraid.org/swaclasses#> .
@prefix swadoc: <http://topbraid.org/swadoc#> .
@prefix swaeditor: <http://topbraid.org/swaeditor#> .
@prefix swaowl: <http://topbraid.org/swaowl#> .
@prefix swash: <http://topbraid.org/swash#> .
@prefix swashacl: <http://topbraid.org/swashacl#> .
@prefix swauml: <http://topbraid.org/swauml#> .
@prefix swon: <http://uispin.org/swon#> .
@prefix sxml: <http://topbraid.org/sxml#> .
@prefix tables: <http://topbraid.org/tables#> .
@prefix tablesmap: <http://topbraid.org/spin/tablesmap#> .
@prefix tagger: <http://evn.topbraidlive.org/tagger#> .
@prefix taggerprojects: <http://evn.topbraidlive.org/taggerprojects#> .
@prefix taggerspin: <http://evn.topbraidlive.org/taggerspin#> .
@prefix taggerui: <http://evn.topbraidlive.org/taggerui#> .
@prefix task: <http://topbraid.org/task#> .
@prefix tasks: <http://topbraid.org/tasks#> .
@prefix tasks.spin: <http://topbraid.org/tasks.spin#> .
@prefix taxonomies: <http://evn.topbraidlive.org/evnprojects#> .
@prefix tbl: <http://topbraidlive.org/functions#> .
@prefix tbladmin: <http://server.topbraidlive.org/system-applications/tbladmin#> .
@prefix tbladmindoc: <http://server.topbraidlive.org/doc/adminguide#> .
@prefix tblinstallguide: <http://server.topbraidlive.org/doc/tblinstallguide#> .
@prefix tblui: <http://server.topbraidlive.org/tblui#> .
@prefix teaminstallsec: <http://teamwork.topbraidlive.org/doc/teamworkInstallGuideSections#> .
@prefix teamwork: <http://topbraid.org/teamwork#> .
@prefix teamworkAdmin: <http://teamwork.topbraidlive.org/doc/teamworkAdmin#> .
@prefix teamworkconfig: <http://server.topbraidlive.org/system-applications/teamworkconfig#> .
@prefix teamworkconstraints: <http://topbraid.org/teamworkconstraints#> .
@prefix teamworkdashboard: <http://topbraid.org/teamworkdashboard#> .
@prefix teamworknotifications: <http://topbraid.org/teamworknotifications#> .
@prefix teamworkrules: <http://topbraid.org/teamworkrules#> .
@prefix teamworkscripts: <http://topbraid.org/teamworkscripts#> .
@prefix teamworkupdate: <http://teamworkAPI.topbraid.com/teamworkUpdate#> .
@prefix textindex: <http://topbraid.org/textindex#> .
@prefix tika-importer: <http://teamwork.topbraidlive.org/corpus/tika-importer#> .
@prefix tops: <http://www.topbraid.org/tops#> .
@prefix tosh: <http://topbraid.org/tosh#> .
@prefix tosh.ui: <http://topbraid.org/tosh.ui#> .
@prefix tracker: <http://teamwork.topbraidlive.org/ui/tracker#> .
@prefix ui: <http://uispin.org/ui#> .
@prefix uitest: <http://uispin.org/test#> .
@prefix uix: <http://topbraidlive.org/uix#> .
@prefix unit: <http://qudt.org/vocab/unit/> .
@prefix userAdminIndex: <http://evn.topbraidlive.org/userAdminIndex#> .
@prefix userIndex: <http://evn.topbraidlive.org/evndoc.www/userIndex#> .
@prefix userdat: <http://teamwork.topbraidlive.org/ui/userdata> .
@prefix userdata: <http://teamwork.topbraidlive.org/ui/userdata#> .
@prefix usingtagger: <http://evn.topbraidlive.org/taggerdoc.www/usingtagger#> .
@prefix vaem: <http://www.linkedmodel.org/schema/vaem#> .
@prefix victory: <http://edg.topbraid.solutions/victory/> .
@prefix visual: <http://topbraid.org/visual#> .
@prefix voag: <http://voag.linkedmodel.org/voag/> .
@prefix vs: <http://www.w3.org/2003/06/sw-vocab-status/ns#> .
@prefix wf: <http://www.w3.org/2005/01/wf/flow#> .
@prefix wot: <http://xmlns.com/wot/0.1/> .
@prefix xhtml: <http://topbraid.org/xhtml#> .
@prefix xlink: <http://www.w3.org/1999/xlink#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

<http://edg.topbraid.solutions/1.0/diagram/lg/software>
  a owl:Ontology ;
  owl:imports <http://edg.topbraid.solutions/1.0/diagram/lg/data-asset> ;
  owl:imports <http://edg.topbraid.solutions/1.0/diagram/lg/library-common> ;
  owl:imports <http://edg.topbraid.solutions/1.0/schema/lineage-models> ;
  owl:imports <http://edg.topbraid.solutions/1.0/schema/technical-assets> ;
  owl:imports <http://edg.topbraid.solutions/1.0/spin/jsfunctions> ;
  owl:imports <http://edg.topbraid.solutions/1.0/spin/library> ;
  owl:imports <http://spinrdf.org/spinx> ;
  owl:imports <http://topbraid.org/swa> ;
  owl:imports <http://topbraid.org/teamwork.ui> ;
  owl:versionInfo "Created with TBC" ;
.
edg:BuildJSONforBusinessApplicationDownstreamTraceabilityDiagram
  a ui:Service ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate edg:breadth ;
      spl:valueType xsd:integer ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate edg:offset ;
      spl:valueType xsd:integer ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate edg:reach ;
      spl:valueType xsd:integer ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:focusNode ;
      spl:valueType xsd:string ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:graph ;
      spl:valueType rdfs:Resource ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:group let:dataGraph=\"{= IRI(?graph) }\" let:myBreadth=\"{= COALESCE(?breadth, 4) }\" let:myFocusNode=\"{= IRI(spif:decodeURL(?focusNode)) }\" let:myOffset=\"{= COALESCE(?offset, 0) }\" let:myReach=\"{= COALESCE(?reach, 3) }\">
    <ui:try>
        <ui:if ui:condition=\"{= !bound(?dataGraph) }\">
            <ui:throw ui:message=\"No data graph provided\"/>
        </ui:if>
        <ui:if ui:condition=\"{= !bound(?myFocusNode) }\">
            <ui:throw ui:message=\"No lineage model specified\"/>
        </ui:if>
        <ui:setContext ui:queryGraph=\"{= ui:graphWithImports(?dataGraph) }\">
            <ui:setContext ui:queryGraph=\"{= ui:unionGraph }\">
                <ui:group let:depictedResourceForFocusNode=\"{= edg:highestDepictionForSoftwareExecutable(?myFocusNode) }\">
                    <edg:MakeSingleViewFrameResourceOccurrence edg:resource=\"{= ?myFocusNode }\" edg:viewFrame=\"{= edg:VF_SourceFrame }\"/>
                    <edg:BuildSoftwareExecutableEnablements arg:resource=\"{= ?depictedResourceForFocusNode }\" arg:reverseNodes=\"{= true }\" edg:activeResource=\"{= ?myFocusNode }\" edg:breadth=\"{= ?lineageBreadth }\" edg:offset=\"{= ?myOffset }\" edg:sourceViewFrame=\"{= edg:VF_SourceFrame }\"/>
                    <ui:call arg:software=\"{= ?myFocusNode }\" ui:template=\"{= edg:GetSoftwareExecutableEnterpriseWorkProductOutputs }\" ui:varName=\"outputs\">
                        <edg:MakeLineageGramNodeAndLinksForInformationAssets arg:resource=\"{= ?myFocusNode }\" arg:resultSet=\"{= ?outputs }\" edg:sourceViewFrame=\"{= edg:VF_SourceFrame }\" edg:targetViewFrame=\"{= edg:VF_InfoAssetsFrame }\"/>
                    </ui:call>
                    <edg:DetermineTransitiveDownstreamSoftwareExecutableDependencies arg:traceabilityTemplate=\"{= edg:GetDownstreamDependents }\" edg:activeResource=\"{= ?myFocusNode }\" edg:breadth=\"{= ?myBreadth }\" edg:offset=\"{= ?myOffset }\" edg:reach=\"{= ?myReach }\" edg:sourceViewFrame=\"{= edg:VF_SourceFrame }\"/>
                    <edg:MakeResourceNodesAndLinksForLastStageSoftwareExecutableOutputs arg:focusNode=\"{= ?myFocusNode }\" edg:breadth=\"{= ?myBreadth }\" edg:maxTierNodeCount=\"{= ?myMaxTierNodeCount }\" edg:offset=\"{= ?myOffset }\" edg:reach=\"{= ?myReach }\" edg:viewFrameStructure=\"{= edg:VFS_LG-ProvenanceModel }\"/>
                    <edg:GenerateJSONforLineageGram arg:diagramType=\"{= edg:DIAGTYPE_DOWNSTREAM-IMPACTGRAM }\" arg:focusNode=\"{= ?depictedResource }\" edg:activeResource=\"{= ?myFocusNode }\" edg:resource=\"{= ?depictedResourceForFocusNode }\"/>
                </ui:group>
            </ui:setContext>
        </ui:setContext>
        <edg:DumpTempGraphForLineageGram/>
    </ui:try>
    <ui:catch>
        <swon:Object>
            <swon:Value arg:name=\"exception\" arg:value=\"{= ?exception }\"/>
        </swon:Object>
    </ui:catch>
</ui:group>
"""^^ui:Literal ;
  ui:responseType ui:JSON ;
  rdfs:comment "Builds a dependency map showing downstream dependencies of a business application" ;
  rdfs:label "Build JSON for business application downstream traceability diagram" ;
.
edg:BuildJSONforBusinessApplicationNode
  a ui:Service ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:parent ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:node ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:private true ;
  ui:private true ;
  ui:prototype """
<ui:group let:ultimateParent=\"{= ?parent }\">
    <ui:group let:server=\"{= spl:object(?node, edg:hostedOn) }\">
        <ui:if ui:condition=\"{= bound(?server) }\">
            <edg:BuildJSONforLineageGramNode arg:label=\"{= ui:label(?server) }\" arg:node=\"{= ?server }\"/>
            <edg:MakeDerivationMapLink arg:id=\"{= CONCAT(str(?node), &quot;~~&quot;, str(?server)) }\" arg:label=\"{= ui:label(edg:hostedOn) }\" edg:source=\"{= str(?node) }\" edg:target=\"{= str(?server) }\"/>
        </ui:if>
        <edg:BuildJSONforLineageGramNode arg:label=\"{= ui:label(?node) }\" arg:node=\"{= ?node }\" arg:parent=\"{= ?ultimateParent }\"/>
    </ui:group>
</ui:group>
"""^^ui:Literal ;
  ui:responseType ui:JSON ;
  rdfs:isDefinedBy <http://edg.topbraid.solutions/1.0/diagram/lg/software> ;
  rdfs:label "Build JSON for business application node" ;
  rdfs:subClassOf edg:DerivationMapServicesForCompositeNodes ;
.
edg:BuildJSONforDerivationMapNodePair
  a ui:Service ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:inverse ;
      spl:valueType xsd:boolean ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:label ;
      spl:valueType xsd:string ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:property ;
      spl:valueType rdf:Property ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:leftNode ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:rightNode ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:private true ;
  ui:private true ;
  ui:prototype """
<ui:group let:myLabel=\"{= COALESCE(?label, ui:label(?property)) }\">
    <swon:Object>
        <swon:Value arg:name=\"nodes\">
            <swon:Array>
                <ui:resourceView ui:matchIds=\"derivation-map-composite-node\" ui:resource=\"{= ?leftNode }\"/>
                <ui:resourceView ui:matchIds=\"derivation-map-composite-node\" ui:resource=\"{= ?rightNode }\"/>
            </swon:Array>
        </swon:Value>
        <swon:Value arg:name=\"edges\">
            <swon:Array>
                <ui:if ui:condition=\"{= bound(?inverse) &amp;&amp; (?inverse = true) }\">
                    <edg:BuildJSONforDerviationMapLink arg:label=\"{= ?myLabel }\" arg:leftNode=\"{= ?rightNode }\" arg:property=\"{= ?property }\" arg:rightNode=\"{= ?leftNode }\"/>
                </ui:if>
                <ui:else>
                    <edg:BuildJSONforDerviationMapLink arg:label=\"{= ?myLabel }\" arg:leftNode=\"{= ?leftNode }\" arg:property=\"{= ?property }\" arg:rightNode=\"{= ?rightNode }\"/>
                </ui:else>
                <ui:call ui:template=\"{= edg:GetLinksFromDerivationMapGraph }\" ui:varName=\"links\">
                    <ui:forEach ui:resultSet=\"{= ?links }\">
                        <swon:Object>
                            <swon:Value arg:name=\"id\" arg:value=\"{= ?linkId }\"/>
                            <ui:if ui:condition=\"{= bound(?label) &amp;&amp; (?label != &quot;&quot;) }\">
                                <swon:Value arg:name=\"label\" arg:value=\"{= ?label }\"/>
                            </ui:if>
                            <swon:Value arg:name=\"source\" arg:value=\"{= ?sourceId }\"/>
                            <swon:Value arg:name=\"target\" arg:value=\"{= ?targetId }\"/>
                        </swon:Object>
                    </ui:forEach>
                </ui:call>
            </swon:Array>
        </swon:Value>
    </swon:Object>
</ui:group>
"""^^ui:Literal ;
  rdfs:isDefinedBy <http://edg.topbraid.solutions/1.0/diagram/lg/library-common> ;
  rdfs:label "Build JSON for derivaiton map node pair" ;
  rdfs:subClassOf edg:DerivationMapServices ;
.
edg:BuildJSONforDerivationMapNodeTrio
  a ui:Service ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:inverse ;
      spl:valueType xsd:boolean ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:label ;
      spl:valueType xsd:string ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:property ;
      spl:valueType rdf:Property ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:centralNode ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:leftNode ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:rightNode ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:private true ;
  ui:private true ;
  ui:prototype """
<ui:group let:myLabel=\"{= COALESCE(?label, ui:label(?property)) }\">
    <swon:Object>
        <swon:Value arg:name=\"nodes\">
            <swon:Array>
                <ui:resourceView ui:matchIds=\"derivation-map-composite-node\" ui:resource=\"{= ?leftNode }\"/>
                <ui:resourceView ui:matchIds=\"derivation-map-composite-node\" ui:resource=\"{= ?rightNode }\"/>
                <ui:resourceView ui:matchIds=\"derivation-map-composite-node\" ui:resource=\"{= ?centralNode }\"/>
            </swon:Array>
        </swon:Value>
        <swon:Value arg:name=\"edges\">
            <swon:Array>
                <ui:if ui:condition=\"{= bound(?inverse) &amp;&amp; (?inverse = true) }\">
                    <edg:BuildJSONforDerviationMapLink arg:label=\"{= ?myLabel }\" arg:leftNode=\"{= ?rightNode }\" arg:property=\"{= ?property }\" arg:rightNode=\"{= ?leftNode }\"/>
                </ui:if>
                <ui:else>
                    <edg:BuildJSONforDerviationMapLink arg:label=\"{= ?myLabel }\" arg:leftNode=\"{= ?leftNode }\" arg:property=\"{= ?property }\" arg:rightNode=\"{= ?rightNode }\"/>
                </ui:else>
                <ui:call ui:template=\"{= edg:GetLinksFromDerivationMapGraph }\" ui:varName=\"links\">
                    <ui:forEach ui:resultSet=\"{= ?links }\">
                        <swon:Object>
                            <swon:Value arg:name=\"id\" arg:value=\"{= ?linkId }\"/>
                            <ui:if ui:condition=\"{= bound(?label) &amp;&amp; (?label != &quot;&quot;) }\">
                                <swon:Value arg:name=\"label\" arg:value=\"{= ?label }\"/>
                            </ui:if>
                            <swon:Value arg:name=\"source\" arg:value=\"{= ?sourceId }\"/>
                            <swon:Value arg:name=\"target\" arg:value=\"{= ?targetId }\"/>
                        </swon:Object>
                    </ui:forEach>
                </ui:call>
            </swon:Array>
        </swon:Value>
    </swon:Object>
</ui:group>
"""^^ui:Literal ;
  rdfs:isDefinedBy <http://edg.topbraid.solutions/1.0/diagram/lg/library-common> ;
  rdfs:label "Build JSON for derivaiton map node trio" ;
  rdfs:subClassOf edg:DerivationMapServices ;
.
edg:BuildJSONforDerivationMapNodes
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:rightNode ;
      spl:valueType rdfs:Resource ;
    ] ;
.
edg:BuildJSONforDerivationMapSingleton
  a ui:Service ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:label ;
      spl:valueType xsd:string ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:property ;
      spl:valueType rdf:Property ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:node ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:private true ;
  ui:private true ;
  ui:prototype """
<ui:group>
    <swon:Object>
        <swon:Value arg:name=\"nodes\">
            <swon:Array>
                <ui:resourceView ui:matchIds=\"derivation-map-composite-node\" ui:resource=\"{= ?node }\"/>
            </swon:Array>
        </swon:Value>
        <swon:Value arg:name=\"edges\">
            <swon:Array>
                <edg:BuildJSONforDerviationMapLink arg:label=\"{= ?label }\" arg:leftNode=\"{= ?node }\" arg:property=\"{= ?property }\" arg:rightNode=\"{= ?node }\"/>
            </swon:Array>
        </swon:Value>
    </swon:Object>
</ui:group>
"""^^ui:Literal ;
  rdfs:isDefinedBy <http://edg.topbraid.solutions/1.0/diagram/lg/library-common> ;
  rdfs:label "Build JSON for derivaiton map singleton" ;
  rdfs:subClassOf edg:DerivationMapServices ;
.
edg:BuildJSONforInputsToSoftwareExecutableDerivationMapNodes
  a ui:Service ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:downstreamNode ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:upstreamNode ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:private true ;
  ui:private true ;
  ui:prototype """
<ui:group>
    <!--ui:dumpScope ui:message=\"AAA1 - BuildJSONforInputsToSoftwareExecutableDerivationMapNodes - {= ?downstreamNode } - {= ?upstreamNode }\"/-->
    <ui:call arg:software=\"{= ?downstreamNode }\" ui:template=\"{= edg:GetSoftwareExecutableInputs }\" ui:varName=\"inputs\">
        <!--ui:dumpResultSet ui:message=\"AAA1 edg:BuildJSONforInputsToSoftwareExecutableDerivationMapNodes {= ?downstreamNode }\"
  ui:resultSet=\"{= ?inputs }\"/-->
        <ui:forEach ui:resultSet=\"{= ?inputs }\">
            <ui:resourceView ui:matchIds=\"derivation-map-composite-node\" ui:resource=\"{= ?activeInput }\"/>
        </ui:forEach>
    </ui:call>
    <ui:resourceView ui:matchIds=\"derivation-map-composite-node\" ui:resource=\"{= ?downstreamNode }\"/>
</ui:group>
"""^^ui:Literal ;
  ui:responseType ui:JSON ;
  rdfs:comment "Generate JSON for the left and right nodes using delegation based on instance views." ;
  rdfs:isDefinedBy <http://edg.topbraid.solutions/1.0/diagram/lg/library-common> ;
  rdfs:label "Build JSON for inputs to software executable derivation map nodes" ;
  rdfs:subClassOf edg:DerivationMapServices ;
.
edg:BuildJSONforSoftwareCapabilityLineageGram
  a ui:Service ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate edg:breadth ;
      spl:valueType xsd:integer ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate edg:offset ;
      spl:valueType xsd:integer ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate edg:reach ;
      spl:valueType xsd:integer ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:focusNode ;
      spl:valueType xsd:string ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:graph ;
      spl:valueType rdfs:Resource ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:group let:dataGraph=\"{= IRI(?graph) }\" let:myBreadth=\"{= COALESCE(?breadth, 10) }\" let:myFocusNode=\"{= IRI(spif:decodeURL(?focusNode)) }\" let:myMaxTierNodeCount=\"{= COALESCE(?maxTierNodeCount, 20) }\" let:myOffset=\"{= COALESCE(?offset, 0) }\" let:myReach=\"{= COALESCE(?reach, 10) }\">
    <ui:try>
        <ui:if ui:condition=\"{= !bound(?dataGraph) }\">
            <ui:throw ui:message=\"No data graph provided\"/>
        </ui:if>
        <ui:if ui:condition=\"{= !bound(?myFocusNode) }\">
            <ui:throw ui:message=\"No lineage model specified\"/>
        </ui:if>
        <ui:setContext ui:queryGraph=\"{= ui:graphWithImports(?dataGraph) }\">
            <ui:setContext ui:queryGraph=\"{= ui:unionGraph }\">
                <!--edg:BuildSoftwareExecutableOutputs arg:focusNode=\"{= ?myFocusNode }\"
edg:breadth=\"{= ?lineageBreadth }\"
edg:viewFrame=\"edg:VF_EnterpriseFrame\"/-->
                <ui:if ui:condition=\"{= true }\">
                    <edg:MakeSingleViewFrameResourceOccurrence edg:activeResource=\"{= ?myFocusNode }\" edg:resource=\"{= ?myFocusNode }\" edg:viewFrame=\"{= edg:VF_TargetFrame }\"/>
                    <ui:call arg:software=\"{= ?myFocusNode }\" ui:template=\"{= edg:GetSoftwareExecutableEnterpriseWorkProductOutputs }\" ui:varName=\"outputs\">
                        <!--ui:dumpResultSet ui:message=\"AAA1: edg:BuildJSONforBusinessApplicationLineageGram {= ?myFocusNode }\"
  ui:resultSet=\"{= ?outputs }\"/-->
                        <edg:MakeLineageGramNodeAndLinksForInformationAssets arg:resource=\"{= ?myFocusNode }\" arg:resultSet=\"{= ?outputs }\" edg:sourceViewFrame=\"{= edg:VF_TargetFrame }\" edg:targetViewFrame=\"{= edg:VF_InfoAssetsFrame }\"/>
                    </ui:call>
                </ui:if>
                <edg:BuildSoftwareExecutableEnablements arg:resource=\"{= ?myFocusNode }\" edg:breadth=\"{= ?lineageBreadth }\"/>
                <edg:DetermineTransitiveUpstreamSoftwareExecutableDependencies arg:iteration=\"{= 1 }\" arg:traceabilityTemplate=\"{= edg:GetUpstreamDependencies }\" edg:activeResource=\"{= ?myFocusNode }\" edg:breadth=\"{= ?myBreadth }\" edg:maxBreadth=\"{= ?myBreadth }\" edg:maxTierNodeCount=\"{= ?myMaxTierNodeCount }\" edg:offset=\"{= ?myOffset }\" edg:reach=\"{= ?myReach }\" edg:targetViewFrame=\"{= edg:VF_TargetFrame }\"/>
                <!--edg:MakeResourceNodesAndLinksForInputsOfFirstSoftwareExecutables/-->
                <edg:MakeResourceNodesAndLinksForFirstStageSoftwareExecutableInputs arg:focusNode=\"{= ?myFocusNode }\" edg:breadth=\"{= ?myBreadth }\" edg:maxTierNodeCount=\"{= ?myMaxTierNodeCount }\" edg:offset=\"{= ?myOffset }\" edg:reach=\"{= ?myReach }\" edg:viewFrameStructure=\"{= edg:VFS_LG-ProvenanceModel }\"/>
                <edg:GenerateJSONforLineageGram arg:diagramType=\"{= edg:DIAGTYPE_UPSTREAM-DEPENDENCYGRAM }\" edg:activeResource=\"{= ?myFocusNode }\" edg:resource=\"{= ?myFocusNode }\"/>
            </ui:setContext>
        </ui:setContext>
        <edg:DumpTempGraphForLineageGram/>
    </ui:try>
    <ui:catch>
        <swon:Object>
            <swon:Value arg:name=\"exception\" arg:value=\"{= ?exception }\"/>
        </swon:Object>
    </ui:catch>
</ui:group>
"""^^ui:Literal ;
  ui:responseType ui:JSON ;
  rdfs:comment "Builds a lineage diagram showing upstream dependencies of a \"software capablity\". This can be a business application, lineage model, software module or system." ;
  rdfs:label "Build JSON for software capability lineagegram" ;
.
edg:BuildJSONforSoftwareExecutableNode
  a ui:Service ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:parent ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:node ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:private true ;
  ui:private true ;
  ui:prototype """
<ui:group>
    <ui:forEach ui:resultSet=\"{#
            SELECT ?parentNode
            WHERE {
                ?parentNode (edg:usesModule)*/(edg:hasSoftwareProgram)? ?node .
            } }\">
        <edg:BuildJSONforLineageGramNode arg:collapsed=\"{= true }\" arg:label=\"{= ui:label(?parentNode) }\" arg:node=\"{= ?parentNode }\" arg:parent=\"{= COALESCE(spl:subject(edg:usesModule, ?parentNode), spl:subject(edg:hasSoftwareProgram, ?parentNode)) }\"/>
        <edg:MakeDerivationMapLink arg:id=\"{= CONCAT(str(?node), &quot;~~&quot;, str(?parentNode)) }\" arg:label=\"\" edg:source=\"{= str(?node) }\" edg:target=\"{= str(?parentNode) }\"/>
    </ui:forEach>
    <ui:if ui:condition=\"{= bound(?parent) }\">
        <edg:BuildJSONforLineageGramNode arg:label=\"\" arg:node=\"{= ?node }\" arg:parent=\"{= ?ultimateParent }\"/>
    </ui:if>
</ui:group>
"""^^ui:Literal ;
  ui:responseType ui:JSON ;
  vaem:todo "Create a query that can traverse all the parents of a software executable" ;
  rdfs:isDefinedBy <http://edg.topbraid.solutions/1.0/diagram/lg/software> ;
  rdfs:label "Build JSON for software executable node" ;
  rdfs:seeAlso edg:BuildJSONforSoftwareProgramCompositeNode ;
  rdfs:subClassOf edg:DerivationMapServicesForCompositeNodes ;
.
edg:BuildJSONforSoftwareFunctionCompositeNode
  a ui:Service ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:private true ;
  ui:private true ;
  ui:prototype """
<ui:group let:softwareProgram=\"{= spl:subject(edg:usesSoftwareFunction, ?resource) }\">
    <!--ui:dumpScope ui:message=\"AAA1: edg:BuildJSONforSoftwareFunctionCompositeNode - {= ?resource }\"/-->
    <ui:if ui:condition=\"{= bound(?softwareProgram) &amp;&amp; EXISTS {
        ?softwareProgram a ?swpClass .
        ?swpClass (rdfs:subClassOf)* edg:SoftwareProgram .
    } }\">
        <ui:group let:application=\"{= spl:subject(edg:hasSoftwareProgram, ?softwareProgram) }\">
            <!--ui:dumpScope ui:message=\"AAA2: edg:BuildJSONforSoftwareFunctionCompositeNode - {= ?resource }\"/-->
            <ui:if ui:condition=\"{= bound(?application) &amp;&amp; EXISTS {
                ?application a ?appClass .
                ?appClass (rdfs:subClassOf)* edg:BusinessApplication .
            } }\">
                <ui:group let:server=\"{= spl:object(?application, edg:hostedOn) }\">
                    <ui:if ui:condition=\"{= bound(?server) }\">
                        <edg:BuildJSONforLineageGramNode arg:collapsed=\"{= true }\" arg:label=\"{= ui:label(?server) }\" arg:node=\"{= ?server }\"/>
                        <edg:BuildJSONforLineageGramNode arg:collapsed=\"{= true }\" arg:label=\"{= ui:label(?application) }\" arg:node=\"{= ?application }\" arg:parent=\"{= ?server }\"/>
                    </ui:if>
                    <ui:else>
                        <edg:BuildJSONforLineageGramNode arg:collapsed=\"{= true }\" arg:label=\"{= ui:label(?application) }\" arg:node=\"{= ?application }\"/>
                    </ui:else>
                    <edg:BuildJSONforLineageGramNode arg:collapsed=\"{= true }\" arg:label=\"{= ui:label(?node) }\" arg:node=\"{= ?softwareProgram }\" arg:parent=\"{= ?application }\"/>
                </ui:group>
            </ui:if>
            <edg:BuildJSONforLineageGramNode arg:collapsed=\"{= true }\" arg:label=\"{= COALESCE(?label, ui:label(?resource)) }\" arg:node=\"{= ?resource }\" arg:parent=\"{= ?softwareProgram }\"/>
        </ui:group>
    </ui:if>
    <ui:else>
        <edg:BuildJSONforLineageGramNode arg:collapsed=\"{= true }\" arg:label=\"{= COALESCE(?label, ui:label(?resource)) }\" arg:node=\"{= ?resource }\"/>
    </ui:else>
</ui:group>
"""^^ui:Literal ;
  ui:responseType ui:JSON ;
  rdfs:isDefinedBy <http://edg.topbraid.solutions/1.0/diagram/lg/software> ;
  rdfs:label "Build JSON for software function composite node" ;
  rdfs:subClassOf edg:DerivationMapServicesForCompositeNodes ;
.
edg:BuildJSONforSoftwareLineageGram
  a ui:Service ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate edg:viewFrameStructure ;
      spl:valueType edg:ViewFramesShape ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate edg:breadth ;
      spl:valueType xsd:integer ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate edg:maxTierNodeCount ;
      spl:valueType xsd:integer ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate edg:offset ;
      spl:valueType xsd:integer ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate edg:reach ;
      spl:valueType xsd:integer ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:focusNode ;
      spl:valueType xsd:string ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:graph ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:private true ;
  ui:private true ;
  ui:prototype """
<ui:group let:dataGraph=\"{= IRI(?graph) }\" let:myBreadth=\"{= COALESCE(?breadth, 10) }\" let:myFocusNode=\"{= IRI(spif:decodeURL(?focusNode)) }\" let:myMaxTierNodeCount=\"{= COALESCE(?maxTierNodeCount, 20) }\" let:myOffset=\"{= COALESCE(?offset, 0) }\" let:myReach=\"{= COALESCE(?reach, 10) }\">
    <ui:try>
        <ui:if ui:condition=\"{= !bound(?dataGraph) }\">
            <ui:throw ui:message=\"No data graph provided\"/>
        </ui:if>
        <ui:if ui:condition=\"{= !bound(?myFocusNode) }\">
            <ui:throw ui:message=\"No focus node specified - request provided: {= ?focusNode }\"/>
        </ui:if>
        <!--ui:dumpScope ui:message=\"AAA: edg:BuildJSONforSoftwareLineageGram\"/-->
        <ui:setContext ui:queryGraph=\"{= ui:graphWithImports(?dataGraph) }\">
            <ui:setContext ui:queryGraph=\"{= ui:unionGraph }\">
                <ui:group let:depictedResourceForFocusNode=\"{= edg:highestDepictionForSoftwareExecutable(?myFocusNode) }\">
                    <edg:MakeSingleViewFrameResourceOccurrence edg:activeResource=\"{= ?myFocusNode }\" edg:explanation=\"Starting node for focus node {= ?myFocusNode }\" edg:resource=\"{= ?depictedResourceForFocusNode }\" edg:viewFrame=\"{= edg:VF_TargetFrame }\"/>
                    <edg:BuildSoftwareExecutableEnablements arg:resource=\"{= ?myFocusNode }\" edg:breadth=\"{= ?lineageBreadth }\"/>
                    <edg:DetermineTransitiveUpstreamSoftwareExecutableDependencies arg:iteration=\"{= 1 }\" arg:traceabilityTemplate=\"{= edg:GetUpstreamDependencies }\" edg:activeResource=\"{= ?myFocusNode }\" edg:breadth=\"{= ?myBreadth }\" edg:maxBreadth=\"{= ?myBreadth }\" edg:maxTierNodeCount=\"{= ?myMaxTierNodeCount }\" edg:offset=\"{= ?myOffset }\" edg:reach=\"{= ?myReach }\" edg:targetViewFrame=\"{= edg:VF_TargetFrame }\"/>
                    <edg:MakeResourceNodesAndLinksForFirstStageSoftwareExecutableInputs arg:focusNode=\"{= ?myFocusNode }\" edg:breadth=\"{= ?myBreadth }\" edg:maxTierNodeCount=\"{= ?myMaxTierNodeCount }\" edg:offset=\"{= ?myOffset }\" edg:reach=\"{= ?myReach }\" edg:viewFrameStructure=\"{= edg:VFS_LG-ProvenanceModel }\"/>
                    <edg:MakeResourceNodesAndLinksForSoftwareExecutableEnterpriseOutputs edg:activeResource=\"{= ?myFocusNode }\" edg:breadth=\"{= ?lineageBreadth }\" edg:resource=\"{= ?depictedResourceForFocusNode }\"/>
                    <edg:GenerateJSONforLineageGram arg:diagramType=\"{= edg:DIAGTYPE_UPSTREAM-DEPENDENCYGRAM }\" arg:focusNode=\"{= ?depictedResourceForFocusNode }\" edg:activeResource=\"{= ?myFocusNode }\" edg:resource=\"{= ?depictedResourceForFocusNode }\"/>
                </ui:group>
            </ui:setContext>
        </ui:setContext>
        <edg:DumpTempGraphForLineageGram/>
    </ui:try>
    <ui:catch>
        <swon:Object>
            <swon:Value arg:name=\"exception\" arg:value=\"{= ?exception }\"/>
        </swon:Object>
    </ui:catch>
</ui:group>
"""^^ui:Literal ;
  ui:responseType ui:JSON ;
  rdfs:comment "Builds a dependency map showing upstream dependencies of a software executable." ;
  rdfs:label "Build JSON for software lineagegram" ;
  rdfs:subClassOf edg:LineageGramServices ;
.
edg:BuildJSONforSoftwareModuleNode
  a ui:Service ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:parent ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:node ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:private true ;
  ui:private true ;
  ui:prototype """
<ui:group>
    <ui:forEach ui:resultSet=\"{#
            SELECT ?parentNode
            WHERE {
                ?parentNode (edg:usesModule)* ?node .
            } }\">
        <edg:BuildJSONforLineageGramNode arg:collapsed=\"{= true }\" arg:label=\"{= ui:label(?parentNode) }\" arg:node=\"{= ?parentNode }\" arg:parent=\"{= spl:subject(edg:usesModule, ?parentNode) }\"/>
        <edg:MakeDerivationMapLink arg:id=\"{= CONCAT(str(?node), &quot;~~&quot;, str(?parentNode)) }\" arg:label=\"\" edg:source=\"{= str(?node) }\" edg:target=\"{= str(?parentNode) }\"/>
    </ui:forEach>
    <ui:if ui:condition=\"{= bound(?parent) }\">
        <edg:BuildJSONforLineageGramNode arg:label=\"\" arg:node=\"{= ?node }\" arg:parent=\"{= ?ultimateParent }\"/>
    </ui:if>
</ui:group>
"""^^ui:Literal ;
  ui:responseType ui:JSON ;
  rdfs:isDefinedBy <http://edg.topbraid.solutions/1.0/diagram/lg/software> ;
  rdfs:label "Build JSON for software module node" ;
  rdfs:subClassOf edg:DerivationMapServicesForCompositeNodes ;
.
edg:BuildJSONforSoftwareProgramCompositeNode
  a ui:Service ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:collapsed ;
      spl:valueType xsd:boolean ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:private true ;
  ui:private true ;
  ui:prototype """
<ui:group let:collapsedFlag=\"{= COALESCE(?collapsed, true) }\">
    <ui:call arg:software=\"{= ?resource }\" ui:template=\"{= edg:GetSoftwareParents }\" ui:varName=\"parents\">
        <!--ui:dumpScope ui:message=\"AAA1: edg:BuildJSONforSoftwareProgramCompositeNode\"/-->
        <!--ui:dumpResultSet ui:message=\"AAA1:edg:BuildJSONforSoftwareProgramCompositeNode\" ui:resultSet=\"{= ?parents }\"/-->
        <ui:if ui:condition=\"{= !spr:isEmpty(?parents) }\">
            <ui:forEach ui:indexVar=\"index\" ui:resultSet=\"{= ?parents }\">
                <edg:BuildJSONforLineageGramNode arg:collapsed=\"{= ?collapsedFlag }\" arg:label=\"{= ui:label(?childSoftware) }\" arg:node=\"{= ?childSoftware }\" arg:parent=\"{= ?parentSoftware }\"/>
                <ui:if ui:condition=\"{= ?index = 0 }\">
                    <edg:BuildJSONforLineageGramNode arg:collapsed=\"{= ?collapsedFlag }\" arg:label=\"{= ui:label(?parentSoftware) }\" arg:node=\"{= ?parentSoftware }\"/>
                </ui:if>
            </ui:forEach>
        </ui:if>
        <ui:else>
            <edg:BuildJSONforLineageGramNode arg:collapsed=\"{= ?collapsedFlag }\" arg:label=\"{= ui:label(?resource) }\" arg:node=\"{= ?resource }\"/>
        </ui:else>
    </ui:call>
</ui:group>
"""^^ui:Literal ;
  ui:responseType ui:JSON ;
  vaem:todo "Need to handle more nesting" ;
  rdfs:isDefinedBy <http://edg.topbraid.solutions/1.0/diagram/lg/software> ;
  rdfs:label "Build JSON for software program composite node" ;
  rdfs:subClassOf edg:DerivationMapServicesForCompositeNodes ;
.
edg:BuildSoftwareExecutableEnablements
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate edg:activeResource ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate edg:sourceViewFrame ;
      spl:valueType edg:ViewFrame ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:reverseNodes ;
      spl:valueType xsd:boolean ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate edg:breadth ;
      spl:valueType xsd:integer ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate edg:offset ;
      spl:valueType xsd:integer ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
    ] ;
  ui:prototype """
<ui:group let:myActiveResource=\"{= COALESCE(?activeResource, ?resource) }\" let:myBreadth=\"{= COALESCE(?breadth, 10) }\" let:myOffset=\"{= COALESCE(?offset, 0) }\" let:myReverseNodes=\"{= COALESCE(?reverseNodes, false) }\" let:mySourceViewframe=\"{= COALESCE(?sourceViewFrame, edg:VF_SoftwareFrame) }\" let:targetViewframe=\"{= edg:VF_EnterpriseFrame }\">
    <ui:if ui:condition=\"{= true }\">
        <ui:call arg:resource=\"{= ?myActiveResource }\" ui:limit=\"{= ?myBreadth }\" ui:offset=\"{= ?myOffset }\" ui:template=\"{= edg:GetSoftwareExecutableEnablements }\" ui:varName=\"enablements\">
            <!--ui:dumpResultSet ui:message=\"AAA1 edg:BuildSoftwareExecutableEnablements {= ?resource }\"
  ui:resultSet=\"{= ?enablements }\"/-->
            <ui:forEach ui:resultSet=\"{= ?enablements }\">
                <edg:MakeViewFrameResourceNodeAndLinks arg:reverseNodes=\"{= false }\" edg:dependencyType=\"{= edg:DEPTYPE_SUPPORTS }\" edg:explanation=\"edg:BuildSoftwareExecutableEnablements\" edg:resource=\"{= ?resource }\" edg:targetNode=\"{= ?enablement }\" edg:targetViewFrame=\"{= ?targetViewframe }\" edg:viewFrame=\"{= ?mySourceViewframe }\"/>
            </ui:forEach>
        </ui:call>
        <ui:call arg:resource=\"{= ?resource }\" ui:limit=\"{= ?myBreadth }\" ui:offset=\"{= ?myOffset + ?myBreadth }\" ui:template=\"{= edg:GetSoftwareExecutableEnablements }\" ui:varName=\"maybeMoreFanoutResults\">
            <edg:DetermineNeedForMoreFanOutPlaceholderNode arg:resource=\"{= ?resource }\" arg:resultSet=\"{= ?maybeMoreFanoutResults }\" edg:breadth=\"{= ?myBreadth }\" edg:explanation=\"BuildSoftwareExecutableEnablements\" edg:offset=\"{= ?myOffset }\" edg:targetViewFrame=\"{= ?mySourceViewframe }\" edg:viewFrame=\"{= ?mySourceViewframe }\"/>
        </ui:call>
    </ui:if>
</ui:group>
"""^^ui:Literal ;
  ui:responseType ui:JSON ;
  rdfs:comment "Creates nodes and links for what a software executable enables and supports." ;
  rdfs:isDefinedBy <http://edg.topbraid.solutions/1.0/diagram/lg/library-common> ;
  rdfs:label "Build software executable enablements" ;
  rdfs:subClassOf edg:LineageGramServices ;
.
edg:BuildSoftwareExecutableOutputs
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate edg:breadth ;
      spl:valueType xsd:integer ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate edg:offset ;
      spl:valueType xsd:integer ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate edg:viewFrame ;
      spl:valueType edg:ViewFrame ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:depictedResource ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:focusNode ;
      spl:valueType rdfs:Resource ;
    ] ;
  ui:prototype """
<ui:group let:myBreadth=\"{= COALESCE(?breadth, 10) }\" let:myOffset=\"{= COALESCE(?offset, 0) }\">
    <!--ui:dumpScope ui:message=\"AAA1: edg:BuildSoftwareExecutableOutputs - {= str(?focusNode) }\"/-->
    <ui:call arg:software=\"{= ?focusNode }\" ui:limit=\"{= ?myBreadth }\" ui:offset=\"{= 0 }\" ui:template=\"{= edg:GetSoftwareExecutableOutputs }\" ui:varName=\"outputs\">
        <!--ui:dumpResultSet ui:message=\"AAA2: edg:BuildSoftwareExecutableOutputs - {= str(?focusNode) }\"
  ui:resultSet=\"{= ?outputs }\"/-->
        <ui:forEach ui:resultSet=\"{= ?outputs }\">
            <edg:MakeSingleViewFrameResourceOccurrence edg:activeResource=\"{= ?focusNode }\" edg:explanation=\"BuildSoftwareExecutableOutputs\" edg:resource=\"{= ?depictedResource }\" edg:viewFrame=\"{= edg:VF_SoftwareFrame }\"/>
            <edg:MakeSingleViewFrameResourceOccurrence edg:explanation=\"BuildSoftwareExecutableOutputs\" edg:resource=\"{= ?output }\" edg:viewFrame=\"{= edg:VF_InfoAssetsFrame }\"/>
            <edg:MakeViewFrameResourceNodeLink edg:dependencyType=\"{= edg:DEPTYPE_INFO-OUTPUT }\" edg:explanation=\"BuildSoftwareExecutableOutputs\" edg:resource=\"{= ?depictedResource }\" edg:targetNode=\"{= ?output }\" edg:targetViewFrame=\"{= edg:VF_InfoAssetsFrame }\" edg:viewFrame=\"{= edg:VF_SoftwareFrame }\"/>
            <ui:call arg:class=\"{= edg:InformationAsset }\" arg:resource=\"{= ?output }\" ui:template=\"{= edg:GetDerivationTargets }\" ui:varName=\"informationAssets\">
                <!--ui:dumpResultSet ui:message=\"AAA3: edg:BuildSoftwareExecutableOutputs - {= str(?output) }\"
  ui:resultSet=\"{= ?informationAssets }\"/-->
                <ui:if ui:condition=\"{= !spr:isEmpty(?informationAssets) }\">
                    <ui:forEach ui:resultSet=\"{= ?informationAssets }\">
                        <edg:MakeSingleViewFrameResourceOccurrence edg:explanation=\"Derivation Dependency on {= ?output }\" edg:resource=\"{= ?target }\" edg:viewFrame=\"{= edg:VF_InfoAssetsFrame }\"/>
                        <edg:MakeViewFrameResourceNodeLink edg:dependencyType=\"{= edg:DEPTYPE_DATA-OUTPUT }\" edg:explanation=\"Derivation link from {= ?output }\" edg:resource=\"{= ?output }\" edg:targetNode=\"{= ?target }\" edg:targetViewFrame=\"{= edg:VF_InfoAssetsFrame }\" edg:viewFrame=\"{= edg:VF_InfoAssetsFrame }\"/>
                    </ui:forEach>
                </ui:if>
            </ui:call>
        </ui:forEach>
    </ui:call>
</ui:group>
"""^^ui:Literal ;
  ui:responseType ui:JSON ;
  rdfs:comment "Creates nodes and links for a software executables outputs." ;
  rdfs:isDefinedBy <http://edg.topbraid.solutions/1.0/diagram/lg/library-common> ;
  rdfs:label "Build software executable outputs" ;
  rdfs:subClassOf edg:LineageGramServices ;
.
edg:BusinessApplication
  ui:instanceView """
<ui:group ui:id=\"derivation-map-composite-node\" ui:priority=\"{= 10 }\">
    <edg:BuildJSONforBusinessApplicationNode arg:node=\"{= ?this }\"/>
</ui:group>
"""^^ui:Literal ;
  ui:instanceView """
<ui:group ui:id=\"derivation-map-data-service-other-node-from-business-application\" ui:priority=\"{= 10 }\">
    <!--ui:dumpScope ui:message=\"AAA7: edg:BusinessApplication {= ui:label(?this) } to {= ui:label(?rightNode) }\"/-->
    <edg:GenerateJSONforSoftwareExecutableToSoftwareExecutableDependencyDetails arg:leftNode=\"{= ?leftNode }\" arg:rightNode=\"{= ?rightNode }\" edg:linkType=\"{= ?linkType }\"/>
</ui:group>
"""^^ui:Literal ;
  ui:instanceView """
<ui:group ui:id=\"derivation-map-data-service-other-node-from-business-function\" ui:priority=\"{= 10 }\">
    <!--ui:dumpScope ui:message=\"AAA: edg:BusinessApplication {= ?this } to {= ?rightNode }\"/-->
    <edg:GenerateJSONforExecutableEnablements arg:leftNode=\"{= ?leftNode }\" arg:rightNode=\"{= ?rightNode }\" edg:linkType=\"{= ?linkType }\"/>
</ui:group>
"""^^ui:Literal ;
  ui:instanceView """
<ui:group ui:id=\"derivation-map-data-service\" ui:priority=\"{= 10 }\">
    <!--ui:dumpScope ui:message=\"AAA1: edg:BusinessApplication {= ui:label(?this) } to {= ui:label(?rightNode) }\"/-->
    <ui:if ui:condition=\"{= ?linkType != &quot;&quot; }\">
        <ui:if ui:condition=\"{= fn:starts-with(?linkType, &quot;more-&quot;) }\">
            <ui:resourceView arg:leftNode=\"{= ?leftNode }\" arg:rightNode=\"{= ?this }\" edg:linkType=\"{= ?linkType }\" ui:matchIds=\"{= ?linkType }\" ui:resource=\"{= ?leftNode }\"/>
        </ui:if>
        <ui:else>
            <ui:resourceView arg:leftNode=\"{= ?leftNode }\" arg:rightNode=\"{= ?rightNode }\" edg:linkType=\"{= ?linkType }\" ui:matchIds=\"derivation-map-data-service-other-node-from-business-application\" ui:resource=\"{= ?leftNode }\"/>
        </ui:else>
    </ui:if>
    <ui:else>
        <ui:throw ui:message=\"Link type missing for {= ui:label(?this) } to {= ui:label(?rightNode) }\"/>
    </ui:else>
</ui:group>
"""^^ui:Literal ;
  ui:instanceView """
<ui:group ui:id=\"downstream-finish-nodes\" ui:priority=\"{= 10 }\"/>
"""^^ui:Literal ;
  ui:instanceView """
<ui:group ui:id=\"downstream-impact\" ui:priority=\"{= 10 }\">
    <ui:group let:myViewFrame=\"{= edg:VF_SoftwareFrame }\">
        <!--ui:dumpScope ui:message=\"AAA: edg:BusinessApplication - downstream-impact of {= ?source } on {= ?activeResource }\"/-->
        <ui:if ui:condition=\"{= !bound(?source) }\">
            <ui:throw ui:message=\"Downstream impact on business application {= str(?this) } - source is not bound\"/>
        </ui:if>
        <ui:if ui:condition=\"{= !bound(?sourceViewFrame) }\">
            <ui:throw ui:message=\"Downstream impact on business application {= str(?this) } source viewframe is not bound\"/>
        </ui:if>
        <edg:MakeSingleViewFrameResourceOccurrence edg:activeResource=\"{= ?this }\" edg:resource=\"{= ?this }\" edg:viewFrame=\"{= ?myViewFrame }\"/>
        <edg:MakeViewFrameResourceNodeLink edg:dependencyType=\"{= edg:DEPTYPE_DATA-INPUT }\" edg:resource=\"{= ?source }\" edg:targetNode=\"{= ?this }\" edg:targetViewFrame=\"{= ?myViewFrame }\" edg:viewFrame=\"{= ?sourceViewFrame }\"/>
        <edg:DetermineDownstreamDependenciesForResource arg:dependencyTemplate=\"{= edg:GetSoftwareDependents }\" arg:focusNode=\"{= ?this }\" edg:breadth=\"{= ?breadth }\" edg:offset=\"{= ?offset }\" edg:reach=\"{= ?reach }\" edg:sourceViewFrame=\"{= ?myViewFrame }\"/>
    </ui:group>
</ui:group>
"""^^ui:Literal ;
  ui:instanceView """
<ui:group ui:id=\"impact-diagram\" ui:priority=\"{= -1 }\">
    <!--ui:dumpScope ui:message=\"AAA3: edg:BusinessApplication - impact diagram of {= ?this }\"/-->
    <edg:LineageGramTemplate arg:dataProvider=\"{= edg:BuildJSONforBusinessApplicationDownstreamTraceabilityDiagram }\" arg:focusNode=\"{= ?this }\" arg:graph=\"{= ?graph }\" edg:breadth=\"{= ?breadth }\" edg:reach=\"{= ?reach }\" edg:viewFrameStructure=\"{= edg:VFS_LG-ImpactDiagram }\" edg:viewFramesGraph=\"{= ?viewFramesGraph }\">
        <ui:insert ui:into=\"header\">
            <edg:LineageGramHeader arg:title=\"Downstream Dependency on Business Application: {= ui:label(?this) }\"/>
        </ui:insert>
    </edg:LineageGramTemplate>
</ui:group>
"""^^ui:Literal ;
  ui:instanceView """
<ui:group ui:id=\"lineageGramNodeType\" ui:priority=\"{= 1 }\">
    <swon:Value arg:name=\"type\" arg:value=\"app\"/>
</ui:group>
"""^^ui:Literal ;
  ui:instanceView """
<ui:group ui:id=\"lineagegram-data-provider\" ui:priority=\"{= 10 }\">
    <edg:BuildJSONforLineageGramDataProviderDataService arg:dataProvider=\"{= edg:BuildJSONforSoftwareCapabilityLineageGram }\" arg:provider=\"{= edg:SoftwareModule }\"/>
</ui:group>
"""^^ui:Literal ;
  ui:instanceView """
<ui:group ui:id=\"lineagegram\" ui:priority=\"{= -1 }\">
    <edg:LineageGramTemplate arg:dataProvider=\"{= edg:BuildJSONforSoftwareCapabilityLineageGram }\" arg:focusNode=\"{= ?this }\" arg:graph=\"{= ?graph }\" edg:breadth=\"{= ?breadth }\" edg:reach=\"{= ?reach }\" edg:viewFrameStructure=\"{= edg:VFS_LG-ProvenanceModel }\" edg:viewFramesGraph=\"{= ?viewFramesGraph }\">
        <ui:insert ui:into=\"header\">
            <edg:LineageGramHeader arg:title=\"Upstream Dependency for Business Application: {= ui:label(?this) }\"/>
        </ui:insert>
    </edg:LineageGramTemplate>
</ui:group>
"""^^ui:Literal ;
.
edg:BusinessApplicationToFeedlineDetails
  a ui:Service ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:leftNode ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:rightNode ;
      spl:valueType rdfs:Resource ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:group>
    <ui:group let:leftNodeStore=\"{= spl:object(?leftNode, edg:storesDataIn) }\" let:rightNodeStore=\"{= spl:object(?rightNode, edg:storesDataIn) }\">
        <swon:Object>
            <swon:Value arg:name=\"nodes\">
                <swon:Array>
                    <edg:BuildJSONforPairOfDerivationMapNodes arg:leftNode=\"{= ?leftNode }\" arg:rightNode=\"{= ?rightNode }\"/>
                    <ui:if ui:condition=\"{= bound(?leftNodeStore) }\">
                        <edg:BuildJSONforPairOfDerivationMapNodes arg:leftNode=\"{= ?leftNode }\" arg:rightNode=\"{= ?leftNodeStore }\"/>
                    </ui:if>
                    <ui:if ui:condition=\"{= bound(?rightNodeStore) }\">
                        <edg:BuildJSONforPairOfDerivationMapNodes arg:leftNode=\"{= ?rightNode }\" arg:rightNode=\"{= ?rightNodeStore }\"/>
                    </ui:if>
                </swon:Array>
            </swon:Value>
            <swon:Value arg:name=\"edges\">
                <swon:Array>
                    <edg:BuildJSONforDerviationMapLink arg:leftNode=\"{= ?rightNode }\" arg:property=\"{= edg:dependsOnDataFrom }\" arg:rightNode=\"{= ?leftNode }\"/>
                    <ui:if ui:condition=\"{= bound(?leftNodeStore) }\">
                        <edg:BuildJSONforDerviationMapLink arg:leftNode=\"{= ?leftNode }\" arg:property=\"{= edg:storesDataIn }\" arg:rightNode=\"{= ?leftNodeStore }\"/>
                    </ui:if>
                    <ui:if ui:condition=\"{= bound(?rightNodeStore) }\">
                        <edg:BuildJSONforDerviationMapLink arg:leftNode=\"{= ?rightNode }\" arg:property=\"{= edg:storesDataIn }\" arg:rightNode=\"{= ?rightNodeStore }\"/>
                    </ui:if>
                </swon:Array>
            </swon:Value>
        </swon:Object>
    </ui:group>
</ui:group>
"""^^ui:Literal ;
  ui:responseType ui:JSON ;
  rdfs:isDefinedBy <http://edg.topbraid.solutions/1.0/diagram/lg/library-common> ;
  rdfs:label "Business application to feedline details" ;
  rdfs:subClassOf edg:DerivationMapServices ;
.
edg:BusinessApplication_1
  a edg:BusinessApplication ;
  rdfs:label "Business application 1" ;
.
edg:CompleteUpstreamPhysicalFlows
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate edg:id ;
      spl:valueType xsd:string ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate edg:dependencyType ;
      spl:valueType edg:DependencyType ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate edg:explanation ;
      spl:valueType xsd:string ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate edg:targetNode ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate edg:targetViewFrame ;
      spl:valueType edg:ViewFrame ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate edg:viewFrame ;
      spl:valueType edg:ViewFrame ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resultSet ;
      spl:valueType spr:Table ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:upstreamResource ;
      spl:valueType rdfs:Resource ;
    ] ;
  ui:prototype """
<ui:group>
    <!--ui:dumpScope ui:message=\" AAA1: edg:BuildUpstreamFlows - {= ?resource }\"/-->
    <ui:forEach ui:resultSet=\"{= ?resultSet }\">
        <ui:if ui:condition=\"{= ?dependencyType = edg:DEPTYPE_LOGICAL-FLOW }\">
            <ui:group let:countOfPhysicalFlows=\"{#
                    SELECT (COUNT(?physicalFlow) AS ?countOfPhysicalFlows)
                    WHERE {
                        ?flow edg:realizedAs ?physicalFlow .
                    } }\">
                <!--ui:dumpScope ui:message=\" AAA2: edg:BuildUpstreamFlows - {= ?resource }\"/-->
                <ui:if ui:condition=\"{= ?countOfPhysicalFlows &gt; 0 }\">
                    <edg:MakeViewFrameResourceNodeLink edg:dependencyType=\"{= edg:DEPTYPE_DATAFLOW }\" edg:explanation=\"Upstream physical flow for {= str(?resource) }\" edg:flow=\"{= str(?countOfPhysicalFlows) }\" edg:id=\"{= CONCAT(&quot;LINK_&quot;, ui:uniqueId()) }\" edg:resource=\"{= ?upstreamResource }\" edg:targetNode=\"{= ?resource }\" edg:targetViewFrame=\"{= ?targetViewFrame }\" edg:viewFrame=\"{= ?viewFrame }\"/>
                </ui:if>
            </ui:group>
        </ui:if>
    </ui:forEach>
</ui:group>
"""^^ui:Literal ;
  ui:responseType ui:JSON ;
  rdfs:comment "For each identified logical flow query for data flows specifed by the \"realizedBy\" property. Because of the constraints that limit the determination of dependencies, the physical flows for the identified logical flows maybe incomplete. The work of this function is to find all the associated physical flows without the constraints governing the lineage model." ;
  rdfs:label "Complete upstream physical flows" ;
  rdfs:subClassOf edg:LineageGramServices ;
.
edg:CustomConnector
  ui:instanceView """
<ui:group ui:id=\"lineagegram\" ui:priority=\"{= -1 }\">
    <edg:LineageGramTemplate arg:dataProvider=\"{= edg:BuildJSONforSoftwareLineageGram }\" arg:focusNode=\"{= ?this }\" arg:graph=\"{= ?graph }\" edg:breadth=\"{= ?breadth }\" edg:reach=\"{= ?reach }\" edg:viewFrameStructure=\"{= edg:VFS_LG-ProvenanceModel }\" edg:viewFramesGraph=\"{= ?viewFramesGraph }\">
        <ui:insert ui:into=\"header\">
            <edg:LineageGramHeader arg:title=\"Upstream Dependency for Custom Connector: {= ui:label(?this) }\"/>
        </ui:insert>
    </edg:LineageGramTemplate>
</ui:group>
"""^^ui:Literal ;
.
edg:Database
  ui:instanceView """
<ui:group ui:id=\"derivation-map-data-service-other-node\" ui:priority=\"{= 10 }\">
    <!--ui:dumpScope ui:message=\"AAA1 - edg:Database - {= ?this }\"/-->
    <swon:Object>
        <swon:Values arg:name=\"nodes\">
            <edg:BuildJSONforDatabaseDerivationMapDependencies arg:downstreamNode=\"{= ?rightNode }\" arg:upstreamNode=\"{= ?this }\"/>
        </swon:Values>
        <swon:Values arg:name=\"edges\">
            <edg:GenerateJSONforDerivationMapLinks arg:leftNode=\"{= ?this }\" arg:rightNode=\"{= ?rightNode }\"/>
        </swon:Values>
    </swon:Object>
</ui:group>
"""^^ui:Literal ;
.
edg:DatabaseTable
  ui:instanceView """
<ui:group ui:id=\"derivation-map-data-service-other-node\" ui:priority=\"{= 10 }\">
    <swon:Object>
        <swon:Values arg:name=\"nodes\">
            <edg:BuildJSONforInputsToSoftwareExecutableDerivationMapNodes arg:downstreamNode=\"{= ?rightNode }\" arg:upstreamNode=\"{= ?leftNode }\"/>
        </swon:Values>
        <swon:Values arg:name=\"edges\">
            <edg:BuildJSONforDerviationMapLink arg:leftNode=\"{= ?leftNode }\" arg:property=\"{= edg:input }\" arg:rightNode=\"{= ?rightNode }\"/>
            <edg:GenerateJSONforDerivationMapLinks arg:leftNode=\"{= ?this }\" arg:rightNode=\"{= ?rightNode }\"/>
        </swon:Values>
    </swon:Object>
</ui:group>
"""^^ui:Literal ;
.
edg:Dataflow
  ui:instanceView """
<ui:group ui:id=\"derivation-map-data-service-other-node\" ui:priority=\"{= 10 }\">
    <edg:DataflowToInteroperableDestinationDetails arg:leftNode=\"{= ?leftNode }\" arg:rightNode=\"{= ?rightNode }\"/>
</ui:group>
"""^^ui:Literal ;
.
edg:DataflowEdges
  a ui:Service ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate edg:flow ;
      spl:valueType edg:Flow ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate edg:source ;
      spl:valueType edg:ServiceEndpoint ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate edg:target ;
      spl:valueType edg:ServiceEndpoint ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:leftNode ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:rightNode ;
      spl:valueType rdfs:Resource ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:group>
    <ui:call arg:resource=\"{= spl:object(?source, edg:mappingsCollection) }\" ui:template=\"{= edg:getDirectMappings }\" ui:varName=\"mappings\">
        <edg:BuildJSONforDerviationMapLink arg:label=\"source for\" arg:leftNode=\"{= ?source }\" arg:rightNode=\"{= ?flow }\"/>
        <edg:BuildJSONforDerviationMapLink arg:label=\"target\" arg:leftNode=\"{= ?flow }\" arg:rightNode=\"{= ?target }\"/>
        <ui:forEach ui:resultSet=\"{= ?mappings }\">
            <ui:forEach ui:resultSet=\"{#
                    SELECT ?sourceOutput ?targetOutput
                    WHERE {
                        ?mapping edg:output ?sourceOutput .
                        ( ?mapping ?flow ) edg:getMappingFlowTargetOutput ?targetOutput .
                    } }\">
                <edg:BuildJSONforDerviationMapLink arg:label=\"=\" arg:leftNode=\"{= ?sourceOutput }\" arg:rightNode=\"{= ?targetOutput }\"/>
            </ui:forEach>
        </ui:forEach>
    </ui:call>
</ui:group>
"""^^ui:Literal ;
  ui:responseType ui:JSON ;
  rdfs:isDefinedBy <http://edg.topbraid.solutions/1.0/diagram/lg/software> ;
  rdfs:label "Dataflow edges" ;
  rdfs:subClassOf edg:DerivationMapServices ;
.
edg:DataflowToInteroperableDestinationDetails
  a ui:Service ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:leftNode ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:rightNode ;
      spl:valueType rdfs:Resource ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:group>
    <ui:group let:source=\"{= spl:subject(edg:outgoingFlow, ?leftNode) }\">
        <swon:Object>
            <swon:Value arg:name=\"nodes\">
                <swon:Array>
                    <edg:BuildJSONforLineageGramNode arg:label=\"{= edg:MakeNodeLabel(?leftNode) }\" arg:node=\"{= ?leftNode }\"/>
                    <edg:BuildJSONforLineageGramNode arg:label=\"{= edg:MakeNodeLabel(?rightNode) }\" arg:node=\"{= ?rightNode }\"/>
                    <ui:forEach ui:resultSet=\"{#
                            SELECT ?dataExchange
                            WHERE {
                                ?leftNode edg:dataExchange ?dataExchange .
                            } }\">
                        <edg:BuildJSONforLineageGramNode arg:label=\"{= edg:MakeNodeLabel(?dataExchange) }\" arg:node=\"{= ?dataExchange }\" arg:parent=\"{= ?leftNode }\"/>
                    </ui:forEach>
                    <ui:if ui:condition=\"{= bound(?source) }\">
                        <edg:BuildJSONforLineageGramNode arg:label=\"{= edg:MakeNodeLabel(?source) }\" arg:node=\"{= ?source }\"/>
                    </ui:if>
                </swon:Array>
            </swon:Value>
            <swon:Value arg:name=\"edges\">
                <swon:Array>
                    <edg:BuildJSONforDerviationMapLink arg:label=\"feeds\" arg:leftNode=\"{= ?leftNode }\" arg:property=\"{= edg:incomingFlow }\" arg:rightNode=\"{= ?rightNode }\"/>
                    <ui:forEach ui:resultSet=\"{#
                            SELECT ?dataExchange
                            WHERE {
                                ?leftNode edg:dataExchange ?dataExchange .
                            } }\">
                        <edg:BuildJSONforDerviationMapLink arg:leftNode=\"{= ?dataExchange }\" arg:property=\"{= edg:dataExchange }\" arg:rightNode=\"{= ?leftNode }\"/>
                    </ui:forEach>
                    <ui:if ui:condition=\"{= bound(?source) }\">
                        <edg:BuildJSONforDerviationMapLink arg:label=\"outgoimg flow\" arg:leftNode=\"{= ?source }\" arg:property=\"{= edg:outgoingFeed }\" arg:rightNode=\"{= ?leftNode }\"/>
                    </ui:if>
                </swon:Array>
            </swon:Value>
        </swon:Object>
    </ui:group>
</ui:group>
"""^^ui:Literal ;
  ui:responseType ui:JSON ;
  rdfs:isDefinedBy <http://edg.topbraid.solutions/1.0/diagram/lg/library-common> ;
  rdfs:label "Dataflow to interoperable destination details" ;
  rdfs:subClassOf edg:DerivationMapServices ;
.
edg:DetermineNeedForMoreFanInPlaceholderNode
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate edg:breadth ;
      spl:valueType xsd:integer ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate edg:explanation ;
      spl:valueType xsd:string ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate provo:wasGeneratedBy ;
      spl:valueType rdfs:Resource ;
    ] ;
  ui:prototype """
<ui:group>
    <ui:if ui:condition=\"{= !bound(?resource) }\">
        <ui:throw ui:message=\"Resource is unbound in edg:DetermineNeedForMoreFanInPlaceholderNode\"/>
    </ui:if>
    <ui:if ui:condition=\"{= !bound(?viewFrame) }\">
        <ui:throw ui:message=\"Viewframe is unbound in edg:DetermineNeedForMoreFanInPlaceholderNode\"/>
    </ui:if>
    <ui:if ui:condition=\"{= !bound(?targetViewFrame) }\">
        <ui:throw ui:message=\"Target viewframe is unbound in edg:DetermineNeedForMoreFanInPlaceholderNode\"/>
    </ui:if>
    <ui:if ui:condition=\"{= !bound(?breadth) }\">
        <ui:throw ui:message=\"Breadth is unbound in edg:DetermineNeedForMoreFanInPlaceholderNode\"/>
    </ui:if>
    <ui:if ui:condition=\"{= !bound(?offset) }\">
        <ui:throw ui:message=\"Offset is unbound in edg:DetermineNeedForMoreFanInPlaceholderNode\"/>
    </ui:if>
    <ui:group let:myOffset=\"{= ?offset + ?breadth }\" let:sourceViewFrame=\"{= COALESCE(?viewFrame, edg:VF_SoftwareFrame) }\" let:targetViewFrame=\"{= COALESCE(?targetViewFrame, edg:VF_SoftwareFrame) }\">
        <ui:group let:moreAlreadyKnownUpstream=\"{= edg:GetViewFrameResourceNodePropertyValue(edg:hasMoreUpstream, ?resource, ?targetViewFrame) }\">
            <ui:if ui:condition=\"{= (!bound(?moreAlreadyKnownUpstream)) || (!?moreAlreadyKnownUpstream) }\">
                <!--ui:dumpScope ui:message=\"AAA1 edg:DetermineNeedForUpstreamPlaceholderNode - {= ?resource }\"/-->
                <ui:call arg:resource=\"{= ?resource }\" ui:limit=\"{= 1 }\" ui:offset=\"{= ?myOffset }\" ui:template=\"{= ?dependencyTemplate }\" ui:varName=\"lookAheadCheck\">
                    <!--ui:dumpResultSet ui:message=\"AAA2 edg:DetermineNeedForUpstreamPlaceholderNode - {= ?resource }\"
  ui:resultSet=\"{= ?lookAheadCheck }\"/-->
                    <ui:if ui:condition=\"{= spr:rowCount(?lookAheadCheck) &gt; 0 }\">
                        <edg:MakeViewFrameUpstreamPlaceholderNodeAndLinks edg:breadth=\"{= ?breadth }\" edg:continuation=\"{= edg:UpstreamSoftwareContinuationService }\" edg:dependencyType=\"{= edg:DEPTYPE_MORE-FANIN }\" edg:explanation=\"{= ?explanation }\" edg:hasMoreUpstream=\"{= true }\" edg:offset=\"{= ?offset + ?breadth }\" edg:outOfBreadth=\"{= true }\" edg:placeholderType=\"{= edg:PlaceholderForMoreFanin }\" edg:resource=\"{= ?resource }\" edg:targetViewFrame=\"{= ?targetViewFrame }\" edg:viewFrame=\"{= ?sourceViewFrame }\" edg:viewFrameTier=\"{= ?reach }\" provo:wasGeneratedBy=\"{= ?wasGeneratedBy }\"/>
                        <edg:SetViewFrameResourceNodePropertyValue arg:property=\"{= edg:hasMoreUpstream }\" arg:value=\"{= true }\" edg:resource=\"{= ?resource }\" edg:viewFrame=\"{= ?sourceViewFrame }\"/>
                    </ui:if>
                </ui:call>
            </ui:if>
        </ui:group>
    </ui:group>
</ui:group>
"""^^ui:Literal ;
  ui:responseType ui:JSON ;
  rdfs:isDefinedBy <http://edg.topbraid.solutions/1.0/diagram/lg/library-common> ;
  rdfs:label "Determine need for more fan-in placeholder node" ;
  rdfs:subClassOf edg:LineageGramServices ;
.
edg:DetermineNeedForMoreFanOutPlaceholderNode
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate edg:explanation ;
      spl:valueType xsd:string ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate edg:targetViewFrame ;
      spl:valueType edg:targetViewFrame ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate edg:viewFrame ;
      spl:valueType edg:ViewFrame ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:property ;
      spl:valueType rdf:Property ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate edg:breadth ;
      spl:valueType xsd:integer ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate edg:offset ;
      spl:valueType xsd:integer ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resultSet ;
      spl:valueType spr:Table ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate provo:wasGeneratedBy ;
      spl:valueType rdfs:Resource ;
    ] ;
  ui:prototype """
<ui:group>
    <ui:if ui:condition=\"{= !bound(?resultSet) }\">
        <ui:throw ui:message=\"ResultSet is unbound in {= CONCAT(&quot;edg:DetermineNeedForMoreFanOutPlaceholderNode&quot;, &quot; trace: &quot;, ?explanation) }\"/>
    </ui:if>
    <ui:if ui:condition=\"{= !bound(?resource) }\">
        <ui:throw ui:message=\"Resource is unbound in {= CONCAT(&quot;edg:DetermineNeedForMoreFanOutPlaceholderNode&quot;, &quot; trace: &quot;, ?explanation) }\"/>
    </ui:if>
    <ui:if ui:condition=\"{= !bound(?viewFrame) }\">
        <ui:throw ui:message=\"Viewframe is unbound in {= CONCAT(&quot;edg:DetermineNeedForMoreFanOutPlaceholderNode&quot;, &quot; trace: &quot;, ?explanation) }\"/>
    </ui:if>
    <ui:if ui:condition=\"{= !bound(?targetViewFrame) }\">
        <ui:throw ui:message=\"Target viewframe is unbound in{= CONCAT(&quot;edg:DetermineNeedForMoreFanOutPlaceholderNode&quot;, &quot; trace: &quot;, ?explanation) }\"/>
    </ui:if>
    <ui:if ui:condition=\"{= !bound(?breadth) }\">
        <ui:throw ui:message=\"Breadth is unbound in {= CONCAT(&quot;edg:DetermineNeedForMoreFanOutPlaceholderNode&quot;, &quot; trace: &quot;, ?explanation) }\"/>
    </ui:if>
    <ui:if ui:condition=\"{= !bound(?offset) }\">
        <ui:throw ui:message=\"Offset is unbound in {= CONCAT(&quot;edg:DetermineNeedForMoreFanOutPlaceholderNode&quot;, &quot; trace: &quot;, ?explanation) }\"/>
    </ui:if>
    <ui:group let:myOffset=\"{= ?offset + ?breadth }\" let:sourceViewFrame=\"{= COALESCE(?viewFrame, edg:VF_SoftwareFrame) }\" let:targetViewFrame=\"{= COALESCE(?targetViewFrame, edg:VF_SoftwareFrame) }\">
        <!--ui:dumpScope ui:message=\"AAA1 edg:DetermineNeedForMoreFanOutPlaceholderNode - {= ?resource }\"/-->
        <!--ui:dumpResultSet ui:message=\"AAA2 edg:DetermineNeedForMoreFanOutPlaceholderNode - {= ?resource }\"
  ui:resultSet=\"{= ?resultSet }\"/-->
        <ui:group let:moreFanoutCount=\"{= spr:rowCount(?resultSet) }\">
            <ui:if ui:condition=\"{= ?moreFanoutCount &gt; 0 }\">
                <ui:group let:moreFanoutAlreadyKnown=\"{= edg:GetViewFrameResourceNodePropertyValue(edg:hasMoreFanout, ?resource, ?viewFrame) }\">
                    <!--ui:dumpScope ui:message=\"AAA1 edg:DetermineNeedForDownstreamPlaceholderNode - {= ?resource }\"/-->
                    <ui:if ui:condition=\"{= (!bound(?moreFanoutAlreadyKnown)) || (!?moreFanoutAlreadyKnown) }\">
                        <edg:MakeViewFrameDownstreamPlaceholderNodeAndLinks edg:breadth=\"{= ?breadth }\" edg:dependencyType=\"{= edg:DEPTYPE_MORE-FANOUT }\" edg:explanation=\"{= CONCAT(?explanation, &quot;- edg:DetermineNeedForMoreFanOutPlaceholderNode - more fanout:&quot;, ?moreFanoutCount) }\" edg:hasMoreDownstream=\"{= true }\" edg:offset=\"{= ?offset + ?breadth }\" edg:outOfBreadth=\"{= true }\" edg:placeholderType=\"{= edg:PlaceholderForMoreFanout }\" edg:resource=\"{= ?resource }\" edg:targetViewFrame=\"{= ?targetViewFrame }\" edg:viewFrame=\"{= ?viewFrame }\" edg:viewFrameTier=\"{= ?reach }\" provo:wasGeneratedBy=\"{= ?wasGeneratedBy }\"/>
                        <edg:SetViewFrameResourceNodePropertyValue arg:property=\"{= edg:hasMoreFanout }\" arg:value=\"{= true }\" edg:resource=\"{= ?resource }\" edg:viewFrame=\"{= ?viewFrame }\"/>
                    </ui:if>
                </ui:group>
            </ui:if>
        </ui:group>
    </ui:group>
</ui:group>
"""^^ui:Literal ;
  ui:responseType ui:JSON ;
  rdfs:isDefinedBy <http://edg.topbraid.solutions/1.0/diagram/lg/library-common> ;
  rdfs:label "Determine need for more fan-out placeholder node" ;
  rdfs:seeAlso edg:DetermineNeedForDownstreamPlaceholderNode ;
  rdfs:subClassOf edg:LineageGramServices ;
.
edg:DetermineTransitiveDownstreamSoftwareExecutableDependencies
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate edg:sourceViewFrame ;
      spl:valueType edg:ViewFrame ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate edg:viewFrame ;
      spl:valueType edg:ViewFrame ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:depictedResource ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate edg:activeResource ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate edg:breadth ;
      spl:valueType xsd:integer ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate edg:offset ;
      spl:valueType xsd:integer ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate edg:reach ;
      spl:valueType xsd:integer ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:traceabilityTemplate ;
      spl:valueType spin:Template ;
    ] ;
  ui:prototype """
<ui:group let:myBreadth=\"{= COALESCE(?breadth, 10) }\" let:myDepictedResource=\"{= COALESCE(?depictedResource, ?activeResource) }\" let:myOffset=\"{= COALESCE(?offset, 0) }\" let:mySourceViewFrame=\"{= COALESCE(?sourceViewFrame, edg:VF_SoftwareFrame) }\" let:myViewFrame=\"{= COALESCE(?viewFrame, edg:VF_SoftwareFrame) }\">
    <ui:if ui:condition=\"{= !bound(?activeResource) }\">
        <ui:throw ui:message=\"Unbound active resource in edg:DetermineTransitiveDownstreamSoftwareExecutableDependencies\"/>
    </ui:if>
    <ui:call arg:resource=\"{= ?activeResource }\" ui:limit=\"{= ?myBreadth }\" ui:offset=\"{= ?myOffset }\" ui:template=\"{= ?traceabilityTemplate }\" ui:varName=\"dependents\">
        <!--ui:dumpScope ui:message=\"AAA1 edg:DetermineTransitiveDownstreamSoftwareExecutableDependencies - {= ?activeResource }\"/-->
        <!--ui:dumpResultSet ui:message=\"AAA1 edg:DetermineTransitiveDownstreamSoftwareExecutableDependencies  - {= ?activeResource }\"
  ui:resultSet=\"{= ?dependents }\"/-->
        <ui:forEach ui:indexVar=\"index\" ui:resultSet=\"{= ?dependents }\">
            <!-- TBD: Data dependencies -->
            <ui:if ui:condition=\"{= bound(?dataDependency) }\"/>
            <ui:elseif ui:condition=\"{= bound(?softwareDependency) }\">
                <ui:group let:depictedResourceForDependency=\"{= edg:highestDepictionForSoftwareExecutable(?softwareDependency) }\">
                    <edg:MakeSingleViewFrameResourceOccurrence edg:resource=\"{= ?depictedResourceForDependency }\" edg:viewFrame=\"{= ?myViewFrame }\"/>
                    <edg:MakeViewFrameResourceNodeLink edg:dependencyType=\"{= ?dependencyType }\" edg:explanation=\"downstream software dependency\" edg:flow=\"{= ?flow }\" edg:id=\"{= str((?index + 1)) }\" edg:resource=\"{= ?myDepictedResource }\" edg:targetNode=\"{= ?depictedResourceForDependency }\" edg:targetViewFrame=\"{= ?myViewFrame }\" edg:viewFrame=\"{= ?mySourceViewFrame }\"/>
                    <ui:resourceView edg:breadth=\"{= ?myBreadth }\" edg:offset=\"{= ?myOffset }\" edg:reach=\"{= ?myReach }\" ui:matchIds=\"lineagegram-expansion-upstream\" ui:resource=\"{= ?softwareDependent }\"/>
                    <ui:group let:knownDependenciesDownstream=\"{= edg:GetViewFrameResourceNodePropertyValue(edg:hasKnownDependenciesDownstream, ?softwareDependency, ?myViewFrame) }\">
                        <ui:if ui:condition=\"{= ?reach &gt; 1 }\">
                            <ui:if ui:condition=\"{= (!bound(?knownDependenciesDownstream)) || (!?knownDependenciesDownstream) }\">
                                <ui:if ui:condition=\"{= ?activeResource != ?softwareDependency }\">
                                    <!-- To detect cyclic paths set the flag for 'known downstream dependencies before making the recursive call -->
                                    <edg:SetViewFrameResourceNodePropertyValue arg:property=\"{= edg:hasKnownDependenciesDownstream }\" arg:value=\"{= true }\" edg:resource=\"{= ?softwareDependency }\" edg:viewFrame=\"{= ?myViewFrame }\"/>
                                    <edg:DetermineTransitiveDownstreamSoftwareExecutableDependencies arg:depictedResource=\"{= ?depictedResourceForDependency }\" arg:traceabilityTemplate=\"{= ?traceabilityTemplate }\" edg:activeResource=\"{= ?softwareDependency }\" edg:breadth=\"{= ?myBreadth }\" edg:offset=\"{= 0 }\" edg:reach=\"{= IF(edg:isFlowline(?activeResource), ?reach, (?reach - 1)) }\" edg:sourceViewFrame=\"{= edg:VF_SoftwareFrame }\" edg:viewFrame=\"{= ?myViewFrame }\"/>
                                </ui:if>
                                <ui:else>
                                    <edg:MakeViewFrameResourceNodeLink edg:explanation=\"downstream dependency on self\" edg:resource=\"{= ?depictedResource }\" edg:targetNode=\"{= ?depictedResource }\" edg:targetViewFrame=\"{= ?myViewFrame }\" edg:viewFrame=\"{= ?myViewFrame }\"/>
                                </ui:else>
                            </ui:if>
                        </ui:if>
                        <ui:else>
                            <!--ui:dumpScope ui:message=\"AAA2 edg:DetermineTransitiveDownstreamSoftwareExecutableDependencies - {= ?activeResource }\"/-->
                            <ui:call arg:resource=\"{= ?softwareDependency }\" ui:template=\"{= ?traceabilityTemplate }\" ui:varName=\"moreDownstreamDependencies\">
                                <ui:group let:moreDownstream=\"{= !spr:isEmpty(?moreDownstreamDependencies) }\">
                                    <ui:if ui:condition=\"{= ?moreDownstream }\">
                                        <edg:MakeViewFrameDownstreamPlaceholderNodeAndLinks edg:breadth=\"{= ?myBreadth }\" edg:continuation=\"{= edg:DetermineDownstreamDependenciesForResource }\" edg:dependencyType=\"{= edg:DEPTYPE_MORE-DOWNSTREAM }\" edg:explanation=\"DetermineTransitiveDownstreamSoftwareExecutableDependencies - out of reach\" edg:hasMoreDownstream=\"{= true }\" edg:offset=\"{= ?myOffset }\" edg:outOfReach=\"{= true }\" edg:placeholderType=\"{= edg:PlaceholderForMoreDownstream }\" edg:resource=\"{= ?depictedResourceForDependency }\" edg:targetViewFrame=\"{= ?myViewFrame }\" edg:viewFrame=\"{= ?myViewFrame }\"/>
                                        <edg:SetViewFrameResourceNodePropertyValue arg:property=\"{= edg:hasMoreDownstream }\" arg:value=\"{= true }\" edg:resource=\"{= ?depictedResourceForDependency }\" edg:viewFrame=\"{= ?myViewFrame }\"/>
                                    </ui:if>
                                </ui:group>
                            </ui:call>
                        </ui:else>
                    </ui:group>
                </ui:group>
            </ui:elseif>
        </ui:forEach>
    </ui:call>
    <ui:call arg:resource=\"{= ?activeResource }\" ui:limit=\"{= ?myBreadth }\" ui:offset=\"{= ?myOffset + ?myBreadth }\" ui:template=\"{= ?traceabilityTemplate }\" ui:varName=\"maybeMoreFanoutResults\">
        <edg:DetermineNeedForMoreFanOutPlaceholderNode arg:resource=\"{= ?activeResource }\" arg:resultSet=\"{= ?maybeMoreFanoutResults }\" edg:breadth=\"{= ?myBreadth }\" edg:explanation=\"DetermineTransitiveDownstreamSoftwareExecutableDependencies\" edg:offset=\"{= ?myOffset }\" edg:targetViewFrame=\"{= ?mySourceViewFrame }\" edg:viewFrame=\"{= ?mySourceViewFrame }\"/>
    </ui:call>
    <edg:DetermineNeedForDownstreamPlaceholderNode arg:dependencyTemplate=\"{= ?traceabilityTemplate }\" arg:resource=\"{= ?activeResource }\" edg:breadth=\"{= ?myBreadth }\" edg:dependencyType=\"{= edg:DEPTYPE_MORE-FANOUT }\" edg:explanation=\"DetermineTransitiveDownstreamSoftwareExecutableDependencies\" edg:offset=\"{= 0 }\" edg:placeholderType=\"{= edg:PlaceholderForMoreFanout }\" edg:viewFrame=\"{= ?mySourceViewFrame }\" provo:wasGeneratedBy=\"{= edg:DetermineTransitiveDownstreamSoftwareExecutableDependencies }\"/>
</ui:group>
"""^^ui:Literal ;
  ui:responseType ui:JSON ;
  rdfs:comment "Builds transitive dependency graph for software executables." ;
  rdfs:label "Determine transitive downstream software executable dependencies" ;
  rdfs:seeAlso edg:DetermineTransitiveUpstreamSoftwareExecutableDependencies ;
  rdfs:seeAlso edg:GetDownstreamDependents ;
  rdfs:subClassOf edg:LineageGramServices ;
.
edg:DetermineTransitiveUpstreamSoftwareExecutableDependencies
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate edg:maxTierNodeCount ;
      spl:valueType xsd:integer ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate edg:targetViewFrame ;
      spl:valueType edg:ViewFrame ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:depictedResource ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate edg:activeResource ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate edg:breadth ;
      spl:valueType xsd:integer ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate edg:maxBreadth ;
      spl:valueType xsd:integer ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate edg:offset ;
      spl:valueType xsd:integer ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate edg:reach ;
      spl:valueType xsd:integer ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:iteration ;
      spl:valueType xsd:integer ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:traceabilityTemplate ;
      spl:valueType spin:Template ;
    ] ;
  ui:prototype """
<ui:group let:myActiveResource=\"{= ?activeResource }\" let:myBreadth=\"{= COALESCE(?breadth, 10) }\" let:myMaxTierNodeCount=\"{= COALESCE(?maxTierNodeCount, 20) }\" let:myOffset=\"{= COALESCE(?offset, 0) }\" let:myTraceabilityTemplate=\"{= COALESCE(?traceabilityTemplate, edg:GetUpstreamDependencies) }\" let:myViewFrame=\"{= COALESCE(?targetViewFrame, edg:VF_SoftwareFrame) }\">
    <ui:group let:depictedSoftware=\"{= COALESCE(?depictedResource, edg:highestDepictionForSoftwareExecutable(?myActiveResource), ?myActiveResource) }\">
        <!--ui:dumpScope ui:message=\"AAA1: edg:DetermineTransitiveUpstreamSoftwareExecutableDependencies - {= ui:label(?myActiveResource) }\"/-->
        <ui:if ui:condition=\"{= !bound(?myActiveResource) }\">
            <ui:throw ui:message=\"No active resource provided in edg:DetermineTransitiveUpstreamSoftwareExecutableDependencies\"/>
        </ui:if>
        <ui:call arg:resource=\"{= ?myActiveResource }\" ui:limit=\"{= ?myBreadth }\" ui:offset=\"{= ?myOffset }\" ui:template=\"{= ?myTraceabilityTemplate }\" ui:varName=\"upstreamDependencies\">
            <ui:group let:dependencies=\"{= spr:rowCount(?upstreamDependencies) }\">
                <ui:group let:nextBreadth=\"{= edg:constrainBreadth(?maxBreadth, ?myMaxTierNodeCount, ?dependencies) }\">
                    <!--ui:dumpResultSet ui:message=\"AAA2: edg:DetermineTransitiveUpstreamSoftwareExecutableDependencies - {= ui:label(?activeResource) }\"
                          ui:resultSet=\"{= ?upstreamDependencies }\"/-->
                    <ui:if ui:condition=\"{= !spr:isEmpty(?upstreamDependencies) }\">
                        <ui:forEach ui:indexVar=\"index\" ui:resultSet=\"{= ?upstreamDependencies }\">
                            <ui:group let:depictedUpstreamSoftware=\"{= edg:highestDepictionForSoftwareExecutable(?softwareDependency) }\">
                                <!--ui:dumpScope ui:message=\"AAA3: edg:DetermineTransitiveUpstreamSoftwareExecutableDependencies - {= ui:label(?softwareDependency) }\"/-->
                                <!-- the 'activeExecutable' is the lowest level component of the 'myActiveResource'-->
                                <!-- when we show the derivation map we will need to show this and get all its parentage -->
                                <edg:SetViewFrameResourceNodePropertyValue arg:property=\"{= edg:activeExecutable }\" arg:value=\"{= ?activeExecutable }\" edg:resource=\"{= ?myActiveResource }\" edg:viewFrame=\"{= ?myViewFrame }\"/>
                                <!-- the new 'activeResource' is the source of a data element that is needed by the 'activeExecutable' of the previous 'activeResource' -->
                                <edg:MakeSingleViewFrameResourceOccurrence edg:activeResource=\"{= ?softwareDependency }\" edg:explanation=\"Iteration: {= ?iteration }, Offset: {= ?myOffset }, Index: {= ?index }, breadth: {= ?myBreadth }, activeExecutable: {= ?activeExecutable }, depictedUpstreamSoftware: {= ?depictedUpstreamSoftware }, next breadth: {= ?nextBreadth }\" edg:resource=\"{= ?depictedUpstreamSoftware }\" edg:viewFrame=\"{= edg:VF_SoftwareFrame }\"/>
                                <edg:MakeViewFrameResourceNodeLink edg:dependencyType=\"{= ?dependencyType }\" edg:explanation=\"{= ?depictedSoftware } depends on {= str(?softwareDependency) }\" edg:flow=\"{= str(?flowCount) }\" edg:id=\"{= str((?index + 1)) }\" edg:resource=\"{= ?depictedUpstreamSoftware }\" edg:targetNode=\"{= ?depictedSoftware }\" edg:targetViewFrame=\"{= ?myViewFrame }\" edg:viewFrame=\"{= edg:VF_SoftwareFrame }\"/>
                                <!--look for logical and physical flows -->
                                <ui:call arg:resource=\"{= ?activeResource }\" arg:upstreamResource=\"{= ?softwareDependency }\" ui:template=\"{= edg:GetUpstreamInteroperableFlowDependencies }\" ui:varName=\"upstreamFlows\">
                                    <!--ui:dumpResultSet ui:message=\"AAA3: edg:DetermineTransitiveUpstreamSoftwareExecutableDependencies- {= ?activeResource } to  {= ?softwareDependency }\"
  ui:resultSet=\"{= ?upstreamFlows }\"/-->
                                    <edg:CompleteUpstreamPhysicalFlows arg:resource=\"{= ?activeResource }\" arg:resultSet=\"{= ?upstreamFlows }\" arg:upstreamResource=\"{= ?depictedUpstreamSoftware }\" edg:targetNode=\"{= ?resource }\" edg:targetViewFrame=\"{= ?myViewFrame }\" edg:viewFrame=\"{= ?myViewFrame }\"/>
                                </ui:call>
                                <ui:if ui:condition=\"{= ?reach &gt; 1 }\">
                                    <ui:group let:knownDependenciesUpstream=\"{= edg:GetViewFrameResourceNodePropertyValue(edg:hasKnownDependenciesUpstream, ?depictedUpstreamSoftware, edg:VF_SoftwareFrame) }\">
                                        <ui:if ui:condition=\"{= (!bound(?knownDependenciesUpstream)) || (!?knownDependenciesUpstream) }\">
                                            <ui:if ui:condition=\"{= ?activeResource != ?softwareDependency }\">
                                                <!-- To detect cyclic paths set the flag for 'known upstream dependencies before making the recursive call-->
                                                <!--ui:dumpScope ui:message=\"AAA3: edg:DetermineTransitiveUpstreamSoftwareExecutableDependencies - {= ui:label(?softwareDependency) }\"/-->
                                                <edg:SetViewFrameResourceNodePropertyValue arg:property=\"{= edg:hasKnownDependenciesUpstream }\" arg:value=\"{= true }\" edg:resource=\"{= ?depictedUpstreamSoftware }\" edg:viewFrame=\"{= ?myViewFrame }\"/>
                                                <edg:DetermineTransitiveUpstreamSoftwareExecutableDependencies arg:iteration=\"{= ?iteration + 1 }\" arg:traceabilityTemplate=\"{= ?traceabilityTemplate }\" edg:activeResource=\"{= ?softwareDependency }\" edg:breadth=\"{= ?nextBreadth }\" edg:maxBreadth=\"{= ?maxBreadth }\" edg:maxTierNodeCount=\"{= ?myMaxTierNodeCount }\" edg:offset=\"{= 0 }\" edg:reach=\"{= IF(edg:isFlowline(?activeResource), ?reach, (?reach - 1)) }\"/>
                                            </ui:if>
                                            <ui:else>
                                                <edg:MakeViewFrameResourceNodeLink edg:dependencyType=\"{= ?dependencyType }\" edg:explanation=\"Upstream dependency analyzed already for {= str(?softwareDependency) }\" edg:resource=\"{= ?depictedUpstreamSoftware }\" edg:targetNode=\"{= ?activeResource }\" edg:targetViewFrame=\"{= ?myViewFrame }\" edg:viewFrame=\"{= ?myViewFrame }\"/>
                                            </ui:else>
                                        </ui:if>
                                    </ui:group>
                                </ui:if>
                                <ui:elseif ui:condition=\"{= ?reach = 1 }\">
                                    <ui:call arg:resource=\"{= ?softwareDependency }\" ui:template=\"{= ?myTraceabilityTemplate }\" ui:varName=\"moreUpstreamDependencies\">
                                        <ui:group let:moreUpstream=\"{= !spr:isEmpty(?moreUpstreamDependencies) }\">
                                            <ui:if ui:condition=\"{= ?moreUpstream }\">
                                                <edg:MakeViewFrameUpstreamPlaceholderNodeAndLinks edg:breadth=\"{= ?myBreadth }\" edg:continuation=\"{= edg:UpstreamSoftwareContinuationService }\" edg:dependencyType=\"{= edg:DEPTYPE_MORE-UPSTREAM }\" edg:explanation=\"Iteration: {= ?iteration }, dependencies: {= spr:rowCount(?moreUpstreamDependencies) }, next breadth: {= ?nextBreadth }\" edg:hasMoreUpstream=\"{= true }\" edg:offset=\"{= ?myOffset }\" edg:outOfReach=\"{= true }\" edg:placeholderType=\"{= edg:PlaceholderForMoreUpstream }\" edg:resource=\"{= ?depictedUpstreamSoftware }\" edg:targetViewFrame=\"{= ?myViewFrame }\" edg:viewFrame=\"{= ?myViewFrame }\" provo:wasGeneratedBy=\"{= edg:DetermineTransitiveUpstreamSoftwareExecutableDependencies }\"/>
                                                <edg:SetViewFrameResourceNodePropertyValue arg:property=\"{= edg:hasMoreUpstream }\" arg:value=\"{= true }\" edg:resource=\"{= ?depictedUpstreamSoftware }\" edg:viewFrame=\"{= ?myViewFrame }\"/>
                                            </ui:if>
                                        </ui:group>
                                    </ui:call>
                                </ui:elseif>
                            </ui:group>
                        </ui:forEach>
                    </ui:if>
                    <ui:else>
                        <!--ui:dumpScope ui:message=\"AAA4: edg:DetermineTransitiveUpstreamSoftwareExecutableDependencies - {= ?activeResource }\"/-->
                        <!-- mark software as first stage software -->
                        <edg:SetViewFrameResourceNodePropertyValue arg:property=\"{= edg:hasMoreUpstream }\" arg:value=\"{= false }\" edg:resource=\"{= ?depictedSoftware }\" edg:viewFrame=\"{= ?myViewFrame }\"/>
                    </ui:else>
                </ui:group>
            </ui:group>
        </ui:call>
        <edg:DetermineNeedForMoreFanInPlaceholderNode arg:dependencyTemplate=\"{= ?myTraceabilityTemplate }\" arg:resource=\"{= ?activeResource }\" edg:breadth=\"{= ?myBreadth }\" edg:explanation=\"Placeholder needed at iteration: {= ?iteration }\" edg:offset=\"{= ?myOffset }\" edg:targetViewFrame=\"{= ?myViewFrame }\" edg:viewFrame=\"{= ?myViewFrame }\"/>
    </ui:group>
</ui:group>
"""^^ui:Literal ;
  ui:responseType ui:JSON ;
  rdfs:comment "Recurses over all dependency constructs of an app return a list of apps. The recursion is limited to a specific reach defined by the parameter 'reach'.  The \"breadth\" parameter limits the exploratiom of fan-in. To explore fan-in an additional API parameter will be needed for offset and the upstream node to apply it to." ;
  rdfs:isDefinedBy <http://edg.topbraid.solutions/1.0/diagram/lg/library-common> ;
  rdfs:label "Determine transitive upsream software executable dependencies" ;
  rdfs:seeAlso edg:DetermineTransitiveDownstreamSoftwareExecutableDependencies ;
  rdfs:seeAlso edg:GetUpstreamDependencies ;
  rdfs:subClassOf edg:LineageGramServices ;
.
edg:FeedlineToInteroperableDestinationDetails
  a ui:Service ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:leftNode ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:rightNode ;
      spl:valueType rdfs:Resource ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:group>
    <ui:group let:feedlineOutputData=\"{= spl:object(?leftNode, edg:output) }\" let:source=\"{= spl:subject(edg:outgoingFlow, ?leftNode) }\">
        <swon:Object>
            <swon:Value arg:name=\"nodes\">
                <swon:Array>
                    <edg:BuildJSONforLineageGramNode arg:label=\"{= edg:MakeNodeLabel(?leftNode) }\" arg:node=\"{= ?leftNode }\"/>
                    <edg:BuildJSONforLineageGramNode arg:label=\"{= edg:MakeNodeLabel(?rightNode) }\" arg:node=\"{= ?rightNode }\"/>
                    <ui:forEach ui:resultSet=\"{#
                            SELECT ?feedlineInputData
                            WHERE {
                                ?leftNode edg:input ?feedlineInputData .
                            } }\">
                        <edg:BuildJSONforLineageGramNode arg:label=\"{= edg:MakeNodeLabel(?feedlineInputData) }\" arg:node=\"{= ?feedlineInputData }\" arg:parent=\"{= IF(bound(?feedlineOutputData), ?feedlineOutputData, ?leftNode) }\"/>
                    </ui:forEach>
                    <ui:if ui:condition=\"{= bound(?feedlineOutputData) }\">
                        <edg:BuildJSONforLineageGramNode arg:label=\"{= CONCAT(&quot;PAYLOAD: &quot;, ui:label(?feedlineOutputData)) }\" arg:node=\"{= ?feedlineOutputData }\" arg:parent=\"{= ?leftNode }\"/>
                    </ui:if>
                    <ui:if ui:condition=\"{= bound(?source) }\">
                        <edg:BuildJSONforLineageGramNode arg:label=\"{= edg:MakeNodeLabel(?source) }\" arg:node=\"{= ?source }\"/>
                    </ui:if>
                </swon:Array>
            </swon:Value>
            <swon:Value arg:name=\"edges\">
                <swon:Array>
                    <edg:BuildJSONforDerviationMapLink arg:label=\"destination\" arg:leftNode=\"{= str(?leftNode) }\" arg:property=\"{= edg:incomingFeed }\" arg:rightNode=\"{= ?rightNode }\"/>
                    <ui:forEach ui:resultSet=\"{#
                            SELECT ?feedlineInputData
                            WHERE {
                                ?leftNode edg:input ?feedlineInputData .
                            } }\">
                        <edg:BuildJSONforDerviationMapLink arg:leftNode=\"{= ?feedlineInputData }\" arg:property=\"{= edg:input }\" arg:rightNode=\"{= ?leftNode }\"/>
                    </ui:forEach>
                    <ui:if ui:condition=\"{= bound(?feedlineOutputData) }\">
                        <edg:BuildJSONforDerviationMapLink arg:leftNode=\"{= ?leftNode }\" arg:property=\"{= edg:output }\" arg:rightNode=\"{= ?feedlineOutputData }\"/>
                    </ui:if>
                    <ui:if ui:condition=\"{= bound(?source) }\">
                        <edg:BuildJSONforDerviationMapLink arg:label=\"source for\" arg:leftNode=\"{= ?source }\" arg:property=\"{= edg:outgoingFlow }\" arg:rightNode=\"{= ?leftNode }\"/>
                    </ui:if>
                </swon:Array>
            </swon:Value>
        </swon:Object>
    </ui:group>
</ui:group>
"""^^ui:Literal ;
  ui:responseType ui:JSON ;
  rdfs:isDefinedBy <http://edg.topbraid.solutions/1.0/diagram/lg/library-common> ;
  rdfs:label "Feedline to interoperable destination details" ;
  rdfs:subClassOf edg:DerivationMapServices ;
.
edg:Flow
  ui:instanceView """
<ui:group ui:id=\"derivation-map-data-service-other-node\" ui:priority=\"{= 10 }\">
    <edg:FeedlineToInteroperableDestinationDetails arg:leftNode=\"{= ?leftNode }\" arg:rightNode=\"{= ?rightNode }\"/>
</ui:group>
"""^^ui:Literal ;
  ui:instanceView """
<ui:group ui:id=\"derivation-map-data-service\" ui:priority=\"{= 10 }\">
    <ui:resourceView arg:leftNode=\"{= ?leftNode }\" arg:rightNode=\"{= ?this }\" ui:matchIds=\"derivation-map-other-node-for-feedline-data-service\" ui:resource=\"{= ?leftNode }\"/>
</ui:group>
"""^^ui:Literal ;
  ui:instanceView """
<ui:group ui:id=\"derivation-map-other-node-for-feedline-data-service\" ui:priority=\"{= 10 }\">
    <!-- currently 'more' nodes cause a callback where the left and right nodes are the same -->
    <edg:MoreUpstreamDerivationMapService arg:node=\"{= ?rightNode }\" arg:placeholder=\"{= edg:PlaceholderForMoreUpstream }\"/>
</ui:group>
"""^^ui:Literal ;
.
edg:GenerateContainerForResourceAndProperty
  a ui:Service ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:class ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdf:Property ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:text ;
      spl:valueType xsd:string ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:group>
    <ui:call arg:class=\"{= ?class }\" arg:property=\"{= ?property }\" arg:resource=\"{= ?resource }\" ui:template=\"{= edg:getPropertyValuesForResource }\" ui:varName=\"results\">
        <ui:if ui:condition=\"{= !spr:isEmpty(?results) }\">
            <ui:group let:container=\"CONTAINER_{= ui:uniqueId() }\">
                <edg:BuildJSONforLineageGramNode arg:collapsed=\"{= true }\" arg:icon=\"fa fa-map\" arg:label=\"{= ?text }\" arg:node=\"{= ?container }\" arg:parent=\"{= ?resource }\"/>
                <ui:forEach ui:resultSet=\"{= ?results }\">
                    <ui:group let:occurrence=\"{= CONCAT(&quot;~~&quot;, spif:camelCase(?label)) }\">
                        <edg:BuildJSONforLineageGramNode arg:label=\"{= ?label }\" arg:node=\"{= ?value }\" arg:occurrence=\"{= ?occurrence }\" arg:parent=\"{= ?container }\"/>
                    </ui:group>
                </ui:forEach>
            </ui:group>
        </ui:if>
    </ui:call>
</ui:group>
"""^^ui:Literal ;
  ui:responseType ui:JSON ;
  rdfs:isDefinedBy <http://edg.topbraid.solutions/1.0/diagram/lg/software> ;
  rdfs:label "Generate container for resource and property" ;
  rdfs:subClassOf edg:DerivationMapServices ;
.
edg:GenerateDataflowNodes
  a ui:Service ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate edg:flow ;
      spl:valueType edg:Flow ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate edg:source ;
      spl:valueType edg:ServiceEndpoint ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate edg:target ;
      spl:valueType edg:ServiceEndpoint ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:leftNode ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:parent ;
      spl:valueType xsd:string ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:rightNode ;
      spl:valueType rdfs:Resource ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:group let:sourceDirectMappings=\"SourceDirectMappings_{= ui:uniqueId() }\" let:sourceDirectMappingsCollection=\"{= spl:object(?source, edg:mappingsCollection) }\" let:targetDirectMappings=\"TargetDirectMappings_{= ui:uniqueId() }\" let:targetDirectMappingsCollection=\"{= spl:object(?target, edg:mappingsCollection) }\">
    <ui:resourceView arg:leftNode=\"{= ?leftNode }\" arg:rightNode=\"{= ?rightNode }\" ui:matchIds=\"derivation-map-composite-node\" ui:resource=\"{= ?leftNode }\"/>
    <ui:resourceView arg:leftNode=\"{= ?leftNode }\" arg:rightNode=\"{= ?rightNode }\" ui:matchIds=\"derivation-map-composite-node\" ui:resource=\"{= ?rightNode }\"/>
    <edg:BuildJSONforLineageGramNode arg:collapsed=\"{= true }\" arg:label=\"{= CONCAT(&quot;Data Flow: &quot;, ui:label(?flow)) }\" arg:node=\"{= ?flow }\" arg:parent=\"{= ?parent }\"/>
    <ui:call arg:class=\"{= edg:LogicalFlow }\" arg:property=\"{= edg:realizedAs }\" arg:resource=\"{= ?flow }\" ui:template=\"{= edg:getSubjectsForGivenPropertyAndObject }\" ui:varName=\"logicalFlows\">
        <ui:if ui:condition=\"{= !spr:isEmpty(?logicalFlows) }\">
            <ui:group let:logicalFlowsContainer=\"LFLOWS_{= ui:uniqueId() }\">
                <edg:BuildJSONforLineageGramNode arg:collapsed=\"{= true }\" arg:icon=\"fa fa-map\" arg:label=\"Implements Logical Flows\" arg:node=\"{= ?logicalFlowsContainer }\" arg:parent=\"{= ?flow }\"/>
                <ui:forEach ui:resultSet=\"{= ?logicalFlows }\">
                    <ui:group let:logicalFlowOccurrence=\"{= CONCAT(&quot;~~&quot;, spif:camelCase(?label)) }\">
                        <edg:BuildJSONforLineageGramNode arg:label=\"{= ?label }\" arg:node=\"{= ?value }\" arg:occurrence=\"{= ?logicalFlowOccurrence }\" arg:parent=\"{= ?logicalFlowsContainer }\"/>
                    </ui:group>
                </ui:forEach>
            </ui:group>
        </ui:if>
    </ui:call>
    <edg:GenerateContainerForResourceAndProperty arg:class=\"{= edg:DataPackage }\" arg:property=\"{= edg:transfersPackage }\" arg:resource=\"{= ?flow }\" arg:text=\"Transferred Data Packages\"/>
    <ui:if ui:condition=\"{= bound(?source) }\">
        <edg:BuildJSONforLineageGramNode arg:label=\"{= CONCAT(&quot;Endpoint: &quot;, ui:label(?source)) }\" arg:node=\"{= ?source }\" arg:parent=\"{= ?leftNode }\"/>
        <ui:if ui:condition=\"{= bound(?sourceDirectMappingsCollection) }\">
            <ui:call arg:resource=\"{= ?sourceDirectMappingsCollection }\" ui:template=\"{= edg:getDirectMappings }\" ui:varName=\"sourceMappings\">
                <edg:BuildJSONforLineageGramNode arg:collapsed=\"{= true }\" arg:icon=\"fa fa-map\" arg:label=\"Direct Mappings - [{= spr:rowCount(?sourceMappings) }]\" arg:node=\"{= ?sourceDirectMappingsCollection }\" arg:parent=\"{= ?source }\"/>
                <ui:forEach ui:resultSet=\"{= ?sourceMappings }\">
                    <edg:BuildJSONforLineageGramNode arg:node=\"{= spl:object(?mapping, edg:output) }\" arg:parent=\"{= ?sourceDirectMappingsCollection }\"/>
                </ui:forEach>
            </ui:call>
        </ui:if>
    </ui:if>
    <ui:if ui:condition=\"{= bound(?target) }\">
        <edg:BuildJSONforLineageGramNode arg:label=\"{= CONCAT(&quot;Endpoint: &quot;, ui:label(?target)) }\" arg:node=\"{= ?target }\" arg:parent=\"{= ?rightNode }\"/>
        <ui:if ui:condition=\"{= bound(?targetDirectMappingsCollection) }\">
            <ui:call arg:resource=\"{= ?targetDirectMappingsCollection }\" ui:template=\"{= edg:getDirectMappings }\" ui:varName=\"targetMappings\">
                <edg:BuildJSONforLineageGramNode arg:collapsed=\"{= true }\" arg:icon=\"fa fa-map\" arg:label=\"Direct Mappings - [{= spr:rowCount(?targetMappings) }]\" arg:node=\"{= ?targetDirectMappingsCollection }\" arg:parent=\"{= ?target }\"/>
                <ui:forEach ui:resultSet=\"{= ?targetMappings }\">
                    <edg:BuildJSONforLineageGramNode arg:node=\"{= spl:object(?mapping, edg:output) }\" arg:parent=\"{= ?targetDirectMappingsCollection }\"/>
                </ui:forEach>
            </ui:call>
        </ui:if>
    </ui:if>
</ui:group>
"""^^ui:Literal ;
  ui:responseType ui:JSON ;
  rdfs:isDefinedBy <http://edg.topbraid.solutions/1.0/diagram/lg/software> ;
  rdfs:label "Generate Dataflow Nodes" ;
  rdfs:subClassOf edg:DerivationMapServices ;
.
edg:GenerateJSONforCompositeFlows
  a ui:Service ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate edg:linkType ;
      spl:valueType xsd:string ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:leftNode ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resultSet ;
      spl:valueType spr:Table ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:rightNode ;
      spl:valueType rdfs:Resource ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:group let:flowContainer=\"FLOWS_{= ui:uniqueId() }\" let:flowContainerName=\"{= IF((?linkType = &quot;logical-flow&quot;), &quot;Logical Flows&quot;, &quot;Data Flows&quot;) }\">
    <swon:Object>
        <swon:Value arg:name=\"nodes\">
            <swon:Array>
                <edg:BuildJSONforLineageGramNode arg:collapsed=\"{= true }\" arg:icon=\"fa fa-object-group\" arg:label=\"{= CONCAT(?flowContainerName, &quot; [&quot;, str(spr:rowCount(?resultSet)), &quot;]&quot;) }\" arg:node=\"{= ?flowContainer }\"/>
                <ui:forEach ui:resultSet=\"{= ?resultSet }\">
                    <ui:if ui:condition=\"{= ?flowType = edg:Feedline }\">
                        <edg:FeedlineToInteroperableDestinationDetails arg:leftNode=\"{= spl:object(?rightNode, edg:incomingFlow) }\" arg:rightNode=\"{= ?rightNode }\"/>
                    </ui:if>
                    <ui:elseif ui:condition=\"{= (?flowType = edg:LogicalFlow) &amp;&amp; (?linkType = &quot;logical-flow&quot;) }\">
                        <edg:GenerateLogicalFlowNodes arg:leftNode=\"{= ?leftNode }\" arg:parent=\"{= ?flowContainer }\" arg:rightNode=\"{= ?rightNode }\" edg:flow=\"{= ?flow }\"/>
                    </ui:elseif>
                    <ui:elseif ui:condition=\"{= ?flowType = edg:Dataflow }\">
                        <edg:GenerateDataflowNodes arg:leftNode=\"{= ?leftNode }\" arg:parent=\"{= ?flowContainer }\" arg:rightNode=\"{= ?rightNode }\" edg:flow=\"{= ?flow }\" edg:source=\"{= ?sourceEndpoint }\" edg:target=\"{= ?targetEndpoint }\"/>
                    </ui:elseif>
                </ui:forEach>
            </swon:Array>
        </swon:Value>
        <swon:Value arg:name=\"edges\">
            <swon:Array>
                <edg:GenerateJSONforDerivationMapLinks arg:leftNode=\"{= ?leftNode }\" arg:rightNode=\"{= ?rightNode }\"/>
                <edg:BuildJSONforDerviationMapLink arg:label=\"source\" arg:leftNode=\"{= ?flowContainer }\" arg:rightNode=\"{= ?leftNode }\"/>
                <edg:BuildJSONforDerviationMapLink arg:label=\"target\" arg:leftNode=\"{= ?flowContainer }\" arg:rightNode=\"{= ?rightNode }\"/>
                <!--ui:forEach ui:resultSet=\"{= ?resultSet }\">
<ui:if ui:condition=\"{= ?flowType = edg:Feedline }\">
<edg:FeedlineToInteroperableDestinationDetails arg:leftNode=\"{= spl:object(?rightNode, edg:incomingFlow) }\"
   arg:rightNode=\"{= ?rightNode }\"/>
</ui:if>
<ui:elseif ui:condition=\"{= ?flowType = edg:Dataflow }\">
<edg:DataflowEdges arg:leftNode=\"{= ?leftNode }\"
   arg:rightNode=\"{= ?rightNode }\"
   edg:flow=\"{= ?flowElement }\"
   edg:source=\"{= COALESCE(?sourceEndpoint, ?leftNode) }\"
   edg:target=\"{= COALESCE(?targetEndpoint, ?rightNode) }\"/>
</ui:elseif>
<ui:elseif ui:condition=\"{= ?flowType = edg:LogicalFlow }\">
<edg:LogicalFlowEdges arg:leftNode=\"{= ?leftNode }\"
  arg:rightNode=\"{= ?rightNode }\"
  edg:flow=\"{= ?flowElement }\"/>
</ui:elseif>
</ui:forEach-->
            </swon:Array>
        </swon:Value>
    </swon:Object>
</ui:group>
"""^^ui:Literal ;
  ui:responseType ui:JSON ;
  rdfs:isDefinedBy <http://edg.topbraid.solutions/1.0/diagram/lg/software> ;
  rdfs:label "Generate JSON for composite flows" ;
  rdfs:subClassOf edg:DerivationMapServices ;
.
edg:GenerateJSONforDeepExecutables
  a ui:Service ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:leftNode ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resultSet ;
      spl:valueType spr:Table ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:rightNode ;
      spl:valueType rdfs:Resource ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:group>
    <swon:Object>
        <ui:if ui:condition=\"{= ?leftNode = ?rightNode }\">
            <edg:GenerateJSONforSoftwareExecutableSelfDependencyNodes arg:dataCoupling=\"{= ?dataCoupling }\" arg:functionalCoupling=\"{= ?functionalCoupling }\" arg:node=\"{= ?leftNode }\" arg:resultSet=\"{= ?resultSet }\"/>
            <edg:GenerateJSONforSoftwareExecutableSelfDependencyEdges arg:dataCoupling=\"{= ?dataCoupling }\" arg:functionalCoupling=\"{= ?functionalCoupling }\" arg:node=\"{= ?leftNode }\" arg:resultSet=\"{= ?resultSet }\"/>
        </ui:if>
        <ui:else>
            <edg:GenerateJSONforSoftwareExecutableToSoftwareExecutableDependencyNodes arg:dataCoupling=\"{= ?dataCoupling }\" arg:functionalCoupling=\"{= ?functionalCoupling }\" arg:leftNode=\"{= ?leftNode }\" arg:resultSet=\"{= ?resultSet }\" arg:rightNode=\"{= ?rightNode }\"/>
            <edg:GenerateJSONforSoftwareExecutableToSoftwareExecutableDependencyEdges arg:dataCoupling=\"{= ?dataCoupling }\" arg:functionalCoupling=\"{= ?functionalCoupling }\" arg:leftNode=\"{= ?leftNode }\" arg:resultSet=\"{= ?resultSet }\" arg:rightNode=\"{= ?rightNode }\"/>
        </ui:else>
    </swon:Object>
</ui:group>
"""^^ui:Literal ;
  ui:responseType ui:JSON ;
  rdfs:isDefinedBy <http://edg.topbraid.solutions/1.0/diagram/lg/software> ;
  rdfs:label "Generate JSON for deep executables" ;
  rdfs:subClassOf edg:DerivationMapServices ;
.
edg:GenerateJSONforExecutableEnablements
  a ui:Service ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate edg:linkType ;
      spl:valueType xsd:string ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:leftNode ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:rightNode ;
      spl:valueType rdfs:Resource ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:group>
    <!--ui:dumpScope ui:message=\"AAA1 - edg:GenerateJSONforExecutableEnablements\"/-->
    <ui:if ui:condition=\"{= EXISTS {
        ?leftNode (edg:supportsBusinessActivity|edg:supportsBusinessFunction)|edg:enablesBusinessCapability ?rightNode .
    } }\">
        <!--ui:dumpScope ui:message=\"AAA2 - edg:GenerateJSONforExecutableEnablements\"/-->
        <swon:Object>
            <swon:Value arg:name=\"nodes\">
                <swon:Array>
                    <ui:resourceView ui:matchIds=\"derivation-map-composite-node\" ui:resource=\"{= ?leftNode }\"/>
                    <ui:resourceView ui:matchIds=\"derivation-map-composite-node\" ui:resource=\"{= ?rightNode }\"/>
                </swon:Array>
            </swon:Value>
            <swon:Value arg:name=\"edges\">
                <swon:Array>
                    <edg:BuildJSONforDerviationMapLink arg:explanation=\"edg:GenerateJSONforExecutableEnablements\" arg:label=\"{= ?linkType }\" arg:leftNode=\"{= ?leftNode }\" arg:rightNode=\"{= ?rightNode }\"/>
                    <edg:GenerateJSONforDerivationMapLinks arg:leftNode=\"{= ?leftNode }\" arg:rightNode=\"{= ?rightNode }\"/>
                </swon:Array>
            </swon:Value>
        </swon:Object>
    </ui:if>
</ui:group>
"""^^ui:Literal ;
  ui:responseType ui:JSON ;
  rdfs:isDefinedBy <http://edg.topbraid.solutions/1.0/diagram/lg/software> ;
  rdfs:label "Generate JSON for executable enablements" ;
  rdfs:subClassOf edg:DerivationMapServices ;
.
edg:GenerateJSONforExecutableSupportsActivity
  a ui:Service ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate edg:linkType ;
      spl:valueType xsd:string ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:leftNode ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:rightNode ;
      spl:valueType rdfs:Resource ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:group>
    <!--ui:dumpScope ui:message=\"AAA1 - edg:GenerateJSONforEnablementDependencies\"/-->
    <ui:call arg:leftNode=\"{= ?leftNode }\" arg:rightNode=\"{= ?rightNode }\" ui:template=\"{= edg:GetnInformationAssetDependencyDetails }\" ui:varName=\"informationAssetDetails\">
        <ui:if ui:condition=\"{= !spr:isEmpty(?informationAssetDetails) }\">
            <!--ui:dumpResultSet ui:message=\"AAA3 - edg:BusinessApplication -  {= ?leftNode }\"
  ui:resultSet=\"{= ?informationAssetDetails }\"/-->
            <edg:GenerateJSONforInformationAssetDependencies arg:leftNode=\"{= ?leftNode }\" arg:resultSet=\"{= ?informationAssetDetails }\" arg:rightNode=\"{= ?rightNode }\"/>
        </ui:if>
        <ui:elseif ui:condition=\"{= EXISTS {
            ?leftNode edg:supportsBusinessActivity ?rightNode .
        } }\">
            <!--ui:dumpScope ui:message=\"AAA2 - edg:GenerateJSONforEnablementDependencies\"/-->
            <swon:Object>
                <swon:Value arg:name=\"nodes\">
                    <swon:Array>
                        <edg:BuildJSONforLineageGramNode arg:label=\"{= edg:MakeNodeLabel(?leftNode) }\" arg:node=\"{= ?leftNode }\"/>
                        <edg:BuildJSONforLineageGramNode arg:label=\"{= edg:MakeNodeLabel(?rightNode) }\" arg:node=\"{= ?rightNode }\"/>
                    </swon:Array>
                </swon:Value>
                <swon:Value arg:name=\"edges\">
                    <swon:Array>
                        <edg:BuildJSONforDerviationMapLink arg:explanation=\"application supports activity\" arg:label=\"supports\" arg:leftNode=\"{= ?leftNode }\" arg:rightNode=\"{= ?rightNode }\"/>
                    </swon:Array>
                </swon:Value>
            </swon:Object>
        </ui:elseif>
    </ui:call>
</ui:group>
"""^^ui:Literal ;
  ui:responseType ui:JSON ;
  rdfs:isDefinedBy <http://edg.topbraid.solutions/1.0/diagram/lg/software> ;
  rdfs:label "Generate JSON for executable supports activity" ;
  rdfs:subClassOf edg:DerivationMapServices ;
.
edg:GenerateJSONforFlows
  a ui:Service ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:leftNode ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resultSet ;
      spl:valueType spr:Table ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:rightNode ;
      spl:valueType rdfs:Resource ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:group>
    <swon:Object>
        <swon:Value arg:name=\"nodes\">
            <swon:Array>
                <ui:forEach ui:resultSet=\"{= ?resultSet }\">
                    <ui:if ui:condition=\"{= ?flowType = edg:Feedline }\">
                        <edg:FeedlineToInteroperableDestinationDetails arg:leftNode=\"{= spl:object(?rightNode, edg:incomingFlow) }\" arg:rightNode=\"{= ?rightNode }\"/>
                    </ui:if>
                    <ui:elseif ui:condition=\"{= ?flowType = edg:Dataflow }\">
                        <edg:GenerateDataflowNodes arg:leftNode=\"{= ?leftNode }\" arg:rightNode=\"{= ?rightNode }\" edg:flow=\"{= ?flowElement }\" edg:source=\"{= ?sourceEndpoint }\" edg:target=\"{= ?targetEndpoint }\"/>
                    </ui:elseif>
                    <ui:elseif ui:condition=\"{= ?flowType = edg:LogicalFlow }\">
                        <edg:GenerateLogicalFlowNodes arg:leftNode=\"{= ?leftNode }\" arg:rightNode=\"{= ?rightNode }\" edg:flow=\"{= ?flowElement }\"/>
                    </ui:elseif>
                </ui:forEach>
            </swon:Array>
        </swon:Value>
        <swon:Value arg:name=\"edges\">
            <swon:Array>
                <edg:BuildJSONforDerviationMapLink arg:leftNode=\"{= ?leftNode }\" arg:property=\"{= edg:dependsOnDataFrom }\" arg:rightNode=\"{= ?rightNode }\"/>
                <edg:GenerateJSONforDerivationMapLinks arg:leftNode=\"{= ?leftNode }\" arg:rightNode=\"{= ?rightNode }\"/>
                <ui:forEach ui:resultSet=\"{= ?resultSet }\">
                    <ui:if ui:condition=\"{= ?flowType = edg:Feedline }\">
                        <edg:FeedlineToInteroperableDestinationDetails arg:leftNode=\"{= spl:object(?rightNode, edg:incomingFlow) }\" arg:rightNode=\"{= ?rightNode }\"/>
                    </ui:if>
                    <ui:elseif ui:condition=\"{= ?flowType = edg:Dataflow }\">
                        <edg:DataflowEdges arg:leftNode=\"{= ?leftNode }\" arg:rightNode=\"{= ?rightNode }\" edg:flow=\"{= ?flowElement }\" edg:source=\"{= COALESCE(?sourceEndpoint, ?leftNode) }\" edg:target=\"{= COALESCE(?targetEndpoint, ?rightNode) }\"/>
                    </ui:elseif>
                    <ui:elseif ui:condition=\"{= ?flowType = edg:LogicalFlow }\">
                        <edg:LogicalFlowEdges arg:leftNode=\"{= ?leftNode }\" arg:rightNode=\"{= ?rightNode }\" edg:flow=\"{= ?flowElement }\"/>
                    </ui:elseif>
                </ui:forEach>
            </swon:Array>
        </swon:Value>
    </swon:Object>
</ui:group>
"""^^ui:Literal ;
  ui:responseType ui:JSON ;
  rdfs:isDefinedBy <http://edg.topbraid.solutions/1.0/diagram/lg/software> ;
  rdfs:label "Generate JSON for flows" ;
  rdfs:subClassOf edg:DerivationMapServices ;
.
edg:GenerateJSONforFunctionDependencyNodes
  a ui:Service ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:function ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:functionalCoupling ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:leftNode ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resultSet ;
      spl:valueType spr:Table ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:rightNode ;
      spl:valueType rdfs:Resource ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:group>
    <edg:GenerateJSONforSoftwareFunctionNodes arg:function=\"{= ?function }\" arg:functionalCoupling=\"{= ?functionalCoupling }\"/>
    <ui:call arg:column=\"{= 3 }\" arg:resultSet=\"{= ?resultSet }\" arg:value=\"{= ?function }\" ui:template=\"{= edg:GetFilteredSoftwareExecutablesPairDependencyDetails }\" ui:varName=\"functionDetails\">
        <!--ui:dumpResultSet ui:message=\"AAA3 - {= ui:label(?function) }\" ui:resultSet=\"{= ?functionDetails }\"/-->
        <ui:forEach ui:resultSet=\"{= ?functionDetails }\">
            <edg:BuildJSONforLineageGramNode arg:node=\"{= ?dataElement }\" arg:occurrence=\"{= CONCAT(&quot;~~&quot;, ENCODE_FOR_URI(str(?functionalCoupling))) }\" arg:parent=\"{= str(?softwareFunction) }_outputs\"/>
        </ui:forEach>
        <ui:call arg:column=\"{= 0 }\" arg:resultSet=\"{= ?functionDetails }\" ui:template=\"{= edg:getDistinctResourcesFromResultSet }\" ui:varName=\"leftNodePrograms\">
            <!--ui:dumpResultSet ui:message=\"AAA4 - {= ui:label(?function) }\" ui:resultSet=\"{= ?leftNodePrograms }\"/-->
            <ui:forEach ui:resultSet=\"{= ?leftNodePrograms }\">
                <edg:BuildJSONforLineageGramNode arg:label=\"{= CONCAT(edg:MakeNodeLabel(?function), &quot;&quot;) }\" arg:node=\"{= ?resource }\" arg:parent=\"{= ?leftNode }\"/>
            </ui:forEach>
        </ui:call>
        <ui:call arg:column=\"{= 5 }\" arg:resultSet=\"{= ?functionDetails }\" ui:template=\"{= edg:getDistinctResourcesFromResultSet }\" ui:varName=\"rightNodePrograms\">
            <!--ui:dumpResultSet ui:message=\"AAA5 - {= ui:label(?function) }\" ui:resultSet=\"{= ?rightNodePrograms }\"/-->
            <ui:forEach ui:resultSet=\"{= ?rightNodePrograms }\">
                <edg:BuildJSONforLineageGramNode arg:label=\"{= CONCAT(edg:MakeNodeLabel(?function), &quot;&quot;) }\" arg:node=\"{= ?resource }\" arg:parent=\"{= ?rightNode }\"/>
            </ui:forEach>
        </ui:call>
    </ui:call>
</ui:group>
"""^^ui:Literal ;
  ui:responseType ui:JSON ;
  rdfs:isDefinedBy <http://edg.topbraid.solutions/1.0/diagram/lg/software> ;
  rdfs:label "Generate JSON for functional dependency nodes" ;
  rdfs:subClassOf edg:DerivationMapServices ;
.
edg:GenerateJSONforInformationAssetDependencies
  a ui:Service ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:leftNode ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resultSet ;
      spl:valueType spr:Table ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:rightNode ;
      spl:valueType rdfs:Resource ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:group let:infoAssets=\"{= spr:rowCount(?resultSet) }\" let:infoCoupling=\"InfoCoupling_{= ui:uniqueId() }\">
    <swon:Object>
        <swon:Value arg:name=\"nodes\">
            <swon:Array>
                <edg:BuildJSONforLineageGramNode arg:icon=\"fa fa-folder\" arg:label=\"{= CONCAT(&quot;Information Assets [&quot;, str(?infoAssets), &quot;]&quot;) }\" arg:node=\"{= ?infoCoupling }\"/>
                <edg:BuildJSONforLineageGramNode arg:label=\"{= edg:MakeNodeLabel(?leftNode) }\" arg:node=\"{= ?leftNode }\"/>
                <ui:if ui:condition=\"{= ?rightNode != ?leftNode }\">
                    <edg:BuildJSONforLineageGramNode arg:label=\"{= edg:MakeNodeLabel(?rightNode) }\" arg:node=\"{= ?rightNode }\"/>
                </ui:if>
                <ui:forEach ui:resultSet=\"{= ?resultSet }\">
                    <edg:BuildJSONforLineageGramNode arg:label=\"{= edg:MakeNodeLabel(?infoAsset) }\" arg:node=\"{= ?infoAsset }\" arg:parent=\"{= ?infoCoupling }\"/>
                </ui:forEach>
            </swon:Array>
        </swon:Value>
        <swon:Value arg:name=\"edges\">
            <swon:Array>
                <ui:forEach ui:resultSet=\"{= ?resultSet }\">
                    <edg:BuildJSONforDerviationMapLink arg:explanation=\"source produces information asset\" arg:label=\"produces\" arg:leftNode=\"{= ?leftNode }\" arg:rightNode=\"{= ?infoCoupling }\"/>
                    <edg:BuildJSONforDerviationMapLink arg:explanation=\"target requires information asset\" arg:label=\"requires\" arg:leftNode=\"{= ?infoCoupling }\" arg:reverseNodes=\"{= true }\" arg:rightNode=\"{= ?rightNode }\"/>
                </ui:forEach>
            </swon:Array>
        </swon:Value>
    </swon:Object>
</ui:group>
"""^^ui:Literal ;
  ui:responseType ui:JSON ;
  rdfs:isDefinedBy <http://edg.topbraid.solutions/1.0/diagram/lg/software> ;
  rdfs:label "Generate JSON for information asset dependency dependencies" ;
  rdfs:subClassOf edg:DerivationMapServices ;
.
edg:GenerateJSONforInformationAssetDependencyEdges
  a ui:Service ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:leftNode ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resultSet ;
      spl:valueType spr:Table ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:rightNode ;
      spl:valueType rdfs:Resource ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:group>
    <!--ui:dumpResultSet ui:message=\"AAA1: edg:GenerateJSONforInformationAssetDependencyEdges\" ui:resultSet=\"{= ?resultSet }\"/-->
    <swon:Value arg:name=\"edges\">
        <swon:Array>
            <ui:forEach ui:resultSet=\"{= ?resultSet }\">
                <ui:if ui:condition=\"{= bound(?softwareFunctionType) }\">
                    <ui:if ui:condition=\"{= bound(?leftNodeSoftwareExecutable) }\">
                        <edg:BuildJSONforDerviationMapLink arg:explanation=\"source program uses function\" arg:label=\"uses\" arg:leftNode=\"{= ?leftNodeSoftwareExecutable }\" arg:rightNode=\"{= ?softwareFunction }\"/>
                        <edg:BuildJSONforDerviationMapLink arg:explanation=\"source outputs data\" arg:leftNode=\"{= ?leftNodeSoftwareExecutable }\" arg:property=\"{= edg:output }\" arg:rightNode=\"{= ?dataElement }\" arg:targetOccurrence=\"{= CONCAT(&quot;~~&quot;, ENCODE_FOR_URI(str(?functionalCoupling))) }\"/>
                    </ui:if>
                    <ui:else>
                        <edg:BuildJSONforDerviationMapLink arg:explanation=\"source application uses function\" arg:label=\"uses\" arg:leftNode=\"{= ?leftNode }\" arg:rightNode=\"{= ?softwareFunction }\"/>
                    </ui:else>
                    <ui:if ui:condition=\"{= bound(?rightNodeSoftwareExecutable) }\">
                        <edg:BuildJSONforDerviationMapLink arg:explanation=\"function is used by target program\" arg:label=\"used by\" arg:leftNode=\"{= ?rightNodeSoftwareExecutable }\" arg:rightNode=\"{= ?softwareFunction }\"/>
                        <edg:BuildJSONforDerviationMapLink arg:explanation=\"target program has input data\" arg:leftNode=\"{= ?rightNodeSoftwareExecutable }\" arg:property=\"{= edg:input }\" arg:rightNode=\"{= ?dataElement }\" arg:targetOccurrence=\"{= CONCAT(&quot;~~&quot;, ENCODE_FOR_URI(str(?functionalCoupling))) }\"/>
                    </ui:if>
                    <ui:else>
                        <edg:BuildJSONforDerviationMapLink arg:explanation=\"target application uses function\" arg:label=\"used by\" arg:leftNode=\"{= ?softwareFunction }\" arg:rightNode=\"{= ?rightNode }\"/>
                    </ui:else>
                </ui:if>
                <ui:else>
                    <edg:BuildJSONforDerviationMapLink arg:explanation=\"source applicatiob has output data\" arg:leftNode=\"{= ?leftNodeSoftwareExecutable }\" arg:property=\"{= edg:output }\" arg:rightNode=\"{= ?dataElement }\"/>
                    <edg:BuildJSONforDerviationMapLink arg:explanation=\"target application has input data\" arg:leftNode=\"{= ?dataElement }\" arg:property=\"{= edg:input }\" arg:rightNode=\"{= ?rightNodeSoftwareExecutable }\"/>
                </ui:else>
            </ui:forEach>
            <edg:BuildJSONforDerviationMapLink arg:leftNode=\"{= ?leftNode }\" arg:property=\"{= edg:dependsOnDataFrom }\" arg:reverseNodes=\"{= true }\" arg:rightNode=\"{= ?rightNode }\"/>
            <edg:GenerateJSONforDerivationMapLinks arg:leftNode=\"{= ?leftNode }\" arg:rightNode=\"{= ?rightNode }\"/>
        </swon:Array>
    </swon:Value>
</ui:group>
"""^^ui:Literal ;
  ui:responseType ui:JSON ;
  rdfs:isDefinedBy <http://edg.topbraid.solutions/1.0/diagram/lg/software> ;
  rdfs:label "Generate JSON for information asset dependency edges" ;
  rdfs:subClassOf edg:DerivationMapServices ;
.
edg:GenerateJSONforLineageGram
  rdfs:comment "Transforms the temporary LG graph into JSON. Special treatmet is made for the focus node so that it appears as the first node in the list of objects." ;
.
edg:GenerateJSONforSoftwareExecutableInformationOutputNodes
  a ui:Service ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:dataCoupling ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:functionalCoupling ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:leftNode ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resultSet ;
      spl:valueType spr:Table ;
      rdfs:comment "A result set describing how a database is involved in a dependency. It has the following columns: \"?table ?inputType ?input ?softwareProgram ?softwareFunction ?serviceEndpoint ?directMappingsCollection ?mapping\" , as provided, for example, by 'edg:GetSoftwareExecutableDatabaseInputs'" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:rightNode ;
      spl:valueType rdfs:Resource ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:group>
    <ui:call arg:property=\"{= edg:producesInformationAsset }\" arg:resource=\"{= ?rightNode }\" ui:template=\"{= edg:getPropertyValuesForResource }\" ui:varName=\"infoAssets\">
        <ui:if ui:condition=\"{= !spr:isEmpty(?infoAssets) }\">
            <edg:BuildJSONforLineageGramNode arg:label=\"{= edg:MakeNodeLabel(?leftNode) }\" arg:node=\"{= ?leftNode }\"/>
        </ui:if>
    </ui:call>
</ui:group>
"""^^ui:Literal ;
  ui:responseType ui:JSON ;
  rdfs:isDefinedBy <http://edg.topbraid.solutions/1.0/diagram/lg/software> ;
  rdfs:label "Generate JSON for software executable information output nodes" ;
  rdfs:subClassOf edg:DerivationMapServices ;
.
edg:GenerateJSONforSoftwareExecutableSelfDependencyEdges
  a ui:Service ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:dataCoupling ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:functionalCoupling ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:node ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resultSet ;
      spl:valueType spr:Table ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:group>
    <swon:Value arg:name=\"edges\">
        <swon:Array>
            <ui:forEach ui:resultSet=\"{= ?resultSet }\">
                <ui:if ui:condition=\"{= bound(?softwareFunctionType) }\">
                    <ui:if ui:condition=\"{= bound(?leftNodeSoftwareExecutable) }\">
                        <edg:BuildJSONforDerviationMapLink arg:label=\"uses\" arg:leftNode=\"{= ?leftNodeSoftwareExecutable }\" arg:property=\"{= edg:output }\" arg:rightNode=\"{= ?softwareFunction }\"/>
                    </ui:if>
                    <ui:else>
                        <edg:BuildJSONforDerviationMapLink arg:label=\"uses\" arg:leftNode=\"{= ?node }\" arg:property=\"{= edg:output }\" arg:rightNode=\"{= ?softwareFunction }\"/>
                    </ui:else>
                    <ui:if ui:condition=\"{= bound(?rightNodeSoftwareExecutable) }\">
                        <edg:BuildJSONforDerviationMapLink arg:label=\"used by\" arg:leftNode=\"{= ?softwareFunction }\" arg:property=\"{= edg:input }\" arg:rightNode=\"{= ?rightNodeSoftwareExecutable }\"/>
                    </ui:if>
                    <ui:else>
                        <edg:BuildJSONforDerviationMapLink arg:label=\"used by\" arg:leftNode=\"{= ?softwareFunction }\" arg:property=\"{= edg:output }\" arg:rightNode=\"{= ?node }\"/>
                    </ui:else>
                </ui:if>
                <ui:else>
                    <edg:BuildJSONforDerviationMapLink arg:label=\"output\" arg:leftNode=\"{= ?leftNodeSoftwareExecutable }\" arg:property=\"{= edg:output }\" arg:rightNode=\"{= ?dataElement }\"/>
                    <edg:BuildJSONforDerviationMapLink arg:label=\"input\" arg:leftNode=\"{= ?rightNodeSoftwareExecutable }\" arg:property=\"{= edg:input }\" arg:rightNode=\"{= ?dataElement }\"/>
                </ui:else>
            </ui:forEach>
        </swon:Array>
    </swon:Value>
</ui:group>
"""^^ui:Literal ;
  ui:responseType ui:JSON ;
  rdfs:isDefinedBy <http://edg.topbraid.solutions/1.0/diagram/lg/software> ;
  rdfs:label "Generate JSON for software executable self dependency edges" ;
  rdfs:subClassOf edg:DerivationMapServices ;
.
edg:GenerateJSONforSoftwareExecutableSelfDependencyNodes
  a ui:Service ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:dataCoupling ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:functionalCoupling ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:node ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resultSet ;
      spl:valueType spr:Table ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:group>
    <swon:Value arg:name=\"nodes\">
        <swon:Array>
            <edg:BuildJSONforLineageGramNode arg:label=\"{= edg:MakeNodeLabel(?node) }\" arg:node=\"{= ?node }\"/>
            <ui:if ui:condition=\"{= spr:isEmpty(?resultSet) }\">
                <edg:BuildJSONforLineageGramNode arg:label=\"{= CONCAT(edg:MakeNodeLabel(?node), &quot;&quot;) }\" arg:node=\"{= ?node }\"/>
            </ui:if>
            <ui:else>
                <ui:forEach ui:resultSet=\"{= ?resultSet }\">
                    <ui:if ui:condition=\"{= bound(?leftNodeSoftwareExecutable) }\">
                        <edg:BuildJSONforLineageGramNode arg:label=\"{= CONCAT(edg:MakeNodeLabel(?leftNodeSoftwareExecutable), &quot;&quot;) }\" arg:node=\"{= ?leftNodeSoftwareExecutable }\" arg:parent=\"{= ?node }\"/>
                    </ui:if>
                    <ui:if ui:condition=\"{= bound(?rightNodeSoftwareExecutable) }\">
                        <edg:BuildJSONforLineageGramNode arg:label=\"{= edg:MakeNodeLabel(?rightNodeSoftwareExecutable) }\" arg:node=\"{= ?rightNodeSoftwareExecutable }\" arg:parent=\"{= ?node }\"/>
                    </ui:if>
                    <ui:if ui:condition=\"{= bound(?softwareFunctionType) }\">
                        <edg:GenerateJSONforSoftwareFunctionNodes arg:function=\"{= ?softwareFunction }\" arg:functionalCoupling=\"{= ?functionalCoupling }\"/>
                        <ui:resourceView arg:parent=\"{= ?softwareFunction }_outputs\" ui:matchIds=\"derivation-map-composite-node\" ui:resource=\"{= ?dataElement }\"/>
                    </ui:if>
                    <ui:else>
                        <edg:BuildJSONforLineageGramNode arg:icon=\"fa fa-balance-scale\" arg:label=\"Data Dependencies\" arg:node=\"{= ?dataCoupling }\"/>
                        <ui:resourceView arg:parent=\"{= ?dataCoupling }\" ui:matchIds=\"derivation-map-composite-node\" ui:resource=\"{= ?dataElement }\"/>
                    </ui:else>
                </ui:forEach>
            </ui:else>
        </swon:Array>
    </swon:Value>
</ui:group>
"""^^ui:Literal ;
  ui:responseType ui:JSON ;
  rdfs:isDefinedBy <http://edg.topbraid.solutions/1.0/diagram/lg/software> ;
  rdfs:label "Generate JSON for software executable self dependency nodes" ;
  rdfs:subClassOf edg:DerivationMapServices ;
.
edg:GenerateJSONforSoftwareExecutableToSoftwareExecutableDataDependencyNodes
  a ui:Service ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:dataCoupling ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:leftNode ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resultSet ;
      spl:valueType spr:Table ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:rightNode ;
      spl:valueType rdfs:Resource ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:group let:occurrenceSuffixForDataElement=\"{= CONCAT(&quot;~~&quot;, ENCODE_FOR_URI(str(?dataCoupling))) }\">
    <!--ui:dumpResultSet ui:message=\"AAA1\" ui:resultSet=\"{= ?resultSet }\"/-->
    <ui:call arg:column=\"{= 6 }\" arg:resultSet=\"{= ?resultSet }\" ui:template=\"{= edg:getDistinctResourcesFromResultSet }\" ui:varName=\"dataElements\">
        <!--ui:dumpResultSet ui:message=\"AAA2\" ui:resultSet=\"{= ?dataElements }\"/-->
        <ui:if ui:condition=\"{= !spr:isEmpty(?dataElements) }\">
            <edg:BuildJSONforLineageGramNode arg:icon=\"fa fa-balance-scale\" arg:label=\"Data Dependencies\" arg:node=\"{= ?dataCoupling }\"/>
            <ui:forEach ui:resultSet=\"{= ?dataElements }\">
                <edg:BuildJSONforLineageGramNode arg:node=\"{= ?resource }\" arg:occurrence=\"{= ?occurrenceSuffixForDataElement }\" arg:parent=\"{= ?dataCoupling }\"/>
            </ui:forEach>
        </ui:if>
    </ui:call>
</ui:group>
"""^^ui:Literal ;
  ui:responseType ui:JSON ;
  rdfs:isDefinedBy <http://edg.topbraid.solutions/1.0/diagram/lg/software> ;
  rdfs:label "Generate JSON for software executable to software executable data dependency nodes" ;
  rdfs:subClassOf edg:DerivationMapServices ;
.
edg:GenerateJSONforSoftwareExecutableToSoftwareExecutableDependencyDetails
  a ui:Service ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate edg:linkType ;
      spl:valueType xsd:string ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:leftNode ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:rightNode ;
      spl:valueType rdfs:Resource ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:group let:dataCoupling=\"DataCoupling_{= ui:uniqueId() }\" let:functionalCoupling=\"FunctionalCoupling_{= ui:uniqueId() }\">
    <!--ui:dumpScope ui:message=\"AAA1: edg:GenerateJSONforSoftwareExecutableToSoftwareExecutableDependencyDetails - {= ui:label(?leftNode) } to {= ui:label(?rightNode) }\"/-->
    <ui:call arg:leftNode=\"{= ?leftNode }\" arg:rightNode=\"{= ?rightNode }\" edg:linkType=\"{= ?linkType }\" ui:template=\"{= edg:getSourceToTargetFlowDetails }\" ui:varName=\"flows\">
        <!--ui:dumpResultSet ui:message=\"AAA2: edg:GenerateJSONforSoftwareExecutableToSoftwareExecutableDependencyDetails {= ?leftNode } to {= ui:label(?rightNode) }\"
      ui:resultSet=\"{= ?flows }\"/-->
        <ui:if ui:condition=\"{= !spr:isEmpty(?flows) }\">
            <edg:GenerateJSONforCompositeFlows arg:leftNode=\"{= ?leftNode }\" arg:resultSet=\"{= ?flows }\" arg:rightNode=\"{= ?rightNode }\" edg:linkType=\"{= ?linkType }\"/>
        </ui:if>
        <ui:else>
            <ui:call arg:leftNode=\"{= ?leftNode }\" arg:rightNode=\"{= ?rightNode }\" ui:template=\"{= edg:GetDeepBusinessApplicationToBusinessApplicationDependencyDetails }\" ui:varName=\"appToAppDetails\">
                <!--ui:dumpResultSet ui:message=\"AAA3 - GenerateJSONforBusinessApplicationToBusinessApplicationDependencyDetails -  {= ui:label(?leftNode) } to {= ui:label(?rightNode) }\"
  ui:resultSet=\"{= ?appToAppDetails }\"/-->
                <ui:if ui:condition=\"{= !spr:isEmpty(?appToAppDetails) }\">
                    <edg:GenerateJSONforDeepExecutables arg:leftNode=\"{= ?leftNode }\" arg:resultSet=\"{= ?appToAppDetails }\" arg:rightNode=\"{= ?rightNode }\"/>
                </ui:if>
                <ui:elseif ui:condition=\"{= EXISTS {
                    ?rightNode edg:requiresInformationAsset ?infoAsset .
                    ?leftNode edg:producesInformationAsset ?infoAsset .
                } }\">
                    <ui:call arg:leftNode=\"{= ?leftNode }\" arg:rightNode=\"{= ?rightNode }\" ui:template=\"{= edg:GetnInformationAssetDependencyDetails }\" ui:varName=\"appToAppInformationAssetDetails\">
                        <!--ui:dumpResultSet ui:message=\"AAA4 - GenerateJSONforBusinessApplicationToBusinessApplicationDependencyDetails -  {= ui:label(?leftNode) } to {= ui:label(?rightNode) }\"
  ui:resultSet=\"{= ?appToAppInformationAssetDetails }\"/-->
                        <edg:GenerateJSONforInformationAssetDependencies arg:leftNode=\"{= ?leftNode }\" arg:resultSet=\"{= ?appToAppInformationAssetDetails }\" arg:rightNode=\"{= ?rightNode }\"/>
                    </ui:call>
                </ui:elseif>
                <ui:elseif ui:condition=\"{= EXISTS {
                    ?rightNode edg:dependsOnDataFrom ?leftNode .
                } }\">
                    <!--ui:dumpScope ui:message=\"AAA3 - GenerateJSONforBusinessApplicationToBusinessApplicationDependencyDetails -  {= ?leftNode }\"/-->
                    <ui:if ui:condition=\"{= ?leftNode = ?rightNode }\">
                        <!--ui:dumpScope ui:message=\"AAA5 - GenerateJSONforBusinessApplicationToBusinessApplicationDependencyDetails -  {= ?leftNode }\"/-->
                        <edg:BuildJSONforDerivationMapSingleton arg:label=\"{= CONCAT(edg:MakeNodeLabel(?leftNode), &quot;&quot;) }\" arg:node=\"{= ?leftNode }\" arg:property=\"{= edg:dependsOnDataFrom }\"/>
                    </ui:if>
                    <ui:else>
                        <!--ui:dumpScope ui:message=\"AAA6 - GenerateJSONforBusinessApplicationToBusinessApplicationDependencyDetails -  {= ?leftNode }\"/-->
                        <edg:BuildJSONforDerivationMapNodePair arg:inverse=\"{= true }\" arg:leftNode=\"{= ?leftNode }\" arg:property=\"{= edg:dependsOnDataFrom }\" arg:rightNode=\"{= ?rightNode }\"/>
                    </ui:else>
                </ui:elseif>
            </ui:call>
        </ui:else>
    </ui:call>
</ui:group>
"""^^ui:Literal ;
  ui:responseType ui:JSON ;
  rdfs:isDefinedBy <http://edg.topbraid.solutions/1.0/diagram/lg/software> ;
  rdfs:label "Generate JSON for software executable to software executable dependency details" ;
  rdfs:subClassOf edg:DerivationMapServices ;
.
edg:GenerateJSONforSoftwareExecutableToSoftwareExecutableDependencyEdges
  a ui:Service ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:dataCoupling ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:functionalCoupling ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:leftNode ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resultSet ;
      spl:valueType spr:Table ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:rightNode ;
      spl:valueType rdfs:Resource ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:group>
    <!--ui:dumpResultSet ui:message=\"AAA1: SE2SE\" ui:resultSet=\"{= ?resultSet }\"/-->
    <swon:Value arg:name=\"edges\">
        <swon:Array>
            <ui:forEach ui:resultSet=\"{= ?resultSet }\">
                <ui:if ui:condition=\"{= bound(?softwareFunctionType) }\">
                    <ui:if ui:condition=\"{= bound(?leftNodeSoftwareExecutable) }\">
                        <edg:BuildJSONforDerviationMapLink arg:explanation=\"source program uses function\" arg:label=\"uses\" arg:leftNode=\"{= ?leftNodeSoftwareExecutable }\" arg:rightNode=\"{= ?softwareFunction }\"/>
                        <edg:BuildJSONforDerviationMapLink arg:explanation=\"source outputs data\" arg:leftNode=\"{= ?leftNodeSoftwareExecutable }\" arg:property=\"{= edg:output }\" arg:rightNode=\"{= ?dataElement }\" arg:targetOccurrence=\"{= CONCAT(&quot;~~&quot;, ENCODE_FOR_URI(str(?functionalCoupling))) }\"/>
                    </ui:if>
                    <ui:else>
                        <edg:BuildJSONforDerviationMapLink arg:explanation=\"source application uses function\" arg:label=\"uses\" arg:leftNode=\"{= ?leftNode }\" arg:rightNode=\"{= ?softwareFunction }\"/>
                    </ui:else>
                    <ui:if ui:condition=\"{= bound(?rightNodeSoftwareExecutable) }\">
                        <edg:BuildJSONforDerviationMapLink arg:explanation=\"function is used by target program\" arg:label=\"used by\" arg:leftNode=\"{= ?rightNodeSoftwareExecutable }\" arg:rightNode=\"{= ?softwareFunction }\"/>
                        <edg:BuildJSONforDerviationMapLink arg:explanation=\"target program has input data\" arg:leftNode=\"{= ?rightNodeSoftwareExecutable }\" arg:property=\"{= edg:input }\" arg:rightNode=\"{= ?dataElement }\" arg:targetOccurrence=\"{= CONCAT(&quot;~~&quot;, ENCODE_FOR_URI(str(?functionalCoupling))) }\"/>
                    </ui:if>
                    <ui:else>
                        <edg:BuildJSONforDerviationMapLink arg:explanation=\"target application uses function\" arg:label=\"used by\" arg:leftNode=\"{= ?softwareFunction }\" arg:rightNode=\"{= ?rightNode }\"/>
                    </ui:else>
                </ui:if>
                <ui:else>
                    <edg:BuildJSONforDerviationMapLink arg:explanation=\"source applicatiob has output data\" arg:leftNode=\"{= ?leftNodeSoftwareExecutable }\" arg:property=\"{= edg:output }\" arg:rightNode=\"{= ?dataElement }\"/>
                    <edg:BuildJSONforDerviationMapLink arg:explanation=\"target application has input data\" arg:leftNode=\"{= ?dataElement }\" arg:property=\"{= edg:input }\" arg:rightNode=\"{= ?rightNodeSoftwareExecutable }\"/>
                </ui:else>
            </ui:forEach>
            <edg:BuildJSONforDerviationMapLink arg:leftNode=\"{= ?leftNode }\" arg:property=\"{= edg:dependsOnDataFrom }\" arg:reverseNodes=\"{= true }\" arg:rightNode=\"{= ?rightNode }\"/>
            <edg:GenerateJSONforDerivationMapLinks arg:leftNode=\"{= ?leftNode }\" arg:rightNode=\"{= ?rightNode }\"/>
        </swon:Array>
    </swon:Value>
</ui:group>
"""^^ui:Literal ;
  ui:responseType ui:JSON ;
  rdfs:isDefinedBy <http://edg.topbraid.solutions/1.0/diagram/lg/software> ;
  rdfs:label "Generate JSON for software executable to software executable dependency edges" ;
  rdfs:subClassOf edg:DerivationMapServices ;
.
edg:GenerateJSONforSoftwareExecutableToSoftwareExecutableDependencyNodes
  a ui:Service ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:dataCoupling ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:functionalCoupling ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:leftNode ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resultSet ;
      spl:valueType spr:Table ;
      rdfs:comment "A result set describing how a database is involved in a dependency. It has the following columns: \"?table ?inputType ?input ?softwareProgram ?softwareFunction ?serviceEndpoint ?directMappingsCollection ?mapping\" , as provided, for example, by 'edg:GetSoftwareExecutableDatabaseInputs'" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:rightNode ;
      spl:valueType rdfs:Resource ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:group let:functionDependencyRows=\"{= edg:mapFunctionOverResultSet(edg:resultSetRowsWithColumnValue, ?resultSet, 0, 3, &quot;&quot;) } \">
    <!--ui:dumpScope ui:message=\"AAA1: edg:GenerateJSONforSoftwareExecutableToSoftwareExecutableDependencyNodes - {= str(?rightNode) }\"/-->
    <!--ui:dumpResultSet ui:message=\"AAA1: edg:GenerateJSONforSoftwareExecutableToSoftwareExecutableDependencyNodes - {= str(?rightNode) }\"
  ui:resultSet=\"{= ?resultSet }\"/-->
    <swon:Value arg:name=\"nodes\">
        <swon:Array>
            <ui:resourceView arg:leftNode=\"{= ?leftNode }\" arg:rightNode=\"{= ?rightNode }\" ui:matchIds=\"derivation-map-composite-node\" ui:resource=\"{= ?leftNode }\"/>
            <ui:resourceView arg:leftNode=\"{= ?leftNode }\" arg:rightNode=\"{= ?rightNode }\" ui:matchIds=\"derivation-map-composite-node\" ui:resource=\"{= ?rightNode }\"/>
            <ui:if ui:condition=\"{= ?functionDependencyRows != &quot;&quot; }\">
                <edg:GenerateJSONforSoftwareExecutableToSoftwareExecutableFunctionalDependencyNodes arg:functionalCoupling=\"{= ?functionalCoupling }\" arg:leftNode=\"{= ?leftNode }\" arg:resultSet=\"{= ?resultSet }\" arg:rightNode=\"{= ?rightNode }\"/>
            </ui:if>
            <ui:if ui:condition=\"{= ?functionDependencyRows = &quot;&quot; }\">
                <edg:GenerateJSONforSoftwareExecutableToSoftwareExecutableDataDependencyNodes arg:dataCoupling=\"{= ?dataCoupling }\" arg:leftNode=\"{= ?leftNode }\" arg:resultSet=\"{= ?resultSet }\" arg:rightNode=\"{= ?rightNode }\"/>
            </ui:if>
        </swon:Array>
    </swon:Value>
</ui:group>
"""^^ui:Literal ;
  ui:responseType ui:JSON ;
  vaem:todo """Decide need for:
 <ui:resourceView arg:parent=\"{= ?dataCoupling }\"
                     ui:matchIds=\"derivation-map-composite-node\"
                     ui:resource=\"{= ?dataElement }\"/>""" ;
  rdfs:isDefinedBy <http://edg.topbraid.solutions/1.0/diagram/lg/software> ;
  rdfs:label "Generate JSON for software executable to software executable dependency nodes" ;
  rdfs:subClassOf edg:DerivationMapServices ;
.
edg:GenerateJSONforSoftwareExecutableToSoftwareExecutableFunctionalDependencyNodes
  a ui:Service ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:functionalCoupling ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:leftNode ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resultSet ;
      spl:valueType spr:Table ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:rightNode ;
      spl:valueType rdfs:Resource ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:group let:dataCoupling=\"{= IRI(CONCAT(&quot;http://edg.topbraid.solutions/model/DataCoupling_&quot;, ui:uniqueId())) }\">
    <!--ui:dumpScope ui:message=\"AAA1 - GenerateJSONforSoftwareExecutableToSoftwareExecutableFunctionalDependencyNodes\"/-->
    <!--ui:dumpResultSet ui:message=\"AAA1 - GenerateJSONforSoftwareExecutableToSoftwareExecutableFunctionalDependencyNodes\"
  ui:resultSet=\"{= ?resultSet }\"/-->
    <ui:call arg:column=\"{= 3 }\" arg:resultSet=\"{= ?resultSet }\" ui:template=\"{= edg:getDistinctResourcesFromResultSet }\" ui:varName=\"functions\">
        <!--ui:dumpResultSet ui:message=\"AAA2 - GenerateJSONforSoftwareExecutableToSoftwareExecutableFunctionalDependencyNodes\"
  ui:resultSet=\"{= ?functions }\"/-->
        <ui:if ui:condition=\"{= !spr:isEmpty(?functions) }\">
            <ui:forEach ui:resultSet=\"{= ?functions }\">
                <edg:GenerateJSONforFunctionDependencyNodes arg:function=\"{= ?resource }\" arg:functionalCoupling=\"{= ?functionalCoupling }\" arg:leftNode=\"{= ?leftNode }\" arg:resultSet=\"{= ?resultSet }\" arg:rightNode=\"{= ?rightNode }\"/>
            </ui:forEach>
        </ui:if>
        <ui:else>
            <ui:call arg:column=\"{= 0 }\" arg:resultSet=\"{= ?resultSet }\" ui:template=\"{= edg:getDistinctResourcesFromResultSet }\" ui:varName=\"sourceNodePrograms\">
                <!--ui:dumpResultSet ui:message=\"AAA3 - GenerateJSONforSoftwareExecutableToSoftwareExecutableFunctionalDependencyNodes\"
  ui:resultSet=\"{= ?sourceNodePrograms }\"/-->
                <ui:if ui:condition=\"{= !spr:isEmpty(?sourceNodePrograms) }\">
                    <ui:forEach ui:resultSet=\"{= ?sourceNodePrograms }\">
                        <edg:BuildJSONforLineageGramNode arg:label=\"{= CONCAT(edg:MakeNodeLabel(?resource), &quot;&quot;) }\" arg:node=\"{= ?resource }\" arg:parent=\"{= ?leftNode }\"/>
                    </ui:forEach>
                </ui:if>
            </ui:call>
            <ui:call arg:column=\"{= 5 }\" arg:resultSet=\"{= ?resultSet }\" ui:template=\"{= edg:getDistinctResourcesFromResultSet }\" ui:varName=\"targetNodePrograms\">
                <!--ui:dumpResultSet ui:message=\"AAA4 - edg:GenerateJSONforSoftwareExecutableToSoftwareExecutableFunctionalDependencyNodes\"
  ui:resultSet=\"{= ?targetNodePrograms }\"/-->
                <ui:if ui:condition=\"{= !spr:isEmpty(?targetNodePrograms) }\">
                    <ui:forEach ui:resultSet=\"{= ?targetNodePrograms }\">
                        <edg:BuildJSONforLineageGramNode arg:label=\"{= CONCAT(edg:MakeNodeLabel(?resource), &quot;&quot;) }\" arg:node=\"{= ?resource }\" arg:parent=\"{= ?rightNode }\"/>
                        <!-- show the data elements of the target program -->
                        <ui:call arg:column=\"{= 5 }\" arg:resultSet=\"{= ?resultSet }\" arg:value=\"{= ?resource }\" ui:template=\"{= edg:RowsOfResultSetFilteredByGivenColumnNumberAndValue }\" ui:varName=\"dataElementRowsFilteredByProgram\">
                            <!--ui:dumpResultSet ui:message=\"AAA5 - edg:GenerateJSONforSoftwareExecutableToSoftwareExecutableFunctionalDependencyNodes\"
  ui:resultSet=\"{= ?dataElementRowsFilteredByProgram }\"/-->
                            <ui:forEach ui:resultSet=\"{= ?dataElementRowsFilteredByProgram }\">
                                <ui:group let:dataElement=\"{= spr:cell(?resultSet, ?rowIndex, 6) }\">
                                    <ui:resourceView ui:matchIds=\"derivation-map-composite-node\" ui:resource=\"{= ?dataElement }\"/>
                                    <edg:MakeDerivationMapLink arg:id=\"{= CONCAT(&quot;LINK_&quot;, ui:uniqueId()) }\" arg:label=\"input\" edg:source=\"{= ENCODE_FOR_URI(str(?dataElement)) }\" edg:target=\"{= ENCODE_FOR_URI(str(?resource)) }\"/>
                                </ui:group>
                            </ui:forEach>
                        </ui:call>
                    </ui:forEach>
                </ui:if>
            </ui:call>
        </ui:else>
    </ui:call>
</ui:group>
"""^^ui:Literal ;
  ui:responseType ui:JSON ;
  rdfs:isDefinedBy <http://edg.topbraid.solutions/1.0/diagram/lg/software> ;
  rdfs:label "Generate JSON for software executable to software executable functional dependency nodes" ;
  rdfs:subClassOf edg:DerivationMapServices ;
.
edg:GenerateJSONforSoftwareFunctionToSoftwareExecutableDependencyDetails
  a ui:Service ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:leftNode ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:rightNode ;
      spl:valueType rdfs:Resource ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:group>
    <ui:group let:directDependency=\"{= EXISTS {
        ?rightNode edg:dependsOnDataFrom ?leftNode .
    } }\">
        <!--ui:dumpScope ui:message=\"AAA2: edg:GenerateJSONforSoftwareProgramToSoftwareProgramDependencyDetails\"/-->
        <ui:if ui:condition=\"{= ?directDependency }\">
            <swon:Object>
                <swon:Value arg:name=\"nodes\">
                    <swon:Array>
                        <ui:resourceView arg:leftNode=\"{= ?leftNode }\" arg:rightNode=\"{= ?rightNode }\" ui:matchIds=\"derivation-map-composite-node\" ui:resource=\"{= ?leftNode }\"/>
                        <ui:resourceView arg:leftNode=\"{= ?leftNode }\" arg:rightNode=\"{= ?rightNode }\" ui:matchIds=\"derivation-map-composite-node\" ui:resource=\"{= ?rightNode }\"/>
                    </swon:Array>
                </swon:Value>
                <swon:Value arg:name=\"edges\">
                    <swon:Array>
                        <edg:BuildJSONforDerviationMapLink arg:leftNode=\"{= ?leftNode }\" arg:property=\"{= edg:dependsOnDataFrom }\" arg:reverseNodes=\"{= false }\" arg:rightNode=\"{= ?rightNode }\"/>
                        <edg:GenerateJSONforDerivationMapLinks arg:leftNode=\"{= ?leftNode }\" arg:rightNode=\"{= ?rightNode }\"/>
                    </swon:Array>
                </swon:Value>
            </swon:Object>
        </ui:if>
        <ui:else>
            <ui:group let:dataCoupling=\"DataCoupling_{= ui:uniqueId() }\" let:functionalCoupling=\"FunctionalCoupling_{= ui:uniqueId() }\">
                <ui:call arg:leftNode=\"{= ?leftNode }\" arg:rightNode=\"{= ?rightNode }\" ui:template=\"{= edg:GetSoftwareExecutableToSoftwareExecutableDependencyDetails }\" ui:varName=\"dependencyDetails\">
                    <!--ui:dumpResultSet ui:message=\"AAA2: edg:GenerateJSONforSoftwareProgramToSoftwareProgramDependencyDetails\"
  ui:resultSet=\"{= ?dependencyDetails }\"/-->
                    <swon:Object>
                        <edg:GenerateJSONforSoftwareExecutableToSoftwareExecutableDependencyNodes arg:dataCoupling=\"{= ?dataCoupling }\" arg:functionalCoupling=\"{= ?functionalCoupling }\" arg:leftNode=\"{= ?leftNode }\" arg:resultSet=\"{= ?dependencyDetails }\" arg:rightNode=\"{= ?rightNode }\"/>
                        <edg:GenerateJSONforSoftwareExecutableToSoftwareExecutableDependencyEdges arg:dataCoupling=\"{= ?dataCoupling }\" arg:functionalCoupling=\"{= ?functionalCoupling }\" arg:leftNode=\"{= ?leftNode }\" arg:resultSet=\"{= ?dependencyDetails }\" arg:rightNode=\"{= ?rightNode }\"/>
                    </swon:Object>
                </ui:call>
            </ui:group>
        </ui:else>
    </ui:group>
</ui:group>
"""^^ui:Literal ;
  ui:responseType ui:JSON ;
  rdfs:isDefinedBy <http://edg.topbraid.solutions/1.0/diagram/lg/software> ;
  rdfs:label "Generate JSON for software function to software program dependency details" ;
  rdfs:subClassOf edg:DerivationMapServices ;
.
edg:GenerateJSONforSoftwareProgramToSoftwareExecutableDependencyDetails
  a ui:Service ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:leftNode ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:rightNode ;
      spl:valueType rdfs:Resource ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:group>
    <ui:group let:directDependency=\"{= EXISTS {
        ?rightNode edg:dependsOnDataFrom ?leftNode .
    } }\">
        <!--ui:dumpScope ui:message=\"AAA2: edg:GenerateJSONforSoftwareProgramToSoftwareExecutableDependencyDetails\"/-->
        <ui:if ui:condition=\"{= ?directDependency }\">
            <swon:Object>
                <swon:Value arg:name=\"nodes\">
                    <swon:Array>
                        <ui:resourceView arg:leftNode=\"{= ?leftNode }\" arg:rightNode=\"{= ?rightNode }\" ui:matchIds=\"derivation-map-composite-node\" ui:resource=\"{= ?leftNode }\"/>
                        <ui:resourceView arg:leftNode=\"{= ?leftNode }\" arg:rightNode=\"{= ?rightNode }\" ui:matchIds=\"derivation-map-composite-node\" ui:resource=\"{= ?rightNode }\"/>
                    </swon:Array>
                </swon:Value>
                <swon:Value arg:name=\"edges\">
                    <swon:Array>
                        <edg:BuildJSONforDerviationMapLink arg:leftNode=\"{= ?leftNode }\" arg:property=\"{= edg:dependsOnDataFrom }\" arg:reverseNodes=\"{= false }\" arg:rightNode=\"{= ?rightNode }\"/>
                        <edg:GenerateJSONforDerivationMapLinks arg:leftNode=\"{= ?leftNode }\" arg:rightNode=\"{= ?rightNode }\"/>
                    </swon:Array>
                </swon:Value>
            </swon:Object>
        </ui:if>
        <ui:else>
            <ui:group let:dataCoupling=\"DataCoupling_{= ui:uniqueId() }\" let:functionalCoupling=\"FunctionalCoupling_{= ui:uniqueId() }\">
                <ui:call arg:leftNode=\"{= ?leftNode }\" arg:rightNode=\"{= ?rightNode }\" ui:template=\"{= edg:GetSoftwareExecutableToSoftwareExecutableDependencyDetails }\" ui:varName=\"dependencyDetails\">
                    <!--ui:dumpResultSet ui:message=\"AAA2: edg:GenerateJSONforSoftwareProgramToSoftwareExecutableDependencyDetails\"
  ui:resultSet=\"{= ?dependencyDetails }\"/-->
                    <swon:Object>
                        <edg:GenerateJSONforSoftwareExecutableToSoftwareExecutableDependencyNodes arg:dataCoupling=\"{= ?dataCoupling }\" arg:functionalCoupling=\"{= ?functionalCoupling }\" arg:leftNode=\"{= ?leftNode }\" arg:resultSet=\"{= ?dependencyDetails }\" arg:rightNode=\"{= ?rightNode }\"/>
                        <edg:GenerateJSONforSoftwareExecutableToSoftwareExecutableDependencyEdges arg:dataCoupling=\"{= ?dataCoupling }\" arg:functionalCoupling=\"{= ?functionalCoupling }\" arg:leftNode=\"{= ?leftNode }\" arg:resultSet=\"{= ?dependencyDetails }\" arg:rightNode=\"{= ?rightNode }\"/>
                    </swon:Object>
                </ui:call>
            </ui:group>
        </ui:else>
    </ui:group>
</ui:group>
"""^^ui:Literal ;
  ui:responseType ui:JSON ;
  rdfs:isDefinedBy <http://edg.topbraid.solutions/1.0/diagram/lg/software> ;
  rdfs:label "Generate JSON for software program to software executable dependency details" ;
  rdfs:subClassOf edg:DerivationMapServices ;
.
edg:GenerateLogicalFlowNodes
  a ui:Service ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate edg:flow ;
      spl:valueType edg:Flow ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:leftNode ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:parent ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:rightNode ;
      spl:valueType rdfs:Resource ;
    ] ;
  ui:errorPrototype """
<ui:group>
    <ui:if ui:condition=\"{= !bound(?flow) }\">
        <ui:throw ui:message=\"Flow is unbound in call to edg:GenerateLogicalFlowNodes\"/>
    </ui:if>
    <ui:if ui:condition=\"{= !bound(?leftNode) }\">
        <ui:throw ui:message=\"Left node is unbound in call to edg:GenerateLogicalFlowNodes\"/>
    </ui:if>
    <ui:if ui:condition=\"{= !bound(?rightNode) }\">
        <ui:throw ui:message=\"Righ node is unbound in call to edg:GenerateLogicalFlowNodes\"/>
    </ui:if>
</ui:group>
"""^^ui:Literal ;
  ui:private true ;
  ui:prototype """
<ui:group>
    <!--ui:dumpScope ui:message=\"AAA1: edg:GenerateLogicalFlowNodes - flow: {= ?flow } from {= ?leftNode } to {= ?rightNode }\"/-->
    <ui:resourceView arg:leftNode=\"{= ?leftNode }\" arg:rightNode=\"{= ?rightNode }\" ui:matchIds=\"derivation-map-composite-node\" ui:resource=\"{= ?leftNode }\"/>
    <ui:resourceView arg:leftNode=\"{= ?leftNode }\" arg:rightNode=\"{= ?rightNode }\" ui:matchIds=\"derivation-map-composite-node\" ui:resource=\"{= ?rightNode }\"/>
    <edg:BuildJSONforLineageGramNode arg:label=\"{= CONCAT(&quot;Flow: &quot;, ui:label(?flow)) }\" arg:node=\"{= ?flow }\" arg:parent=\"{= ?parent }\"/>
    <edg:GenerateContainerForResourceAndProperty arg:property=\"{= edg:informatiionTypeKind }\" arg:resource=\"{= ?flow }\" arg:text=\"Transferred Information\"/>
    <edg:GenerateContainerForResourceAndProperty arg:property=\"{= edg:transfersPackage }\" arg:resource=\"{= ?flow }\" arg:text=\"Transferred Packages\"/>
    <edg:GenerateContainerForResourceAndProperty arg:property=\"{= edg:transfersEntity }\" arg:resource=\"{= ?flow }\" arg:text=\"Transferred Entities\"/>
    <edg:GenerateContainerForResourceAndProperty arg:property=\"{= edg:realizedAs }\" arg:resource=\"{= ?flow }\" arg:text=\"Implemented As\"/>
</ui:group>
"""^^ui:Literal ;
  ui:responseType ui:JSON ;
  rdfs:isDefinedBy <http://edg.topbraid.solutions/1.0/diagram/lg/software> ;
  rdfs:label "Generate Logical Flow Nodes" ;
  rdfs:subClassOf edg:DerivationMapServices ;
.
edg:GetBusinessApplicationToBusinessApplicationLinkDetails
  a spin:SelectTemplate ;
  a spin:Template ;
  spin:body [
      a sp:Select ;
      sp:distinct true ;
      sp:resultVariables (
          [
            sp:varName "leftNodeType" ;
          ]
          [
            sp:varName "rightNodeType" ;
          ]
          [
            sp:varName "element" ;
          ]
          [
            sp:varName "elementType" ;
          ]
          [
            sp:varName "table" ;
          ]
          [
            sp:varName "tableType" ;
          ]
          [
            sp:varName "schema" ;
          ]
          [
            sp:varName "schemaType" ;
          ]
          [
            sp:varName "database" ;
          ]
          [
            sp:varName "databaseType" ;
          ]
          [
            sp:varName "server" ;
          ]
          [
            sp:varName "serverType" ;
          ]
          [
            sp:varName "leftObjectType" ;
          ]
          [
            sp:varName "rightObjectType" ;
          ]
          [
            sp:varName "leftObjectOutput" ;
          ]
          [
            sp:varName "rightObjectInput" ;
          ]
          [
            sp:varName "leftPredicate" ;
          ]
          [
            sp:varName "rightPredicate" ;
          ]
        ) ;
      sp:where (
          (
            [
              a sp:Filter ;
              sp:expression [
                  a sp:and ;
                  sp:arg1 [
                      a sp:bound ;
                      sp:arg1 [
                          sp:varName "leftNode" ;
                        ] ;
                    ] ;
                  sp:arg2 [
                      a sp:bound ;
                      sp:arg1 [
                          sp:varName "rightNode" ;
                        ] ;
                    ] ;
                ] ;
            ]
          )
          [
            a sp:Bind ;
            sp:expression [
                a spl:object ;
                sp:arg1 [
                    sp:varName "leftNode" ;
                  ] ;
                sp:arg2 rdf:type ;
              ] ;
            sp:variable [
                sp:varName "maybeLeftNodeType" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:coalesce ;
                sp:arg1 [
                    sp:varName "maybeLeftNodeType" ;
                  ] ;
                sp:arg2 edg:UNKNOWN-TYPE ;
              ] ;
            sp:variable [
                sp:varName "leftNodeType" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a spl:object ;
                sp:arg1 [
                    sp:varName "rightNode" ;
                  ] ;
                sp:arg2 rdf:type ;
              ] ;
            sp:variable [
                sp:varName "maybeRightNodeType" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:coalesce ;
                sp:arg1 [
                    sp:varName "maybeLeftNodeType" ;
                  ] ;
                sp:arg2 edg:UNKNOWN-TYPE ;
              ] ;
            sp:variable [
                sp:varName "rightNodeType" ;
              ] ;
          ]
          [
            a sp:Union ;
            sp:elements (
                (
                  [
                    sp:object [
                        sp:varName "element" ;
                      ] ;
                    sp:predicate edg:input ;
                    sp:subject [
                        sp:varName "rightNode" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "element" ;
                      ] ;
                    sp:predicate edg:output ;
                    sp:subject [
                        sp:varName "leftNode" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression [
                        a spl:object ;
                        sp:arg1 [
                            sp:varName "element" ;
                          ] ;
                        sp:arg2 rdf:type ;
                      ] ;
                    sp:variable [
                        sp:varName "maybeElementType" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression [
                        a sp:coalesce ;
                        sp:arg1 [
                            sp:varName "maybeElementType" ;
                          ] ;
                        sp:arg2 edg:UNKNOWN-TYPE ;
                      ] ;
                    sp:variable [
                        sp:varName "elementType" ;
                      ] ;
                  ]
                  [
                    a sp:Optional ;
                    sp:elements (
                        [
                          sp:object [
                              sp:varName "table" ;
                            ] ;
                          sp:predicate edg:columnOf ;
                          sp:subject [
                              sp:varName "element" ;
                            ] ;
                        ]
                        [
                          a sp:Bind ;
                          sp:expression [
                              a spl:object ;
                              sp:arg1 [
                                  sp:varName "table" ;
                                ] ;
                              sp:arg2 rdf:type ;
                            ] ;
                          sp:variable [
                              sp:varName "maybeTableType" ;
                            ] ;
                        ]
                        [
                          a sp:Bind ;
                          sp:expression [
                              a sp:coalesce ;
                              sp:arg1 [
                                  sp:varName "maybeTableType" ;
                                ] ;
                              sp:arg2 edg:UNKNOWN-TYPE ;
                            ] ;
                          sp:variable [
                              sp:varName "tableType" ;
                            ] ;
                        ]
                        [
                          a sp:Optional ;
                          sp:elements (
                              [
                                sp:object [
                                    sp:varName "schema" ;
                                  ] ;
                                sp:predicate edg:belongsToSchema ;
                                sp:subject [
                                    sp:varName "table" ;
                                  ] ;
                              ]
                              [
                                a sp:Bind ;
                                sp:expression [
                                    a spl:object ;
                                    sp:arg1 [
                                        sp:varName "schema" ;
                                      ] ;
                                    sp:arg2 rdf:type ;
                                  ] ;
                                sp:variable [
                                    sp:varName "maybeSchemaType" ;
                                  ] ;
                              ]
                              [
                                a sp:Bind ;
                                sp:expression [
                                    a sp:coalesce ;
                                    sp:arg1 [
                                        sp:varName "maybeSchemaType" ;
                                      ] ;
                                    sp:arg2 edg:UNKNOWN-TYPE ;
                                  ] ;
                                sp:variable [
                                    sp:varName "schemaType" ;
                                  ] ;
                              ]
                            ) ;
                        ]
                        [
                          a sp:Optional ;
                          sp:elements (
                              [
                                sp:object [
                                    sp:varName "database" ;
                                  ] ;
                                sp:predicate edg:tableOf ;
                                sp:subject [
                                    sp:varName "table" ;
                                  ] ;
                              ]
                              [
                                a sp:Bind ;
                                sp:expression [
                                    a spl:object ;
                                    sp:arg1 [
                                        sp:varName "database" ;
                                      ] ;
                                    sp:arg2 rdf:type ;
                                  ] ;
                                sp:variable [
                                    sp:varName "maybeDatabaseType" ;
                                  ] ;
                              ]
                              [
                                a sp:Bind ;
                                sp:expression [
                                    a sp:coalesce ;
                                    sp:arg1 [
                                        sp:varName "maybeDatabaseType" ;
                                      ] ;
                                    sp:arg2 edg:UNKNOWN-TYPE ;
                                  ] ;
                                sp:variable [
                                    sp:varName "databaseType" ;
                                  ] ;
                              ]
                            ) ;
                        ]
                      ) ;
                  ]
                )
                (
                  [
                    a sp:TriplePath ;
                    sp:object edg:usesSoftwareExecutable ;
                    sp:path [
                        a sp:ModPath ;
                        sp:modMax -2 ;
                        sp:modMin 0 ;
                        sp:subPath rdfs:subPropertyOf ;
                      ] ;
                    sp:subject [
                        sp:varName "leftPredicate" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "leftObject" ;
                      ] ;
                    sp:predicate [
                        sp:varName "leftPredicate" ;
                      ] ;
                    sp:subject [
                        sp:varName "leftNode" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression [
                        a spl:object ;
                        sp:arg1 [
                            sp:varName "leftObject" ;
                          ] ;
                        sp:arg2 rdf:type ;
                      ] ;
                    sp:variable [
                        sp:varName "maybeLeftSubordinateObjectType" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression [
                        a sp:coalesce ;
                        sp:arg1 [
                            sp:varName "maybeLeftSubordinateObjectType" ;
                          ] ;
                        sp:arg2 edg:UNKNOWN-TYPE ;
                      ] ;
                    sp:variable [
                        sp:varName "leftObjectType" ;
                      ] ;
                  ]
                  [
                    a sp:Optional ;
                    sp:elements (
                        [
                          sp:object [
                              sp:varName "leftObjectOutput" ;
                            ] ;
                          sp:predicate edg:output ;
                          sp:subject [
                              sp:varName "leftObject" ;
                            ] ;
                        ]
                        [
                          sp:object [
                              sp:varName "leftObjectOutput" ;
                            ] ;
                          sp:predicate edg:input ;
                          sp:subject [
                              sp:varName "rightNode" ;
                            ] ;
                        ]
                      ) ;
                  ]
                )
                (
                  [
                    a sp:TriplePath ;
                    sp:object edg:usesSoftwareExecutable ;
                    sp:path [
                        a sp:ModPath ;
                        sp:modMax -2 ;
                        sp:modMin 0 ;
                        sp:subPath rdfs:subPropertyOf ;
                      ] ;
                    sp:subject [
                        sp:varName "rightPredicate" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "rightObject" ;
                      ] ;
                    sp:predicate [
                        sp:varName "rightPredicate" ;
                      ] ;
                    sp:subject [
                        sp:varName "rightNode" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression [
                        a spl:object ;
                        sp:arg1 [
                            sp:varName "rightObject" ;
                          ] ;
                        sp:arg2 rdf:type ;
                      ] ;
                    sp:variable [
                        sp:varName "maybeRightSubordinateObjectType" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression [
                        a sp:coalesce ;
                        sp:arg1 [
                            sp:varName "maybeRightSubordinateObjectType" ;
                          ] ;
                        sp:arg2 edg:UNKNOWN-TYPE ;
                      ] ;
                    sp:variable [
                        sp:varName "rightObjectType" ;
                      ] ;
                  ]
                  [
                    a sp:Optional ;
                    sp:elements (
                        [
                          sp:object [
                              sp:varName "rightObjectInput" ;
                            ] ;
                          sp:predicate edg:input ;
                          sp:subject [
                              sp:varName "rightObject" ;
                            ] ;
                        ]
                        [
                          sp:object [
                              sp:varName "rightObjectInput" ;
                            ] ;
                          sp:predicate edg:output ;
                          sp:subject [
                              sp:varName "leftNode" ;
                            ] ;
                        ]
                      ) ;
                  ]
                )
                (
                  [
                    sp:object [
                        sp:varName "leftNode" ;
                      ] ;
                    sp:predicate edg:input ;
                    sp:subject [
                        sp:varName "rightNode" ;
                      ] ;
                  ]
                  [
                    a sp:TriplePath ;
                    sp:object edg:DataElement ;
                    sp:path [
                        a sp:ModPath ;
                        sp:modMax -2 ;
                        sp:modMin 0 ;
                        sp:subPath rdfs:subClassOf ;
                      ] ;
                    sp:subject [
                        sp:varName "leftNodeType" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression [
                        sp:varName "leftNode" ;
                      ] ;
                    sp:variable [
                        sp:varName "element" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression [
                        sp:varName "leftNodeType" ;
                      ] ;
                    sp:variable [
                        sp:varName "elementType" ;
                      ] ;
                  ]
                )
                (
                  [
                    a sp:TriplePath ;
                    sp:object edg:Table ;
                    sp:path [
                        a sp:ModPath ;
                        sp:modMax -2 ;
                        sp:modMin 0 ;
                        sp:subPath rdfs:subClassOf ;
                      ] ;
                    sp:subject [
                        sp:varName "leftNodeType" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "input" ;
                      ] ;
                    sp:predicate edg:input ;
                    sp:subject [
                        sp:varName "rightNode" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "leftNode" ;
                      ] ;
                    sp:predicate edg:columnOf ;
                    sp:subject [
                        sp:varName "input" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression [
                        sp:varName "leftNode" ;
                      ] ;
                    sp:variable [
                        sp:varName "element" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression [
                        sp:varName "leftNodeType" ;
                      ] ;
                    sp:variable [
                        sp:varName "elementType" ;
                      ] ;
                  ]
                )
              ) ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:leftNode ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:rightNode ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:private true ;
  rdfs:comment "Determines the structure needed to show a derivation map." ;
  rdfs:comment """TBD: Needs magic properties and functions to compute deeper structures that define dependencies. For example this is too simplistic:

  UNION
    {
        ?leftPredicate (rdfs:subPropertyOf)* edg:usesSoftwareExecutable .
        ?leftNode ?leftPredicate ?leftObject .
        BIND (spl:object(?leftObject, rdf:type) AS ?maybeLeftSubordinateObjectType) .
        BIND (COALESCE(?maybeLeftSubordinateObjectType, edg:UNKNOWN-TYPE) AS ?leftObjectType) .
        OPTIONAL {
            ?leftObject edg:output ?leftObjectOutput .
            ?rightNode edg:input ?leftObjectOutput .
        } .
    }
    UNION
    {
        ?rightPredicate (rdfs:subPropertyOf)* edg:usesSoftwareExecutable .
        ?rightNode ?rightPredicate ?rightObject .
        BIND (spl:object(?rightObject, rdf:type) AS ?maybeRightSubordinateObjectType) .
        BIND (COALESCE(?maybeRightSubordinateObjectType, edg:UNKNOWN-TYPE) AS ?rightObjectType) .
        OPTIONAL {
            ?rightObject edg:input ?rightObjectInput .
            ?leftNode edg:output ?rightObjectInput .
        } .
    }""" ;
  rdfs:isDefinedBy <http://edg.topbraid.solutions/1.0/diagram/lg/library-common> ;
  rdfs:label "Get business application to business appiication link details" ;
  rdfs:subClassOf edg:SoftwareExecutableSelectTemplates ;
.
edg:GetDeepBusinessApplicationToBusinessApplicationDependencyDetails
  a spin:SelectTemplate ;
  a spin:Template ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "leftNodeSoftwareExecutable" ;
          ]
          [
            sp:varName "leftNodeSoftwareType" ;
          ]
          [
            sp:varName "rightNodeSoftwareType" ;
          ]
          [
            sp:varName "softwareFunction" ;
          ]
          [
            sp:varName "softwareFunctionType" ;
          ]
          [
            sp:varName "rightNodeSoftwareExecutable" ;
          ]
          [
            sp:varName "dataElement" ;
          ]
          [
            sp:varName "sourceEndpoint" ;
          ]
          [
            sp:varName "targetEndpoint" ;
          ]
          [
            sp:varName "flow" ;
          ]
          [
            sp:varName "dependencyType" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Union ;
            sp:elements (
                (
                  [
                    a sp:TriplePath ;
                    sp:object [
                        sp:varName "leftNodeSoftwareExecutable" ;
                      ] ;
                    sp:path [
                        a sp:AltPath ;
                        sp:path1 edg:usesSoftwareProgram ;
                        sp:path2 edg:usesSoftwareExecutable ;
                      ] ;
                    sp:subject [
                        sp:varName "leftNode" ;
                      ] ;
                  ]
                  [
                    a sp:TriplePath ;
                    sp:object [
                        sp:varName "rightNodeSoftwareExecutable" ;
                      ] ;
                    sp:path [
                        a sp:AltPath ;
                        sp:path1 edg:usesSoftwareProgram ;
                        sp:path2 edg:usesSoftwareExecutable ;
                      ] ;
                    sp:subject [
                        sp:varName "rightNode" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "dataElement" ;
                      ] ;
                    sp:predicate edg:input ;
                    sp:subject [
                        sp:varName "rightNodeSoftwareExecutable" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "dataElement" ;
                      ] ;
                    sp:predicate edg:output ;
                    sp:subject [
                        sp:varName "leftNodeSoftwareExecutable" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression "program-io" ;
                    sp:variable [
                        sp:varName "dependencyType" ;
                      ] ;
                  ]
                )
                (
                  [
                    a sp:TriplePath ;
                    sp:object [
                        sp:varName "leftNodeSoftwareExecutable" ;
                      ] ;
                    sp:path [
                        a sp:AltPath ;
                        sp:path1 edg:usesSoftwareProgram ;
                        sp:path2 edg:usesSoftwareExecutable ;
                      ] ;
                    sp:subject [
                        sp:varName "leftNode" ;
                      ] ;
                  ]
                  [
                    a sp:TriplePath ;
                    sp:object [
                        sp:varName "rightNodeSoftwareExecutable" ;
                      ] ;
                    sp:path [
                        a sp:AltPath ;
                        sp:path1 edg:usesSoftwareProgram ;
                        sp:path2 edg:usesSoftwareExecutable ;
                      ] ;
                    sp:subject [
                        sp:varName "rightNode" ;
                      ] ;
                  ]
                  [
                    a sp:TriplePath ;
                    sp:object [
                        sp:varName "softwareFunction" ;
                      ] ;
                    sp:path [
                        a sp:ModPath ;
                        sp:modMax -2 ;
                        sp:modMin 1 ;
                        sp:subPath edg:usesSoftwareFunction ;
                      ] ;
                    sp:subject [
                        sp:varName "rightNodeSoftwareExecutable" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "dataElement" ;
                      ] ;
                    sp:predicate edg:input ;
                    sp:subject [
                        sp:varName "softwareFunction" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "dataElement" ;
                      ] ;
                    sp:predicate edg:input ;
                    sp:subject [
                        sp:varName "anotherSoftwareExecutable" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "dataElement" ;
                      ] ;
                    sp:predicate edg:output ;
                    sp:subject [
                        sp:varName "leftNodeSoftwareExecutable" ;
                      ] ;
                  ]
                  [
                    a sp:TriplePath ;
                    sp:object [
                        sp:varName "anotherSoftwareExecutable" ;
                      ] ;
                    sp:path [
                        a sp:ModPath ;
                        sp:modMax -2 ;
                        sp:modMin 1 ;
                        sp:subPath edg:usesSoftwareFunction ;
                      ] ;
                    sp:subject [
                        sp:varName "leftNodeSoftwareExecutable" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "softwareFunctionType" ;
                      ] ;
                    sp:predicate rdf:type ;
                    sp:subject [
                        sp:varName "softwareFunction" ;
                      ] ;
                  ]
                  [
                    a sp:TriplePath ;
                    sp:object edg:SoftwareFunction ;
                    sp:path [
                        a sp:ModPath ;
                        sp:modMax -2 ;
                        sp:modMin 0 ;
                        sp:subPath rdfs:subClassOf ;
                      ] ;
                    sp:subject [
                        sp:varName "softwareFunctionType" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression "function-io" ;
                    sp:variable [
                        sp:varName "dependencyType" ;
                      ] ;
                  ]
                )
                (
                  [
                    a sp:TriplePath ;
                    sp:object [
                        sp:varName "leftNodeSoftwareExecutable" ;
                      ] ;
                    sp:path [
                        a sp:ModPath ;
                        sp:modMax -1 ;
                        sp:modMin 0 ;
                        sp:subPath [
                            a sp:AltPath ;
                            sp:path1 edg:usesSoftwareProgram ;
                            sp:path2 edg:usesSoftwareExecutable ;
                          ] ;
                      ] ;
                    sp:subject [
                        sp:varName "leftNode" ;
                      ] ;
                  ]
                  [
                    a sp:TriplePath ;
                    sp:object [
                        sp:varName "rightNodeSoftwareExecutable" ;
                      ] ;
                    sp:path [
                        a sp:ModPath ;
                        sp:modMax -1 ;
                        sp:modMin 0 ;
                        sp:subPath [
                            a sp:AltPath ;
                            sp:path1 edg:usesSoftwareProgram ;
                            sp:path2 edg:usesSoftwareExecutable ;
                          ] ;
                      ] ;
                    sp:subject [
                        sp:varName "rightNode" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "sourceEndpoint" ;
                      ] ;
                    sp:predicate edg:serviceEndpoint ;
                    sp:subject [
                        sp:varName "leftNodeSoftwareExecutable" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "targetEndpoint" ;
                      ] ;
                    sp:predicate edg:serviceEndpoint ;
                    sp:subject [
                        sp:varName "rightNodeSoftwareExecutable" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "sourceEndpoint" ;
                      ] ;
                    sp:predicate edg:source ;
                    sp:subject [
                        sp:varName "flow" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "targetEndpoint" ;
                      ] ;
                    sp:predicate edg:target ;
                    sp:subject [
                        sp:varName "flow" ;
                      ] ;
                  ]
                  [
                    a sp:TriplePath ;
                    sp:object edg:Dataflow ;
                    sp:path [
                        a sp:ModPath ;
                        sp:modMax -2 ;
                        sp:modMin 0 ;
                        sp:subPath rdfs:subClassOf ;
                      ] ;
                    sp:subject [
                        sp:varName "flowType" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "flowType" ;
                      ] ;
                    sp:predicate rdf:type ;
                    sp:subject [
                        sp:varName "flow" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression "flow-io" ;
                    sp:variable [
                        sp:varName "dependencyType" ;
                      ] ;
                  ]
                )
              ) ;
          ]
          [
            sp:object [
                sp:varName "rightNodeSoftwareType" ;
              ] ;
            sp:predicate rdf:type ;
            sp:subject [
                sp:varName "rightNodeSoftwareExecutable" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "leftNodeSoftwareType" ;
              ] ;
            sp:predicate rdf:type ;
            sp:subject [
                sp:varName "leftNodeSoftwareExecutable" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:leftNode ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:rightNode ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:private true ;
  rdfs:comment "Determines the structure needed to show a derivation map." ;
  rdfs:label "Get deep business application to business appiication dependency details" ;
  rdfs:subClassOf edg:SoftwareExecutableSelectTemplates ;
.
edg:GetDependenciesOfDataElement
  a spin:Template ;
  spin:body [
      a sp:Select ;
      sp:distinct true ;
      sp:resultVariables (
          [
            sp:varName "dependency" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Union ;
            sp:elements (
                (
                  [
                    sp:object [
                        sp:varName "focusNode" ;
                      ] ;
                    sp:predicate edg:input ;
                    sp:subject [
                        sp:varName "dependency" ;
                      ] ;
                  ]
                )
                (
                  [
                    a sp:TriplePath ;
                    sp:object [
                        sp:varName "dataStructure" ;
                      ] ;
                    sp:path [
                        a sp:ModPath ;
                        sp:modMax -2 ;
                        sp:modMin 0 ;
                        sp:subPath edg:dataElementOf ;
                      ] ;
                    sp:subject [
                        sp:varName "focusNode" ;
                      ] ;
                  ]
                  [
                    a sp:TriplePath ;
                    sp:object edg:DataStructure ;
                    sp:path [
                        a sp:ModPath ;
                        sp:modMax -2 ;
                        sp:modMin 0 ;
                        sp:subPath rdfs:subClassOf ;
                      ] ;
                    sp:subject [
                        sp:varName "dataStructureClass" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "dataStructureClass" ;
                      ] ;
                    sp:predicate rdf:type ;
                    sp:subject [
                        sp:varName "dataStructure" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "dataStructure" ;
                      ] ;
                    sp:predicate edg:input ;
                    sp:subject [
                        sp:varName "dependency" ;
                      ] ;
                  ]
                )
              ) ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:focusNode ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:private true ;
  rdfs:isDefinedBy <http://edg.topbraid.solutions/1.0/diagram/lg/software> ;
  rdfs:label "Get dependencies of data element" ;
  rdfs:subClassOf edg:SelectTemplates ;
.
edg:GetDownstreamDependents
  rdfs:seeAlso edg:GetDownstreamSoftwareDependencies ;
.
edg:GetDownstreamSoftwareDependencies
  a spin:Template ;
  spin:body [
      a sp:Select ;
      sp:distinct true ;
      sp:orderBy (
          [
            sp:varName "softwareDependency" ;
          ]
        ) ;
      sp:resultVariables (
          [
            sp:varName "softwareDependency" ;
          ]
          [
            sp:varName "softwareExecutableType" ;
          ]
          [
            sp:varName "dependencyType" ;
          ]
          [
            sp:varName "flowCount" ;
          ]
          [
            sp:varName "sourceEndpoint" ;
          ]
          [
            sp:varName "targetEndpoint" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Filter ;
            sp:expression [
                a sp:bound ;
                sp:arg1 [
                    sp:varName "resource" ;
                  ] ;
              ] ;
          ]
          [
            a sp:Union ;
            sp:elements (
                (
                  [
                    sp:object [
                        sp:varName "input" ;
                      ] ;
                    sp:predicate edg:producesInformationAsset ;
                    sp:subject [
                        sp:varName "resource" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "input" ;
                      ] ;
                    sp:predicate edg:requiresInformationAsset ;
                    sp:subject [
                        sp:varName "softwareDependency" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression edg:DEPTYPE_INFO-IO ;
                    sp:variable [
                        sp:varName "dependencyType" ;
                      ] ;
                  ]
                )
                (
                  [
                    sp:object [
                        sp:varName "dataElement" ;
                      ] ;
                    sp:predicate edg:output ;
                    sp:subject [
                        sp:varName "resource" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "dataElement" ;
                      ] ;
                    sp:predicate edg:input ;
                    sp:subject [
                        sp:varName "softwareDependency" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "dataElementType" ;
                      ] ;
                    sp:predicate rdf:type ;
                    sp:subject [
                        sp:varName "dataElement" ;
                      ] ;
                  ]
                  [
                    a sp:TriplePath ;
                    sp:object edg:DataElement ;
                    sp:path [
                        a sp:ModPath ;
                        sp:modMax -2 ;
                        sp:modMin 0 ;
                        sp:subPath rdfs:subClassOf ;
                      ] ;
                    sp:subject [
                        sp:varName "dataElementType" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression [
                        a edg:getSoftwareDependencyType ;
                        arg:resource [
                            sp:varName "softwareDependency" ;
                          ] ;
                      ] ;
                    sp:variable [
                        sp:varName "dependencyType" ;
                      ] ;
                  ]
                )
                (
                  [
                    a sp:TriplePath ;
                    sp:object [
                        sp:varName "resource" ;
                      ] ;
                    sp:path [
                        a sp:AltPath ;
                        sp:path1 edg:usesSoftwareExecutable ;
                        sp:path2 edg:usesSoftwareProgram ;
                      ] ;
                    sp:subject [
                        sp:varName "softwareDependency" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "dataElement" ;
                      ] ;
                    sp:predicate edg:output ;
                    sp:subject [
                        sp:varName "softwareExecutable" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "dataElement" ;
                      ] ;
                    sp:predicate edg:input ;
                    sp:subject [
                        sp:varName "softwareDependency" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression edg:DEPTYPE_PROGRAM-IO ;
                    sp:variable [
                        sp:varName "dependencyType" ;
                      ] ;
                  ]
                )
                (
                  [
                    a sp:TriplePath ;
                    sp:object [
                        sp:varName "softwareFunction" ;
                      ] ;
                    sp:path [
                        a sp:SeqPath ;
                        sp:path1 [
                            a sp:AltPath ;
                            sp:path1 edg:usesSoftwareProgram ;
                            sp:path2 edg:hasSoftwareProgram ;
                          ] ;
                        sp:path2 [
                            a sp:ModPath ;
                            sp:modMax -2 ;
                            sp:modMin 1 ;
                            sp:subPath edg:usesSoftwareFunction ;
                          ] ;
                      ] ;
                    sp:subject [
                        sp:varName "resource" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "dataElement" ;
                      ] ;
                    sp:predicate edg:output ;
                    sp:subject [
                        sp:varName "softwareFunction" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "dataElement" ;
                      ] ;
                    sp:predicate edg:input ;
                    sp:subject [
                        sp:varName "softwareDependency" ;
                      ] ;
                  ]
                  [
                    a sp:Filter ;
                    sp:expression [
                        a sp:ne ;
                        sp:arg1 [
                            sp:varName "softwareDependency" ;
                          ] ;
                        sp:arg2 [
                            sp:varName "resource" ;
                          ] ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression edg:DEPTYPE_FUNCTION-IO ;
                    sp:variable [
                        sp:varName "dependencyType" ;
                      ] ;
                  ]
                )
                (
                  [
                    sp:object [
                        sp:varName "resource" ;
                      ] ;
                    sp:predicate edg:dependsOnDataFrom ;
                    sp:subject [
                        sp:varName "softwareDependency" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression edg:DEPTYPE_DIRECT ;
                    sp:variable [
                        sp:varName "dependencyType" ;
                      ] ;
                  ]
                )
                (
                  [
                    sp:object [
                        sp:varName "softwareType" ;
                      ] ;
                    sp:predicate rdf:type ;
                    sp:subject [
                        sp:varName "resource" ;
                      ] ;
                  ]
                  [
                    a sp:Union ;
                    sp:elements (
                        (
                          [
                            a sp:TriplePath ;
                            sp:object edg:LineageModel ;
                            sp:path [
                                a sp:ModPath ;
                                sp:modMax -2 ;
                                sp:modMin 0 ;
                                sp:subPath rdfs:subClassOf ;
                              ] ;
                            sp:subject [
                                sp:varName "softwareType" ;
                              ] ;
                          ]
                          [
                            a sp:TriplePath ;
                            sp:object [
                                sp:varName "softwareDependency" ;
                              ] ;
                            sp:path [
                                a sp:AltPath ;
                                sp:path1 edg:usesSoftwareExecutable ;
                                sp:path2 edg:usesPipeline ;
                              ] ;
                            sp:subject [
                                sp:varName "resource" ;
                              ] ;
                          ]
                          [
                            a sp:Bind ;
                            sp:expression edg:DEPTYPE_PROGRAM-USAGE ;
                            sp:variable [
                                sp:varName "dependencyType" ;
                              ] ;
                          ]
                        )
                        (
                          [
                            a sp:TriplePath ;
                            sp:object edg:Pipeline ;
                            sp:path [
                                a sp:ModPath ;
                                sp:modMax -2 ;
                                sp:modMin 0 ;
                                sp:subPath rdfs:subClassOf ;
                              ] ;
                            sp:subject [
                                sp:varName "softwareType" ;
                              ] ;
                          ]
                          [
                            a sp:TriplePath ;
                            sp:object [
                                sp:varName "softwareDependency" ;
                              ] ;
                            sp:path [
                                a sp:AltPath ;
                                sp:path1 [
                                    a sp:AltPath ;
                                    sp:path1 edg:usesPipeline ;
                                    sp:path2 edg:usesSoftwareExecutable ;
                                  ] ;
                                sp:path2 edg:pipelineStep ;
                              ] ;
                            sp:subject [
                                sp:varName "resource" ;
                              ] ;
                          ]
                          [
                            a sp:Bind ;
                            sp:expression edg:DEPTYPE_PROGRAM-USAGE ;
                            sp:variable [
                                sp:varName "dependencyType" ;
                              ] ;
                          ]
                        )
                        (
                          [
                            a sp:TriplePath ;
                            sp:object edg:PipelineStep ;
                            sp:path [
                                a sp:ModPath ;
                                sp:modMax -2 ;
                                sp:modMin 0 ;
                                sp:subPath rdfs:subClassOf ;
                              ] ;
                            sp:subject [
                                sp:varName "softwareType" ;
                              ] ;
                          ]
                          [
                            sp:object [
                                sp:varName "softwareDependency" ;
                              ] ;
                            sp:predicate edg:usesSoftwareProgram ;
                            sp:subject [
                                sp:varName "resource" ;
                              ] ;
                          ]
                          [
                            a sp:Bind ;
                            sp:expression edg:DEPTYPE_PROGRAM-USAGE ;
                            sp:variable [
                                sp:varName "dependencyType" ;
                              ] ;
                          ]
                        )
                      ) ;
                  ]
                )
                (
                  [
                    sp:object [
                        sp:varName "targetEndpoint" ;
                      ] ;
                    sp:predicate edg:serviceEndpoint ;
                    sp:subject [
                        sp:varName "resource" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "targetEndpoint" ;
                      ] ;
                    sp:predicate edg:source ;
                    sp:subject [
                        sp:varName "flow" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "sourceEndpoint" ;
                      ] ;
                    sp:predicate edg:target ;
                    sp:subject [
                        sp:varName "flow" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "sourceEndpoint" ;
                      ] ;
                    sp:predicate edg:serviceEndpoint ;
                    sp:subject [
                        sp:varName "softwareDependency" ;
                      ] ;
                  ]
                )
                (
                  [
                    a sp:SubQuery ;
                    sp:query [
                        a sp:Select ;
                        sp:distinct true ;
                        sp:groupBy (
                            [
                              sp:varName "softwareDependency" ;
                            ]
                            [
                              sp:varName "softwareExecutableType" ;
                            ]
                            [
                              sp:varName "dependencyType" ;
                            ]
                            [
                              sp:varName "sourceEndpoint" ;
                            ]
                            [
                              sp:varName "targetEndpoint" ;
                            ]
                          ) ;
                        sp:resultVariables (
                            [
                              sp:varName "softwareDependency" ;
                            ]
                            [
                              sp:varName "dependencyType" ;
                            ]
                            [
                              sp:expression [
                                  a sp:Count ;
                                  sp:expression [
                                      sp:varName "flow" ;
                                    ] ;
                                ] ;
                              sp:varName "flowCount" ;
                            ]
                          ) ;
                        sp:where (
                            [
                              sp:object [
                                  sp:varName "resource" ;
                                ] ;
                              sp:predicate edg:source ;
                              sp:subject [
                                  sp:varName "flow" ;
                                ] ;
                            ]
                            [
                              sp:object [
                                  sp:varName "softwareDependency" ;
                                ] ;
                              sp:predicate edg:target ;
                              sp:subject [
                                  sp:varName "flow" ;
                                ] ;
                            ]
                            [
                              a sp:Union ;
                              sp:elements (
                                  (
                                    [
                                      sp:object [
                                          sp:varName "flowType" ;
                                        ] ;
                                      sp:predicate rdf:type ;
                                      sp:subject [
                                          sp:varName "flow" ;
                                        ] ;
                                    ]
                                    [
                                      a sp:Filter ;
                                      sp:expression [
                                          a sp:eq ;
                                          sp:arg1 [
                                              sp:varName "flowType" ;
                                            ] ;
                                          sp:arg2 edg:Feedline ;
                                        ] ;
                                    ]
                                    [
                                      a sp:Bind ;
                                      sp:expression edg:DEPTYPE_FEEDLINE ;
                                      sp:variable [
                                          sp:varName "dependencyType" ;
                                        ] ;
                                    ]
                                  )
                                  (
                                    [
                                      sp:object [
                                          sp:varName "flowType" ;
                                        ] ;
                                      sp:predicate rdf:type ;
                                      sp:subject [
                                          sp:varName "flow" ;
                                        ] ;
                                    ]
                                    [
                                      a sp:Filter ;
                                      sp:expression [
                                          a sp:eq ;
                                          sp:arg1 [
                                              sp:varName "flowType" ;
                                            ] ;
                                          sp:arg2 edg:Dataflow ;
                                        ] ;
                                    ]
                                    [
                                      a sp:Bind ;
                                      sp:expression edg:DEPTYPE_DATAFLOW ;
                                      sp:variable [
                                          sp:varName "dependencyType" ;
                                        ] ;
                                    ]
                                  )
                                  (
                                    [
                                      sp:object [
                                          sp:varName "flowType" ;
                                        ] ;
                                      sp:predicate rdf:type ;
                                      sp:subject [
                                          sp:varName "flow" ;
                                        ] ;
                                    ]
                                    [
                                      a sp:Filter ;
                                      sp:expression [
                                          a sp:eq ;
                                          sp:arg1 [
                                              sp:varName "flowType" ;
                                            ] ;
                                          sp:arg2 edg:LogicalFlow ;
                                        ] ;
                                    ]
                                    [
                                      a sp:Bind ;
                                      sp:expression edg:DEPTYPE_LOGICAL-FLOW ;
                                      sp:variable [
                                          sp:varName "dependencyType" ;
                                        ] ;
                                    ]
                                  )
                                ) ;
                            ]
                          ) ;
                      ] ;
                  ]
                )
              ) ;
          ]
          [
            sp:object [
                sp:varName "softwareExecutableType" ;
              ] ;
            sp:predicate rdf:type ;
            sp:subject [
                sp:varName "softwareDependency" ;
              ] ;
          ]
          [
            a sp:TriplePath ;
            sp:object [
                sp:varName "parentClass" ;
              ] ;
            sp:path [
                a sp:ModPath ;
                sp:modMax -2 ;
                sp:modMin 0 ;
                sp:subPath rdfs:subClassOf ;
              ] ;
            sp:subject [
                sp:varName "softwareExecutableType" ;
              ] ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:in ;
                sp:arg1 [
                    sp:varName "parentClass" ;
                  ] ;
                sp:arg2 edg:BusinessApplication ;
                sp:arg3 edg:Pipeline ;
                sp:arg4 edg:PipelineStep ;
                sp:arg5 edg:Interoperable ;
                sp:arg6 edg:SoftwareProgram ;
                sp:arg7 edg:SoftwareFunction ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:private true ;
  rdfs:isDefinedBy <http://edg.topbraid.solutions/1.0/diagram/lg/software> ;
  rdfs:label "Get downstream software dependencies" ;
  rdfs:seeAlso edg:GetDownstreamDependents ;
  rdfs:seeAlso edg:GetUpstreamDependencies ;
  rdfs:subClassOf edg:SelectTemplates ;
.
edg:GetSoftwareDependents
  a spin:Template ;
  spin:body [
      a sp:Select ;
      sp:distinct true ;
      sp:orderBy (
          [
            sp:varName "dependent" ;
          ]
        ) ;
      sp:resultVariables (
          [
            sp:varName "dependent" ;
          ]
          [
            sp:varName "dependentType" ;
          ]
          [
            sp:varName "parent" ;
          ]
          [
            sp:varName "containmentProperty" ;
          ]
          [
            sp:varName "dependencyType" ;
          ]
          [
            sp:varName "flowCount" ;
          ]
          [
            sp:varName "sourceEndpoint" ;
          ]
          [
            sp:varName "targetEndpoint" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Filter ;
            sp:expression [
                a sp:bound ;
                sp:arg1 [
                    sp:varName "resource" ;
                  ] ;
              ] ;
          ]
          [
            a sp:Union ;
            sp:elements (
                (
                  [
                    sp:object [
                        sp:varName "input" ;
                      ] ;
                    sp:predicate edg:producesInformationAsset ;
                    sp:subject [
                        sp:varName "resource" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "input" ;
                      ] ;
                    sp:predicate edg:requiresInformationAsset ;
                    sp:subject [
                        sp:varName "dependent" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression edg:DEPTYPE_INFO-IO ;
                    sp:variable [
                        sp:varName "dependencyType" ;
                      ] ;
                  ]
                )
                (
                  [
                    sp:object [
                        sp:varName "dataElement" ;
                      ] ;
                    sp:predicate edg:output ;
                    sp:subject [
                        sp:varName "resource" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "dataElement" ;
                      ] ;
                    sp:predicate edg:input ;
                    sp:subject [
                        sp:varName "dependent" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "dataElementType" ;
                      ] ;
                    sp:predicate rdf:type ;
                    sp:subject [
                        sp:varName "dataElement" ;
                      ] ;
                  ]
                  [
                    a sp:TriplePath ;
                    sp:object edg:DataElement ;
                    sp:path [
                        a sp:ModPath ;
                        sp:modMax -2 ;
                        sp:modMin 0 ;
                        sp:subPath rdfs:subClassOf ;
                      ] ;
                    sp:subject [
                        sp:varName "dataElementType" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression [
                        a edg:getSoftwareDependencyType ;
                        arg:resource [
                            sp:varName "dependent" ;
                          ] ;
                      ] ;
                    sp:variable [
                        sp:varName "dependencyType" ;
                      ] ;
                  ]
                )
                (
                  [
                    a sp:TriplePath ;
                    sp:object [
                        sp:varName "resource" ;
                      ] ;
                    sp:path [
                        a sp:AltPath ;
                        sp:path1 edg:usesSoftwareExecutable ;
                        sp:path2 edg:usesSoftwareProgram ;
                      ] ;
                    sp:subject [
                        sp:varName "dependent" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "dataElement" ;
                      ] ;
                    sp:predicate edg:output ;
                    sp:subject [
                        sp:varName "softwareExecutable" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "dataElement" ;
                      ] ;
                    sp:predicate edg:input ;
                    sp:subject [
                        sp:varName "dependent" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression edg:DEPTYPE_PROGRAM-IO ;
                    sp:variable [
                        sp:varName "dependencyType" ;
                      ] ;
                  ]
                )
                (
                  [
                    a sp:TriplePath ;
                    sp:object [
                        sp:varName "softwareFunction" ;
                      ] ;
                    sp:path [
                        a sp:SeqPath ;
                        sp:path1 [
                            a sp:AltPath ;
                            sp:path1 edg:usesSoftwareProgram ;
                            sp:path2 edg:hasSoftwareProgram ;
                          ] ;
                        sp:path2 [
                            a sp:ModPath ;
                            sp:modMax -2 ;
                            sp:modMin 1 ;
                            sp:subPath edg:usesSoftwareFunction ;
                          ] ;
                      ] ;
                    sp:subject [
                        sp:varName "resource" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "dataElement" ;
                      ] ;
                    sp:predicate edg:output ;
                    sp:subject [
                        sp:varName "softwareFunction" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "dataElement" ;
                      ] ;
                    sp:predicate edg:input ;
                    sp:subject [
                        sp:varName "dependent" ;
                      ] ;
                  ]
                  [
                    a sp:Filter ;
                    sp:expression [
                        a sp:ne ;
                        sp:arg1 [
                            sp:varName "dependent" ;
                          ] ;
                        sp:arg2 [
                            sp:varName "resource" ;
                          ] ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression edg:DEPTYPE_FUNCTION-IO ;
                    sp:variable [
                        sp:varName "dependencyType" ;
                      ] ;
                  ]
                )
                (
                  [
                    sp:object [
                        sp:varName "resource" ;
                      ] ;
                    sp:predicate edg:dependsOnDataFrom ;
                    sp:subject [
                        sp:varName "dependent" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression edg:DEPTYPE_DIRECT ;
                    sp:variable [
                        sp:varName "dependencyType" ;
                      ] ;
                  ]
                )
                (
                  [
                    sp:object [
                        sp:varName "softwareType" ;
                      ] ;
                    sp:predicate rdf:type ;
                    sp:subject [
                        sp:varName "resource" ;
                      ] ;
                  ]
                  [
                    a sp:Union ;
                    sp:elements (
                        (
                          [
                            a sp:TriplePath ;
                            sp:object edg:LineageModel ;
                            sp:path [
                                a sp:ModPath ;
                                sp:modMax -2 ;
                                sp:modMin 0 ;
                                sp:subPath rdfs:subClassOf ;
                              ] ;
                            sp:subject [
                                sp:varName "softwareType" ;
                              ] ;
                          ]
                          [
                            a sp:TriplePath ;
                            sp:object [
                                sp:varName "dependent" ;
                              ] ;
                            sp:path [
                                a sp:AltPath ;
                                sp:path1 edg:usesSoftwareExecutable ;
                                sp:path2 edg:usesPipeline ;
                              ] ;
                            sp:subject [
                                sp:varName "resource" ;
                              ] ;
                          ]
                          [
                            a sp:Bind ;
                            sp:expression edg:DEPTYPE_PROGRAM-USAGE ;
                            sp:variable [
                                sp:varName "dependencyType" ;
                              ] ;
                          ]
                        )
                        (
                          [
                            a sp:TriplePath ;
                            sp:object edg:Pipeline ;
                            sp:path [
                                a sp:ModPath ;
                                sp:modMax -2 ;
                                sp:modMin 0 ;
                                sp:subPath rdfs:subClassOf ;
                              ] ;
                            sp:subject [
                                sp:varName "softwareType" ;
                              ] ;
                          ]
                          [
                            a sp:TriplePath ;
                            sp:object [
                                sp:varName "dependent" ;
                              ] ;
                            sp:path [
                                a sp:AltPath ;
                                sp:path1 [
                                    a sp:AltPath ;
                                    sp:path1 edg:usesPipeline ;
                                    sp:path2 edg:usesSoftwareExecutable ;
                                  ] ;
                                sp:path2 edg:pipelineStep ;
                              ] ;
                            sp:subject [
                                sp:varName "resource" ;
                              ] ;
                          ]
                          [
                            a sp:Bind ;
                            sp:expression edg:DEPTYPE_PROGRAM-USAGE ;
                            sp:variable [
                                sp:varName "dependencyType" ;
                              ] ;
                          ]
                        )
                        (
                          [
                            a sp:TriplePath ;
                            sp:object edg:PipelineStep ;
                            sp:path [
                                a sp:ModPath ;
                                sp:modMax -2 ;
                                sp:modMin 0 ;
                                sp:subPath rdfs:subClassOf ;
                              ] ;
                            sp:subject [
                                sp:varName "softwareType" ;
                              ] ;
                          ]
                          [
                            sp:object [
                                sp:varName "dependent" ;
                              ] ;
                            sp:predicate edg:usesSoftwareProgram ;
                            sp:subject [
                                sp:varName "resource" ;
                              ] ;
                          ]
                          [
                            a sp:Bind ;
                            sp:expression edg:DEPTYPE_PROGRAM-USAGE ;
                            sp:variable [
                                sp:varName "dependencyType" ;
                              ] ;
                          ]
                        )
                      ) ;
                  ]
                )
                (
                  [
                    sp:object [
                        sp:varName "targetEndpoint" ;
                      ] ;
                    sp:predicate edg:serviceEndpoint ;
                    sp:subject [
                        sp:varName "resource" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "targetEndpoint" ;
                      ] ;
                    sp:predicate edg:source ;
                    sp:subject [
                        sp:varName "flow" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "sourceEndpoint" ;
                      ] ;
                    sp:predicate edg:target ;
                    sp:subject [
                        sp:varName "flow" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "sourceEndpoint" ;
                      ] ;
                    sp:predicate edg:serviceEndpoint ;
                    sp:subject [
                        sp:varName "dependent" ;
                      ] ;
                  ]
                )
                (
                  [
                    a sp:SubQuery ;
                    sp:query [
                        a sp:Select ;
                        sp:distinct true ;
                        sp:groupBy (
                            [
                              sp:varName "dependent" ;
                            ]
                            [
                              sp:varName "dependencyType" ;
                            ]
                            [
                              sp:varName "sourceEndpoint" ;
                            ]
                            [
                              sp:varName "targetEndpoint" ;
                            ]
                          ) ;
                        sp:resultVariables (
                            [
                              sp:varName "dependent" ;
                            ]
                            [
                              sp:varName "dependencyType" ;
                            ]
                            [
                              sp:expression [
                                  a sp:Count ;
                                  sp:expression [
                                      sp:varName "flow" ;
                                    ] ;
                                ] ;
                              sp:varName "flowCount" ;
                            ]
                          ) ;
                        sp:where (
                            [
                              sp:object [
                                  sp:varName "resource" ;
                                ] ;
                              sp:predicate edg:source ;
                              sp:subject [
                                  sp:varName "flow" ;
                                ] ;
                            ]
                            [
                              sp:object [
                                  sp:varName "dependent" ;
                                ] ;
                              sp:predicate edg:target ;
                              sp:subject [
                                  sp:varName "flow" ;
                                ] ;
                            ]
                            [
                              a sp:Union ;
                              sp:elements (
                                  (
                                    [
                                      sp:object [
                                          sp:varName "flowType" ;
                                        ] ;
                                      sp:predicate rdf:type ;
                                      sp:subject [
                                          sp:varName "flow" ;
                                        ] ;
                                    ]
                                    [
                                      a sp:Filter ;
                                      sp:expression [
                                          a sp:eq ;
                                          sp:arg1 [
                                              sp:varName "flowType" ;
                                            ] ;
                                          sp:arg2 edg:Feedline ;
                                        ] ;
                                    ]
                                    [
                                      a sp:Bind ;
                                      sp:expression edg:DEPTYPE_FEEDLINE ;
                                      sp:variable [
                                          sp:varName "dependencyType" ;
                                        ] ;
                                    ]
                                  )
                                  (
                                    [
                                      sp:object [
                                          sp:varName "flowType" ;
                                        ] ;
                                      sp:predicate rdf:type ;
                                      sp:subject [
                                          sp:varName "flow" ;
                                        ] ;
                                    ]
                                    [
                                      a sp:Filter ;
                                      sp:expression [
                                          a sp:eq ;
                                          sp:arg1 [
                                              sp:varName "flowType" ;
                                            ] ;
                                          sp:arg2 edg:Dataflow ;
                                        ] ;
                                    ]
                                    [
                                      a sp:Bind ;
                                      sp:expression edg:DEPTYPE_DATAFLOW ;
                                      sp:variable [
                                          sp:varName "dependencyType" ;
                                        ] ;
                                    ]
                                  )
                                  (
                                    [
                                      sp:object [
                                          sp:varName "flowType" ;
                                        ] ;
                                      sp:predicate rdf:type ;
                                      sp:subject [
                                          sp:varName "flow" ;
                                        ] ;
                                    ]
                                    [
                                      a sp:Filter ;
                                      sp:expression [
                                          a sp:eq ;
                                          sp:arg1 [
                                              sp:varName "flowType" ;
                                            ] ;
                                          sp:arg2 edg:LogicalFlow ;
                                        ] ;
                                    ]
                                    [
                                      a sp:Bind ;
                                      sp:expression edg:DEPTYPE_LOGICAL-FLOW ;
                                      sp:variable [
                                          sp:varName "dependencyType" ;
                                        ] ;
                                    ]
                                  )
                                ) ;
                            ]
                          ) ;
                      ] ;
                  ]
                )
              ) ;
          ]
          [
            sp:object [
                sp:varName "dependentType" ;
              ] ;
            sp:predicate rdf:type ;
            sp:subject [
                sp:varName "dependent" ;
              ] ;
          ]
          [
            a sp:TriplePath ;
            sp:object [
                sp:varName "parentClass" ;
              ] ;
            sp:path [
                a sp:ModPath ;
                sp:modMax -2 ;
                sp:modMin 0 ;
                sp:subPath rdfs:subClassOf ;
              ] ;
            sp:subject [
                sp:varName "dependentType" ;
              ] ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:in ;
                sp:arg1 [
                    sp:varName "parentClass" ;
                  ] ;
                sp:arg2 edg:BusinessApplication ;
                sp:arg3 edg:Pipeline ;
                sp:arg4 edg:PipelineStep ;
                sp:arg5 edg:Interoperable ;
                sp:arg6 edg:SoftwareProgram ;
                sp:arg7 edg:SoftwareFunction ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a edg:highestDepictionForSoftwareExecutable ;
                arg:software [
                    sp:varName "dependent" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "parent" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:private true ;
  rdfs:comment "Finds software executables that are dependent on a given resource. Conforms to the interface of edg:GetDataDependents." ;
  rdfs:isDefinedBy <http://edg.topbraid.solutions/1.0/diagram/lg/software> ;
  rdfs:label "Get software dependents" ;
  rdfs:seeAlso edg:GetDataDependents ;
  rdfs:seeAlso edg:GetDownstreamDependents ;
  rdfs:seeAlso edg:GetDownstreamSoftwareDependencies ;
  rdfs:seeAlso edg:GetUpstreamDependencies ;
  rdfs:subClassOf edg:SelectTemplates ;
.
edg:GetSoftwareExecutableToSoftwareExecutableDependencyDetails
  a spin:SelectTemplate ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "leftNodeSoftwareExecutable" ;
          ]
          [
            sp:varName "leftNodeSoftwareType" ;
          ]
          [
            sp:varName "rightNodeSoftwareType" ;
          ]
          [
            sp:varName "softwareFunction" ;
          ]
          [
            sp:varName "softwareFunctionType" ;
          ]
          [
            sp:varName "rightNodeSoftwareExecutable" ;
          ]
          [
            sp:varName "dataElement" ;
          ]
          [
            sp:varName "case" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Union ;
            sp:elements (
                (
                  [
                    a sp:TriplePath ;
                    sp:object [
                        sp:varName "leftNodeSoftwareExecutable" ;
                      ] ;
                    sp:path [
                        a sp:ModPath ;
                        sp:modMax -2 ;
                        sp:modMin 0 ;
                        sp:subPath edg:usesSoftwareProgram ;
                      ] ;
                    sp:subject [
                        sp:varName "leftNode" ;
                      ] ;
                  ]
                  [
                    a sp:TriplePath ;
                    sp:object [
                        sp:varName "rightNodeSoftwareExecutable" ;
                      ] ;
                    sp:path [
                        a sp:ModPath ;
                        sp:modMax -2 ;
                        sp:modMin 0 ;
                        sp:subPath edg:usesSoftwareProgram ;
                      ] ;
                    sp:subject [
                        sp:varName "rightNode" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "rightNodeSoftwareType" ;
                      ] ;
                    sp:predicate rdf:type ;
                    sp:subject [
                        sp:varName "rightNodeSoftwareExecutable" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "leftNodeSoftwareType" ;
                      ] ;
                    sp:predicate rdf:type ;
                    sp:subject [
                        sp:varName "leftNodeSoftwareExecutable" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "dataElement" ;
                      ] ;
                    sp:predicate edg:input ;
                    sp:subject [
                        sp:varName "rightNodeSoftwareExecutable" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "dataElement" ;
                      ] ;
                    sp:predicate edg:output ;
                    sp:subject [
                        sp:varName "leftNodeSoftwareExecutable" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression 1 ;
                    sp:variable [
                        sp:varName "case" ;
                      ] ;
                  ]
                )
                (
                  [
                    a sp:TriplePath ;
                    sp:object [
                        sp:varName "leftNodeSoftwareExecutable" ;
                      ] ;
                    sp:path [
                        a sp:ModPath ;
                        sp:modMax -2 ;
                        sp:modMin 0 ;
                        sp:subPath edg:usesSoftwareProgram ;
                      ] ;
                    sp:subject [
                        sp:varName "leftNode" ;
                      ] ;
                  ]
                  [
                    a sp:TriplePath ;
                    sp:object [
                        sp:varName "rightNodeSoftwareExecutable" ;
                      ] ;
                    sp:path [
                        a sp:ModPath ;
                        sp:modMax -2 ;
                        sp:modMin 0 ;
                        sp:subPath edg:usesSoftwareProgram ;
                      ] ;
                    sp:subject [
                        sp:varName "rightNode" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "rightNodeSoftwareType" ;
                      ] ;
                    sp:predicate rdf:type ;
                    sp:subject [
                        sp:varName "rightNodeSoftwareExecutable" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "leftNodeSoftwareType" ;
                      ] ;
                    sp:predicate rdf:type ;
                    sp:subject [
                        sp:varName "leftNodeSoftwareExecutable" ;
                      ] ;
                  ]
                  [
                    a sp:TriplePath ;
                    sp:object [
                        sp:varName "softwareFunction" ;
                      ] ;
                    sp:path [
                        a sp:ModPath ;
                        sp:modMax -2 ;
                        sp:modMin 1 ;
                        sp:subPath edg:usesSoftwareFunction ;
                      ] ;
                    sp:subject [
                        sp:varName "leftNodeSoftwareExecutable" ;
                      ] ;
                  ]
                  [
                    a sp:TriplePath ;
                    sp:object [
                        sp:varName "softwareFunction" ;
                      ] ;
                    sp:path [
                        a sp:ModPath ;
                        sp:modMax -2 ;
                        sp:modMin 1 ;
                        sp:subPath edg:usesSoftwareFunction ;
                      ] ;
                    sp:subject [
                        sp:varName "rightNodeSoftwareExecutable" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "dataElement" ;
                      ] ;
                    sp:predicate edg:input ;
                    sp:subject [
                        sp:varName "rightNodeSoftwareExecutable" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "dataElement" ;
                      ] ;
                    sp:predicate edg:output ;
                    sp:subject [
                        sp:varName "softwareFunction" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "softwareFunctionType" ;
                      ] ;
                    sp:predicate rdf:type ;
                    sp:subject [
                        sp:varName "softwareFunction" ;
                      ] ;
                  ]
                  [
                    a sp:TriplePath ;
                    sp:object edg:SoftwareFunction ;
                    sp:path [
                        a sp:ModPath ;
                        sp:modMax -2 ;
                        sp:modMin 0 ;
                        sp:subPath rdfs:subClassOf ;
                      ] ;
                    sp:subject [
                        sp:varName "softwareFunctionType" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression 2 ;
                    sp:variable [
                        sp:varName "case" ;
                      ] ;
                  ]
                )
                (
                  [
                    a sp:TriplePath ;
                    sp:object [
                        sp:varName "softwareFunction" ;
                      ] ;
                    sp:path [
                        a sp:ModPath ;
                        sp:modMax -2 ;
                        sp:modMin 1 ;
                        sp:subPath edg:usesSoftwareFunction ;
                      ] ;
                    sp:subject [
                        sp:varName "leftNode" ;
                      ] ;
                  ]
                  [
                    a sp:TriplePath ;
                    sp:object [
                        sp:varName "softwareFunction" ;
                      ] ;
                    sp:path [
                        a sp:SeqPath ;
                        sp:path1 [
                            a sp:ModPath ;
                            sp:modMax -2 ;
                            sp:modMin 0 ;
                            sp:subPath edg:usesSoftwareProgram ;
                          ] ;
                        sp:path2 [
                            a sp:ModPath ;
                            sp:modMax -2 ;
                            sp:modMin 1 ;
                            sp:subPath edg:usesSoftwareFunction ;
                          ] ;
                      ] ;
                    sp:subject [
                        sp:varName "rightNode" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "dataElement" ;
                      ] ;
                    sp:predicate edg:input ;
                    sp:subject [
                        sp:varName "rightNode" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "dataElement" ;
                      ] ;
                    sp:predicate edg:output ;
                    sp:subject [
                        sp:varName "softwareFunction" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "softwareFunctionType" ;
                      ] ;
                    sp:predicate rdf:type ;
                    sp:subject [
                        sp:varName "softwareFunction" ;
                      ] ;
                  ]
                  [
                    a sp:TriplePath ;
                    sp:object edg:SoftwareFunction ;
                    sp:path [
                        a sp:ModPath ;
                        sp:modMax -2 ;
                        sp:modMin 0 ;
                        sp:subPath rdfs:subClassOf ;
                      ] ;
                    sp:subject [
                        sp:varName "softwareFunctionType" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression 3 ;
                    sp:variable [
                        sp:varName "case" ;
                      ] ;
                  ]
                )
              ) ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:leftNode ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:rightNode ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:private true ;
  rdfs:comment "Determines the structure needed to show a derivation map." ;
  rdfs:label "get software executable to software executable dependency details" ;
  rdfs:subClassOf edg:SelectTemplates ;
.
edg:GetSoftwareParents
  a spin:SelectTemplate ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "childSoftware" ;
          ]
          [
            sp:varName "parentSoftware" ;
          ]
          [
            sp:varName "level" ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "software" ;
              ] ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "?0" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "?1" ;
              ] ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "?0" ;
              ] ;
          ]
          [
            sp:object 1 ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "?1" ;
              ] ;
          ]
          [
            sp:object () ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "?1" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "?2" ;
              ] ;
            sp:predicate edg:getSoftwareParentage ;
            sp:subject [
                sp:varName "?0" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "childSoftware" ;
              ] ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "?2" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "?3" ;
              ] ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "?2" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "parentSoftware" ;
              ] ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "?3" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "?4" ;
              ] ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "?3" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "level" ;
              ] ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "?4" ;
              ] ;
          ]
          [
            sp:object () ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "?4" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:software ;
      spl:valueType edg:SoftwareExecutable ;
    ] ;
  spin:private true ;
  spin:returnType rdfs:Resource ;
  rdfs:label "Get software parents" ;
  rdfs:subClassOf edg:SelectTemplates ;
.
edg:GetUpstreamDependencies
  a spin:Template ;
  spin:body [
      a sp:Select ;
      sp:distinct true ;
      sp:orderBy (
          [
            sp:varName "softwareDependency" ;
          ]
        ) ;
      sp:resultVariables (
          [
            sp:varName "softwareDependency" ;
          ]
          [
            sp:varName "softwareExecutableType" ;
          ]
          [
            sp:varName "dependencyType" ;
          ]
          [
            sp:varName "flowCount" ;
          ]
          [
            sp:varName "sourceEndpoint" ;
          ]
          [
            sp:varName "targetEndpoint" ;
          ]
          [
            sp:varName "activeExecutable" ;
          ]
          [
            sp:varName "dataDependency" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Filter ;
            sp:expression [
                a sp:bound ;
                sp:arg1 [
                    sp:varName "resource" ;
                  ] ;
              ] ;
          ]
          [
            a sp:Union ;
            sp:elements (
                (
                  [
                    sp:object [
                        sp:varName "input" ;
                      ] ;
                    sp:predicate edg:requiresInformationAsset ;
                    sp:subject [
                        sp:varName "resource" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "input" ;
                      ] ;
                    sp:predicate edg:producesInformationAsset ;
                    sp:subject [
                        sp:varName "softwareDependency" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression [
                        sp:varName "softwareDependency" ;
                      ] ;
                    sp:variable [
                        sp:varName "activeExecutable" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression edg:DEPTYPE_INFO-IO ;
                    sp:variable [
                        sp:varName "dependencyType" ;
                      ] ;
                  ]
                )
                (
                  [
                    a sp:TriplePath ;
                    sp:object provo:wasDerivedFrom ;
                    sp:path [
                        a sp:ModPath ;
                        sp:modMax -2 ;
                        sp:modMin 0 ;
                        sp:subPath rdfs:subPropertyOf ;
                      ] ;
                    sp:subject [
                        sp:varName "property" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "dataDependency" ;
                      ] ;
                    sp:predicate [
                        sp:varName "property" ;
                      ] ;
                    sp:subject [
                        sp:varName "resource" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "dependencyClass" ;
                      ] ;
                    sp:predicate rdf:type ;
                    sp:subject [
                        sp:varName "dataDependency" ;
                      ] ;
                  ]
                  [
                    a sp:TriplePath ;
                    sp:object provo:Entity ;
                    sp:path [
                        a sp:ModPath ;
                        sp:modMax -2 ;
                        sp:modMin 1 ;
                        sp:subPath rdfs:subClassOf ;
                      ] ;
                    sp:subject [
                        sp:varName "dependencyClass" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression edg:DEPTYPE_DATA-DERIVED-FROM ;
                    sp:variable [
                        sp:varName "dependencyType" ;
                      ] ;
                  ]
                )
                (
                  [
                    sp:object [
                        sp:varName "softwareDependency" ;
                      ] ;
                    sp:predicate edg:dependsOnDataFrom ;
                    sp:subject [
                        sp:varName "resource" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression [
                        sp:varName "softwareDependency" ;
                      ] ;
                    sp:variable [
                        sp:varName "activeExecutable" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression edg:DEPTYPE_DIRECT ;
                    sp:variable [
                        sp:varName "dependencyType" ;
                      ] ;
                  ]
                )
                (
                  [
                    sp:object [
                        sp:varName "dataAsset" ;
                      ] ;
                    sp:predicate edg:input ;
                    sp:subject [
                        sp:varName "resource" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "dataAssetType" ;
                      ] ;
                    sp:predicate rdf:type ;
                    sp:subject [
                        sp:varName "dataAsset" ;
                      ] ;
                  ]
                  [
                    a sp:TriplePath ;
                    sp:object edg:DataAsset ;
                    sp:path [
                        a sp:ModPath ;
                        sp:modMax -2 ;
                        sp:modMin 0 ;
                        sp:subPath rdfs:subClassOf ;
                      ] ;
                    sp:subject [
                        sp:varName "dataAssetType" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "dataAsset" ;
                      ] ;
                    sp:predicate edg:output ;
                    sp:subject [
                        sp:varName "softwareDependency" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression [
                        sp:varName "softwareDependency" ;
                      ] ;
                    sp:variable [
                        sp:varName "activeExecutable" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression [
                        a edg:getSoftwareDependencyType ;
                        arg:resource [
                            sp:varName "softwareDependency" ;
                          ] ;
                      ] ;
                    sp:variable [
                        sp:varName "dependencyType" ;
                      ] ;
                  ]
                )
                (
                  [
                    a sp:TriplePath ;
                    sp:object [
                        sp:varName "activeExecutable" ;
                      ] ;
                    sp:path [
                        a sp:AltPath ;
                        sp:path1 edg:usesSoftwareProgram ;
                        sp:path2 edg:hasSoftwareProgram ;
                      ] ;
                    sp:subject [
                        sp:varName "resource" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "dataElement" ;
                      ] ;
                    sp:predicate edg:input ;
                    sp:subject [
                        sp:varName "activeExecutable" ;
                      ] ;
                  ]
                  [
                    a sp:Filter ;
                    sp:expression [
                        a sp:notExists ;
                        sp:elements (
                            [
                              a sp:TriplePath ;
                              sp:object [
                                  sp:varName "softwareFunction" ;
                                ] ;
                              sp:path [
                                  a sp:ModPath ;
                                  sp:modMax -2 ;
                                  sp:modMin 1 ;
                                  sp:subPath edg:usesSoftwareFunction ;
                                ] ;
                              sp:subject [
                                  sp:varName "activeExecutable" ;
                                ] ;
                            ]
                          ) ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "dataElement" ;
                      ] ;
                    sp:predicate edg:output ;
                    sp:subject [
                        sp:varName "softwareDependency" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression edg:DEPTYPE_PROGRAM-IO ;
                    sp:variable [
                        sp:varName "dependencyType" ;
                      ] ;
                  ]
                )
                (
                  [
                    a sp:TriplePath ;
                    sp:object [
                        sp:varName "activeExecutable" ;
                      ] ;
                    sp:path [
                        a sp:SeqPath ;
                        sp:path1 [
                            a sp:AltPath ;
                            sp:path1 edg:usesSoftwareProgram ;
                            sp:path2 edg:hasSoftwareProgram ;
                          ] ;
                        sp:path2 [
                            a sp:ModPath ;
                            sp:modMax -2 ;
                            sp:modMin 1 ;
                            sp:subPath edg:usesSoftwareFunction ;
                          ] ;
                      ] ;
                    sp:subject [
                        sp:varName "resource" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "dataElement" ;
                      ] ;
                    sp:predicate edg:input ;
                    sp:subject [
                        sp:varName "activeExecutable" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "dataElement" ;
                      ] ;
                    sp:predicate edg:output ;
                    sp:subject [
                        sp:varName "softwareDependency" ;
                      ] ;
                  ]
                  [
                    a sp:Filter ;
                    sp:expression [
                        a sp:ne ;
                        sp:arg1 [
                            sp:varName "softwareDependency" ;
                          ] ;
                        sp:arg2 [
                            sp:varName "resource" ;
                          ] ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression edg:DEPTYPE_FUNCTION-IO ;
                    sp:variable [
                        sp:varName "dependencyType" ;
                      ] ;
                  ]
                )
                (
                  [
                    sp:object [
                        sp:varName "softwareType" ;
                      ] ;
                    sp:predicate rdf:type ;
                    sp:subject [
                        sp:varName "resource" ;
                      ] ;
                  ]
                  [
                    a sp:Union ;
                    sp:elements (
                        (
                          [
                            a sp:TriplePath ;
                            sp:object edg:LineageModel ;
                            sp:path [
                                a sp:ModPath ;
                                sp:modMax -2 ;
                                sp:modMin 0 ;
                                sp:subPath rdfs:subClassOf ;
                              ] ;
                            sp:subject [
                                sp:varName "softwareType" ;
                              ] ;
                          ]
                          [
                            a sp:TriplePath ;
                            sp:object [
                                sp:varName "softwareDependency" ;
                              ] ;
                            sp:path [
                                a sp:AltPath ;
                                sp:path1 edg:usesSoftwareExecutable ;
                                sp:path2 edg:usesPipeline ;
                              ] ;
                            sp:subject [
                                sp:varName "resource" ;
                              ] ;
                          ]
                          [
                            a sp:Bind ;
                            sp:expression edg:DEPTYPE_PROGRAM-USAGE ;
                            sp:variable [
                                sp:varName "dependencyType" ;
                              ] ;
                          ]
                        )
                        (
                          [
                            a sp:TriplePath ;
                            sp:object edg:Pipeline ;
                            sp:path [
                                a sp:ModPath ;
                                sp:modMax -2 ;
                                sp:modMin 0 ;
                                sp:subPath rdfs:subClassOf ;
                              ] ;
                            sp:subject [
                                sp:varName "softwareType" ;
                              ] ;
                          ]
                          [
                            a sp:TriplePath ;
                            sp:object [
                                sp:varName "softwareDependency" ;
                              ] ;
                            sp:path [
                                a sp:AltPath ;
                                sp:path1 [
                                    a sp:AltPath ;
                                    sp:path1 edg:usesPipeline ;
                                    sp:path2 edg:usesSoftwareExecutable ;
                                  ] ;
                                sp:path2 edg:pipelineStep ;
                              ] ;
                            sp:subject [
                                sp:varName "resource" ;
                              ] ;
                          ]
                          [
                            a sp:Bind ;
                            sp:expression edg:DEPTYPE_PROGRAM-USAGE ;
                            sp:variable [
                                sp:varName "dependencyType" ;
                              ] ;
                          ]
                        )
                        (
                          [
                            a sp:TriplePath ;
                            sp:object edg:PipelineStep ;
                            sp:path [
                                a sp:ModPath ;
                                sp:modMax -2 ;
                                sp:modMin 0 ;
                                sp:subPath rdfs:subClassOf ;
                              ] ;
                            sp:subject [
                                sp:varName "softwareType" ;
                              ] ;
                          ]
                          [
                            sp:object [
                                sp:varName "softwareDependency" ;
                              ] ;
                            sp:predicate edg:usesSoftwareProgram ;
                            sp:subject [
                                sp:varName "resource" ;
                              ] ;
                          ]
                          [
                            a sp:Bind ;
                            sp:expression edg:DEPTYPE_PROGRAM-USAGE ;
                            sp:variable [
                                sp:varName "dependencyType" ;
                              ] ;
                          ]
                        )
                      ) ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression [
                        sp:varName "softwareDependency" ;
                      ] ;
                    sp:variable [
                        sp:varName "activeExecutable" ;
                      ] ;
                  ]
                )
                (
                  [
                    sp:object [
                        sp:varName "activeExecutable" ;
                      ] ;
                    sp:predicate edg:serviceEndpoint ;
                    sp:subject [
                        sp:varName "resource" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "activeExecutable" ;
                      ] ;
                    sp:predicate edg:target ;
                    sp:subject [
                        sp:varName "flow" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "sourceEndpoint" ;
                      ] ;
                    sp:predicate edg:source ;
                    sp:subject [
                        sp:varName "flow" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "sourceEndpoint" ;
                      ] ;
                    sp:predicate edg:serviceEndpoint ;
                    sp:subject [
                        sp:varName "softwareDependency" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression edg:DEPTYPE_SERVICE-ENDPOINT ;
                    sp:variable [
                        sp:varName "dependencyType" ;
                      ] ;
                  ]
                )
                (
                  [
                    a sp:SubQuery ;
                    sp:query [
                        a sp:Select ;
                        sp:distinct true ;
                        sp:groupBy (
                            [
                              sp:varName "softwareDependency" ;
                            ]
                            [
                              sp:varName "dependencyType" ;
                            ]
                            [
                              sp:varName "activeExecutable" ;
                            ]
                            [
                              sp:varName "sourceEndpoint" ;
                            ]
                          ) ;
                        sp:resultVariables (
                            [
                              sp:varName "softwareDependency" ;
                            ]
                            [
                              sp:varName "dependencyType" ;
                            ]
                            [
                              sp:varName "activeExecutable" ;
                            ]
                            [
                              sp:expression [
                                  a sp:Count ;
                                  sp:expression [
                                      sp:varName "flow" ;
                                    ] ;
                                ] ;
                              sp:varName "flowCount" ;
                            ]
                          ) ;
                        sp:where (
                            [
                              a sp:Union ;
                              sp:elements (
                                  (
                                    [
                                      sp:object [
                                          sp:varName "resource" ;
                                        ] ;
                                      sp:predicate edg:target ;
                                      sp:subject [
                                          sp:varName "flow" ;
                                        ] ;
                                    ]
                                    [
                                      sp:object [
                                          sp:varName "softwareDependency" ;
                                        ] ;
                                      sp:predicate edg:source ;
                                      sp:subject [
                                          sp:varName "flow" ;
                                        ] ;
                                    ]
                                    [
                                      sp:object [
                                          sp:varName "flowType" ;
                                        ] ;
                                      sp:predicate rdf:type ;
                                      sp:subject [
                                          sp:varName "flow" ;
                                        ] ;
                                    ]
                                    [
                                      a sp:Filter ;
                                      sp:expression [
                                          a sp:eq ;
                                          sp:arg1 [
                                              sp:varName "flowType" ;
                                            ] ;
                                          sp:arg2 edg:Feedline ;
                                        ] ;
                                    ]
                                    [
                                      a sp:Bind ;
                                      sp:expression edg:DEPTYPE_FEEDLINE ;
                                      sp:variable [
                                          sp:varName "dependencyType" ;
                                        ] ;
                                    ]
                                  )
                                  (
                                    [
                                      sp:object [
                                          sp:varName "resource" ;
                                        ] ;
                                      sp:predicate edg:target ;
                                      sp:subject [
                                          sp:varName "flow" ;
                                        ] ;
                                    ]
                                    [
                                      sp:object [
                                          sp:varName "softwareDependency" ;
                                        ] ;
                                      sp:predicate edg:source ;
                                      sp:subject [
                                          sp:varName "flow" ;
                                        ] ;
                                    ]
                                    [
                                      sp:object [
                                          sp:varName "flowType" ;
                                        ] ;
                                      sp:predicate rdf:type ;
                                      sp:subject [
                                          sp:varName "flow" ;
                                        ] ;
                                    ]
                                    [
                                      a sp:Filter ;
                                      sp:expression [
                                          a sp:eq ;
                                          sp:arg1 [
                                              sp:varName "flowType" ;
                                            ] ;
                                          sp:arg2 edg:Dataflow ;
                                        ] ;
                                    ]
                                    [
                                      a sp:Bind ;
                                      sp:expression edg:DEPTYPE_DATAFLOW ;
                                      sp:variable [
                                          sp:varName "dependencyType" ;
                                        ] ;
                                    ]
                                  )
                                  (
                                    [
                                      sp:object [
                                          sp:varName "resource" ;
                                        ] ;
                                      sp:predicate edg:target ;
                                      sp:subject [
                                          sp:varName "flow" ;
                                        ] ;
                                    ]
                                    [
                                      sp:object [
                                          sp:varName "softwareDependency" ;
                                        ] ;
                                      sp:predicate edg:source ;
                                      sp:subject [
                                          sp:varName "flow" ;
                                        ] ;
                                    ]
                                    [
                                      sp:object [
                                          sp:varName "flowType" ;
                                        ] ;
                                      sp:predicate rdf:type ;
                                      sp:subject [
                                          sp:varName "flow" ;
                                        ] ;
                                    ]
                                    [
                                      a sp:Filter ;
                                      sp:expression [
                                          a sp:eq ;
                                          sp:arg1 [
                                              sp:varName "flowType" ;
                                            ] ;
                                          sp:arg2 edg:LogicalFlow ;
                                        ] ;
                                    ]
                                    [
                                      a sp:Bind ;
                                      sp:expression edg:DEPTYPE_LOGICAL-FLOW ;
                                      sp:variable [
                                          sp:varName "dependencyType" ;
                                        ] ;
                                    ]
                                  )
                                ) ;
                            ]
                            [
                              a sp:Bind ;
                              sp:expression [
                                  sp:varName "softwareDependency" ;
                                ] ;
                              sp:variable [
                                  sp:varName "activeExecutable" ;
                                ] ;
                            ]
                          ) ;
                      ] ;
                  ]
                )
              ) ;
          ]
          [
            sp:object [
                sp:varName "softwareExecutableType" ;
              ] ;
            sp:predicate rdf:type ;
            sp:subject [
                sp:varName "softwareDependency" ;
              ] ;
          ]
          [
            a sp:TriplePath ;
            sp:object [
                sp:varName "parentClass" ;
              ] ;
            sp:path [
                a sp:ModPath ;
                sp:modMax -2 ;
                sp:modMin 0 ;
                sp:subPath rdfs:subClassOf ;
              ] ;
            sp:subject [
                sp:varName "softwareExecutableType" ;
              ] ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:in ;
                sp:arg1 [
                    sp:varName "parentClass" ;
                  ] ;
                sp:arg2 edg:BusinessApplication ;
                sp:arg3 edg:Pipeline ;
                sp:arg4 edg:PipelineStep ;
                sp:arg5 edg:Interoperable ;
                sp:arg6 edg:SoftwareProgram ;
                sp:arg7 edg:SoftwareFunction ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
    ] ;
  rdfs:isDefinedBy <http://edg.topbraid.solutions/1.0/diagram/lg/software> ;
  rdfs:label "Get upstream dependencies" ;
  rdfs:seeAlso edg:GetDownstreamSoftwareDependencies ;
  rdfs:subClassOf edg:SelectTemplates ;
.
edg:GetUpstreamInteroperableFlowDependencies
  a spin:Template ;
  spin:body [
      a sp:Select ;
      sp:distinct true ;
      sp:orderBy (
          [
            sp:varName "softwareDependency" ;
          ]
        ) ;
      sp:resultVariables (
          [
            sp:varName "dependencyType" ;
          ]
          [
            sp:varName "flow" ;
          ]
          [
            sp:varName "sourceEndpoint" ;
          ]
          [
            sp:varName "targetEndpoint" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Filter ;
            sp:expression [
                a sp:and ;
                sp:arg1 [
                    a sp:bound ;
                    sp:arg1 [
                        sp:varName "resource" ;
                      ] ;
                  ] ;
                sp:arg2 [
                    a sp:bound ;
                    sp:arg1 [
                        sp:varName "upstreamResource" ;
                      ] ;
                  ] ;
              ] ;
          ]
          (
            [
              a sp:Union ;
              sp:elements (
                  (
                    [
                      sp:object [
                          sp:varName "targetEndpoint" ;
                        ] ;
                      sp:predicate edg:serviceEndpoint ;
                      sp:subject [
                          sp:varName "resource" ;
                        ] ;
                    ]
                    [
                      sp:object [
                          sp:varName "targetEndpoint" ;
                        ] ;
                      sp:predicate edg:target ;
                      sp:subject [
                          sp:varName "flow" ;
                        ] ;
                    ]
                    [
                      sp:object [
                          sp:varName "sourceEndpoint" ;
                        ] ;
                      sp:predicate edg:source ;
                      sp:subject [
                          sp:varName "flow" ;
                        ] ;
                    ]
                    [
                      sp:object [
                          sp:varName "sourceEndpoint" ;
                        ] ;
                      sp:predicate edg:serviceEndpoint ;
                      sp:subject [
                          sp:varName "upstreamResource" ;
                        ] ;
                    ]
                  )
                  (
                    [
                      sp:object [
                          sp:varName "resource" ;
                        ] ;
                      sp:predicate edg:target ;
                      sp:subject [
                          sp:varName "flow" ;
                        ] ;
                    ]
                    [
                      sp:object [
                          sp:varName "upstreamResource" ;
                        ] ;
                      sp:predicate edg:source ;
                      sp:subject [
                          sp:varName "flow" ;
                        ] ;
                    ]
                  )
                ) ;
            ]
            [
              a sp:Union ;
              sp:elements (
                  (
                    [
                      sp:object [
                          sp:varName "flowType" ;
                        ] ;
                      sp:predicate rdf:type ;
                      sp:subject [
                          sp:varName "flow" ;
                        ] ;
                    ]
                    [
                      a sp:Filter ;
                      sp:expression [
                          a sp:eq ;
                          sp:arg1 [
                              sp:varName "flowType" ;
                            ] ;
                          sp:arg2 edg:Feedline ;
                        ] ;
                    ]
                    [
                      a sp:Bind ;
                      sp:expression edg:DEPTYPE_FEEDLINE ;
                      sp:variable [
                          sp:varName "dependencyType" ;
                        ] ;
                    ]
                  )
                  (
                    [
                      sp:object [
                          sp:varName "flowType" ;
                        ] ;
                      sp:predicate rdf:type ;
                      sp:subject [
                          sp:varName "flow" ;
                        ] ;
                    ]
                    [
                      a sp:Filter ;
                      sp:expression [
                          a sp:eq ;
                          sp:arg1 [
                              sp:varName "flowType" ;
                            ] ;
                          sp:arg2 edg:Dataflow ;
                        ] ;
                    ]
                    [
                      a sp:Bind ;
                      sp:expression edg:DEPTYPE_DATAFLOW ;
                      sp:variable [
                          sp:varName "dependencyType" ;
                        ] ;
                    ]
                  )
                  (
                    [
                      sp:object [
                          sp:varName "flowType" ;
                        ] ;
                      sp:predicate rdf:type ;
                      sp:subject [
                          sp:varName "flow" ;
                        ] ;
                    ]
                    [
                      a sp:Filter ;
                      sp:expression [
                          a sp:eq ;
                          sp:arg1 [
                              sp:varName "flowType" ;
                            ] ;
                          sp:arg2 edg:LogicalFlow ;
                        ] ;
                    ]
                    [
                      a sp:Bind ;
                      sp:expression edg:DEPTYPE_LOGICAL-FLOW ;
                      sp:variable [
                          sp:varName "dependencyType" ;
                        ] ;
                    ]
                  )
                ) ;
            ]
          )
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:upstreamResource ;
      spl:valueType rdfs:Resource ;
    ] ;
  rdfs:isDefinedBy <http://edg.topbraid.solutions/1.0/diagram/lg/software> ;
  rdfs:label "Get upstream interoperable flow dependencies" ;
  rdfs:subClassOf edg:SelectTemplates ;
.
edg:GetUpstreamSoftwareDependencies
  a spin:Template ;
  spin:body [
      a sp:Select ;
      sp:distinct true ;
      sp:resultVariables (
          [
            sp:varName "softwareDependency" ;
          ]
          [
            sp:varName "softwareExecutableType" ;
          ]
          [
            sp:varName "dependencyType" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Union ;
            sp:elements (
                (
                  [
                    sp:object [
                        sp:varName "dataElement" ;
                      ] ;
                    sp:predicate edg:input ;
                    sp:subject [
                        sp:varName "resource" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "dataElement" ;
                      ] ;
                    sp:predicate edg:output ;
                    sp:subject [
                        sp:varName "softwareDependency" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression edg:DEPTYPE_PROGRAM-IO ;
                    sp:variable [
                        sp:varName "dependencyType" ;
                      ] ;
                  ]
                )
                (
                  [
                    sp:object [
                        sp:varName "softwareDependency" ;
                      ] ;
                    sp:predicate edg:dependsOnDataFrom ;
                    sp:subject [
                        sp:varName "resource" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression edg:DEPTYPE_DIRECT ;
                    sp:variable [
                        sp:varName "dependencyType" ;
                      ] ;
                  ]
                )
                (
                  [
                    a sp:TriplePath ;
                    sp:object [
                        sp:varName "softwareFunction" ;
                      ] ;
                    sp:path [
                        a sp:SeqPath ;
                        sp:path1 [
                            a sp:ModPath ;
                            sp:modMax -2 ;
                            sp:modMin 0 ;
                            sp:subPath edg:usesSoftwareProgram ;
                          ] ;
                        sp:path2 edg:usesSoftwareFunction ;
                      ] ;
                    sp:subject [
                        sp:varName "resource" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "input" ;
                      ] ;
                    sp:predicate edg:input ;
                    sp:subject [
                        sp:varName "softwareFunction" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "input" ;
                      ] ;
                    sp:predicate edg:output ;
                    sp:subject [
                        sp:varName "anotherSoftwareFunction" ;
                      ] ;
                  ]
                  [
                    a sp:TriplePath ;
                    sp:object [
                        sp:varName "anotherSoftwareFunction" ;
                      ] ;
                    sp:path [
                        a sp:SeqPath ;
                        sp:path1 [
                            a sp:ModPath ;
                            sp:modMax -2 ;
                            sp:modMin 0 ;
                            sp:subPath edg:usesSoftwareProgram ;
                          ] ;
                        sp:path2 edg:usesSoftwareFunction ;
                      ] ;
                    sp:subject [
                        sp:varName "softwareDependency" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression edg:DEPTYPE_FUNCTION-IO ;
                    sp:variable [
                        sp:varName "dependencyType" ;
                      ] ;
                  ]
                )
              ) ;
          ]
          [
            sp:object [
                sp:varName "softwareExecutableType" ;
              ] ;
            sp:predicate rdf:type ;
            sp:subject [
                sp:varName "softwareDependency" ;
              ] ;
          ]
          [
            a sp:TriplePath ;
            sp:object [
                sp:varName "parentClass" ;
              ] ;
            sp:path [
                a sp:ModPath ;
                sp:modMax -2 ;
                sp:modMin 0 ;
                sp:subPath rdfs:subClassOf ;
              ] ;
            sp:subject [
                sp:varName "softwareExecutableType" ;
              ] ;
          ]
          [
            a sp:Values ;
            sp:bindings (
                (
                  edg:SoftwareProgram
                )
                (
                  edg:SoftwareFunction
                )
              ) ;
            sp:varNames (
                "parentClass"
              ) ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
    ] ;
  rdfs:isDefinedBy <http://edg.topbraid.solutions/1.0/diagram/lg/library-software> ;
  rdfs:label "Get upstream software dependencies" ;
  rdfs:subClassOf edg:SelectTemplates ;
.
edg:GetnInformationAssetDependencyDetails
  a spin:SelectTemplate ;
  a spin:Template ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "infoAsset" ;
          ]
          [
            sp:varName "dependencyType" ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "infoAsset" ;
              ] ;
            sp:predicate edg:requiresInformationAsset ;
            sp:subject [
                sp:varName "rightNode" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "infoAsset" ;
              ] ;
            sp:predicate edg:producesInformationAsset ;
            sp:subject [
                sp:varName "leftNode" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression "info-io" ;
            sp:variable [
                sp:varName "dependencyType" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:leftNode ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:rightNode ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:private true ;
  rdfs:comment "Determines the structure needed to show a derivation map." ;
  rdfs:label "Get information asset dependency details" ;
  rdfs:subClassOf edg:SoftwareExecutableSelectTemplates ;
.
edg:Interoperable
  ui:instanceView """
<ui:group ui:id=\"derivation-map-data-service-other-node\" ui:priority=\"{= 10 }\">
    <edg:InteroperableSourceToFeedlineDetails arg:leftNode=\"{= ?leftNode }\" arg:rightNode=\"{= ?rightNode }\"/>
</ui:group>
"""^^ui:Literal ;
  ui:instanceView """
<ui:group ui:id=\"derivation-map-data-service\" ui:priority=\"{= 10 }\">
    <ui:resourceView arg:leftNode=\"{= ?leftNode }\" arg:rightNode=\"{= ?this }\" ui:matchIds=\"derivation-map-data-service-other-node\" ui:resource=\"{= ?leftNode }\"/>
</ui:group>
"""^^ui:Literal ;
  ui:instanceView """
<ui:group ui:id=\"derivation-map-other-node-for-feedline-data-service\" ui:priority=\"{= 10 }\">
    <edg:InteroperableSourceToFeedlineDetails arg:leftNode=\"{= ?leftNode }\" arg:rightNode=\"{= ?rightNode }\"/>
</ui:group>
"""^^ui:Literal ;
.
edg:InteroperableSourceToFeedlineDetails
  a ui:Service ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:leftNode ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:rightNode ;
      spl:valueType rdfs:Resource ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:group>
    <ui:group let:destination=\"{= spl:subject(edg:incomingFeed, ?rightNode) }\" let:feedlineOutputData=\"{= spl:object(?rightNode, edg:output) }\">
        <swon:Object>
            <swon:Value arg:name=\"nodes\">
                <swon:Array>
                    <edg:BuildJSONforLineageGramNode arg:label=\"{= edg:MakeNodeLabel(?leftNode) }\" arg:node=\"{= ?leftNode }\"/>
                    <edg:BuildJSONforLineageGramNode arg:label=\"{= edg:MakeNodeLabel(?rightNode) }\" arg:node=\"{= ?rightNode }\"/>
                    <ui:forEach ui:resultSet=\"{#
                            SELECT ?feedlineInputData
                            WHERE {
                                ?rightNode edg:input ?feedlineInputData .
                            } }\">
                        <edg:BuildJSONforLineageGramNode arg:label=\"{= edg:MakeNodeLabel(?feedlineInputData) }\" arg:node=\"{= ?feedlineInputData }\" arg:parent=\"{= IF(bound(?feedlineOutputData), ?feedlineOutputData, ?rightNode) }\"/>
                    </ui:forEach>
                    <ui:if ui:condition=\"{= bound(?feedlineOutputData) }\">
                        <edg:BuildJSONforLineageGramNode arg:label=\"{= CONCAT(&quot;PAYLOAD: &quot;, ui:label(?feedlineOutputData)) }\" arg:node=\"{= ?feedlineOutputData }\" arg:parent=\"{= ?rightNode }\"/>
                    </ui:if>
                    <ui:if ui:condition=\"{= bound(?destination) }\">
                        <edg:BuildJSONforLineageGramNode arg:label=\"{= edg:MakeNodeLabel(?destination) }\" arg:node=\"{= ?destination }\"/>
                    </ui:if>
                </swon:Array>
            </swon:Value>
            <swon:Value arg:name=\"edges\">
                <swon:Array>
                    <edg:BuildJSONforDerviationMapLink arg:label=\"source for\" arg:leftNode=\"{= ?leftNode }\" arg:property=\"{= edg:incomingFeed }\" arg:rightNode=\"{= ?rightNode }\"/>
                    <ui:forEach ui:resultSet=\"{#
                            SELECT ?feedlineInputData
                            WHERE {
                                ?rightNode edg:input ?feedlineInputData .
                            } }\">
                        <edg:BuildJSONforDerviationMapLink arg:leftNode=\"{= ?feedlineInputData }\" arg:property=\"{= edg:input }\" arg:rightNode=\"{= ?rightNode }\"/>
                    </ui:forEach>
                    <ui:if ui:condition=\"{= bound(?feedlineOutputData) }\">
                        <edg:BuildJSONforDerviationMapLink arg:leftNode=\"{= ?rightNode }\" arg:property=\"{= edg:output }\" arg:rightNode=\"{= ?feedlineOutputData }\"/>
                    </ui:if>
                    <ui:if ui:condition=\"{= bound(?destination) }\">
                        <edg:BuildJSONforDerviationMapLink arg:label=\"destination\" arg:leftNode=\"{= ?rightNode }\" arg:property=\"{= edg:outgoingFeed }\" arg:rightNode=\"{= ?destination }\"/>
                    </ui:if>
                </swon:Array>
            </swon:Value>
        </swon:Object>
    </ui:group>
</ui:group>
"""^^ui:Literal ;
  ui:responseType ui:JSON ;
  rdfs:isDefinedBy <http://edg.topbraid.solutions/1.0/diagram/lg/library-common> ;
  rdfs:label "Business application to business applicaition feedline details" ;
  rdfs:subClassOf edg:DerivationMapServices ;
.
edg:LogicalFlowEdges
  a ui:Service ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate edg:flow ;
      spl:valueType edg:Flow ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:leftNode ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:rightNode ;
      spl:valueType rdfs:Resource ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:group>
    <edg:BuildJSONforDerviationMapLink arg:label=\"source for\" arg:leftNode=\"{= ?leftNode }\" arg:rightNode=\"{= ?flow }\"/>
    <edg:BuildJSONforDerviationMapLink arg:label=\"target\" arg:leftNode=\"{= ?flow }\" arg:rightNode=\"{= ?rightNode }\"/>
</ui:group>
"""^^ui:Literal ;
  ui:responseType ui:JSON ;
  rdfs:isDefinedBy <http://edg.topbraid.solutions/1.0/diagram/lg/software> ;
  rdfs:label "Logical Flow Edges" ;
  rdfs:subClassOf edg:DerivationMapServices ;
.
edg:MakeViewFrameDownstreamPlaceholderNodeAndLinks
  spin:constraint [
      a spl:Argument ;
      spl:predicate edg:outOfBreadth ;
      spl:valueType xsd:boolean ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate edg:outOfReach ;
      spl:valueType xsd:boolean ;
    ] ;
.
edg:MoreUpstreamDerivationMapService
  a ui:Service ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:node ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:placeholder ;
      spl:valueType rdfs:Resource ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:group>
    <swon:Object>
        <swon:Value arg:name=\"nodes\">
            <swon:Array>
                <edg:BuildJSONforLineageGramNode arg:label=\"{= edg:MakeNodeLabel(?node) }\" arg:node=\"{= ?node }\"/>
                <swon:Object>
                    <swon:Value arg:name=\"id\" arg:value=\"{= ?placeholder }\"/>
                    <swon:Value arg:name=\"label\" arg:value=\"{= COALESCE(?label, ui:label(?placeholder)) }\"/>
                    <swon:Value arg:name=\"resourceType\" arg:value=\"{= ?placeholder }\"/>
                    <swon:Value arg:name=\"type\" arg:value=\"{= ?placeholder }\"/>
                </swon:Object>
            </swon:Array>
        </swon:Value>
        <swon:Value arg:name=\"edges\">
            <swon:Array>
                <edg:BuildJSONforDerviationMapLink arg:label=\"for\" arg:leftNode=\"{= ?placeholder }\" arg:rightNode=\"{= ?node }\"/>
            </swon:Array>
        </swon:Value>
    </swon:Object>
</ui:group>
"""^^ui:Literal ;
  ui:responseType ui:JSON ;
  rdfs:isDefinedBy <http://edg.topbraid.solutions/1.0/diagram/lg/library-common> ;
  rdfs:label "More upstream derivation map service" ;
  rdfs:subClassOf edg:DerivationMapServices ;
.
edg:MoreUpstreamToFeedlineDetails
  a ui:Service ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:leftNode ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:rightNode ;
      spl:valueType rdfs:Resource ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:group let:whyMore=\"{= IF(spl:object(?leftNode, edg:outOfBreadth), &quot;more inputs to&quot;, &quot;more reach for&quot;) }\">
    <swon:Object>
        <swon:Value arg:name=\"nodes\">
            <swon:Array>
                <edg:BuildJSONforLineageGramNode arg:label=\"{= edg:MakeNodeLabel(?leftNode) }\" arg:node=\"{= ?leftNode }\"/>
                <edg:BuildJSONforLineageGramNode arg:label=\"{= edg:MakeNodeLabel(?rightNode) }\" arg:node=\"{= ?rightNode }\"/>
            </swon:Array>
        </swon:Value>
        <swon:Value arg:name=\"edges\">
            <swon:Array>
                <edg:BuildJSONforDerviationMapLink arg:label=\"{= ?whyMore }\" arg:leftNode=\"{= ?leftNode }\" arg:property=\"{= edg:dependencyOf }\" arg:rightNode=\"{= ?rightNode }\"/>
            </swon:Array>
        </swon:Value>
    </swon:Object>
</ui:group>
"""^^ui:Literal ;
  ui:responseType ui:JSON ;
  rdfs:isDefinedBy <http://edg.topbraid.solutions/1.0/diagram/lg/library-common> ;
  rdfs:label "More upstream to feedline details" ;
  rdfs:subClassOf edg:DerivationMapServices ;
.
edg:Party
  ui:instanceView """
<ui:group ui:id=\"derivation-map-data-service-other-node\" ui:priority=\"{= 10 }\">
    <!--ui:dumpScope ui:message=\"AAA2: edg:Party {= ?this } to {= ?rightNode }, link type {= ?linkType }\"/-->
    <edg:GenerateJSONforSoftwareExecutableToSoftwareExecutableDependencyDetails arg:leftNode=\"{= ?leftNode }\" arg:rightNode=\"{= ?rightNode }\" edg:linkType=\"{= ?linkType }\"/>
</ui:group>
"""^^ui:Literal ;
  ui:instanceView """
<ui:group ui:id=\"derivation-map-data-service\" ui:priority=\"{= 10 }\">
    <!--ui:dumpScope ui:message=\"AAA1: edg:Party {= ?this } to {= ?rightNode }, link type {= ?linkType }\"/-->
    <ui:resourceView arg:leftNode=\"{= ?leftNode }\" arg:linkType=\"{= ?linkType }\" arg:rightNode=\"{= ?this }\" ui:matchIds=\"derivation-map-data-service-other-node\" ui:resource=\"{= ?leftNode }\"/>
</ui:group>
"""^^ui:Literal ;
.
edg:Placeholder
  ui:instanceView """
<ui:group ui:id=\"derivation-map-data-service-other-node\" ui:priority=\"{= 10 }\">
    <edg:MoreUpstreamToFeedlineDetails arg:leftNode=\"{= ?leftNode }\" arg:rightNode=\"{= ?rightNode }\"/>
</ui:group>
"""^^ui:Literal ;
  ui:instanceView """
<ui:group ui:id=\"derivation-map-other-node-for-feedline-data-service\" ui:priority=\"{= 10 }\">
    <edg:MoreUpstreamToFeedlineDetails arg:leftNode=\"{= ?leftNode }\" arg:rightNode=\"{= ?rightNode }\"/>
</ui:group>
"""^^ui:Literal ;
.
edg:Script
  ui:instanceView """
<ui:group ui:id=\"lineagegram\" ui:priority=\"{= -1 }\">
    <edg:LineageGramTemplate arg:dataProvider=\"{= edg:BuildJSONforSoftwareLineageGram }\" arg:focusNode=\"{= ?this }\" arg:graph=\"{= ?graph }\" edg:breadth=\"{= ?breadth }\" edg:reach=\"{= ?reach }\" edg:viewFrameStructure=\"{= edg:VFS_LG-ProvenanceModel }\" edg:viewFramesGraph=\"{= ?viewFramesGraph }\">
        <ui:insert ui:into=\"header\">
            <edg:LineageGramHeader arg:title=\"Upstream Dependency for Script: {= ui:label(?this) }\"/>
        </ui:insert>
    </edg:LineageGramTemplate>
</ui:group>
"""^^ui:Literal ;
.
edg:SoftwareCapable
  ui:instanceView """
<ui:group ui:id=\"lineagegram-data-provider\" ui:priority=\"{= 10 }\">
    <edg:BuildJSONforLineageGramDataProviderDataService arg:dataProvider=\"{= edg:BuildJSONforSoftwareLineageGram }\" arg:provider=\"{= edg:BusinessApplcation }\"/>
</ui:group>
"""^^ui:Literal ;
  ui:instanceView """
<ui:group ui:id=\"lineagegram\" ui:priority=\"{= 10 }\">
    <!--ui:dumpScope ui:message=\"AAA: edg:SoftwareCapable - lineagegram for {= ?this }\"/-->
    <edg:LineageGramTemplate arg:dataProvider=\"{= edg:BuildJSONforSoftwareLineageGram }\" arg:focusNode=\"{= ?this }\" arg:graph=\"{= ?graph }\" edg:breadth=\"{= ?breadth }\" edg:reach=\"{= ?reach }\" edg:viewFrameStructure=\"{= edg:VFS_LG-ProvenanceModel }\" edg:viewFramesGraph=\"{= ?viewFramesGraph }\">
        <ui:insert ui:into=\"header\">
            <edg:LineageGramHeader arg:title=\"Upstream Dependency for Software Capability: {= ui:label(?this) }\"/>
        </ui:insert>
    </edg:LineageGramTemplate>
</ui:group>
"""^^ui:Literal ;
.
edg:SoftwareExecutable
  ui:instanceView """
<ui:group ui:id=\"derivation-map-data-service-other-node\" ui:priority=\"{= 10 }\">
    <edg:DefaultDerivationMapDataService arg:leftNode=\"{= ?leftNode }\" arg:rightNode=\"{= ?rightNode }\"/>
</ui:group>
"""^^ui:Literal ;
  ui:instanceView """
<ui:group ui:id=\"derivation-map-data-service\" ui:priority=\"{= 10 }\">
    <ui:resourceView arg:leftNode=\"{= ?leftNode }\" arg:linkType=\"{= ?linkType }\" arg:rightNode=\"{= ?this }\" ui:matchIds=\"derivation-map-data-service-other-node\" ui:resource=\"{= ?leftNode }\"/>
</ui:group>
"""^^ui:Literal ;
  ui:instanceView """
<ui:group ui:id=\"derivation-map-other-node-for-feedline-data-service\" ui:priority=\"{= 10 }\">
    <edg:InteroperableSourceToFeedlineDetails arg:leftNode=\"{= ?leftNode }\" arg:rightNode=\"{= ?rightNode }\"/>
</ui:group>
"""^^ui:Literal ;
  ui:instanceView """
<ui:group ui:id=\"downstream-impact\" ui:priority=\"{= 10 }\">
    <ui:group let:myViewFrame=\"{= edg:VF_SoftwareFrame }\">
        <!--ui:dumpScope ui:message=\"AAA: edg:SoftwareExecutable - downstream-impact of {= ?source } on {= ?activeResource }\"/-->
        <ui:if ui:condition=\"{= !bound(?source) }\">
            <ui:throw ui:message=\"Downstream impact on software executable {= str(?this) } - source is not bound\"/>
        </ui:if>
        <ui:if ui:condition=\"{= !bound(?sourceViewFrame) }\">
            <ui:throw ui:message=\"Downstream impact on software executable {= str(?this) } source viewframe is not bound\"/>
        </ui:if>
        <edg:MakeSingleViewFrameResourceOccurrence edg:activeResource=\"{= ?this }\" edg:resource=\"{= ?this }\" edg:viewFrame=\"{= ?myViewFrame }\"/>
        <edg:MakeViewFrameResourceNodeLink edg:dependencyType=\"{= edg:DEPTYPE_DATA-INPUT }\" edg:resource=\"{= ?source }\" edg:targetNode=\"{= ?this }\" edg:targetViewFrame=\"{= ?myViewFrame }\" edg:viewFrame=\"{= ?sourceViewFrame }\"/>
        <edg:DetermineDownstreamDependenciesForResource arg:dependencyTemplate=\"{= edg:GetSoftwareDependents }\" arg:focusNode=\"{= ?this }\" edg:breadth=\"{= ?breadth }\" edg:offset=\"{= ?offset }\" edg:reach=\"{= ?reach }\" edg:sourceViewFrame=\"{= ?myViewFrame }\"/>
    </ui:group>
</ui:group>
"""^^ui:Literal ;
.
edg:SoftwareFunction
  ui:instanceView """
<ui:group ui:id=\"derivation-map-composite-node\" ui:priority=\"{= 10 }\">
    <!--ui:dumpScope ui:message=\"AAA: edg:SoftwareFunction\"/-->
    <edg:BuildJSONforSoftwareFunctionCompositeNode arg:resource=\"{= ?this }\"/>
    <edg:BuildJSONforDerivationMapResourceAspects arg:resource=\"{= ?this }\"/>
</ui:group>
"""^^ui:Literal ;
.
edg:SoftwareModule
  ui:instanceView """
<ui:group ui:id=\"derivation-map-composite-node\" ui:priority=\"{= 10 }\">
    <edg:BuildJSONforSoftwareModuleNode arg:node=\"{= ?this }\"/>
    <edg:BuildJSONforDerivationMapResourceAspects arg:resource=\"{= ?this }\"/>
</ui:group>
"""^^ui:Literal ;
  ui:instanceView """
<ui:group ui:id=\"information-asset-dependency\" ui:priority=\"{= 20 }\">
    <!--ui:dumpScope ui:message=\"AAA: edg:SoftwareModule - dependency on {= ?this }\"/-->
    <ui:group let:depictedResourceForFocusNode=\"{= edg:highestDepictionForSoftwareExecutable(?this) }\">
        <edg:MakeViewFrameResourceNodeLink arg:property=\"{= ?property }\" edg:dependencyType=\"{= ?dependencyType }\" edg:explanation=\"information-asset-dependency - edg:SoftwareProgram\" edg:resource=\"{= ?depictedResourceForFocusNode }\" edg:targetNode=\"{= ?targetNode }\" edg:targetViewFrame=\"{= ?targetViewFrame }\" edg:viewFrame=\"{= edg:VF_SoftwareFrame }\"/>
        <edg:MakeSingleViewFrameResourceOccurrence edg:activeResource=\"{= ?this }\" edg:resource=\"{= ?depictedResourceForFocusNode }\" edg:viewFrame=\"{= edg:VF_SoftwareFrame }\"/>
        <edg:DetermineTransitiveUpstreamSoftwareExecutableDependencies arg:iteration=\"{= 1 }\" arg:traceabilityTemplate=\"{= edg:GetUpstreamDependencies }\" edg:activeResource=\"{= ?this }\" edg:breadth=\"{= ?breadth }\" edg:offset=\"{= ?offset }\" edg:reach=\"{= ?reach }\"/>
        <edg:MakeResourceNodesAndLinksForFirstStageSoftwareExecutableInputs/>
    </ui:group>
</ui:group>
"""^^ui:Literal ;
.
edg:SoftwareProgram
  ui:instanceView """
<ui:group let:depictedResourceForFocusNode=\"{= ?this }\" let:myViewFrameStructure=\"{= COALESCE(?viewFrameStructure, edg:VFS_LG-ProvenanceModel) }\" ui:id=\"asset-provenance\" ui:priority=\"{= 10 }\">
    <ui:group let:viewFrameForDependent=\"{= COALESCE(?targetViewFrame, edg:getViewFrameForResource(?targetNode, ?myViewFrameStructure)) }\" let:viewFrameForDepictedResource=\"{= edg:getViewFrameForResource(?depictedResourceForFocusNode, ?myViewFrameStructure) }\">
        <!--ui:dumpScope ui:message=\"AAA: edg:SoftwareProgram - dependency on {= ?this }\"/-->
        <edg:MakeViewFrameResourceNodeLink arg:property=\"{= ?property }\" edg:dependencyType=\"{= ?dependencyType }\" edg:explanation=\"provenance link\" edg:resource=\"{= ?depictedResourceForFocusNode }\" edg:targetNode=\"{= ?targetNode }\" edg:targetViewFrame=\"{= ?viewFrameForDependent }\" edg:viewFrame=\"{= ?viewFrameForDepictedResource }\"/>
        <edg:MakeSingleViewFrameResourceOccurrence edg:activeResource=\"{= ?this }\" edg:resource=\"{= ?depictedResourceForFocusNode }\" edg:viewFrame=\"{= edg:VF_SoftwareFrame }\"/>
        <edg:DetermineTransitiveUpstreamSoftwareExecutableDependencies arg:iteration=\"{= 1 }\" arg:traceabilityTemplate=\"{= edg:GetUpstreamDependencies }\" edg:activeResource=\"{= ?this }\" edg:breadth=\"{= ?breadth }\" edg:offset=\"{= ?offset }\" edg:reach=\"{= ?reach }\"/>
    </ui:group>
</ui:group>
"""^^ui:Literal ;
  ui:instanceView """
<ui:group ui:id=\"derivation-map-composite-node\" ui:priority=\"{= 10 }\">
    <edg:BuildJSONforSoftwareProgramCompositeNode arg:collapsed=\"{= false }\" arg:resource=\"{= ?this }\"/>
    <edg:BuildJSONforDerivationMapResourceAspects arg:resource=\"{= ?this }\"/>
</ui:group>
"""^^ui:Literal ;
  ui:instanceView """
<ui:group ui:id=\"derivation-map-data-service-other-node-for-data-element\" ui:priority=\"{= 10 }\">
    <!--ui:dumpScope ui:message=\"AAA2: edg:SoftwareProgram from {= ?leftNode } to {= ?rightNode }\"/-->
    <edg:GenericNodeToNodeMapDetails arg:explanation=\"Generated by edg:SoftwareProgram from {= ?this } to {= ?rightNode }\" arg:leftNode=\"{= ?leftNode }\" arg:link=\"input\" arg:reverseNodes=\"{= false }\" arg:rightNode=\"{= ?rightNode }\"/>
</ui:group>
"""^^ui:Literal ;
  ui:instanceView """
<ui:group ui:id=\"derivation-map-data-service-other-node-from-lineage-model\" ui:priority=\"{= 10 }\">
    <edg:FallbackDerivationMapDataService arg:leftNode=\"{= ?leftNode }\" arg:rightNode=\"{= ?rightNode }\"/>
</ui:group>
"""^^ui:Literal ;
  ui:instanceView """
<ui:group ui:id=\"derivation-map-data-service-other-node\" ui:priority=\"{= 10 }\">
    <!--ui:dumpScope ui:message=\"AAA2: edg:SoftwareProgram {= ?this } to  {= ?rightNode }\"/-->
    <edg:GenerateJSONforSoftwareProgramToSoftwareExecutableDependencyDetails arg:leftNode=\"{= ?leftNode }\" arg:rightNode=\"{= ?rightNode }\"/>
</ui:group>
"""^^ui:Literal ;
  ui:instanceView """
<ui:group ui:id=\"derivation-map-data-service\" ui:priority=\"{= 10 }\">
    <ui:resourceView arg:diagramLinkQueryTemplate=\"{= edg:GenerateJSONforSoftwareFunctionToSoftwareExecutableDependencyDetails }\" arg:leftNode=\"{= ?leftNode }\" arg:rightNode=\"{= ?this }\" ui:matchIds=\"derivation-map-data-service-other-node\" ui:resource=\"{= ?leftNode }\"/>
</ui:group>
"""^^ui:Literal ;
  ui:instanceView """
<ui:group ui:id=\"downstream-impact\" ui:priority=\"{= 10 }\">
    <ui:group let:myViewFrame=\"{= edg:VF_SoftwareFrame }\">
        <!--ui:dumpScope ui:message=\"AAA: edg:SoftwareProgram - downstream-impact of {= ?source } on {= ?activeResource }\"/-->
        <ui:if ui:condition=\"{= !bound(?source) }\">
            <ui:throw ui:message=\"Downstream impact on software program {= str(?this) } - source is not bound\"/>
        </ui:if>
        <ui:if ui:condition=\"{= !bound(?sourceViewFrame) }\">
            <ui:throw ui:message=\"Downstream impact on software program {= str(?this) } source viewframe is not bound\"/>
        </ui:if>
        <edg:MakeSingleViewFrameResourceOccurrence edg:activeResource=\"{= ?this }\" edg:resource=\"{= ?this }\" edg:viewFrame=\"{= ?myViewFrame }\"/>
        <edg:MakeViewFrameResourceNodeLink edg:dependencyType=\"{= edg:DEPTYPE_DATA-INPUT }\" edg:resource=\"{= ?source }\" edg:targetNode=\"{= ?this }\" edg:targetViewFrame=\"{= ?myViewFrame }\" edg:viewFrame=\"{= ?sourceViewFrame }\"/>
        <edg:DetermineDownstreamDependenciesForResource arg:dependencyTemplate=\"{= edg:GetSoftwareDependents }\" arg:focusNode=\"{= ?this }\" edg:breadth=\"{= ?breadth }\" edg:offset=\"{= ?offset }\" edg:reach=\"{= ?reach }\" edg:sourceViewFrame=\"{= ?myViewFrame }\"/>
    </ui:group>
</ui:group>
"""^^ui:Literal ;
  ui:instanceView """
<ui:group ui:id=\"information-asset-dependency\" ui:priority=\"{= 20 }\">
    <!--ui:dumpScope ui:message=\"AAA: edg:SoftwareProgram - dependency on {= ?this }\"/-->
    <ui:group let:depictedResourceForFocusNode=\"{= edg:highestDepictionForSoftwareExecutable(?this) }\">
        <edg:MakeViewFrameResourceNodeLink arg:property=\"{= ?property }\" edg:dependencyType=\"{= ?dependencyType }\" edg:explanation=\"information-asset-dependency - edg:SoftwareProgram\" edg:resource=\"{= ?depictedResourceForFocusNode }\" edg:targetNode=\"{= ?targetNode }\" edg:targetViewFrame=\"{= ?targetViewFrame }\" edg:viewFrame=\"{= edg:VF_SoftwareFrame }\"/>
        <edg:MakeSingleViewFrameResourceOccurrence edg:activeResource=\"{= ?this }\" edg:resource=\"{= ?depictedResourceForFocusNode }\" edg:viewFrame=\"{= edg:VF_SoftwareFrame }\"/>
        <edg:DetermineTransitiveUpstreamSoftwareExecutableDependencies arg:iteration=\"{= 1 }\" arg:traceabilityTemplate=\"{= edg:GetUpstreamDependencies }\" edg:activeResource=\"{= ?this }\" edg:breadth=\"{= ?breadth }\" edg:offset=\"{= ?offset }\" edg:reach=\"{= ?reach - 1 }\"/>
        <edg:MakeResourceNodesAndLinksForFirstStageSoftwareExecutableInputs/>
    </ui:group>
</ui:group>
"""^^ui:Literal ;
  ui:instanceView """
<ui:group ui:id=\"lineagegram-data-provider\" ui:priority=\"{= 10 }\">
    <edg:BuildJSONforLineageGramDataProviderDataService arg:dataProvider=\"{= edg:BuildJSONforSoftwareLineageGram }\" arg:provider=\"{= edg:SoftwareProgram }\"/>
</ui:group>
"""^^ui:Literal ;
  ui:instanceView """
<ui:group ui:id=\"lineagegram\" ui:priority=\"{= -1 }\">
    <edg:LineageGramTemplate arg:dataProvider=\"{= edg:BuildJSONforSoftwareLineageGram }\" arg:focusNode=\"{= ?this }\" arg:graph=\"{= ?graph }\" edg:breadth=\"{= ?breadth }\" edg:reach=\"{= ?reach }\" edg:viewFrameStructure=\"{= edg:VFS_LG-ProvenanceModel }\" edg:viewFramesGraph=\"{= ?viewFramesGraph }\">
        <ui:insert ui:into=\"header\">
            <edg:LineageGramHeader arg:title=\"Upstream Dependency for {= ui:label(spl:object(?this, rdf:type)) }: {= ui:label(?this) }\"/>
        </ui:insert>
    </edg:LineageGramTemplate>
</ui:group>
"""^^ui:Literal ;
.
edg:System
  ui:instanceView """
<ui:group ui:id=\"derivation-map-data-service-other-node\" ui:priority=\"{= 10 }\">
    <!--edg:InteroperableSourceToFeedlineDetails arg:leftNode=\"{= ?leftNode }\" arg:rightNode=\"{= ?rightNode }\"/-->
    <edg:GenerateJSONforSoftwareExecutableToSoftwareExecutableDependencyDetails arg:leftNode=\"{= ?leftNode }\" arg:rightNode=\"{= ?rightNode }\" edg:linkType=\"{= ?linkType }\"/>
</ui:group>
"""^^ui:Literal ;
  ui:instanceView """
<ui:group ui:id=\"derivation-map-data-service\" ui:priority=\"{= 10 }\">
    <ui:resourceView arg:leftNode=\"{= ?leftNode }\" arg:rightNode=\"{= ?this }\" edg:linkType=\"{= ?linkType }\" ui:matchIds=\"derivation-map-data-service-other-node\" ui:resource=\"{= ?leftNode }\"/>
</ui:group>
"""^^ui:Literal ;
.
edg:getDataflow
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "dataflow" ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "leftNode" ;
              ] ;
            sp:predicate edg:source ;
            sp:subject [
                sp:varName "dataflow" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "rightNode" ;
              ] ;
            sp:predicate edg:target ;
            sp:subject [
                sp:varName "dataflow" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:leftNode ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:rightNode ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:returnType rdfs:Resource ;
  rdfs:label "get dataflow" ;
  rdfs:subClassOf edg:Functions ;
.
edg:getDirectMappings
  a spin:SelectTemplate ;
  a spin:Template ;
  spin:body [
      a sp:Select ;
      sp:orderBy (
          [
            a ui:label ;
            sp:arg1 [
                sp:varName "mapping" ;
              ] ;
          ]
        ) ;
      sp:resultVariables (
          [
            sp:varName "mapping" ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "mapping" ;
              ] ;
            sp:predicate edg:mapping ;
            sp:subject [
                sp:varName "resource" ;
              ] ;
          ]
          [
            sp:object edg:DirectMapping ;
            sp:predicate rdf:type ;
            sp:subject [
                sp:varName "mapping" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:private true ;
  rdfs:comment "Gets the direct mappings of a given resource" ;
  rdfs:label "get direct mappings" ;
  rdfs:subClassOf edg:SelectTemplates ;
.
edg:getHeirarchyDepth
  a spin:MagicProperty ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "depth" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Union ;
            sp:elements (
                (
                  [
                    sp:object [
                        sp:varName "x" ;
                      ] ;
                    sp:predicate rdfs:subClassOf ;
                    sp:subject spin:_arg1 ;
                  ]
                  [
                    a sp:Filter ;
                    sp:expression [
                        a sp:ne ;
                        sp:arg1 [
                            sp:varName "x" ;
                          ] ;
                        sp:arg2 spin:_arg2 ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "x" ;
                      ] ;
                    sp:predicate rdf:first ;
                    sp:subject [
                        sp:varName "?0" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "?1" ;
                      ] ;
                    sp:predicate rdf:rest ;
                    sp:subject [
                        sp:varName "?0" ;
                      ] ;
                  ]
                  [
                    sp:object spin:_arg2 ;
                    sp:predicate rdf:first ;
                    sp:subject [
                        sp:varName "?1" ;
                      ] ;
                  ]
                  [
                    sp:object () ;
                    sp:predicate rdf:rest ;
                    sp:subject [
                        sp:varName "?1" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "inc" ;
                      ] ;
                    sp:predicate edg:getHeirarchyDepth ;
                    sp:subject [
                        sp:varName "?0" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression [
                        a sp:add ;
                        sp:arg1 [
                            sp:varName "inc" ;
                          ] ;
                        sp:arg2 1 ;
                      ] ;
                    sp:variable [
                        sp:varName "depth" ;
                      ] ;
                  ]
                )
                (
                  [
                    sp:object spin:_arg2 ;
                    sp:predicate rdfs:subClassOf ;
                    sp:subject spin:_arg1 ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression 1 ;
                    sp:variable [
                        sp:varName "depth" ;
                      ] ;
                  ]
                )
                (
                  [
                    a sp:Filter ;
                    sp:expression [
                        a sp:eq ;
                        sp:arg1 spin:_arg1 ;
                        sp:arg2 spin:_arg2 ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression 0 ;
                    sp:variable [
                        sp:varName "depth" ;
                      ] ;
                  ]
                )
              ) ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType edg:SoftwareExecutable ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "Current parent" ;
    ] ;
  rdfs:label "Get heirarchy depth" ;
  rdfs:subClassOf edg:MagicProperties ;
.
edg:getPayloads
  a spin:SelectTemplate ;
  a spin:Template ;
  spin:body [
      a sp:Select ;
      sp:groupBy (
          [
            sp:varName "payloadType" ;
          ]
          [
            sp:varName "payload" ;
          ]
        ) ;
      sp:orderBy (
          [
            a ui:label ;
            sp:arg1 [
                sp:varName "payload" ;
              ] ;
          ]
        ) ;
      sp:resultVariables (
          [
            sp:varName "payloadType" ;
          ]
          [
            sp:varName "payload" ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "payload" ;
              ] ;
            sp:predicate edg:dataExchange ;
            sp:subject [
                sp:varName "resource" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "payloadType" ;
              ] ;
            sp:predicate rdf:type ;
            sp:subject [
                sp:varName "payload" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:private true ;
  rdfs:comment "Gets the payloads of a dataflow" ;
  rdfs:label "get payloads" ;
  rdfs:subClassOf edg:SelectTemplates ;
.
edg:getSoftwareParentage
  a spin:MagicProperty ;
  spin:body [
      a sp:Select ;
      sp:distinct true ;
      sp:orderBy (
          [
            a sp:Desc ;
            sp:expression [
                sp:varName "level" ;
              ] ;
          ]
        ) ;
      sp:resultVariables (
          [
            sp:varName "software" ;
          ]
          [
            sp:varName "parent" ;
          ]
          [
            sp:varName "level" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Union ;
            sp:elements (
                (
                  [
                    sp:object spin:_arg1 ;
                    sp:predicate edg:hasSoftwareProgram ;
                    sp:subject [
                        sp:varName "parent" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression spin:_arg1 ;
                    sp:variable [
                        sp:varName "software" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression spin:_arg2 ;
                    sp:variable [
                        sp:varName "level" ;
                      ] ;
                  ]
                )
                (
                  [
                    sp:object spin:_arg1 ;
                    sp:predicate edg:hasSoftwareProgram ;
                    sp:subject [
                        sp:varName "software" ;
                      ] ;
                  ]
                  (
                    [
                      a sp:Filter ;
                      sp:expression [
                          a sp:exists ;
                          sp:elements (
                              [
                                sp:object [
                                    sp:varName "software" ;
                                  ] ;
                                sp:predicate edg:usesModule ;
                                sp:subject [
                                    sp:varName "anotherParent" ;
                                  ] ;
                              ]
                            ) ;
                        ] ;
                    ]
                    [
                      a sp:Bind ;
                      sp:expression [
                          a sp:add ;
                          sp:arg1 spin:_arg2 ;
                          sp:arg2 1 ;
                        ] ;
                      sp:variable [
                          sp:varName "newLevel" ;
                        ] ;
                    ]
                    [
                      sp:object [
                          sp:varName "software" ;
                        ] ;
                      sp:predicate rdf:first ;
                      sp:subject [
                          sp:varName "?0" ;
                        ] ;
                    ]
                    [
                      sp:object [
                          sp:varName "?1" ;
                        ] ;
                      sp:predicate rdf:rest ;
                      sp:subject [
                          sp:varName "?0" ;
                        ] ;
                    ]
                    [
                      sp:object [
                          sp:varName "newLevel" ;
                        ] ;
                      sp:predicate rdf:first ;
                      sp:subject [
                          sp:varName "?1" ;
                        ] ;
                    ]
                    [
                      sp:object () ;
                      sp:predicate rdf:rest ;
                      sp:subject [
                          sp:varName "?1" ;
                        ] ;
                    ]
                    [
                      sp:object [
                          sp:varName "?2" ;
                        ] ;
                      sp:predicate edg:getSoftwareParentage ;
                      sp:subject [
                          sp:varName "?0" ;
                        ] ;
                    ]
                    [
                      sp:object [
                          sp:varName "software" ;
                        ] ;
                      sp:predicate rdf:first ;
                      sp:subject [
                          sp:varName "?2" ;
                        ] ;
                    ]
                    [
                      sp:object [
                          sp:varName "?3" ;
                        ] ;
                      sp:predicate rdf:rest ;
                      sp:subject [
                          sp:varName "?2" ;
                        ] ;
                    ]
                    [
                      sp:object [
                          sp:varName "parent" ;
                        ] ;
                      sp:predicate rdf:first ;
                      sp:subject [
                          sp:varName "?3" ;
                        ] ;
                    ]
                    [
                      sp:object [
                          sp:varName "?4" ;
                        ] ;
                      sp:predicate rdf:rest ;
                      sp:subject [
                          sp:varName "?3" ;
                        ] ;
                    ]
                    [
                      sp:object [
                          sp:varName "level" ;
                        ] ;
                      sp:predicate rdf:first ;
                      sp:subject [
                          sp:varName "?4" ;
                        ] ;
                    ]
                    [
                      sp:object () ;
                      sp:predicate rdf:rest ;
                      sp:subject [
                          sp:varName "?4" ;
                        ] ;
                    ]
                  )
                )
                (
                  [
                    sp:object spin:_arg1 ;
                    sp:predicate edg:usesModule ;
                    sp:subject [
                        sp:varName "parent" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression spin:_arg1 ;
                    sp:variable [
                        sp:varName "software" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression spin:_arg2 ;
                    sp:variable [
                        sp:varName "level" ;
                      ] ;
                  ]
                )
                (
                  [
                    sp:object spin:_arg1 ;
                    sp:predicate edg:usesModule ;
                    sp:subject [
                        sp:varName "software" ;
                      ] ;
                  ]
                  (
                    [
                      a sp:Filter ;
                      sp:expression [
                          a sp:exists ;
                          sp:elements (
                              [
                                sp:object [
                                    sp:varName "software" ;
                                  ] ;
                                sp:predicate edg:usesModule ;
                                sp:subject [
                                    sp:varName "anotherModule" ;
                                  ] ;
                              ]
                            ) ;
                        ] ;
                    ]
                    [
                      a sp:Bind ;
                      sp:expression [
                          a sp:add ;
                          sp:arg1 spin:_arg2 ;
                          sp:arg2 1 ;
                        ] ;
                      sp:variable [
                          sp:varName "newLevel" ;
                        ] ;
                    ]
                    [
                      sp:object [
                          sp:varName "software" ;
                        ] ;
                      sp:predicate rdf:first ;
                      sp:subject [
                          sp:varName "?5" ;
                        ] ;
                    ]
                    [
                      sp:object [
                          sp:varName "?6" ;
                        ] ;
                      sp:predicate rdf:rest ;
                      sp:subject [
                          sp:varName "?5" ;
                        ] ;
                    ]
                    [
                      sp:object [
                          sp:varName "newLevel" ;
                        ] ;
                      sp:predicate rdf:first ;
                      sp:subject [
                          sp:varName "?6" ;
                        ] ;
                    ]
                    [
                      sp:object () ;
                      sp:predicate rdf:rest ;
                      sp:subject [
                          sp:varName "?6" ;
                        ] ;
                    ]
                    [
                      sp:object [
                          sp:varName "?7" ;
                        ] ;
                      sp:predicate edg:getSoftwareParentage ;
                      sp:subject [
                          sp:varName "?5" ;
                        ] ;
                    ]
                    [
                      sp:object [
                          sp:varName "software" ;
                        ] ;
                      sp:predicate rdf:first ;
                      sp:subject [
                          sp:varName "?7" ;
                        ] ;
                    ]
                    [
                      sp:object [
                          sp:varName "?8" ;
                        ] ;
                      sp:predicate rdf:rest ;
                      sp:subject [
                          sp:varName "?7" ;
                        ] ;
                    ]
                    [
                      sp:object [
                          sp:varName "parent" ;
                        ] ;
                      sp:predicate rdf:first ;
                      sp:subject [
                          sp:varName "?8" ;
                        ] ;
                    ]
                    [
                      sp:object [
                          sp:varName "?9" ;
                        ] ;
                      sp:predicate rdf:rest ;
                      sp:subject [
                          sp:varName "?8" ;
                        ] ;
                    ]
                    [
                      sp:object [
                          sp:varName "level" ;
                        ] ;
                      sp:predicate rdf:first ;
                      sp:subject [
                          sp:varName "?9" ;
                        ] ;
                    ]
                    [
                      sp:object () ;
                      sp:predicate rdf:rest ;
                      sp:subject [
                          sp:varName "?9" ;
                        ] ;
                    ]
                  )
                )
              ) ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType edg:SoftwareExecutable ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:integer ;
    ] ;
  rdfs:label "Get software parentage" ;
  rdfs:subClassOf edg:MagicProperties ;
.
edg:getSourceToTargetFlowDetails
  a spin:SelectTemplate ;
  a spin:Template ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "sourceEndpoint" ;
          ]
          [
            sp:varName "targetEndpoint" ;
          ]
          [
            sp:varName "flow" ;
          ]
          [
            sp:varName "flowType" ;
          ]
          [
            sp:varName "dependencyType" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Union ;
            sp:elements (
                (
                  [
                    a sp:TriplePath ;
                    sp:object [
                        sp:varName "leftNodeSoftwareExecutable" ;
                      ] ;
                    sp:path [
                        a sp:ModPath ;
                        sp:modMax -1 ;
                        sp:modMin 0 ;
                        sp:subPath [
                            a sp:AltPath ;
                            sp:path1 edg:usesSoftwareProgram ;
                            sp:path2 edg:usesSoftwareExecutable ;
                          ] ;
                      ] ;
                    sp:subject [
                        sp:varName "leftNode" ;
                      ] ;
                  ]
                  [
                    a sp:TriplePath ;
                    sp:object [
                        sp:varName "rightNodeSoftwareExecutable" ;
                      ] ;
                    sp:path [
                        a sp:ModPath ;
                        sp:modMax -1 ;
                        sp:modMin 0 ;
                        sp:subPath [
                            a sp:AltPath ;
                            sp:path1 edg:usesSoftwareProgram ;
                            sp:path2 edg:usesSoftwareExecutable ;
                          ] ;
                      ] ;
                    sp:subject [
                        sp:varName "rightNode" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "sourceEndpoint" ;
                      ] ;
                    sp:predicate edg:serviceEndpoint ;
                    sp:subject [
                        sp:varName "leftNodeSoftwareExecutable" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "targetEndpoint" ;
                      ] ;
                    sp:predicate edg:serviceEndpoint ;
                    sp:subject [
                        sp:varName "rightNodeSoftwareExecutable" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "sourceEndpoint" ;
                      ] ;
                    sp:predicate edg:source ;
                    sp:subject [
                        sp:varName "flow" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "targetEndpoint" ;
                      ] ;
                    sp:predicate edg:target ;
                    sp:subject [
                        sp:varName "flow" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "flowType" ;
                      ] ;
                    sp:predicate rdf:type ;
                    sp:subject [
                        sp:varName "flow" ;
                      ] ;
                  ]
                  [
                    a sp:TriplePath ;
                    sp:object edg:Dataflow ;
                    sp:path [
                        a sp:ModPath ;
                        sp:modMax -2 ;
                        sp:modMin 0 ;
                        sp:subPath rdfs:subClassOf ;
                      ] ;
                    sp:subject [
                        sp:varName "flowType" ;
                      ] ;
                  ]
                  [
                    a sp:Filter ;
                    sp:expression [
                        a sp:or ;
                        sp:arg1 [
                            a sp:or ;
                            sp:arg1 [
                                a sp:eq ;
                                sp:arg1 [
                                    sp:varName "linkType" ;
                                  ] ;
                                sp:arg2 "dataflow" ;
                              ] ;
                            sp:arg2 [
                                a sp:eq ;
                                sp:arg1 [
                                    sp:varName "linkType" ;
                                  ] ;
                                sp:arg2 "service-endpoint" ;
                              ] ;
                          ] ;
                        sp:arg2 [
                            a sp:and ;
                            sp:arg1 [
                                a sp:eq ;
                                sp:arg1 [
                                    sp:varName "linkType" ;
                                  ] ;
                                sp:arg2 "logical-flow" ;
                              ] ;
                            sp:arg2 [
                                a sp:eq ;
                                sp:arg1 [
                                    sp:varName "flowType" ;
                                  ] ;
                                sp:arg2 edg:LogicalFlow ;
                              ] ;
                          ] ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression "service-endpoint" ;
                    sp:variable [
                        sp:varName "dependencyType" ;
                      ] ;
                  ]
                )
                (
                  [
                    a sp:TriplePath ;
                    sp:object [
                        sp:varName "leftNodeSoftwareExecutable" ;
                      ] ;
                    sp:path [
                        a sp:ModPath ;
                        sp:modMax -1 ;
                        sp:modMin 0 ;
                        sp:subPath [
                            a sp:AltPath ;
                            sp:path1 edg:usesSoftwareProgram ;
                            sp:path2 edg:usesSoftwareExecutable ;
                          ] ;
                      ] ;
                    sp:subject [
                        sp:varName "leftNode" ;
                      ] ;
                  ]
                  [
                    a sp:TriplePath ;
                    sp:object [
                        sp:varName "rightNodeSoftwareExecutable" ;
                      ] ;
                    sp:path [
                        a sp:ModPath ;
                        sp:modMax -1 ;
                        sp:modMin 0 ;
                        sp:subPath [
                            a sp:AltPath ;
                            sp:path1 edg:usesSoftwareProgram ;
                            sp:path2 edg:usesSoftwareExecutable ;
                          ] ;
                      ] ;
                    sp:subject [
                        sp:varName "rightNode" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "leftNodeSoftwareExecutable" ;
                      ] ;
                    sp:predicate edg:source ;
                    sp:subject [
                        sp:varName "flow" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "rightNodeSoftwareExecutable" ;
                      ] ;
                    sp:predicate edg:target ;
                    sp:subject [
                        sp:varName "flow" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "flowType" ;
                      ] ;
                    sp:predicate rdf:type ;
                    sp:subject [
                        sp:varName "flow" ;
                      ] ;
                  ]
                  [
                    a sp:Filter ;
                    sp:expression [
                        a sp:or ;
                        sp:arg1 [
                            a sp:and ;
                            sp:arg1 [
                                a sp:or ;
                                sp:arg1 [
                                    a sp:eq ;
                                    sp:arg1 [
                                        sp:varName "linkType" ;
                                      ] ;
                                    sp:arg2 "dataflow" ;
                                  ] ;
                                sp:arg2 [
                                    a sp:eq ;
                                    sp:arg1 [
                                        sp:varName "linkType" ;
                                      ] ;
                                    sp:arg2 "service-endpoint" ;
                                  ] ;
                              ] ;
                            sp:arg2 [
                                a sp:eq ;
                                sp:arg1 [
                                    sp:varName "flowType" ;
                                  ] ;
                                sp:arg2 edg:Dataflow ;
                              ] ;
                          ] ;
                        sp:arg2 [
                            a sp:and ;
                            sp:arg1 [
                                a sp:eq ;
                                sp:arg1 [
                                    sp:varName "linkType" ;
                                  ] ;
                                sp:arg2 "logical-flow" ;
                              ] ;
                            sp:arg2 [
                                a sp:eq ;
                                sp:arg1 [
                                    sp:varName "flowType" ;
                                  ] ;
                                sp:arg2 edg:LogicalFlow ;
                              ] ;
                          ] ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression "flow-io" ;
                    sp:variable [
                        sp:varName "dependencyType" ;
                      ] ;
                  ]
                )
              ) ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate edg:linkType ;
      spl:valueType xsd:string ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:leftNode ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:rightNode ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:private true ;
  rdfs:comment "returns flow details given source and target nodes" ;
  rdfs:label "get source to target flow details" ;
  rdfs:subClassOf edg:SelectTemplates ;
.
edg:resultSetRowsWithFunctionalDependencies
  spin:returnType xsd:string ;
.
sioc:Role
  ui:instanceView """
<ui:group ui:id=\"derivation-map-data-service\" ui:priority=\"{= 10 }\">
    <ui:resourceView arg:leftNode=\"{= ?leftNode }\" arg:rightNode=\"{= ?this }\" ui:matchIds=\"derivation-map-data-service-other-node\" ui:resource=\"{= ?leftNode }\"/>
</ui:group>
"""^^ui:Literal ;
.
arg:dataCoupling
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:functionalCoupling
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:upstreamResource
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
