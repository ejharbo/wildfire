(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.LineageGram = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
(function (process,global){
/*!
 * @overview es6-promise - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
 * @version   3.3.1
 */

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global.ES6Promise = factory());
}(this, (function () { 'use strict';

function objectOrFunction(x) {
  return typeof x === 'function' || typeof x === 'object' && x !== null;
}

function isFunction(x) {
  return typeof x === 'function';
}

var _isArray = undefined;
if (!Array.isArray) {
  _isArray = function (x) {
    return Object.prototype.toString.call(x) === '[object Array]';
  };
} else {
  _isArray = Array.isArray;
}

var isArray = _isArray;

var len = 0;
var vertxNext = undefined;
var customSchedulerFn = undefined;

var asap = function asap(callback, arg) {
  queue[len] = callback;
  queue[len + 1] = arg;
  len += 2;
  if (len === 2) {
    // If len is 2, that means that we need to schedule an async flush.
    // If additional callbacks are queued before the queue is flushed, they
    // will be processed by this flush that we are scheduling.
    if (customSchedulerFn) {
      customSchedulerFn(flush);
    } else {
      scheduleFlush();
    }
  }
};

function setScheduler(scheduleFn) {
  customSchedulerFn = scheduleFn;
}

function setAsap(asapFn) {
  asap = asapFn;
}

var browserWindow = typeof window !== 'undefined' ? window : undefined;
var browserGlobal = browserWindow || {};
var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
var isNode = typeof self === 'undefined' && typeof process !== 'undefined' && ({}).toString.call(process) === '[object process]';

// test for web worker but not in IE10
var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';

// node
function useNextTick() {
  // node version 0.10.x displays a deprecation warning when nextTick is used recursively
  // see https://github.com/cujojs/when/issues/410 for details
  return function () {
    return process.nextTick(flush);
  };
}

// vertx
function useVertxTimer() {
  return function () {
    vertxNext(flush);
  };
}

function useMutationObserver() {
  var iterations = 0;
  var observer = new BrowserMutationObserver(flush);
  var node = document.createTextNode('');
  observer.observe(node, { characterData: true });

  return function () {
    node.data = iterations = ++iterations % 2;
  };
}

// web worker
function useMessageChannel() {
  var channel = new MessageChannel();
  channel.port1.onmessage = flush;
  return function () {
    return channel.port2.postMessage(0);
  };
}

function useSetTimeout() {
  // Store setTimeout reference so es6-promise will be unaffected by
  // other code modifying setTimeout (like sinon.useFakeTimers())
  var globalSetTimeout = setTimeout;
  return function () {
    return globalSetTimeout(flush, 1);
  };
}

var queue = new Array(1000);
function flush() {
  for (var i = 0; i < len; i += 2) {
    var callback = queue[i];
    var arg = queue[i + 1];

    callback(arg);

    queue[i] = undefined;
    queue[i + 1] = undefined;
  }

  len = 0;
}

function attemptVertx() {
  try {
    var r = require;
    var vertx = r('vertx');
    vertxNext = vertx.runOnLoop || vertx.runOnContext;
    return useVertxTimer();
  } catch (e) {
    return useSetTimeout();
  }
}

var scheduleFlush = undefined;
// Decide what async method to use to triggering processing of queued callbacks:
if (isNode) {
  scheduleFlush = useNextTick();
} else if (BrowserMutationObserver) {
  scheduleFlush = useMutationObserver();
} else if (isWorker) {
  scheduleFlush = useMessageChannel();
} else if (browserWindow === undefined && typeof require === 'function') {
  scheduleFlush = attemptVertx();
} else {
  scheduleFlush = useSetTimeout();
}

function then(onFulfillment, onRejection) {
  var _arguments = arguments;

  var parent = this;

  var child = new this.constructor(noop);

  if (child[PROMISE_ID] === undefined) {
    makePromise(child);
  }

  var _state = parent._state;

  if (_state) {
    (function () {
      var callback = _arguments[_state - 1];
      asap(function () {
        return invokeCallback(_state, child, callback, parent._result);
      });
    })();
  } else {
    subscribe(parent, child, onFulfillment, onRejection);
  }

  return child;
}

/**
  `Promise.resolve` returns a promise that will become resolved with the
  passed `value`. It is shorthand for the following:

  ```javascript
  let promise = new Promise(function(resolve, reject){
    resolve(1);
  });

  promise.then(function(value){
    // value === 1
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  let promise = Promise.resolve(1);

  promise.then(function(value){
    // value === 1
  });
  ```

  @method resolve
  @static
  @param {Any} value value that the returned promise will be resolved with
  Useful for tooling.
  @return {Promise} a promise that will become fulfilled with the given
  `value`
*/
function resolve(object) {
  /*jshint validthis:true */
  var Constructor = this;

  if (object && typeof object === 'object' && object.constructor === Constructor) {
    return object;
  }

  var promise = new Constructor(noop);
  _resolve(promise, object);
  return promise;
}

var PROMISE_ID = Math.random().toString(36).substring(16);

function noop() {}

var PENDING = void 0;
var FULFILLED = 1;
var REJECTED = 2;

var GET_THEN_ERROR = new ErrorObject();

function selfFulfillment() {
  return new TypeError("You cannot resolve a promise with itself");
}

function cannotReturnOwn() {
  return new TypeError('A promises callback cannot return that same promise.');
}

function getThen(promise) {
  try {
    return promise.then;
  } catch (error) {
    GET_THEN_ERROR.error = error;
    return GET_THEN_ERROR;
  }
}

function tryThen(then, value, fulfillmentHandler, rejectionHandler) {
  try {
    then.call(value, fulfillmentHandler, rejectionHandler);
  } catch (e) {
    return e;
  }
}

function handleForeignThenable(promise, thenable, then) {
  asap(function (promise) {
    var sealed = false;
    var error = tryThen(then, thenable, function (value) {
      if (sealed) {
        return;
      }
      sealed = true;
      if (thenable !== value) {
        _resolve(promise, value);
      } else {
        fulfill(promise, value);
      }
    }, function (reason) {
      if (sealed) {
        return;
      }
      sealed = true;

      _reject(promise, reason);
    }, 'Settle: ' + (promise._label || ' unknown promise'));

    if (!sealed && error) {
      sealed = true;
      _reject(promise, error);
    }
  }, promise);
}

function handleOwnThenable(promise, thenable) {
  if (thenable._state === FULFILLED) {
    fulfill(promise, thenable._result);
  } else if (thenable._state === REJECTED) {
    _reject(promise, thenable._result);
  } else {
    subscribe(thenable, undefined, function (value) {
      return _resolve(promise, value);
    }, function (reason) {
      return _reject(promise, reason);
    });
  }
}

function handleMaybeThenable(promise, maybeThenable, then$$) {
  if (maybeThenable.constructor === promise.constructor && then$$ === then && maybeThenable.constructor.resolve === resolve) {
    handleOwnThenable(promise, maybeThenable);
  } else {
    if (then$$ === GET_THEN_ERROR) {
      _reject(promise, GET_THEN_ERROR.error);
    } else if (then$$ === undefined) {
      fulfill(promise, maybeThenable);
    } else if (isFunction(then$$)) {
      handleForeignThenable(promise, maybeThenable, then$$);
    } else {
      fulfill(promise, maybeThenable);
    }
  }
}

function _resolve(promise, value) {
  if (promise === value) {
    _reject(promise, selfFulfillment());
  } else if (objectOrFunction(value)) {
    handleMaybeThenable(promise, value, getThen(value));
  } else {
    fulfill(promise, value);
  }
}

function publishRejection(promise) {
  if (promise._onerror) {
    promise._onerror(promise._result);
  }

  publish(promise);
}

function fulfill(promise, value) {
  if (promise._state !== PENDING) {
    return;
  }

  promise._result = value;
  promise._state = FULFILLED;

  if (promise._subscribers.length !== 0) {
    asap(publish, promise);
  }
}

function _reject(promise, reason) {
  if (promise._state !== PENDING) {
    return;
  }
  promise._state = REJECTED;
  promise._result = reason;

  asap(publishRejection, promise);
}

function subscribe(parent, child, onFulfillment, onRejection) {
  var _subscribers = parent._subscribers;
  var length = _subscribers.length;

  parent._onerror = null;

  _subscribers[length] = child;
  _subscribers[length + FULFILLED] = onFulfillment;
  _subscribers[length + REJECTED] = onRejection;

  if (length === 0 && parent._state) {
    asap(publish, parent);
  }
}

function publish(promise) {
  var subscribers = promise._subscribers;
  var settled = promise._state;

  if (subscribers.length === 0) {
    return;
  }

  var child = undefined,
      callback = undefined,
      detail = promise._result;

  for (var i = 0; i < subscribers.length; i += 3) {
    child = subscribers[i];
    callback = subscribers[i + settled];

    if (child) {
      invokeCallback(settled, child, callback, detail);
    } else {
      callback(detail);
    }
  }

  promise._subscribers.length = 0;
}

function ErrorObject() {
  this.error = null;
}

var TRY_CATCH_ERROR = new ErrorObject();

function tryCatch(callback, detail) {
  try {
    return callback(detail);
  } catch (e) {
    TRY_CATCH_ERROR.error = e;
    return TRY_CATCH_ERROR;
  }
}

function invokeCallback(settled, promise, callback, detail) {
  var hasCallback = isFunction(callback),
      value = undefined,
      error = undefined,
      succeeded = undefined,
      failed = undefined;

  if (hasCallback) {
    value = tryCatch(callback, detail);

    if (value === TRY_CATCH_ERROR) {
      failed = true;
      error = value.error;
      value = null;
    } else {
      succeeded = true;
    }

    if (promise === value) {
      _reject(promise, cannotReturnOwn());
      return;
    }
  } else {
    value = detail;
    succeeded = true;
  }

  if (promise._state !== PENDING) {
    // noop
  } else if (hasCallback && succeeded) {
      _resolve(promise, value);
    } else if (failed) {
      _reject(promise, error);
    } else if (settled === FULFILLED) {
      fulfill(promise, value);
    } else if (settled === REJECTED) {
      _reject(promise, value);
    }
}

function initializePromise(promise, resolver) {
  try {
    resolver(function resolvePromise(value) {
      _resolve(promise, value);
    }, function rejectPromise(reason) {
      _reject(promise, reason);
    });
  } catch (e) {
    _reject(promise, e);
  }
}

var id = 0;
function nextId() {
  return id++;
}

function makePromise(promise) {
  promise[PROMISE_ID] = id++;
  promise._state = undefined;
  promise._result = undefined;
  promise._subscribers = [];
}

function Enumerator(Constructor, input) {
  this._instanceConstructor = Constructor;
  this.promise = new Constructor(noop);

  if (!this.promise[PROMISE_ID]) {
    makePromise(this.promise);
  }

  if (isArray(input)) {
    this._input = input;
    this.length = input.length;
    this._remaining = input.length;

    this._result = new Array(this.length);

    if (this.length === 0) {
      fulfill(this.promise, this._result);
    } else {
      this.length = this.length || 0;
      this._enumerate();
      if (this._remaining === 0) {
        fulfill(this.promise, this._result);
      }
    }
  } else {
    _reject(this.promise, validationError());
  }
}

function validationError() {
  return new Error('Array Methods must be provided an Array');
};

Enumerator.prototype._enumerate = function () {
  var length = this.length;
  var _input = this._input;

  for (var i = 0; this._state === PENDING && i < length; i++) {
    this._eachEntry(_input[i], i);
  }
};

Enumerator.prototype._eachEntry = function (entry, i) {
  var c = this._instanceConstructor;
  var resolve$$ = c.resolve;

  if (resolve$$ === resolve) {
    var _then = getThen(entry);

    if (_then === then && entry._state !== PENDING) {
      this._settledAt(entry._state, i, entry._result);
    } else if (typeof _then !== 'function') {
      this._remaining--;
      this._result[i] = entry;
    } else if (c === Promise) {
      var promise = new c(noop);
      handleMaybeThenable(promise, entry, _then);
      this._willSettleAt(promise, i);
    } else {
      this._willSettleAt(new c(function (resolve$$) {
        return resolve$$(entry);
      }), i);
    }
  } else {
    this._willSettleAt(resolve$$(entry), i);
  }
};

Enumerator.prototype._settledAt = function (state, i, value) {
  var promise = this.promise;

  if (promise._state === PENDING) {
    this._remaining--;

    if (state === REJECTED) {
      _reject(promise, value);
    } else {
      this._result[i] = value;
    }
  }

  if (this._remaining === 0) {
    fulfill(promise, this._result);
  }
};

Enumerator.prototype._willSettleAt = function (promise, i) {
  var enumerator = this;

  subscribe(promise, undefined, function (value) {
    return enumerator._settledAt(FULFILLED, i, value);
  }, function (reason) {
    return enumerator._settledAt(REJECTED, i, reason);
  });
};

/**
  `Promise.all` accepts an array of promises, and returns a new promise which
  is fulfilled with an array of fulfillment values for the passed promises, or
  rejected with the reason of the first passed promise to be rejected. It casts all
  elements of the passed iterable to promises as it runs this algorithm.

  Example:

  ```javascript
  let promise1 = resolve(1);
  let promise2 = resolve(2);
  let promise3 = resolve(3);
  let promises = [ promise1, promise2, promise3 ];

  Promise.all(promises).then(function(array){
    // The array here would be [ 1, 2, 3 ];
  });
  ```

  If any of the `promises` given to `all` are rejected, the first promise
  that is rejected will be given as an argument to the returned promises's
  rejection handler. For example:

  Example:

  ```javascript
  let promise1 = resolve(1);
  let promise2 = reject(new Error("2"));
  let promise3 = reject(new Error("3"));
  let promises = [ promise1, promise2, promise3 ];

  Promise.all(promises).then(function(array){
    // Code here never runs because there are rejected promises!
  }, function(error) {
    // error.message === "2"
  });
  ```

  @method all
  @static
  @param {Array} entries array of promises
  @param {String} label optional string for labeling the promise.
  Useful for tooling.
  @return {Promise} promise that is fulfilled when all `promises` have been
  fulfilled, or rejected if any of them become rejected.
  @static
*/
function all(entries) {
  return new Enumerator(this, entries).promise;
}

/**
  `Promise.race` returns a new promise which is settled in the same way as the
  first passed promise to settle.

  Example:

  ```javascript
  let promise1 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

  let promise2 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 2');
    }, 100);
  });

  Promise.race([promise1, promise2]).then(function(result){
    // result === 'promise 2' because it was resolved before promise1
    // was resolved.
  });
  ```

  `Promise.race` is deterministic in that only the state of the first
  settled promise matters. For example, even if other promises given to the
  `promises` array argument are resolved, but the first settled promise has
  become rejected before the other promises became fulfilled, the returned
  promise will become rejected:

  ```javascript
  let promise1 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

  let promise2 = new Promise(function(resolve, reject){
    setTimeout(function(){
      reject(new Error('promise 2'));
    }, 100);
  });

  Promise.race([promise1, promise2]).then(function(result){
    // Code here never runs
  }, function(reason){
    // reason.message === 'promise 2' because promise 2 became rejected before
    // promise 1 became fulfilled
  });
  ```

  An example real-world use case is implementing timeouts:

  ```javascript
  Promise.race([ajax('foo.json'), timeout(5000)])
  ```

  @method race
  @static
  @param {Array} promises array of promises to observe
  Useful for tooling.
  @return {Promise} a promise which settles in the same way as the first passed
  promise to settle.
*/
function race(entries) {
  /*jshint validthis:true */
  var Constructor = this;

  if (!isArray(entries)) {
    return new Constructor(function (_, reject) {
      return reject(new TypeError('You must pass an array to race.'));
    });
  } else {
    return new Constructor(function (resolve, reject) {
      var length = entries.length;
      for (var i = 0; i < length; i++) {
        Constructor.resolve(entries[i]).then(resolve, reject);
      }
    });
  }
}

/**
  `Promise.reject` returns a promise rejected with the passed `reason`.
  It is shorthand for the following:

  ```javascript
  let promise = new Promise(function(resolve, reject){
    reject(new Error('WHOOPS'));
  });

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  let promise = Promise.reject(new Error('WHOOPS'));

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  @method reject
  @static
  @param {Any} reason value that the returned promise will be rejected with.
  Useful for tooling.
  @return {Promise} a promise rejected with the given `reason`.
*/
function reject(reason) {
  /*jshint validthis:true */
  var Constructor = this;
  var promise = new Constructor(noop);
  _reject(promise, reason);
  return promise;
}

function needsResolver() {
  throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
}

function needsNew() {
  throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
}

/**
  Promise objects represent the eventual result of an asynchronous operation. The
  primary way of interacting with a promise is through its `then` method, which
  registers callbacks to receive either a promise's eventual value or the reason
  why the promise cannot be fulfilled.

  Terminology
  -----------

  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
  - `thenable` is an object or function that defines a `then` method.
  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
  - `exception` is a value that is thrown using the throw statement.
  - `reason` is a value that indicates why a promise was rejected.
  - `settled` the final resting state of a promise, fulfilled or rejected.

  A promise can be in one of three states: pending, fulfilled, or rejected.

  Promises that are fulfilled have a fulfillment value and are in the fulfilled
  state.  Promises that are rejected have a rejection reason and are in the
  rejected state.  A fulfillment value is never a thenable.

  Promises can also be said to *resolve* a value.  If this value is also a
  promise, then the original promise's settled state will match the value's
  settled state.  So a promise that *resolves* a promise that rejects will
  itself reject, and a promise that *resolves* a promise that fulfills will
  itself fulfill.


  Basic Usage:
  ------------

  ```js
  let promise = new Promise(function(resolve, reject) {
    // on success
    resolve(value);

    // on failure
    reject(reason);
  });

  promise.then(function(value) {
    // on fulfillment
  }, function(reason) {
    // on rejection
  });
  ```

  Advanced Usage:
  ---------------

  Promises shine when abstracting away asynchronous interactions such as
  `XMLHttpRequest`s.

  ```js
  function getJSON(url) {
    return new Promise(function(resolve, reject){
      let xhr = new XMLHttpRequest();

      xhr.open('GET', url);
      xhr.onreadystatechange = handler;
      xhr.responseType = 'json';
      xhr.setRequestHeader('Accept', 'application/json');
      xhr.send();

      function handler() {
        if (this.readyState === this.DONE) {
          if (this.status === 200) {
            resolve(this.response);
          } else {
            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
          }
        }
      };
    });
  }

  getJSON('/posts.json').then(function(json) {
    // on fulfillment
  }, function(reason) {
    // on rejection
  });
  ```

  Unlike callbacks, promises are great composable primitives.

  ```js
  Promise.all([
    getJSON('/posts'),
    getJSON('/comments')
  ]).then(function(values){
    values[0] // => postsJSON
    values[1] // => commentsJSON

    return values;
  });
  ```

  @class Promise
  @param {function} resolver
  Useful for tooling.
  @constructor
*/
function Promise(resolver) {
  this[PROMISE_ID] = nextId();
  this._result = this._state = undefined;
  this._subscribers = [];

  if (noop !== resolver) {
    typeof resolver !== 'function' && needsResolver();
    this instanceof Promise ? initializePromise(this, resolver) : needsNew();
  }
}

Promise.all = all;
Promise.race = race;
Promise.resolve = resolve;
Promise.reject = reject;
Promise._setScheduler = setScheduler;
Promise._setAsap = setAsap;
Promise._asap = asap;

Promise.prototype = {
  constructor: Promise,

  /**
    The primary way of interacting with a promise is through its `then` method,
    which registers callbacks to receive either a promise's eventual value or the
    reason why the promise cannot be fulfilled.
  
    ```js
    findUser().then(function(user){
      // user is available
    }, function(reason){
      // user is unavailable, and you are given the reason why
    });
    ```
  
    Chaining
    --------
  
    The return value of `then` is itself a promise.  This second, 'downstream'
    promise is resolved with the return value of the first promise's fulfillment
    or rejection handler, or rejected if the handler throws an exception.
  
    ```js
    findUser().then(function (user) {
      return user.name;
    }, function (reason) {
      return 'default name';
    }).then(function (userName) {
      // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
      // will be `'default name'`
    });
  
    findUser().then(function (user) {
      throw new Error('Found user, but still unhappy');
    }, function (reason) {
      throw new Error('`findUser` rejected and we're unhappy');
    }).then(function (value) {
      // never reached
    }, function (reason) {
      // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
      // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
    });
    ```
    If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.
  
    ```js
    findUser().then(function (user) {
      throw new PedagogicalException('Upstream error');
    }).then(function (value) {
      // never reached
    }).then(function (value) {
      // never reached
    }, function (reason) {
      // The `PedgagocialException` is propagated all the way down to here
    });
    ```
  
    Assimilation
    ------------
  
    Sometimes the value you want to propagate to a downstream promise can only be
    retrieved asynchronously. This can be achieved by returning a promise in the
    fulfillment or rejection handler. The downstream promise will then be pending
    until the returned promise is settled. This is called *assimilation*.
  
    ```js
    findUser().then(function (user) {
      return findCommentsByAuthor(user);
    }).then(function (comments) {
      // The user's comments are now available
    });
    ```
  
    If the assimliated promise rejects, then the downstream promise will also reject.
  
    ```js
    findUser().then(function (user) {
      return findCommentsByAuthor(user);
    }).then(function (comments) {
      // If `findCommentsByAuthor` fulfills, we'll have the value here
    }, function (reason) {
      // If `findCommentsByAuthor` rejects, we'll have the reason here
    });
    ```
  
    Simple Example
    --------------
  
    Synchronous Example
  
    ```javascript
    let result;
  
    try {
      result = findResult();
      // success
    } catch(reason) {
      // failure
    }
    ```
  
    Errback Example
  
    ```js
    findResult(function(result, err){
      if (err) {
        // failure
      } else {
        // success
      }
    });
    ```
  
    Promise Example;
  
    ```javascript
    findResult().then(function(result){
      // success
    }, function(reason){
      // failure
    });
    ```
  
    Advanced Example
    --------------
  
    Synchronous Example
  
    ```javascript
    let author, books;
  
    try {
      author = findAuthor();
      books  = findBooksByAuthor(author);
      // success
    } catch(reason) {
      // failure
    }
    ```
  
    Errback Example
  
    ```js
  
    function foundBooks(books) {
  
    }
  
    function failure(reason) {
  
    }
  
    findAuthor(function(author, err){
      if (err) {
        failure(err);
        // failure
      } else {
        try {
          findBoooksByAuthor(author, function(books, err) {
            if (err) {
              failure(err);
            } else {
              try {
                foundBooks(books);
              } catch(reason) {
                failure(reason);
              }
            }
          });
        } catch(error) {
          failure(err);
        }
        // success
      }
    });
    ```
  
    Promise Example;
  
    ```javascript
    findAuthor().
      then(findBooksByAuthor).
      then(function(books){
        // found books
    }).catch(function(reason){
      // something went wrong
    });
    ```
  
    @method then
    @param {Function} onFulfilled
    @param {Function} onRejected
    Useful for tooling.
    @return {Promise}
  */
  then: then,

  /**
    `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
    as the catch block of a try/catch statement.
  
    ```js
    function findAuthor(){
      throw new Error('couldn't find that author');
    }
  
    // synchronous
    try {
      findAuthor();
    } catch(reason) {
      // something went wrong
    }
  
    // async with promises
    findAuthor().catch(function(reason){
      // something went wrong
    });
    ```
  
    @method catch
    @param {Function} onRejection
    Useful for tooling.
    @return {Promise}
  */
  'catch': function _catch(onRejection) {
    return this.then(null, onRejection);
  }
};

function polyfill() {
    var local = undefined;

    if (typeof global !== 'undefined') {
        local = global;
    } else if (typeof self !== 'undefined') {
        local = self;
    } else {
        try {
            local = Function('return this')();
        } catch (e) {
            throw new Error('polyfill failed because global object is unavailable in this environment');
        }
    }

    var P = local.Promise;

    if (P) {
        var promiseToString = null;
        try {
            promiseToString = Object.prototype.toString.call(P.resolve());
        } catch (e) {
            // silently ignored
        }

        if (promiseToString === '[object Promise]' && !P.cast) {
            return;
        }
    }

    local.Promise = Promise;
}

polyfill();
// Strange compat..
Promise.polyfill = polyfill;
Promise.Promise = Promise;

return Promise;

})));

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"_process":3}],2:[function(require,module,exports){
/*! FileSaver.js v1.3.6
 *
 * A saveAs() FileSaver implementation.
 *
 * By Travis Clarke, https://travismclarke.com
 * By Eli Grey, http://eligrey.com
 *
 * License: MIT (https://github.com/clarketm/FileSaver.js/blob/master/LICENSE.md)
 */

;(function (root, factory) {
    if (typeof exports === 'object' && typeof exports.nodeName !== 'string') {
        module.exports = root.document ? factory(root, true) : function (w) {
            if (!w.document) {
                throw new Error("FileSaver requires a window with a document");
            }
            return factory(w);
        };
    } else {
        factory(root);
    }
}(window || this, function (window, noGlobal) {
        "use strict";
        // IE <10 is explicitly unsupported
        if (typeof window === "undefined" || typeof navigator !== "undefined" && /MSIE [1-9]\./.test(navigator.userAgent)) {
            return;
        }
        var
            doc = window.document
            // only get URL when necessary in case Blob.js hasn't overridden it yet
            , get_URL = function () {
                return window.URL || window.webkitURL || window;
            }
            , save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a")
            , can_use_save_link = "download" in save_link
            , click = function (node) {
                var event = new MouseEvent("click");
                node.dispatchEvent(event);
            }
            , is_safari = /constructor/i.test(window.HTMLElement) || window.safari
            , is_chrome_ios = /CriOS\/[\d]+/.test(navigator.userAgent)
            , throw_outside = function (ex) {
                (window.setImmediate || window.setTimeout)(function () {
                    throw ex;
                }, 0);
            }
            , force_saveable_type = "application/octet-stream"
            // the Blob API is fundamentally broken as there is no "downloadfinished" event to subscribe to
            , arbitrary_revoke_timeout = 1000 * 40 // in ms
            , revoke = function (file) {
                var revoker = function () {
                    if (typeof file === "string") { // file is an object URL
                        get_URL().revokeObjectURL(file);
                    } else { // file is a File
                        file.remove();
                    }
                };
                setTimeout(revoker, arbitrary_revoke_timeout);
            }
            , dispatch = function (filesaver, event_types, event) {
                event_types = [].concat(event_types);
                var i = event_types.length;
                while (i--) {
                    var listener = filesaver["on" + event_types[i]];
                    if (typeof listener === "function") {
                        try {
                            listener.call(filesaver, event || filesaver);
                        } catch (ex) {
                            throw_outside(ex);
                        }
                    }
                }
            }
            , auto_bom = function (blob) {
                // prepend BOM for UTF-8 XML and text/* types (including HTML)
                // note: your browser will automatically convert UTF-16 U+FEFF to EF BB BF
                if (/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type)) {
                    return new Blob([String.fromCharCode(0xFEFF), blob], {type: blob.type});
                }
                return blob;
            }
            , FileSaver = function (blob, name, no_auto_bom) {
                if (!no_auto_bom) {
                    blob = auto_bom(blob);
                }
                // First try a.download, then web filesystem, then object URLs
                var
                    filesaver = this
                    , type = blob.type
                    , force = type === force_saveable_type
                    , object_url
                    , dispatch_all = function () {
                        dispatch(filesaver, "writestart progress write writeend".split(" "));
                    }
                    // on any filesys errors revert to saving with object URLs
                    , fs_error = function () {
                        if ((is_chrome_ios || (force && is_safari)) && window.FileReader) {
                            // Safari doesn't allow downloading of blob urls
                            var reader = new FileReader();
                            reader.onloadend = function () {
                                var url = is_chrome_ios ? reader.result : reader.result.replace(/^data:[^;]*;/, 'data:attachment/file;');
                                var popup = window.open(url, '_blank');
                                if (!popup) window.location.href = url;
                                url = undefined; // release reference before dispatching
                                filesaver.readyState = filesaver.DONE;
                                dispatch_all();
                            };
                            reader.readAsDataURL(blob);
                            filesaver.readyState = filesaver.INIT;
                            return;
                        }
                        // don't create more object URLs than needed
                        if (!object_url) {
                            object_url = get_URL().createObjectURL(blob);
                        }
                        if (force) {
                            window.location.href = object_url;
                        } else {
                            var opened = window.open(object_url, "_blank");
                            if (!opened) {
                                // Apple does not allow window.open, see https://developer.apple.com/library/safari/documentation/Tools/Conceptual/SafariExtensionGuide/WorkingwithWindowsandTabs/WorkingwithWindowsandTabs.html
                                window.location.href = object_url;
                            }
                        }
                        filesaver.readyState = filesaver.DONE;
                        dispatch_all();
                        revoke(object_url);
                    }
                    ;
                filesaver.readyState = filesaver.INIT;

                if (can_use_save_link) {
                    object_url = get_URL().createObjectURL(blob);
                    setTimeout(function () {
                        save_link.href = object_url;
                        save_link.download = name;
                        click(save_link);
                        dispatch_all();
                        revoke(object_url);
                        filesaver.readyState = filesaver.DONE;
                    });
                    return;
                }

                fs_error();
            }
            , FS_proto = FileSaver.prototype
            , saveAs = function (blob, name, no_auto_bom) {
                return new FileSaver(blob, name || blob.name || "download", no_auto_bom);
            }
            ;
        // IE 10+ (native saveAs)
        if (typeof navigator !== "undefined" && navigator.msSaveOrOpenBlob) {
            saveAs = function (blob, name, no_auto_bom) {
                name = name || blob.name || "download";

                if (!no_auto_bom) {
                    blob = auto_bom(blob);
                }
                return navigator.msSaveOrOpenBlob(blob, name);
            };
        }

        FS_proto.abort = function () {
        };
        FS_proto.readyState = FS_proto.INIT = 0;
        FS_proto.WRITING = 1;
        FS_proto.DONE = 2;

        FS_proto.error =
            FS_proto.onwritestart =
                FS_proto.onprogress =
                    FS_proto.onwrite =
                        FS_proto.onabort =
                            FS_proto.onerror =
                                FS_proto.onwriteend =
                                    null;

        if (typeof define === "function" && define.amd) {
            define("file-saverjs", [], function () {
                return saveAs;
            });
        }

        if (typeof noGlobal === 'undefined') {
            window.saveAs = saveAs;
        }
        return saveAs;
    }
));

},{}],3:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],4:[function(require,module,exports){
;(function(undefined) {
  'use strict';

  var __instances = {};

  /**
   * This is the sigma instances constructor. One instance of sigma represent
   * one graph. It is possible to represent this grapÄ¥ with several renderers
   * at the same time. By default, the default renderer (WebGL + Canvas
   * polyfill) will be used as the only renderer, with the container specified
   * in the configuration.
   *
   * @param  {?*}    conf The configuration of the instance. There are a lot of
   *                      different recognized forms to instantiate sigma, check
   *                      example files, documentation in this file and unit
   *                      tests to know more.
   * @return {sigma}      The fresh new sigma instance.
   *
   * Instanciating sigma:
   * ********************
   * If no parameter is given to the constructor, the instance will be created
   * without any renderer or camera. It will just instantiate the graph, and
   * other modules will have to be instantiated through the public methods,
   * like "addRenderer" etc:
   *
   *  > s0 = new sigma();
   *  > s0.addRenderer({
   *  >   type: 'canvas',
   *  >   container: 'my-container-id'
   *  > });
   *
   * In most of the cases, sigma will simply be used with the default renderer.
   * Then, since the only required parameter is the DOM container, there are
   * some simpler way to call the constructor. The four following calls do the
   * exact same things:
   *
   *  > s1 = new sigma('my-container-id');
   *  > s2 = new sigma(document.getElementById('my-container-id'));
   *  > s3 = new sigma({
   *  >   container: document.getElementById('my-container-id')
   *  > });
   *  > s4 = new sigma({
   *  >   renderers: [{
   *  >     container: document.getElementById('my-container-id')
   *  >   }]
   *  > });
   *
   * Recognized parameters:
   * **********************
   * Here is the exhaustive list of every accepted parameters, when calling the
   * constructor with to top level configuration object (fourth case in the
   * previous examples):
   *
   *   {?string} id        The id of the instance. It will be generated
   *                       automatically if not specified.
   *   {?array}  renderers An array containing objects describing renderers.
   *   {?object} graph     An object containing an array of nodes and an array
   *                       of edges, to avoid having to add them by hand later.
   *   {?object} settings  An object containing instance specific settings that
   *                       will override the default ones defined in the object
   *                       sigma.settings.
   */
  var sigma = function(conf) {
    // Local variables:
    // ****************
    var i,
        l,
        a,
        c,
        o,
        id;

    sigma.classes.dispatcher.extend(this);

    // Private attributes:
    // *******************
    var _self = this,
        _conf = conf || {};

    // Little shortcut:
    // ****************
    // The configuration is supposed to have a list of the configuration
    // objects for each renderer.
    //  - If there are no configuration at all, then nothing is done.
    //  - If there are no renderer list, the given configuration object will be
    //    considered as describing the first and only renderer.
    //  - If there are no renderer list nor "container" object, it will be
    //    considered as the container itself (a DOM element).
    //  - If the argument passed to sigma() is a string, it will be considered
    //    as the ID of the DOM container.
    if (
      typeof _conf === 'string' ||
      _conf instanceof HTMLElement
    )
      _conf = {
        renderers: [_conf]
      };
    else if (Object.prototype.toString.call(_conf) === '[object Array]')
      _conf = {
        renderers: _conf
      };

    // Also check "renderer" and "container" keys:
    o = _conf.renderers || _conf.renderer || _conf.container;
    if (!_conf.renderers || _conf.renderers.length === 0)
      if (
        typeof o === 'string' ||
        o instanceof HTMLElement ||
        (typeof o === 'object' && 'container' in o)
      )
        _conf.renderers = [o];

    // Recense the instance:
    if (_conf.id) {
      if (__instances[_conf.id])
        throw 'sigma: Instance "' + _conf.id + '" already exists.';
      Object.defineProperty(this, 'id', {
        value: _conf.id
      });
    } else {
      id = 0;
      while (__instances[id])
        id++;
      Object.defineProperty(this, 'id', {
        value: '' + id
      });
    }
    __instances[this.id] = this;

    // Initialize settings function:
    this.settings = new sigma.classes.configurable(
      sigma.settings,
      _conf.settings || {}
    );

    // Initialize locked attributes:
    Object.defineProperty(this, 'graph', {
      value: new sigma.classes.graph(this.settings),
      configurable: true
    });
    Object.defineProperty(this, 'middlewares', {
      value: [],
      configurable: true
    });
    Object.defineProperty(this, 'cameras', {
      value: {},
      configurable: true
    });
    Object.defineProperty(this, 'renderers', {
      value: {},
      configurable: true
    });
    Object.defineProperty(this, 'renderersPerCamera', {
      value: {},
      configurable: true
    });
    Object.defineProperty(this, 'cameraFrames', {
      value: {},
      configurable: true
    });
    Object.defineProperty(this, 'camera', {
      get: function() {
        return this.cameras[0];
      }
    });
    Object.defineProperty(this, 'events', {
      value: [
        'click',
        'rightClick',
        'clickStage',
        'doubleClickStage',
        'rightClickStage',
        'clickNode',
        'clickNodes',
        'doubleClickNode',
        'doubleClickNodes',
        'rightClickNode',
        'rightClickNodes',
        'overNode',
        'overNodes',
        'outNode',
        'outNodes',
        'downNode',
        'downNodes',
        'upNode',
        'upNodes'
      ],
      configurable: true
    });

    // Add a custom handler, to redispatch events from renderers:
    this._handler = (function(e) {
      var k,
          data = {};

      for (k in e.data)
        data[k] = e.data[k];

      data.renderer = e.target;
      this.dispatchEvent(e.type, data);
    }).bind(this);

    // Initialize renderers:
    a = _conf.renderers || [];
    for (i = 0, l = a.length; i < l; i++)
      this.addRenderer(a[i]);

    // Initialize middlewares:
    a = _conf.middlewares || [];
    for (i = 0, l = a.length; i < l; i++)
      this.middlewares.push(
        typeof a[i] === 'string' ?
          sigma.middlewares[a[i]] :
          a[i]
      );

    // Check if there is already a graph to fill in:
    if (typeof _conf.graph === 'object' && _conf.graph) {
      this.graph.read(_conf.graph);

      // If a graph is given to the to the instance, the "refresh" method is
      // directly called:
      this.refresh();
    }

    // Deal with resize:
    window.addEventListener('resize', function() {
      if (_self.settings)
        _self.refresh();
    });
  };




  /**
   * This methods will instantiate and reference a new camera. If no id is
   * specified, then an automatic id will be generated.
   *
   * @param  {?string}              id Eventually the camera id.
   * @return {sigma.classes.camera}    The fresh new camera instance.
   */
  sigma.prototype.addCamera = function(id) {
    var self = this,
        camera;

    if (!arguments.length) {
      id = 0;
      while (this.cameras['' + id])
        id++;
      id = '' + id;
    }

    if (this.cameras[id])
      throw 'sigma.addCamera: The camera "' + id + '" already exists.';

    camera = new sigma.classes.camera(id, this.graph, this.settings);
    this.cameras[id] = camera;

    // Add a quadtree to the camera:
    camera.quadtree = new sigma.classes.quad();

    // Add an edgequadtree to the camera:
    if (sigma.classes.edgequad !== undefined) {
      camera.edgequadtree = new sigma.classes.edgequad();
    }

    camera.bind('coordinatesUpdated', function(e) {
      self.renderCamera(camera, camera.isAnimated);
    });

    this.renderersPerCamera[id] = [];

    return camera;
  };

  /**
   * This method kills a camera, and every renderer attached to it.
   *
   * @param  {string|camera} v The camera to kill or its ID.
   * @return {sigma}           Returns the instance.
   */
  sigma.prototype.killCamera = function(v) {
    v = typeof v === 'string' ? this.cameras[v] : v;

    if (!v)
      throw 'sigma.killCamera: The camera is undefined.';

    var i,
        l,
        a = this.renderersPerCamera[v.id];

    for (l = a.length, i = l - 1; i >= 0; i--)
      this.killRenderer(a[i]);

    delete this.renderersPerCamera[v.id];
    delete this.cameraFrames[v.id];
    delete this.cameras[v.id];

    if (v.kill)
      v.kill();

    return this;
  };

  /**
   * This methods will instantiate and reference a new renderer. The "type"
   * argument can be the constructor or its name in the "sigma.renderers"
   * package. If no type is specified, then "sigma.renderers.def" will be used.
   * If no id is specified, then an automatic id will be generated.
   *
   * @param  {?object}  options Eventually some options to give to the renderer
   *                            constructor.
   * @return {renderer}         The fresh new renderer instance.
   *
   * Recognized parameters:
   * **********************
   * Here is the exhaustive list of every accepted parameters in the "options"
   * object:
   *
   *   {?string}            id     Eventually the renderer id.
   *   {?(function|string)} type   Eventually the renderer constructor or its
   *                               name in the "sigma.renderers" package.
   *   {?(camera|string)}   camera Eventually the renderer camera or its
   *                               id.
   */
  sigma.prototype.addRenderer = function(options) {
    var id,
        fn,
        camera,
        renderer,
        o = options || {};

    // Polymorphism:
    if (typeof o === 'string')
      o = {
        container: document.getElementById(o)
      };
    else if (o instanceof HTMLElement)
      o = {
        container: o
      };

    // If the container still is a string, we get it by id
    if (typeof o.container === 'string')
      o.container = document.getElementById(o.container);

    // Reference the new renderer:
    if (!('id' in o)) {
      id = 0;
      while (this.renderers['' + id])
        id++;
      id = '' + id;
    } else
      id = o.id;

    if (this.renderers[id])
      throw 'sigma.addRenderer: The renderer "' + id + '" already exists.';

    // Find the good constructor:
    fn = typeof o.type === 'function' ? o.type : sigma.renderers[o.type];
    fn = fn || sigma.renderers.def;

    // Find the good camera:
    camera = 'camera' in o ?
      (
        o.camera instanceof sigma.classes.camera ?
          o.camera :
          this.cameras[o.camera] || this.addCamera(o.camera)
      ) :
      this.addCamera();

    if (this.cameras[camera.id] !== camera)
      throw 'sigma.addRenderer: The camera is not properly referenced.';

    // Instantiate:
    renderer = new fn(this.graph, camera, this.settings, o);
    this.renderers[id] = renderer;
    Object.defineProperty(renderer, 'id', {
      value: id
    });

    // Bind events:
    if (renderer.bind)
      renderer.bind(
        [
          'click',
          'rightClick',
          'clickStage',
          'doubleClickStage',
          'rightClickStage',
          'clickNode',
          'clickNodes',
          'clickEdge',
          'clickEdges',
          'doubleClickNode',
          'doubleClickNodes',
          'doubleClickEdge',
          'doubleClickEdges',
          'rightClickNode',
          'rightClickNodes',
          'rightClickEdge',
          'rightClickEdges',
          'overNode',
          'overNodes',
          'overEdge',
          'overEdges',
          'outNode',
          'outNodes',
          'outEdge',
          'outEdges',
          'downNode',
          'downNodes',
          'downEdge',
          'downEdges',
          'upNode',
          'upNodes',
          'upEdge',
          'upEdges'
        ],
        this._handler
      );

    // Reference the renderer by its camera:
    this.renderersPerCamera[camera.id].push(renderer);

    return renderer;
  };

  /**
   * This method kills a renderer.
   *
   * @param  {string|renderer} v The renderer to kill or its ID.
   * @return {sigma}             Returns the instance.
   */
  sigma.prototype.killRenderer = function(v) {
    v = typeof v === 'string' ? this.renderers[v] : v;

    if (!v)
      throw 'sigma.killRenderer: The renderer is undefined.';

    var a = this.renderersPerCamera[v.camera.id],
        i = a.indexOf(v);

    if (i >= 0)
      a.splice(i, 1);

    if (v.kill)
      v.kill();

    delete this.renderers[v.id];

    return this;
  };




  /**
   * This method calls the "render" method of each renderer, with the same
   * arguments than the "render" method, but will also check if the renderer
   * has a "process" method, and call it if it exists.
   *
   * It is useful for quadtrees or WebGL processing, for instance.
   *
   * @param  {?object}  options Eventually some options to give to the refresh
   *                            method.
   * @return {sigma}            Returns the instance itself.
   *
   * Recognized parameters:
   * **********************
   * Here is the exhaustive list of every accepted parameters in the "options"
   * object:
   *
   *   {?boolean} skipIndexation A flag specifying wether or not the refresh
   *                             function should reindex the graph in the
   *                             quadtrees or not (default: false).
   */
  sigma.prototype.refresh = function(options) {
    var i,
        l,
        k,
        a,
        c,
        bounds,
        prefix = 0;

    options = options || {};

    // Call each middleware:
    a = this.middlewares || [];
    for (i = 0, l = a.length; i < l; i++)
      a[i].call(
        this,
        (i === 0) ? '' : 'tmp' + prefix + ':',
        (i === l - 1) ? 'ready:' : ('tmp' + (++prefix) + ':')
      );

    // Then, for each camera, call the "rescale" middleware, unless the
    // settings specify not to:
    for (k in this.cameras) {
      c = this.cameras[k];
      if (
        c.settings('autoRescale') &&
        this.renderersPerCamera[c.id] &&
        this.renderersPerCamera[c.id].length
      )
        sigma.middlewares.rescale.call(
          this,
          a.length ? 'ready:' : '',
          c.readPrefix,
          {
            width: this.renderersPerCamera[c.id][0].width,
            height: this.renderersPerCamera[c.id][0].height
          }
        );
      else
        sigma.middlewares.copy.call(
          this,
          a.length ? 'ready:' : '',
          c.readPrefix
        );

      if (!options.skipIndexation) {
        // Find graph boundaries:
        bounds = sigma.utils.getBoundaries(
          this.graph,
          c.readPrefix
        );

        // Refresh quadtree:
        c.quadtree.index(this.graph.nodes(), {
          prefix: c.readPrefix,
          bounds: {
            x: bounds.minX,
            y: bounds.minY,
            width: bounds.maxX - bounds.minX,
            height: bounds.maxY - bounds.minY
          }
        });

        // Refresh edgequadtree:
        if (
          c.edgequadtree !== undefined &&
          c.settings('drawEdges') &&
          c.settings('enableEdgeHovering')
        ) {
          c.edgequadtree.index(this.graph, {
            prefix: c.readPrefix,
            bounds: {
              x: bounds.minX,
              y: bounds.minY,
              width: bounds.maxX - bounds.minX,
              height: bounds.maxY - bounds.minY
            }
          });
        }
      }
    }

    // Call each renderer:
    a = Object.keys(this.renderers);
    for (i = 0, l = a.length; i < l; i++)
      if (this.renderers[a[i]].process) {
        if (this.settings('skipErrors'))
          try {
            this.renderers[a[i]].process();
          } catch (e) {
            console.log(
              'Warning: The renderer "' + a[i] + '" crashed on ".process()"'
            );
          }
        else
          this.renderers[a[i]].process();
      }

    this.render();

    return this;
  };

  /**
   * This method calls the "render" method of each renderer.
   *
   * @return {sigma} Returns the instance itself.
   */
  sigma.prototype.render = function() {
    var i,
        l,
        a,
        prefix = 0;

    // Call each renderer:
    a = Object.keys(this.renderers);
    for (i = 0, l = a.length; i < l; i++)
      if (this.settings('skipErrors'))
        try {
          this.renderers[a[i]].render();
        } catch (e) {
          if (this.settings('verbose'))
            console.log(
              'Warning: The renderer "' + a[i] + '" crashed on ".render()"'
            );
        }
      else
        this.renderers[a[i]].render();

    return this;
  };

  /**
   * This method calls the "render" method of each renderer that is bound to
   * the specified camera. To improve the performances, if this method is
   * called too often, the number of effective renderings is limitated to one
   * per frame, unless you are using the "force" flag.
   *
   * @param  {sigma.classes.camera} camera The camera to render.
   * @param  {?boolean}             force  If true, will render the camera
   *                                       directly.
   * @return {sigma}                       Returns the instance itself.
   */
  sigma.prototype.renderCamera = function(camera, force) {
    var i,
        l,
        a,
        self = this;

    if (force) {
      a = this.renderersPerCamera[camera.id];
      for (i = 0, l = a.length; i < l; i++)
        if (this.settings('skipErrors'))
          try {
            a[i].render();
          } catch (e) {
            if (this.settings('verbose'))
              console.log(
                'Warning: The renderer "' + a[i].id + '" crashed on ".render()"'
              );
          }
        else
          a[i].render();
    } else {
      if (!this.cameraFrames[camera.id]) {
        a = this.renderersPerCamera[camera.id];
        for (i = 0, l = a.length; i < l; i++)
          if (this.settings('skipErrors'))
            try {
              a[i].render();
            } catch (e) {
              if (this.settings('verbose'))
                console.log(
                  'Warning: The renderer "' +
                    a[i].id +
                    '" crashed on ".render()"'
                );
            }
          else
            a[i].render();

        this.cameraFrames[camera.id] = requestAnimationFrame(function() {
          delete self.cameraFrames[camera.id];
        });
      }
    }

    return this;
  };

  /**
   * This method calls the "kill" method of each module and destroys any
   * reference from the instance.
   */
  sigma.prototype.kill = function() {
    var k;

    // Dispatching event
    this.dispatchEvent('kill');

    // Kill graph:
    this.graph.kill();

    // Kill middlewares:
    delete this.middlewares;

    // Kill each renderer:
    for (k in this.renderers)
      this.killRenderer(this.renderers[k]);

    // Kill each camera:
    for (k in this.cameras)
      this.killCamera(this.cameras[k]);

    delete this.renderers;
    delete this.cameras;

    // Kill everything else:
    for (k in this)
      if (this.hasOwnProperty(k))
        delete this[k];

    delete __instances[this.id];
  };




  /**
   * Returns a clone of the instances object or a specific running instance.
   *
   * @param  {?string} id Eventually an instance ID.
   * @return {object}     The related instance or a clone of the instances
   *                      object.
   */
  sigma.instances = function(id) {
    return arguments.length ?
      __instances[id] :
      sigma.utils.extend({}, __instances);
  };



  /**
   * The current version of sigma:
   */
  sigma.version = '1.2.1';




  /**
   * EXPORT:
   * *******
   */
  if (typeof this.sigma !== 'undefined')
    throw 'An object called sigma is already in the global scope.';

  this.sigma = sigma;

}).call(this);

/**
 * conrad.js is a tiny JavaScript jobs scheduler,
 *
 * Version: 0.1.0
 * Sources: http://github.com/jacomyal/conrad.js
 * Doc:     http://github.com/jacomyal/conrad.js#readme
 *
 * License:
 * --------
 * Copyright Â© 2013 Alexis Jacomy, Sciences-Po mÃ©dialab
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * The Software is provided "as is", without warranty of any kind, express or
 * implied, including but not limited to the warranties of merchantability,
 * fitness for a particular purpose and noninfringement. In no event shall the
 * authors or copyright holders be liable for any claim, damages or other
 * liability, whether in an action of contract, tort or otherwise, arising
 * from, out of or in connection with the software or the use or other dealings
 * in the Software.
 */
(function(global) {
  'use strict';

  // Check that conrad.js has not been loaded yet:
  if (global.conrad)
    throw new Error('conrad already exists');


  /**
   * PRIVATE VARIABLES:
   * ******************
   */

  /**
   * A flag indicating whether conrad is running or not.
   *
   * @type {Number}
   */
  var _lastFrameTime;

  /**
   * A flag indicating whether conrad is running or not.
   *
   * @type {Boolean}
   */
  var _isRunning = false;

  /**
   * The hash of registered jobs. Each job must at least have a unique ID
   * under the key "id" and a function under the key "job". This hash
   * contains each running job and each waiting job.
   *
   * @type {Object}
   */
  var _jobs = {};

  /**
   * The hash of currently running jobs.
   *
   * @type {Object}
   */
  var _runningJobs = {};

  /**
   * The array of currently running jobs, sorted by priority.
   *
   * @type {Array}
   */
  var _sortedByPriorityJobs = [];

  /**
   * The array of currently waiting jobs.
   *
   * @type {Object}
   */
  var _waitingJobs = {};

  /**
   * The array of finished jobs. They are stored in an array, since two jobs
   * with the same "id" can happen at two different times.
   *
   * @type {Array}
   */
  var _doneJobs = [];

  /**
   * A dirty flag to keep conrad from starting: Indeed, when addJob() is called
   * with several jobs, conrad must be started only at the end. This flag keeps
   * me from duplicating the code that effectively adds a job.
   *
   * @type {Boolean}
   */
  var _noStart = false;

  /**
   * An hash containing some global settings about how conrad.js should
   * behave.
   *
   * @type {Object}
   */
  var _parameters = {
    frameDuration: 20,
    history: true
  };

  /**
   * This object contains every handlers bound to conrad events. It does not
   * requirea any DOM implementation, since the events are all JavaScript.
   *
   * @type {Object}
   */
  var _handlers = Object.create(null);


  /**
   * PRIVATE FUNCTIONS:
   * ******************
   */

  /**
   * Will execute the handler everytime that the indicated event (or the
   * indicated events) will be triggered.
   *
   * @param  {string|array|object} events  The name of the event (or the events
   *                                       separated by spaces).
   * @param  {function(Object)}    handler The handler to bind.
   * @return {Object}                      Returns conrad.
   */
  function _bind(events, handler) {
    var i,
        i_end,
        event,
        eArray;

    if (!arguments.length)
      return;
    else if (
      arguments.length === 1 &&
      Object(arguments[0]) === arguments[0]
    )
      for (events in arguments[0])
        _bind(events, arguments[0][events]);
    else if (arguments.length > 1) {
      eArray =
        Array.isArray(events) ?
          events :
          events.split(/ /);

      for (i = 0, i_end = eArray.length; i !== i_end; i += 1) {
        event = eArray[i];

        if (!_handlers[event])
          _handlers[event] = [];

        // Using an object instead of directly the handler will make possible
        // later to add flags
        _handlers[event].push({
          handler: handler
        });
      }
    }
  }

  /**
   * Removes the handler from a specified event (or specified events).
   *
   * @param  {?string}           events  The name of the event (or the events
   *                                     separated by spaces). If undefined,
   *                                     then all handlers are removed.
   * @param  {?function(Object)} handler The handler to unbind. If undefined,
   *                                     each handler bound to the event or the
   *                                     events will be removed.
   * @return {Object}            Returns conrad.
   */
  function _unbind(events, handler) {
    var i,
        i_end,
        j,
        j_end,
        a,
        event,
        eArray = Array.isArray(events) ?
                   events :
                   events.split(/ /);

    if (!arguments.length)
      _handlers = Object.create(null);
    else if (handler) {
      for (i = 0, i_end = eArray.length; i !== i_end; i += 1) {
        event = eArray[i];
        if (_handlers[event]) {
          a = [];
          for (j = 0, j_end = _handlers[event].length; j !== j_end; j += 1)
            if (_handlers[event][j].handler !== handler)
              a.push(_handlers[event][j]);

          _handlers[event] = a;
        }

        if (_handlers[event] && _handlers[event].length === 0)
          delete _handlers[event];
      }
    } else
      for (i = 0, i_end = eArray.length; i !== i_end; i += 1)
        delete _handlers[eArray[i]];
  }

  /**
   * Executes each handler bound to the event.
   *
   * @param  {string}  events The name of the event (or the events separated
   *                          by spaces).
   * @param  {?Object} data   The content of the event (optional).
   * @return {Object}         Returns conrad.
   */
  function _dispatch(events, data) {
    var i,
        j,
        i_end,
        j_end,
        event,
        eventName,
        eArray = Array.isArray(events) ?
                   events :
                   events.split(/ /);

    data = data === undefined ? {} : data;

    for (i = 0, i_end = eArray.length; i !== i_end; i += 1) {
      eventName = eArray[i];

      if (_handlers[eventName]) {
        event = {
          type: eventName,
          data: data || {}
        };

        for (j = 0, j_end = _handlers[eventName].length; j !== j_end; j += 1)
          try {
            _handlers[eventName][j].handler(event);
          } catch (e) {}
      }
    }
  }

  /**
   * Executes the most prioritary job once, and deals with filling the stats
   * (done, time, averageTime, currentTime, etc...).
   *
   * @return {?Object} Returns the job object if it has to be killed, null else.
   */
  function _executeFirstJob() {
    var i,
        l,
        test,
        kill,
        pushed = false,
        time = __dateNow(),
        job = _sortedByPriorityJobs.shift();

    // Execute the job and look at the result:
    test = job.job();

    // Deal with stats:
    time = __dateNow() - time;
    job.done++;
    job.time += time;
    job.currentTime += time;
    job.weightTime = job.currentTime / (job.weight || 1);
    job.averageTime = job.time / job.done;

    // Check if the job has to be killed:
    kill = job.count ? (job.count <= job.done) : !test;

    // Reset priorities:
    if (!kill) {
      for (i = 0, l = _sortedByPriorityJobs.length; i < l; i++)
        if (_sortedByPriorityJobs[i].weightTime > job.weightTime) {
          _sortedByPriorityJobs.splice(i, 0, job);
          pushed = true;
          break;
        }

      if (!pushed)
        _sortedByPriorityJobs.push(job);
    }

    return kill ? job : null;
  }

  /**
   * Activates a job, by adding it to the _runningJobs object and the
   * _sortedByPriorityJobs array. It also initializes its currentTime value.
   *
   * @param  {Object} job The job to activate.
   */
  function _activateJob(job) {
    var l = _sortedByPriorityJobs.length;

    // Add the job to the running jobs:
    _runningJobs[job.id] = job;
    job.status = 'running';

    // Add the job to the priorities:
    if (l) {
      job.weightTime = _sortedByPriorityJobs[l - 1].weightTime;
      job.currentTime = job.weightTime * (job.weight || 1);
    }

    // Initialize the job and dispatch:
    job.startTime = __dateNow();
    _dispatch('jobStarted', __clone(job));

    _sortedByPriorityJobs.push(job);
  }

  /**
   * The main loop of conrad.js:
   *  . It executes job such that they all occupate the same processing time.
   *  . It stops jobs that do not need to be executed anymore.
   *  . It triggers callbacks when it is relevant.
   *  . It starts waiting jobs when they need to be started.
   *  . It injects frames to keep a constant frapes per second ratio.
   *  . It stops itself when there are no more jobs to execute.
   */
  function _loop() {
    var k,
        o,
        l,
        job,
        time,
        deadJob;

    // Deal with the newly added jobs (the _jobs object):
    for (k in _jobs) {
      job = _jobs[k];

      if (job.after)
        _waitingJobs[k] = job;
      else
        _activateJob(job);

      delete _jobs[k];
    }

    // Set the _isRunning flag to false if there are no running job:
    _isRunning = !!_sortedByPriorityJobs.length;

    // Deal with the running jobs (the _runningJobs object):
    while (
      _sortedByPriorityJobs.length &&
      __dateNow() - _lastFrameTime < _parameters.frameDuration
    ) {
      deadJob = _executeFirstJob();

      // Deal with the case where the job has ended:
      if (deadJob) {
        _killJob(deadJob.id);

        // Check for waiting jobs:
        for (k in _waitingJobs)
          if (_waitingJobs[k].after === deadJob.id) {
            _activateJob(_waitingJobs[k]);
            delete _waitingJobs[k];
          }
      }
    }

    // Check if conrad still has jobs to deal with, and kill it if not:
    if (_isRunning) {
      // Update the _lastFrameTime:
      _lastFrameTime = __dateNow();

      _dispatch('enterFrame');
      setTimeout(_loop, 0);
    } else
      _dispatch('stop');
  }

  /**
   * Adds one or more jobs, and starts the loop if no job was running before. A
   * job is at least a unique string "id" and a function, and there are some
   * parameters that you can specify for each job to modify the way conrad will
   * execute it. If a job is added with the "id" of another job that is waiting
   * or still running, an error will be thrown.
   *
   * When a job is added, it is referenced in the _jobs object, by its id.
   * Then, if it has to be executed right now, it will be also referenced in
   * the _runningJobs object. If it has to wait, then it will be added into the
   * _waitingJobs object, until it can start.
   *
   * Keep reading this documentation to see how to call this method.
   *
   * @return {Object} Returns conrad.
   *
   * Adding one job:
   * ***************
   * Basically, a job is defined by its string id and a function (the job). It
   * is also possible to add some parameters:
   *
   *  > conrad.addJob('myJobId', myJobFunction);
   *  > conrad.addJob('myJobId', {
   *  >   job: myJobFunction,
   *  >   someParameter: someValue
   *  > });
   *  > conrad.addJob({
   *  >   id: 'myJobId',
   *  >   job: myJobFunction,
   *  >   someParameter: someValue
   *  > });
   *
   * Adding several jobs:
   * ********************
   * When adding several jobs at the same time, it is possible to specify
   * parameters for each one individually or for all:
   *
   *  > conrad.addJob([
   *  >   {
   *  >     id: 'myJobId1',
   *  >     job: myJobFunction1,
   *  >     someParameter1: someValue1
   *  >   },
   *  >   {
   *  >     id: 'myJobId2',
   *  >     job: myJobFunction2,
   *  >     someParameter2: someValue2
   *  >   }
   *  > ], {
   *  >   someCommonParameter: someCommonValue
   *  > });
   *  > conrad.addJob({
   *  >   myJobId1: {,
   *  >     job: myJobFunction1,
   *  >     someParameter1: someValue1
   *  >   },
   *  >   myJobId2: {,
   *  >     job: myJobFunction2,
   *  >     someParameter2: someValue2
   *  >   }
   *  > }, {
   *  >   someCommonParameter: someCommonValue
   *  > });
   *  > conrad.addJob({
   *  >   myJobId1: myJobFunction1,
   *  >   myJobId2: myJobFunction2
   *  > }, {
   *  >   someCommonParameter: someCommonValue
   *  > });
   *
   *  Recognized parameters:
   *  **********************
   *  Here is the exhaustive list of every accepted parameters:
   *
   *    {?Function} end      A callback to execute when the job is ended. It is
   *                         not executed if the job is killed instead of ended
   *                         "naturally".
   *    {?Integer}  count    The number of time the job has to be executed.
   *    {?Number}   weight   If specified, the job will be executed as it was
   *                         added "weight" times.
   *    {?String}   after    The id of another job (eventually not added yet).
   *                         If specified, this job will start only when the
   *                         specified "after" job is ended.
   */
  function _addJob(v1, v2) {
    var i,
        l,
        o;

    // Array of jobs:
    if (Array.isArray(v1)) {
      // Keep conrad to start until the last job is added:
      _noStart = true;

      for (i = 0, l = v1.length; i < l; i++)
        _addJob(v1[i].id, __extend(v1[i], v2));

      _noStart = false;
      if (!_isRunning) {
        // Update the _lastFrameTime:
        _lastFrameTime = __dateNow();

        _dispatch('start');
        _loop();
      }
    } else if (typeof v1 === 'object') {
      // One job (object):
      if (typeof v1.id === 'string')
        _addJob(v1.id, v1);

      // Hash of jobs:
      else {
        // Keep conrad to start until the last job is added:
        _noStart = true;

        for (i in v1)
          if (typeof v1[i] === 'function')
            _addJob(i, __extend({
              job: v1[i]
            }, v2));
          else
            _addJob(i, __extend(v1[i], v2));

        _noStart = false;
        if (!_isRunning) {
          // Update the _lastFrameTime:
          _lastFrameTime = __dateNow();

          _dispatch('start');
          _loop();
        }
      }

    // One job (string, *):
    } else if (typeof v1 === 'string') {
      if (_hasJob(v1))
        throw new Error(
          '[conrad.addJob] Job with id "' + v1 + '" already exists.'
        );

      // One job (string, function):
      if (typeof v2 === 'function') {
        o = {
          id: v1,
          done: 0,
          time: 0,
          status: 'waiting',
          currentTime: 0,
          averageTime: 0,
          weightTime: 0,
          job: v2
        };

      // One job (string, object):
      } else if (typeof v2 === 'object') {
        o = __extend(
          {
            id: v1,
            done: 0,
            time: 0,
            status: 'waiting',
            currentTime: 0,
            averageTime: 0,
            weightTime: 0
          },
          v2
        );

      // If none of those cases, throw an error:
      } else
        throw new Error('[conrad.addJob] Wrong arguments.');

      // Effectively add the job:
      _jobs[v1] = o;
      _dispatch('jobAdded', __clone(o));

      // Check if the loop has to be started:
      if (!_isRunning && !_noStart) {
        // Update the _lastFrameTime:
        _lastFrameTime = __dateNow();

        _dispatch('start');
        _loop();
      }

    // If none of those cases, throw an error:
    } else
      throw new Error('[conrad.addJob] Wrong arguments.');

    return this;
  }

  /**
   * Kills one or more jobs, indicated by their ids. It is only possible to
   * kill running jobs or waiting jobs. If you try to kill a job that does not
   * exist or that is already killed, a warning will be thrown.
   *
   * @param  {Array|String} v1 A string job id or an array of job ids.
   * @return {Object}       Returns conrad.
   */
  function _killJob(v1) {
    var i,
        l,
        k,
        a,
        job,
        found = false;

    // Array of job ids:
    if (Array.isArray(v1))
      for (i = 0, l = v1.length; i < l; i++)
        _killJob(v1[i]);

    // One job's id:
    else if (typeof v1 === 'string') {
      a = [_runningJobs, _waitingJobs, _jobs];

      // Remove the job from the hashes:
      for (i = 0, l = a.length; i < l; i++)
        if (v1 in a[i]) {
          job = a[i][v1];

          if (_parameters.history) {
            job.status = 'done';
            _doneJobs.push(job);
          }

          _dispatch('jobEnded', __clone(job));
          delete a[i][v1];

          if (typeof job.end === 'function')
            job.end();

          found = true;
        }

      // Remove the priorities array:
      a = _sortedByPriorityJobs;
      for (i = 0, l = a.length; i < l; i++)
        if (a[i].id === v1) {
          a.splice(i, 1);
          break;
        }

      if (!found)
        throw new Error('[conrad.killJob] Job "' + v1 + '" not found.');

    // If none of those cases, throw an error:
    } else
      throw new Error('[conrad.killJob] Wrong arguments.');

    return this;
  }

  /**
   * Kills every running, waiting, and just added jobs.
   *
   * @return {Object} Returns conrad.
   */
  function _killAll() {
    var k,
        jobs = __extend(_jobs, _runningJobs, _waitingJobs);

    // Take every jobs and push them into the _doneJobs object:
    if (_parameters.history)
      for (k in jobs) {
        jobs[k].status = 'done';
        _doneJobs.push(jobs[k]);

        if (typeof jobs[k].end === 'function')
          jobs[k].end();
      }

    // Reinitialize the different jobs lists:
    _jobs = {};
    _waitingJobs = {};
    _runningJobs = {};
    _sortedByPriorityJobs = [];

    // In case some jobs are added right after the kill:
    _isRunning = false;

    return this;
  }

  /**
   * Returns true if a job with the specified id is currently running or
   * waiting, and false else.
   *
   * @param  {String}  id The id of the job.
   * @return {?Object} Returns the job object if it exists.
   */
  function _hasJob(id) {
    var job = _jobs[id] || _runningJobs[id] || _waitingJobs[id];
    return job ? __extend(job) : null;
  }

  /**
   * This method will set the setting specified by "v1" to the value specified
   * by "v2" if both are given, and else return the current value of the
   * settings "v1".
   *
   * @param  {String}   v1 The name of the property.
   * @param  {?*}       v2 Eventually, a value to set to the specified
   *                       property.
   * @return {Object|*} Returns the specified settings value if "v2" is not
   *                    given, and conrad else.
   */
  function _settings(v1, v2) {
    var o;

    if (typeof a1 === 'string' && arguments.length === 1)
      return _parameters[a1];
    else {
      o = (typeof a1 === 'object' && arguments.length === 1) ?
        a1 || {} :
        {};
      if (typeof a1 === 'string')
        o[a1] = a2;

      for (var k in o)
        if (o[k] !== undefined)
          _parameters[k] = o[k];
        else
          delete _parameters[k];

      return this;
    }
  }

  /**
   * Returns true if conrad is currently running, and false else.
   *
   * @return {Boolean} Returns _isRunning.
   */
  function _getIsRunning() {
    return _isRunning;
  }

  /**
   * Unreference every job that is stored in the _doneJobs object. It will
   * not be possible anymore to get stats about these jobs, but it will release
   * the memory.
   *
   * @return {Object} Returns conrad.
   */
  function _clearHistory() {
    _doneJobs = [];
    return this;
  }

  /**
   * Returns a snapshot of every data about jobs that wait to be started, are
   * currently running or are done.
   *
   * It is possible to get only running, waiting or done jobs by giving
   * "running", "waiting" or "done" as fist argument.
   *
   * It is also possible to get every job with a specified id by giving it as
   * first argument. Also, using a RegExp instead of an id will return every
   * jobs whose ids match the RegExp. And these two last use cases work as well
   * by giving before "running", "waiting" or "done".
   *
   * @return {Array} The array of the matching jobs.
   *
   * Some call examples:
   * *******************
   *  > conrad.getStats('running')
   *  > conrad.getStats('waiting')
   *  > conrad.getStats('done')
   *  > conrad.getStats('myJob')
   *  > conrad.getStats(/test/)
   *  > conrad.getStats('running', 'myRunningJob')
   *  > conrad.getStats('running', /test/)
   */
  function _getStats(v1, v2) {
    var a,
        k,
        i,
        l,
        stats,
        pattern,
        isPatternString;

    if (!arguments.length) {
      stats = [];

      for (k in _jobs)
        stats.push(_jobs[k]);

      for (k in _waitingJobs)
        stats.push(_waitingJobs[k]);

      for (k in _runningJobs)
        stats.push(_runningJobs[k]);

      stats = stats.concat(_doneJobs);
    }

    if (typeof v1 === 'string')
      switch (v1) {
        case 'waiting':
          stats = __objectValues(_waitingJobs);
          break;
        case 'running':
          stats = __objectValues(_runningJobs);
          break;
        case 'done':
          stats = _doneJobs;
          break;
        default:
          pattern = v1;
      }

    if (v1 instanceof RegExp)
      pattern = v1;

    if (!pattern && (typeof v2 === 'string' || v2 instanceof RegExp))
      pattern = v2;

    // Filter jobs if a pattern is given:
    if (pattern) {
      isPatternString = typeof pattern === 'string';

      if (stats instanceof Array) {
        a = stats;
      } else if (typeof stats === 'object') {
        a = [];

        for (k in stats)
          a = a.concat(stats[k]);
      } else {
        a = [];

        for (k in _jobs)
          a.push(_jobs[k]);

        for (k in _waitingJobs)
          a.push(_waitingJobs[k]);

        for (k in _runningJobs)
          a.push(_runningJobs[k]);

        a = a.concat(_doneJobs);
      }

      stats = [];
      for (i = 0, l = a.length; i < l; i++)
        if (isPatternString ? a[i].id === pattern : a[i].id.match(pattern))
          stats.push(a[i]);
    }

    return __clone(stats);
  }


  /**
   * TOOLS FUNCTIONS:
   * ****************
   */

  /**
   * This function takes any number of objects as arguments, copies from each
   * of these objects each pair key/value into a new object, and finally
   * returns this object.
   *
   * The arguments are parsed from the last one to the first one, such that
   * when two objects have keys in common, the "earliest" object wins.
   *
   * Example:
   * ********
   *  > var o1 = {
   *  >       a: 1,
   *  >       b: 2,
   *  >       c: '3'
   *  >     },
   *  >     o2 = {
   *  >       c: '4',
   *  >       d: [ 5 ]
   *  >     };
   *  > __extend(o1, o2);
   *  > // Returns: {
   *  > //   a: 1,
   *  > //   b: 2,
   *  > //   c: '3',
   *  > //   d: [ 5 ]
   *  > // };
   *
   * @param  {Object+} Any number of objects.
   * @return {Object}  The merged object.
   */
  function __extend() {
    var i,
        k,
        res = {},
        l = arguments.length;

    for (i = l - 1; i >= 0; i--)
      for (k in arguments[i])
        res[k] = arguments[i][k];

    return res;
  }

  /**
   * This function simply clones an object. This object must contain only
   * objects, arrays and immutable values. Since it is not public, it does not
   * deal with cyclic references, DOM elements and instantiated objects - so
   * use it carefully.
   *
   * @param  {Object} The object to clone.
   * @return {Object} The clone.
   */
  function __clone(item) {
    var result, i, k, l;

    if (!item)
      return item;

    if (Array.isArray(item)) {
      result = [];
      for (i = 0, l = item.length; i < l; i++)
        result.push(__clone(item[i]));
    } else if (typeof item === 'object') {
      result = {};
      for (i in item)
        result[i] = __clone(item[i]);
    } else
      result = item;

    return result;
  }

  /**
   * Returns an array containing the values of an object.
   *
   * @param  {Object} The object.
   * @return {Array}  The array of values.
   */
  function __objectValues(o) {
    var k,
        a = [];

    for (k in o)
      a.push(o[k]);

    return a;
  }

  /**
   * A short "Date.now()" polyfill.
   *
   * @return {Number} The current time (in ms).
   */
  function __dateNow() {
    return Date.now ? Date.now() : new Date().getTime();
  }

  /**
   * Polyfill for the Array.isArray function:
   */
  if (!Array.isArray)
    Array.isArray = function(v) {
      return Object.prototype.toString.call(v) === '[object Array]';
    };


  /**
   * EXPORT PUBLIC API:
   * ******************
   */
  var conrad = {
    hasJob: _hasJob,
    addJob: _addJob,
    killJob: _killJob,
    killAll: _killAll,
    settings: _settings,
    getStats: _getStats,
    isRunning: _getIsRunning,
    clearHistory: _clearHistory,

    // Events management:
    bind: _bind,
    unbind: _unbind,

    // Version:
    version: '0.1.0'
  };

  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports)
      exports = module.exports = conrad;
    exports.conrad = conrad;
  }
  global.conrad = conrad;
})(this);

// Hardcoded export for the node.js version:
var sigma = this.sigma,
    conrad = this.conrad;

sigma.conrad = conrad;

// Dirty polyfills to permit sigma usage in node
if (typeof HTMLElement === 'undefined')
  HTMLElement = function() {};

if (typeof window === 'undefined')
  window = {
    addEventListener: function() {}
  };

if (typeof exports !== 'undefined') {
  if (typeof module !== 'undefined' && module.exports)
    exports = module.exports = sigma;
  exports.sigma = sigma;
}

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  var _root = this;

  // Initialize packages:
  sigma.utils = sigma.utils || {};

  /**
   * MISC UTILS:
   */
  /**
   * This function takes any number of objects as arguments, copies from each
   * of these objects each pair key/value into a new object, and finally
   * returns this object.
   *
   * The arguments are parsed from the last one to the first one, such that
   * when several objects have keys in common, the "earliest" object wins.
   *
   * Example:
   * ********
   *  > var o1 = {
   *  >       a: 1,
   *  >       b: 2,
   *  >       c: '3'
   *  >     },
   *  >     o2 = {
   *  >       c: '4',
   *  >       d: [ 5 ]
   *  >     };
   *  > sigma.utils.extend(o1, o2);
   *  > // Returns: {
   *  > //   a: 1,
   *  > //   b: 2,
   *  > //   c: '3',
   *  > //   d: [ 5 ]
   *  > // };
   *
   * @param  {object+} Any number of objects.
   * @return {object}  The merged object.
   */
  sigma.utils.extend = function() {
    var i,
        k,
        res = {},
        l = arguments.length;

    for (i = l - 1; i >= 0; i--)
      for (k in arguments[i])
        res[k] = arguments[i][k];

    return res;
  };

  /**
   * A short "Date.now()" polyfill.
   *
   * @return {Number} The current time (in ms).
   */
  sigma.utils.dateNow = function() {
    return Date.now ? Date.now() : new Date().getTime();
  };

  /**
   * Takes a package name as parameter and checks at each lebel if it exists,
   * and if it does not, creates it.
   *
   * Example:
   * ********
   *  > sigma.utils.pkg('a.b.c');
   *  > a.b.c;
   *  > // Object {};
   *  >
   *  > sigma.utils.pkg('a.b.d');
   *  > a.b;
   *  > // Object { c: {}, d: {} };
   *
   * @param  {string} pkgName The name of the package to create/find.
   * @return {object}         The related package.
   */
  sigma.utils.pkg = function(pkgName) {
    return (pkgName || '').split('.').reduce(function(context, objName) {
      return (objName in context) ?
        context[objName] :
        (context[objName] = {});
    }, _root);
  };

  /**
   * Returns a unique incremental number ID.
   *
   * Example:
   * ********
   *  > sigma.utils.id();
   *  > // 1;
   *  >
   *  > sigma.utils.id();
   *  > // 2;
   *  >
   *  > sigma.utils.id();
   *  > // 3;
   *
   * @param  {string} pkgName The name of the package to create/find.
   * @return {object}         The related package.
   */
  sigma.utils.id = (function() {
    var i = 0;
    return function() {
      return ++i;
    };
  })();

  /**
   * This function takes an hexa color (for instance "#ffcc00" or "#fc0") or a
   * rgb / rgba color (like "rgb(255,255,12)" or "rgba(255,255,12,1)") and
   * returns an integer equal to "r * 255 * 255 + g * 255 + b", to gain some
   * memory in the data given to WebGL shaders.
   *
   * Note that the function actually caches its results for better performance.
   *
   * @param  {string} val The hexa or rgba color.
   * @return {number}     The number value.
   */
  var floatColorCache = {};

  sigma.utils.floatColor = function(val) {

    // Is the color already computed?
    if (floatColorCache[val])
      return floatColorCache[val];

    var original = val,
        r = 0,
        g = 0,
        b = 0;

    if (val[0] === '#') {
      val = val.slice(1);

      if (val.length === 3) {
        r = parseInt(val.charAt(0) + val.charAt(0), 16);
        g = parseInt(val.charAt(1) + val.charAt(1), 16);
        b = parseInt(val.charAt(2) + val.charAt(2), 16);
      }
      else {
        r = parseInt(val.charAt(0) + val.charAt(1), 16);
        g = parseInt(val.charAt(2) + val.charAt(3), 16);
        b = parseInt(val.charAt(4) + val.charAt(5), 16);
      }
    } else if (val.match(/^ *rgba? *\(/)) {
      val = val.match(
        /^ *rgba? *\( *([0-9]*) *, *([0-9]*) *, *([0-9]*) *(,.*)?\) *$/
      );
      r = +val[1];
      g = +val[2];
      b = +val[3];
    }

    var color = (
      r * 256 * 256 +
      g * 256 +
      b
    );

    // Caching the color
    floatColorCache[original] = color;

    return color;
  };

    /**
   * Perform a zoom into a camera, with or without animation, to the
   * coordinates indicated using a specified ratio.
   *
   * Recognized parameters:
   * **********************
   * Here is the exhaustive list of every accepted parameters in the animation
   * object:
   *
   *   {?number} duration     An amount of time that means the duration of the
   *                          animation. If this parameter doesn't exist the
   *                          zoom will be performed without animation.
   *   {?function} onComplete A function to perform it after the animation. It
   *                          will be performed even if there is no duration.
   *
   * @param {camera}     The camera where perform the zoom.
   * @param {x}          The X coordiantion where the zoom goes.
   * @param {y}          The Y coordiantion where the zoom goes.
   * @param {ratio}      The ratio to apply it to the current camera ratio.
   * @param {?animation} A dictionary with options for a possible animation.
   */
  sigma.utils.zoomTo = function(camera, x, y, ratio, animation) {
    var settings = camera.settings,
        count,
        newRatio,
        animationSettings,
        coordinates;

    // Create the newRatio dealing with min / max:
    newRatio = Math.max(
      settings('zoomMin'),
      Math.min(
        settings('zoomMax'),
        camera.ratio * ratio
      )
    );

    // Check that the new ratio is different from the initial one:
    if (newRatio !== camera.ratio) {
      // Create the coordinates variable:
      ratio = newRatio / camera.ratio;
      coordinates = {
        x: x * (1 - ratio) + camera.x,
        y: y * (1 - ratio) + camera.y,
        ratio: newRatio
      };

      if (animation && animation.duration) {
        // Complete the animation setings:
        count = sigma.misc.animation.killAll(camera);
        animation = sigma.utils.extend(
          animation,
          {
            easing: count ? 'quadraticOut' : 'quadraticInOut'
          }
        );

        sigma.misc.animation.camera(camera, coordinates, animation);
      } else {
        camera.goTo(coordinates);
        if (animation && animation.onComplete)
          animation.onComplete();
      }
    }
  };

  /**
   * Return the control point coordinates for a quadratic bezier curve.
   *
   * @param  {number} x1  The X coordinate of the start point.
   * @param  {number} y1  The Y coordinate of the start point.
   * @param  {number} x2  The X coordinate of the end point.
   * @param  {number} y2  The Y coordinate of the end point.
   * @return {x,y}        The control point coordinates.
   */
  sigma.utils.getQuadraticControlPoint = function(x1, y1, x2, y2) {
    return {
      x: (x1 + x2) / 2 + (y2 - y1) / 4,
      y: (y1 + y2) / 2 + (x1 - x2) / 4
    };
  };

  /**
    * Compute the coordinates of the point positioned
    * at length t in the quadratic bezier curve.
    *
    * @param  {number} t  In [0,1] the step percentage to reach
    *                     the point in the curve from the context point.
    * @param  {number} x1 The X coordinate of the context point.
    * @param  {number} y1 The Y coordinate of the context point.
    * @param  {number} x2 The X coordinate of the ending point.
    * @param  {number} y2 The Y coordinate of the ending point.
    * @param  {number} xi The X coordinate of the control point.
    * @param  {number} yi The Y coordinate of the control point.
    * @return {object}    {x,y}.
  */
  sigma.utils.getPointOnQuadraticCurve = function(t, x1, y1, x2, y2, xi, yi) {
    // http://stackoverflow.com/a/5634528
    return {
      x: Math.pow(1 - t, 2) * x1 + 2 * (1 - t) * t * xi + Math.pow(t, 2) * x2,
      y: Math.pow(1 - t, 2) * y1 + 2 * (1 - t) * t * yi + Math.pow(t, 2) * y2
    };
  };

  /**
    * Compute the coordinates of the point positioned
    * at length t in the cubic bezier curve.
    *
    * @param  {number} t  In [0,1] the step percentage to reach
    *                     the point in the curve from the context point.
    * @param  {number} x1 The X coordinate of the context point.
    * @param  {number} y1 The Y coordinate of the context point.
    * @param  {number} x2 The X coordinate of the end point.
    * @param  {number} y2 The Y coordinate of the end point.
    * @param  {number} cx The X coordinate of the first control point.
    * @param  {number} cy The Y coordinate of the first control point.
    * @param  {number} dx The X coordinate of the second control point.
    * @param  {number} dy The Y coordinate of the second control point.
    * @return {object}    {x,y} The point at t.
  */
  sigma.utils.getPointOnBezierCurve =
    function(t, x1, y1, x2, y2, cx, cy, dx, dy) {
    // http://stackoverflow.com/a/15397596
    // Blending functions:
    var B0_t = Math.pow(1 - t, 3),
        B1_t = 3 * t * Math.pow(1 - t, 2),
        B2_t = 3 * Math.pow(t, 2) * (1 - t),
        B3_t = Math.pow(t, 3);

    return {
      x: (B0_t * x1) + (B1_t * cx) + (B2_t * dx) + (B3_t * x2),
      y: (B0_t * y1) + (B1_t * cy) + (B2_t * dy) + (B3_t * y2)
    };
  };

  /**
   * Return the coordinates of the two control points for a self loop (i.e.
   * where the start point is also the end point) computed as a cubic bezier
   * curve.
   *
   * @param  {number} x    The X coordinate of the node.
   * @param  {number} y    The Y coordinate of the node.
   * @param  {number} size The node size.
   * @return {x1,y1,x2,y2} The coordinates of the two control points.
   */
  sigma.utils.getSelfLoopControlPoints = function(x , y, size) {
    return {
      x1: x - size * 7,
      y1: y,
      x2: x,
      y2: y + size * 7
    };
  };

  /**
   * Return the euclidian distance between two points of a plane
   * with an orthonormal basis.
   *
   * @param  {number} x1  The X coordinate of the first point.
   * @param  {number} y1  The Y coordinate of the first point.
   * @param  {number} x2  The X coordinate of the second point.
   * @param  {number} y2  The Y coordinate of the second point.
   * @return {number}     The euclidian distance.
   */
  sigma.utils.getDistance = function(x0, y0, x1, y1) {
    return Math.sqrt(Math.pow(x1 - x0, 2) + Math.pow(y1 - y0, 2));
  };

  /**
   * Return the coordinates of the intersection points of two circles.
   *
   * @param  {number} x0  The X coordinate of center location of the first
   *                      circle.
   * @param  {number} y0  The Y coordinate of center location of the first
   *                      circle.
   * @param  {number} r0  The radius of the first circle.
   * @param  {number} x1  The X coordinate of center location of the second
   *                      circle.
   * @param  {number} y1  The Y coordinate of center location of the second
   *                      circle.
   * @param  {number} r1  The radius of the second circle.
   * @return {xi,yi}      The coordinates of the intersection points.
   */
  sigma.utils.getCircleIntersection = function(x0, y0, r0, x1, y1, r1) {
    // http://stackoverflow.com/a/12219802
    var a, dx, dy, d, h, rx, ry, x2, y2;

    // dx and dy are the vertical and horizontal distances between the circle
    // centers:
    dx = x1 - x0;
    dy = y1 - y0;

    // Determine the straight-line distance between the centers:
    d = Math.sqrt((dy * dy) + (dx * dx));

    // Check for solvability:
    if (d > (r0 + r1)) {
        // No solution. circles do not intersect.
        return false;
    }
    if (d < Math.abs(r0 - r1)) {
        // No solution. one circle is contained in the other.
        return false;
    }

    //'point 2' is the point where the line through the circle intersection
    // points crosses the line between the circle centers.

    // Determine the distance from point 0 to point 2:
    a = ((r0 * r0) - (r1 * r1) + (d * d)) / (2.0 * d);

    // Determine the coordinates of point 2:
    x2 = x0 + (dx * a / d);
    y2 = y0 + (dy * a / d);

    // Determine the distance from point 2 to either of the intersection
    // points:
    h = Math.sqrt((r0 * r0) - (a * a));

    // Determine the offsets of the intersection points from point 2:
    rx = -dy * (h / d);
    ry = dx * (h / d);

    // Determine the absolute intersection points:
    var xi = x2 + rx;
    var xi_prime = x2 - rx;
    var yi = y2 + ry;
    var yi_prime = y2 - ry;

    return {xi: xi, xi_prime: xi_prime, yi: yi, yi_prime: yi_prime};
  };

  /**
    * Check if a point is on a line segment.
    *
    * @param  {number} x       The X coordinate of the point to check.
    * @param  {number} y       The Y coordinate of the point to check.
    * @param  {number} x1      The X coordinate of the line start point.
    * @param  {number} y1      The Y coordinate of the line start point.
    * @param  {number} x2      The X coordinate of the line end point.
    * @param  {number} y2      The Y coordinate of the line end point.
    * @param  {number} epsilon The precision (consider the line thickness).
    * @return {boolean}        True if point is "close to" the line
    *                          segment, false otherwise.
  */
  sigma.utils.isPointOnSegment = function(x, y, x1, y1, x2, y2, epsilon) {
    // http://stackoverflow.com/a/328122
    var crossProduct = Math.abs((y - y1) * (x2 - x1) - (x - x1) * (y2 - y1)),
        d = sigma.utils.getDistance(x1, y1, x2, y2),
        nCrossProduct = crossProduct / d; // normalized cross product

    return (nCrossProduct < epsilon &&
     Math.min(x1, x2) <= x && x <= Math.max(x1, x2) &&
     Math.min(y1, y2) <= y && y <= Math.max(y1, y2));
  };

  /**
    * Check if a point is on a quadratic bezier curve segment with a thickness.
    *
    * @param  {number} x       The X coordinate of the point to check.
    * @param  {number} y       The Y coordinate of the point to check.
    * @param  {number} x1      The X coordinate of the curve start point.
    * @param  {number} y1      The Y coordinate of the curve start point.
    * @param  {number} x2      The X coordinate of the curve end point.
    * @param  {number} y2      The Y coordinate of the curve end point.
    * @param  {number} cpx     The X coordinate of the curve control point.
    * @param  {number} cpy     The Y coordinate of the curve control point.
    * @param  {number} epsilon The precision (consider the line thickness).
    * @return {boolean}        True if (x,y) is on the curve segment,
    *                          false otherwise.
  */
  sigma.utils.isPointOnQuadraticCurve =
    function(x, y, x1, y1, x2, y2, cpx, cpy, epsilon) {
    // Fails if the point is too far from the extremities of the segment,
    // preventing for more costly computation:
    var dP1P2 = sigma.utils.getDistance(x1, y1, x2, y2);
    if (Math.abs(x - x1) > dP1P2 || Math.abs(y - y1) > dP1P2) {
      return false;
    }

    var dP1 = sigma.utils.getDistance(x, y, x1, y1),
        dP2 = sigma.utils.getDistance(x, y, x2, y2),
        t = 0.5,
        r = (dP1 < dP2) ? -0.01 : 0.01,
        rThreshold = 0.001,
        i = 100,
        pt = sigma.utils.getPointOnQuadraticCurve(t, x1, y1, x2, y2, cpx, cpy),
        dt = sigma.utils.getDistance(x, y, pt.x, pt.y),
        old_dt;

    // This algorithm minimizes the distance from the point to the curve. It
    // find the optimal t value where t=0 is the start point and t=1 is the end
    // point of the curve, starting from t=0.5.
    // It terminates because it runs a maximum of i interations.
    while (i-- > 0 &&
      t >= 0 && t <= 1 &&
      (dt > epsilon) &&
      (r > rThreshold || r < -rThreshold)) {
      old_dt = dt;
      pt = sigma.utils.getPointOnQuadraticCurve(t, x1, y1, x2, y2, cpx, cpy);
      dt = sigma.utils.getDistance(x, y, pt.x, pt.y);

      if (dt > old_dt) {
        // not the right direction:
        // halfstep in the opposite direction
        r = -r / 2;
        t += r;
      }
      else if (t + r < 0 || t + r > 1) {
        // oops, we've gone too far:
        // revert with a halfstep
        r = r / 2;
        dt = old_dt;
      }
      else {
        // progress:
        t += r;
      }
    }

    return dt < epsilon;
  };


  /**
    * Check if a point is on a cubic bezier curve segment with a thickness.
    *
    * @param  {number} x       The X coordinate of the point to check.
    * @param  {number} y       The Y coordinate of the point to check.
    * @param  {number} x1      The X coordinate of the curve start point.
    * @param  {number} y1      The Y coordinate of the curve start point.
    * @param  {number} x2      The X coordinate of the curve end point.
    * @param  {number} y2      The Y coordinate of the curve end point.
    * @param  {number} cpx1    The X coordinate of the 1st curve control point.
    * @param  {number} cpy1    The Y coordinate of the 1st curve control point.
    * @param  {number} cpx2    The X coordinate of the 2nd curve control point.
    * @param  {number} cpy2    The Y coordinate of the 2nd curve control point.
    * @param  {number} epsilon The precision (consider the line thickness).
    * @return {boolean}        True if (x,y) is on the curve segment,
    *                          false otherwise.
  */
  sigma.utils.isPointOnBezierCurve =
    function(x, y, x1, y1, x2, y2, cpx1, cpy1, cpx2, cpy2, epsilon) {
    // Fails if the point is too far from the extremities of the segment,
    // preventing for more costly computation:
    var dP1CP1 = sigma.utils.getDistance(x1, y1, cpx1, cpy1);
    if (Math.abs(x - x1) > dP1CP1 || Math.abs(y - y1) > dP1CP1) {
      return false;
    }

    var dP1 = sigma.utils.getDistance(x, y, x1, y1),
        dP2 = sigma.utils.getDistance(x, y, x2, y2),
        t = 0.5,
        r = (dP1 < dP2) ? -0.01 : 0.01,
        rThreshold = 0.001,
        i = 100,
        pt = sigma.utils.getPointOnBezierCurve(
          t, x1, y1, x2, y2, cpx1, cpy1, cpx2, cpy2),
        dt = sigma.utils.getDistance(x, y, pt.x, pt.y),
        old_dt;

    // This algorithm minimizes the distance from the point to the curve. It
    // find the optimal t value where t=0 is the start point and t=1 is the end
    // point of the curve, starting from t=0.5.
    // It terminates because it runs a maximum of i interations.
    while (i-- > 0 &&
      t >= 0 && t <= 1 &&
      (dt > epsilon) &&
      (r > rThreshold || r < -rThreshold)) {
      old_dt = dt;
      pt = sigma.utils.getPointOnBezierCurve(
        t, x1, y1, x2, y2, cpx1, cpy1, cpx2, cpy2);
      dt = sigma.utils.getDistance(x, y, pt.x, pt.y);

      if (dt > old_dt) {
        // not the right direction:
        // halfstep in the opposite direction
        r = -r / 2;
        t += r;
      }
      else if (t + r < 0 || t + r > 1) {
        // oops, we've gone too far:
        // revert with a halfstep
        r = r / 2;
        dt = old_dt;
      }
      else {
        // progress:
        t += r;
      }
    }

    return dt < epsilon;
  };


  /**
   * ************
   * EVENTS UTILS:
   * ************
   */
  /**
   * Here are some useful functions to unify extraction of the information we
   * need with mouse events and touch events, from different browsers:
   */

  /**
   * Extract the local X position from a mouse or touch event.
   *
   * @param  {event}  e A mouse or touch event.
   * @return {number}   The local X value of the mouse.
   */
  sigma.utils.getX = function(e) {
    return (
      (e.offsetX !== undefined && e.offsetX) ||
      (e.layerX !== undefined && e.layerX) ||
      (e.clientX !== undefined && e.clientX)
    );
  };

  /**
   * Extract the local Y position from a mouse or touch event.
   *
   * @param  {event}  e A mouse or touch event.
   * @return {number}   The local Y value of the mouse.
   */
  sigma.utils.getY = function(e) {
    return (
      (e.offsetY !== undefined && e.offsetY) ||
      (e.layerY !== undefined && e.layerY) ||
      (e.clientY !== undefined && e.clientY)
    );
  };

  /**
   * The pixel ratio of the screen. Taking zoom into account
   *
   * @return {number}        Pixel ratio of the screen
   */
  sigma.utils.getPixelRatio = function() {
    var ratio = 1;
    if (window.screen.deviceXDPI !== undefined &&
         window.screen.logicalXDPI !== undefined &&
         window.screen.deviceXDPI > window.screen.logicalXDPI) {
        ratio = window.screen.systemXDPI / window.screen.logicalXDPI;
    }
    else if (window.devicePixelRatio !== undefined) {
        ratio = window.devicePixelRatio;
    }
    return ratio;
  };

  /**
   * Extract the width from a mouse or touch event.
   *
   * @param  {event}  e A mouse or touch event.
   * @return {number}   The width of the event's target.
   */
  sigma.utils.getWidth = function(e) {
    var w = (!e.target.ownerSVGElement) ?
              e.target.width :
              e.target.ownerSVGElement.width;

    return (
      (typeof w === 'number' && w) ||
      (w !== undefined && w.baseVal !== undefined && w.baseVal.value)
    );
  };

  /**
   * Extract the center from a mouse or touch event.
   *
   * @param  {event}  e A mouse or touch event.
   * @return {object}   The center of the event's target.
   */
  sigma.utils.getCenter = function(e) {
    var ratio = e.target.namespaceURI.indexOf('svg') !== -1 ? 1 :
        sigma.utils.getPixelRatio();
    return {
      x: sigma.utils.getWidth(e) / (2 * ratio),
      y: sigma.utils.getHeight(e) / (2 * ratio)
    };
  };

  /**
   * Convert mouse coords to sigma coords
   *
   * @param  {event}   e A mouse or touch event.
   * @param  {number?} x The x coord to convert
   * @param  {number?} x The y coord to convert
   *
   * @return {object}    The standardized event
   */
  sigma.utils.mouseCoords = function(e, x, y) {
    x = x || sigma.utils.getX(e);
    y = y || sigma.utils.getY(e);
    return {
        x: x - sigma.utils.getCenter(e).x,
        y: y - sigma.utils.getCenter(e).y,
        clientX: e.clientX,
        clientY: e.clientY,
        ctrlKey: e.ctrlKey,
        metaKey: e.metaKey,
        altKey: e.altKey,
        shiftKey: e.shiftKey
    };
  };

  /**
   * Extract the height from a mouse or touch event.
   *
   * @param  {event}  e A mouse or touch event.
   * @return {number}   The height of the event's target.
   */
  sigma.utils.getHeight = function(e) {
    var h = (!e.target.ownerSVGElement) ?
              e.target.height :
              e.target.ownerSVGElement.height;

    return (
      (typeof h === 'number' && h) ||
      (h !== undefined && h.baseVal !== undefined && h.baseVal.value)
    );
  };

  /**
   * Extract the wheel delta from a mouse or touch event.
   *
   * @param  {event}  e A mouse or touch event.
   * @return {number}   The wheel delta of the mouse.
   */
  sigma.utils.getDelta = function(e) {
    return (
      (e.wheelDelta !== undefined && e.wheelDelta) ||
      (e.detail !== undefined && -e.detail)
    );
  };

  /**
   * Returns the offset of a DOM element.
   *
   * @param  {DOMElement} dom The element to retrieve the position.
   * @return {object}         The offset of the DOM element (top, left).
   */
  sigma.utils.getOffset = function(dom) {
    var left = 0,
        top = 0;

    while (dom) {
      top = top + parseInt(dom.offsetTop);
      left = left + parseInt(dom.offsetLeft);
      dom = dom.offsetParent;
    }

    return {
      top: top,
      left: left
    };
  };

  /**
   * Simulates a "double click" event.
   *
   * @param  {HTMLElement} target   The event target.
   * @param  {string}      type     The event type.
   * @param  {function}    callback The callback to execute.
   */
  sigma.utils.doubleClick = function(target, type, callback) {
    var clicks = 0,
        self = this,
        handlers;

    target._doubleClickHandler = target._doubleClickHandler || {};
    target._doubleClickHandler[type] = target._doubleClickHandler[type] || [];
    handlers = target._doubleClickHandler[type];

    handlers.push(function(e) {
      clicks++;

      if (clicks === 2) {
        clicks = 0;
        return callback(e);
      } else if (clicks === 1) {
        setTimeout(function() {
          clicks = 0;
        }, sigma.settings.doubleClickTimeout);
      }
    });

    target.addEventListener(type, handlers[handlers.length - 1], false);
  };

  /**
   * Unbind simulated "double click" events.
   *
   * @param  {HTMLElement} target   The event target.
   * @param  {string}      type     The event type.
   */
  sigma.utils.unbindDoubleClick = function(target, type) {
    var handler,
        handlers = (target._doubleClickHandler || {})[type] || [];

    while ((handler = handlers.pop())) {
      target.removeEventListener(type, handler);
    }

    delete (target._doubleClickHandler || {})[type];
  };




  /**
   * Here are just some of the most basic easing functions, used for the
   * animated camera "goTo" calls.
   *
   * If you need some more easings functions, don't hesitate to add them to
   * sigma.utils.easings. But I will not add some more here or merge PRs
   * containing, because I do not want sigma sources full of overkill and never
   * used stuff...
   */
  sigma.utils.easings = sigma.utils.easings || {};
  sigma.utils.easings.linearNone = function(k) {
    return k;
  };
  sigma.utils.easings.quadraticIn = function(k) {
    return k * k;
  };
  sigma.utils.easings.quadraticOut = function(k) {
    return k * (2 - k);
  };
  sigma.utils.easings.quadraticInOut = function(k) {
    if ((k *= 2) < 1)
      return 0.5 * k * k;
    return - 0.5 * (--k * (k - 2) - 1);
  };
  sigma.utils.easings.cubicIn = function(k) {
    return k * k * k;
  };
  sigma.utils.easings.cubicOut = function(k) {
    return --k * k * k + 1;
  };
  sigma.utils.easings.cubicInOut = function(k) {
    if ((k *= 2) < 1)
      return 0.5 * k * k * k;
    return 0.5 * ((k -= 2) * k * k + 2);
  };




  /**
   * ************
   * WEBGL UTILS:
   * ************
   */
  /**
   * Loads a WebGL shader and returns it.
   *
   * @param  {WebGLContext}           gl           The WebGLContext to use.
   * @param  {string}                 shaderSource The shader source.
   * @param  {number}                 shaderType   The type of shader.
   * @param  {function(string): void} error        Callback for errors.
   * @return {WebGLShader}                         The created shader.
   */
  sigma.utils.loadShader = function(gl, shaderSource, shaderType, error) {
    var compiled,
        shader = gl.createShader(shaderType);

    // Load the shader source
    gl.shaderSource(shader, shaderSource);

    // Compile the shader
    gl.compileShader(shader);

    // Check the compile status
    compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);

    // If something went wrong:
    if (!compiled) {
      if (error) {
        error(
          'Error compiling shader "' + shader + '":' +
          gl.getShaderInfoLog(shader)
        );
      }

      gl.deleteShader(shader);
      return null;
    }

    return shader;
  };

  /**
   * Creates a program, attaches shaders, binds attrib locations, links the
   * program and calls useProgram.
   *
   * @param  {Array.<WebGLShader>}    shaders   The shaders to attach.
   * @param  {Array.<string>}         attribs   The attribs names.
   * @param  {Array.<number>}         locations The locations for the attribs.
   * @param  {function(string): void} error     Callback for errors.
   * @return {WebGLProgram}                     The created program.
   */
  sigma.utils.loadProgram = function(gl, shaders, attribs, loc, error) {
    var i,
        linked,
        program = gl.createProgram();

    for (i = 0; i < shaders.length; ++i)
      gl.attachShader(program, shaders[i]);

    if (attribs)
      for (i = 0; i < attribs.length; ++i)
        gl.bindAttribLocation(
          program,
          locations ? locations[i] : i,
          opt_attribs[i]
        );

    gl.linkProgram(program);

    // Check the link status
    linked = gl.getProgramParameter(program, gl.LINK_STATUS);
    if (!linked) {
      if (error)
        error('Error in program linking: ' + gl.getProgramInfoLog(program));

      gl.deleteProgram(program);
      return null;
    }

    return program;
  };




  /**
   * *********
   * MATRICES:
   * *********
   * The following utils are just here to help generating the transformation
   * matrices for the WebGL renderers.
   */
  sigma.utils.pkg('sigma.utils.matrices');

  /**
   * The returns a 3x3 translation matrix.
   *
   * @param  {number} dx The X translation.
   * @param  {number} dy The Y translation.
   * @return {array}     Returns the matrix.
   */
  sigma.utils.matrices.translation = function(dx, dy) {
    return [
      1, 0, 0,
      0, 1, 0,
      dx, dy, 1
    ];
  };

  /**
   * The returns a 3x3 or 2x2 rotation matrix.
   *
   * @param  {number}  angle The rotation angle.
   * @param  {boolean} m2    If true, the function will return a 2x2 matrix.
   * @return {array}         Returns the matrix.
   */
  sigma.utils.matrices.rotation = function(angle, m2) {
    var cos = Math.cos(angle),
        sin = Math.sin(angle);

    return m2 ? [
      cos, -sin,
      sin, cos
    ] : [
      cos, -sin, 0,
      sin, cos, 0,
      0, 0, 1
    ];
  };

  /**
   * The returns a 3x3 or 2x2 homothetic transformation matrix.
   *
   * @param  {number}  ratio The scaling ratio.
   * @param  {boolean} m2    If true, the function will return a 2x2 matrix.
   * @return {array}         Returns the matrix.
   */
  sigma.utils.matrices.scale = function(ratio, m2) {
    return m2 ? [
      ratio, 0,
      0, ratio
    ] : [
      ratio, 0, 0,
      0, ratio, 0,
      0, 0, 1
    ];
  };

  /**
   * The returns a 3x3 or 2x2 homothetic transformation matrix.
   *
   * @param  {array}   a  The first matrix.
   * @param  {array}   b  The second matrix.
   * @param  {boolean} m2 If true, the function will assume both matrices are
   *                      2x2.
   * @return {array}      Returns the matrix.
   */
  sigma.utils.matrices.multiply = function(a, b, m2) {
    var l = m2 ? 2 : 3,
        a00 = a[0 * l + 0],
        a01 = a[0 * l + 1],
        a02 = a[0 * l + 2],
        a10 = a[1 * l + 0],
        a11 = a[1 * l + 1],
        a12 = a[1 * l + 2],
        a20 = a[2 * l + 0],
        a21 = a[2 * l + 1],
        a22 = a[2 * l + 2],
        b00 = b[0 * l + 0],
        b01 = b[0 * l + 1],
        b02 = b[0 * l + 2],
        b10 = b[1 * l + 0],
        b11 = b[1 * l + 1],
        b12 = b[1 * l + 2],
        b20 = b[2 * l + 0],
        b21 = b[2 * l + 1],
        b22 = b[2 * l + 2];

    return m2 ? [
      a00 * b00 + a01 * b10,
      a00 * b01 + a01 * b11,
      a10 * b00 + a11 * b10,
      a10 * b01 + a11 * b11
    ] : [
      a00 * b00 + a01 * b10 + a02 * b20,
      a00 * b01 + a01 * b11 + a02 * b21,
      a00 * b02 + a01 * b12 + a02 * b22,
      a10 * b00 + a11 * b10 + a12 * b20,
      a10 * b01 + a11 * b11 + a12 * b21,
      a10 * b02 + a11 * b12 + a12 * b22,
      a20 * b00 + a21 * b10 + a22 * b20,
      a20 * b01 + a21 * b11 + a22 * b21,
      a20 * b02 + a21 * b12 + a22 * b22
    ];
  };
}).call(this);

;(function(global) {
  'use strict';

  /**
   * http://paulirish.com/2011/requestanimationframe-for-smart-animating/
   * http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating
   * requestAnimationFrame polyfill by Erik MÃ¶ller.
   * fixes from Paul Irish and Tino Zijdel
   * MIT license
   */
  var x,
      lastTime = 0,
      vendors = ['ms', 'moz', 'webkit', 'o'];

  for (x = 0; x < vendors.length && !global.requestAnimationFrame; x++) {
    global.requestAnimationFrame =
      global[vendors[x] + 'RequestAnimationFrame'];
    global.cancelAnimationFrame =
      global[vendors[x] + 'CancelAnimationFrame'] ||
      global[vendors[x] + 'CancelRequestAnimationFrame'];
  }

  if (!global.requestAnimationFrame)
    global.requestAnimationFrame = function(callback, element) {
      var currTime = new Date().getTime(),
          timeToCall = Math.max(0, 16 - (currTime - lastTime)),
          id = global.setTimeout(
            function() {
              callback(currTime + timeToCall);
            },
            timeToCall
          );

      lastTime = currTime + timeToCall;
      return id;
    };

  if (!global.cancelAnimationFrame)
    global.cancelAnimationFrame = function(id) {
      clearTimeout(id);
    };

  /**
   * Function.prototype.bind polyfill found on MDN.
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind#Compatibility
   * Public domain
   */
  if (!Function.prototype.bind)
    Function.prototype.bind = function(oThis) {
      if (typeof this !== 'function')
        // Closest thing possible to the ECMAScript 5 internal IsCallable
        // function:
        throw new TypeError(
          'Function.prototype.bind - what is trying to be bound is not callable'
        );

      var aArgs = Array.prototype.slice.call(arguments, 1),
          fToBind = this,
          fNOP,
          fBound;

      fNOP = function() {};
      fBound = function() {
        return fToBind.apply(
          this instanceof fNOP && oThis ?
            this :
            oThis,
          aArgs.concat(Array.prototype.slice.call(arguments))
        );
      };

      fNOP.prototype = this.prototype;
      fBound.prototype = new fNOP();

      return fBound;
    };
})(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Packages initialization:
  sigma.utils.pkg('sigma.settings');

  var settings = {
    /**
     * GRAPH SETTINGS:
     * ***************
     */
    // {boolean} Indicates if the data have to be cloned in methods to add
    //           nodes or edges.
    clone: true,
    // {boolean} Indicates if nodes "id" values and edges "id", "source" and
    //           "target" values must be set as immutable.
    immutable: true,
    // {boolean} Indicates if sigma can log its errors and warnings.
    verbose: false,


    /**
     * RENDERERS SETTINGS:
     * *******************
     */
    // {string}
    classPrefix: 'sigma',
    // {string}
    defaultNodeType: 'def',
    // {string}
    defaultEdgeType: 'def',
    // {string}
    defaultLabelColor: '#000',
    // {string}
    defaultEdgeColor: '#000',
    // {string}
    defaultNodeColor: '#000',
    // {string}
    defaultLabelSize: 14,
    // {string} Indicates how to choose the edges color. Available values:
    //          "source", "target", "default"
    edgeColor: 'source',
    // {number} Defines the minimal edge's arrow display size.
    minArrowSize: 0,
    // {string}
    font: 'arial',
    // {string} Example: 'bold'
    fontStyle: '',
    // {string} Indicates how to choose the labels color. Available values:
    //          "node", "default"
    labelColor: 'default',
    // {string} Indicates how to choose the labels size. Available values:
    //          "fixed", "proportional"
    labelSize: 'fixed',
    // {string} The ratio between the font size of the label and the node size.
    labelSizeRatio: 1,
    // {number} The minimum size a node must have to see its label displayed.
    labelThreshold: 8,
    // {number} The oversampling factor used in WebGL renderer.
    webglOversamplingRatio: 2,
    // {number} The size of the border of hovered nodes.
    borderSize: 0,
    // {number} The default hovered node border's color.
    defaultNodeBorderColor: '#000',
    // {number} The hovered node's label font. If not specified, will heritate
    //          the "font" value.
    hoverFont: '',
    // {boolean} If true, then only one node can be hovered at a time.
    singleHover: true,
    // {string} Example: 'bold'
    hoverFontStyle: '',
    // {string} Indicates how to choose the hovered nodes shadow color.
    //          Available values: "node", "default"
    labelHoverShadow: 'default',
    // {string}
    labelHoverShadowColor: '#000',
    // {string} Indicates how to choose the hovered nodes color.
    //          Available values: "node", "default"
    nodeHoverColor: 'node',
    // {string}
    defaultNodeHoverColor: '#000',
    // {string} Indicates how to choose the hovered nodes background color.
    //          Available values: "node", "default"
    labelHoverBGColor: 'default',
    // {string}
    defaultHoverLabelBGColor: '#fff',
    // {string} Indicates how to choose the hovered labels color.
    //          Available values: "node", "default"
    labelHoverColor: 'default',
    // {string}
    defaultLabelHoverColor: '#000',
    // {string} Indicates how to choose the edges hover color. Available values:
    //          "edge", "default"
    edgeHoverColor: 'edge',
    // {number} The size multiplicator of hovered edges.
    edgeHoverSizeRatio: 1,
    // {string}
    defaultEdgeHoverColor: '#000',
    // {boolean} Indicates if the edge extremities must be hovered when the
    //           edge is hovered.
    edgeHoverExtremities: false,
    // {booleans} The different drawing modes:
    //           false: Layered not displayed.
    //           true: Layered displayed.
    drawEdges: true,
    drawNodes: true,
    drawLabels: true,
    drawEdgeLabels: false,
    // {boolean} Indicates if the edges must be drawn in several frames or in
    //           one frame, as the nodes and labels are drawn.
    batchEdgesDrawing: false,
    // {boolean} Indicates if the edges must be hidden during dragging and
    //           animations.
    hideEdgesOnMove: false,
    // {numbers} The different batch sizes, when elements are displayed in
    //           several frames.
    canvasEdgesBatchSize: 500,
    webglEdgesBatchSize: 1000,




    /**
     * RESCALE SETTINGS:
     * *****************
     */
    // {string} Indicates of to scale the graph relatively to its container.
    //          Available values: "inside", "outside"
    scalingMode: 'inside',
    // {number} The margin to keep around the graph.
    sideMargin: 0,
    // {number} Determine the size of the smallest and the biggest node / edges
    //          on the screen. This mapping makes easier to display the graph,
    //          avoiding too big nodes that take half of the screen, or too
    //          small ones that are not readable. If the two parameters are
    //          equals, then the minimal display size will be 0. And if they
    //          are both equal to 0, then there is no mapping, and the radius
    //          of the nodes will be their size.
    minEdgeSize: 0.5,
    maxEdgeSize: 1,
    minNodeSize: 1,
    maxNodeSize: 8,




    /**
     * CAPTORS SETTINGS:
     * *****************
     */
    // {boolean}
    touchEnabled: true,
    // {boolean}
    mouseEnabled: true,
    // {boolean}
    mouseWheelEnabled: true,
    // {boolean}
    doubleClickEnabled: true,
    // {boolean} Defines whether the custom events such as "clickNode" can be
    //           used.
    eventsEnabled: true,
    // {number} Defines by how much multiplicating the zooming level when the
    //          user zooms with the mouse-wheel.
    zoomingRatio: 1.7,
    // {number} Defines by how much multiplicating the zooming level when the
    //          user zooms by double clicking.
    doubleClickZoomingRatio: 2.2,
    // {number} The minimum zooming level.
    zoomMin: 0.0625,
    // {number} The maximum zooming level.
    zoomMax: 2,
    // {number} The duration of animations following a mouse scrolling.
    mouseZoomDuration: 200,
    // {number} The duration of animations following a mouse double click.
    doubleClickZoomDuration: 200,
    // {number} The duration of animations following a mouse dropping.
    mouseInertiaDuration: 200,
    // {number} The inertia power (mouse captor).
    mouseInertiaRatio: 3,
    // {number} The duration of animations following a touch dropping.
    touchInertiaDuration: 200,
    // {number} The inertia power (touch captor).
    touchInertiaRatio: 3,
    // {number} The maximum time between two clicks to make it a double click.
    doubleClickTimeout: 300,
    // {number} The maximum time between two taps to make it a double tap.
    doubleTapTimeout: 300,
    // {number} The maximum time of dragging to trigger intertia.
    dragTimeout: 200,




    /**
     * GLOBAL SETTINGS:
     * ****************
     */
    // {boolean} Determines whether the instance has to refresh itself
    //           automatically when a "resize" event is dispatched from the
    //           window object.
    autoResize: true,
    // {boolean} Determines whether the "rescale" middleware has to be called
    //           automatically for each camera on refresh.
    autoRescale: true,
    // {boolean} If set to false, the camera method "goTo" will basically do
    //           nothing.
    enableCamera: true,
    // {boolean} If set to false, the nodes cannot be hovered.
    enableHovering: true,
    // {boolean} If set to true, the edges can be hovered.
    enableEdgeHovering: false,
    // {number} The size of the area around the edges to activate hovering.
    edgeHoverPrecision: 5,
    // {boolean} If set to true, the rescale middleware will ignore node sizes
    //           to determine the graphs boundings.
    rescaleIgnoreSize: false,
    // {boolean} Determines if the core has to try to catch errors on
    //           rendering.
    skipErrors: false,




    /**
     * CAMERA SETTINGS:
     * ****************
     */
    // {number} The power degrees applied to the nodes/edges size relatively to
    //          the zooming level. Basically:
    //           > onScreenR = Math.pow(zoom, nodesPowRatio) * R
    //           > onScreenT = Math.pow(zoom, edgesPowRatio) * T
    nodesPowRatio: 0.5,
    edgesPowRatio: 0.5,




    /**
     * ANIMATIONS SETTINGS:
     * ********************
     */
    // {number} The default animation time.
    animationsTime: 200
  };

  // Export the previously designed settings:
  sigma.settings = sigma.utils.extend(sigma.settings || {}, settings);
}).call(this);

;(function() {
  'use strict';

  /**
   * Dispatcher constructor.
   *
   * @return {dispatcher} The new dispatcher instance.
   */
  var dispatcher = function() {
    Object.defineProperty(this, '_handlers', {
      value: {}
    });
  };




  /**
   * Will execute the handler everytime that the indicated event (or the
   * indicated events) will be triggered.
   *
   * @param  {string}           events  The name of the event (or the events
   *                                    separated by spaces).
   * @param  {function(Object)} handler The handler to bind.
   * @return {dispatcher}               Returns the instance itself.
   */
  dispatcher.prototype.bind = function(events, handler) {
    var i,
        l,
        event,
        eArray;

    if (
      arguments.length === 1 &&
      typeof arguments[0] === 'object'
    )
      for (events in arguments[0])
        this.bind(events, arguments[0][events]);
    else if (
      arguments.length === 2 &&
      typeof arguments[1] === 'function'
    ) {
      eArray = typeof events === 'string' ? events.split(' ') : events;

      for (i = 0, l = eArray.length; i !== l; i += 1) {
        event = eArray[i];

        // Check that event is not '':
        if (!event)
          continue;

        if (!this._handlers[event])
          this._handlers[event] = [];

        // Using an object instead of directly the handler will make possible
        // later to add flags
        this._handlers[event].push({
          handler: handler
        });
      }
    } else
      throw 'bind: Wrong arguments.';

    return this;
  };

  /**
   * Removes the handler from a specified event (or specified events).
   *
   * @param  {?string}           events  The name of the event (or the events
   *                                     separated by spaces). If undefined,
   *                                     then all handlers are removed.
   * @param  {?function(object)} handler The handler to unbind. If undefined,
   *                                     each handler bound to the event or the
   *                                     events will be removed.
   * @return {dispatcher}                Returns the instance itself.
   */
  dispatcher.prototype.unbind = function(events, handler) {
    var i,
        n,
        j,
        m,
        k,
        a,
        event,
        eArray = typeof events === 'string' ? events.split(' ') : events;

    if (!arguments.length) {
      for (k in this._handlers)
        delete this._handlers[k];
      return this;
    }

    if (handler) {
      for (i = 0, n = eArray.length; i !== n; i += 1) {
        event = eArray[i];
        if (this._handlers[event]) {
          a = [];
          for (j = 0, m = this._handlers[event].length; j !== m; j += 1)
            if (this._handlers[event][j].handler !== handler)
              a.push(this._handlers[event][j]);

          this._handlers[event] = a;
        }

        if (this._handlers[event] && this._handlers[event].length === 0)
          delete this._handlers[event];
      }
    } else
      for (i = 0, n = eArray.length; i !== n; i += 1)
        delete this._handlers[eArray[i]];

    return this;
  };

  /**
   * Executes each handler bound to the event
   *
   * @param  {string}     events The name of the event (or the events separated
   *                             by spaces).
   * @param  {?object}    data   The content of the event (optional).
   * @return {dispatcher}        Returns the instance itself.
   */
  dispatcher.prototype.dispatchEvent = function(events, data) {
    var i,
        n,
        j,
        m,
        a,
        event,
        eventName,
        self = this,
        eArray = typeof events === 'string' ? events.split(' ') : events;

    data = data === undefined ? {} : data;

    for (i = 0, n = eArray.length; i !== n; i += 1) {
      eventName = eArray[i];

      if (this._handlers[eventName]) {
        event = self.getEvent(eventName, data);
        a = [];

        for (j = 0, m = this._handlers[eventName].length; j !== m; j += 1) {
          this._handlers[eventName][j].handler(event);
          if (!this._handlers[eventName][j].one)
            a.push(this._handlers[eventName][j]);
        }

        this._handlers[eventName] = a;
      }
    }

    return this;
  };

  /**
   * Return an event object.
   *
   * @param  {string}  events The name of the event.
   * @param  {?object} data   The content of the event (optional).
   * @return {object}         Returns the instance itself.
   */
  dispatcher.prototype.getEvent = function(event, data) {
    return {
      type: event,
      data: data || {},
      target: this
    };
  };

  /**
   * A useful function to deal with inheritance. It will make the target
   * inherit the prototype of the class dispatcher as well as its constructor.
   *
   * @param {object} target The target.
   */
  dispatcher.extend = function(target, args) {
    var k;

    for (k in dispatcher.prototype)
      if (dispatcher.prototype.hasOwnProperty(k))
        target[k] = dispatcher.prototype[k];

    dispatcher.apply(target, args);
  };




  /**
   * EXPORT:
   * *******
   */
  if (typeof this.sigma !== 'undefined') {
    this.sigma.classes = this.sigma.classes || {};
    this.sigma.classes.dispatcher = dispatcher;
  } else if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports)
      exports = module.exports = dispatcher;
    exports.dispatcher = dispatcher;
  } else
    this.dispatcher = dispatcher;
}).call(this);

;(function() {
  'use strict';

  /**
   * This utils aims to facilitate the manipulation of each instance setting.
   * Using a function instead of an object brings two main advantages: First,
   * it will be easier in the future to catch settings updates through a
   * function than an object. Second, giving it a full object will "merge" it
   * to the settings object properly, keeping us to have to always add a loop.
   *
   * @return {configurable} The "settings" function.
   */
  var configurable = function() {
    var i,
        l,
        data = {},
        datas = Array.prototype.slice.call(arguments, 0);

    /**
     * The method to use to set or get any property of this instance.
     *
     * @param  {string|object}    a1 If it is a string and if a2 is undefined,
     *                               then it will return the corresponding
     *                               property. If it is a string and if a2 is
     *                               set, then it will set a2 as the property
     *                               corresponding to a1, and return this. If
     *                               it is an object, then each pair string +
     *                               object(or any other type) will be set as a
     *                               property.
     * @param  {*?}               a2 The new property corresponding to a1 if a1
     *                               is a string.
     * @return {*|configurable}      Returns itself or the corresponding
     *                               property.
     *
     * Polymorphism:
     * *************
     * Here are some basic use examples:
     *
     *  > settings = new configurable();
     *  > settings('mySetting', 42);
     *  > settings('mySetting'); // Logs: 42
     *  > settings('mySetting', 123);
     *  > settings('mySetting'); // Logs: 123
     *  > settings({mySetting: 456});
     *  > settings('mySetting'); // Logs: 456
     *
     * Also, it is possible to use the function as a fallback:
     *  > settings({mySetting: 'abc'}, 'mySetting');  // Logs: 'abc'
     *  > settings({hisSetting: 'abc'}, 'mySetting'); // Logs: 456
     */
    var settings = function(a1, a2) {
      var o,
          i,
          l,
          k;

      if (arguments.length === 1 && typeof a1 === 'string') {
        if (data[a1] !== undefined)
          return data[a1];
        for (i = 0, l = datas.length; i < l; i++)
          if (datas[i][a1] !== undefined)
            return datas[i][a1];
        return undefined;
      } else if (typeof a1 === 'object' && typeof a2 === 'string') {
        return (a1 || {})[a2] !== undefined ? a1[a2] : settings(a2);
      } else {
        o = (typeof a1 === 'object' && a2 === undefined) ? a1 : {};

        if (typeof a1 === 'string')
          o[a1] = a2;

        for (i = 0, k = Object.keys(o), l = k.length; i < l; i++)
          data[k[i]] = o[k[i]];

        return this;
      }
    };

    /**
     * This method returns a new configurable function, with new objects
     *
     * @param  {object*}  Any number of objects to search in.
     * @return {function} Returns the function. Check its documentation to know
     *                    more about how it works.
     */
    settings.embedObjects = function() {
      var args = datas.concat(
        data
      ).concat(
        Array.prototype.splice.call(arguments, 0)
      );

      return configurable.apply({}, args);
    };

    // Initialize
    for (i = 0, l = arguments.length; i < l; i++)
      settings(arguments[i]);

    return settings;
  };

  /**
   * EXPORT:
   * *******
   */
  if (typeof this.sigma !== 'undefined') {
    this.sigma.classes = this.sigma.classes || {};
    this.sigma.classes.configurable = configurable;
  } else if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports)
      exports = module.exports = configurable;
    exports.configurable = configurable;
  } else
    this.configurable = configurable;
}).call(this);

;(function(undefined) {
  'use strict';

  var _methods = Object.create(null),
      _indexes = Object.create(null),
      _initBindings = Object.create(null),
      _methodBindings = Object.create(null),
      _methodBeforeBindings = Object.create(null),
      _defaultSettings = {
        immutable: true,
        clone: true
      },
      _defaultSettingsFunction = function(key) {
        return _defaultSettings[key];
      };

  /**
   * The graph constructor. It initializes the data and the indexes, and binds
   * the custom indexes and methods to its own scope.
   *
   * Recognized parameters:
   * **********************
   * Here is the exhaustive list of every accepted parameters in the settings
   * object:
   *
   *   {boolean} clone     Indicates if the data have to be cloned in methods
   *                       to add nodes or edges.
   *   {boolean} immutable Indicates if nodes "id" values and edges "id",
   *                       "source" and "target" values must be set as
   *                       immutable.
   *
   * @param  {?configurable} settings Eventually a settings function.
   * @return {graph}                  The new graph instance.
   */
  var graph = function(settings) {
    var k,
        fn,
        data;

    /**
     * DATA:
     * *****
     * Every data that is callable from graph methods are stored in this "data"
     * object. This object will be served as context for all these methods,
     * and it is possible to add other type of data in it.
     */
    data = {
      /**
       * SETTINGS FUNCTION:
       * ******************
       */
      settings: settings || _defaultSettingsFunction,

      /**
       * MAIN DATA:
       * **********
       */
      nodesArray: [],
      edgesArray: [],

      /**
       * GLOBAL INDEXES:
       * ***************
       * These indexes just index data by ids.
       */
      nodesIndex: Object.create(null),
      edgesIndex: Object.create(null),

      /**
       * LOCAL INDEXES:
       * **************
       * These indexes refer from node to nodes. Each key is an id, and each
       * value is the array of the ids of related nodes.
       */
      inNeighborsIndex: Object.create(null),
      outNeighborsIndex: Object.create(null),
      allNeighborsIndex: Object.create(null),

      inNeighborsCount: Object.create(null),
      outNeighborsCount: Object.create(null),
      allNeighborsCount: Object.create(null)
    };

    // Execute bindings:
    for (k in _initBindings)
      _initBindings[k].call(data);

    // Add methods to both the scope and the data objects:
    for (k in _methods) {
      fn = __bindGraphMethod(k, data, _methods[k]);
      this[k] = fn;
      data[k] = fn;
    }
  };




  /**
   * A custom tool to bind methods such that function that are bound to it will
   * be executed anytime the method is called.
   *
   * @param  {string}   methodName The name of the method to bind.
   * @param  {object}   scope      The scope where the method must be executed.
   * @param  {function} fn         The method itself.
   * @return {function}            The new method.
   */
  function __bindGraphMethod(methodName, scope, fn) {
    var result = function() {
      var k,
          res;

      // Execute "before" bound functions:
      for (k in _methodBeforeBindings[methodName])
        _methodBeforeBindings[methodName][k].apply(scope, arguments);

      // Apply the method:
      res = fn.apply(scope, arguments);

      // Execute bound functions:
      for (k in _methodBindings[methodName])
        _methodBindings[methodName][k].apply(scope, arguments);

      // Return res:
      return res;
    };

    return result;
  }

  /**
   * This custom tool function removes every pair key/value from an hash. The
   * goal is to avoid creating a new object while some other references are
   * still hanging in some scopes...
   *
   * @param  {object} obj The object to empty.
   * @return {object}     The empty object.
   */
  function __emptyObject(obj) {
    var k;

    for (k in obj)
      if (!('hasOwnProperty' in obj) || obj.hasOwnProperty(k))
        delete obj[k];

    return obj;
  }




  /**
   * This global method adds a method that will be bound to the futurly created
   * graph instances.
   *
   * Since these methods will be bound to their scope when the instances are
   * created, it does not use the prototype. Because of that, methods have to
   * be added before instances are created to make them available.
   *
   * Here is an example:
   *
   *  > graph.addMethod('getNodesCount', function() {
   *  >   return this.nodesArray.length;
   *  > });
   *  >
   *  > var myGraph = new graph();
   *  > console.log(myGraph.getNodesCount()); // outputs 0
   *
   * @param  {string}   methodName The name of the method.
   * @param  {function} fn         The method itself.
   * @return {object}              The global graph constructor.
   */
  graph.addMethod = function(methodName, fn) {
    if (
      typeof methodName !== 'string' ||
      typeof fn !== 'function' ||
      arguments.length !== 2
    )
      throw 'addMethod: Wrong arguments.';

    if (_methods[methodName] || graph[methodName])
      throw 'The method "' + methodName + '" already exists.';

    _methods[methodName] = fn;
    _methodBindings[methodName] = Object.create(null);
    _methodBeforeBindings[methodName] = Object.create(null);

    return this;
  };

  /**
   * This global method returns true if the method has already been added, and
   * false else.
   *
   * Here are some examples:
   *
   *  > graph.hasMethod('addNode'); // returns true
   *  > graph.hasMethod('hasMethod'); // returns true
   *  > graph.hasMethod('unexistingMethod'); // returns false
   *
   * @param  {string}  methodName The name of the method.
   * @return {boolean}            The result.
   */
  graph.hasMethod = function(methodName) {
    return !!(_methods[methodName] || graph[methodName]);
  };

  /**
   * This global methods attaches a function to a method. Anytime the specified
   * method is called, the attached function is called right after, with the
   * same arguments and in the same scope. The attached function is called
   * right before if the last argument is true, unless the method is the graph
   * constructor.
   *
   * To attach a function to the graph constructor, use 'constructor' as the
   * method name (first argument).
   *
   * The main idea is to have a clean way to keep custom indexes up to date,
   * for instance:
   *
   *  > var timesAddNodeCalled = 0;
   *  > graph.attach('addNode', 'timesAddNodeCalledInc', function() {
   *  >   timesAddNodeCalled++;
   *  > });
   *  >
   *  > var myGraph = new graph();
   *  > console.log(timesAddNodeCalled); // outputs 0
   *  >
   *  > myGraph.addNode({ id: '1' }).addNode({ id: '2' });
   *  > console.log(timesAddNodeCalled); // outputs 2
   *
   * The idea for calling a function before is to provide pre-processors, for
   * instance:
   *
   *  > var colorPalette = { Person: '#C3CBE1', Place: '#9BDEBD' };
   *  > graph.attach('addNode', 'applyNodeColorPalette', function(n) {
   *  >   n.color = colorPalette[n.category];
   *  > }, true);
   *  >
   *  > var myGraph = new graph();
   *  > myGraph.addNode({ id: 'n0', category: 'Person' });
   *  > console.log(myGraph.nodes('n0').color); // outputs '#C3CBE1'
   *
   * @param  {string}   methodName The name of the related method or
   *                               "constructor".
   * @param  {string}   key        The key to identify the function to attach.
   * @param  {function} fn         The function to bind.
   * @param  {boolean}  before     If true the function is called right before.
   * @return {object}              The global graph constructor.
   */
  graph.attach = function(methodName, key, fn, before) {
    if (
      typeof methodName !== 'string' ||
      typeof key !== 'string' ||
      typeof fn !== 'function' ||
      arguments.length < 3 ||
      arguments.length > 4
    )
      throw 'attach: Wrong arguments.';

    var bindings;

    if (methodName === 'constructor')
      bindings = _initBindings;
    else {
      if (before) {
        if (!_methodBeforeBindings[methodName])
        throw 'The method "' + methodName + '" does not exist.';

        bindings = _methodBeforeBindings[methodName];
      }
      else {
        if (!_methodBindings[methodName])
          throw 'The method "' + methodName + '" does not exist.';

        bindings = _methodBindings[methodName];
      }
    }

    if (bindings[key])
      throw 'A function "' + key + '" is already attached ' +
            'to the method "' + methodName + '".';

    bindings[key] = fn;

    return this;
  };

  /**
   * Alias of attach(methodName, key, fn, true).
   */
  graph.attachBefore = function(methodName, key, fn) {
    return this.attach(methodName, key, fn, true);
  };

  /**
   * This methods is just an helper to deal with custom indexes. It takes as
   * arguments the name of the index and an object containing all the different
   * functions to bind to the methods.
   *
   * Here is a basic example, that creates an index to keep the number of nodes
   * in the current graph. It also adds a method to provide a getter on that
   * new index:
   *
   *  > sigma.classes.graph.addIndex('nodesCount', {
   *  >   constructor: function() {
   *  >     this.nodesCount = 0;
   *  >   },
   *  >   addNode: function() {
   *  >     this.nodesCount++;
   *  >   },
   *  >   dropNode: function() {
   *  >     this.nodesCount--;
   *  >   }
   *  > });
   *  >
   *  > sigma.classes.graph.addMethod('getNodesCount', function() {
   *  >   return this.nodesCount;
   *  > });
   *  >
   *  > var myGraph = new sigma.classes.graph();
   *  > console.log(myGraph.getNodesCount()); // outputs 0
   *  >
   *  > myGraph.addNode({ id: '1' }).addNode({ id: '2' });
   *  > console.log(myGraph.getNodesCount()); // outputs 2
   *
   * @param  {string} name     The name of the index.
   * @param  {object} bindings The object containing the functions to bind.
   * @return {object}          The global graph constructor.
   */
  graph.addIndex = function(name, bindings) {
    if (
      typeof name !== 'string' ||
      Object(bindings) !== bindings ||
      arguments.length !== 2
    )
      throw 'addIndex: Wrong arguments.';

    if (_indexes[name])
      throw 'The index "' + name + '" already exists.';

    var k;

    // Store the bindings:
    _indexes[name] = bindings;

    // Attach the bindings:
    for (k in bindings)
      if (typeof bindings[k] !== 'function')
        throw 'The bindings must be functions.';
      else
        graph.attach(k, name, bindings[k]);

    return this;
  };




  /**
   * This method adds a node to the graph. The node must be an object, with a
   * string under the key "id". Except for this, it is possible to add any
   * other attribute, that will be preserved all along the manipulations.
   *
   * If the graph option "clone" has a truthy value, the node will be cloned
   * when added to the graph. Also, if the graph option "immutable" has a
   * truthy value, its id will be defined as immutable.
   *
   * @param  {object} node The node to add.
   * @return {object}      The graph instance.
   */
  graph.addMethod('addNode', function(node) {
    // Check that the node is an object and has an id:
    if (Object(node) !== node || arguments.length !== 1)
      throw 'addNode: Wrong arguments.';

    if (typeof node.id !== 'string' && typeof node.id !== 'number')
      throw 'The node must have a string or number id.';

    if (this.nodesIndex[node.id])
      throw 'The node "' + node.id + '" already exists.';

    var k,
        id = node.id,
        validNode = Object.create(null);

    // Check the "clone" option:
    if (this.settings('clone')) {
      for (k in node)
        if (k !== 'id')
          validNode[k] = node[k];
    } else
      validNode = node;

    // Check the "immutable" option:
    if (this.settings('immutable'))
      Object.defineProperty(validNode, 'id', {
        value: id,
        enumerable: true
      });
    else
      validNode.id = id;

    // Add empty containers for edges indexes:
    this.inNeighborsIndex[id] = Object.create(null);
    this.outNeighborsIndex[id] = Object.create(null);
    this.allNeighborsIndex[id] = Object.create(null);

    this.inNeighborsCount[id] = 0;
    this.outNeighborsCount[id] = 0;
    this.allNeighborsCount[id] = 0;

    // Add the node to indexes:
    this.nodesArray.push(validNode);
    this.nodesIndex[validNode.id] = validNode;

    // Return the current instance:
    return this;
  });

  /**
   * This method adds an edge to the graph. The edge must be an object, with a
   * string under the key "id", and strings under the keys "source" and
   * "target" that design existing nodes. Except for this, it is possible to
   * add any other attribute, that will be preserved all along the
   * manipulations.
   *
   * If the graph option "clone" has a truthy value, the edge will be cloned
   * when added to the graph. Also, if the graph option "immutable" has a
   * truthy value, its id, source and target will be defined as immutable.
   *
   * @param  {object} edge The edge to add.
   * @return {object}      The graph instance.
   */
  graph.addMethod('addEdge', function(edge) {
    // Check that the edge is an object and has an id:
    if (Object(edge) !== edge || arguments.length !== 1)
      throw 'addEdge: Wrong arguments.';

    if (typeof edge.id !== 'string' && typeof edge.id !== 'number')
      throw 'The edge must have a string or number id.';

    if ((typeof edge.source !== 'string' && typeof edge.source !== 'number') ||
        !this.nodesIndex[edge.source])
      throw 'The edge source must have an existing node id.';

    if ((typeof edge.target !== 'string' && typeof edge.target !== 'number') ||
        !this.nodesIndex[edge.target])
      throw 'The edge target must have an existing node id.';

    if (this.edgesIndex[edge.id])
      throw 'The edge "' + edge.id + '" already exists.';

    var k,
        validEdge = Object.create(null);

    // Check the "clone" option:
    if (this.settings('clone')) {
      for (k in edge)
        if (k !== 'id' && k !== 'source' && k !== 'target')
          validEdge[k] = edge[k];
    } else
      validEdge = edge;

    // Check the "immutable" option:
    if (this.settings('immutable')) {
      Object.defineProperty(validEdge, 'id', {
        value: edge.id,
        enumerable: true
      });

      Object.defineProperty(validEdge, 'source', {
        value: edge.source,
        enumerable: true
      });

      Object.defineProperty(validEdge, 'target', {
        value: edge.target,
        enumerable: true
      });
    } else {
      validEdge.id = edge.id;
      validEdge.source = edge.source;
      validEdge.target = edge.target;
    }

    // Add the edge to indexes:
    this.edgesArray.push(validEdge);
    this.edgesIndex[validEdge.id] = validEdge;

    if (!this.inNeighborsIndex[validEdge.target][validEdge.source])
      this.inNeighborsIndex[validEdge.target][validEdge.source] =
        Object.create(null);
    this.inNeighborsIndex[validEdge.target][validEdge.source][validEdge.id] =
      validEdge;

    if (!this.outNeighborsIndex[validEdge.source][validEdge.target])
      this.outNeighborsIndex[validEdge.source][validEdge.target] =
        Object.create(null);
    this.outNeighborsIndex[validEdge.source][validEdge.target][validEdge.id] =
      validEdge;

    if (!this.allNeighborsIndex[validEdge.source][validEdge.target])
      this.allNeighborsIndex[validEdge.source][validEdge.target] =
        Object.create(null);
    this.allNeighborsIndex[validEdge.source][validEdge.target][validEdge.id] =
      validEdge;

    if (validEdge.target !== validEdge.source) {
      if (!this.allNeighborsIndex[validEdge.target][validEdge.source])
        this.allNeighborsIndex[validEdge.target][validEdge.source] =
          Object.create(null);
      this.allNeighborsIndex[validEdge.target][validEdge.source][validEdge.id] =
        validEdge;
    }

    // Keep counts up to date:
    this.inNeighborsCount[validEdge.target]++;
    this.outNeighborsCount[validEdge.source]++;
    this.allNeighborsCount[validEdge.target]++;
    this.allNeighborsCount[validEdge.source]++;

    return this;
  });

  /**
   * This method drops a node from the graph. It also removes each edge that is
   * bound to it, through the dropEdge method. An error is thrown if the node
   * does not exist.
   *
   * @param  {string} id The node id.
   * @return {object}    The graph instance.
   */
  graph.addMethod('dropNode', function(id) {
    // Check that the arguments are valid:
    if ((typeof id !== 'string' && typeof id !== 'number') ||
        arguments.length !== 1)
      throw 'dropNode: Wrong arguments.';

    if (!this.nodesIndex[id])
      throw 'The node "' + id + '" does not exist.';

    var i, k, l;

    // Remove the node from indexes:
    delete this.nodesIndex[id];
    for (i = 0, l = this.nodesArray.length; i < l; i++)
      if (this.nodesArray[i].id === id) {
        this.nodesArray.splice(i, 1);
        break;
      }

    // Remove related edges:
    for (i = this.edgesArray.length - 1; i >= 0; i--)
      if (this.edgesArray[i].source === id || this.edgesArray[i].target === id)
        this.dropEdge(this.edgesArray[i].id);

    // Remove related edge indexes:
    delete this.inNeighborsIndex[id];
    delete this.outNeighborsIndex[id];
    delete this.allNeighborsIndex[id];

    delete this.inNeighborsCount[id];
    delete this.outNeighborsCount[id];
    delete this.allNeighborsCount[id];

    for (k in this.nodesIndex) {
      delete this.inNeighborsIndex[k][id];
      delete this.outNeighborsIndex[k][id];
      delete this.allNeighborsIndex[k][id];
    }

    return this;
  });

  /**
   * This method drops an edge from the graph. An error is thrown if the edge
   * does not exist.
   *
   * @param  {string} id The edge id.
   * @return {object}    The graph instance.
   */
  graph.addMethod('dropEdge', function(id) {
    // Check that the arguments are valid:
    if ((typeof id !== 'string' && typeof id !== 'number') ||
        arguments.length !== 1)
      throw 'dropEdge: Wrong arguments.';

    if (!this.edgesIndex[id])
      throw 'The edge "' + id + '" does not exist.';

    var i, l, edge;

    // Remove the edge from indexes:
    edge = this.edgesIndex[id];
    delete this.edgesIndex[id];
    for (i = 0, l = this.edgesArray.length; i < l; i++)
      if (this.edgesArray[i].id === id) {
        this.edgesArray.splice(i, 1);
        break;
      }

    delete this.inNeighborsIndex[edge.target][edge.source][edge.id];
    if (!Object.keys(this.inNeighborsIndex[edge.target][edge.source]).length)
      delete this.inNeighborsIndex[edge.target][edge.source];

    delete this.outNeighborsIndex[edge.source][edge.target][edge.id];
    if (!Object.keys(this.outNeighborsIndex[edge.source][edge.target]).length)
      delete this.outNeighborsIndex[edge.source][edge.target];

    delete this.allNeighborsIndex[edge.source][edge.target][edge.id];
    if (!Object.keys(this.allNeighborsIndex[edge.source][edge.target]).length)
      delete this.allNeighborsIndex[edge.source][edge.target];

    if (edge.target !== edge.source) {
      delete this.allNeighborsIndex[edge.target][edge.source][edge.id];
      if (!Object.keys(this.allNeighborsIndex[edge.target][edge.source]).length)
        delete this.allNeighborsIndex[edge.target][edge.source];
    }

    this.inNeighborsCount[edge.target]--;
    this.outNeighborsCount[edge.source]--;
    this.allNeighborsCount[edge.source]--;
    this.allNeighborsCount[edge.target]--;

    return this;
  });

  /**
   * This method destroys the current instance. It basically empties each index
   * and methods attached to the graph.
   */
  graph.addMethod('kill', function() {
    // Delete arrays:
    this.nodesArray.length = 0;
    this.edgesArray.length = 0;
    delete this.nodesArray;
    delete this.edgesArray;

    // Delete indexes:
    delete this.nodesIndex;
    delete this.edgesIndex;
    delete this.inNeighborsIndex;
    delete this.outNeighborsIndex;
    delete this.allNeighborsIndex;
    delete this.inNeighborsCount;
    delete this.outNeighborsCount;
    delete this.allNeighborsCount;
  });

  /**
   * This method empties the nodes and edges arrays, as well as the different
   * indexes.
   *
   * @return {object} The graph instance.
   */
  graph.addMethod('clear', function() {
    this.nodesArray.length = 0;
    this.edgesArray.length = 0;

    // Due to GC issues, I prefer not to create new object. These objects are
    // only available from the methods and attached functions, but still, it is
    // better to prevent ghost references to unrelevant data...
    __emptyObject(this.nodesIndex);
    __emptyObject(this.edgesIndex);
    __emptyObject(this.nodesIndex);
    __emptyObject(this.inNeighborsIndex);
    __emptyObject(this.outNeighborsIndex);
    __emptyObject(this.allNeighborsIndex);
    __emptyObject(this.inNeighborsCount);
    __emptyObject(this.outNeighborsCount);
    __emptyObject(this.allNeighborsCount);

    return this;
  });

  /**
   * This method reads an object and adds the nodes and edges, through the
   * proper methods "addNode" and "addEdge".
   *
   * Here is an example:
   *
   *  > var myGraph = new graph();
   *  > myGraph.read({
   *  >   nodes: [
   *  >     { id: 'n0' },
   *  >     { id: 'n1' }
   *  >   ],
   *  >   edges: [
   *  >     {
   *  >       id: 'e0',
   *  >       source: 'n0',
   *  >       target: 'n1'
   *  >     }
   *  >   ]
   *  > });
   *  >
   *  > console.log(
   *  >   myGraph.nodes().length,
   *  >   myGraph.edges().length
   *  > ); // outputs 2 1
   *
   * @param  {object} g The graph object.
   * @return {object}   The graph instance.
   */
  graph.addMethod('read', function(g) {
    var i,
        a,
        l;

    a = g.nodes || [];
    for (i = 0, l = a.length; i < l; i++)
      this.addNode(a[i]);

    a = g.edges || [];
    for (i = 0, l = a.length; i < l; i++)
      this.addEdge(a[i]);

    return this;
  });

  /**
   * This methods returns one or several nodes, depending on how it is called.
   *
   * To get the array of nodes, call "nodes" without argument. To get a
   * specific node, call it with the id of the node. The get multiple node,
   * call it with an array of ids, and it will return the array of nodes, in
   * the same order.
   *
   * @param  {?(string|array)} v Eventually one id, an array of ids.
   * @return {object|array}      The related node or array of nodes.
   */
  graph.addMethod('nodes', function(v) {
    // Clone the array of nodes and return it:
    if (!arguments.length)
      return this.nodesArray.slice(0);

    // Return the related node:
    if (arguments.length === 1 &&
        (typeof v === 'string' || typeof v === 'number'))
      return this.nodesIndex[v];

    // Return an array of the related node:
    if (
      arguments.length === 1 &&
      Object.prototype.toString.call(v) === '[object Array]'
    ) {
      var i,
          l,
          a = [];

      for (i = 0, l = v.length; i < l; i++)
        if (typeof v[i] === 'string' || typeof v[i] === 'number')
          a.push(this.nodesIndex[v[i]]);
        else
          throw 'nodes: Wrong arguments.';

      return a;
    }

    throw 'nodes: Wrong arguments.';
  });

  /**
   * This methods returns the degree of one or several nodes, depending on how
   * it is called. It is also possible to get incoming or outcoming degrees
   * instead by specifying 'in' or 'out' as a second argument.
   *
   * @param  {string|array} v     One id, an array of ids.
   * @param  {?string}      which Which degree is required. Values are 'in',
   *                              'out', and by default the normal degree.
   * @return {number|array}       The related degree or array of degrees.
   */
  graph.addMethod('degree', function(v, which) {
    // Check which degree is required:
    which = {
      'in': this.inNeighborsCount,
      'out': this.outNeighborsCount
    }[which || ''] || this.allNeighborsCount;

    // Return the related node:
    if (typeof v === 'string' || typeof v === 'number')
      return which[v];

    // Return an array of the related node:
    if (Object.prototype.toString.call(v) === '[object Array]') {
      var i,
          l,
          a = [];

      for (i = 0, l = v.length; i < l; i++)
        if (typeof v[i] === 'string' || typeof v[i] === 'number')
          a.push(which[v[i]]);
        else
          throw 'degree: Wrong arguments.';

      return a;
    }

    throw 'degree: Wrong arguments.';
  });

  /**
   * This methods returns one or several edges, depending on how it is called.
   *
   * To get the array of edges, call "edges" without argument. To get a
   * specific edge, call it with the id of the edge. The get multiple edge,
   * call it with an array of ids, and it will return the array of edges, in
   * the same order.
   *
   * @param  {?(string|array)} v Eventually one id, an array of ids.
   * @return {object|array}      The related edge or array of edges.
   */
  graph.addMethod('edges', function(v) {
    // Clone the array of edges and return it:
    if (!arguments.length)
      return this.edgesArray.slice(0);

    // Return the related edge:
    if (arguments.length === 1 &&
        (typeof v === 'string' || typeof v === 'number'))
      return this.edgesIndex[v];

    // Return an array of the related edge:
    if (
      arguments.length === 1 &&
      Object.prototype.toString.call(v) === '[object Array]'
    ) {
      var i,
          l,
          a = [];

      for (i = 0, l = v.length; i < l; i++)
        if (typeof v[i] === 'string' || typeof v[i] === 'number')
          a.push(this.edgesIndex[v[i]]);
        else
          throw 'edges: Wrong arguments.';

      return a;
    }

    throw 'edges: Wrong arguments.';
  });


  /**
   * EXPORT:
   * *******
   */
  if (typeof sigma !== 'undefined') {
    sigma.classes = sigma.classes || Object.create(null);
    sigma.classes.graph = graph;
  } else if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports)
      exports = module.exports = graph;
    exports.graph = graph;
  } else
    this.graph = graph;
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  sigma.utils.pkg('sigma.classes');

  /**
   * The camera constructor. It just initializes its attributes and methods.
   *
   * @param  {string}       id       The id.
   * @param  {sigma.classes.graph}  graph    The graph.
   * @param  {configurable} settings The settings function.
   * @param  {?object}      options  Eventually some overriding options.
   * @return {camera}                Returns the fresh new camera instance.
   */
  sigma.classes.camera = function(id, graph, settings, options) {
    sigma.classes.dispatcher.extend(this);

    Object.defineProperty(this, 'graph', {
      value: graph
    });
    Object.defineProperty(this, 'id', {
      value: id
    });
    Object.defineProperty(this, 'readPrefix', {
      value: 'read_cam' + id + ':'
    });
    Object.defineProperty(this, 'prefix', {
      value: 'cam' + id + ':'
    });

    this.x = 0;
    this.y = 0;
    this.ratio = 1;
    this.angle = 0;
    this.isAnimated = false;
    this.settings = (typeof options === 'object' && options) ?
      settings.embedObject(options) :
      settings;
  };

  /**
   * Updates the camera position.
   *
   * @param  {object} coordinates The new coordinates object.
   * @return {camera}             Returns the camera.
   */
  sigma.classes.camera.prototype.goTo = function(coordinates) {
    if (!this.settings('enableCamera'))
      return this;

    var i,
        l,
        c = coordinates || {},
        keys = ['x', 'y', 'ratio', 'angle'];

    for (i = 0, l = keys.length; i < l; i++)
      if (c[keys[i]] !== undefined) {
        if (typeof c[keys[i]] === 'number' && !isNaN(c[keys[i]]))
          this[keys[i]] = c[keys[i]];
        else
          throw 'Value for "' + keys[i] + '" is not a number.';
      }

    this.dispatchEvent('coordinatesUpdated');
    return this;
  };

  /**
   * This method takes a graph and computes for each node and edges its
   * coordinates relatively to the center of the camera. Basically, it will
   * compute the coordinates that will be used by the graphic renderers.
   *
   * Since it should be possible to use different cameras and different
   * renderers, it is possible to specify a prefix to put before the new
   * coordinates (to get something like "node.camera1_x")
   *
   * @param  {?string} read    The prefix of the coordinates to read.
   * @param  {?string} write   The prefix of the coordinates to write.
   * @param  {?object} options Eventually an object of options. Those can be:
   *                           - A restricted nodes array.
   *                           - A restricted edges array.
   *                           - A width.
   *                           - A height.
   * @return {camera}        Returns the camera.
   */
  sigma.classes.camera.prototype.applyView = function(read, write, options) {
    options = options || {};
    write = write !== undefined ? write : this.prefix;
    read = read !== undefined ? read : this.readPrefix;

    var nodes = options.nodes || this.graph.nodes(),
        edges = options.edges || this.graph.edges();

    var i,
        l,
        node,
        relCos = Math.cos(this.angle) / this.ratio,
        relSin = Math.sin(this.angle) / this.ratio,
        nodeRatio = Math.pow(this.ratio, this.settings('nodesPowRatio')),
        edgeRatio = Math.pow(this.ratio, this.settings('edgesPowRatio')),
        xOffset = (options.width || 0) / 2 - this.x * relCos - this.y * relSin,
        yOffset = (options.height || 0) / 2 - this.y * relCos + this.x * relSin;

    for (i = 0, l = nodes.length; i < l; i++) {
      node = nodes[i];
      node[write + 'x'] =
        (node[read + 'x'] || 0) * relCos +
        (node[read + 'y'] || 0) * relSin +
        xOffset;
      node[write + 'y'] =
        (node[read + 'y'] || 0) * relCos -
        (node[read + 'x'] || 0) * relSin +
        yOffset;
      node[write + 'size'] =
        (node[read + 'size'] || 0) /
        nodeRatio;
    }

    for (i = 0, l = edges.length; i < l; i++) {
      edges[i][write + 'size'] =
        (edges[i][read + 'size'] || 0) /
        edgeRatio;
    }

    return this;
  };

  /**
   * This function converts the coordinates of a point from the frame of the
   * camera to the frame of the graph.
   *
   * @param  {number} x The X coordinate of the point in the frame of the
   *                    camera.
   * @param  {number} y The Y coordinate of the point in the frame of the
   *                    camera.
   * @return {object}   The point coordinates in the frame of the graph.
   */
  sigma.classes.camera.prototype.graphPosition = function(x, y, vector) {
    var X = 0,
        Y = 0,
        cos = Math.cos(this.angle),
        sin = Math.sin(this.angle);

    // Revert the origin differential vector:
    if (!vector) {
      X = - (this.x * cos + this.y * sin) / this.ratio;
      Y = - (this.y * cos - this.x * sin) / this.ratio;
    }

    return {
      x: (x * cos + y * sin) / this.ratio + X,
      y: (y * cos - x * sin) / this.ratio + Y
    };
  };

  /**
   * This function converts the coordinates of a point from the frame of the
   * graph to the frame of the camera.
   *
   * @param  {number} x The X coordinate of the point in the frame of the
   *                    graph.
   * @param  {number} y The Y coordinate of the point in the frame of the
   *                    graph.
   * @return {object}   The point coordinates in the frame of the camera.
   */
  sigma.classes.camera.prototype.cameraPosition = function(x, y, vector) {
    var X = 0,
        Y = 0,
        cos = Math.cos(this.angle),
        sin = Math.sin(this.angle);

    // Revert the origin differential vector:
    if (!vector) {
      X = - (this.x * cos + this.y * sin) / this.ratio;
      Y = - (this.y * cos - this.x * sin) / this.ratio;
    }

    return {
      x: ((x - X) * cos - (y - Y) * sin) * this.ratio,
      y: ((y - Y) * cos + (x - X) * sin) * this.ratio
    };
  };

  /**
   * This method returns the transformation matrix of the camera. This is
   * especially useful to apply the camera view directly in shaders, in case of
   * WebGL rendering.
   *
   * @return {array} The transformation matrix.
   */
  sigma.classes.camera.prototype.getMatrix = function() {
    var scale = sigma.utils.matrices.scale(1 / this.ratio),
        rotation = sigma.utils.matrices.rotation(this.angle),
        translation = sigma.utils.matrices.translation(-this.x, -this.y),
        matrix = sigma.utils.matrices.multiply(
          translation,
          sigma.utils.matrices.multiply(
            rotation,
            scale
          )
        );

    return matrix;
  };

  /**
   * Taking a width and a height as parameters, this method returns the
   * coordinates of the rectangle representing the camera on screen, in the
   * graph's referentiel.
   *
   * To keep displaying labels of nodes going out of the screen, the method
   * keeps a margin around the screen in the returned rectangle.
   *
   * @param  {number} width  The width of the screen.
   * @param  {number} height The height of the screen.
   * @return {object}        The rectangle as x1, y1, x2 and y2, representing
   *                         two opposite points.
   */
  sigma.classes.camera.prototype.getRectangle = function(width, height) {
    var widthVect = this.cameraPosition(width, 0, true),
        heightVect = this.cameraPosition(0, height, true),
        centerVect = this.cameraPosition(width / 2, height / 2, true),
        marginX = this.cameraPosition(width / 4, 0, true).x,
        marginY = this.cameraPosition(0, height / 4, true).y;

    return {
      x1: this.x - centerVect.x - marginX,
      y1: this.y - centerVect.y - marginY,
      x2: this.x - centerVect.x + marginX + widthVect.x,
      y2: this.y - centerVect.y - marginY + widthVect.y,
      height: Math.sqrt(
        Math.pow(heightVect.x, 2) +
        Math.pow(heightVect.y + 2 * marginY, 2)
      )
    };
  };
}).call(this);

;(function(undefined) {
  'use strict';

  /**
   * Sigma Quadtree Module
   * =====================
   *
   * Author: Guillaume Plique (Yomguithereal)
   * Version: 0.2
   */



  /**
   * Quad Geometric Operations
   * -------------------------
   *
   * A useful batch of geometric operations used by the quadtree.
   */

  var _geom = {

    /**
     * Transforms a graph node with x, y and size into an
     * axis-aligned square.
     *
     * @param  {object} A graph node with at least a point (x, y) and a size.
     * @return {object} A square: two points (x1, y1), (x2, y2) and height.
     */
    pointToSquare: function(n) {
      return {
        x1: n.x - n.size,
        y1: n.y - n.size,
        x2: n.x + n.size,
        y2: n.y - n.size,
        height: n.size * 2
      };
    },

    /**
     * Checks whether a rectangle is axis-aligned.
     *
     * @param  {object}  A rectangle defined by two points
     *                   (x1, y1) and (x2, y2).
     * @return {boolean} True if the rectangle is axis-aligned.
     */
    isAxisAligned: function(r) {
      return r.x1 === r.x2 || r.y1 === r.y2;
    },

    /**
     * Compute top points of an axis-aligned rectangle. This is useful in
     * cases when the rectangle has been rotated (left, right or bottom up) and
     * later operations need to know the top points.
     *
     * @param  {object} An axis-aligned rectangle defined by two points
     *                  (x1, y1), (x2, y2) and height.
     * @return {object} A rectangle: two points (x1, y1), (x2, y2) and height.
     */
    axisAlignedTopPoints: function(r) {

      // Basic
      if (r.y1 === r.y2 && r.x1 < r.x2)
        return r;

      // Rotated to right
      if (r.x1 === r.x2 && r.y2 > r.y1)
        return {
          x1: r.x1 - r.height, y1: r.y1,
          x2: r.x1, y2: r.y1,
          height: r.height
        };

      // Rotated to left
      if (r.x1 === r.x2 && r.y2 < r.y1)
        return {
          x1: r.x1, y1: r.y2,
          x2: r.x2 + r.height, y2: r.y2,
          height: r.height
        };

      // Bottom's up
      return {
        x1: r.x2, y1: r.y1 - r.height,
        x2: r.x1, y2: r.y1 - r.height,
        height: r.height
      };
    },

    /**
     * Get coordinates of a rectangle's lower left corner from its top points.
     *
     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).
     * @return {object} Coordinates of the corner (x, y).
     */
    lowerLeftCoor: function(r) {
      var width = (
        Math.sqrt(
          Math.pow(r.x2 - r.x1, 2) +
          Math.pow(r.y2 - r.y1, 2)
        )
      );

      return {
        x: r.x1 - (r.y2 - r.y1) * r.height / width,
        y: r.y1 + (r.x2 - r.x1) * r.height / width
      };
    },

    /**
     * Get coordinates of a rectangle's lower right corner from its top points
     * and its lower left corner.
     *
     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).
     * @param  {object} A corner's coordinates (x, y).
     * @return {object} Coordinates of the corner (x, y).
     */
    lowerRightCoor: function(r, llc) {
      return {
        x: llc.x - r.x1 + r.x2,
        y: llc.y - r.y1 + r.y2
      };
    },

    /**
     * Get the coordinates of all the corners of a rectangle from its top point.
     *
     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).
     * @return {array}  An array of the four corners' coordinates (x, y).
     */
    rectangleCorners: function(r) {
      var llc = this.lowerLeftCoor(r),
          lrc = this.lowerRightCoor(r, llc);

      return [
        {x: r.x1, y: r.y1},
        {x: r.x2, y: r.y2},
        {x: llc.x, y: llc.y},
        {x: lrc.x, y: lrc.y}
      ];
    },

    /**
     * Split a square defined by its boundaries into four.
     *
     * @param  {object} Boundaries of the square (x, y, width, height).
     * @return {array}  An array containing the four new squares, themselves
     *                  defined by an array of their four corners (x, y).
     */
    splitSquare: function(b) {
      return [
        [
          {x: b.x, y: b.y},
          {x: b.x + b.width / 2, y: b.y},
          {x: b.x, y: b.y + b.height / 2},
          {x: b.x + b.width / 2, y: b.y + b.height / 2}
        ],
        [
          {x: b.x + b.width / 2, y: b.y},
          {x: b.x + b.width, y: b.y},
          {x: b.x + b.width / 2, y: b.y + b.height / 2},
          {x: b.x + b.width, y: b.y + b.height / 2}
        ],
        [
          {x: b.x, y: b.y + b.height / 2},
          {x: b.x + b.width / 2, y: b.y + b.height / 2},
          {x: b.x, y: b.y + b.height},
          {x: b.x + b.width / 2, y: b.y + b.height}
        ],
        [
          {x: b.x + b.width / 2, y: b.y + b.height / 2},
          {x: b.x + b.width, y: b.y + b.height / 2},
          {x: b.x + b.width / 2, y: b.y + b.height},
          {x: b.x + b.width, y: b.y + b.height}
        ]
      ];
    },

    /**
     * Compute the four axis between corners of rectangle A and corners of
     * rectangle B. This is needed later to check an eventual collision.
     *
     * @param  {array} An array of rectangle A's four corners (x, y).
     * @param  {array} An array of rectangle B's four corners (x, y).
     * @return {array} An array of four axis defined by their coordinates (x,y).
     */
    axis: function(c1, c2) {
      return [
        {x: c1[1].x - c1[0].x, y: c1[1].y - c1[0].y},
        {x: c1[1].x - c1[3].x, y: c1[1].y - c1[3].y},
        {x: c2[0].x - c2[2].x, y: c2[0].y - c2[2].y},
        {x: c2[0].x - c2[1].x, y: c2[0].y - c2[1].y}
      ];
    },

    /**
     * Project a rectangle's corner on an axis.
     *
     * @param  {object} Coordinates of a corner (x, y).
     * @param  {object} Coordinates of an axis (x, y).
     * @return {object} The projection defined by coordinates (x, y).
     */
    projection: function(c, a) {
      var l = (
        (c.x * a.x + c.y * a.y) /
        (Math.pow(a.x, 2) + Math.pow(a.y, 2))
      );

      return {
        x: l * a.x,
        y: l * a.y
      };
    },

    /**
     * Check whether two rectangles collide on one particular axis.
     *
     * @param  {object}   An axis' coordinates (x, y).
     * @param  {array}    Rectangle A's corners.
     * @param  {array}    Rectangle B's corners.
     * @return {boolean}  True if the rectangles collide on the axis.
     */
    axisCollision: function(a, c1, c2) {
      var sc1 = [],
          sc2 = [];

      for (var ci = 0; ci < 4; ci++) {
        var p1 = this.projection(c1[ci], a),
            p2 = this.projection(c2[ci], a);

        sc1.push(p1.x * a.x + p1.y * a.y);
        sc2.push(p2.x * a.x + p2.y * a.y);
      }

      var maxc1 = Math.max.apply(Math, sc1),
          maxc2 = Math.max.apply(Math, sc2),
          minc1 = Math.min.apply(Math, sc1),
          minc2 = Math.min.apply(Math, sc2);

      return (minc2 <= maxc1 && maxc2 >= minc1);
    },

    /**
     * Check whether two rectangles collide on each one of their four axis. If
     * all axis collide, then the two rectangles do collide on the plane.
     *
     * @param  {array}    Rectangle A's corners.
     * @param  {array}    Rectangle B's corners.
     * @return {boolean}  True if the rectangles collide.
     */
    collision: function(c1, c2) {
      var axis = this.axis(c1, c2),
          col = true;

      for (var i = 0; i < 4; i++)
        col = col && this.axisCollision(axis[i], c1, c2);

      return col;
    }
  };


  /**
   * Quad Functions
   * ------------
   *
   * The Quadtree functions themselves.
   * For each of those functions, we consider that in a splitted quad, the
   * index of each node is the following:
   * 0: top left
   * 1: top right
   * 2: bottom left
   * 3: bottom right
   *
   * Moreover, the hereafter quad's philosophy is to consider that if an element
   * collides with more than one nodes, this element belongs to each of the
   * nodes it collides with where other would let it lie on a higher node.
   */

  /**
   * Get the index of the node containing the point in the quad
   *
   * @param  {object}  point      A point defined by coordinates (x, y).
   * @param  {object}  quadBounds Boundaries of the quad (x, y, width, heigth).
   * @return {integer}            The index of the node containing the point.
   */
  function _quadIndex(point, quadBounds) {
    var xmp = quadBounds.x + quadBounds.width / 2,
        ymp = quadBounds.y + quadBounds.height / 2,
        top = (point.y < ymp),
        left = (point.x < xmp);

    if (top) {
      if (left)
        return 0;
      else
        return 1;
    }
    else {
      if (left)
        return 2;
      else
        return 3;
    }
  }

  /**
   * Get a list of indexes of nodes containing an axis-aligned rectangle
   *
   * @param  {object}  rectangle   A rectangle defined by two points (x1, y1),
   *                               (x2, y2) and height.
   * @param  {array}   quadCorners An array of the quad nodes' corners.
   * @return {array}               An array of indexes containing one to
   *                               four integers.
   */
  function _quadIndexes(rectangle, quadCorners) {
    var indexes = [];

    // Iterating through quads
    for (var i = 0; i < 4; i++)
      if ((rectangle.x2 >= quadCorners[i][0].x) &&
          (rectangle.x1 <= quadCorners[i][1].x) &&
          (rectangle.y1 + rectangle.height >= quadCorners[i][0].y) &&
          (rectangle.y1 <= quadCorners[i][2].y))
        indexes.push(i);

    return indexes;
  }

  /**
   * Get a list of indexes of nodes containing a non-axis-aligned rectangle
   *
   * @param  {array}  corners      An array containing each corner of the
   *                               rectangle defined by its coordinates (x, y).
   * @param  {array}  quadCorners  An array of the quad nodes' corners.
   * @return {array}               An array of indexes containing one to
   *                               four integers.
   */
  function _quadCollision(corners, quadCorners) {
    var indexes = [];

    // Iterating through quads
    for (var i = 0; i < 4; i++)
      if (_geom.collision(corners, quadCorners[i]))
        indexes.push(i);

    return indexes;
  }

  /**
   * Subdivide a quad by creating a node at a precise index. The function does
   * not generate all four nodes not to potentially create unused nodes.
   *
   * @param  {integer}  index The index of the node to create.
   * @param  {object}   quad  The quad object to subdivide.
   * @return {object}         A new quad representing the node created.
   */
  function _quadSubdivide(index, quad) {
    var next = quad.level + 1,
        subw = Math.round(quad.bounds.width / 2),
        subh = Math.round(quad.bounds.height / 2),
        qx = Math.round(quad.bounds.x),
        qy = Math.round(quad.bounds.y),
        x,
        y;

    switch (index) {
      case 0:
        x = qx;
        y = qy;
        break;
      case 1:
        x = qx + subw;
        y = qy;
        break;
      case 2:
        x = qx;
        y = qy + subh;
        break;
      case 3:
        x = qx + subw;
        y = qy + subh;
        break;
    }

    return _quadTree(
      {x: x, y: y, width: subw, height: subh},
      next,
      quad.maxElements,
      quad.maxLevel
    );
  }

  /**
   * Recursively insert an element into the quadtree. Only points
   * with size, i.e. axis-aligned squares, may be inserted with this
   * method.
   *
   * @param  {object}  el         The element to insert in the quadtree.
   * @param  {object}  sizedPoint A sized point defined by two top points
   *                              (x1, y1), (x2, y2) and height.
   * @param  {object}  quad       The quad in which to insert the element.
   * @return {undefined}          The function does not return anything.
   */
  function _quadInsert(el, sizedPoint, quad) {
    if (quad.level < quad.maxLevel) {

      // Searching appropriate quads
      var indexes = _quadIndexes(sizedPoint, quad.corners);

      // Iterating
      for (var i = 0, l = indexes.length; i < l; i++) {

        // Subdividing if necessary
        if (quad.nodes[indexes[i]] === undefined)
          quad.nodes[indexes[i]] = _quadSubdivide(indexes[i], quad);

        // Recursion
        _quadInsert(el, sizedPoint, quad.nodes[indexes[i]]);
      }
    }
    else {

      // Pushing the element in a leaf node
      quad.elements.push(el);
    }
  }

  /**
   * Recursively retrieve every elements held by the node containing the
   * searched point.
   *
   * @param  {object}  point The searched point (x, y).
   * @param  {object}  quad  The searched quad.
   * @return {array}         An array of elements contained in the relevant
   *                         node.
   */
  function _quadRetrievePoint(point, quad) {
    if (quad.level < quad.maxLevel) {
      var index = _quadIndex(point, quad.bounds);

      // If node does not exist we return an empty list
      if (quad.nodes[index] !== undefined) {
        return _quadRetrievePoint(point, quad.nodes[index]);
      }
      else {
        return [];
      }
    }
    else {
      return quad.elements;
    }
  }

  /**
   * Recursively retrieve every elements contained within an rectangular area
   * that may or may not be axis-aligned.
   *
   * @param  {object|array} rectData       The searched area defined either by
   *                                       an array of four corners (x, y) in
   *                                       the case of a non-axis-aligned
   *                                       rectangle or an object with two top
   *                                       points (x1, y1), (x2, y2) and height.
   * @param  {object}       quad           The searched quad.
   * @param  {function}     collisionFunc  The collision function used to search
   *                                       for node indexes.
   * @param  {array?}       els            The retrieved elements.
   * @return {array}                       An array of elements contained in the
   *                                       area.
   */
  function _quadRetrieveArea(rectData, quad, collisionFunc, els) {
    els = els || {};

    if (quad.level < quad.maxLevel) {
      var indexes = collisionFunc(rectData, quad.corners);

      for (var i = 0, l = indexes.length; i < l; i++)
        if (quad.nodes[indexes[i]] !== undefined)
          _quadRetrieveArea(
            rectData,
            quad.nodes[indexes[i]],
            collisionFunc,
            els
          );
    } else
      for (var j = 0, m = quad.elements.length; j < m; j++)
        if (els[quad.elements[j].id] === undefined)
          els[quad.elements[j].id] = quad.elements[j];

    return els;
  }

  /**
   * Creates the quadtree object itself.
   *
   * @param  {object}   bounds       The boundaries of the quad defined by an
   *                                 origin (x, y), width and heigth.
   * @param  {integer}  level        The level of the quad in the tree.
   * @param  {integer}  maxElements  The max number of element in a leaf node.
   * @param  {integer}  maxLevel     The max recursion level of the tree.
   * @return {object}                The quadtree object.
   */
  function _quadTree(bounds, level, maxElements, maxLevel) {
    return {
      level: level || 0,
      bounds: bounds,
      corners: _geom.splitSquare(bounds),
      maxElements: maxElements || 20,
      maxLevel: maxLevel || 4,
      elements: [],
      nodes: []
    };
  }


  /**
   * Sigma Quad Constructor
   * ----------------------
   *
   * The quad API as exposed to sigma.
   */

  /**
   * The quad core that will become the sigma interface with the quadtree.
   *
   * property {object} _tree  Property holding the quadtree object.
   * property {object} _geom  Exposition of the _geom namespace for testing.
   * property {object} _cache Cache for the area method.
   */
  var quad = function() {
    this._geom = _geom;
    this._tree = null;
    this._cache = {
      query: false,
      result: false
    };
  };

  /**
   * Index a graph by inserting its nodes into the quadtree.
   *
   * @param  {array}  nodes   An array of nodes to index.
   * @param  {object} params  An object of parameters with at least the quad
   *                          bounds.
   * @return {object}         The quadtree object.
   *
   * Parameters:
   * ----------
   * bounds:      {object}   boundaries of the quad defined by its origin (x, y)
   *                         width and heigth.
   * prefix:      {string?}  a prefix for node geometric attributes.
   * maxElements: {integer?} the max number of elements in a leaf node.
   * maxLevel:    {integer?} the max recursion level of the tree.
   */
  quad.prototype.index = function(nodes, params) {

    // Enforcing presence of boundaries
    if (!params.bounds)
      throw 'sigma.classes.quad.index: bounds information not given.';

    // Prefix
    var prefix = params.prefix || '';

    // Building the tree
    this._tree = _quadTree(
      params.bounds,
      0,
      params.maxElements,
      params.maxLevel
    );

    // Inserting graph nodes into the tree
    for (var i = 0, l = nodes.length; i < l; i++) {

      // Inserting node
      _quadInsert(
        nodes[i],
        _geom.pointToSquare({
          x: nodes[i][prefix + 'x'],
          y: nodes[i][prefix + 'y'],
          size: nodes[i][prefix + 'size']
        }),
        this._tree
      );
    }

    // Reset cache:
    this._cache = {
      query: false,
      result: false
    };

    // remove?
    return this._tree;
  };

  /**
   * Retrieve every graph nodes held by the quadtree node containing the
   * searched point.
   *
   * @param  {number} x of the point.
   * @param  {number} y of the point.
   * @return {array}  An array of nodes retrieved.
   */
  quad.prototype.point = function(x, y) {
    return this._tree ?
      _quadRetrievePoint({x: x, y: y}, this._tree) || [] :
      [];
  };

  /**
   * Retrieve every graph nodes within a rectangular area. The methods keep the
   * last area queried in cache for optimization reason and will act differently
   * for the same reason if the area is axis-aligned or not.
   *
   * @param  {object} A rectangle defined by two top points (x1, y1), (x2, y2)
   *                  and height.
   * @return {array}  An array of nodes retrieved.
   */
  quad.prototype.area = function(rect) {
    var serialized = JSON.stringify(rect),
        collisionFunc,
        rectData;

    // Returning cache?
    if (this._cache.query === serialized)
      return this._cache.result;

    // Axis aligned ?
    if (_geom.isAxisAligned(rect)) {
      collisionFunc = _quadIndexes;
      rectData = _geom.axisAlignedTopPoints(rect);
    }
    else {
      collisionFunc = _quadCollision;
      rectData = _geom.rectangleCorners(rect);
    }

    // Retrieving nodes
    var nodes = this._tree ?
      _quadRetrieveArea(
        rectData,
        this._tree,
        collisionFunc
      ) :
      [];

    // Object to array
    var nodesArray = [];
    for (var i in nodes)
      nodesArray.push(nodes[i]);

    // Caching
    this._cache.query = serialized;
    this._cache.result = nodesArray;

    return nodesArray;
  };


  /**
   * EXPORT:
   * *******
   */
  if (typeof this.sigma !== 'undefined') {
    this.sigma.classes = this.sigma.classes || {};
    this.sigma.classes.quad = quad;
  } else if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports)
      exports = module.exports = quad;
    exports.quad = quad;
  } else
    this.quad = quad;
}).call(this);

;(function(undefined) {
  'use strict';

  /**
   * Sigma Quadtree Module for edges
   * ===============================
   *
   * Author: SÃ©bastien Heymann,
   *   from the quad of Guillaume Plique (Yomguithereal)
   * Version: 0.2
   */



  /**
   * Quad Geometric Operations
   * -------------------------
   *
   * A useful batch of geometric operations used by the quadtree.
   */

  var _geom = {

    /**
     * Transforms a graph node with x, y and size into an
     * axis-aligned square.
     *
     * @param  {object} A graph node with at least a point (x, y) and a size.
     * @return {object} A square: two points (x1, y1), (x2, y2) and height.
     */
    pointToSquare: function(n) {
      return {
        x1: n.x - n.size,
        y1: n.y - n.size,
        x2: n.x + n.size,
        y2: n.y - n.size,
        height: n.size * 2
      };
    },

    /**
     * Transforms a graph edge with x1, y1, x2, y2 and size into an
     * axis-aligned square.
     *
     * @param  {object} A graph edge with at least two points
     *                  (x1, y1), (x2, y2) and a size.
     * @return {object} A square: two points (x1, y1), (x2, y2) and height.
     */
    lineToSquare: function(e) {
      if (e.y1 < e.y2) {
        // (e.x1, e.y1) on top
        if (e.x1 < e.x2) {
          // (e.x1, e.y1) on left
          return {
            x1: e.x1 - e.size,
            y1: e.y1 - e.size,
            x2: e.x2 + e.size,
            y2: e.y1 - e.size,
            height: e.y2 - e.y1 + e.size * 2
          };
        }
        // (e.x1, e.y1) on right
        return {
          x1: e.x2 - e.size,
          y1: e.y1 - e.size,
          x2: e.x1 + e.size,
          y2: e.y1 - e.size,
          height: e.y2 - e.y1 + e.size * 2
        };
      }

      // (e.x2, e.y2) on top
      if (e.x1 < e.x2) {
        // (e.x1, e.y1) on left
        return {
          x1: e.x1 - e.size,
          y1: e.y2 - e.size,
          x2: e.x2 + e.size,
          y2: e.y2 - e.size,
          height: e.y1 - e.y2 + e.size * 2
        };
      }
      // (e.x2, e.y2) on right
      return {
        x1: e.x2 - e.size,
        y1: e.y2 - e.size,
        x2: e.x1 + e.size,
        y2: e.y2 - e.size,
        height: e.y1 - e.y2 + e.size * 2
      };
    },

    /**
     * Transforms a graph edge of type 'curve' with x1, y1, x2, y2,
     * control point and size into an axis-aligned square.
     *
     * @param  {object} e  A graph edge with at least two points
     *                     (x1, y1), (x2, y2) and a size.
     * @param  {object} cp A control point (x,y).
     * @return {object}    A square: two points (x1, y1), (x2, y2) and height.
     */
    quadraticCurveToSquare: function(e, cp) {
      var pt = sigma.utils.getPointOnQuadraticCurve(
        0.5,
        e.x1,
        e.y1,
        e.x2,
        e.y2,
        cp.x,
        cp.y
      );

      // Bounding box of the two points and the point at the middle of the
      // curve:
      var minX = Math.min(e.x1, e.x2, pt.x),
          maxX = Math.max(e.x1, e.x2, pt.x),
          minY = Math.min(e.y1, e.y2, pt.y),
          maxY = Math.max(e.y1, e.y2, pt.y);

      return {
        x1: minX - e.size,
        y1: minY - e.size,
        x2: maxX + e.size,
        y2: minY - e.size,
        height: maxY - minY + e.size * 2
      };
    },

    /**
     * Transforms a graph self loop into an axis-aligned square.
     *
     * @param  {object} n A graph node with a point (x, y) and a size.
     * @return {object}   A square: two points (x1, y1), (x2, y2) and height.
     */
    selfLoopToSquare: function(n) {
      // Fitting to the curve is too costly, we compute a larger bounding box
      // using the control points:
      var cp = sigma.utils.getSelfLoopControlPoints(n.x, n.y, n.size);

      // Bounding box of the point and the two control points:
      var minX = Math.min(n.x, cp.x1, cp.x2),
          maxX = Math.max(n.x, cp.x1, cp.x2),
          minY = Math.min(n.y, cp.y1, cp.y2),
          maxY = Math.max(n.y, cp.y1, cp.y2);

      return {
        x1: minX - n.size,
        y1: minY - n.size,
        x2: maxX + n.size,
        y2: minY - n.size,
        height: maxY - minY + n.size * 2
      };
    },

    /**
     * Checks whether a rectangle is axis-aligned.
     *
     * @param  {object}  A rectangle defined by two points
     *                   (x1, y1) and (x2, y2).
     * @return {boolean} True if the rectangle is axis-aligned.
     */
    isAxisAligned: function(r) {
      return r.x1 === r.x2 || r.y1 === r.y2;
    },

    /**
     * Compute top points of an axis-aligned rectangle. This is useful in
     * cases when the rectangle has been rotated (left, right or bottom up) and
     * later operations need to know the top points.
     *
     * @param  {object} An axis-aligned rectangle defined by two points
     *                  (x1, y1), (x2, y2) and height.
     * @return {object} A rectangle: two points (x1, y1), (x2, y2) and height.
     */
    axisAlignedTopPoints: function(r) {

      // Basic
      if (r.y1 === r.y2 && r.x1 < r.x2)
        return r;

      // Rotated to right
      if (r.x1 === r.x2 && r.y2 > r.y1)
        return {
          x1: r.x1 - r.height, y1: r.y1,
          x2: r.x1, y2: r.y1,
          height: r.height
        };

      // Rotated to left
      if (r.x1 === r.x2 && r.y2 < r.y1)
        return {
          x1: r.x1, y1: r.y2,
          x2: r.x2 + r.height, y2: r.y2,
          height: r.height
        };

      // Bottom's up
      return {
        x1: r.x2, y1: r.y1 - r.height,
        x2: r.x1, y2: r.y1 - r.height,
        height: r.height
      };
    },

    /**
     * Get coordinates of a rectangle's lower left corner from its top points.
     *
     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).
     * @return {object} Coordinates of the corner (x, y).
     */
    lowerLeftCoor: function(r) {
      var width = (
        Math.sqrt(
          Math.pow(r.x2 - r.x1, 2) +
          Math.pow(r.y2 - r.y1, 2)
        )
      );

      return {
        x: r.x1 - (r.y2 - r.y1) * r.height / width,
        y: r.y1 + (r.x2 - r.x1) * r.height / width
      };
    },

    /**
     * Get coordinates of a rectangle's lower right corner from its top points
     * and its lower left corner.
     *
     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).
     * @param  {object} A corner's coordinates (x, y).
     * @return {object} Coordinates of the corner (x, y).
     */
    lowerRightCoor: function(r, llc) {
      return {
        x: llc.x - r.x1 + r.x2,
        y: llc.y - r.y1 + r.y2
      };
    },

    /**
     * Get the coordinates of all the corners of a rectangle from its top point.
     *
     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).
     * @return {array}  An array of the four corners' coordinates (x, y).
     */
    rectangleCorners: function(r) {
      var llc = this.lowerLeftCoor(r),
          lrc = this.lowerRightCoor(r, llc);

      return [
        {x: r.x1, y: r.y1},
        {x: r.x2, y: r.y2},
        {x: llc.x, y: llc.y},
        {x: lrc.x, y: lrc.y}
      ];
    },

    /**
     * Split a square defined by its boundaries into four.
     *
     * @param  {object} Boundaries of the square (x, y, width, height).
     * @return {array}  An array containing the four new squares, themselves
     *                  defined by an array of their four corners (x, y).
     */
    splitSquare: function(b) {
      return [
        [
          {x: b.x, y: b.y},
          {x: b.x + b.width / 2, y: b.y},
          {x: b.x, y: b.y + b.height / 2},
          {x: b.x + b.width / 2, y: b.y + b.height / 2}
        ],
        [
          {x: b.x + b.width / 2, y: b.y},
          {x: b.x + b.width, y: b.y},
          {x: b.x + b.width / 2, y: b.y + b.height / 2},
          {x: b.x + b.width, y: b.y + b.height / 2}
        ],
        [
          {x: b.x, y: b.y + b.height / 2},
          {x: b.x + b.width / 2, y: b.y + b.height / 2},
          {x: b.x, y: b.y + b.height},
          {x: b.x + b.width / 2, y: b.y + b.height}
        ],
        [
          {x: b.x + b.width / 2, y: b.y + b.height / 2},
          {x: b.x + b.width, y: b.y + b.height / 2},
          {x: b.x + b.width / 2, y: b.y + b.height},
          {x: b.x + b.width, y: b.y + b.height}
        ]
      ];
    },

    /**
     * Compute the four axis between corners of rectangle A and corners of
     * rectangle B. This is needed later to check an eventual collision.
     *
     * @param  {array} An array of rectangle A's four corners (x, y).
     * @param  {array} An array of rectangle B's four corners (x, y).
     * @return {array} An array of four axis defined by their coordinates (x,y).
     */
    axis: function(c1, c2) {
      return [
        {x: c1[1].x - c1[0].x, y: c1[1].y - c1[0].y},
        {x: c1[1].x - c1[3].x, y: c1[1].y - c1[3].y},
        {x: c2[0].x - c2[2].x, y: c2[0].y - c2[2].y},
        {x: c2[0].x - c2[1].x, y: c2[0].y - c2[1].y}
      ];
    },

    /**
     * Project a rectangle's corner on an axis.
     *
     * @param  {object} Coordinates of a corner (x, y).
     * @param  {object} Coordinates of an axis (x, y).
     * @return {object} The projection defined by coordinates (x, y).
     */
    projection: function(c, a) {
      var l = (
        (c.x * a.x + c.y * a.y) /
        (Math.pow(a.x, 2) + Math.pow(a.y, 2))
      );

      return {
        x: l * a.x,
        y: l * a.y
      };
    },

    /**
     * Check whether two rectangles collide on one particular axis.
     *
     * @param  {object}   An axis' coordinates (x, y).
     * @param  {array}    Rectangle A's corners.
     * @param  {array}    Rectangle B's corners.
     * @return {boolean}  True if the rectangles collide on the axis.
     */
    axisCollision: function(a, c1, c2) {
      var sc1 = [],
          sc2 = [];

      for (var ci = 0; ci < 4; ci++) {
        var p1 = this.projection(c1[ci], a),
            p2 = this.projection(c2[ci], a);

        sc1.push(p1.x * a.x + p1.y * a.y);
        sc2.push(p2.x * a.x + p2.y * a.y);
      }

      var maxc1 = Math.max.apply(Math, sc1),
          maxc2 = Math.max.apply(Math, sc2),
          minc1 = Math.min.apply(Math, sc1),
          minc2 = Math.min.apply(Math, sc2);

      return (minc2 <= maxc1 && maxc2 >= minc1);
    },

    /**
     * Check whether two rectangles collide on each one of their four axis. If
     * all axis collide, then the two rectangles do collide on the plane.
     *
     * @param  {array}    Rectangle A's corners.
     * @param  {array}    Rectangle B's corners.
     * @return {boolean}  True if the rectangles collide.
     */
    collision: function(c1, c2) {
      var axis = this.axis(c1, c2),
          col = true;

      for (var i = 0; i < 4; i++)
        col = col && this.axisCollision(axis[i], c1, c2);

      return col;
    }
  };


  /**
   * Quad Functions
   * ------------
   *
   * The Quadtree functions themselves.
   * For each of those functions, we consider that in a splitted quad, the
   * index of each node is the following:
   * 0: top left
   * 1: top right
   * 2: bottom left
   * 3: bottom right
   *
   * Moreover, the hereafter quad's philosophy is to consider that if an element
   * collides with more than one nodes, this element belongs to each of the
   * nodes it collides with where other would let it lie on a higher node.
   */

  /**
   * Get the index of the node containing the point in the quad
   *
   * @param  {object}  point      A point defined by coordinates (x, y).
   * @param  {object}  quadBounds Boundaries of the quad (x, y, width, heigth).
   * @return {integer}            The index of the node containing the point.
   */
  function _quadIndex(point, quadBounds) {
    var xmp = quadBounds.x + quadBounds.width / 2,
        ymp = quadBounds.y + quadBounds.height / 2,
        top = (point.y < ymp),
        left = (point.x < xmp);

    if (top) {
      if (left)
        return 0;
      else
        return 1;
    }
    else {
      if (left)
        return 2;
      else
        return 3;
    }
  }

  /**
   * Get a list of indexes of nodes containing an axis-aligned rectangle
   *
   * @param  {object}  rectangle   A rectangle defined by two points (x1, y1),
   *                               (x2, y2) and height.
   * @param  {array}   quadCorners An array of the quad nodes' corners.
   * @return {array}               An array of indexes containing one to
   *                               four integers.
   */
  function _quadIndexes(rectangle, quadCorners) {
    var indexes = [];

    // Iterating through quads
    for (var i = 0; i < 4; i++)
      if ((rectangle.x2 >= quadCorners[i][0].x) &&
          (rectangle.x1 <= quadCorners[i][1].x) &&
          (rectangle.y1 + rectangle.height >= quadCorners[i][0].y) &&
          (rectangle.y1 <= quadCorners[i][2].y))
        indexes.push(i);

    return indexes;
  }

  /**
   * Get a list of indexes of nodes containing a non-axis-aligned rectangle
   *
   * @param  {array}  corners      An array containing each corner of the
   *                               rectangle defined by its coordinates (x, y).
   * @param  {array}  quadCorners  An array of the quad nodes' corners.
   * @return {array}               An array of indexes containing one to
   *                               four integers.
   */
  function _quadCollision(corners, quadCorners) {
    var indexes = [];

    // Iterating through quads
    for (var i = 0; i < 4; i++)
      if (_geom.collision(corners, quadCorners[i]))
        indexes.push(i);

    return indexes;
  }

  /**
   * Subdivide a quad by creating a node at a precise index. The function does
   * not generate all four nodes not to potentially create unused nodes.
   *
   * @param  {integer}  index The index of the node to create.
   * @param  {object}   quad  The quad object to subdivide.
   * @return {object}         A new quad representing the node created.
   */
  function _quadSubdivide(index, quad) {
    var next = quad.level + 1,
        subw = Math.round(quad.bounds.width / 2),
        subh = Math.round(quad.bounds.height / 2),
        qx = Math.round(quad.bounds.x),
        qy = Math.round(quad.bounds.y),
        x,
        y;

    switch (index) {
      case 0:
        x = qx;
        y = qy;
        break;
      case 1:
        x = qx + subw;
        y = qy;
        break;
      case 2:
        x = qx;
        y = qy + subh;
        break;
      case 3:
        x = qx + subw;
        y = qy + subh;
        break;
    }

    return _quadTree(
      {x: x, y: y, width: subw, height: subh},
      next,
      quad.maxElements,
      quad.maxLevel
    );
  }

  /**
   * Recursively insert an element into the quadtree. Only points
   * with size, i.e. axis-aligned squares, may be inserted with this
   * method.
   *
   * @param  {object}  el         The element to insert in the quadtree.
   * @param  {object}  sizedPoint A sized point defined by two top points
   *                              (x1, y1), (x2, y2) and height.
   * @param  {object}  quad       The quad in which to insert the element.
   * @return {undefined}          The function does not return anything.
   */
  function _quadInsert(el, sizedPoint, quad) {
    if (quad.level < quad.maxLevel) {

      // Searching appropriate quads
      var indexes = _quadIndexes(sizedPoint, quad.corners);

      // Iterating
      for (var i = 0, l = indexes.length; i < l; i++) {

        // Subdividing if necessary
        if (quad.nodes[indexes[i]] === undefined)
          quad.nodes[indexes[i]] = _quadSubdivide(indexes[i], quad);

        // Recursion
        _quadInsert(el, sizedPoint, quad.nodes[indexes[i]]);
      }
    }
    else {

      // Pushing the element in a leaf node
      quad.elements.push(el);
    }
  }

  /**
   * Recursively retrieve every elements held by the node containing the
   * searched point.
   *
   * @param  {object}  point The searched point (x, y).
   * @param  {object}  quad  The searched quad.
   * @return {array}         An array of elements contained in the relevant
   *                         node.
   */
  function _quadRetrievePoint(point, quad) {
    if (quad.level < quad.maxLevel) {
      var index = _quadIndex(point, quad.bounds);

      // If node does not exist we return an empty list
      if (quad.nodes[index] !== undefined) {
        return _quadRetrievePoint(point, quad.nodes[index]);
      }
      else {
        return [];
      }
    }
    else {
      return quad.elements;
    }
  }

  /**
   * Recursively retrieve every elements contained within an rectangular area
   * that may or may not be axis-aligned.
   *
   * @param  {object|array} rectData       The searched area defined either by
   *                                       an array of four corners (x, y) in
   *                                       the case of a non-axis-aligned
   *                                       rectangle or an object with two top
   *                                       points (x1, y1), (x2, y2) and height.
   * @param  {object}       quad           The searched quad.
   * @param  {function}     collisionFunc  The collision function used to search
   *                                       for node indexes.
   * @param  {array?}       els            The retrieved elements.
   * @return {array}                       An array of elements contained in the
   *                                       area.
   */
  function _quadRetrieveArea(rectData, quad, collisionFunc, els) {
    els = els || {};

    if (quad.level < quad.maxLevel) {
      var indexes = collisionFunc(rectData, quad.corners);

      for (var i = 0, l = indexes.length; i < l; i++)
        if (quad.nodes[indexes[i]] !== undefined)
          _quadRetrieveArea(
            rectData,
            quad.nodes[indexes[i]],
            collisionFunc,
            els
          );
    } else
      for (var j = 0, m = quad.elements.length; j < m; j++)
        if (els[quad.elements[j].id] === undefined)
          els[quad.elements[j].id] = quad.elements[j];

    return els;
  }

  /**
   * Creates the quadtree object itself.
   *
   * @param  {object}   bounds       The boundaries of the quad defined by an
   *                                 origin (x, y), width and heigth.
   * @param  {integer}  level        The level of the quad in the tree.
   * @param  {integer}  maxElements  The max number of element in a leaf node.
   * @param  {integer}  maxLevel     The max recursion level of the tree.
   * @return {object}                The quadtree object.
   */
  function _quadTree(bounds, level, maxElements, maxLevel) {
    return {
      level: level || 0,
      bounds: bounds,
      corners: _geom.splitSquare(bounds),
      maxElements: maxElements || 40,
      maxLevel: maxLevel || 8,
      elements: [],
      nodes: []
    };
  }


  /**
   * Sigma Quad Constructor
   * ----------------------
   *
   * The edgequad API as exposed to sigma.
   */

  /**
   * The edgequad core that will become the sigma interface with the quadtree.
   *
   * property {object} _tree     Property holding the quadtree object.
   * property {object} _geom     Exposition of the _geom namespace for testing.
   * property {object} _cache    Cache for the area method.
   * property {boolean} _enabled Can index and retreive elements.
   */
  var edgequad = function() {
    this._geom = _geom;
    this._tree = null;
    this._cache = {
      query: false,
      result: false
    };
    this._enabled = true;
  };

  /**
   * Index a graph by inserting its edges into the quadtree.
   *
   * @param  {object} graph   A graph instance.
   * @param  {object} params  An object of parameters with at least the quad
   *                          bounds.
   * @return {object}         The quadtree object.
   *
   * Parameters:
   * ----------
   * bounds:      {object}   boundaries of the quad defined by its origin (x, y)
   *                         width and heigth.
   * prefix:      {string?}  a prefix for edge geometric attributes.
   * maxElements: {integer?} the max number of elements in a leaf node.
   * maxLevel:    {integer?} the max recursion level of the tree.
   */
  edgequad.prototype.index = function(graph, params) {
    if (!this._enabled)
      return this._tree;

    // Enforcing presence of boundaries
    if (!params.bounds)
      throw 'sigma.classes.edgequad.index: bounds information not given.';

    // Prefix
    var prefix = params.prefix || '',
        cp,
        source,
        target,
        n,
        e;

    // Building the tree
    this._tree = _quadTree(
      params.bounds,
      0,
      params.maxElements,
      params.maxLevel
    );

    var edges = graph.edges();

    // Inserting graph edges into the tree
    for (var i = 0, l = edges.length; i < l; i++) {
      source = graph.nodes(edges[i].source);
      target = graph.nodes(edges[i].target);
      e = {
        x1: source[prefix + 'x'],
        y1: source[prefix + 'y'],
        x2: target[prefix + 'x'],
        y2: target[prefix + 'y'],
        size: edges[i][prefix + 'size'] || 0
      };

      // Inserting edge
      if (edges[i].type === 'curve' || edges[i].type === 'curvedArrow') {
        if (source.id === target.id) {
          n = {
            x: source[prefix + 'x'],
            y: source[prefix + 'y'],
            size: source[prefix + 'size'] || 0
          };
          _quadInsert(
            edges[i],
            _geom.selfLoopToSquare(n),
            this._tree);
        }
        else {
          cp = sigma.utils.getQuadraticControlPoint(e.x1, e.y1, e.x2, e.y2);
          _quadInsert(
            edges[i],
            _geom.quadraticCurveToSquare(e, cp),
            this._tree);
        }
      }
      else {
        _quadInsert(
          edges[i],
          _geom.lineToSquare(e),
          this._tree);
      }
    }

    // Reset cache:
    this._cache = {
      query: false,
      result: false
    };

    // remove?
    return this._tree;
  };

  /**
   * Retrieve every graph edges held by the quadtree node containing the
   * searched point.
   *
   * @param  {number} x of the point.
   * @param  {number} y of the point.
   * @return {array}  An array of edges retrieved.
   */
  edgequad.prototype.point = function(x, y) {
    if (!this._enabled)
      return [];

    return this._tree ?
      _quadRetrievePoint({x: x, y: y}, this._tree) || [] :
      [];
  };

  /**
   * Retrieve every graph edges within a rectangular area. The methods keep the
   * last area queried in cache for optimization reason and will act differently
   * for the same reason if the area is axis-aligned or not.
   *
   * @param  {object} A rectangle defined by two top points (x1, y1), (x2, y2)
   *                  and height.
   * @return {array}  An array of edges retrieved.
   */
  edgequad.prototype.area = function(rect) {
    if (!this._enabled)
      return [];

    var serialized = JSON.stringify(rect),
        collisionFunc,
        rectData;

    // Returning cache?
    if (this._cache.query === serialized)
      return this._cache.result;

    // Axis aligned ?
    if (_geom.isAxisAligned(rect)) {
      collisionFunc = _quadIndexes;
      rectData = _geom.axisAlignedTopPoints(rect);
    }
    else {
      collisionFunc = _quadCollision;
      rectData = _geom.rectangleCorners(rect);
    }

    // Retrieving edges
    var edges = this._tree ?
      _quadRetrieveArea(
        rectData,
        this._tree,
        collisionFunc
      ) :
      [];

    // Object to array
    var edgesArray = [];
    for (var i in edges)
      edgesArray.push(edges[i]);

    // Caching
    this._cache.query = serialized;
    this._cache.result = edgesArray;

    return edgesArray;
  };


  /**
   * EXPORT:
   * *******
   */
  if (typeof this.sigma !== 'undefined') {
    this.sigma.classes = this.sigma.classes || {};
    this.sigma.classes.edgequad = edgequad;
  } else if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports)
      exports = module.exports = edgequad;
    exports.edgequad = edgequad;
  } else
    this.edgequad = edgequad;
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.captors');

  /**
   * The user inputs default captor. It deals with mouse events, keyboards
   * events and touch events.
   *
   * @param  {DOMElement}   target   The DOM element where the listeners will be
   *                                 bound.
   * @param  {camera}       camera   The camera related to the target.
   * @param  {configurable} settings The settings function.
   * @return {sigma.captor}          The fresh new captor instance.
   */
  sigma.captors.mouse = function(target, camera, settings) {
    var _self = this,
        _target = target,
        _camera = camera,
        _settings = settings,

        // CAMERA MANAGEMENT:
        // ******************
        // The camera position when the user starts dragging:
        _startCameraX,
        _startCameraY,
        _startCameraAngle,

        // The latest stage position:
        _lastCameraX,
        _lastCameraY,
        _lastCameraAngle,
        _lastCameraRatio,

        // MOUSE MANAGEMENT:
        // *****************
        // The mouse position when the user starts dragging:
        _startMouseX,
        _startMouseY,

        _isMouseDown,
        _isMoving,
        _hasDragged,
        _downStartTime,
        _movingTimeoutId;

    sigma.classes.dispatcher.extend(this);

    sigma.utils.doubleClick(_target, 'click', _doubleClickHandler);
    _target.addEventListener('DOMMouseScroll', _wheelHandler, false);
    _target.addEventListener('mousewheel', _wheelHandler, false);
    _target.addEventListener('mousemove', _moveHandler, false);
    _target.addEventListener('mousedown', _downHandler, false);
    _target.addEventListener('click', _clickHandler, false);
    _target.addEventListener('mouseout', _outHandler, false);
    document.addEventListener('mouseup', _upHandler, false);




    /**
     * This method unbinds every handlers that makes the captor work.
     */
    this.kill = function() {
      sigma.utils.unbindDoubleClick(_target, 'click');
      _target.removeEventListener('DOMMouseScroll', _wheelHandler);
      _target.removeEventListener('mousewheel', _wheelHandler);
      _target.removeEventListener('mousemove', _moveHandler);
      _target.removeEventListener('mousedown', _downHandler);
      _target.removeEventListener('click', _clickHandler);
      _target.removeEventListener('mouseout', _outHandler);
      document.removeEventListener('mouseup', _upHandler);
    };




    // MOUSE EVENTS:
    // *************

    /**
     * The handler listening to the 'move' mouse event. It will effectively
     * drag the graph.
     *
     * @param {event} e A mouse event.
     */
    function _moveHandler(e) {
      var x,
          y,
          pos;

      // Dispatch event:
      if (_settings('mouseEnabled')) {
        _self.dispatchEvent('mousemove',
          sigma.utils.mouseCoords(e));

        if (_isMouseDown) {
          _isMoving = true;
          _hasDragged = true;

          if (_movingTimeoutId)
            clearTimeout(_movingTimeoutId);

          _movingTimeoutId = setTimeout(function() {
            _isMoving = false;
          }, _settings('dragTimeout'));

          sigma.misc.animation.killAll(_camera);

          _camera.isMoving = true;
          pos = _camera.cameraPosition(
            sigma.utils.getX(e) - _startMouseX,
            sigma.utils.getY(e) - _startMouseY,
            true
          );

          x = _startCameraX - pos.x;
          y = _startCameraY - pos.y;

          if (x !== _camera.x || y !== _camera.y) {
            _lastCameraX = _camera.x;
            _lastCameraY = _camera.y;

            _camera.goTo({
              x: x,
              y: y
            });
          }

          if (e.preventDefault)
            e.preventDefault();
          else
            e.returnValue = false;

          e.stopPropagation();
          return false;
        }
      }
    }

    /**
     * The handler listening to the 'up' mouse event. It will stop dragging the
     * graph.
     *
     * @param {event} e A mouse event.
     */
    function _upHandler(e) {
      if (_settings('mouseEnabled') && _isMouseDown) {
        _isMouseDown = false;
        if (_movingTimeoutId)
          clearTimeout(_movingTimeoutId);

        _camera.isMoving = false;

        var x = sigma.utils.getX(e),
            y = sigma.utils.getY(e);

        if (_isMoving) {
          sigma.misc.animation.killAll(_camera);
          sigma.misc.animation.camera(
            _camera,
            {
              x: _camera.x +
                _settings('mouseInertiaRatio') * (_camera.x - _lastCameraX),
              y: _camera.y +
                _settings('mouseInertiaRatio') * (_camera.y - _lastCameraY)
            },
            {
              easing: 'quadraticOut',
              duration: _settings('mouseInertiaDuration')
            }
          );
        } else if (
          _startMouseX !== x ||
          _startMouseY !== y
        )
          _camera.goTo({
            x: _camera.x,
            y: _camera.y
          });

        _self.dispatchEvent('mouseup',
          sigma.utils.mouseCoords(e));

        // Update _isMoving flag:
        _isMoving = false;
      }
    }

    /**
     * The handler listening to the 'down' mouse event. It will start observing
     * the mouse position for dragging the graph.
     *
     * @param {event} e A mouse event.
     */
    function _downHandler(e) {
      if (_settings('mouseEnabled')) {
        _startCameraX = _camera.x;
        _startCameraY = _camera.y;

        _lastCameraX = _camera.x;
        _lastCameraY = _camera.y;

        _startMouseX = sigma.utils.getX(e);
        _startMouseY = sigma.utils.getY(e);

        _hasDragged = false;
        _downStartTime = (new Date()).getTime();

        switch (e.which) {
          case 2:
            // Middle mouse button pressed
            // Do nothing.
            break;
          case 3:
            // Right mouse button pressed
            _self.dispatchEvent('rightclick',
              sigma.utils.mouseCoords(e, _startMouseX, _startMouseY));
            break;
          // case 1:
          default:
            // Left mouse button pressed
            _isMouseDown = true;

            _self.dispatchEvent('mousedown',
              sigma.utils.mouseCoords(e, _startMouseX, _startMouseY));
        }
      }
    }

    /**
     * The handler listening to the 'out' mouse event. It will just redispatch
     * the event.
     *
     * @param {event} e A mouse event.
     */
    function _outHandler(e) {
      if (_settings('mouseEnabled'))
        _self.dispatchEvent('mouseout');
    }

    /**
     * The handler listening to the 'click' mouse event. It will redispatch the
     * click event, but with normalized X and Y coordinates.
     *
     * @param {event} e A mouse event.
     */
    function _clickHandler(e) {
      if (_settings('mouseEnabled')) {
        var event = sigma.utils.mouseCoords(e);
        event.isDragging =
          (((new Date()).getTime() - _downStartTime) > 100) && _hasDragged;
        _self.dispatchEvent('click', event);
      }

      if (e.preventDefault)
        e.preventDefault();
      else
        e.returnValue = false;

      e.stopPropagation();
      return false;
    }

    /**
     * The handler listening to the double click custom event. It will
     * basically zoom into the graph.
     *
     * @param {event} e A mouse event.
     */
    function _doubleClickHandler(e) {
      var pos,
          ratio,
          animation;

      if (_settings('mouseEnabled')) {
        ratio = 1 / _settings('doubleClickZoomingRatio');

        _self.dispatchEvent('doubleclick',
            sigma.utils.mouseCoords(e, _startMouseX, _startMouseY));

        if (_settings('doubleClickEnabled')) {
          pos = _camera.cameraPosition(
            sigma.utils.getX(e) - sigma.utils.getCenter(e).x,
            sigma.utils.getY(e) - sigma.utils.getCenter(e).y,
            true
          );

          animation = {
            duration: _settings('doubleClickZoomDuration')
          };

          sigma.utils.zoomTo(_camera, pos.x, pos.y, ratio, animation);
        }

        if (e.preventDefault)
          e.preventDefault();
        else
          e.returnValue = false;

        e.stopPropagation();
        return false;
      }
    }

    /**
     * The handler listening to the 'wheel' mouse event. It will basically zoom
     * in or not into the graph.
     *
     * @param {event} e A mouse event.
     */
    function _wheelHandler(e) {
      var pos,
          ratio,
          animation,
          wheelDelta = sigma.utils.getDelta(e);

      if (_settings('mouseEnabled') && _settings('mouseWheelEnabled') && wheelDelta !== 0) {
        ratio = wheelDelta > 0 ?
          1 / _settings('zoomingRatio') :
          _settings('zoomingRatio');

        pos = _camera.cameraPosition(
          sigma.utils.getX(e) - sigma.utils.getCenter(e).x,
          sigma.utils.getY(e) - sigma.utils.getCenter(e).y,
          true
        );

        animation = {
          duration: _settings('mouseZoomDuration')
        };

        sigma.utils.zoomTo(_camera, pos.x, pos.y, ratio, animation);

        if (e.preventDefault)
          e.preventDefault();
        else
          e.returnValue = false;

        e.stopPropagation();
        return false;
      }
    }
  };
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.captors');

  /**
   * The user inputs default captor. It deals with mouse events, keyboards
   * events and touch events.
   *
   * @param  {DOMElement}   target   The DOM element where the listeners will be
   *                                 bound.
   * @param  {camera}       camera   The camera related to the target.
   * @param  {configurable} settings The settings function.
   * @return {sigma.captor}          The fresh new captor instance.
   */
  sigma.captors.touch = function(target, camera, settings) {
    var _self = this,
        _target = target,
        _camera = camera,
        _settings = settings,

        // CAMERA MANAGEMENT:
        // ******************
        // The camera position when the user starts dragging:
        _startCameraX,
        _startCameraY,
        _startCameraAngle,
        _startCameraRatio,

        // The latest stage position:
        _lastCameraX,
        _lastCameraY,
        _lastCameraAngle,
        _lastCameraRatio,

        // TOUCH MANAGEMENT:
        // *****************
        // Touches that are down:
        _downTouches = [],

        _startTouchX0,
        _startTouchY0,
        _startTouchX1,
        _startTouchY1,
        _startTouchAngle,
        _startTouchDistance,

        _touchMode,

        _isMoving,
        _doubleTap,
        _movingTimeoutId;

    sigma.classes.dispatcher.extend(this);

    sigma.utils.doubleClick(_target, 'touchstart', _doubleTapHandler);
    _target.addEventListener('touchstart', _handleStart, false);
    _target.addEventListener('touchend', _handleLeave, false);
    _target.addEventListener('touchcancel', _handleLeave, false);
    _target.addEventListener('touchleave', _handleLeave, false);
    _target.addEventListener('touchmove', _handleMove, false);

    function position(e) {
      var offset = sigma.utils.getOffset(_target);

      return {
        x: e.pageX - offset.left,
        y: e.pageY - offset.top
      };
    }

    /**
     * This method unbinds every handlers that makes the captor work.
     */
    this.kill = function() {
      sigma.utils.unbindDoubleClick(_target, 'touchstart');
      _target.addEventListener('touchstart', _handleStart);
      _target.addEventListener('touchend', _handleLeave);
      _target.addEventListener('touchcancel', _handleLeave);
      _target.addEventListener('touchleave', _handleLeave);
      _target.addEventListener('touchmove', _handleMove);
    };

    // TOUCH EVENTS:
    // *************
    /**
     * The handler listening to the 'touchstart' event. It will set the touch
     * mode ("_touchMode") and start observing the user touch moves.
     *
     * @param {event} e A touch event.
     */
    function _handleStart(e) {
      if (_settings('touchEnabled')) {
        var x0,
            x1,
            y0,
            y1,
            pos0,
            pos1;

        _downTouches = e.touches;

        switch (_downTouches.length) {
          case 1:
            _camera.isMoving = true;
            _touchMode = 1;

            _startCameraX = _camera.x;
            _startCameraY = _camera.y;

            _lastCameraX = _camera.x;
            _lastCameraY = _camera.y;

            pos0 = position(_downTouches[0]);
            _startTouchX0 = pos0.x;
            _startTouchY0 = pos0.y;

            break;
          case 2:
            _camera.isMoving = true;
            _touchMode = 2;

            pos0 = position(_downTouches[0]);
            pos1 = position(_downTouches[1]);
            x0 = pos0.x;
            y0 = pos0.y;
            x1 = pos1.x;
            y1 = pos1.y;

            _lastCameraX = _camera.x;
            _lastCameraY = _camera.y;

            _startCameraAngle = _camera.angle;
            _startCameraRatio = _camera.ratio;

            _startCameraX = _camera.x;
            _startCameraY = _camera.y;

            _startTouchX0 = x0;
            _startTouchY0 = y0;
            _startTouchX1 = x1;
            _startTouchY1 = y1;

            _startTouchAngle = Math.atan2(
              _startTouchY1 - _startTouchY0,
              _startTouchX1 - _startTouchX0
            );
            _startTouchDistance = Math.sqrt(
              (_startTouchY1 - _startTouchY0) *
                (_startTouchY1 - _startTouchY0) +
              (_startTouchX1 - _startTouchX0) *
                (_startTouchX1 - _startTouchX0)
            );

            e.preventDefault();
            return false;
        }
      }
    }

    /**
     * The handler listening to the 'touchend', 'touchcancel' and 'touchleave'
     * event. It will update the touch mode if there are still at least one
     * finger, and stop dragging else.
     *
     * @param {event} e A touch event.
     */
    function _handleLeave(e) {
      if (_settings('touchEnabled')) {
        _downTouches = e.touches;
        var inertiaRatio = _settings('touchInertiaRatio');

        if (_movingTimeoutId) {
          _isMoving = false;
          clearTimeout(_movingTimeoutId);
        }

        switch (_touchMode) {
          case 2:
            if (e.touches.length === 1) {
              _handleStart(e);

              e.preventDefault();
              break;
            }
            /* falls through */
          case 1:
            _camera.isMoving = false;
            _self.dispatchEvent('stopDrag');

            if (_isMoving) {
              _doubleTap = false;
              sigma.misc.animation.camera(
                _camera,
                {
                  x: _camera.x +
                    inertiaRatio * (_camera.x - _lastCameraX),
                  y: _camera.y +
                    inertiaRatio * (_camera.y - _lastCameraY)
                },
                {
                  easing: 'quadraticOut',
                  duration: _settings('touchInertiaDuration')
                }
              );
            }

            _isMoving = false;
            _touchMode = 0;
            break;
        }
      }
    }

    /**
     * The handler listening to the 'touchmove' event. It will effectively drag
     * the graph, and eventually zooms and turn it if the user is using two
     * fingers.
     *
     * @param {event} e A touch event.
     */
    function _handleMove(e) {
      if (!_doubleTap && _settings('touchEnabled')) {
        var x0,
            x1,
            y0,
            y1,
            cos,
            sin,
            end,
            pos0,
            pos1,
            diff,
            start,
            dAngle,
            dRatio,
            newStageX,
            newStageY,
            newStageRatio,
            newStageAngle;

        _downTouches = e.touches;
        _isMoving = true;

        if (_movingTimeoutId)
          clearTimeout(_movingTimeoutId);

        _movingTimeoutId = setTimeout(function() {
          _isMoving = false;
        }, _settings('dragTimeout'));

        switch (_touchMode) {
          case 1:
            pos0 = position(_downTouches[0]);
            x0 = pos0.x;
            y0 = pos0.y;

            diff = _camera.cameraPosition(
              x0 - _startTouchX0,
              y0 - _startTouchY0,
              true
            );

            newStageX = _startCameraX - diff.x;
            newStageY = _startCameraY - diff.y;

            if (newStageX !== _camera.x || newStageY !== _camera.y) {
              _lastCameraX = _camera.x;
              _lastCameraY = _camera.y;

              _camera.goTo({
                x: newStageX,
                y: newStageY
              });

              _self.dispatchEvent('mousemove',
                sigma.utils.mouseCoords(e, pos0.x, pos0.y));

              _self.dispatchEvent('drag');
            }
            break;
          case 2:
            pos0 = position(_downTouches[0]);
            pos1 = position(_downTouches[1]);
            x0 = pos0.x;
            y0 = pos0.y;
            x1 = pos1.x;
            y1 = pos1.y;

            start = _camera.cameraPosition(
              (_startTouchX0 + _startTouchX1) / 2 -
                sigma.utils.getCenter(e).x,
              (_startTouchY0 + _startTouchY1) / 2 -
                sigma.utils.getCenter(e).y,
              true
            );
            end = _camera.cameraPosition(
              (x0 + x1) / 2 - sigma.utils.getCenter(e).x,
              (y0 + y1) / 2 - sigma.utils.getCenter(e).y,
              true
            );

            dAngle = Math.atan2(y1 - y0, x1 - x0) - _startTouchAngle;
            dRatio = Math.sqrt(
              (y1 - y0) * (y1 - y0) + (x1 - x0) * (x1 - x0)
            ) / _startTouchDistance;

            // Translation:
            x0 = start.x;
            y0 = start.y;

            // Homothetic transformation:
            newStageRatio = _startCameraRatio / dRatio;
            x0 = x0 * dRatio;
            y0 = y0 * dRatio;

            // Rotation:
            newStageAngle = _startCameraAngle - dAngle;
            cos = Math.cos(-dAngle);
            sin = Math.sin(-dAngle);
            x1 = x0 * cos + y0 * sin;
            y1 = y0 * cos - x0 * sin;
            x0 = x1;
            y0 = y1;

            // Finalize:
            newStageX = x0 - end.x + _startCameraX;
            newStageY = y0 - end.y + _startCameraY;

            if (
              newStageRatio !== _camera.ratio ||
              newStageAngle !== _camera.angle ||
              newStageX !== _camera.x ||
              newStageY !== _camera.y
            ) {
              _lastCameraX = _camera.x;
              _lastCameraY = _camera.y;
              _lastCameraAngle = _camera.angle;
              _lastCameraRatio = _camera.ratio;

              _camera.goTo({
                x: newStageX,
                y: newStageY,
                angle: newStageAngle,
                ratio: newStageRatio
              });

              _self.dispatchEvent('drag');
            }

            break;
        }

        e.preventDefault();
        return false;
      }
    }

    /**
     * The handler listening to the double tap custom event. It will
     * basically zoom into the graph.
     *
     * @param {event} e A touch event.
     */
    function _doubleTapHandler(e) {
      var pos,
          ratio,
          animation;

      if (e.touches && e.touches.length === 1 && _settings('touchEnabled')) {
        _doubleTap = true;

        ratio = 1 / _settings('doubleClickZoomingRatio');

        pos = position(e.touches[0]);
        _self.dispatchEvent('doubleclick',
          sigma.utils.mouseCoords(e, pos.x, pos.y));

        if (_settings('doubleClickEnabled')) {
          pos = _camera.cameraPosition(
            pos.x - sigma.utils.getCenter(e).x,
            pos.y - sigma.utils.getCenter(e).y,
            true
          );

          animation = {
            duration: _settings('doubleClickZoomDuration'),
            onComplete: function() {
              _doubleTap = false;
            }
          };

          sigma.utils.zoomTo(_camera, pos.x, pos.y, ratio, animation);
        }

        if (e.preventDefault)
          e.preventDefault();
        else
          e.returnValue = false;

        e.stopPropagation();
        return false;
      }
    }
  };
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  if (typeof conrad === 'undefined')
    throw 'conrad is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.renderers');

  /**
   * This function is the constructor of the canvas sigma's renderer.
   *
   * @param  {sigma.classes.graph}            graph    The graph to render.
   * @param  {sigma.classes.camera}           camera   The camera.
   * @param  {configurable}           settings The sigma instance settings
   *                                           function.
   * @param  {object}                 object   The options object.
   * @return {sigma.renderers.canvas}          The renderer instance.
   */
  sigma.renderers.canvas = function(graph, camera, settings, options) {
    if (typeof options !== 'object')
      throw 'sigma.renderers.canvas: Wrong arguments.';

    if (!(options.container instanceof HTMLElement))
      throw 'Container not found.';

    var k,
        i,
        l,
        a,
        fn,
        self = this;

    sigma.classes.dispatcher.extend(this);

    // Initialize main attributes:
    Object.defineProperty(this, 'conradId', {
      value: sigma.utils.id()
    });
    this.graph = graph;
    this.camera = camera;
    this.contexts = {};
    this.domElements = {};
    this.options = options;
    this.container = this.options.container;
    this.settings = (
        typeof options.settings === 'object' &&
        options.settings
      ) ?
        settings.embedObjects(options.settings) :
        settings;

    // Node indexes:
    this.nodesOnScreen = [];
    this.edgesOnScreen = [];

    // Conrad related attributes:
    this.jobs = {};

    // Find the prefix:
    this.options.prefix = 'renderer' + this.conradId + ':';

    // Initialize the DOM elements:
    if (
      !this.settings('batchEdgesDrawing')
    ) {
      this.initDOM('canvas', 'scene');
      this.contexts.edges = this.contexts.scene;
      this.contexts.nodes = this.contexts.scene;
      this.contexts.labels = this.contexts.scene;
    } else {
      this.initDOM('canvas', 'edges');
      this.initDOM('canvas', 'scene');
      this.contexts.nodes = this.contexts.scene;
      this.contexts.labels = this.contexts.scene;
    }

    this.initDOM('canvas', 'mouse');
    this.contexts.hover = this.contexts.mouse;

    // Initialize captors:
    this.captors = [];
    a = this.options.captors || [sigma.captors.mouse, sigma.captors.touch];
    for (i = 0, l = a.length; i < l; i++) {
      fn = typeof a[i] === 'function' ? a[i] : sigma.captors[a[i]];
      this.captors.push(
        new fn(
          this.domElements.mouse,
          this.camera,
          this.settings
        )
      );
    }

    // Deal with sigma events:
    sigma.misc.bindEvents.call(this, this.options.prefix);
    sigma.misc.drawHovers.call(this, this.options.prefix);

    this.resize(false);
  };




  /**
   * This method renders the graph on the canvases.
   *
   * @param  {?object}                options Eventually an object of options.
   * @return {sigma.renderers.canvas}         Returns the instance itself.
   */
  sigma.renderers.canvas.prototype.render = function(options) {
    options = options || {};

    var a,
        i,
        k,
        l,
        o,
        id,
        end,
        job,
        start,
        edges,
        renderers,
        rendererType,
        batchSize,
        tempGCO,
        index = {},
        graph = this.graph,
        nodes = this.graph.nodes,
        prefix = this.options.prefix || '',
        drawEdges = this.settings(options, 'drawEdges'),
        drawNodes = this.settings(options, 'drawNodes'),
        drawLabels = this.settings(options, 'drawLabels'),
        drawEdgeLabels = this.settings(options, 'drawEdgeLabels'),
        embedSettings = this.settings.embedObjects(options, {
          prefix: this.options.prefix
        });

    // Call the resize function:
    this.resize(false);

    // Check the 'hideEdgesOnMove' setting:
    if (this.settings(options, 'hideEdgesOnMove'))
      if (this.camera.isAnimated || this.camera.isMoving)
        drawEdges = false;

    // Apply the camera's view:
    this.camera.applyView(
      undefined,
      this.options.prefix,
      {
        width: this.width,
        height: this.height
      }
    );

    // Clear canvases:
    this.clear();

    // Kill running jobs:
    for (k in this.jobs)
      if (conrad.hasJob(k))
        conrad.killJob(k);

    // Find which nodes are on screen:
    this.edgesOnScreen = [];
    this.nodesOnScreen = this.camera.quadtree.area(
      this.camera.getRectangle(this.width, this.height)
    );

    for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++)
      index[a[i].id] = a[i];

    // Draw edges:
    // - If settings('batchEdgesDrawing') is true, the edges are displayed per
    //   batches. If not, they are drawn in one frame.
    if (drawEdges) {
      // First, let's identify which edges to draw. To do this, we just keep
      // every edges that have at least one extremity displayed according to
      // the quadtree and the "hidden" attribute. We also do not keep hidden
      // edges.
      for (a = graph.edges(), i = 0, l = a.length; i < l; i++) {
        o = a[i];
        if (
          (index[o.source] || index[o.target]) &&
          (!o.hidden && !nodes(o.source).hidden && !nodes(o.target).hidden)
        )
          this.edgesOnScreen.push(o);
      }

      // If the "batchEdgesDrawing" settings is true, edges are batched:
      if (this.settings(options, 'batchEdgesDrawing')) {
        id = 'edges_' + this.conradId;
        batchSize = embedSettings('canvasEdgesBatchSize');

        edges = this.edgesOnScreen;
        l = edges.length;

        start = 0;
        end = Math.min(edges.length, start + batchSize);

        job = function() {
          tempGCO = this.contexts.edges.globalCompositeOperation;
          this.contexts.edges.globalCompositeOperation = 'destination-over';

          renderers = sigma.canvas.edges;
          for (i = start; i < end; i++) {
            o = edges[i];
            (renderers[
              o.type || this.settings(options, 'defaultEdgeType')
            ] || renderers.def)(
              o,
              graph.nodes(o.source),
              graph.nodes(o.target),
              this.contexts.edges,
              embedSettings
            );
          }

          // Draw edge labels:
          if (drawEdgeLabels) {
            renderers = sigma.canvas.edges.labels;
            for (i = start; i < end; i++) {
              o = edges[i];
              if (!o.hidden)
                (renderers[
                  o.type || this.settings(options, 'defaultEdgeType')
                ] || renderers.def)(
                  o,
                  graph.nodes(o.source),
                  graph.nodes(o.target),
                  this.contexts.labels,
                  embedSettings
                );
            }
          }

          // Restore original globalCompositeOperation:
          this.contexts.edges.globalCompositeOperation = tempGCO;

          // Catch job's end:
          if (end === edges.length) {
            delete this.jobs[id];
            return false;
          }

          start = end + 1;
          end = Math.min(edges.length, start + batchSize);
          return true;
        };

        this.jobs[id] = job;
        conrad.addJob(id, job.bind(this));

      // If not, they are drawn in one frame:
      } else {
        renderers = sigma.canvas.edges;
        for (a = this.edgesOnScreen, i = 0, l = a.length; i < l; i++) {
          o = a[i];
          (renderers[
            o.type || this.settings(options, 'defaultEdgeType')
          ] || renderers.def)(
            o,
            graph.nodes(o.source),
            graph.nodes(o.target),
            this.contexts.edges,
            embedSettings
          );
        }

        // Draw edge labels:
        // - No batching
        if (drawEdgeLabels) {
          renderers = sigma.canvas.edges.labels;
          for (a = this.edgesOnScreen, i = 0, l = a.length; i < l; i++)
            if (!a[i].hidden)
              (renderers[
                a[i].type || this.settings(options, 'defaultEdgeType')
              ] || renderers.def)(
                a[i],
                graph.nodes(a[i].source),
                graph.nodes(a[i].target),
                this.contexts.labels,
                embedSettings
              );
        }
      }
    }

    // Draw nodes:
    // - No batching
    if (drawNodes) {
      renderers = sigma.canvas.nodes;
      for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++)
        if (!a[i].hidden)
          (renderers[
            a[i].type || this.settings(options, 'defaultNodeType')
          ] || renderers.def)(
            a[i],
            this.contexts.nodes,
            embedSettings
          );
    }

    // Draw labels:
    // - No batching
    if (drawLabels) {
      renderers = sigma.canvas.labels;
      for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++)
        if (!a[i].hidden)
          (renderers[
            a[i].type || this.settings(options, 'defaultNodeType')
          ] || renderers.def)(
            a[i],
            this.contexts.labels,
            embedSettings
          );
    }

    this.dispatchEvent('render');

    return this;
  };

  /**
   * This method creates a DOM element of the specified type, switches its
   * position to "absolute", references it to the domElements attribute, and
   * finally appends it to the container.
   *
   * @param  {string} tag The label tag.
   * @param  {string} id  The id of the element (to store it in "domElements").
   */
  sigma.renderers.canvas.prototype.initDOM = function(tag, id) {
    var dom = document.createElement(tag);

    dom.style.position = 'absolute';
    dom.setAttribute('class', 'sigma-' + id);

    this.domElements[id] = dom;
    this.container.appendChild(dom);

    if (tag.toLowerCase() === 'canvas')
      this.contexts[id] = dom.getContext('2d');
  };

  /**
   * This method resizes each DOM elements in the container and stores the new
   * dimensions. Then, it renders the graph.
   *
   * @param  {?number}                width  The new width of the container.
   * @param  {?number}                height The new height of the container.
   * @return {sigma.renderers.canvas}        Returns the instance itself.
   */
  sigma.renderers.canvas.prototype.resize = function(w, h) {
    var k,
        oldWidth = this.width,
        oldHeight = this.height,
        pixelRatio = sigma.utils.getPixelRatio();

    if (w !== undefined && h !== undefined) {
      this.width = w;
      this.height = h;
    } else {
      this.width = this.container.offsetWidth;
      this.height = this.container.offsetHeight;

      w = this.width;
      h = this.height;
    }

    if (oldWidth !== this.width || oldHeight !== this.height) {
      for (k in this.domElements) {
        this.domElements[k].style.width = w + 'px';
        this.domElements[k].style.height = h + 'px';

        if (this.domElements[k].tagName.toLowerCase() === 'canvas') {
          this.domElements[k].setAttribute('width', (w * pixelRatio) + 'px');
          this.domElements[k].setAttribute('height', (h * pixelRatio) + 'px');

          if (pixelRatio !== 1)
            this.contexts[k].scale(pixelRatio, pixelRatio);
        }
      }
    }

    return this;
  };

  /**
   * This method clears each canvas.
   *
   * @return {sigma.renderers.canvas} Returns the instance itself.
   */
  sigma.renderers.canvas.prototype.clear = function() {
    for (var k in this.contexts) {
      this.contexts[k].clearRect(0, 0, this.width, this.height);
    }

    return this;
  };

  /**
   * This method kills contexts and other attributes.
   */
  sigma.renderers.canvas.prototype.kill = function() {
    var k,
        captor;

    // Kill captors:
    while ((captor = this.captors.pop()))
      captor.kill();
    delete this.captors;

    // Kill contexts:
    for (k in this.domElements) {
      this.domElements[k].parentNode.removeChild(this.domElements[k]);
      delete this.domElements[k];
      delete this.contexts[k];
    }
    delete this.domElements;
    delete this.contexts;
  };




  /**
   * The labels, nodes and edges renderers are stored in the three following
   * objects. When an element is drawn, its type will be checked and if a
   * renderer with the same name exists, it will be used. If not found, the
   * default renderer will be used instead.
   *
   * They are stored in different files, in the "./canvas" folder.
   */
  sigma.utils.pkg('sigma.canvas.nodes');
  sigma.utils.pkg('sigma.canvas.edges');
  sigma.utils.pkg('sigma.canvas.labels');
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.renderers');

  /**
   * This function is the constructor of the canvas sigma's renderer.
   *
   * @param  {sigma.classes.graph}            graph    The graph to render.
   * @param  {sigma.classes.camera}           camera   The camera.
   * @param  {configurable}           settings The sigma instance settings
   *                                           function.
   * @param  {object}                 object   The options object.
   * @return {sigma.renderers.canvas}          The renderer instance.
   */
  sigma.renderers.webgl = function(graph, camera, settings, options) {
    if (typeof options !== 'object')
      throw 'sigma.renderers.webgl: Wrong arguments.';

    if (!(options.container instanceof HTMLElement))
      throw 'Container not found.';

    var k,
        i,
        l,
        a,
        fn,
        _self = this;

    sigma.classes.dispatcher.extend(this);

    // Conrad related attributes:
    this.jobs = {};

    Object.defineProperty(this, 'conradId', {
      value: sigma.utils.id()
    });

    // Initialize main attributes:
    this.graph = graph;
    this.camera = camera;
    this.contexts = {};
    this.domElements = {};
    this.options = options;
    this.container = this.options.container;
    this.settings = (
        typeof options.settings === 'object' &&
        options.settings
      ) ?
        settings.embedObjects(options.settings) :
        settings;

    // Find the prefix:
    this.options.prefix = this.camera.readPrefix;

    // Initialize programs hash
    Object.defineProperty(this, 'nodePrograms', {
      value: {}
    });
    Object.defineProperty(this, 'edgePrograms', {
      value: {}
    });
    Object.defineProperty(this, 'nodeFloatArrays', {
      value: {}
    });
    Object.defineProperty(this, 'edgeFloatArrays', {
      value: {}
    });
    Object.defineProperty(this, 'edgeIndicesArrays', {
      value: {}
    });

    // Initialize the DOM elements:
    if (this.settings(options, 'batchEdgesDrawing')) {
      this.initDOM('canvas', 'edges', true);
      this.initDOM('canvas', 'nodes', true);
    } else {
      this.initDOM('canvas', 'scene', true);
      this.contexts.nodes = this.contexts.scene;
      this.contexts.edges = this.contexts.scene;
    }

    this.initDOM('canvas', 'labels');
    this.initDOM('canvas', 'mouse');
    this.contexts.hover = this.contexts.mouse;

    // Initialize captors:
    this.captors = [];
    a = this.options.captors || [sigma.captors.mouse, sigma.captors.touch];
    for (i = 0, l = a.length; i < l; i++) {
      fn = typeof a[i] === 'function' ? a[i] : sigma.captors[a[i]];
      this.captors.push(
        new fn(
          this.domElements.mouse,
          this.camera,
          this.settings
        )
      );
    }

    // Deal with sigma events:
    sigma.misc.bindEvents.call(this, this.camera.prefix);
    sigma.misc.drawHovers.call(this, this.camera.prefix);

    this.resize();
  };




  /**
   * This method will generate the nodes and edges float arrays. This step is
   * separated from the "render" method, because to keep WebGL efficient, since
   * all the camera and middlewares are modelised as matrices and they do not
   * require the float arrays to be regenerated.
   *
   * Basically, when the user moves the camera or applies some specific linear
   * transformations, this process step will be skipped, and the "render"
   * method will efficiently refresh the rendering.
   *
   * And when the user modifies the graph colors or positions (applying a new
   * layout or filtering the colors, for instance), this "process" step will be
   * required to regenerate the float arrays.
   *
   * @return {sigma.renderers.webgl} Returns the instance itself.
   */
  sigma.renderers.webgl.prototype.process = function() {
    var a,
        i,
        l,
        k,
        type,
        renderer,
        graph = this.graph,
        options = sigma.utils.extend(options, this.options),
        defaultEdgeType = this.settings(options, 'defaultEdgeType'),
        defaultNodeType = this.settings(options, 'defaultNodeType');

    // Empty float arrays:
    for (k in this.nodeFloatArrays)
      delete this.nodeFloatArrays[k];

    for (k in this.edgeFloatArrays)
      delete this.edgeFloatArrays[k];

    for (k in this.edgeIndicesArrays)
      delete this.edgeIndicesArrays[k];

    // Sort edges and nodes per types:
    for (a = graph.edges(), i = 0, l = a.length; i < l; i++) {
      type = a[i].type || defaultEdgeType;
      k = (type && sigma.webgl.edges[type]) ? type : 'def';

      if (!this.edgeFloatArrays[k])
        this.edgeFloatArrays[k] = {
          edges: []
        };

      this.edgeFloatArrays[k].edges.push(a[i]);
    }

    for (a = graph.nodes(), i = 0, l = a.length; i < l; i++) {
      type = a[i].type || defaultNodeType;
      k = (type && sigma.webgl.nodes[type]) ? type : 'def';

      if (!this.nodeFloatArrays[k])
        this.nodeFloatArrays[k] = {
          nodes: []
        };

      this.nodeFloatArrays[k].nodes.push(a[i]);
    }

    // Push edges:
    for (k in this.edgeFloatArrays) {
      renderer = sigma.webgl.edges[k];
      a = this.edgeFloatArrays[k].edges;

      // Creating the necessary arrays
      this.edgeFloatArrays[k].array = new Float32Array(
        a.length * renderer.POINTS * renderer.ATTRIBUTES
      );

      for (i = 0, l = a.length; i < l; i++) {

        // Just check that the edge and both its extremities are visible:
        if (
          !a[i].hidden &&
          !graph.nodes(a[i].source).hidden &&
          !graph.nodes(a[i].target).hidden
        )
          renderer.addEdge(
            a[i],
            graph.nodes(a[i].source),
            graph.nodes(a[i].target),
            this.edgeFloatArrays[k].array,
            i * renderer.POINTS * renderer.ATTRIBUTES,
            options.prefix,
            this.settings
          );
      }

      if (typeof renderer.computeIndices === 'function')
        this.edgeIndicesArrays[k] = renderer.computeIndices(
          this.edgeFloatArrays[k].array
        );
    }

    // Push nodes:
    for (k in this.nodeFloatArrays) {
      renderer = sigma.webgl.nodes[k];
      a = this.nodeFloatArrays[k].nodes;

      // Creating the necessary arrays
      this.nodeFloatArrays[k].array = new Float32Array(
        a.length * renderer.POINTS * renderer.ATTRIBUTES
      );

      for (i = 0, l = a.length; i < l; i++) {
        if (!this.nodeFloatArrays[k].array)
          this.nodeFloatArrays[k].array = new Float32Array(
            a.length * renderer.POINTS * renderer.ATTRIBUTES
          );

        // Just check that the edge and both its extremities are visible:
        if (
          !a[i].hidden
        )
          renderer.addNode(
            a[i],
            this.nodeFloatArrays[k].array,
            i * renderer.POINTS * renderer.ATTRIBUTES,
            options.prefix,
            this.settings
          );
      }
    }

    return this;
  };




  /**
   * This method renders the graph. It basically calls each program (and
   * generate them if they do not exist yet) to render nodes and edges, batched
   * per renderer.
   *
   * As in the canvas renderer, it is possible to display edges, nodes and / or
   * labels in batches, to make the whole thing way more scalable.
   *
   * @param  {?object}               params Eventually an object of options.
   * @return {sigma.renderers.webgl}        Returns the instance itself.
   */
  sigma.renderers.webgl.prototype.render = function(params) {
    var a,
        i,
        l,
        k,
        o,
        program,
        renderer,
        self = this,
        graph = this.graph,
        nodesGl = this.contexts.nodes,
        edgesGl = this.contexts.edges,
        matrix = this.camera.getMatrix(),
        options = sigma.utils.extend(params, this.options),
        drawLabels = this.settings(options, 'drawLabels'),
        drawEdges = this.settings(options, 'drawEdges'),
        drawNodes = this.settings(options, 'drawNodes');

    // Call the resize function:
    this.resize(false);

    // Check the 'hideEdgesOnMove' setting:
    if (this.settings(options, 'hideEdgesOnMove'))
      if (this.camera.isAnimated || this.camera.isMoving)
        drawEdges = false;

    // Clear canvases:
    this.clear();

    // Translate matrix to [width/2, height/2]:
    matrix = sigma.utils.matrices.multiply(
      matrix,
      sigma.utils.matrices.translation(this.width / 2, this.height / 2)
    );

    // Kill running jobs:
    for (k in this.jobs)
      if (conrad.hasJob(k))
        conrad.killJob(k);

    if (drawEdges) {
      if (this.settings(options, 'batchEdgesDrawing'))
        (function() {
          var a,
              k,
              i,
              id,
              job,
              arr,
              end,
              start,
              indices,
              renderer,
              batchSize,
              currentProgram;

          id = 'edges_' + this.conradId;
          batchSize = this.settings(options, 'webglEdgesBatchSize');
          a = Object.keys(this.edgeFloatArrays);

          if (!a.length)
            return;
          i = 0;
          renderer = sigma.webgl.edges[a[i]];
          arr = this.edgeFloatArrays[a[i]].array;
          indices = this.edgeIndicesArrays[a[i]];
          start = 0;
          end = Math.min(
            start + batchSize * renderer.POINTS,
            arr.length / renderer.ATTRIBUTES
          );

          job = function() {
            // Check program:
            if (!this.edgePrograms[a[i]])
              this.edgePrograms[a[i]] = renderer.initProgram(edgesGl);

            if (start < end) {
              edgesGl.useProgram(this.edgePrograms[a[i]]);
              renderer.render(
                edgesGl,
                this.edgePrograms[a[i]],
                arr,
                {
                  settings: this.settings,
                  matrix: matrix,
                  width: this.width,
                  height: this.height,
                  ratio: this.camera.ratio,
                  scalingRatio: this.settings(
                    options,
                    'webglOversamplingRatio'
                  ),
                  start: start,
                  count: end - start,
                  indicesData: indices
                }
              );
            }

            // Catch job's end:
            if (
              end >= arr.length / renderer.ATTRIBUTES &&
              i === a.length - 1
            ) {
              delete this.jobs[id];
              return false;
            }

            if (end >= arr.length / renderer.ATTRIBUTES) {
              i++;
              arr = this.edgeFloatArrays[a[i]].array;
              renderer = sigma.webgl.edges[a[i]];
              start = 0;
              end = Math.min(
                start + batchSize * renderer.POINTS,
                arr.length / renderer.ATTRIBUTES
              );
            } else {
              start = end;
              end = Math.min(
                start + batchSize * renderer.POINTS,
                arr.length / renderer.ATTRIBUTES
              );
            }

            return true;
          };

          this.jobs[id] = job;
          conrad.addJob(id, job.bind(this));
        }).call(this);
      else {
        for (k in this.edgeFloatArrays) {
          renderer = sigma.webgl.edges[k];

          // Check program:
          if (!this.edgePrograms[k])
            this.edgePrograms[k] = renderer.initProgram(edgesGl);

          // Render
          if (this.edgeFloatArrays[k]) {
            edgesGl.useProgram(this.edgePrograms[k]);
            renderer.render(
              edgesGl,
              this.edgePrograms[k],
              this.edgeFloatArrays[k].array,
              {
                settings: this.settings,
                matrix: matrix,
                width: this.width,
                height: this.height,
                ratio: this.camera.ratio,
                scalingRatio: this.settings(options, 'webglOversamplingRatio'),
                indicesData: this.edgeIndicesArrays[k]
              }
            );
          }
        }
      }
    }

    if (drawNodes) {
      // Enable blending:
      nodesGl.blendFunc(nodesGl.SRC_ALPHA, nodesGl.ONE_MINUS_SRC_ALPHA);
      nodesGl.enable(nodesGl.BLEND);

      for (k in this.nodeFloatArrays) {
        renderer = sigma.webgl.nodes[k];

        // Check program:
        if (!this.nodePrograms[k])
          this.nodePrograms[k] = renderer.initProgram(nodesGl);

        // Render
        if (this.nodeFloatArrays[k]) {
          nodesGl.useProgram(this.nodePrograms[k]);
          renderer.render(
            nodesGl,
            this.nodePrograms[k],
            this.nodeFloatArrays[k].array,
            {
              settings: this.settings,
              matrix: matrix,
              width: this.width,
              height: this.height,
              ratio: this.camera.ratio,
              scalingRatio: this.settings(options, 'webglOversamplingRatio')
            }
          );
        }
      }
    }

    if (drawLabels) {
      a = this.camera.quadtree.area(
        this.camera.getRectangle(this.width, this.height)
      );

      // Apply camera view to these nodes:
      this.camera.applyView(
        undefined,
        undefined,
        {
          nodes: a,
          edges: [],
          width: this.width,
          height: this.height
        }
      );

      o = function(key) {
        return self.settings({
          prefix: self.camera.prefix
        }, key);
      };

      for (i = 0, l = a.length; i < l; i++)
        if (!a[i].hidden)
          (
            sigma.canvas.labels[
              a[i].type ||
              this.settings(options, 'defaultNodeType')
            ] || sigma.canvas.labels.def
          )(a[i], this.contexts.labels, o);
    }

    this.dispatchEvent('render');

    return this;
  };




  /**
   * This method creates a DOM element of the specified type, switches its
   * position to "absolute", references it to the domElements attribute, and
   * finally appends it to the container.
   *
   * @param  {string}   tag   The label tag.
   * @param  {string}   id    The id of the element (to store it in
   *                          "domElements").
   * @param  {?boolean} webgl Will init the WebGL context if true.
   */
  sigma.renderers.webgl.prototype.initDOM = function(tag, id, webgl) {
    var gl,
        dom = document.createElement(tag),
        self = this;

    dom.style.position = 'absolute';
    dom.setAttribute('class', 'sigma-' + id);

    this.domElements[id] = dom;
    this.container.appendChild(dom);

    if (tag.toLowerCase() === 'canvas') {
      this.contexts[id] = dom.getContext(webgl ? 'experimental-webgl' : '2d', {
        preserveDrawingBuffer: true
      });

      // Adding webgl context loss listeners
      if (webgl) {
        dom.addEventListener('webglcontextlost', function(e) {
          e.preventDefault();
        }, false);

        dom.addEventListener('webglcontextrestored', function(e) {
          self.render();
        }, false);
      }
    }
  };

  /**
   * This method resizes each DOM elements in the container and stores the new
   * dimensions. Then, it renders the graph.
   *
   * @param  {?number}               width  The new width of the container.
   * @param  {?number}               height The new height of the container.
   * @return {sigma.renderers.webgl}        Returns the instance itself.
   */
  sigma.renderers.webgl.prototype.resize = function(w, h) {
    var k,
        oldWidth = this.width,
        oldHeight = this.height,
        pixelRatio = sigma.utils.getPixelRatio();

    if (w !== undefined && h !== undefined) {
      this.width = w;
      this.height = h;
    } else {
      this.width = this.container.offsetWidth;
      this.height = this.container.offsetHeight;

      w = this.width;
      h = this.height;
    }

    if (oldWidth !== this.width || oldHeight !== this.height) {
      for (k in this.domElements) {
        this.domElements[k].style.width = w + 'px';
        this.domElements[k].style.height = h + 'px';

        if (this.domElements[k].tagName.toLowerCase() === 'canvas') {
          // If simple 2D canvas:
          if (this.contexts[k] && this.contexts[k].scale) {
            this.domElements[k].setAttribute('width', (w * pixelRatio) + 'px');
            this.domElements[k].setAttribute('height', (h * pixelRatio) + 'px');

            if (pixelRatio !== 1)
              this.contexts[k].scale(pixelRatio, pixelRatio);
          } else {
            this.domElements[k].setAttribute(
              'width',
              (w * this.settings('webglOversamplingRatio')) + 'px'
            );
            this.domElements[k].setAttribute(
              'height',
              (h * this.settings('webglOversamplingRatio')) + 'px'
            );
          }
        }
      }
    }

    // Scale:
    for (k in this.contexts)
      if (this.contexts[k] && this.contexts[k].viewport)
        this.contexts[k].viewport(
          0,
          0,
          this.width * this.settings('webglOversamplingRatio'),
          this.height * this.settings('webglOversamplingRatio')
        );

    return this;
  };

  /**
   * This method clears each canvas.
   *
   * @return {sigma.renderers.webgl} Returns the instance itself.
   */
  sigma.renderers.webgl.prototype.clear = function() {
    this.contexts.labels.clearRect(0, 0, this.width, this.height);
    this.contexts.nodes.clear(this.contexts.nodes.COLOR_BUFFER_BIT);
    this.contexts.edges.clear(this.contexts.edges.COLOR_BUFFER_BIT);

    return this;
  };

  /**
   * This method kills contexts and other attributes.
   */
  sigma.renderers.webgl.prototype.kill = function() {
    var k,
        captor;

    // Kill captors:
    while ((captor = this.captors.pop()))
      captor.kill();
    delete this.captors;

    // Kill contexts:
    for (k in this.domElements) {
      this.domElements[k].parentNode.removeChild(this.domElements[k]);
      delete this.domElements[k];
      delete this.contexts[k];
    }
    delete this.domElements;
    delete this.contexts;
  };




  /**
   * The object "sigma.webgl.nodes" contains the different WebGL node
   * renderers. The default one draw nodes as discs. Here are the attributes
   * any node renderer must have:
   *
   * {number}   POINTS      The number of points required to draw a node.
   * {number}   ATTRIBUTES  The number of attributes needed to draw one point.
   * {function} addNode     A function that adds a node to the data stack that
   *                        will be given to the buffer. Here is the arguments:
   *                        > {object}       node
   *                        > {number}       index   The node index in the
   *                                                 nodes array.
   *                        > {Float32Array} data    The stack.
   *                        > {object}       options Some options.
   * {function} render      The function that will effectively render the nodes
   *                        into the buffer.
   *                        > {WebGLRenderingContext} gl
   *                        > {WebGLProgram}          program
   *                        > {Float32Array} data    The stack to give to the
   *                                                 buffer.
   *                        > {object}       params  An object containing some
   *                                                 options, like width,
   *                                                 height, the camera ratio.
   * {function} initProgram The function that will initiate the program, with
   *                        the relevant shaders and parameters. It must return
   *                        the newly created program.
   *
   * Check sigma.webgl.nodes.def or sigma.webgl.nodes.fast to see how it
   * works more precisely.
   */
  sigma.utils.pkg('sigma.webgl.nodes');




  /**
   * The object "sigma.webgl.edges" contains the different WebGL edge
   * renderers. The default one draw edges as direct lines. Here are the
   * attributes any edge renderer must have:
   *
   * {number}   POINTS      The number of points required to draw an edge.
   * {number}   ATTRIBUTES  The number of attributes needed to draw one point.
   * {function} addEdge     A function that adds an edge to the data stack that
   *                        will be given to the buffer. Here is the arguments:
   *                        > {object}       edge
   *                        > {object}       source
   *                        > {object}       target
   *                        > {Float32Array} data    The stack.
   *                        > {object}       options Some options.
   * {function} render      The function that will effectively render the edges
   *                        into the buffer.
   *                        > {WebGLRenderingContext} gl
   *                        > {WebGLProgram}          program
   *                        > {Float32Array} data    The stack to give to the
   *                                                 buffer.
   *                        > {object}       params  An object containing some
   *                                                 options, like width,
   *                                                 height, the camera ratio.
   * {function} initProgram The function that will initiate the program, with
   *                        the relevant shaders and parameters. It must return
   *                        the newly created program.
   *
   * Check sigma.webgl.edges.def or sigma.webgl.edges.fast to see how it
   * works more precisely.
   */
  sigma.utils.pkg('sigma.webgl.edges');




  /**
   * The object "sigma.canvas.labels" contains the different
   * label renderers for the WebGL renderer. Since displaying texts in WebGL is
   * definitely painful and since there a way less labels to display than nodes
   * or edges, the default renderer simply renders them in a canvas.
   *
   * A labels renderer is a simple function, taking as arguments the related
   * node, the renderer and a settings function.
   */
  sigma.utils.pkg('sigma.canvas.labels');
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  if (typeof conrad === 'undefined')
    throw 'conrad is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.renderers');

  /**
   * This function is the constructor of the svg sigma's renderer.
   *
   * @param  {sigma.classes.graph}            graph    The graph to render.
   * @param  {sigma.classes.camera}           camera   The camera.
   * @param  {configurable}           settings The sigma instance settings
   *                                           function.
   * @param  {object}                 object   The options object.
   * @return {sigma.renderers.svg}             The renderer instance.
   */
  sigma.renderers.svg = function(graph, camera, settings, options) {
    if (typeof options !== 'object')
      throw 'sigma.renderers.svg: Wrong arguments.';

    if (!(options.container instanceof HTMLElement))
      throw 'Container not found.';

    var i,
        l,
        a,
        fn,
        self = this;

    sigma.classes.dispatcher.extend(this);

    // Initialize main attributes:
    this.graph = graph;
    this.camera = camera;
    this.domElements = {
      graph: null,
      groups: {},
      nodes: {},
      edges: {},
      labels: {},
      hovers: {}
    };
    this.measurementCanvas = null;
    this.options = options;
    this.container = this.options.container;
    this.settings = (
        typeof options.settings === 'object' &&
        options.settings
      ) ?
        settings.embedObjects(options.settings) :
        settings;

    // Is the renderer meant to be freestyle?
    this.settings('freeStyle', !!this.options.freeStyle);

    // SVG xmlns
    this.settings('xmlns', 'http://www.w3.org/2000/svg');

    // Indexes:
    this.nodesOnScreen = [];
    this.edgesOnScreen = [];

    // Find the prefix:
    this.options.prefix = 'renderer' + sigma.utils.id() + ':';

    // Initialize the DOM elements
    this.initDOM('svg');

    // Initialize captors:
    this.captors = [];
    a = this.options.captors || [sigma.captors.mouse, sigma.captors.touch];
    for (i = 0, l = a.length; i < l; i++) {
      fn = typeof a[i] === 'function' ? a[i] : sigma.captors[a[i]];
      this.captors.push(
        new fn(
          this.domElements.graph,
          this.camera,
          this.settings
        )
      );
    }

    // Bind resize:
    window.addEventListener('resize', function() {
      self.resize();
    });

    // Deal with sigma events:
    // TODO: keep an option to override the DOM events?
    sigma.misc.bindDOMEvents.call(this, this.domElements.graph);
    this.bindHovers(this.options.prefix);

    // Resize
    this.resize(false);
  };

  /**
   * This method renders the graph on the svg scene.
   *
   * @param  {?object}                options Eventually an object of options.
   * @return {sigma.renderers.svg}            Returns the instance itself.
   */
  sigma.renderers.svg.prototype.render = function(options) {
    options = options || {};

    var a,
        i,
        k,
        e,
        l,
        o,
        source,
        target,
        start,
        edges,
        renderers,
        subrenderers,
        index = {},
        graph = this.graph,
        nodes = this.graph.nodes,
        prefix = this.options.prefix || '',
        drawEdges = this.settings(options, 'drawEdges'),
        drawNodes = this.settings(options, 'drawNodes'),
        drawLabels = this.settings(options, 'drawLabels'),
        embedSettings = this.settings.embedObjects(options, {
          prefix: this.options.prefix,
          forceLabels: this.options.forceLabels
        });

    // Check the 'hideEdgesOnMove' setting:
    if (this.settings(options, 'hideEdgesOnMove'))
      if (this.camera.isAnimated || this.camera.isMoving)
        drawEdges = false;

    // Apply the camera's view:
    this.camera.applyView(
      undefined,
      this.options.prefix,
      {
        width: this.width,
        height: this.height
      }
    );

    // Hiding everything
    // TODO: find a more sensible way to perform this operation
    this.hideDOMElements(this.domElements.nodes);
    this.hideDOMElements(this.domElements.edges);
    this.hideDOMElements(this.domElements.labels);

    // Find which nodes are on screen
    this.edgesOnScreen = [];
    this.nodesOnScreen = this.camera.quadtree.area(
      this.camera.getRectangle(this.width, this.height)
    );

    // Node index
    for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++)
      index[a[i].id] = a[i];

    // Find which edges are on screen
    for (a = graph.edges(), i = 0, l = a.length; i < l; i++) {
      o = a[i];
      if (
        (index[o.source] || index[o.target]) &&
        (!o.hidden && !nodes(o.source).hidden && !nodes(o.target).hidden)
      )
        this.edgesOnScreen.push(o);
    }

    // Display nodes
    //---------------
    renderers = sigma.svg.nodes;
    subrenderers = sigma.svg.labels;

    //-- First we create the nodes which are not already created
    if (drawNodes)
      for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++) {
        if (!a[i].hidden && !this.domElements.nodes[a[i].id]) {

          // Node
          e = (renderers[a[i].type] || renderers.def).create(
            a[i],
            embedSettings
          );

          this.domElements.nodes[a[i].id] = e;
          this.domElements.groups.nodes.appendChild(e);

          // Label
          e = (subrenderers[a[i].type] || subrenderers.def).create(
            a[i],
            embedSettings
          );

          this.domElements.labels[a[i].id] = e;
          this.domElements.groups.labels.appendChild(e);
        }
      }

    //-- Second we update the nodes
    if (drawNodes)
      for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++) {

        if (a[i].hidden)
          continue;

        // Node
        (renderers[a[i].type] || renderers.def).update(
          a[i],
          this.domElements.nodes[a[i].id],
          embedSettings
        );

        // Label
        (subrenderers[a[i].type] || subrenderers.def).update(
          a[i],
          this.domElements.labels[a[i].id],
          embedSettings
        );
      }

    // Display edges
    //---------------
    renderers = sigma.svg.edges;

    //-- First we create the edges which are not already created
    if (drawEdges)
      for (a = this.edgesOnScreen, i = 0, l = a.length; i < l; i++) {
        if (!this.domElements.edges[a[i].id]) {
          source = nodes(a[i].source);
          target = nodes(a[i].target);

          e = (renderers[a[i].type] || renderers.def).create(
            a[i],
            source,
            target,
            embedSettings
          );

          this.domElements.edges[a[i].id] = e;
          this.domElements.groups.edges.appendChild(e);
        }
       }

    //-- Second we update the edges
    if (drawEdges)
      for (a = this.edgesOnScreen, i = 0, l = a.length; i < l; i++) {
        source = nodes(a[i].source);
        target = nodes(a[i].target);

        (renderers[a[i].type] || renderers.def).update(
          a[i],
          this.domElements.edges[a[i].id],
          source,
          target,
          embedSettings
        );
       }

    this.dispatchEvent('render');

    return this;
  };

  /**
   * This method creates a DOM element of the specified type, switches its
   * position to "absolute", references it to the domElements attribute, and
   * finally appends it to the container.
   *
   * @param  {string} tag The label tag.
   * @param  {string} id  The id of the element (to store it in "domElements").
   */
  sigma.renderers.svg.prototype.initDOM = function(tag) {
    var dom = document.createElementNS(this.settings('xmlns'), tag),
        c = this.settings('classPrefix'),
        g,
        l,
        i;

    dom.style.position = 'absolute';
    dom.setAttribute('class', c + '-svg');

    // Setting SVG namespace
    dom.setAttribute('xmlns', this.settings('xmlns'));
    dom.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');
    dom.setAttribute('version', '1.1');

    // Creating the measurement canvas
    var canvas = document.createElement('canvas');
    canvas.setAttribute('class', c + '-measurement-canvas');

    // Appending elements
    this.domElements.graph = this.container.appendChild(dom);

    // Creating groups
    var groups = ['edges', 'nodes', 'labels', 'hovers'];
    for (i = 0, l = groups.length; i < l; i++) {
      g = document.createElementNS(this.settings('xmlns'), 'g');

      g.setAttributeNS(null, 'id', c + '-group-' + groups[i]);
      g.setAttributeNS(null, 'class', c + '-group');

      this.domElements.groups[groups[i]] =
        this.domElements.graph.appendChild(g);
    }

    // Appending measurement canvas
    this.container.appendChild(canvas);
    this.measurementCanvas = canvas.getContext('2d');
  };

  /**
   * This method hides a batch of SVG DOM elements.
   *
   * @param  {array}                  elements  An array of elements to hide.
   * @param  {object}                 renderer  The renderer to use.
   * @return {sigma.renderers.svg}              Returns the instance itself.
   */
  sigma.renderers.svg.prototype.hideDOMElements = function(elements) {
    var o,
        i;

    for (i in elements) {
      o = elements[i];
      sigma.svg.utils.hide(o);
    }

    return this;
  };

  /**
   * This method binds the hover events to the renderer.
   *
   * @param  {string} prefix The renderer prefix.
   */
  // TODO: add option about whether to display hovers or not
  sigma.renderers.svg.prototype.bindHovers = function(prefix) {
    var renderers = sigma.svg.hovers,
        self = this,
        hoveredNode;

    function overNode(e) {
      var node = e.data.node,
          embedSettings = self.settings.embedObjects({
            prefix: prefix
          });

      if (!embedSettings('enableHovering'))
        return;

      var hover = (renderers[node.type] || renderers.def).create(
        node,
        self.domElements.nodes[node.id],
        self.measurementCanvas,
        embedSettings
      );

      self.domElements.hovers[node.id] = hover;

      // Inserting the hover in the dom
      self.domElements.groups.hovers.appendChild(hover);
      hoveredNode = node;
    }

    function outNode(e) {
      var node = e.data.node,
          embedSettings = self.settings.embedObjects({
            prefix: prefix
          });

      if (!embedSettings('enableHovering'))
        return;

      // Deleting element
      self.domElements.groups.hovers.removeChild(
        self.domElements.hovers[node.id]
      );
      hoveredNode = null;
      delete self.domElements.hovers[node.id];

      // Reinstate
      self.domElements.groups.nodes.appendChild(
        self.domElements.nodes[node.id]
      );
    }

    // OPTIMIZE: perform a real update rather than a deletion
    function update() {
      if (!hoveredNode)
        return;

      var embedSettings = self.settings.embedObjects({
            prefix: prefix
          });

      // Deleting element before update
      self.domElements.groups.hovers.removeChild(
        self.domElements.hovers[hoveredNode.id]
      );
      delete self.domElements.hovers[hoveredNode.id];

      var hover = (renderers[hoveredNode.type] || renderers.def).create(
        hoveredNode,
        self.domElements.nodes[hoveredNode.id],
        self.measurementCanvas,
        embedSettings
      );

      self.domElements.hovers[hoveredNode.id] = hover;

      // Inserting the hover in the dom
      self.domElements.groups.hovers.appendChild(hover);
    }

    // Binding events
    this.bind('overNode', overNode);
    this.bind('outNode', outNode);

    // Update on render
    this.bind('render', update);
  };

  /**
   * This method resizes each DOM elements in the container and stores the new
   * dimensions. Then, it renders the graph.
   *
   * @param  {?number}                width  The new width of the container.
   * @param  {?number}                height The new height of the container.
   * @return {sigma.renderers.svg}           Returns the instance itself.
   */
  sigma.renderers.svg.prototype.resize = function(w, h) {
    var oldWidth = this.width,
        oldHeight = this.height,
        pixelRatio = 1;

    if (w !== undefined && h !== undefined) {
      this.width = w;
      this.height = h;
    } else {
      this.width = this.container.offsetWidth;
      this.height = this.container.offsetHeight;

      w = this.width;
      h = this.height;
    }

    if (oldWidth !== this.width || oldHeight !== this.height) {
      this.domElements.graph.style.width = w + 'px';
      this.domElements.graph.style.height = h + 'px';

      if (this.domElements.graph.tagName.toLowerCase() === 'svg') {
        this.domElements.graph.setAttribute('width', (w * pixelRatio));
        this.domElements.graph.setAttribute('height', (h * pixelRatio));
      }
    }

    return this;
  };


  /**
   * The labels, nodes and edges renderers are stored in the three following
   * objects. When an element is drawn, its type will be checked and if a
   * renderer with the same name exists, it will be used. If not found, the
   * default renderer will be used instead.
   *
   * They are stored in different files, in the "./svg" folder.
   */
  sigma.utils.pkg('sigma.svg.nodes');
  sigma.utils.pkg('sigma.svg.edges');
  sigma.utils.pkg('sigma.svg.labels');
}).call(this);

;(function(global) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.renderers');

  // Check if WebGL is enabled:
  var canvas,
      webgl = !!global.WebGLRenderingContext;
  if (webgl) {
    canvas = document.createElement('canvas');
    try {
      webgl = !!(
        canvas.getContext('webgl') ||
        canvas.getContext('experimental-webgl')
      );
    } catch (e) {
      webgl = false;
    }
  }

  // Copy the good renderer:
  sigma.renderers.def = webgl ?
    sigma.renderers.webgl :
    sigma.renderers.canvas;
})(this);

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.webgl.nodes');

  /**
   * This node renderer will display nodes as discs, shaped in triangles with
   * the gl.TRIANGLES display mode. So, to be more precise, to draw one node,
   * it will store three times the center of node, with the color and the size,
   * and an angle indicating which "corner" of the triangle to draw.
   *
   * The fragment shader does not deal with anti-aliasing, so make sure that
   * you deal with it somewhere else in the code (by default, the WebGL
   * renderer will oversample the rendering through the webglOversamplingRatio
   * value).
   */
  sigma.webgl.nodes.def = {
    POINTS: 3,
    ATTRIBUTES: 5,
    addNode: function(node, data, i, prefix, settings) {
      var color = sigma.utils.floatColor(
        node.color || settings('defaultNodeColor')
      );

      data[i++] = node[prefix + 'x'];
      data[i++] = node[prefix + 'y'];
      data[i++] = node[prefix + 'size'];
      data[i++] = color;
      data[i++] = 0;

      data[i++] = node[prefix + 'x'];
      data[i++] = node[prefix + 'y'];
      data[i++] = node[prefix + 'size'];
      data[i++] = color;
      data[i++] = 2 * Math.PI / 3;

      data[i++] = node[prefix + 'x'];
      data[i++] = node[prefix + 'y'];
      data[i++] = node[prefix + 'size'];
      data[i++] = color;
      data[i++] = 4 * Math.PI / 3;
    },
    render: function(gl, program, data, params) {
      var buffer;

      // Define attributes:
      var positionLocation =
            gl.getAttribLocation(program, 'a_position'),
          sizeLocation =
            gl.getAttribLocation(program, 'a_size'),
          colorLocation =
            gl.getAttribLocation(program, 'a_color'),
          angleLocation =
            gl.getAttribLocation(program, 'a_angle'),
          resolutionLocation =
            gl.getUniformLocation(program, 'u_resolution'),
          matrixLocation =
            gl.getUniformLocation(program, 'u_matrix'),
          ratioLocation =
            gl.getUniformLocation(program, 'u_ratio'),
          scaleLocation =
            gl.getUniformLocation(program, 'u_scale');

      buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(gl.ARRAY_BUFFER, data, gl.DYNAMIC_DRAW);

      gl.uniform2f(resolutionLocation, params.width, params.height);
      gl.uniform1f(
        ratioLocation,
        1 / Math.pow(params.ratio, params.settings('nodesPowRatio'))
      );
      gl.uniform1f(scaleLocation, params.scalingRatio);
      gl.uniformMatrix3fv(matrixLocation, false, params.matrix);

      gl.enableVertexAttribArray(positionLocation);
      gl.enableVertexAttribArray(sizeLocation);
      gl.enableVertexAttribArray(colorLocation);
      gl.enableVertexAttribArray(angleLocation);

      gl.vertexAttribPointer(
        positionLocation,
        2,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        0
      );
      gl.vertexAttribPointer(
        sizeLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        8
      );
      gl.vertexAttribPointer(
        colorLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        12
      );
      gl.vertexAttribPointer(
        angleLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        16
      );

      gl.drawArrays(
        gl.TRIANGLES,
        params.start || 0,
        params.count || (data.length / this.ATTRIBUTES)
      );
    },
    initProgram: function(gl) {
      var vertexShader,
          fragmentShader,
          program;

      vertexShader = sigma.utils.loadShader(
        gl,
        [
          'attribute vec2 a_position;',
          'attribute float a_size;',
          'attribute float a_color;',
          'attribute float a_angle;',

          'uniform vec2 u_resolution;',
          'uniform float u_ratio;',
          'uniform float u_scale;',
          'uniform mat3 u_matrix;',

          'varying vec4 color;',
          'varying vec2 center;',
          'varying float radius;',

          'void main() {',
            // Multiply the point size twice:
            'radius = a_size * u_ratio;',

            // Scale from [[-1 1] [-1 1]] to the container:
            'vec2 position = (u_matrix * vec3(a_position, 1)).xy;',
            // 'center = (position / u_resolution * 2.0 - 1.0) * vec2(1, -1);',
            'center = position * u_scale;',
            'center = vec2(center.x, u_scale * u_resolution.y - center.y);',

            'position = position +',
              '2.0 * radius * vec2(cos(a_angle), sin(a_angle));',
            'position = (position / u_resolution * 2.0 - 1.0) * vec2(1, -1);',

            'radius = radius * u_scale;',

            'gl_Position = vec4(position, 0, 1);',

            // Extract the color:
            'float c = a_color;',
            'color.b = mod(c, 256.0); c = floor(c / 256.0);',
            'color.g = mod(c, 256.0); c = floor(c / 256.0);',
            'color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;',
            'color.a = 1.0;',
          '}'
        ].join('\n'),
        gl.VERTEX_SHADER
      );

      fragmentShader = sigma.utils.loadShader(
        gl,
        [
          'precision mediump float;',

          'varying vec4 color;',
          'varying vec2 center;',
          'varying float radius;',

          'void main(void) {',
            'vec4 color0 = vec4(0.0, 0.0, 0.0, 0.0);',

            'vec2 m = gl_FragCoord.xy - center;',
            'float diff = radius - sqrt(m.x * m.x + m.y * m.y);',

            // Here is how we draw a disc instead of a square:
            'if (diff > 0.0)',
              'gl_FragColor = color;',
            'else',
              'gl_FragColor = color0;',
          '}'
        ].join('\n'),
        gl.FRAGMENT_SHADER
      );

      program = sigma.utils.loadProgram(gl, [vertexShader, fragmentShader]);

      return program;
    }
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.webgl.nodes');

  /**
   * This node renderer will display nodes in the fastest way: Nodes are basic
   * squares, drawn through the gl.POINTS drawing method. The size of the nodes
   * are represented with the "gl_PointSize" value in the vertex shader.
   *
   * It is the fastest node renderer here since the buffer just takes one line
   * to draw each node (with attributes "x", "y", "size" and "color").
   *
   * Nevertheless, this method has some problems, especially due to some issues
   * with the gl.POINTS:
   *  - First, if the center of a node is outside the scene, the point will not
   *    be drawn, even if it should be partly on screen.
   *  - I tried applying a fragment shader similar to the one in the default
   *    node renderer to display them as discs, but it did not work fine on
   *    some computers settings, filling the discs with weird gradients not
   *    depending on the actual color.
   */
  sigma.webgl.nodes.fast = {
    POINTS: 1,
    ATTRIBUTES: 4,
    addNode: function(node, data, i, prefix, settings) {
      data[i++] = node[prefix + 'x'];
      data[i++] = node[prefix + 'y'];
      data[i++] = node[prefix + 'size'];
      data[i++] = sigma.utils.floatColor(
        node.color || settings('defaultNodeColor')
      );
    },
    render: function(gl, program, data, params) {
      var buffer;

      // Define attributes:
      var positionLocation =
            gl.getAttribLocation(program, 'a_position'),
          sizeLocation =
            gl.getAttribLocation(program, 'a_size'),
          colorLocation =
            gl.getAttribLocation(program, 'a_color'),
          resolutionLocation =
            gl.getUniformLocation(program, 'u_resolution'),
          matrixLocation =
            gl.getUniformLocation(program, 'u_matrix'),
          ratioLocation =
            gl.getUniformLocation(program, 'u_ratio'),
          scaleLocation =
            gl.getUniformLocation(program, 'u_scale');

      buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(gl.ARRAY_BUFFER, data, gl.DYNAMIC_DRAW);

      gl.uniform2f(resolutionLocation, params.width, params.height);
      gl.uniform1f(
        ratioLocation,
        1 / Math.pow(params.ratio, params.settings('nodesPowRatio'))
      );
      gl.uniform1f(scaleLocation, params.scalingRatio);
      gl.uniformMatrix3fv(matrixLocation, false, params.matrix);

      gl.enableVertexAttribArray(positionLocation);
      gl.enableVertexAttribArray(sizeLocation);
      gl.enableVertexAttribArray(colorLocation);

      gl.vertexAttribPointer(
        positionLocation,
        2,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        0
      );
      gl.vertexAttribPointer(
        sizeLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        8
      );
      gl.vertexAttribPointer(
        colorLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        12
      );

      gl.drawArrays(
        gl.POINTS,
        params.start || 0,
        params.count || (data.length / this.ATTRIBUTES)
      );
    },
    initProgram: function(gl) {
      var vertexShader,
          fragmentShader,
          program;

      vertexShader = sigma.utils.loadShader(
        gl,
        [
          'attribute vec2 a_position;',
          'attribute float a_size;',
          'attribute float a_color;',

          'uniform vec2 u_resolution;',
          'uniform float u_ratio;',
          'uniform float u_scale;',
          'uniform mat3 u_matrix;',

          'varying vec4 color;',

          'void main() {',
            // Scale from [[-1 1] [-1 1]] to the container:
            'gl_Position = vec4(',
              '((u_matrix * vec3(a_position, 1)).xy /',
                'u_resolution * 2.0 - 1.0) * vec2(1, -1),',
              '0,',
              '1',
            ');',

            // Multiply the point size twice:
            //  - x SCALING_RATIO to correct the canvas scaling
            //  - x 2 to correct the formulae
            'gl_PointSize = a_size * u_ratio * u_scale * 2.0;',

            // Extract the color:
            'float c = a_color;',
            'color.b = mod(c, 256.0); c = floor(c / 256.0);',
            'color.g = mod(c, 256.0); c = floor(c / 256.0);',
            'color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;',
            'color.a = 1.0;',
          '}'
        ].join('\n'),
        gl.VERTEX_SHADER
      );

      fragmentShader = sigma.utils.loadShader(
        gl,
        [
          'precision mediump float;',

          'varying vec4 color;',

          'void main(void) {',
            'float border = 0.01;',
            'float radius = 0.5;',

            'vec4 color0 = vec4(0.0, 0.0, 0.0, 0.0);',
            'vec2 m = gl_PointCoord - vec2(0.5, 0.5);',
            'float dist = radius - sqrt(m.x * m.x + m.y * m.y);',

            'float t = 0.0;',
            'if (dist > border)',
              't = 1.0;',
            'else if (dist > 0.0)',
              't = dist / border;',

            'gl_FragColor = mix(color0, color, t);',
          '}'
        ].join('\n'),
        gl.FRAGMENT_SHADER
      );

      program = sigma.utils.loadProgram(gl, [vertexShader, fragmentShader]);

      return program;
    }
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.webgl.edges');

  /**
   * This edge renderer will display edges as lines going from the source node
   * to the target node. To deal with edge thicknesses, the lines are made of
   * two triangles forming rectangles, with the gl.TRIANGLES drawing mode.
   *
   * It is expensive, since drawing a single edge requires 6 points, each
   * having 7 attributes (source position, target position, thickness, color
   * and a flag indicating which vertice of the rectangle it is).
   */
  sigma.webgl.edges.def = {
    POINTS: 6,
    ATTRIBUTES: 7,
    addEdge: function(edge, source, target, data, i, prefix, settings) {
      var w = (edge[prefix + 'size'] || 1) / 2,
          x1 = source[prefix + 'x'],
          y1 = source[prefix + 'y'],
          x2 = target[prefix + 'x'],
          y2 = target[prefix + 'y'],
          color = edge.color;

      if (!color)
        switch (settings('edgeColor')) {
          case 'source':
            color = source.color || settings('defaultNodeColor');
            break;
          case 'target':
            color = target.color || settings('defaultNodeColor');
            break;
          default:
            color = settings('defaultEdgeColor');
            break;
        }

      // Normalize color:
      color = sigma.utils.floatColor(color);

      data[i++] = x1;
      data[i++] = y1;
      data[i++] = x2;
      data[i++] = y2;
      data[i++] = w;
      data[i++] = 0.0;
      data[i++] = color;

      data[i++] = x2;
      data[i++] = y2;
      data[i++] = x1;
      data[i++] = y1;
      data[i++] = w;
      data[i++] = 1.0;
      data[i++] = color;

      data[i++] = x2;
      data[i++] = y2;
      data[i++] = x1;
      data[i++] = y1;
      data[i++] = w;
      data[i++] = 0.0;
      data[i++] = color;

      data[i++] = x2;
      data[i++] = y2;
      data[i++] = x1;
      data[i++] = y1;
      data[i++] = w;
      data[i++] = 0.0;
      data[i++] = color;

      data[i++] = x1;
      data[i++] = y1;
      data[i++] = x2;
      data[i++] = y2;
      data[i++] = w;
      data[i++] = 1.0;
      data[i++] = color;

      data[i++] = x1;
      data[i++] = y1;
      data[i++] = x2;
      data[i++] = y2;
      data[i++] = w;
      data[i++] = 0.0;
      data[i++] = color;
    },
    render: function(gl, program, data, params) {
      var buffer;

      // Define attributes:
      var colorLocation =
            gl.getAttribLocation(program, 'a_color'),
          positionLocation1 =
            gl.getAttribLocation(program, 'a_position1'),
          positionLocation2 =
            gl.getAttribLocation(program, 'a_position2'),
          thicknessLocation =
            gl.getAttribLocation(program, 'a_thickness'),
          minusLocation =
            gl.getAttribLocation(program, 'a_minus'),
          resolutionLocation =
            gl.getUniformLocation(program, 'u_resolution'),
          matrixLocation =
            gl.getUniformLocation(program, 'u_matrix'),
          matrixHalfPiLocation =
            gl.getUniformLocation(program, 'u_matrixHalfPi'),
          matrixHalfPiMinusLocation =
            gl.getUniformLocation(program, 'u_matrixHalfPiMinus'),
          ratioLocation =
            gl.getUniformLocation(program, 'u_ratio'),
          scaleLocation =
            gl.getUniformLocation(program, 'u_scale');

      buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);

      gl.uniform2f(resolutionLocation, params.width, params.height);
      gl.uniform1f(
        ratioLocation,
        params.ratio / Math.pow(params.ratio, params.settings('edgesPowRatio'))
      );
      gl.uniform1f(scaleLocation, params.scalingRatio);
      gl.uniformMatrix3fv(matrixLocation, false, params.matrix);
      gl.uniformMatrix2fv(
        matrixHalfPiLocation,
        false,
        sigma.utils.matrices.rotation(Math.PI / 2, true)
      );
      gl.uniformMatrix2fv(
        matrixHalfPiMinusLocation,
        false,
        sigma.utils.matrices.rotation(-Math.PI / 2, true)
      );

      gl.enableVertexAttribArray(colorLocation);
      gl.enableVertexAttribArray(positionLocation1);
      gl.enableVertexAttribArray(positionLocation2);
      gl.enableVertexAttribArray(thicknessLocation);
      gl.enableVertexAttribArray(minusLocation);

      gl.vertexAttribPointer(positionLocation1,
        2,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        0
      );
      gl.vertexAttribPointer(positionLocation2,
        2,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        8
      );
      gl.vertexAttribPointer(thicknessLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        16
      );
      gl.vertexAttribPointer(minusLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        20
      );
      gl.vertexAttribPointer(colorLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        24
      );

      gl.drawArrays(
        gl.TRIANGLES,
        params.start || 0,
        params.count || (data.length / this.ATTRIBUTES)
      );
    },
    initProgram: function(gl) {
      var vertexShader,
          fragmentShader,
          program;

      vertexShader = sigma.utils.loadShader(
        gl,
        [
          'attribute vec2 a_position1;',
          'attribute vec2 a_position2;',
          'attribute float a_thickness;',
          'attribute float a_minus;',
          'attribute float a_color;',

          'uniform vec2 u_resolution;',
          'uniform float u_ratio;',
          'uniform float u_scale;',
          'uniform mat3 u_matrix;',
          'uniform mat2 u_matrixHalfPi;',
          'uniform mat2 u_matrixHalfPiMinus;',

          'varying vec4 color;',

          'void main() {',
            // Find the good point:
            'vec2 position = a_thickness * u_ratio *',
              'normalize(a_position2 - a_position1);',

            'mat2 matrix = a_minus * u_matrixHalfPiMinus +',
              '(1.0 - a_minus) * u_matrixHalfPi;',

            'position = matrix * position + a_position1;',

            // Scale from [[-1 1] [-1 1]] to the container:
            'gl_Position = vec4(',
              '((u_matrix * vec3(position, 1)).xy /',
                'u_resolution * 2.0 - 1.0) * vec2(1, -1),',
              '0,',
              '1',
            ');',

            // Extract the color:
            'float c = a_color;',
            'color.b = mod(c, 256.0); c = floor(c / 256.0);',
            'color.g = mod(c, 256.0); c = floor(c / 256.0);',
            'color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;',
            'color.a = 1.0;',
          '}'
        ].join('\n'),
        gl.VERTEX_SHADER
      );

      fragmentShader = sigma.utils.loadShader(
        gl,
        [
          'precision mediump float;',

          'varying vec4 color;',

          'void main(void) {',
            'gl_FragColor = color;',
          '}'
        ].join('\n'),
        gl.FRAGMENT_SHADER
      );

      program = sigma.utils.loadProgram(gl, [vertexShader, fragmentShader]);

      return program;
    }
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.webgl.edges');

  /**
   * This edge renderer will display edges as lines with the gl.LINES display
   * mode. Since this mode does not support well thickness, edges are all drawn
   * with the same thickness (3px), independantly of the edge attributes or the
   * zooming ratio.
   */
  sigma.webgl.edges.fast = {
    POINTS: 2,
    ATTRIBUTES: 3,
    addEdge: function(edge, source, target, data, i, prefix, settings) {
      var w = (edge[prefix + 'size'] || 1) / 2,
          x1 = source[prefix + 'x'],
          y1 = source[prefix + 'y'],
          x2 = target[prefix + 'x'],
          y2 = target[prefix + 'y'],
          color = edge.color;

      if (!color)
        switch (settings('edgeColor')) {
          case 'source':
            color = source.color || settings('defaultNodeColor');
            break;
          case 'target':
            color = target.color || settings('defaultNodeColor');
            break;
          default:
            color = settings('defaultEdgeColor');
            break;
        }

      // Normalize color:
      color = sigma.utils.floatColor(color);

      data[i++] = x1;
      data[i++] = y1;
      data[i++] = color;

      data[i++] = x2;
      data[i++] = y2;
      data[i++] = color;
    },
    render: function(gl, program, data, params) {
      var buffer;

      // Define attributes:
      var colorLocation =
            gl.getAttribLocation(program, 'a_color'),
          positionLocation =
            gl.getAttribLocation(program, 'a_position'),
          resolutionLocation =
            gl.getUniformLocation(program, 'u_resolution'),
          matrixLocation =
            gl.getUniformLocation(program, 'u_matrix');

      buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(gl.ARRAY_BUFFER, data, gl.DYNAMIC_DRAW);

      gl.uniform2f(resolutionLocation, params.width, params.height);
      gl.uniformMatrix3fv(matrixLocation, false, params.matrix);

      gl.enableVertexAttribArray(positionLocation);
      gl.enableVertexAttribArray(colorLocation);

      gl.vertexAttribPointer(positionLocation,
        2,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        0
      );
      gl.vertexAttribPointer(colorLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        8
      );

      gl.lineWidth(3);
      gl.drawArrays(
        gl.LINES,
        params.start || 0,
        params.count || (data.length / this.ATTRIBUTES)
      );
    },
    initProgram: function(gl) {
      var vertexShader,
          fragmentShader,
          program;

      vertexShader = sigma.utils.loadShader(
        gl,
        [
          'attribute vec2 a_position;',
          'attribute float a_color;',

          'uniform vec2 u_resolution;',
          'uniform mat3 u_matrix;',

          'varying vec4 color;',

          'void main() {',
            // Scale from [[-1 1] [-1 1]] to the container:
            'gl_Position = vec4(',
              '((u_matrix * vec3(a_position, 1)).xy /',
                'u_resolution * 2.0 - 1.0) * vec2(1, -1),',
              '0,',
              '1',
            ');',

            // Extract the color:
            'float c = a_color;',
            'color.b = mod(c, 256.0); c = floor(c / 256.0);',
            'color.g = mod(c, 256.0); c = floor(c / 256.0);',
            'color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;',
            'color.a = 1.0;',
          '}'
        ].join('\n'),
        gl.VERTEX_SHADER
      );

      fragmentShader = sigma.utils.loadShader(
        gl,
        [
          'precision mediump float;',

          'varying vec4 color;',

          'void main(void) {',
            'gl_FragColor = color;',
          '}'
        ].join('\n'),
        gl.FRAGMENT_SHADER
      );

      program = sigma.utils.loadProgram(gl, [vertexShader, fragmentShader]);

      return program;
    }
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.webgl.edges');

  /**
   * This edge renderer will display edges as arrows going from the source node
   * to the target node. To deal with edge thicknesses, the lines are made of
   * three triangles: two forming rectangles, with the gl.TRIANGLES drawing
   * mode.
   *
   * It is expensive, since drawing a single edge requires 9 points, each
   * having a lot of attributes.
   */
  sigma.webgl.edges.arrow = {
    POINTS: 9,
    ATTRIBUTES: 11,
    addEdge: function(edge, source, target, data, i, prefix, settings) {
      var w = (edge[prefix + 'size'] || 1) / 2,
          x1 = source[prefix + 'x'],
          y1 = source[prefix + 'y'],
          x2 = target[prefix + 'x'],
          y2 = target[prefix + 'y'],
          targetSize = target[prefix + 'size'],
          color = edge.color;

      if (!color)
        switch (settings('edgeColor')) {
          case 'source':
            color = source.color || settings('defaultNodeColor');
            break;
          case 'target':
            color = target.color || settings('defaultNodeColor');
            break;
          default:
            color = settings('defaultEdgeColor');
            break;
        }

      // Normalize color:
      color = sigma.utils.floatColor(color);

      data[i++] = x1;
      data[i++] = y1;
      data[i++] = x2;
      data[i++] = y2;
      data[i++] = w;
      data[i++] = targetSize;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = color;

      data[i++] = x2;
      data[i++] = y2;
      data[i++] = x1;
      data[i++] = y1;
      data[i++] = w;
      data[i++] = targetSize;
      data[i++] = 1.0;
      data[i++] = 1.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = color;

      data[i++] = x2;
      data[i++] = y2;
      data[i++] = x1;
      data[i++] = y1;
      data[i++] = w;
      data[i++] = targetSize;
      data[i++] = 1.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = color;

      data[i++] = x2;
      data[i++] = y2;
      data[i++] = x1;
      data[i++] = y1;
      data[i++] = w;
      data[i++] = targetSize;
      data[i++] = 1.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = color;

      data[i++] = x1;
      data[i++] = y1;
      data[i++] = x2;
      data[i++] = y2;
      data[i++] = w;
      data[i++] = targetSize;
      data[i++] = 0.0;
      data[i++] = 1.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = color;

      data[i++] = x1;
      data[i++] = y1;
      data[i++] = x2;
      data[i++] = y2;
      data[i++] = w;
      data[i++] = targetSize;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = color;

      // Arrow head:
      data[i++] = x2;
      data[i++] = y2;
      data[i++] = x1;
      data[i++] = y1;
      data[i++] = w;
      data[i++] = targetSize;
      data[i++] = 1.0;
      data[i++] = 0.0;
      data[i++] = 1.0;
      data[i++] = -1.0;
      data[i++] = color;

      data[i++] = x2;
      data[i++] = y2;
      data[i++] = x1;
      data[i++] = y1;
      data[i++] = w;
      data[i++] = targetSize;
      data[i++] = 1.0;
      data[i++] = 0.0;
      data[i++] = 1.0;
      data[i++] = 0.0;
      data[i++] = color;

      data[i++] = x2;
      data[i++] = y2;
      data[i++] = x1;
      data[i++] = y1;
      data[i++] = w;
      data[i++] = targetSize;
      data[i++] = 1.0;
      data[i++] = 0.0;
      data[i++] = 1.0;
      data[i++] = 1.0;
      data[i++] = color;
    },
    render: function(gl, program, data, params) {
      var buffer;

      // Define attributes:
      var positionLocation1 =
            gl.getAttribLocation(program, 'a_pos1'),
          positionLocation2 =
            gl.getAttribLocation(program, 'a_pos2'),
          thicknessLocation =
            gl.getAttribLocation(program, 'a_thickness'),
          targetSizeLocation =
            gl.getAttribLocation(program, 'a_tSize'),
          delayLocation =
            gl.getAttribLocation(program, 'a_delay'),
          minusLocation =
            gl.getAttribLocation(program, 'a_minus'),
          headLocation =
            gl.getAttribLocation(program, 'a_head'),
          headPositionLocation =
            gl.getAttribLocation(program, 'a_headPosition'),
          colorLocation =
            gl.getAttribLocation(program, 'a_color'),
          resolutionLocation =
            gl.getUniformLocation(program, 'u_resolution'),
          matrixLocation =
            gl.getUniformLocation(program, 'u_matrix'),
          matrixHalfPiLocation =
            gl.getUniformLocation(program, 'u_matrixHalfPi'),
          matrixHalfPiMinusLocation =
            gl.getUniformLocation(program, 'u_matrixHalfPiMinus'),
          ratioLocation =
            gl.getUniformLocation(program, 'u_ratio'),
          nodeRatioLocation =
            gl.getUniformLocation(program, 'u_nodeRatio'),
          arrowHeadLocation =
            gl.getUniformLocation(program, 'u_arrowHead'),
          scaleLocation =
            gl.getUniformLocation(program, 'u_scale');

      buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);

      gl.uniform2f(resolutionLocation, params.width, params.height);
      gl.uniform1f(
        ratioLocation,
        params.ratio / Math.pow(params.ratio, params.settings('edgesPowRatio'))
      );
      gl.uniform1f(
        nodeRatioLocation,
        Math.pow(params.ratio, params.settings('nodesPowRatio')) /
        params.ratio
      );
      gl.uniform1f(arrowHeadLocation, 5.0);
      gl.uniform1f(scaleLocation, params.scalingRatio);
      gl.uniformMatrix3fv(matrixLocation, false, params.matrix);
      gl.uniformMatrix2fv(
        matrixHalfPiLocation,
        false,
        sigma.utils.matrices.rotation(Math.PI / 2, true)
      );
      gl.uniformMatrix2fv(
        matrixHalfPiMinusLocation,
        false,
        sigma.utils.matrices.rotation(-Math.PI / 2, true)
      );

      gl.enableVertexAttribArray(positionLocation1);
      gl.enableVertexAttribArray(positionLocation2);
      gl.enableVertexAttribArray(thicknessLocation);
      gl.enableVertexAttribArray(targetSizeLocation);
      gl.enableVertexAttribArray(delayLocation);
      gl.enableVertexAttribArray(minusLocation);
      gl.enableVertexAttribArray(headLocation);
      gl.enableVertexAttribArray(headPositionLocation);
      gl.enableVertexAttribArray(colorLocation);

      gl.vertexAttribPointer(positionLocation1,
        2,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        0
      );
      gl.vertexAttribPointer(positionLocation2,
        2,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        8
      );
      gl.vertexAttribPointer(thicknessLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        16
      );
      gl.vertexAttribPointer(targetSizeLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        20
      );
      gl.vertexAttribPointer(delayLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        24
      );
      gl.vertexAttribPointer(minusLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        28
      );
      gl.vertexAttribPointer(headLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        32
      );
      gl.vertexAttribPointer(headPositionLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        36
      );
      gl.vertexAttribPointer(colorLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        40
      );

      gl.drawArrays(
        gl.TRIANGLES,
        params.start || 0,
        params.count || (data.length / this.ATTRIBUTES)
      );
    },
    initProgram: function(gl) {
      var vertexShader,
          fragmentShader,
          program;

      vertexShader = sigma.utils.loadShader(
        gl,
        [
          'attribute vec2 a_pos1;',
          'attribute vec2 a_pos2;',
          'attribute float a_thickness;',
          'attribute float a_tSize;',
          'attribute float a_delay;',
          'attribute float a_minus;',
          'attribute float a_head;',
          'attribute float a_headPosition;',
          'attribute float a_color;',

          'uniform vec2 u_resolution;',
          'uniform float u_ratio;',
          'uniform float u_nodeRatio;',
          'uniform float u_arrowHead;',
          'uniform float u_scale;',
          'uniform mat3 u_matrix;',
          'uniform mat2 u_matrixHalfPi;',
          'uniform mat2 u_matrixHalfPiMinus;',

          'varying vec4 color;',

          'void main() {',
            // Find the good point:
            'vec2 pos = normalize(a_pos2 - a_pos1);',

            'mat2 matrix = (1.0 - a_head) *',
              '(',
                'a_minus * u_matrixHalfPiMinus +',
                '(1.0 - a_minus) * u_matrixHalfPi',
              ') + a_head * (',
                'a_headPosition * u_matrixHalfPiMinus * 0.6 +',
                '(a_headPosition * a_headPosition - 1.0) * mat2(1.0)',
              ');',

            'pos = a_pos1 + (',
              // Deal with body:
              '(1.0 - a_head) * a_thickness * u_ratio * matrix * pos +',
              // Deal with head:
              'a_head * u_arrowHead * a_thickness * u_ratio * matrix * pos +',
              // Deal with delay:
              'a_delay * pos * (',
                'a_tSize / u_nodeRatio +',
                'u_arrowHead * a_thickness * u_ratio',
              ')',
            ');',

            // Scale from [[-1 1] [-1 1]] to the container:
            'gl_Position = vec4(',
              '((u_matrix * vec3(pos, 1)).xy /',
                'u_resolution * 2.0 - 1.0) * vec2(1, -1),',
              '0,',
              '1',
            ');',

            // Extract the color:
            'float c = a_color;',
            'color.b = mod(c, 256.0); c = floor(c / 256.0);',
            'color.g = mod(c, 256.0); c = floor(c / 256.0);',
            'color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;',
            'color.a = 1.0;',
          '}'
        ].join('\n'),
        gl.VERTEX_SHADER
      );

      fragmentShader = sigma.utils.loadShader(
        gl,
        [
          'precision mediump float;',

          'varying vec4 color;',

          'void main(void) {',
            'gl_FragColor = color;',
          '}'
        ].join('\n'),
        gl.FRAGMENT_SHADER
      );

      program = sigma.utils.loadProgram(gl, [vertexShader, fragmentShader]);

      return program;
    }
  };
})();

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.canvas.labels');

  /**
   * This label renderer will just display the label on the right of the node.
   *
   * @param  {object}                   node     The node object.
   * @param  {CanvasRenderingContext2D} context  The canvas context.
   * @param  {configurable}             settings The settings function.
   */
  sigma.canvas.labels.def = function(node, context, settings) {
    var fontSize,
        prefix = settings('prefix') || '',
        size = node[prefix + 'size'];

    if (size < settings('labelThreshold'))
      return;

    if (!node.label || typeof node.label !== 'string')
      return;

    fontSize = (settings('labelSize') === 'fixed') ?
      settings('defaultLabelSize') :
      settings('labelSizeRatio') * size;

    context.font = (settings('fontStyle') ? settings('fontStyle') + ' ' : '') +
      fontSize + 'px ' + settings('font');
    context.fillStyle = (settings('labelColor') === 'node') ?
      (node.color || settings('defaultNodeColor')) :
      settings('defaultLabelColor');

    context.fillText(
      node.label,
      Math.round(node[prefix + 'x'] + size + 3),
      Math.round(node[prefix + 'y'] + fontSize / 3)
    );
  };
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.canvas.hovers');

  /**
   * This hover renderer will basically display the label with a background.
   *
   * @param  {object}                   node     The node object.
   * @param  {CanvasRenderingContext2D} context  The canvas context.
   * @param  {configurable}             settings The settings function.
   */
  sigma.canvas.hovers.def = function(node, context, settings) {
    var x,
        y,
        w,
        h,
        e,
        fontStyle = settings('hoverFontStyle') || settings('fontStyle'),
        prefix = settings('prefix') || '',
        size = node[prefix + 'size'],
        fontSize = (settings('labelSize') === 'fixed') ?
          settings('defaultLabelSize') :
          settings('labelSizeRatio') * size;

    // Label background:
    context.font = (fontStyle ? fontStyle + ' ' : '') +
      fontSize + 'px ' + (settings('hoverFont') || settings('font'));

    context.beginPath();
    context.fillStyle = settings('labelHoverBGColor') === 'node' ?
      (node.color || settings('defaultNodeColor')) :
      settings('defaultHoverLabelBGColor');

    if (node.label && settings('labelHoverShadow')) {
      context.shadowOffsetX = 0;
      context.shadowOffsetY = 0;
      context.shadowBlur = 8;
      context.shadowColor = settings('labelHoverShadowColor');
    }

    if (node.label && typeof node.label === 'string') {
      x = Math.round(node[prefix + 'x'] - fontSize / 2 - 2);
      y = Math.round(node[prefix + 'y'] - fontSize / 2 - 2);
      w = Math.round(
        context.measureText(node.label).width + fontSize / 2 + size + 7
      );
      h = Math.round(fontSize + 4);
      e = Math.round(fontSize / 2 + 2);

      context.moveTo(x, y + e);
      context.arcTo(x, y, x + e, y, e);
      context.lineTo(x + w, y);
      context.lineTo(x + w, y + h);
      context.lineTo(x + e, y + h);
      context.arcTo(x, y + h, x, y + h - e, e);
      context.lineTo(x, y + e);

      context.closePath();
      context.fill();

      context.shadowOffsetX = 0;
      context.shadowOffsetY = 0;
      context.shadowBlur = 0;
    }

    // Node border:
    if (settings('borderSize') > 0) {
      context.beginPath();
      context.fillStyle = settings('nodeBorderColor') === 'node' ?
        (node.color || settings('defaultNodeColor')) :
        settings('defaultNodeBorderColor');
      context.arc(
        node[prefix + 'x'],
        node[prefix + 'y'],
        size + settings('borderSize'),
        0,
        Math.PI * 2,
        true
      );
      context.closePath();
      context.fill();
    }

    // Node:
    var nodeRenderer = sigma.canvas.nodes[node.type] || sigma.canvas.nodes.def;
    nodeRenderer(node, context, settings);

    // Display the label:
    if (node.label && typeof node.label === 'string') {
      context.fillStyle = (settings('labelHoverColor') === 'node') ?
        (node.color || settings('defaultNodeColor')) :
        settings('defaultLabelHoverColor');

      context.fillText(
        node.label,
        Math.round(node[prefix + 'x'] + size + 3),
        Math.round(node[prefix + 'y'] + fontSize / 3)
      );
    }
  };
}).call(this);

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.canvas.nodes');

  /**
   * The default node renderer. It renders the node as a simple disc.
   *
   * @param  {object}                   node     The node object.
   * @param  {CanvasRenderingContext2D} context  The canvas context.
   * @param  {configurable}             settings The settings function.
   */
  sigma.canvas.nodes.def = function(node, context, settings) {
    var prefix = settings('prefix') || '';

    context.fillStyle = node.color || settings('defaultNodeColor');
    context.beginPath();
    context.arc(
      node[prefix + 'x'],
      node[prefix + 'y'],
      node[prefix + 'size'],
      0,
      Math.PI * 2,
      true
    );

    context.closePath();
    context.fill();
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.canvas.edges');

  /**
   * The default edge renderer. It renders the edge as a simple line.
   *
   * @param  {object}                   edge         The edge object.
   * @param  {object}                   source node  The edge source node.
   * @param  {object}                   target node  The edge target node.
   * @param  {CanvasRenderingContext2D} context      The canvas context.
   * @param  {configurable}             settings     The settings function.
   */
  sigma.canvas.edges.def = function(edge, source, target, context, settings) {
    var color = edge.color,
        prefix = settings('prefix') || '',
        size = edge[prefix + 'size'] || 1,
        edgeColor = settings('edgeColor'),
        defaultNodeColor = settings('defaultNodeColor'),
        defaultEdgeColor = settings('defaultEdgeColor');

    if (!color)
      switch (edgeColor) {
        case 'source':
          color = source.color || defaultNodeColor;
          break;
        case 'target':
          color = target.color || defaultNodeColor;
          break;
        default:
          color = defaultEdgeColor;
          break;
      }

    context.strokeStyle = color;
    context.lineWidth = size;
    context.beginPath();
    context.moveTo(
      source[prefix + 'x'],
      source[prefix + 'y']
    );
    context.lineTo(
      target[prefix + 'x'],
      target[prefix + 'y']
    );
    context.stroke();
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.canvas.edges');

  /**
   * This edge renderer will display edges as arrows going from the source node
   *
   * @param  {object}                   edge         The edge object.
   * @param  {object}                   source node  The edge source node.
   * @param  {object}                   target node  The edge target node.
   * @param  {CanvasRenderingContext2D} context      The canvas context.
   * @param  {configurable}             settings     The settings function.
   */
  sigma.canvas.edges.arrow = function(edge, source, target, context, settings) {
    var color = edge.color,
        prefix = settings('prefix') || '',
        edgeColor = settings('edgeColor'),
        defaultNodeColor = settings('defaultNodeColor'),
        defaultEdgeColor = settings('defaultEdgeColor'),
        size = edge[prefix + 'size'] || 1,
        tSize = target[prefix + 'size'],
        sX = source[prefix + 'x'],
        sY = source[prefix + 'y'],
        tX = target[prefix + 'x'],
        tY = target[prefix + 'y'],
        aSize = Math.max(size * 2.5, settings('minArrowSize')),
        d = Math.sqrt(Math.pow(tX - sX, 2) + Math.pow(tY - sY, 2)),
        aX = sX + (tX - sX) * (d - aSize - tSize) / d,
        aY = sY + (tY - sY) * (d - aSize - tSize) / d,
        vX = (tX - sX) * aSize / d,
        vY = (tY - sY) * aSize / d;

    if (!color)
      switch (edgeColor) {
        case 'source':
          color = source.color || defaultNodeColor;
          break;
        case 'target':
          color = target.color || defaultNodeColor;
          break;
        default:
          color = defaultEdgeColor;
          break;
      }

    context.strokeStyle = color;
    context.lineWidth = size;
    context.beginPath();
    context.moveTo(sX, sY);
    context.lineTo(
      aX,
      aY
    );
    context.stroke();

    context.fillStyle = color;
    context.beginPath();
    context.moveTo(aX + vX, aY + vY);
    context.lineTo(aX + vY * 0.6, aY - vX * 0.6);
    context.lineTo(aX - vY * 0.6, aY + vX * 0.6);
    context.lineTo(aX + vX, aY + vY);
    context.closePath();
    context.fill();
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.canvas.edgehovers');

  /**
   * This hover renderer will display the edge with a different color or size.
   *
   * @param  {object}                   edge         The edge object.
   * @param  {object}                   source node  The edge source node.
   * @param  {object}                   target node  The edge target node.
   * @param  {CanvasRenderingContext2D} context      The canvas context.
   * @param  {configurable}             settings     The settings function.
   */
  sigma.canvas.edgehovers.def =
    function(edge, source, target, context, settings) {
      var color = edge.color,
        prefix = settings('prefix') || '',
        size = edge[prefix + 'size'] || 1,
        edgeColor = settings('edgeColor'),
        defaultNodeColor = settings('defaultNodeColor'),
        defaultEdgeColor = settings('defaultEdgeColor');

    if (!color)
      switch (edgeColor) {
        case 'source':
          color = source.color || defaultNodeColor;
          break;
        case 'target':
          color = target.color || defaultNodeColor;
          break;
        default:
          color = defaultEdgeColor;
          break;
      }

    if (settings('edgeHoverColor') === 'edge') {
      color = edge.hover_color || color;
    } else {
      color = edge.hover_color || settings('defaultEdgeHoverColor') || color;
    }
    size *= settings('edgeHoverSizeRatio');

    context.strokeStyle = color;
    context.lineWidth = size;
    context.beginPath();
    context.moveTo(
      source[prefix + 'x'],
      source[prefix + 'y']
    );
    context.lineTo(
      target[prefix + 'x'],
      target[prefix + 'y']
    );
    context.stroke();
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.canvas.edgehovers');

  /**
   * This hover renderer will display the edge with a different color or size.
   *
   * @param  {object}                   edge         The edge object.
   * @param  {object}                   source node  The edge source node.
   * @param  {object}                   target node  The edge target node.
   * @param  {CanvasRenderingContext2D} context      The canvas context.
   * @param  {configurable}             settings     The settings function.
   */
  sigma.canvas.edgehovers.curve =
    function(edge, source, target, context, settings) {
    var color = edge.color,
        prefix = settings('prefix') || '',
        size = settings('edgeHoverSizeRatio') * (edge[prefix + 'size'] || 1),
        edgeColor = settings('edgeColor'),
        defaultNodeColor = settings('defaultNodeColor'),
        defaultEdgeColor = settings('defaultEdgeColor'),
        cp = {},
        sSize = source[prefix + 'size'],
        sX = source[prefix + 'x'],
        sY = source[prefix + 'y'],
        tX = target[prefix + 'x'],
        tY = target[prefix + 'y'];

    cp = (source.id === target.id) ?
      sigma.utils.getSelfLoopControlPoints(sX, sY, sSize) :
      sigma.utils.getQuadraticControlPoint(sX, sY, tX, tY);

    if (!color)
      switch (edgeColor) {
        case 'source':
          color = source.color || defaultNodeColor;
          break;
        case 'target':
          color = target.color || defaultNodeColor;
          break;
        default:
          color = defaultEdgeColor;
          break;
      }

    if (settings('edgeHoverColor') === 'edge') {
      color = edge.hover_color || color;
    } else {
      color = edge.hover_color || settings('defaultEdgeHoverColor') || color;
    }

    context.strokeStyle = color;
    context.lineWidth = size;
    context.beginPath();
    context.moveTo(sX, sY);
    if (source.id === target.id) {
      context.bezierCurveTo(cp.x1, cp.y1, cp.x2, cp.y2, tX, tY);
    } else {
      context.quadraticCurveTo(cp.x, cp.y, tX, tY);
    }
    context.stroke();
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.canvas.edgehovers');

  /**
   * This hover renderer will display the edge with a different color or size.
   *
   * @param  {object}                   edge         The edge object.
   * @param  {object}                   source node  The edge source node.
   * @param  {object}                   target node  The edge target node.
   * @param  {CanvasRenderingContext2D} context      The canvas context.
   * @param  {configurable}             settings     The settings function.
   */
  sigma.canvas.edgehovers.arrow =
    function(edge, source, target, context, settings) {
    var color = edge.color,
        prefix = settings('prefix') || '',
        edgeColor = settings('edgeColor'),
        defaultNodeColor = settings('defaultNodeColor'),
        defaultEdgeColor = settings('defaultEdgeColor'),
        size = edge[prefix + 'size'] || 1,
        tSize = target[prefix + 'size'],
        sX = source[prefix + 'x'],
        sY = source[prefix + 'y'],
        tX = target[prefix + 'x'],
        tY = target[prefix + 'y'];

    size = (edge.hover) ?
      settings('edgeHoverSizeRatio') * size : size;
    var aSize = size * 2.5,
        d = Math.sqrt(Math.pow(tX - sX, 2) + Math.pow(tY - sY, 2)),
        aX = sX + (tX - sX) * (d - aSize - tSize) / d,
        aY = sY + (tY - sY) * (d - aSize - tSize) / d,
        vX = (tX - sX) * aSize / d,
        vY = (tY - sY) * aSize / d;

    if (!color)
      switch (edgeColor) {
        case 'source':
          color = source.color || defaultNodeColor;
          break;
        case 'target':
          color = target.color || defaultNodeColor;
          break;
        default:
          color = defaultEdgeColor;
          break;
      }

    if (settings('edgeHoverColor') === 'edge') {
      color = edge.hover_color || color;
    } else {
      color = edge.hover_color || settings('defaultEdgeHoverColor') || color;
    }

    context.strokeStyle = color;
    context.lineWidth = size;
    context.beginPath();
    context.moveTo(sX, sY);
    context.lineTo(
      aX,
      aY
    );
    context.stroke();

    context.fillStyle = color;
    context.beginPath();
    context.moveTo(aX + vX, aY + vY);
    context.lineTo(aX + vY * 0.6, aY - vX * 0.6);
    context.lineTo(aX - vY * 0.6, aY + vX * 0.6);
    context.lineTo(aX + vX, aY + vY);
    context.closePath();
    context.fill();
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.canvas.edgehovers');

  /**
   * This hover renderer will display the edge with a different color or size.
   *
   * @param  {object}                   edge         The edge object.
   * @param  {object}                   source node  The edge source node.
   * @param  {object}                   target node  The edge target node.
   * @param  {CanvasRenderingContext2D} context      The canvas context.
   * @param  {configurable}             settings     The settings function.
   */
  sigma.canvas.edgehovers.curvedArrow =
    function(edge, source, target, context, settings) {
    var color = edge.color,
        prefix = settings('prefix') || '',
        edgeColor = settings('edgeColor'),
        defaultNodeColor = settings('defaultNodeColor'),
        defaultEdgeColor = settings('defaultEdgeColor'),
        cp = {},
        size = settings('edgeHoverSizeRatio') * (edge[prefix + 'size'] || 1),
        tSize = target[prefix + 'size'],
        sX = source[prefix + 'x'],
        sY = source[prefix + 'y'],
        tX = target[prefix + 'x'],
        tY = target[prefix + 'y'],
        d,
        aSize,
        aX,
        aY,
        vX,
        vY;

    cp = (source.id === target.id) ?
      sigma.utils.getSelfLoopControlPoints(sX, sY, tSize) :
      sigma.utils.getQuadraticControlPoint(sX, sY, tX, tY);

    if (source.id === target.id) {
      d = Math.sqrt(Math.pow(tX - cp.x1, 2) + Math.pow(tY - cp.y1, 2));
      aSize = size * 2.5;
      aX = cp.x1 + (tX - cp.x1) * (d - aSize - tSize) / d;
      aY = cp.y1 + (tY - cp.y1) * (d - aSize - tSize) / d;
      vX = (tX - cp.x1) * aSize / d;
      vY = (tY - cp.y1) * aSize / d;
    }
    else {
      d = Math.sqrt(Math.pow(tX - cp.x, 2) + Math.pow(tY - cp.y, 2));
      aSize = size * 2.5;
      aX = cp.x + (tX - cp.x) * (d - aSize - tSize) / d;
      aY = cp.y + (tY - cp.y) * (d - aSize - tSize) / d;
      vX = (tX - cp.x) * aSize / d;
      vY = (tY - cp.y) * aSize / d;
    }

    if (!color)
      switch (edgeColor) {
        case 'source':
          color = source.color || defaultNodeColor;
          break;
        case 'target':
          color = target.color || defaultNodeColor;
          break;
        default:
          color = defaultEdgeColor;
          break;
      }

    if (settings('edgeHoverColor') === 'edge') {
      color = edge.hover_color || color;
    } else {
      color = edge.hover_color || settings('defaultEdgeHoverColor') || color;
    }

    context.strokeStyle = color;
    context.lineWidth = size;
    context.beginPath();
    context.moveTo(sX, sY);
    if (source.id === target.id) {
      context.bezierCurveTo(cp.x2, cp.y2, cp.x1, cp.y1, aX, aY);
    } else {
      context.quadraticCurveTo(cp.x, cp.y, aX, aY);
    }
    context.stroke();

    context.fillStyle = color;
    context.beginPath();
    context.moveTo(aX + vX, aY + vY);
    context.lineTo(aX + vY * 0.6, aY - vX * 0.6);
    context.lineTo(aX - vY * 0.6, aY + vX * 0.6);
    context.lineTo(aX + vX, aY + vY);
    context.closePath();
    context.fill();
  };
})();

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.canvas.extremities');

  /**
   * The default renderer for hovered edge extremities. It renders the edge
   * extremities as hovered.
   *
   * @param  {object}                   edge         The edge object.
   * @param  {object}                   source node  The edge source node.
   * @param  {object}                   target node  The edge target node.
   * @param  {CanvasRenderingContext2D} context      The canvas context.
   * @param  {configurable}             settings     The settings function.
   */
  sigma.canvas.extremities.def =
    function(edge, source, target, context, settings) {
    // Source Node:
    (
      sigma.canvas.hovers[source.type] ||
      sigma.canvas.hovers.def
    ) (
      source, context, settings
    );

    // Target Node:
    (
      sigma.canvas.hovers[target.type] ||
      sigma.canvas.hovers.def
    ) (
      target, context, settings
    );
  };
}).call(this);

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.svg.utils');

  /**
   * Some useful functions used by sigma's SVG renderer.
   */
  sigma.svg.utils = {

    /**
     * SVG Element show.
     *
     * @param  {DOMElement}               element   The DOM element to show.
     */
    show: function(element) {
      element.style.display = '';
      return this;
    },

    /**
     * SVG Element hide.
     *
     * @param  {DOMElement}               element   The DOM element to hide.
     */
    hide: function(element) {
      element.style.display = 'none';
      return this;
    }
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.svg.nodes');

  /**
   * The default node renderer. It renders the node as a simple disc.
   */
  sigma.svg.nodes.def = {

    /**
     * SVG Element creation.
     *
     * @param  {object}                   node     The node object.
     * @param  {configurable}             settings The settings function.
     */
    create: function(node, settings) {
      var prefix = settings('prefix') || '',
          circle = document.createElementNS(settings('xmlns'), 'circle');

      // Defining the node's circle
      circle.setAttributeNS(null, 'data-node-id', node.id);
      circle.setAttributeNS(null, 'class', settings('classPrefix') + '-node');
      circle.setAttributeNS(
        null, 'fill', node.color || settings('defaultNodeColor'));

      // Returning the DOM Element
      return circle;
    },

    /**
     * SVG Element update.
     *
     * @param  {object}                   node     The node object.
     * @param  {DOMElement}               circle   The node DOM element.
     * @param  {configurable}             settings The settings function.
     */
    update: function(node, circle, settings) {
      var prefix = settings('prefix') || '';

      // Applying changes
      // TODO: optimize - check if necessary
      circle.setAttributeNS(null, 'cx', node[prefix + 'x']);
      circle.setAttributeNS(null, 'cy', node[prefix + 'y']);
      circle.setAttributeNS(null, 'r', node[prefix + 'size']);

      // Updating only if not freestyle
      if (!settings('freeStyle'))
        circle.setAttributeNS(
          null, 'fill', node.color || settings('defaultNodeColor'));

      // Showing
      circle.style.display = '';

      return this;
    }
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.svg.edges');

  /**
   * The default edge renderer. It renders the node as a simple line.
   */
  sigma.svg.edges.def = {

    /**
     * SVG Element creation.
     *
     * @param  {object}                   edge       The edge object.
     * @param  {object}                   source     The source node object.
     * @param  {object}                   target     The target node object.
     * @param  {configurable}             settings   The settings function.
     */
    create: function(edge, source, target, settings) {
      var color = edge.color,
          prefix = settings('prefix') || '',
          edgeColor = settings('edgeColor'),
          defaultNodeColor = settings('defaultNodeColor'),
          defaultEdgeColor = settings('defaultEdgeColor');

      if (!color)
        switch (edgeColor) {
          case 'source':
            color = source.color || defaultNodeColor;
            break;
          case 'target':
            color = target.color || defaultNodeColor;
            break;
          default:
            color = defaultEdgeColor;
            break;
        }

      var line = document.createElementNS(settings('xmlns'), 'line');

      // Attributes
      line.setAttributeNS(null, 'data-edge-id', edge.id);
      line.setAttributeNS(null, 'class', settings('classPrefix') + '-edge');
      line.setAttributeNS(null, 'stroke', color);

      return line;
    },

    /**
     * SVG Element update.
     *
     * @param  {object}                   edge       The edge object.
     * @param  {DOMElement}               line       The line DOM Element.
     * @param  {object}                   source     The source node object.
     * @param  {object}                   target     The target node object.
     * @param  {configurable}             settings   The settings function.
     */
    update: function(edge, line, source, target, settings) {
      var prefix = settings('prefix') || '';

      line.setAttributeNS(null, 'stroke-width', edge[prefix + 'size'] || 1);
      line.setAttributeNS(null, 'x1', source[prefix + 'x']);
      line.setAttributeNS(null, 'y1', source[prefix + 'y']);
      line.setAttributeNS(null, 'x2', target[prefix + 'x']);
      line.setAttributeNS(null, 'y2', target[prefix + 'y']);

      // Showing
      line.style.display = '';

      return this;
    }
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.svg.edges');

  /**
   * The curve edge renderer. It renders the node as a bezier curve.
   */
  sigma.svg.edges.curve = {

    /**
     * SVG Element creation.
     *
     * @param  {object}                   edge       The edge object.
     * @param  {object}                   source     The source node object.
     * @param  {object}                   target     The target node object.
     * @param  {configurable}             settings   The settings function.
     */
    create: function(edge, source, target, settings) {
      var color = edge.color,
          prefix = settings('prefix') || '',
          edgeColor = settings('edgeColor'),
          defaultNodeColor = settings('defaultNodeColor'),
          defaultEdgeColor = settings('defaultEdgeColor');

      if (!color)
        switch (edgeColor) {
          case 'source':
            color = source.color || defaultNodeColor;
            break;
          case 'target':
            color = target.color || defaultNodeColor;
            break;
          default:
            color = defaultEdgeColor;
            break;
        }

      var path = document.createElementNS(settings('xmlns'), 'path');

      // Attributes
      path.setAttributeNS(null, 'data-edge-id', edge.id);
      path.setAttributeNS(null, 'class', settings('classPrefix') + '-edge');
      path.setAttributeNS(null, 'stroke', color);

      return path;
    },

    /**
     * SVG Element update.
     *
     * @param  {object}                   edge       The edge object.
     * @param  {DOMElement}               line       The line DOM Element.
     * @param  {object}                   source     The source node object.
     * @param  {object}                   target     The target node object.
     * @param  {configurable}             settings   The settings function.
     */
    update: function(edge, path, source, target, settings) {
      var prefix = settings('prefix') || '';

      path.setAttributeNS(null, 'stroke-width', edge[prefix + 'size'] || 1);

      // Control point
      var cx = (source[prefix + 'x'] + target[prefix + 'x']) / 2 +
        (target[prefix + 'y'] - source[prefix + 'y']) / 4,
          cy = (source[prefix + 'y'] + target[prefix + 'y']) / 2 +
        (source[prefix + 'x'] - target[prefix + 'x']) / 4;

      // Path
      var p = 'M' + source[prefix + 'x'] + ',' + source[prefix + 'y'] + ' ' +
              'Q' + cx + ',' + cy + ' ' +
              target[prefix + 'x'] + ',' + target[prefix + 'y'];

      // Updating attributes
      path.setAttributeNS(null, 'd', p);
      path.setAttributeNS(null, 'fill', 'none');

      // Showing
      path.style.display = '';

      return this;
    }
  };
})();

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.svg.labels');

  /**
   * The default label renderer. It renders the label as a simple text.
   */
  sigma.svg.labels.def = {

    /**
     * SVG Element creation.
     *
     * @param  {object}                   node       The node object.
     * @param  {configurable}             settings   The settings function.
     */
    create: function(node, settings) {
      var prefix = settings('prefix') || '',
          size = node[prefix + 'size'],
          text = document.createElementNS(settings('xmlns'), 'text');

      var fontSize = (settings('labelSize') === 'fixed') ?
        settings('defaultLabelSize') :
        settings('labelSizeRatio') * size;

      var fontColor = (settings('labelColor') === 'node') ?
        (node.color || settings('defaultNodeColor')) :
        settings('defaultLabelColor');

      text.setAttributeNS(null, 'data-label-target', node.id);
      text.setAttributeNS(null, 'class', settings('classPrefix') + '-label');
      text.setAttributeNS(null, 'font-size', fontSize);
      text.setAttributeNS(null, 'font-family', settings('font'));
      text.setAttributeNS(null, 'fill', fontColor);

      text.innerHTML = node.label;
      text.textContent = node.label;

      return text;
    },

    /**
     * SVG Element update.
     *
     * @param  {object}                   node     The node object.
     * @param  {DOMElement}               text     The label DOM element.
     * @param  {configurable}             settings The settings function.
     */
    update: function(node, text, settings) {
      var prefix = settings('prefix') || '',
          size = node[prefix + 'size'];

      var fontSize = (settings('labelSize') === 'fixed') ?
        settings('defaultLabelSize') :
        settings('labelSizeRatio') * size;

      // Case when we don't want to display the label
      if (!settings('forceLabels') && size < settings('labelThreshold'))
        return;

      if (typeof node.label !== 'string')
        return;

      // Updating
      text.setAttributeNS(null, 'x',
        Math.round(node[prefix + 'x'] + size + 3));
      text.setAttributeNS(null, 'y',
        Math.round(node[prefix + 'y'] + fontSize / 3));

      // Showing
      text.style.display = '';

      return this;
    }
  };
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.svg.hovers');

  /**
   * The default hover renderer.
   */
  sigma.svg.hovers.def = {

    /**
     * SVG Element creation.
     *
     * @param  {object}           node               The node object.
     * @param  {CanvasElement}    measurementCanvas  A fake canvas handled by
     *                            the svg to perform some measurements and
     *                            passed by the renderer.
     * @param  {DOMElement}       nodeCircle         The node DOM Element.
     * @param  {configurable}     settings           The settings function.
     */
    create: function(node, nodeCircle, measurementCanvas, settings) {

      // Defining visual properties
      var x,
          y,
          w,
          h,
          e,
          d,
          fontStyle = settings('hoverFontStyle') || settings('fontStyle'),
          prefix = settings('prefix') || '',
          size = node[prefix + 'size'],
          fontSize = (settings('labelSize') === 'fixed') ?
            settings('defaultLabelSize') :
            settings('labelSizeRatio') * size,
          fontColor = (settings('labelHoverColor') === 'node') ?
                        (node.color || settings('defaultNodeColor')) :
                        settings('defaultLabelHoverColor');

      // Creating elements
      var group = document.createElementNS(settings('xmlns'), 'g'),
          rectangle = document.createElementNS(settings('xmlns'), 'rect'),
          circle = document.createElementNS(settings('xmlns'), 'circle'),
          text = document.createElementNS(settings('xmlns'), 'text');

      // Defining properties
      group.setAttributeNS(null, 'class', settings('classPrefix') + '-hover');
      group.setAttributeNS(null, 'data-node-id', node.id);

      if (typeof node.label === 'string') {

        // Text
        text.innerHTML = node.label;
        text.textContent = node.label;
        text.setAttributeNS(
            null,
            'class',
            settings('classPrefix') + '-hover-label');
        text.setAttributeNS(null, 'font-size', fontSize);
        text.setAttributeNS(null, 'font-family', settings('font'));
        text.setAttributeNS(null, 'fill', fontColor);
        text.setAttributeNS(null, 'x',
          Math.round(node[prefix + 'x'] + size + 3));
        text.setAttributeNS(null, 'y',
          Math.round(node[prefix + 'y'] + fontSize / 3));

        // Measures
        // OPTIMIZE: Find a better way than a measurement canvas
        x = Math.round(node[prefix + 'x'] - fontSize / 2 - 2);
        y = Math.round(node[prefix + 'y'] - fontSize / 2 - 2);
        w = Math.round(
          measurementCanvas.measureText(node.label).width +
            fontSize / 2 + size + 9
        );
        h = Math.round(fontSize + 4);
        e = Math.round(fontSize / 2 + 2);

        // Circle
        circle.setAttributeNS(
            null,
            'class',
            settings('classPrefix') + '-hover-area');
        circle.setAttributeNS(null, 'fill', '#fff');
        circle.setAttributeNS(null, 'cx', node[prefix + 'x']);
        circle.setAttributeNS(null, 'cy', node[prefix + 'y']);
        circle.setAttributeNS(null, 'r', e);

        // Rectangle
        rectangle.setAttributeNS(
            null,
            'class',
            settings('classPrefix') + '-hover-area');
        rectangle.setAttributeNS(null, 'fill', '#fff');
        rectangle.setAttributeNS(null, 'x', node[prefix + 'x'] + e / 4);
        rectangle.setAttributeNS(null, 'y', node[prefix + 'y'] - e);
        rectangle.setAttributeNS(null, 'width', w);
        rectangle.setAttributeNS(null, 'height', h);
      }

      // Appending childs
      group.appendChild(circle);
      group.appendChild(rectangle);
      group.appendChild(text);
      group.appendChild(nodeCircle);

      return group;
    }
  };
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.middlewares');
  sigma.utils.pkg('sigma.utils');

  /**
   * This middleware will rescale the graph such that it takes an optimal space
   * on the renderer.
   *
   * As each middleware, this function is executed in the scope of the sigma
   * instance.
   *
   * @param {?string} readPrefix  The read prefix.
   * @param {?string} writePrefix The write prefix.
   * @param {object}  options     The parameters.
   */
  sigma.middlewares.rescale = function(readPrefix, writePrefix, options) {
    var i,
        l,
        a,
        b,
        c,
        d,
        scale,
        margin,
        n = this.graph.nodes(),
        e = this.graph.edges(),
        settings = this.settings.embedObjects(options || {}),
        bounds = settings('bounds') || sigma.utils.getBoundaries(
          this.graph,
          readPrefix,
          true
        ),
        minX = bounds.minX,
        minY = bounds.minY,
        maxX = bounds.maxX,
        maxY = bounds.maxY,
        sizeMax = bounds.sizeMax,
        weightMax = bounds.weightMax,
        w = settings('width') || 1,
        h = settings('height') || 1,
        rescaleSettings = settings('autoRescale'),
        validSettings = {
          nodePosition: 1,
          nodeSize: 1,
          edgeSize: 1
        };

    /**
     * What elements should we rescale?
     */
    if (!(rescaleSettings instanceof Array))
      rescaleSettings = ['nodePosition', 'nodeSize', 'edgeSize'];

    for (i = 0, l = rescaleSettings.length; i < l; i++)
      if (!validSettings[rescaleSettings[i]])
        throw new Error(
          'The rescale setting "' + rescaleSettings[i] + '" is not recognized.'
        );

    var np = ~rescaleSettings.indexOf('nodePosition'),
        ns = ~rescaleSettings.indexOf('nodeSize'),
        es = ~rescaleSettings.indexOf('edgeSize');

    /**
     * First, we compute the scaling ratio, without considering the sizes
     * of the nodes : Each node will have its center in the canvas, but might
     * be partially out of it.
     */
    scale = settings('scalingMode') === 'outside' ?
      Math.max(
        w / Math.max(maxX - minX, 1),
        h / Math.max(maxY - minY, 1)
      ) :
      Math.min(
        w / Math.max(maxX - minX, 1),
        h / Math.max(maxY - minY, 1)
      );

    /**
     * Then, we correct that scaling ratio considering a margin, which is
     * basically the size of the biggest node.
     * This has to be done as a correction since to compare the size of the
     * biggest node to the X and Y values, we have to first get an
     * approximation of the scaling ratio.
     **/
    margin =
      (
        settings('rescaleIgnoreSize') ?
          0 :
          (settings('maxNodeSize') || sizeMax) / scale
      ) +
      (settings('sideMargin') || 0);
    maxX += margin;
    minX -= margin;
    maxY += margin;
    minY -= margin;

    // Fix the scaling with the new extrema:
    scale = settings('scalingMode') === 'outside' ?
      Math.max(
        w / Math.max(maxX - minX, 1),
        h / Math.max(maxY - minY, 1)
      ) :
      Math.min(
        w / Math.max(maxX - minX, 1),
        h / Math.max(maxY - minY, 1)
      );

    // Size homothetic parameters:
    if (!settings('maxNodeSize') && !settings('minNodeSize')) {
      a = 1;
      b = 0;
    } else if (settings('maxNodeSize') === settings('minNodeSize')) {
      a = 0;
      b = +settings('maxNodeSize');
    } else {
      a = (settings('maxNodeSize') - settings('minNodeSize')) / sizeMax;
      b = +settings('minNodeSize');
    }

    if (!settings('maxEdgeSize') && !settings('minEdgeSize')) {
      c = 1;
      d = 0;
    } else if (settings('maxEdgeSize') === settings('minEdgeSize')) {
      c = 0;
      d = +settings('minEdgeSize');
    } else {
      c = (settings('maxEdgeSize') - settings('minEdgeSize')) / weightMax;
      d = +settings('minEdgeSize');
    }

    // Rescale the nodes and edges:
    for (i = 0, l = e.length; i < l; i++)
      e[i][writePrefix + 'size'] =
        e[i][readPrefix + 'size'] * (es ? c : 1) + (es ? d : 0);

    for (i = 0, l = n.length; i < l; i++) {
      n[i][writePrefix + 'size'] =
        n[i][readPrefix + 'size'] * (ns ? a : 1) + (ns ? b : 0);
      n[i][writePrefix + 'x'] =
        (n[i][readPrefix + 'x'] - (maxX + minX) / 2) * (np ? scale : 1);
      n[i][writePrefix + 'y'] =
        (n[i][readPrefix + 'y'] - (maxY + minY) / 2) * (np ? scale : 1);
    }
  };

  sigma.utils.getBoundaries = function(graph, prefix, doEdges) {
    var i,
        l,
        e = graph.edges(),
        n = graph.nodes(),
        weightMax = -Infinity,
        sizeMax = -Infinity,
        minX = Infinity,
        minY = Infinity,
        maxX = -Infinity,
        maxY = -Infinity;

    if (doEdges)
      for (i = 0, l = e.length; i < l; i++)
        weightMax = Math.max(e[i][prefix + 'size'], weightMax);

    for (i = 0, l = n.length; i < l; i++) {
      sizeMax = Math.max(n[i][prefix + 'size'], sizeMax);
      maxX = Math.max(n[i][prefix + 'x'], maxX);
      minX = Math.min(n[i][prefix + 'x'], minX);
      maxY = Math.max(n[i][prefix + 'y'], maxY);
      minY = Math.min(n[i][prefix + 'y'], minY);
    }

    weightMax = weightMax || 1;
    sizeMax = sizeMax || 1;

    return {
      weightMax: weightMax,
      sizeMax: sizeMax,
      minX: minX,
      minY: minY,
      maxX: maxX,
      maxY: maxY
    };
  };
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.middlewares');

  /**
   * This middleware will just copy the graphic properties.
   *
   * @param {?string} readPrefix  The read prefix.
   * @param {?string} writePrefix The write prefix.
   */
  sigma.middlewares.copy = function(readPrefix, writePrefix) {
    var i,
        l,
        a;

    if (writePrefix + '' === readPrefix + '')
      return;

    a = this.graph.nodes();
    for (i = 0, l = a.length; i < l; i++) {
      a[i][writePrefix + 'x'] = a[i][readPrefix + 'x'];
      a[i][writePrefix + 'y'] = a[i][readPrefix + 'y'];
      a[i][writePrefix + 'size'] = a[i][readPrefix + 'size'];
    }

    a = this.graph.edges();
    for (i = 0, l = a.length; i < l; i++)
      a[i][writePrefix + 'size'] = a[i][readPrefix + 'size'];
  };
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.misc.animation.running');

  /**
   * Generates a unique ID for the animation.
   *
   * @return {string} Returns the new ID.
   */
  var _getID = (function() {
    var id = 0;
    return function() {
      return '' + (++id);
    };
  })();

  /**
   * This function animates a camera. It has to be called with the camera to
   * animate, the values of the coordinates to reach and eventually some
   * options. It returns a number id, that you can use to kill the animation,
   * with the method sigma.misc.animation.kill(id).
   *
   * The available options are:
   *
   *   {?number}            duration   The duration of the animation.
   *   {?function}          onNewFrame A callback to execute when the animation
   *                                   enter a new frame.
   *   {?function}          onComplete A callback to execute when the animation
   *                                   is completed or killed.
   *   {?(string|function)} easing     The name of a function from the package
   *                                   sigma.utils.easings, or a custom easing
   *                                   function.
   *
   * @param  {camera}  camera  The camera to animate.
   * @param  {object}  target  The coordinates to reach.
   * @param  {?object} options Eventually an object to specify some options to
   *                           the function. The available options are
   *                           presented in the description of the function.
   * @return {number}          The animation id, to make it easy to kill
   *                           through the method "sigma.misc.animation.kill".
   */
  sigma.misc.animation.camera = function(camera, val, options) {
    if (
      !(camera instanceof sigma.classes.camera) ||
      typeof val !== 'object' ||
      !val
    )
      throw 'animation.camera: Wrong arguments.';

    if (
      typeof val.x !== 'number' &&
      typeof val.y !== 'number' &&
      typeof val.ratio !== 'number' &&
      typeof val.angle !== 'number'
    )
      throw 'There must be at least one valid coordinate in the given val.';

    var fn,
        id,
        anim,
        easing,
        duration,
        initialVal,
        o = options || {},
        start = sigma.utils.dateNow();

    // Store initial values:
    initialVal = {
      x: camera.x,
      y: camera.y,
      ratio: camera.ratio,
      angle: camera.angle
    };

    duration = o.duration;
    easing = typeof o.easing !== 'function' ?
      sigma.utils.easings[o.easing || 'quadraticInOut'] :
      o.easing;

    fn = function() {
      var coef,
          t = o.duration ? (sigma.utils.dateNow() - start) / o.duration : 1;

      // If the animation is over:
      if (t >= 1) {
        camera.isAnimated = false;
        camera.goTo({
          x: val.x !== undefined ? val.x : initialVal.x,
          y: val.y !== undefined ? val.y : initialVal.y,
          ratio: val.ratio !== undefined ? val.ratio : initialVal.ratio,
          angle: val.angle !== undefined ? val.angle : initialVal.angle
        });

        cancelAnimationFrame(id);
        delete sigma.misc.animation.running[id];

        // Check callbacks:
        if (typeof o.onComplete === 'function')
          o.onComplete();

      // Else, let's keep going:
      } else {
        coef = easing(t);
        camera.isAnimated = true;
        camera.goTo({
          x: val.x !== undefined ?
            initialVal.x + (val.x - initialVal.x) * coef :
            initialVal.x,
          y: val.y !== undefined ?
            initialVal.y + (val.y - initialVal.y) * coef :
            initialVal.y,
          ratio: val.ratio !== undefined ?
            initialVal.ratio + (val.ratio - initialVal.ratio) * coef :
            initialVal.ratio,
          angle: val.angle !== undefined ?
            initialVal.angle + (val.angle - initialVal.angle) * coef :
            initialVal.angle
        });

        // Check callbacks:
        if (typeof o.onNewFrame === 'function')
          o.onNewFrame();

        anim.frameId = requestAnimationFrame(fn);
      }
    };

    id = _getID();
    anim = {
      frameId: requestAnimationFrame(fn),
      target: camera,
      type: 'camera',
      options: o,
      fn: fn
    };
    sigma.misc.animation.running[id] = anim;

    return id;
  };

  /**
   * Kills a running animation. It triggers the eventual onComplete callback.
   *
   * @param  {number} id  The id of the animation to kill.
   * @return {object}     Returns the sigma.misc.animation package.
   */
  sigma.misc.animation.kill = function(id) {
    if (arguments.length !== 1 || typeof id !== 'number')
      throw 'animation.kill: Wrong arguments.';

    var o = sigma.misc.animation.running[id];

    if (o) {
      cancelAnimationFrame(id);
      delete sigma.misc.animation.running[o.frameId];

      if (o.type === 'camera')
        o.target.isAnimated = false;

      // Check callbacks:
      if (typeof (o.options || {}).onComplete === 'function')
        o.options.onComplete();
    }

    return this;
  };

  /**
   * Kills every running animations, or only the one with the specified type,
   * if a string parameter is given.
   *
   * @param  {?(string|object)} filter A string to filter the animations to kill
   *                                   on their type (example: "camera"), or an
   *                                   object to filter on their target.
   * @return {number}                  Returns the number of animations killed
   *                                   that way.
   */
  sigma.misc.animation.killAll = function(filter) {
    var o,
        id,
        count = 0,
        type = typeof filter === 'string' ? filter : null,
        target = typeof filter === 'object' ? filter : null,
        running = sigma.misc.animation.running;

    for (id in running)
      if (
        (!type || running[id].type === type) &&
        (!target || running[id].target === target)
      ) {
        o = sigma.misc.animation.running[id];
        cancelAnimationFrame(o.frameId);
        delete sigma.misc.animation.running[id];

        if (o.type === 'camera')
          o.target.isAnimated = false;

        // Increment counter:
        count++;

        // Check callbacks:
        if (typeof (o.options || {}).onComplete === 'function')
          o.options.onComplete();
      }

    return count;
  };

  /**
   * Returns "true" if any animation that is currently still running matches
   * the filter given to the function.
   *
   * @param  {string|object} filter A string to filter the animations to kill
   *                                on their type (example: "camera"), or an
   *                                object to filter on their target.
   * @return {boolean}              Returns true if any running animation
   *                                matches.
   */
  sigma.misc.animation.has = function(filter) {
    var id,
        type = typeof filter === 'string' ? filter : null,
        target = typeof filter === 'object' ? filter : null,
        running = sigma.misc.animation.running;

    for (id in running)
      if (
        (!type || running[id].type === type) &&
        (!target || running[id].target === target)
      )
        return true;

    return false;
  };
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.misc');

  /**
   * This helper will bind any no-DOM renderer (for instance canvas or WebGL)
   * to its captors, to properly dispatch the good events to the sigma instance
   * to manage clicking, hovering etc...
   *
   * It has to be called in the scope of the related renderer.
   */
  sigma.misc.bindEvents = function(prefix) {
    var i,
        l,
        mX,
        mY,
        captor,
        self = this;

    function getNodes(e) {
      if (e) {
        mX = 'x' in e.data ? e.data.x : mX;
        mY = 'y' in e.data ? e.data.y : mY;
      }

      var i,
          j,
          l,
          n,
          x,
          y,
          s,
          inserted,
          selected = [],
          modifiedX = mX + self.width / 2,
          modifiedY = mY + self.height / 2,
          point = self.camera.cameraPosition(
            mX,
            mY
          ),
          nodes = self.camera.quadtree.point(
            point.x,
            point.y
          );

      if (nodes.length)
        for (i = 0, l = nodes.length; i < l; i++) {
          n = nodes[i];
          x = n[prefix + 'x'];
          y = n[prefix + 'y'];
          s = n[prefix + 'size'];

          if (
            !n.hidden &&
            modifiedX > x - s &&
            modifiedX < x + s &&
            modifiedY > y - s &&
            modifiedY < y + s &&
            Math.sqrt(
              Math.pow(modifiedX - x, 2) +
              Math.pow(modifiedY - y, 2)
            ) < s
          ) {
            // Insert the node:
            inserted = false;

            for (j = 0; j < selected.length; j++)
              if (n.size > selected[j].size) {
                selected.splice(j, 0, n);
                inserted = true;
                break;
              }

            if (!inserted)
              selected.push(n);
          }
        }

      return selected;
    }


    function getEdges(e) {
      if (!self.settings('enableEdgeHovering')) {
        // No event if the setting is off:
        return [];
      }

      var isCanvas = (
        sigma.renderers.canvas && self instanceof sigma.renderers.canvas);

      if (!isCanvas) {
        // A quick hardcoded rule to prevent people from using this feature
        // with the WebGL renderer (which is not good enough at the moment):
        throw new Error(
          'The edge events feature is not compatible with the WebGL renderer'
        );
      }

      if (e) {
        mX = 'x' in e.data ? e.data.x : mX;
        mY = 'y' in e.data ? e.data.y : mY;
      }

      var i,
          j,
          l,
          a,
          edge,
          s,
          maxEpsilon = self.settings('edgeHoverPrecision'),
          source,
          target,
          cp,
          nodeIndex = {},
          inserted,
          selected = [],
          modifiedX = mX + self.width / 2,
          modifiedY = mY + self.height / 2,
          point = self.camera.cameraPosition(
            mX,
            mY
          ),
          edges = [];

      if (isCanvas) {
        var nodesOnScreen = self.camera.quadtree.area(
          self.camera.getRectangle(self.width, self.height)
        );
        for (a = nodesOnScreen, i = 0, l = a.length; i < l; i++)
          nodeIndex[a[i].id] = a[i];
      }

      if (self.camera.edgequadtree !== undefined) {
        edges = self.camera.edgequadtree.point(
          point.x,
          point.y
        );
      }

      function insertEdge(selected, edge) {
        inserted = false;

        for (j = 0; j < selected.length; j++)
          if (edge.size > selected[j].size) {
            selected.splice(j, 0, edge);
            inserted = true;
            break;
          }

        if (!inserted)
          selected.push(edge);
      }

      if (edges.length)
        for (i = 0, l = edges.length; i < l; i++) {
          edge = edges[i];
          source = self.graph.nodes(edge.source);
          target = self.graph.nodes(edge.target);
          // (HACK) we can't get edge[prefix + 'size'] on WebGL renderer:
          s = edge[prefix + 'size'] ||
              edge['read_' + prefix + 'size'];

          // First, let's identify which edges are drawn. To do this, we keep
          // every edges that have at least one extremity displayed according to
          // the quadtree and the "hidden" attribute. We also do not keep hidden
          // edges.
          // Then, let's check if the mouse is on the edge (we suppose that it
          // is a line segment).

          if (
            !edge.hidden &&
            !source.hidden && !target.hidden &&
            (!isCanvas ||
              (nodeIndex[edge.source] || nodeIndex[edge.target])) &&
            sigma.utils.getDistance(
              source[prefix + 'x'],
              source[prefix + 'y'],
              modifiedX,
              modifiedY) > source[prefix + 'size'] &&
            sigma.utils.getDistance(
              target[prefix + 'x'],
              target[prefix + 'y'],
              modifiedX,
              modifiedY) > target[prefix + 'size']
          ) {
            if (edge.type == 'curve' || edge.type == 'curvedArrow') {
              if (source.id === target.id) {
                cp = sigma.utils.getSelfLoopControlPoints(
                  source[prefix + 'x'],
                  source[prefix + 'y'],
                  source[prefix + 'size']
                );
                if (
                  sigma.utils.isPointOnBezierCurve(
                  modifiedX,
                  modifiedY,
                  source[prefix + 'x'],
                  source[prefix + 'y'],
                  target[prefix + 'x'],
                  target[prefix + 'y'],
                  cp.x1,
                  cp.y1,
                  cp.x2,
                  cp.y2,
                  Math.max(s, maxEpsilon)
                )) {
                  insertEdge(selected, edge);
                }
              }
              else {
                cp = sigma.utils.getQuadraticControlPoint(
                  source[prefix + 'x'],
                  source[prefix + 'y'],
                  target[prefix + 'x'],
                  target[prefix + 'y']);
                if (
                  sigma.utils.isPointOnQuadraticCurve(
                  modifiedX,
                  modifiedY,
                  source[prefix + 'x'],
                  source[prefix + 'y'],
                  target[prefix + 'x'],
                  target[prefix + 'y'],
                  cp.x,
                  cp.y,
                  Math.max(s, maxEpsilon)
                )) {
                  insertEdge(selected, edge);
                }
              }
            } else if (
                sigma.utils.isPointOnSegment(
                modifiedX,
                modifiedY,
                source[prefix + 'x'],
                source[prefix + 'y'],
                target[prefix + 'x'],
                target[prefix + 'y'],
                Math.max(s, maxEpsilon)
              )) {
              insertEdge(selected, edge);
            }
          }
        }

      return selected;
    }


    function bindCaptor(captor) {
      var nodes,
          edges,
          overNodes = {},
          overEdges = {};

      function onClick(e) {
        if (!self.settings('eventsEnabled'))
          return;

        self.dispatchEvent('click', e.data);

        nodes = getNodes(e);
        edges = getEdges(e);

        if (nodes.length) {
          self.dispatchEvent('clickNode', {
            node: nodes[0],
            captor: e.data
          });
          self.dispatchEvent('clickNodes', {
            node: nodes,
            captor: e.data
          });
        } else if (edges.length) {
          self.dispatchEvent('clickEdge', {
            edge: edges[0],
            captor: e.data
          });
          self.dispatchEvent('clickEdges', {
            edge: edges,
            captor: e.data
          });
        } else
          self.dispatchEvent('clickStage', {captor: e.data});
      }

      function onDoubleClick(e) {
        if (!self.settings('eventsEnabled'))
          return;

        self.dispatchEvent('doubleClick', e.data);

        nodes = getNodes(e);
        edges = getEdges(e);

        if (nodes.length) {
          self.dispatchEvent('doubleClickNode', {
            node: nodes[0],
            captor: e.data
          });
          self.dispatchEvent('doubleClickNodes', {
            node: nodes,
            captor: e.data
          });
        } else if (edges.length) {
          self.dispatchEvent('doubleClickEdge', {
            edge: edges[0],
            captor: e.data
          });
          self.dispatchEvent('doubleClickEdges', {
            edge: edges,
            captor: e.data
          });
        } else
          self.dispatchEvent('doubleClickStage', {captor: e.data});
      }

      function onRightClick(e) {
        if (!self.settings('eventsEnabled'))
          return;

        self.dispatchEvent('rightClick', e.data);

        nodes = getNodes(e);
        edges = getEdges(e);

        if (nodes.length) {
          self.dispatchEvent('rightClickNode', {
            node: nodes[0],
            captor: e.data
          });
          self.dispatchEvent('rightClickNodes', {
            node: nodes,
            captor: e.data
          });
        } else if (edges.length) {
          self.dispatchEvent('rightClickEdge', {
            edge: edges[0],
            captor: e.data
          });
          self.dispatchEvent('rightClickEdges', {
            edge: edges,
            captor: e.data
          });
        } else
          self.dispatchEvent('rightClickStage', {captor: e.data});
      }

      function onOut(e) {
        if (!self.settings('eventsEnabled'))
          return;

        var k,
            i,
            l,
            le,
            outNodes = [],
            outEdges = [];

        for (k in overNodes)
          outNodes.push(overNodes[k]);

        overNodes = {};
        // Dispatch both single and multi events:
        for (i = 0, l = outNodes.length; i < l; i++)
          self.dispatchEvent('outNode', {
            node: outNodes[i],
            captor: e.data
          });
        if (outNodes.length)
          self.dispatchEvent('outNodes', {
            nodes: outNodes,
            captor: e.data
          });

        overEdges = {};
        // Dispatch both single and multi events:
        for (i = 0, le = outEdges.length; i < le; i++)
          self.dispatchEvent('outEdge', {
            edge: outEdges[i],
            captor: e.data
          });
        if (outEdges.length)
          self.dispatchEvent('outEdges', {
            edges: outEdges,
            captor: e.data
          });
      }

      function onMove(e) {
        if (!self.settings('eventsEnabled'))
          return;

        nodes = getNodes(e);
        edges = getEdges(e);

        var i,
            k,
            node,
            edge,
            newOutNodes = [],
            newOverNodes = [],
            currentOverNodes = {},
            l = nodes.length,
            newOutEdges = [],
            newOverEdges = [],
            currentOverEdges = {},
            le = edges.length;

        // Check newly overred nodes:
        for (i = 0; i < l; i++) {
          node = nodes[i];
          currentOverNodes[node.id] = node;
          if (!overNodes[node.id]) {
            newOverNodes.push(node);
            overNodes[node.id] = node;
          }
        }

        // Check no more overred nodes:
        for (k in overNodes)
          if (!currentOverNodes[k]) {
            newOutNodes.push(overNodes[k]);
            delete overNodes[k];
          }

        // Dispatch both single and multi events:
        for (i = 0, l = newOverNodes.length; i < l; i++)
          self.dispatchEvent('overNode', {
            node: newOverNodes[i],
            captor: e.data
          });
        for (i = 0, l = newOutNodes.length; i < l; i++)
          self.dispatchEvent('outNode', {
            node: newOutNodes[i],
            captor: e.data
          });
        if (newOverNodes.length)
          self.dispatchEvent('overNodes', {
            nodes: newOverNodes,
            captor: e.data
          });
        if (newOutNodes.length)
          self.dispatchEvent('outNodes', {
            nodes: newOutNodes,
            captor: e.data
          });

        // Check newly overred edges:
        for (i = 0; i < le; i++) {
          edge = edges[i];
          currentOverEdges[edge.id] = edge;
          if (!overEdges[edge.id]) {
            newOverEdges.push(edge);
            overEdges[edge.id] = edge;
          }
        }

        // Check no more overred edges:
        for (k in overEdges)
          if (!currentOverEdges[k]) {
            newOutEdges.push(overEdges[k]);
            delete overEdges[k];
          }

        // Dispatch both single and multi events:
        for (i = 0, le = newOverEdges.length; i < le; i++)
          self.dispatchEvent('overEdge', {
            edge: newOverEdges[i],
            captor: e.data
          });
        for (i = 0, le = newOutEdges.length; i < le; i++)
          self.dispatchEvent('outEdge', {
            edge: newOutEdges[i],
            captor: e.data
          });
        if (newOverEdges.length)
          self.dispatchEvent('overEdges', {
            edges: newOverEdges,
            captor: e.data
          });
        if (newOutEdges.length)
          self.dispatchEvent('outEdges', {
            edges: newOutEdges,
            captor: e.data
          });
      }

      // Bind events:
      captor.bind('click', onClick);
      captor.bind('mousedown', onMove);
      captor.bind('mouseup', onMove);
      captor.bind('mousemove', onMove);
      captor.bind('mouseout', onOut);
      captor.bind('doubleclick', onDoubleClick);
      captor.bind('rightclick', onRightClick);
      self.bind('render', onMove);
    }

    for (i = 0, l = this.captors.length; i < l; i++)
      bindCaptor(this.captors[i]);
  };
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.misc');

  /**
   * This helper will bind any DOM renderer (for instance svg)
   * to its captors, to properly dispatch the good events to the sigma instance
   * to manage clicking, hovering etc...
   *
   * It has to be called in the scope of the related renderer.
   */
  sigma.misc.bindDOMEvents = function(container) {
    var self = this,
        graph = this.graph;

    // DOMElement abstraction
    function Element(domElement) {

      // Helpers
      this.attr = function(attrName) {
        return domElement.getAttributeNS(null, attrName);
      };

      // Properties
      this.tag = domElement.tagName;
      this.class = this.attr('class');
      this.id = this.attr('id');

      // Methods
      this.isNode = function() {
        return !!~this.class.indexOf(self.settings('classPrefix') + '-node');
      };

      this.isEdge = function() {
        return !!~this.class.indexOf(self.settings('classPrefix') + '-edge');
      };

      this.isHover = function() {
        return !!~this.class.indexOf(self.settings('classPrefix') + '-hover');
      };
    }

    // Click
    function click(e) {
      if (!self.settings('eventsEnabled'))
        return;

      // Generic event
      self.dispatchEvent('click', e);

      // Are we on a node?
      var element = new Element(e.target);

      if (element.isNode())
        self.dispatchEvent('clickNode', {
          node: graph.nodes(element.attr('data-node-id'))
        });
      else
        self.dispatchEvent('clickStage');

      e.preventDefault();
      e.stopPropagation();
    }

    // Double click
    function doubleClick(e) {
      if (!self.settings('eventsEnabled'))
        return;

      // Generic event
      self.dispatchEvent('doubleClick', e);

      // Are we on a node?
      var element = new Element(e.target);

      if (element.isNode())
        self.dispatchEvent('doubleClickNode', {
          node: graph.nodes(element.attr('data-node-id'))
        });
      else
        self.dispatchEvent('doubleClickStage');

      e.preventDefault();
      e.stopPropagation();
    }

    // On over
    function onOver(e) {
      var target = e.toElement || e.target;

      if (!self.settings('eventsEnabled') || !target)
        return;

      var el = new Element(target);

      if (el.isNode()) {
        self.dispatchEvent('overNode', {
          node: graph.nodes(el.attr('data-node-id'))
        });
      }
      else if (el.isEdge()) {
        var edge = graph.edges(el.attr('data-edge-id'));
        self.dispatchEvent('overEdge', {
          edge: edge,
          source: graph.nodes(edge.source),
          target: graph.nodes(edge.target)
        });
      }
    }

    // On out
    function onOut(e) {
      var target = e.fromElement || e.originalTarget;

      if (!self.settings('eventsEnabled'))
        return;

      var el = new Element(target);

      if (el.isNode()) {
        self.dispatchEvent('outNode', {
          node: graph.nodes(el.attr('data-node-id'))
        });
      }
      else if (el.isEdge()) {
        var edge = graph.edges(el.attr('data-edge-id'));
        self.dispatchEvent('outEdge', {
          edge: edge,
          source: graph.nodes(edge.source),
          target: graph.nodes(edge.target)
        });
      }
    }

    // Registering Events:

    // Click
    container.addEventListener('click', click, false);
    sigma.utils.doubleClick(container, 'click', doubleClick);

    // Touch counterparts
    container.addEventListener('touchstart', click, false);
    sigma.utils.doubleClick(container, 'touchstart', doubleClick);

    // Mouseover
    container.addEventListener('mouseover', onOver, true);

    // Mouseout
    container.addEventListener('mouseout', onOut, true);
  };
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.misc');

  /**
   * This method listens to "overNode", "outNode", "overEdge" and "outEdge"
   * events from a renderer and renders the nodes differently on the top layer.
   * The goal is to make any node label readable with the mouse, and to
   * highlight hovered nodes and edges.
   *
   * It has to be called in the scope of the related renderer.
   */
  sigma.misc.drawHovers = function(prefix) {
    var self = this,
        hoveredNodes = {},
        hoveredEdges = {};

    this.bind('overNode', function(event) {
      var node = event.data.node;
      if (!node.hidden) {
        hoveredNodes[node.id] = node;
        draw();
      }
    });

    this.bind('outNode', function(event) {
      delete hoveredNodes[event.data.node.id];
      draw();
    });

    this.bind('overEdge', function(event) {
      var edge = event.data.edge;
      if (!edge.hidden) {
        hoveredEdges[edge.id] = edge;
        draw();
      }
    });

    this.bind('outEdge', function(event) {
      delete hoveredEdges[event.data.edge.id];
      draw();
    });

    this.bind('render', function(event) {
      draw();
    });

    function draw() {

      var k,
          source,
          target,
          hoveredNode,
          hoveredEdge,
          c = self.contexts.hover.canvas,
          defaultNodeType = self.settings('defaultNodeType'),
          defaultEdgeType = self.settings('defaultEdgeType'),
          nodeRenderers = sigma.canvas.hovers,
          edgeRenderers = sigma.canvas.edgehovers,
          extremitiesRenderers = sigma.canvas.extremities,
          embedSettings = self.settings.embedObjects({
            prefix: prefix
          });

      // Clear self.contexts.hover:
      self.contexts.hover.clearRect(0, 0, c.width, c.height);

      // Node render: single hover
      if (
        embedSettings('enableHovering') &&
        embedSettings('singleHover') &&
        Object.keys(hoveredNodes).length
      ) {
        hoveredNode = hoveredNodes[Object.keys(hoveredNodes)[0]];
        (
          nodeRenderers[hoveredNode.type] ||
          nodeRenderers[defaultNodeType] ||
          nodeRenderers.def
        )(
          hoveredNode,
          self.contexts.hover,
          embedSettings
        );
      }

      // Node render: multiple hover
      if (
        embedSettings('enableHovering') &&
        !embedSettings('singleHover')
      )
        for (k in hoveredNodes)
          (
            nodeRenderers[hoveredNodes[k].type] ||
            nodeRenderers[defaultNodeType] ||
            nodeRenderers.def
          )(
            hoveredNodes[k],
            self.contexts.hover,
            embedSettings
          );

      // Edge render: single hover
      if (
        embedSettings('enableEdgeHovering') &&
        embedSettings('singleHover') &&
        Object.keys(hoveredEdges).length
      ) {
        hoveredEdge = hoveredEdges[Object.keys(hoveredEdges)[0]];
        source = self.graph.nodes(hoveredEdge.source);
        target = self.graph.nodes(hoveredEdge.target);

        if (! hoveredEdge.hidden) {
          (
            edgeRenderers[hoveredEdge.type] ||
            edgeRenderers[defaultEdgeType] ||
            edgeRenderers.def
          ) (
            hoveredEdge,
            source,
            target,
            self.contexts.hover,
            embedSettings
          );

          if (embedSettings('edgeHoverExtremities')) {
            (
              extremitiesRenderers[hoveredEdge.type] ||
              extremitiesRenderers.def
            )(
              hoveredEdge,
              source,
              target,
              self.contexts.hover,
              embedSettings
            );

          } else {
            // Avoid edges rendered over nodes:
            (
              sigma.canvas.nodes[source.type] ||
              sigma.canvas.nodes.def
            ) (
              source,
              self.contexts.hover,
              embedSettings
            );
            (
              sigma.canvas.nodes[target.type] ||
              sigma.canvas.nodes.def
            ) (
              target,
              self.contexts.hover,
              embedSettings
            );
          }
        }
      }

      // Edge render: multiple hover
      if (
        embedSettings('enableEdgeHovering') &&
        !embedSettings('singleHover')
      ) {
        for (k in hoveredEdges) {
          hoveredEdge = hoveredEdges[k];
          source = self.graph.nodes(hoveredEdge.source);
          target = self.graph.nodes(hoveredEdge.target);

          if (!hoveredEdge.hidden) {
            (
              edgeRenderers[hoveredEdge.type] ||
              edgeRenderers[defaultEdgeType] ||
              edgeRenderers.def
            ) (
              hoveredEdge,
              source,
              target,
              self.contexts.hover,
              embedSettings
            );

            if (embedSettings('edgeHoverExtremities')) {
              (
                extremitiesRenderers[hoveredEdge.type] ||
                extremitiesRenderers.def
              )(
                hoveredEdge,
                source,
                target,
                self.contexts.hover,
                embedSettings
              );
            } else {
              // Avoid edges rendered over nodes:
              (
                sigma.canvas.nodes[source.type] ||
                sigma.canvas.nodes.def
              ) (
                source,
                self.contexts.hover,
                embedSettings
              );
              (
                sigma.canvas.nodes[target.type] ||
                sigma.canvas.nodes.def
              ) (
                target,
                self.contexts.hover,
                embedSettings
              );
            }
          }
        }
      }
    }
  };
}).call(this);

},{}],5:[function(require,module,exports){
(function (global){
!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var t;t="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this,t.TQGramUI=e()}}(function(){return function(){function e(t,n,o){function i(l,a){if(!n[l]){if(!t[l]){var s="function"==typeof require&&require;if(!a&&s)return s(l,!0);if(r)return r(l,!0);var u=new Error("Cannot find module '"+l+"'");throw u.code="MODULE_NOT_FOUND",u}var d=n[l]={exports:{}};t[l][0].call(d.exports,function(e){var n=t[l][1][e];return i(n?n:e)},d,d.exports,e,t,n,o)}return n[l].exports}for(var r="function"==typeof require&&require,l=0;l<o.length;l++)i(o[l]);return i}return e}()({1:[function(e,t,n){"use strict";function o(e){function t(){r.rootHtml.innerHTML="",r.rootHtml.style.borderTop=0!==r.buttons.length?"1px solid #cccccc":null,r.rootHtml.style.borderBottom=0!==r.buttons.length?"1px solid #cccccc":null,r.buttons.forEach(function(e){var t=document.createElement("BUTTON");t.title=e.label,t.className="tq-ui-toolbar__button tq-ui-colored-button",t.innerHTML='<span style="color: '+e.borderColor+'">'+n(e.label)+"</span>",t.style.backgroundColor=e.backgroundColor||"white",t.style.borderColor=e.borderColor||"black",t.onclick=function(t){e.callback(e,t)},r.rootHtml.appendChild(t)})}function n(e){if(e){var t=e.match(/[a-z'\-]+/gi);return t.filter(function(e){return"and"!==e.toLowerCase()&&"&"!==e}).map(function(e){return e[0]}).join("")}}function o(){var e=document.createElement("DIV");return e.className="tq-ui-colored-buttons-list",e.innerHTML="",e}var r=this;e||(e={}),r.rootHtml=o(),r.id=e.id||"coloredButtons-"+i++,r.rootHtml.id=r.id,r.buttons=e.buttons||[],t(),r.removeAll=function(){r.buttons=[],t()},r.addButton=function(e){r.buttons.map(function(e){return e.id}).indexOf(e.id)===-1&&(r.buttons.push(e),t())},r.removeButton=function(e){r.buttons.splice(r.buttons.indexOf(e),1),t()}}Object.defineProperty(n,"__esModule",{value:!0}),n.ColoredButtonsList=o;var i=0;n["default"]=o},{}],2:[function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{"default":e}}function i(e){function t(){if(e.body instanceof Object){var t=i.rootHtml.querySelector(".tq-ui-body_container");t.appendChild(e.body.rootHtml)}var a=i.rootHtml.querySelector(".tq-ui-flying-panel_header");a.addEventListener("mousedown",o);var s=i.rootHtml.querySelector(".tq-ui-windows-collapse-button");if(s.onclick=i.hide,e.resizable){var u=i.rootHtml.querySelector(".tq-ui-flying-panel__border.tq-ui-top-border");u.addEventListener("mousedown",function(e){o(e,"n")});var d=i.rootHtml.querySelector(".tq-ui-flying-panel__border.tq-ui-right-border");d.addEventListener("mousedown",function(e){o(e,"e")});var c=i.rootHtml.querySelector(".tq-ui-flying-panel__border.tq-ui-bottom-border");c.addEventListener("mousedown",function(e){o(e,"s")});var f=i.rootHtml.querySelector(".tq-ui-flying-panel__border.tq-ui-left-border");f.addEventListener("mousedown",function(e){o(e,"w")});var p=i.rootHtml.querySelector(".tq-ui-flying-panel__border.tq-ui-top-right-border");p.addEventListener("mousedown",function(e){o(e,"ne")});var b=i.rootHtml.querySelector(".tq-ui-flying-panel__border.tq-ui-top-left-border");b.addEventListener("mousedown",function(e){o(e,"nw")});var m=i.rootHtml.querySelector(".tq-ui-flying-panel__border.tq-ui-bottom-right-border");m.addEventListener("mousedown",function(e){o(e,"se")});var y=i.rootHtml.querySelector(".tq-ui-flying-panel__border.tq-ui-bottom-left-border");y.addEventListener("mousedown",function(e){o(e,"sw")})}i._triggerButton=r(e.triggerButton),n(),i._triggerButton&&(i._triggerButton.onclick=function(){l?i.show():i.hide()})}function n(){l?(i._triggerButton&&(i._triggerButton.className=i._triggerButton.className.replace(/ tq-ui-selected/gi,"")),i.rootHtml.className=i.rootHtml.className+" tq-ui-collapsed"):(i._triggerButton&&(i._triggerButton.className=i._triggerButton.className+" tq-ui-selected"),i.rootHtml.className=i.rootHtml.className.replace(/ tq-ui-collapsed/gi,""))}function o(e,t){function n(e){i._mouseMove=!0;var n=0;e.pageX?n=e.pageX:e.clientX&&(n=e.clientX);var o=n-l;l=n,t||(i.rootHtml.style.left=i.rootHtml.offsetLeft+o+"px");var s=0;e.pageY?s=e.pageY:e.clientY&&(s=e.clientY);var u=s-a;a=s,t||(i.rootHtml.style.top=i.rootHtml.offsetTop+u+"px"),t?(r(o,u,t),i.trigger("size-changed",{width:i.rootHtml.offsetWidth,height:i.rootHtml.offsetHeight}),t.indexOf("n")===-1&&t.indexOf("w")===-1||i.trigger("position-changed",{x:i.rootHtml.offsetLeft,y:i.rootHtml.offsetTop})):i.trigger("position-changed",{x:i.rootHtml.offsetLeft,y:i.rootHtml.offsetTop})}function o(e){i._mouseMove&&(n(e,!0),i._mouseMove=!1),document.body.onmousemove=document.body.onmouseup=null,document.body.removeEventListener("mousemove",n),document.body.removeEventListener("mouseup",o)}function r(e,t,n){switch(n){case"n":i.rootHtml.style.height=i.rootHtml.offsetHeight-t+"px",i.rootHtml.style.top=i.rootHtml.offsetTop+t+"px";break;case"e":i.rootHtml.style.width=i.rootHtml.offsetWidth+e+"px";break;case"s":i.rootHtml.style.height=i.rootHtml.offsetHeight+t+"px";break;case"w":i.rootHtml.style.width=i.rootHtml.offsetWidth-e+"px",i.rootHtml.style.left=i.rootHtml.offsetLeft+e+"px";break;case"ne":i.rootHtml.style.width=i.rootHtml.offsetWidth+e+"px",i.rootHtml.style.height=i.rootHtml.offsetHeight-t+"px",i.rootHtml.style.top=i.rootHtml.offsetTop+t+"px";break;case"nw":i.rootHtml.style.height=i.rootHtml.offsetHeight-t+"px",i.rootHtml.style.top=i.rootHtml.offsetTop+t+"px",i.rootHtml.style.width=i.rootHtml.offsetWidth-e+"px",i.rootHtml.style.left=i.rootHtml.offsetLeft+e+"px";break;case"se":i.rootHtml.style.width=i.rootHtml.offsetWidth+e+"px",i.rootHtml.style.height=i.rootHtml.offsetHeight+t+"px";break;case"sw":i.rootHtml.style.height=i.rootHtml.offsetHeight+t+"px",i.rootHtml.style.width=i.rootHtml.offsetWidth-e+"px",i.rootHtml.style.left=i.rootHtml.offsetLeft+e+"px"}}var l=0,a=0;e.pageX?l=e.pageX:e.clientX&&(l=e.clientX),e.pageY?a=e.pageY:e.clientY&&(a=e.clientY),window.getSelection().removeAllRanges(),document.body.addEventListener("mousemove",n),document.body.addEventListener("mouseup",o)}s["default"].apply(this);var i=this;e||(e={});var l=!e.active;i.markup='\n        <div class="tq-ui-flying-panel"\n            style="\n                width: '+(e.size?e.size.width:"")+";\n                height: "+(e.size?e.size.height:"")+";\n                left: "+(e.position?e.position.x:"")+";\n                top: "+(e.position?e.position.y:"")+';\n            "\n        >\n            <div class="tq-ui-flying-panel_header">\n                <div class="tq-ui-flying-panel_header__header">\n                    <label class="tq-ui-window-header-label">'+(e.header?e.header:"")+'</label>\n                    <img class="tq-ui-windows-collapse-button"/>\n                </div>\n            </div>\n            <div class="tq-ui-body">\n                <div class="tq-ui-body_container '+(e.removeBackground?"tq-ui-body_empty-container":"tq-ui-body_default-container")+'">\n                    '+(e.body&&"string"==typeof e.body?e.body:"")+"\n                </div>\n            </div>\n            "+(e.resizable?'\n                <div class="tq-ui-flying-panel__border tq-ui-top-border"></div>\n                <div class="tq-ui-flying-panel__border tq-ui-right-border"></div>\n                <div class="tq-ui-flying-panel__border tq-ui-bottom-border"></div>\n                <div class="tq-ui-flying-panel__border tq-ui-left-border"></div>\n                <div class="tq-ui-flying-panel__border tq-ui-top-left-border"></div>\n                <div class="tq-ui-flying-panel__border tq-ui-top-right-border"></div>\n                <div class="tq-ui-flying-panel__border tq-ui-bottom-left-border"></div>\n                <div class="tq-ui-flying-panel__border tq-ui-bottom-right-border"></div>\n            ':"")+"\n        </div>";var a=r(e.baseElement);a.innerHTML=i.markup,i.rootHtml=a.querySelector(".tq-ui-flying-panel"),i.id=e.id||"flyingPanel-"+u++,i.rootHtml.id=i.id,i.show=function(e){e&&e.stopPropagation(),l&&(l=!1,n())},i.hide=function(e){e&&e.stopPropagation(),l||(l=!0,n())},t()}function r(e){var t=void 0;return"string"==typeof e?t=document.getElementById(e):"object"===("undefined"==typeof e?"undefined":l(e))&&(t=e),t}Object.defineProperty(n,"__esModule",{value:!0});var l="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e};n.FlyingPanel=i;var a=e("./subscriptionAPI/subscribeable"),s=o(a),u=0;n["default"]=i},{"./subscriptionAPI/subscribeable":8}],3:[function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{"default":e}}function i(e){function t(e){function t(e){var t=e.label,n=e.label+" ("+e.id+")",o=document.createElement("LI");return o.className="tq-ui-property-button",o.title=n,o.innerText=t,o.onclick=function(){i.trigger("selected-element-changed",e.id)},o}var n=i.rootHtml.querySelector("#relatedElements");n.innerHTML="";var o=e.incomings||[];if(o.length){var r=document.createElement("LABEL");r.className="tq-label",r.innerText="Incoming nodes:",n.appendChild(r);var l=document.createElement("UL");l.className="tq-ui-info-panel_related-elements_list",n.appendChild(l),o.forEach(function(e){l.appendChild(t(e))})}var a=e.outgoings||[];if(a.length){var s=document.createElement("LABEL");s.className="tq-label",s.innerText="Outgoing nodes:",n.appendChild(s);var u=document.createElement("UL");u.className="tq-ui-info-panel_related-elements_list",n.appendChild(u),a.forEach(function(e){u.appendChild(t(e))})}}function n(e){var t="";return Object.keys(e).forEach(function(n){t+='<label for="'+n+'" class="tq-label">'+n+'</label>\n                        <input id="'+n+'" type="text" class="tq-ui-property" value="'+e[n]+'" disabled></input>'}),t}function o(){var e=document.createElement("DIV");return e.className="tq-ui-info-panel",e.innerHTML=i.markup,e}l["default"].apply(this),e||(e={});var i=this,r=e.placeholder||"Select a diagram element",s='<div class="tq-ui-info-panel_empty-stuff">'+r+"</div>";i.rootHtml=o(),i.rootHtml.innerHTML=s,i.id=e.id||"infoPanel-"+a++,i.rootHtml.id=i.id,i.setSelectedElement=function(o){if(o){if(i.rootHtml.innerHTML=""+(e.launchExternal&&"node"===o.diagramType?'<div class="tq-ui-group">\n                      <button id="tqLaunchExternalBtn" class="tq-button" title="View more in new tab.">\n                        More &nbsp;\n                      <span class="glyphicon glyphicon-new-window"></span></button>\n                     </div>':"")+(o.id?'\n                    <label class="tq-label">ID</label>\n                    <input value="'+o.id+'" type="text" class="tq-ui-property" disabled></input>\n                ':"")+(o.label?'\n                    <label class="tq-label">Label</label>\n                    <input value="'+o.label+'" type="text" class="tq-ui-property" disabled></input>\n                ':"")+(o.types?'\n                    <label class="tq-label">Types</label>\n                    <input value="'+o.types+'" type="text" class="tq-ui-property" disabled></input>\n                ':"")+(o.source?'\n                    <label for="linkFrom" class="tq-label">Source</label>\n                    <div id="linkFrom" type="text" class="tq-ui-property-button"></div>\n                ':"")+(o.target?'\n                    <label for="linkTo" class="tq-label">Target</label>\n                    <div id="linkTo" type="text" class="tq-ui-property-button"></div>\n                ':"")+(o.thickness?'\n                    <label for="thickness" class="tq-label">Thickness</label>\n                    <input value="'+o.thickness+'" type="text" class="tq-ui-property" disabled></input>\n                ':"")+(o.data?n(o.data):"")+(o.relations?'\n                    <label for="relatedElements" class="tq-label">Related elements</label>\n                    <div   id="relatedElements" class="tq-ui-info-panel_related-elements"></div>\n                ':""),e.launchExternal&&"node"===o.diagramType){var r=document.getElementById("tqLaunchExternalBtn");r.onclick=function(){e.launchExternal(o)}}if(o.relations&&t(o.relations),o.source){var l=document.getElementById("linkFrom");l.innerText=o.source.label,l.title=o.source.label+"(ID: "+o.source.id+")",l.onclick=function(){i.trigger("selected-element-changed",o.source.id)}}if(o.target){var a=document.getElementById("linkTo");a.innerText=o.target.label,a.title=o.target.label+"(ID: "+o.target.id+")",a.onclick=function(){i.trigger("selected-element-changed",o.target.id)}}}else i.rootHtml.innerHTML=s},e.selectedElement&&i.setSelectedElement(e.selectedElement)}Object.defineProperty(n,"__esModule",{value:!0}),n.InfoPanel=i;var r=e("./subscriptionAPI/subscribeable"),l=o(r),a=0;n["default"]=i},{"./subscriptionAPI/subscribeable":8}],4:[function(e,t,n){"use strict";function o(e){function t(){var e=document.createElement("DIV");return e.innerHTML=n.markup,e.querySelector(".tq-ui-legend-panel_body_legends")}var n=this;e||(e={});var o=e.legends||[];n.markup='\n        <div class="tq-ui-legend-panel_body_legends">\n        '+o.map(function(e){return'\n                <div class="tq-ui-legend-panel_body_legends_legend" title="'+e.description+'">\n                    <div class="tq-ui-legend-panel_body_legends_legend_img"><img src="'+e.image+'"></div>\n                    <label class="tq-label">'+e.label+"</label>\n                </div>\n            "}).join("")+"\n        </div>\n    ",n.rootHtml=t(),n.id=e.id||"legends-"+i++,n.rootHtml.id=n.id}Object.defineProperty(n,"__esModule",{value:!0}),n.Legends=o;var i=0;n["default"]=o},{}],5:[function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{"default":e}}var i=e("./coloredButtonsList"),r=o(i),l=e("./flyingPanel"),a=o(l),s=e("./infoPanel"),u=o(s),d=e("./legends"),c=o(d),f=e("./progressScreen"),p=o(f),b=e("./searchPanel"),m=o(b),y=e("./switcher"),v=o(y),g=e("./tabPanel"),h=o(g),H=e("./toolbar"),q=o(H);t.exports={ColoredButtonsList:r["default"],FlyingPanel:a["default"],InfoPanel:u["default"],Legends:c["default"],ProgressScreen:p["default"],SearchPanel:m["default"],Switcher:v["default"],TabPanel:h["default"],Toolbar:q["default"]}},{"./coloredButtonsList":1,"./flyingPanel":2,"./infoPanel":3,"./legends":4,"./progressScreen":6,"./searchPanel":7,"./switcher":9,"./tabPanel":10,"./toolbar":11}],6:[function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{"default":e}}function i(e){function t(){var e=document.createElement("DIV");return e.className="tq-ui-progress-screen",e.innerHTML=o.markup,e}function n(e){var t=void 0;return"string"==typeof e?t=document.getElementById(e):"object"===("undefined"==typeof e?"undefined":r(e))&&(t=e),t}a["default"].apply(this);var o=this;e||(e={}),o.markup="",o.state="completed",o.rootHtml=t(),o.id=e.id||"tabPanel-"+s++,o.rootHtml.id=o.id;var i=n(e.baseElement);i.appendChild(o.rootHtml),o.setState=function(e,t){e&&(o.state=e,"active"===e?(o.rootHtml.innerHTML="<h1>"+(t||u)+'</h1><div class="tq-ui-progress-screen__progress"></div>',o.rootHtml.style.display=null):"completed"===e?(o.rootHtml.innerHTML="",o.rootHtml.style.display="none"):"error"===e&&(o.rootHtml.innerHTML="<h1>"+(t||d)+"</h1>",o.rootHtml.style.display=null),o.trigger("diagram-state-changed",e))},o.setState(e.state,e.text)}Object.defineProperty(n,"__esModule",{value:!0});var r="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e};n.ProgressScreen=i;var l=e("./subscriptionAPI/subscribeable"),a=o(l),s=0,u="Loading",d="Error has occurred!";n["default"]=i},{"./subscriptionAPI/subscribeable":8}],7:[function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{"default":e}}function i(e){l["default"].apply(this),e||(e={});var t=e.searchButtonId||"tqLgSearchButton",n=e.searchId||"search";s["default"].apply(this,[{id:e.id,baseElement:e.baseElement,active:e.active,header:e.header||"Search panel",triggerButton:e.triggerButton,body:"\n            <span id= "+t+' class="tq-ui-search-icon glyphicon glyphicon-search" aria-hidden="true"></span>\n            <input id="'+n+'" placeHolder="Search..." class="tq-ui-search-input"></input>\n        ',removeBackground:!0,size:{width:"260px",height:"70px"}}])}Object.defineProperty(n,"__esModule",{value:!0}),n.SearchPanel=i;var r=e("./subscriptionAPI/subscribeable"),l=o(r),a=e("./flyingPanel"),s=o(a);n["default"]=i},{"./flyingPanel":2,"./subscriptionAPI/subscribeable":8}],8:[function(e,t,n){"use strict";function o(){var e=this;e._subscribtions={},e.on=function(t,n){e._subscribtions[t]||(e._subscribtions[t]=[]),e._subscribtions[t].push(n)},e.unsubscribe=function(t){Object.keys(e._subscribtions).map(function(t){return e._subscribtions[t]}).forEach(function(e){var n=e.indexOf(t);n!==-1&&e.splice(n,1)})},e.trigger=function(t,n){var o=this;n instanceof Array||(n=[n]),e._subscribtions&&e._subscribtions[t]&&e._subscribtions[t].forEach(function(e){e.apply(o,n)})}}Object.defineProperty(n,"__esModule",{value:!0}),n.Subscribable=o,n["default"]=o},{}],9:[function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{"default":e}}function i(e){function t(){var t=document.createElement("DIV");return t.className="tq-ui-switch-buttons"+(e.verticalOrientation?"-vertical":""),t.innerHTML=n.markup,t}l["default"].apply(this),e||(e={});var n=this,o=e.states||[];n.markup=o.map(function(t,n){return'<button id="'+t.id+'" '+(0!==n?"":"disabled")+' title="'+(t.label||t.id)+'">\n            '+(e.verticalOrientation&&t.icon?'<span class="'+t.icon+'" aria-hidden="true"></span>':t.label||t.id)+"\n        </button>"}).join(""),n.rootHtml=t(),n.id=e.id||"switcher-"+a++,n.rootHtml.id=n.id;var i=null;o.forEach(function(e,t){var o=n.rootHtml.querySelector("#"+e.id);0===t&&(i=o),o.onclick=function(){o.disabled=!0,i.disabled=!1,i=o,n.trigger("state-changed",e.id)}}),n.setState=function(e){var t=n.rootHtml.querySelector("#"+e);t&&e!==i.id&&(t.disabled=!0,i.disabled=!1,i=t)}}Object.defineProperty(n,"__esModule",{value:!0}),n.Switcher=i;var r=e("./subscriptionAPI/subscribeable"),l=o(r),a=0;n["default"]=i},{"./subscriptionAPI/subscribeable":8}],10:[function(e,t,n){"use strict";function o(e){function t(){var e=document.createElement("DIV");return e.className="tq-ui-tab-panel",e.innerHTML=n.markup,e}var n=this;e||(e={});var o=e.tabs||[];n.markup='\n        <div class="tq-ui-tab-switcher tq-ui-switch-buttons">'+o.map(function(e,t){return'\n            <button id="'+e.id+'" '+(0!==t?"":"disabled")+">\n                "+(e.label||e.id)+"\n            </button>  \n        "}).join("")+"</div>"+o.map(function(e,t){return'\n            <div id="'+e.id+'Panel" class="tq-ui-tab-panel_page" style="display: '+(0===t?"":"none")+'">\n                <div class="tq-ui-tab-panel_page_body">\n                    '+("string"==typeof e.body?e.body:"")+"\n                </div>\n            </div>\n        "}).join(""),n.rootHtml=t(),n.id=e.id||"tabPanel-"+i++,n.rootHtml.id=n.id,o.map(function(e){if(e.body instanceof Object&&e.body.rootHtml){var t=n.rootHtml.querySelector("#"+e.id+"Panel .tq-ui-tab-panel_page_body");t.appendChild(e.body.rootHtml)}});var r=null;o.forEach(function(e,t){var o=n.rootHtml.querySelector("#"+e.id),i=n.rootHtml.querySelector("#"+e.id+"Panel");0===t&&(r={tabBtn:o,tabPanel:i}),o.onclick=function(){o.disabled=!0,i.style.display="",r.tabBtn.disabled=!1,r.tabPanel.style.display="none",r={tabBtn:o,tabPanel:i}}})}Object.defineProperty(n,"__esModule",{value:!0}),n.TabPanel=o;var i=0;n["default"]=o},{}],11:[function(e,t,n){"use strict";function o(e){function t(e){var t=void 0;if("string"==typeof e){var n=document.createElement("DIV");n.innerHTML=e,t=n.firstChild}else if(e.id&&e.icon){var o=document.createElement("DIV");if(o.innerHTML='<button id="'+e.id+'" title="'+(e.label||e.id)+'" class="tq-ui-toolbar__button">\n                <span class="'+e.icon+'" aria-hidden="true"></span>\n            </button>',t=o.firstChild,e.icon2){var i=!0;t.onclick=function(n){t.innerHTML='<span class="'+(i?e.icon2:e.icon)+'" aria-hidden="true"></span>',e.callback(n),i=!i}}else t.onclick=e.callback}else e.rootHtml&&(t=e.rootHtml);return t}function n(){var t=void 0;return"string"==typeof e.baseElement?t=document.getElementById(e.baseElement):"object"===i(e.baseElement)&&(t=e.baseElement),t?(t.innerHTML=o.markup,t):null}var o=this;if(e||(e={}),o.markup='\n        <div id="toolbarRootElement" class="tq-ui-toolbar">\n        </div>\n    ',o.rootHtml=n(),o.id=e.id||"toolbar-"+r++,o.rootHtml.id=o.id,!o.rootHtml)throw new Error("The root element is not specified!");o.container=o.rootHtml.querySelector("#toolbarRootElement"),o.pushTool=function(e){var n=t(e);n&&("string"!=typeof n?l.push(e):l.push({id:"customhtml"+r++,markup:e,rootHtml:n}),o.container.appendChild(n))},o.insertTool=function(e,n){var i=Math.min(Math.max(n,0),l.length-1),r=o.container.querySelector("#"+l[i].id);if(r){var a=t(e);a&&(l.splice(i,0,e),o.container.insertBefore(a,r))}else o.pushTool(e)},o.removeTool=function(e){var t="string"==typeof e?e:e.id;l.splice(l.indexOf(e),1);var n=o.container.querySelector("#"+t);o.container.removeChild(n)};var l=[];e.tools.forEach(function(e){o.pushTool(e)})}Object.defineProperty(n,"__esModule",{value:!0});var i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e};n.Toolbar=o;var r=0;n["default"]=o},{}]},{},[5])(5)});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],6:[function(require,module,exports){
"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(require("./src/adaptor"));
__export(require("./src/d3adaptor"));
__export(require("./src/descent"));
__export(require("./src/geom"));
__export(require("./src/gridrouter"));
__export(require("./src/handledisconnected"));
__export(require("./src/layout"));
__export(require("./src/layout3d"));
__export(require("./src/linklengths"));
__export(require("./src/powergraph"));
__export(require("./src/pqueue"));
__export(require("./src/rbtree"));
__export(require("./src/rectangle"));
__export(require("./src/shortestpaths"));
__export(require("./src/vpsc"));
__export(require("./src/batch"));

},{"./src/adaptor":7,"./src/batch":8,"./src/d3adaptor":9,"./src/descent":12,"./src/geom":13,"./src/gridrouter":14,"./src/handledisconnected":15,"./src/layout":16,"./src/layout3d":17,"./src/linklengths":18,"./src/powergraph":19,"./src/pqueue":20,"./src/rbtree":21,"./src/rectangle":22,"./src/shortestpaths":23,"./src/vpsc":24}],7:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var layout_1 = require("./layout");
var LayoutAdaptor = (function (_super) {
    __extends(LayoutAdaptor, _super);
    function LayoutAdaptor(options) {
        var _this = _super.call(this) || this;
        var self = _this;
        var o = options;
        if (o.trigger) {
            _this.trigger = o.trigger;
        }
        if (o.kick) {
            _this.kick = o.kick;
        }
        if (o.drag) {
            _this.drag = o.drag;
        }
        if (o.on) {
            _this.on = o.on;
        }
        _this.dragstart = _this.dragStart = layout_1.Layout.dragStart;
        _this.dragend = _this.dragEnd = layout_1.Layout.dragEnd;
        return _this;
    }
    LayoutAdaptor.prototype.trigger = function (e) { };
    ;
    LayoutAdaptor.prototype.kick = function () { };
    ;
    LayoutAdaptor.prototype.drag = function () { };
    ;
    LayoutAdaptor.prototype.on = function (eventType, listener) { return this; };
    ;
    return LayoutAdaptor;
}(layout_1.Layout));
exports.LayoutAdaptor = LayoutAdaptor;
function adaptor(options) {
    return new LayoutAdaptor(options);
}
exports.adaptor = adaptor;

},{"./layout":16}],8:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var layout_1 = require("./layout");
var gridrouter_1 = require("./gridrouter");
function gridify(pgLayout, nudgeGap, margin, groupMargin) {
    pgLayout.cola.start(0, 0, 0, 10, false);
    var gridrouter = route(pgLayout.cola.nodes(), pgLayout.cola.groups(), margin, groupMargin);
    return gridrouter.routeEdges(pgLayout.powerGraph.powerEdges, nudgeGap, function (e) { return e.source.routerNode.id; }, function (e) { return e.target.routerNode.id; });
}
exports.gridify = gridify;
function route(nodes, groups, margin, groupMargin) {
    nodes.forEach(function (d) {
        d.routerNode = {
            name: d.name,
            bounds: d.bounds.inflate(-margin)
        };
    });
    groups.forEach(function (d) {
        d.routerNode = {
            bounds: d.bounds.inflate(-groupMargin),
            children: (typeof d.groups !== 'undefined' ? d.groups.map(function (c) { return nodes.length + c.id; }) : [])
                .concat(typeof d.leaves !== 'undefined' ? d.leaves.map(function (c) { return c.index; }) : [])
        };
    });
    var gridRouterNodes = nodes.concat(groups).map(function (d, i) {
        d.routerNode.id = i;
        return d.routerNode;
    });
    return new gridrouter_1.GridRouter(gridRouterNodes, {
        getChildren: function (v) { return v.children; },
        getBounds: function (v) { return v.bounds; }
    }, margin - groupMargin);
}
function powerGraphGridLayout(graph, size, grouppadding) {
    var powerGraph;
    graph.nodes.forEach(function (v, i) { return v.index = i; });
    new layout_1.Layout()
        .avoidOverlaps(false)
        .nodes(graph.nodes)
        .links(graph.links)
        .powerGraphGroups(function (d) {
        powerGraph = d;
        powerGraph.groups.forEach(function (v) { return v.padding = grouppadding; });
    });
    var n = graph.nodes.length;
    var edges = [];
    var vs = graph.nodes.slice(0);
    vs.forEach(function (v, i) { return v.index = i; });
    powerGraph.groups.forEach(function (g) {
        var sourceInd = g.index = g.id + n;
        vs.push(g);
        if (typeof g.leaves !== 'undefined')
            g.leaves.forEach(function (v) { return edges.push({ source: sourceInd, target: v.index }); });
        if (typeof g.groups !== 'undefined')
            g.groups.forEach(function (gg) { return edges.push({ source: sourceInd, target: gg.id + n }); });
    });
    powerGraph.powerEdges.forEach(function (e) {
        edges.push({ source: e.source.index, target: e.target.index });
    });
    new layout_1.Layout()
        .size(size)
        .nodes(vs)
        .links(edges)
        .avoidOverlaps(false)
        .linkDistance(30)
        .symmetricDiffLinkLengths(5)
        .convergenceThreshold(1e-4)
        .start(100, 0, 0, 0, false);
    return {
        cola: new layout_1.Layout()
            .convergenceThreshold(1e-3)
            .size(size)
            .avoidOverlaps(true)
            .nodes(graph.nodes)
            .links(graph.links)
            .groupCompactness(1e-4)
            .linkDistance(30)
            .symmetricDiffLinkLengths(5)
            .powerGraphGroups(function (d) {
            powerGraph = d;
            powerGraph.groups.forEach(function (v) {
                v.padding = grouppadding;
            });
        }).start(50, 0, 100, 0, false),
        powerGraph: powerGraph
    };
}
exports.powerGraphGridLayout = powerGraphGridLayout;

},{"./gridrouter":14,"./layout":16}],9:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var d3v3 = require("./d3v3adaptor");
var d3v4 = require("./d3v4adaptor");
;
function d3adaptor(d3Context) {
    if (!d3Context || isD3V3(d3Context)) {
        return new d3v3.D3StyleLayoutAdaptor();
    }
    return new d3v4.D3StyleLayoutAdaptor(d3Context);
}
exports.d3adaptor = d3adaptor;
function isD3V3(d3Context) {
    var v3exp = /^3\./;
    return d3Context.version && d3Context.version.match(v3exp) !== null;
}

},{"./d3v3adaptor":10,"./d3v4adaptor":11}],10:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var layout_1 = require("./layout");
var D3StyleLayoutAdaptor = (function (_super) {
    __extends(D3StyleLayoutAdaptor, _super);
    function D3StyleLayoutAdaptor() {
        var _this = _super.call(this) || this;
        _this.event = d3.dispatch(layout_1.EventType[layout_1.EventType.start], layout_1.EventType[layout_1.EventType.tick], layout_1.EventType[layout_1.EventType.end]);
        var d3layout = _this;
        var drag;
        _this.drag = function () {
            if (!drag) {
                var drag = d3.behavior.drag()
                    .origin(layout_1.Layout.dragOrigin)
                    .on("dragstart.d3adaptor", layout_1.Layout.dragStart)
                    .on("drag.d3adaptor", function (d) {
                    layout_1.Layout.drag(d, d3.event);
                    d3layout.resume();
                })
                    .on("dragend.d3adaptor", layout_1.Layout.dragEnd);
            }
            if (!arguments.length)
                return drag;
            this
                .call(drag);
        };
        return _this;
    }
    D3StyleLayoutAdaptor.prototype.trigger = function (e) {
        var d3event = { type: layout_1.EventType[e.type], alpha: e.alpha, stress: e.stress };
        this.event[d3event.type](d3event);
    };
    D3StyleLayoutAdaptor.prototype.kick = function () {
        var _this = this;
        d3.timer(function () { return _super.prototype.tick.call(_this); });
    };
    D3StyleLayoutAdaptor.prototype.on = function (eventType, listener) {
        if (typeof eventType === 'string') {
            this.event.on(eventType, listener);
        }
        else {
            this.event.on(layout_1.EventType[eventType], listener);
        }
        return this;
    };
    return D3StyleLayoutAdaptor;
}(layout_1.Layout));
exports.D3StyleLayoutAdaptor = D3StyleLayoutAdaptor;
function d3adaptor() {
    return new D3StyleLayoutAdaptor();
}
exports.d3adaptor = d3adaptor;

},{"./layout":16}],11:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var layout_1 = require("./layout");
var D3StyleLayoutAdaptor = (function (_super) {
    __extends(D3StyleLayoutAdaptor, _super);
    function D3StyleLayoutAdaptor(d3Context) {
        var _this = _super.call(this) || this;
        _this.d3Context = d3Context;
        _this.event = d3Context.dispatch(layout_1.EventType[layout_1.EventType.start], layout_1.EventType[layout_1.EventType.tick], layout_1.EventType[layout_1.EventType.end]);
        var d3layout = _this;
        var drag;
        _this.drag = function () {
            if (!drag) {
                var drag = d3Context.drag()
                    .subject(layout_1.Layout.dragOrigin)
                    .on("start.d3adaptor", layout_1.Layout.dragStart)
                    .on("drag.d3adaptor", function (d) {
                    layout_1.Layout.drag(d, d3Context.event);
                    d3layout.resume();
                })
                    .on("end.d3adaptor", layout_1.Layout.dragEnd);
            }
            if (!arguments.length)
                return drag;
            arguments[0].call(drag);
        };
        return _this;
    }
    D3StyleLayoutAdaptor.prototype.trigger = function (e) {
        var d3event = { type: layout_1.EventType[e.type], alpha: e.alpha, stress: e.stress };
        this.event.call(d3event.type, d3event);
    };
    D3StyleLayoutAdaptor.prototype.kick = function () {
        var _this = this;
        var t = this.d3Context.timer(function () { return _super.prototype.tick.call(_this) && t.stop(); });
    };
    D3StyleLayoutAdaptor.prototype.on = function (eventType, listener) {
        if (typeof eventType === 'string') {
            this.event.on(eventType, listener);
        }
        else {
            this.event.on(layout_1.EventType[eventType], listener);
        }
        return this;
    };
    return D3StyleLayoutAdaptor;
}(layout_1.Layout));
exports.D3StyleLayoutAdaptor = D3StyleLayoutAdaptor;

},{"./layout":16}],12:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Locks = (function () {
    function Locks() {
        this.locks = {};
    }
    Locks.prototype.add = function (id, x) {
        this.locks[id] = x;
    };
    Locks.prototype.clear = function () {
        this.locks = {};
    };
    Locks.prototype.isEmpty = function () {
        for (var l in this.locks)
            return false;
        return true;
    };
    Locks.prototype.apply = function (f) {
        for (var l in this.locks) {
            f(Number(l), this.locks[l]);
        }
    };
    return Locks;
}());
exports.Locks = Locks;
var Descent = (function () {
    function Descent(x, D, G) {
        if (G === void 0) { G = null; }
        this.D = D;
        this.G = G;
        this.threshold = 0.0001;
        this.numGridSnapNodes = 0;
        this.snapGridSize = 100;
        this.snapStrength = 1000;
        this.scaleSnapByMaxH = false;
        this.random = new PseudoRandom();
        this.project = null;
        this.x = x;
        this.k = x.length;
        var n = this.n = x[0].length;
        this.H = new Array(this.k);
        this.g = new Array(this.k);
        this.Hd = new Array(this.k);
        this.a = new Array(this.k);
        this.b = new Array(this.k);
        this.c = new Array(this.k);
        this.d = new Array(this.k);
        this.e = new Array(this.k);
        this.ia = new Array(this.k);
        this.ib = new Array(this.k);
        this.xtmp = new Array(this.k);
        this.locks = new Locks();
        this.minD = Number.MAX_VALUE;
        var i = n, j;
        while (i--) {
            j = n;
            while (--j > i) {
                var d = D[i][j];
                if (d > 0 && d < this.minD) {
                    this.minD = d;
                }
            }
        }
        if (this.minD === Number.MAX_VALUE)
            this.minD = 1;
        i = this.k;
        while (i--) {
            this.g[i] = new Array(n);
            this.H[i] = new Array(n);
            j = n;
            while (j--) {
                this.H[i][j] = new Array(n);
            }
            this.Hd[i] = new Array(n);
            this.a[i] = new Array(n);
            this.b[i] = new Array(n);
            this.c[i] = new Array(n);
            this.d[i] = new Array(n);
            this.e[i] = new Array(n);
            this.ia[i] = new Array(n);
            this.ib[i] = new Array(n);
            this.xtmp[i] = new Array(n);
        }
    }
    Descent.createSquareMatrix = function (n, f) {
        var M = new Array(n);
        for (var i = 0; i < n; ++i) {
            M[i] = new Array(n);
            for (var j = 0; j < n; ++j) {
                M[i][j] = f(i, j);
            }
        }
        return M;
    };
    Descent.prototype.offsetDir = function () {
        var _this = this;
        var u = new Array(this.k);
        var l = 0;
        for (var i = 0; i < this.k; ++i) {
            var x = u[i] = this.random.getNextBetween(0.01, 1) - 0.5;
            l += x * x;
        }
        l = Math.sqrt(l);
        return u.map(function (x) { return x *= _this.minD / l; });
    };
    Descent.prototype.computeDerivatives = function (x) {
        var _this = this;
        var n = this.n;
        if (n < 1)
            return;
        var i;
        var d = new Array(this.k);
        var d2 = new Array(this.k);
        var Huu = new Array(this.k);
        var maxH = 0;
        for (var u = 0; u < n; ++u) {
            for (i = 0; i < this.k; ++i)
                Huu[i] = this.g[i][u] = 0;
            for (var v = 0; v < n; ++v) {
                if (u === v)
                    continue;
                var maxDisplaces = n;
                while (maxDisplaces--) {
                    var sd2 = 0;
                    for (i = 0; i < this.k; ++i) {
                        var dx = d[i] = x[i][u] - x[i][v];
                        sd2 += d2[i] = dx * dx;
                    }
                    if (sd2 > 1e-9)
                        break;
                    var rd = this.offsetDir();
                    for (i = 0; i < this.k; ++i)
                        x[i][v] += rd[i];
                }
                var l = Math.sqrt(sd2);
                var D = this.D[u][v];
                var weight = this.G != null ? this.G[u][v] : 1;
                if (weight > 1 && l > D || !isFinite(D)) {
                    for (i = 0; i < this.k; ++i)
                        this.H[i][u][v] = 0;
                    continue;
                }
                if (weight > 1) {
                    weight = 1;
                }
                var D2 = D * D;
                var gs = 2 * weight * (l - D) / (D2 * l);
                var l3 = l * l * l;
                var hs = 2 * -weight / (D2 * l3);
                if (!isFinite(gs))
                    console.log(gs);
                for (i = 0; i < this.k; ++i) {
                    this.g[i][u] += d[i] * gs;
                    Huu[i] -= this.H[i][u][v] = hs * (l3 + D * (d2[i] - sd2) + l * sd2);
                }
            }
            for (i = 0; i < this.k; ++i)
                maxH = Math.max(maxH, this.H[i][u][u] = Huu[i]);
        }
        var r = this.snapGridSize / 2;
        var g = this.snapGridSize;
        var w = this.snapStrength;
        var k = w / (r * r);
        var numNodes = this.numGridSnapNodes;
        for (var u = 0; u < numNodes; ++u) {
            for (i = 0; i < this.k; ++i) {
                var xiu = this.x[i][u];
                var m = xiu / g;
                var f = m % 1;
                var q = m - f;
                var a = Math.abs(f);
                var dx = (a <= 0.5) ? xiu - q * g :
                    (xiu > 0) ? xiu - (q + 1) * g : xiu - (q - 1) * g;
                if (-r < dx && dx <= r) {
                    if (this.scaleSnapByMaxH) {
                        this.g[i][u] += maxH * k * dx;
                        this.H[i][u][u] += maxH * k;
                    }
                    else {
                        this.g[i][u] += k * dx;
                        this.H[i][u][u] += k;
                    }
                }
            }
        }
        if (!this.locks.isEmpty()) {
            this.locks.apply(function (u, p) {
                for (i = 0; i < _this.k; ++i) {
                    _this.H[i][u][u] += maxH;
                    _this.g[i][u] -= maxH * (p[i] - x[i][u]);
                }
            });
        }
    };
    Descent.dotProd = function (a, b) {
        var x = 0, i = a.length;
        while (i--)
            x += a[i] * b[i];
        return x;
    };
    Descent.rightMultiply = function (m, v, r) {
        var i = m.length;
        while (i--)
            r[i] = Descent.dotProd(m[i], v);
    };
    Descent.prototype.computeStepSize = function (d) {
        var numerator = 0, denominator = 0;
        for (var i = 0; i < this.k; ++i) {
            numerator += Descent.dotProd(this.g[i], d[i]);
            Descent.rightMultiply(this.H[i], d[i], this.Hd[i]);
            denominator += Descent.dotProd(d[i], this.Hd[i]);
        }
        if (denominator === 0 || !isFinite(denominator))
            return 0;
        return 1 * numerator / denominator;
    };
    Descent.prototype.reduceStress = function () {
        this.computeDerivatives(this.x);
        var alpha = this.computeStepSize(this.g);
        for (var i = 0; i < this.k; ++i) {
            this.takeDescentStep(this.x[i], this.g[i], alpha);
        }
        return this.computeStress();
    };
    Descent.copy = function (a, b) {
        var m = a.length, n = b[0].length;
        for (var i = 0; i < m; ++i) {
            for (var j = 0; j < n; ++j) {
                b[i][j] = a[i][j];
            }
        }
    };
    Descent.prototype.stepAndProject = function (x0, r, d, stepSize) {
        Descent.copy(x0, r);
        this.takeDescentStep(r[0], d[0], stepSize);
        if (this.project)
            this.project[0](x0[0], x0[1], r[0]);
        this.takeDescentStep(r[1], d[1], stepSize);
        if (this.project)
            this.project[1](r[0], x0[1], r[1]);
        for (var i = 2; i < this.k; i++)
            this.takeDescentStep(r[i], d[i], stepSize);
    };
    Descent.mApply = function (m, n, f) {
        var i = m;
        while (i-- > 0) {
            var j = n;
            while (j-- > 0)
                f(i, j);
        }
    };
    Descent.prototype.matrixApply = function (f) {
        Descent.mApply(this.k, this.n, f);
    };
    Descent.prototype.computeNextPosition = function (x0, r) {
        var _this = this;
        this.computeDerivatives(x0);
        var alpha = this.computeStepSize(this.g);
        this.stepAndProject(x0, r, this.g, alpha);
        if (this.project) {
            this.matrixApply(function (i, j) { return _this.e[i][j] = x0[i][j] - r[i][j]; });
            var beta = this.computeStepSize(this.e);
            beta = Math.max(0.2, Math.min(beta, 1));
            this.stepAndProject(x0, r, this.e, beta);
        }
    };
    Descent.prototype.run = function (iterations) {
        var stress = Number.MAX_VALUE, converged = false;
        while (!converged && iterations-- > 0) {
            var s = this.rungeKutta();
            converged = Math.abs(stress / s - 1) < this.threshold;
            stress = s;
        }
        return stress;
    };
    Descent.prototype.rungeKutta = function () {
        var _this = this;
        this.computeNextPosition(this.x, this.a);
        Descent.mid(this.x, this.a, this.ia);
        this.computeNextPosition(this.ia, this.b);
        Descent.mid(this.x, this.b, this.ib);
        this.computeNextPosition(this.ib, this.c);
        this.computeNextPosition(this.c, this.d);
        var disp = 0;
        this.matrixApply(function (i, j) {
            var x = (_this.a[i][j] + 2.0 * _this.b[i][j] + 2.0 * _this.c[i][j] + _this.d[i][j]) / 6.0, d = _this.x[i][j] - x;
            disp += d * d;
            _this.x[i][j] = x;
        });
        return disp;
    };
    Descent.mid = function (a, b, m) {
        Descent.mApply(a.length, a[0].length, function (i, j) {
            return m[i][j] = a[i][j] + (b[i][j] - a[i][j]) / 2.0;
        });
    };
    Descent.prototype.takeDescentStep = function (x, d, stepSize) {
        for (var i = 0; i < this.n; ++i) {
            x[i] = x[i] - stepSize * d[i];
        }
    };
    Descent.prototype.computeStress = function () {
        var stress = 0;
        for (var u = 0, nMinus1 = this.n - 1; u < nMinus1; ++u) {
            for (var v = u + 1, n = this.n; v < n; ++v) {
                var l = 0;
                for (var i = 0; i < this.k; ++i) {
                    var dx = this.x[i][u] - this.x[i][v];
                    l += dx * dx;
                }
                l = Math.sqrt(l);
                var d = this.D[u][v];
                if (!isFinite(d))
                    continue;
                var rl = d - l;
                var d2 = d * d;
                stress += rl * rl / d2;
            }
        }
        return stress;
    };
    Descent.zeroDistance = 1e-10;
    return Descent;
}());
exports.Descent = Descent;
var PseudoRandom = (function () {
    function PseudoRandom(seed) {
        if (seed === void 0) { seed = 1; }
        this.seed = seed;
        this.a = 214013;
        this.c = 2531011;
        this.m = 2147483648;
        this.range = 32767;
    }
    PseudoRandom.prototype.getNext = function () {
        this.seed = (this.seed * this.a + this.c) % this.m;
        return (this.seed >> 16) / this.range;
    };
    PseudoRandom.prototype.getNextBetween = function (min, max) {
        return min + this.getNext() * (max - min);
    };
    return PseudoRandom;
}());
exports.PseudoRandom = PseudoRandom;

},{}],13:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var rectangle_1 = require("./rectangle");
var Point = (function () {
    function Point() {
    }
    return Point;
}());
exports.Point = Point;
var LineSegment = (function () {
    function LineSegment(x1, y1, x2, y2) {
        this.x1 = x1;
        this.y1 = y1;
        this.x2 = x2;
        this.y2 = y2;
    }
    return LineSegment;
}());
exports.LineSegment = LineSegment;
var PolyPoint = (function (_super) {
    __extends(PolyPoint, _super);
    function PolyPoint() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return PolyPoint;
}(Point));
exports.PolyPoint = PolyPoint;
function isLeft(P0, P1, P2) {
    return (P1.x - P0.x) * (P2.y - P0.y) - (P2.x - P0.x) * (P1.y - P0.y);
}
exports.isLeft = isLeft;
function above(p, vi, vj) {
    return isLeft(p, vi, vj) > 0;
}
function below(p, vi, vj) {
    return isLeft(p, vi, vj) < 0;
}
function ConvexHull(S) {
    var P = S.slice(0).sort(function (a, b) { return a.x !== b.x ? b.x - a.x : b.y - a.y; });
    var n = S.length, i;
    var minmin = 0;
    var xmin = P[0].x;
    for (i = 1; i < n; ++i) {
        if (P[i].x !== xmin)
            break;
    }
    var minmax = i - 1;
    var H = [];
    H.push(P[minmin]);
    if (minmax === n - 1) {
        if (P[minmax].y !== P[minmin].y)
            H.push(P[minmax]);
    }
    else {
        var maxmin, maxmax = n - 1;
        var xmax = P[n - 1].x;
        for (i = n - 2; i >= 0; i--)
            if (P[i].x !== xmax)
                break;
        maxmin = i + 1;
        i = minmax;
        while (++i <= maxmin) {
            if (isLeft(P[minmin], P[maxmin], P[i]) >= 0 && i < maxmin)
                continue;
            while (H.length > 1) {
                if (isLeft(H[H.length - 2], H[H.length - 1], P[i]) > 0)
                    break;
                else
                    H.length -= 1;
            }
            if (i != minmin)
                H.push(P[i]);
        }
        if (maxmax != maxmin)
            H.push(P[maxmax]);
        var bot = H.length;
        i = maxmin;
        while (--i >= minmax) {
            if (isLeft(P[maxmax], P[minmax], P[i]) >= 0 && i > minmax)
                continue;
            while (H.length > bot) {
                if (isLeft(H[H.length - 2], H[H.length - 1], P[i]) > 0)
                    break;
                else
                    H.length -= 1;
            }
            if (i != minmin)
                H.push(P[i]);
        }
    }
    return H;
}
exports.ConvexHull = ConvexHull;
function clockwiseRadialSweep(p, P, f) {
    P.slice(0).sort(function (a, b) { return Math.atan2(a.y - p.y, a.x - p.x) - Math.atan2(b.y - p.y, b.x - p.x); }).forEach(f);
}
exports.clockwiseRadialSweep = clockwiseRadialSweep;
function nextPolyPoint(p, ps) {
    if (p.polyIndex === ps.length - 1)
        return ps[0];
    return ps[p.polyIndex + 1];
}
function prevPolyPoint(p, ps) {
    if (p.polyIndex === 0)
        return ps[ps.length - 1];
    return ps[p.polyIndex - 1];
}
function tangent_PointPolyC(P, V) {
    var Vclosed = V.slice(0);
    Vclosed.push(V[0]);
    return { rtan: Rtangent_PointPolyC(P, Vclosed), ltan: Ltangent_PointPolyC(P, Vclosed) };
}
function Rtangent_PointPolyC(P, V) {
    var n = V.length - 1;
    var a, b, c;
    var upA, dnC;
    if (below(P, V[1], V[0]) && !above(P, V[n - 1], V[0]))
        return 0;
    for (a = 0, b = n;;) {
        if (b - a === 1)
            if (above(P, V[a], V[b]))
                return a;
            else
                return b;
        c = Math.floor((a + b) / 2);
        dnC = below(P, V[c + 1], V[c]);
        if (dnC && !above(P, V[c - 1], V[c]))
            return c;
        upA = above(P, V[a + 1], V[a]);
        if (upA) {
            if (dnC)
                b = c;
            else {
                if (above(P, V[a], V[c]))
                    b = c;
                else
                    a = c;
            }
        }
        else {
            if (!dnC)
                a = c;
            else {
                if (below(P, V[a], V[c]))
                    b = c;
                else
                    a = c;
            }
        }
    }
}
function Ltangent_PointPolyC(P, V) {
    var n = V.length - 1;
    var a, b, c;
    var dnA, dnC;
    if (above(P, V[n - 1], V[0]) && !below(P, V[1], V[0]))
        return 0;
    for (a = 0, b = n;;) {
        if (b - a === 1)
            if (below(P, V[a], V[b]))
                return a;
            else
                return b;
        c = Math.floor((a + b) / 2);
        dnC = below(P, V[c + 1], V[c]);
        if (above(P, V[c - 1], V[c]) && !dnC)
            return c;
        dnA = below(P, V[a + 1], V[a]);
        if (dnA) {
            if (!dnC)
                b = c;
            else {
                if (below(P, V[a], V[c]))
                    b = c;
                else
                    a = c;
            }
        }
        else {
            if (dnC)
                a = c;
            else {
                if (above(P, V[a], V[c]))
                    b = c;
                else
                    a = c;
            }
        }
    }
}
function tangent_PolyPolyC(V, W, t1, t2, cmp1, cmp2) {
    var ix1, ix2;
    ix1 = t1(W[0], V);
    ix2 = t2(V[ix1], W);
    var done = false;
    while (!done) {
        done = true;
        while (true) {
            if (ix1 === V.length - 1)
                ix1 = 0;
            if (cmp1(W[ix2], V[ix1], V[ix1 + 1]))
                break;
            ++ix1;
        }
        while (true) {
            if (ix2 === 0)
                ix2 = W.length - 1;
            if (cmp2(V[ix1], W[ix2], W[ix2 - 1]))
                break;
            --ix2;
            done = false;
        }
    }
    return { t1: ix1, t2: ix2 };
}
exports.tangent_PolyPolyC = tangent_PolyPolyC;
function LRtangent_PolyPolyC(V, W) {
    var rl = RLtangent_PolyPolyC(W, V);
    return { t1: rl.t2, t2: rl.t1 };
}
exports.LRtangent_PolyPolyC = LRtangent_PolyPolyC;
function RLtangent_PolyPolyC(V, W) {
    return tangent_PolyPolyC(V, W, Rtangent_PointPolyC, Ltangent_PointPolyC, above, below);
}
exports.RLtangent_PolyPolyC = RLtangent_PolyPolyC;
function LLtangent_PolyPolyC(V, W) {
    return tangent_PolyPolyC(V, W, Ltangent_PointPolyC, Ltangent_PointPolyC, below, below);
}
exports.LLtangent_PolyPolyC = LLtangent_PolyPolyC;
function RRtangent_PolyPolyC(V, W) {
    return tangent_PolyPolyC(V, W, Rtangent_PointPolyC, Rtangent_PointPolyC, above, above);
}
exports.RRtangent_PolyPolyC = RRtangent_PolyPolyC;
var BiTangent = (function () {
    function BiTangent(t1, t2) {
        this.t1 = t1;
        this.t2 = t2;
    }
    return BiTangent;
}());
exports.BiTangent = BiTangent;
var BiTangents = (function () {
    function BiTangents() {
    }
    return BiTangents;
}());
exports.BiTangents = BiTangents;
var TVGPoint = (function (_super) {
    __extends(TVGPoint, _super);
    function TVGPoint() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return TVGPoint;
}(Point));
exports.TVGPoint = TVGPoint;
var VisibilityVertex = (function () {
    function VisibilityVertex(id, polyid, polyvertid, p) {
        this.id = id;
        this.polyid = polyid;
        this.polyvertid = polyvertid;
        this.p = p;
        p.vv = this;
    }
    return VisibilityVertex;
}());
exports.VisibilityVertex = VisibilityVertex;
var VisibilityEdge = (function () {
    function VisibilityEdge(source, target) {
        this.source = source;
        this.target = target;
    }
    VisibilityEdge.prototype.length = function () {
        var dx = this.source.p.x - this.target.p.x;
        var dy = this.source.p.y - this.target.p.y;
        return Math.sqrt(dx * dx + dy * dy);
    };
    return VisibilityEdge;
}());
exports.VisibilityEdge = VisibilityEdge;
var TangentVisibilityGraph = (function () {
    function TangentVisibilityGraph(P, g0) {
        this.P = P;
        this.V = [];
        this.E = [];
        if (!g0) {
            var n = P.length;
            for (var i = 0; i < n; i++) {
                var p = P[i];
                for (var j = 0; j < p.length; ++j) {
                    var pj = p[j], vv = new VisibilityVertex(this.V.length, i, j, pj);
                    this.V.push(vv);
                    if (j > 0)
                        this.E.push(new VisibilityEdge(p[j - 1].vv, vv));
                }
                if (p.length > 1)
                    this.E.push(new VisibilityEdge(p[0].vv, p[p.length - 1].vv));
            }
            for (var i = 0; i < n - 1; i++) {
                var Pi = P[i];
                for (var j = i + 1; j < n; j++) {
                    var Pj = P[j], t = tangents(Pi, Pj);
                    for (var q in t) {
                        var c = t[q], source = Pi[c.t1], target = Pj[c.t2];
                        this.addEdgeIfVisible(source, target, i, j);
                    }
                }
            }
        }
        else {
            this.V = g0.V.slice(0);
            this.E = g0.E.slice(0);
        }
    }
    TangentVisibilityGraph.prototype.addEdgeIfVisible = function (u, v, i1, i2) {
        if (!this.intersectsPolys(new LineSegment(u.x, u.y, v.x, v.y), i1, i2)) {
            this.E.push(new VisibilityEdge(u.vv, v.vv));
        }
    };
    TangentVisibilityGraph.prototype.addPoint = function (p, i1) {
        var n = this.P.length;
        this.V.push(new VisibilityVertex(this.V.length, n, 0, p));
        for (var i = 0; i < n; ++i) {
            if (i === i1)
                continue;
            var poly = this.P[i], t = tangent_PointPolyC(p, poly);
            this.addEdgeIfVisible(p, poly[t.ltan], i1, i);
            this.addEdgeIfVisible(p, poly[t.rtan], i1, i);
        }
        return p.vv;
    };
    TangentVisibilityGraph.prototype.intersectsPolys = function (l, i1, i2) {
        for (var i = 0, n = this.P.length; i < n; ++i) {
            if (i != i1 && i != i2 && intersects(l, this.P[i]).length > 0) {
                return true;
            }
        }
        return false;
    };
    return TangentVisibilityGraph;
}());
exports.TangentVisibilityGraph = TangentVisibilityGraph;
function intersects(l, P) {
    var ints = [];
    for (var i = 1, n = P.length; i < n; ++i) {
        var int = rectangle_1.Rectangle.lineIntersection(l.x1, l.y1, l.x2, l.y2, P[i - 1].x, P[i - 1].y, P[i].x, P[i].y);
        if (int)
            ints.push(int);
    }
    return ints;
}
function tangents(V, W) {
    var m = V.length - 1, n = W.length - 1;
    var bt = new BiTangents();
    for (var i = 0; i < m; ++i) {
        for (var j = 0; j < n; ++j) {
            var v1 = V[i == 0 ? m - 1 : i - 1];
            var v2 = V[i];
            var v3 = V[i + 1];
            var w1 = W[j == 0 ? n - 1 : j - 1];
            var w2 = W[j];
            var w3 = W[j + 1];
            var v1v2w2 = isLeft(v1, v2, w2);
            var v2w1w2 = isLeft(v2, w1, w2);
            var v2w2w3 = isLeft(v2, w2, w3);
            var w1w2v2 = isLeft(w1, w2, v2);
            var w2v1v2 = isLeft(w2, v1, v2);
            var w2v2v3 = isLeft(w2, v2, v3);
            if (v1v2w2 >= 0 && v2w1w2 >= 0 && v2w2w3 < 0
                && w1w2v2 >= 0 && w2v1v2 >= 0 && w2v2v3 < 0) {
                bt.ll = new BiTangent(i, j);
            }
            else if (v1v2w2 <= 0 && v2w1w2 <= 0 && v2w2w3 > 0
                && w1w2v2 <= 0 && w2v1v2 <= 0 && w2v2v3 > 0) {
                bt.rr = new BiTangent(i, j);
            }
            else if (v1v2w2 <= 0 && v2w1w2 > 0 && v2w2w3 <= 0
                && w1w2v2 >= 0 && w2v1v2 < 0 && w2v2v3 >= 0) {
                bt.rl = new BiTangent(i, j);
            }
            else if (v1v2w2 >= 0 && v2w1w2 < 0 && v2w2w3 >= 0
                && w1w2v2 <= 0 && w2v1v2 > 0 && w2v2v3 <= 0) {
                bt.lr = new BiTangent(i, j);
            }
        }
    }
    return bt;
}
exports.tangents = tangents;
function isPointInsidePoly(p, poly) {
    for (var i = 1, n = poly.length; i < n; ++i)
        if (below(poly[i - 1], poly[i], p))
            return false;
    return true;
}
function isAnyPInQ(p, q) {
    return !p.every(function (v) { return !isPointInsidePoly(v, q); });
}
function polysOverlap(p, q) {
    if (isAnyPInQ(p, q))
        return true;
    if (isAnyPInQ(q, p))
        return true;
    for (var i = 1, n = p.length; i < n; ++i) {
        var v = p[i], u = p[i - 1];
        if (intersects(new LineSegment(u.x, u.y, v.x, v.y), q).length > 0)
            return true;
    }
    return false;
}
exports.polysOverlap = polysOverlap;

},{"./rectangle":22}],14:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var rectangle_1 = require("./rectangle");
var vpsc_1 = require("./vpsc");
var shortestpaths_1 = require("./shortestpaths");
var NodeWrapper = (function () {
    function NodeWrapper(id, rect, children) {
        this.id = id;
        this.rect = rect;
        this.children = children;
        this.leaf = typeof children === 'undefined' || children.length === 0;
    }
    return NodeWrapper;
}());
exports.NodeWrapper = NodeWrapper;
var Vert = (function () {
    function Vert(id, x, y, node, line) {
        if (node === void 0) { node = null; }
        if (line === void 0) { line = null; }
        this.id = id;
        this.x = x;
        this.y = y;
        this.node = node;
        this.line = line;
    }
    return Vert;
}());
exports.Vert = Vert;
var LongestCommonSubsequence = (function () {
    function LongestCommonSubsequence(s, t) {
        this.s = s;
        this.t = t;
        var mf = LongestCommonSubsequence.findMatch(s, t);
        var tr = t.slice(0).reverse();
        var mr = LongestCommonSubsequence.findMatch(s, tr);
        if (mf.length >= mr.length) {
            this.length = mf.length;
            this.si = mf.si;
            this.ti = mf.ti;
            this.reversed = false;
        }
        else {
            this.length = mr.length;
            this.si = mr.si;
            this.ti = t.length - mr.ti - mr.length;
            this.reversed = true;
        }
    }
    LongestCommonSubsequence.findMatch = function (s, t) {
        var m = s.length;
        var n = t.length;
        var match = { length: 0, si: -1, ti: -1 };
        var l = new Array(m);
        for (var i = 0; i < m; i++) {
            l[i] = new Array(n);
            for (var j = 0; j < n; j++)
                if (s[i] === t[j]) {
                    var v = l[i][j] = (i === 0 || j === 0) ? 1 : l[i - 1][j - 1] + 1;
                    if (v > match.length) {
                        match.length = v;
                        match.si = i - v + 1;
                        match.ti = j - v + 1;
                    }
                    ;
                }
                else
                    l[i][j] = 0;
        }
        return match;
    };
    LongestCommonSubsequence.prototype.getSequence = function () {
        return this.length >= 0 ? this.s.slice(this.si, this.si + this.length) : [];
    };
    return LongestCommonSubsequence;
}());
exports.LongestCommonSubsequence = LongestCommonSubsequence;
var GridRouter = (function () {
    function GridRouter(originalnodes, accessor, groupPadding) {
        if (groupPadding === void 0) { groupPadding = 12; }
        var _this = this;
        this.originalnodes = originalnodes;
        this.groupPadding = groupPadding;
        this.leaves = null;
        this.nodes = originalnodes.map(function (v, i) { return new NodeWrapper(i, accessor.getBounds(v), accessor.getChildren(v)); });
        this.leaves = this.nodes.filter(function (v) { return v.leaf; });
        this.groups = this.nodes.filter(function (g) { return !g.leaf; });
        this.cols = this.getGridLines('x');
        this.rows = this.getGridLines('y');
        this.groups.forEach(function (v) {
            return v.children.forEach(function (c) { return _this.nodes[c].parent = v; });
        });
        this.root = { children: [] };
        this.nodes.forEach(function (v) {
            if (typeof v.parent === 'undefined') {
                v.parent = _this.root;
                _this.root.children.push(v.id);
            }
            v.ports = [];
        });
        this.backToFront = this.nodes.slice(0);
        this.backToFront.sort(function (x, y) { return _this.getDepth(x) - _this.getDepth(y); });
        var frontToBackGroups = this.backToFront.slice(0).reverse().filter(function (g) { return !g.leaf; });
        frontToBackGroups.forEach(function (v) {
            var r = rectangle_1.Rectangle.empty();
            v.children.forEach(function (c) { return r = r.union(_this.nodes[c].rect); });
            v.rect = r.inflate(_this.groupPadding);
        });
        var colMids = this.midPoints(this.cols.map(function (r) { return r.pos; }));
        var rowMids = this.midPoints(this.rows.map(function (r) { return r.pos; }));
        var rowx = colMids[0], rowX = colMids[colMids.length - 1];
        var coly = rowMids[0], colY = rowMids[rowMids.length - 1];
        var hlines = this.rows.map(function (r) { return ({ x1: rowx, x2: rowX, y1: r.pos, y2: r.pos }); })
            .concat(rowMids.map(function (m) { return ({ x1: rowx, x2: rowX, y1: m, y2: m }); }));
        var vlines = this.cols.map(function (c) { return ({ x1: c.pos, x2: c.pos, y1: coly, y2: colY }); })
            .concat(colMids.map(function (m) { return ({ x1: m, x2: m, y1: coly, y2: colY }); }));
        var lines = hlines.concat(vlines);
        lines.forEach(function (l) { return l.verts = []; });
        this.verts = [];
        this.edges = [];
        hlines.forEach(function (h) {
            return vlines.forEach(function (v) {
                var p = new Vert(_this.verts.length, v.x1, h.y1);
                h.verts.push(p);
                v.verts.push(p);
                _this.verts.push(p);
                var i = _this.backToFront.length;
                while (i-- > 0) {
                    var node = _this.backToFront[i], r = node.rect;
                    var dx = Math.abs(p.x - r.cx()), dy = Math.abs(p.y - r.cy());
                    if (dx < r.width() / 2 && dy < r.height() / 2) {
                        p.node = node;
                        break;
                    }
                }
            });
        });
        lines.forEach(function (l, li) {
            _this.nodes.forEach(function (v, i) {
                v.rect.lineIntersections(l.x1, l.y1, l.x2, l.y2).forEach(function (intersect, j) {
                    var p = new Vert(_this.verts.length, intersect.x, intersect.y, v, l);
                    _this.verts.push(p);
                    l.verts.push(p);
                    v.ports.push(p);
                });
            });
            var isHoriz = Math.abs(l.y1 - l.y2) < 0.1;
            var delta = function (a, b) { return isHoriz ? b.x - a.x : b.y - a.y; };
            l.verts.sort(delta);
            for (var i = 1; i < l.verts.length; i++) {
                var u = l.verts[i - 1], v = l.verts[i];
                if (u.node && u.node === v.node && u.node.leaf)
                    continue;
                _this.edges.push({ source: u.id, target: v.id, length: Math.abs(delta(u, v)) });
            }
        });
    }
    GridRouter.prototype.avg = function (a) { return a.reduce(function (x, y) { return x + y; }) / a.length; };
    GridRouter.prototype.getGridLines = function (axis) {
        var columns = [];
        var ls = this.leaves.slice(0, this.leaves.length);
        while (ls.length > 0) {
            var overlapping = ls.filter(function (v) { return v.rect['overlap' + axis.toUpperCase()](ls[0].rect); });
            var col = {
                nodes: overlapping,
                pos: this.avg(overlapping.map(function (v) { return v.rect['c' + axis](); }))
            };
            columns.push(col);
            col.nodes.forEach(function (v) { return ls.splice(ls.indexOf(v), 1); });
        }
        columns.sort(function (a, b) { return a.pos - b.pos; });
        return columns;
    };
    GridRouter.prototype.getDepth = function (v) {
        var depth = 0;
        while (v.parent !== this.root) {
            depth++;
            v = v.parent;
        }
        return depth;
    };
    GridRouter.prototype.midPoints = function (a) {
        var gap = a[1] - a[0];
        var mids = [a[0] - gap / 2];
        for (var i = 1; i < a.length; i++) {
            mids.push((a[i] + a[i - 1]) / 2);
        }
        mids.push(a[a.length - 1] + gap / 2);
        return mids;
    };
    GridRouter.prototype.findLineage = function (v) {
        var lineage = [v];
        do {
            v = v.parent;
            lineage.push(v);
        } while (v !== this.root);
        return lineage.reverse();
    };
    GridRouter.prototype.findAncestorPathBetween = function (a, b) {
        var aa = this.findLineage(a), ba = this.findLineage(b), i = 0;
        while (aa[i] === ba[i])
            i++;
        return { commonAncestor: aa[i - 1], lineages: aa.slice(i).concat(ba.slice(i)) };
    };
    GridRouter.prototype.siblingObstacles = function (a, b) {
        var _this = this;
        var path = this.findAncestorPathBetween(a, b);
        var lineageLookup = {};
        path.lineages.forEach(function (v) { return lineageLookup[v.id] = {}; });
        var obstacles = path.commonAncestor.children.filter(function (v) { return !(v in lineageLookup); });
        path.lineages
            .filter(function (v) { return v.parent !== path.commonAncestor; })
            .forEach(function (v) { return obstacles = obstacles.concat(v.parent.children.filter(function (c) { return c !== v.id; })); });
        return obstacles.map(function (v) { return _this.nodes[v]; });
    };
    GridRouter.getSegmentSets = function (routes, x, y) {
        var vsegments = [];
        for (var ei = 0; ei < routes.length; ei++) {
            var route = routes[ei];
            for (var si = 0; si < route.length; si++) {
                var s = route[si];
                s.edgeid = ei;
                s.i = si;
                var sdx = s[1][x] - s[0][x];
                if (Math.abs(sdx) < 0.1) {
                    vsegments.push(s);
                }
            }
        }
        vsegments.sort(function (a, b) { return a[0][x] - b[0][x]; });
        var vsegmentsets = [];
        var segmentset = null;
        for (var i = 0; i < vsegments.length; i++) {
            var s = vsegments[i];
            if (!segmentset || Math.abs(s[0][x] - segmentset.pos) > 0.1) {
                segmentset = { pos: s[0][x], segments: [] };
                vsegmentsets.push(segmentset);
            }
            segmentset.segments.push(s);
        }
        return vsegmentsets;
    };
    GridRouter.nudgeSegs = function (x, y, routes, segments, leftOf, gap) {
        var n = segments.length;
        if (n <= 1)
            return;
        var vs = segments.map(function (s) { return new vpsc_1.Variable(s[0][x]); });
        var cs = [];
        for (var i = 0; i < n; i++) {
            for (var j = 0; j < n; j++) {
                if (i === j)
                    continue;
                var s1 = segments[i], s2 = segments[j], e1 = s1.edgeid, e2 = s2.edgeid, lind = -1, rind = -1;
                if (x == 'x') {
                    if (leftOf(e1, e2)) {
                        if (s1[0][y] < s1[1][y]) {
                            lind = j, rind = i;
                        }
                        else {
                            lind = i, rind = j;
                        }
                    }
                }
                else {
                    if (leftOf(e1, e2)) {
                        if (s1[0][y] < s1[1][y]) {
                            lind = i, rind = j;
                        }
                        else {
                            lind = j, rind = i;
                        }
                    }
                }
                if (lind >= 0) {
                    cs.push(new vpsc_1.Constraint(vs[lind], vs[rind], gap));
                }
            }
        }
        var solver = new vpsc_1.Solver(vs, cs);
        solver.solve();
        vs.forEach(function (v, i) {
            var s = segments[i];
            var pos = v.position();
            s[0][x] = s[1][x] = pos;
            var route = routes[s.edgeid];
            if (s.i > 0)
                route[s.i - 1][1][x] = pos;
            if (s.i < route.length - 1)
                route[s.i + 1][0][x] = pos;
        });
    };
    GridRouter.nudgeSegments = function (routes, x, y, leftOf, gap) {
        var vsegmentsets = GridRouter.getSegmentSets(routes, x, y);
        for (var i = 0; i < vsegmentsets.length; i++) {
            var ss = vsegmentsets[i];
            var events = [];
            for (var j = 0; j < ss.segments.length; j++) {
                var s = ss.segments[j];
                events.push({ type: 0, s: s, pos: Math.min(s[0][y], s[1][y]) });
                events.push({ type: 1, s: s, pos: Math.max(s[0][y], s[1][y]) });
            }
            events.sort(function (a, b) { return a.pos - b.pos + a.type - b.type; });
            var open = [];
            var openCount = 0;
            events.forEach(function (e) {
                if (e.type === 0) {
                    open.push(e.s);
                    openCount++;
                }
                else {
                    openCount--;
                }
                if (openCount == 0) {
                    GridRouter.nudgeSegs(x, y, routes, open, leftOf, gap);
                    open = [];
                }
            });
        }
    };
    GridRouter.prototype.routeEdges = function (edges, nudgeGap, source, target) {
        var _this = this;
        var routePaths = edges.map(function (e) { return _this.route(source(e), target(e)); });
        var order = GridRouter.orderEdges(routePaths);
        var routes = routePaths.map(function (e) { return GridRouter.makeSegments(e); });
        GridRouter.nudgeSegments(routes, 'x', 'y', order, nudgeGap);
        GridRouter.nudgeSegments(routes, 'y', 'x', order, nudgeGap);
        GridRouter.unreverseEdges(routes, routePaths);
        return routes;
    };
    GridRouter.unreverseEdges = function (routes, routePaths) {
        routes.forEach(function (segments, i) {
            var path = routePaths[i];
            if (path.reversed) {
                segments.reverse();
                segments.forEach(function (segment) {
                    segment.reverse();
                });
            }
        });
    };
    GridRouter.angleBetween2Lines = function (line1, line2) {
        var angle1 = Math.atan2(line1[0].y - line1[1].y, line1[0].x - line1[1].x);
        var angle2 = Math.atan2(line2[0].y - line2[1].y, line2[0].x - line2[1].x);
        var diff = angle1 - angle2;
        if (diff > Math.PI || diff < -Math.PI) {
            diff = angle2 - angle1;
        }
        return diff;
    };
    GridRouter.isLeft = function (a, b, c) {
        return ((b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x)) <= 0;
    };
    GridRouter.getOrder = function (pairs) {
        var outgoing = {};
        for (var i = 0; i < pairs.length; i++) {
            var p = pairs[i];
            if (typeof outgoing[p.l] === 'undefined')
                outgoing[p.l] = {};
            outgoing[p.l][p.r] = true;
        }
        return function (l, r) { return typeof outgoing[l] !== 'undefined' && outgoing[l][r]; };
    };
    GridRouter.orderEdges = function (edges) {
        var edgeOrder = [];
        for (var i = 0; i < edges.length - 1; i++) {
            for (var j = i + 1; j < edges.length; j++) {
                var e = edges[i], f = edges[j], lcs = new LongestCommonSubsequence(e, f);
                var u, vi, vj;
                if (lcs.length === 0)
                    continue;
                if (lcs.reversed) {
                    f.reverse();
                    f.reversed = true;
                    lcs = new LongestCommonSubsequence(e, f);
                }
                if ((lcs.si <= 0 || lcs.ti <= 0) &&
                    (lcs.si + lcs.length >= e.length || lcs.ti + lcs.length >= f.length)) {
                    edgeOrder.push({ l: i, r: j });
                    continue;
                }
                if (lcs.si + lcs.length >= e.length || lcs.ti + lcs.length >= f.length) {
                    u = e[lcs.si + 1];
                    vj = e[lcs.si - 1];
                    vi = f[lcs.ti - 1];
                }
                else {
                    u = e[lcs.si + lcs.length - 2];
                    vi = e[lcs.si + lcs.length];
                    vj = f[lcs.ti + lcs.length];
                }
                if (GridRouter.isLeft(u, vi, vj)) {
                    edgeOrder.push({ l: j, r: i });
                }
                else {
                    edgeOrder.push({ l: i, r: j });
                }
            }
        }
        return GridRouter.getOrder(edgeOrder);
    };
    GridRouter.makeSegments = function (path) {
        function copyPoint(p) {
            return { x: p.x, y: p.y };
        }
        var isStraight = function (a, b, c) { return Math.abs((b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x)) < 0.001; };
        var segments = [];
        var a = copyPoint(path[0]);
        for (var i = 1; i < path.length; i++) {
            var b = copyPoint(path[i]), c = i < path.length - 1 ? path[i + 1] : null;
            if (!c || !isStraight(a, b, c)) {
                segments.push([a, b]);
                a = b;
            }
        }
        return segments;
    };
    GridRouter.prototype.route = function (s, t) {
        var _this = this;
        var source = this.nodes[s], target = this.nodes[t];
        this.obstacles = this.siblingObstacles(source, target);
        var obstacleLookup = {};
        this.obstacles.forEach(function (o) { return obstacleLookup[o.id] = o; });
        this.passableEdges = this.edges.filter(function (e) {
            var u = _this.verts[e.source], v = _this.verts[e.target];
            return !(u.node && u.node.id in obstacleLookup
                || v.node && v.node.id in obstacleLookup);
        });
        for (var i = 1; i < source.ports.length; i++) {
            var u = source.ports[0].id;
            var v = source.ports[i].id;
            this.passableEdges.push({
                source: u,
                target: v,
                length: 0
            });
        }
        for (var i = 1; i < target.ports.length; i++) {
            var u = target.ports[0].id;
            var v = target.ports[i].id;
            this.passableEdges.push({
                source: u,
                target: v,
                length: 0
            });
        }
        var getSource = function (e) { return e.source; }, getTarget = function (e) { return e.target; }, getLength = function (e) { return e.length; };
        var shortestPathCalculator = new shortestpaths_1.Calculator(this.verts.length, this.passableEdges, getSource, getTarget, getLength);
        var bendPenalty = function (u, v, w) {
            var a = _this.verts[u], b = _this.verts[v], c = _this.verts[w];
            var dx = Math.abs(c.x - a.x), dy = Math.abs(c.y - a.y);
            if (a.node === source && a.node === b.node || b.node === target && b.node === c.node)
                return 0;
            return dx > 1 && dy > 1 ? 1000 : 0;
        };
        var shortestPath = shortestPathCalculator.PathFromNodeToNodeWithPrevCost(source.ports[0].id, target.ports[0].id, bendPenalty);
        var pathPoints = shortestPath.reverse().map(function (vi) { return _this.verts[vi]; });
        pathPoints.push(this.nodes[target.id].ports[0]);
        return pathPoints.filter(function (v, i) {
            return !(i < pathPoints.length - 1 && pathPoints[i + 1].node === source && v.node === source
                || i > 0 && v.node === target && pathPoints[i - 1].node === target);
        });
    };
    GridRouter.getRoutePath = function (route, cornerradius, arrowwidth, arrowheight) {
        var result = {
            routepath: 'M ' + route[0][0].x + ' ' + route[0][0].y + ' ',
            arrowpath: ''
        };
        if (route.length > 1) {
            for (var i = 0; i < route.length; i++) {
                var li = route[i];
                var x = li[1].x, y = li[1].y;
                var dx = x - li[0].x;
                var dy = y - li[0].y;
                if (i < route.length - 1) {
                    if (Math.abs(dx) > 0) {
                        x -= dx / Math.abs(dx) * cornerradius;
                    }
                    else {
                        y -= dy / Math.abs(dy) * cornerradius;
                    }
                    result.routepath += 'L ' + x + ' ' + y + ' ';
                    var l = route[i + 1];
                    var x0 = l[0].x, y0 = l[0].y;
                    var x1 = l[1].x;
                    var y1 = l[1].y;
                    dx = x1 - x0;
                    dy = y1 - y0;
                    var angle = GridRouter.angleBetween2Lines(li, l) < 0 ? 1 : 0;
                    var x2, y2;
                    if (Math.abs(dx) > 0) {
                        x2 = x0 + dx / Math.abs(dx) * cornerradius;
                        y2 = y0;
                    }
                    else {
                        x2 = x0;
                        y2 = y0 + dy / Math.abs(dy) * cornerradius;
                    }
                    var cx = Math.abs(x2 - x);
                    var cy = Math.abs(y2 - y);
                    result.routepath += 'A ' + cx + ' ' + cy + ' 0 0 ' + angle + ' ' + x2 + ' ' + y2 + ' ';
                }
                else {
                    var arrowtip = [x, y];
                    var arrowcorner1, arrowcorner2;
                    if (Math.abs(dx) > 0) {
                        x -= dx / Math.abs(dx) * arrowheight;
                        arrowcorner1 = [x, y + arrowwidth];
                        arrowcorner2 = [x, y - arrowwidth];
                    }
                    else {
                        y -= dy / Math.abs(dy) * arrowheight;
                        arrowcorner1 = [x + arrowwidth, y];
                        arrowcorner2 = [x - arrowwidth, y];
                    }
                    result.routepath += 'L ' + x + ' ' + y + ' ';
                    if (arrowheight > 0) {
                        result.arrowpath = 'M ' + arrowtip[0] + ' ' + arrowtip[1] + ' L ' + arrowcorner1[0] + ' ' + arrowcorner1[1]
                            + ' L ' + arrowcorner2[0] + ' ' + arrowcorner2[1];
                    }
                }
            }
        }
        else {
            var li = route[0];
            var x = li[1].x, y = li[1].y;
            var dx = x - li[0].x;
            var dy = y - li[0].y;
            var arrowtip = [x, y];
            var arrowcorner1, arrowcorner2;
            if (Math.abs(dx) > 0) {
                x -= dx / Math.abs(dx) * arrowheight;
                arrowcorner1 = [x, y + arrowwidth];
                arrowcorner2 = [x, y - arrowwidth];
            }
            else {
                y -= dy / Math.abs(dy) * arrowheight;
                arrowcorner1 = [x + arrowwidth, y];
                arrowcorner2 = [x - arrowwidth, y];
            }
            result.routepath += 'L ' + x + ' ' + y + ' ';
            if (arrowheight > 0) {
                result.arrowpath = 'M ' + arrowtip[0] + ' ' + arrowtip[1] + ' L ' + arrowcorner1[0] + ' ' + arrowcorner1[1]
                    + ' L ' + arrowcorner2[0] + ' ' + arrowcorner2[1];
            }
        }
        return result;
    };
    return GridRouter;
}());
exports.GridRouter = GridRouter;

},{"./rectangle":22,"./shortestpaths":23,"./vpsc":24}],15:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var packingOptions = {
    PADDING: 10,
    GOLDEN_SECTION: (1 + Math.sqrt(5)) / 2,
    FLOAT_EPSILON: 0.0001,
    MAX_INERATIONS: 100
};
function applyPacking(graphs, w, h, node_size, desired_ratio) {
    if (desired_ratio === void 0) { desired_ratio = 1; }
    var init_x = 0, init_y = 0, svg_width = w, svg_height = h, desired_ratio = typeof desired_ratio !== 'undefined' ? desired_ratio : 1, node_size = typeof node_size !== 'undefined' ? node_size : 0, real_width = 0, real_height = 0, min_width = 0, global_bottom = 0, line = [];
    if (graphs.length == 0)
        return;
    calculate_bb(graphs);
    apply(graphs, desired_ratio);
    put_nodes_to_right_positions(graphs);
    function calculate_bb(graphs) {
        graphs.forEach(function (g) {
            calculate_single_bb(g);
        });
        function calculate_single_bb(graph) {
            var min_x = Number.MAX_VALUE, min_y = Number.MAX_VALUE, max_x = 0, max_y = 0;
            graph.array.forEach(function (v) {
                var w = typeof v.width !== 'undefined' ? v.width : node_size;
                var h = typeof v.height !== 'undefined' ? v.height : node_size;
                w /= 2;
                h /= 2;
                max_x = Math.max(v.x + w, max_x);
                min_x = Math.min(v.x - w, min_x);
                max_y = Math.max(v.y + h, max_y);
                min_y = Math.min(v.y - h, min_y);
            });
            graph.width = max_x - min_x;
            graph.height = max_y - min_y;
        }
    }
    function put_nodes_to_right_positions(graphs) {
        graphs.forEach(function (g) {
            var center = { x: 0, y: 0 };
            g.array.forEach(function (node) {
                center.x += node.x;
                center.y += node.y;
            });
            center.x /= g.array.length;
            center.y /= g.array.length;
            var corner = { x: center.x - g.width / 2, y: center.y - g.height / 2 };
            var offset = { x: g.x - corner.x + svg_width / 2 - real_width / 2, y: g.y - corner.y + svg_height / 2 - real_height / 2 };
            g.array.forEach(function (node) {
                node.x += offset.x;
                node.y += offset.y;
            });
        });
    }
    function apply(data, desired_ratio) {
        var curr_best_f = Number.POSITIVE_INFINITY;
        var curr_best = 0;
        data.sort(function (a, b) { return b.height - a.height; });
        min_width = data.reduce(function (a, b) {
            return a.width < b.width ? a.width : b.width;
        });
        var left = x1 = min_width;
        var right = x2 = get_entire_width(data);
        var iterationCounter = 0;
        var f_x1 = Number.MAX_VALUE;
        var f_x2 = Number.MAX_VALUE;
        var flag = -1;
        var dx = Number.MAX_VALUE;
        var df = Number.MAX_VALUE;
        while ((dx > min_width) || df > packingOptions.FLOAT_EPSILON) {
            if (flag != 1) {
                var x1 = right - (right - left) / packingOptions.GOLDEN_SECTION;
                var f_x1 = step(data, x1);
            }
            if (flag != 0) {
                var x2 = left + (right - left) / packingOptions.GOLDEN_SECTION;
                var f_x2 = step(data, x2);
            }
            dx = Math.abs(x1 - x2);
            df = Math.abs(f_x1 - f_x2);
            if (f_x1 < curr_best_f) {
                curr_best_f = f_x1;
                curr_best = x1;
            }
            if (f_x2 < curr_best_f) {
                curr_best_f = f_x2;
                curr_best = x2;
            }
            if (f_x1 > f_x2) {
                left = x1;
                x1 = x2;
                f_x1 = f_x2;
                flag = 1;
            }
            else {
                right = x2;
                x2 = x1;
                f_x2 = f_x1;
                flag = 0;
            }
            if (iterationCounter++ > 100) {
                break;
            }
        }
        step(data, curr_best);
    }
    function step(data, max_width) {
        line = [];
        real_width = 0;
        real_height = 0;
        global_bottom = init_y;
        for (var i = 0; i < data.length; i++) {
            var o = data[i];
            put_rect(o, max_width);
        }
        return Math.abs(get_real_ratio() - desired_ratio);
    }
    function put_rect(rect, max_width) {
        var parent = undefined;
        for (var i = 0; i < line.length; i++) {
            if ((line[i].space_left >= rect.height) && (line[i].x + line[i].width + rect.width + packingOptions.PADDING - max_width) <= packingOptions.FLOAT_EPSILON) {
                parent = line[i];
                break;
            }
        }
        line.push(rect);
        if (parent !== undefined) {
            rect.x = parent.x + parent.width + packingOptions.PADDING;
            rect.y = parent.bottom;
            rect.space_left = rect.height;
            rect.bottom = rect.y;
            parent.space_left -= rect.height + packingOptions.PADDING;
            parent.bottom += rect.height + packingOptions.PADDING;
        }
        else {
            rect.y = global_bottom;
            global_bottom += rect.height + packingOptions.PADDING;
            rect.x = init_x;
            rect.bottom = rect.y;
            rect.space_left = rect.height;
        }
        if (rect.y + rect.height - real_height > -packingOptions.FLOAT_EPSILON)
            real_height = rect.y + rect.height - init_y;
        if (rect.x + rect.width - real_width > -packingOptions.FLOAT_EPSILON)
            real_width = rect.x + rect.width - init_x;
    }
    ;
    function get_entire_width(data) {
        var width = 0;
        data.forEach(function (d) { return width += d.width + packingOptions.PADDING; });
        return width;
    }
    function get_real_ratio() {
        return (real_width / real_height);
    }
}
exports.applyPacking = applyPacking;
function separateGraphs(nodes, links) {
    var marks = {};
    var ways = {};
    var graphs = [];
    var clusters = 0;
    for (var i = 0; i < links.length; i++) {
        var link = links[i];
        var n1 = link.source;
        var n2 = link.target;
        if (ways[n1.index])
            ways[n1.index].push(n2);
        else
            ways[n1.index] = [n2];
        if (ways[n2.index])
            ways[n2.index].push(n1);
        else
            ways[n2.index] = [n1];
    }
    for (var i = 0; i < nodes.length; i++) {
        var node = nodes[i];
        if (marks[node.index])
            continue;
        explore_node(node, true);
    }
    function explore_node(n, is_new) {
        if (marks[n.index] !== undefined)
            return;
        if (is_new) {
            clusters++;
            graphs.push({ array: [] });
        }
        marks[n.index] = clusters;
        graphs[clusters - 1].array.push(n);
        var adjacent = ways[n.index];
        if (!adjacent)
            return;
        for (var j = 0; j < adjacent.length; j++) {
            explore_node(adjacent[j], false);
        }
    }
    return graphs;
}
exports.separateGraphs = separateGraphs;

},{}],16:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var powergraph = require("./powergraph");
var linklengths_1 = require("./linklengths");
var descent_1 = require("./descent");
var rectangle_1 = require("./rectangle");
var shortestpaths_1 = require("./shortestpaths");
var geom_1 = require("./geom");
var handledisconnected_1 = require("./handledisconnected");
var EventType;
(function (EventType) {
    EventType[EventType["start"] = 0] = "start";
    EventType[EventType["tick"] = 1] = "tick";
    EventType[EventType["end"] = 2] = "end";
})(EventType = exports.EventType || (exports.EventType = {}));
;
function isGroup(g) {
    return typeof g.leaves !== 'undefined' || typeof g.groups !== 'undefined';
}
var Layout = (function () {
    function Layout() {
        var _this = this;
        this._canvasSize = [1, 1];
        this._linkDistance = 20;
        this._defaultNodeSize = 10;
        this._linkLengthCalculator = null;
        this._linkType = null;
        this._avoidOverlaps = false;
        this._handleDisconnected = true;
        this._running = false;
        this._nodes = [];
        this._groups = [];
        this._rootGroup = null;
        this._links = [];
        this._constraints = [];
        this._distanceMatrix = null;
        this._descent = null;
        this._directedLinkConstraints = null;
        this._threshold = 0.01;
        this._visibilityGraph = null;
        this._groupCompactness = 1e-6;
        this.event = null;
        this.linkAccessor = {
            getSourceIndex: Layout.getSourceIndex,
            getTargetIndex: Layout.getTargetIndex,
            setLength: Layout.setLinkLength,
            getType: function (l) { return typeof _this._linkType === "function" ? _this._linkType(l) : 0; }
        };
    }
    Layout.prototype.on = function (e, listener) {
        if (!this.event)
            this.event = {};
        if (typeof e === 'string') {
            this.event[EventType[e]] = listener;
        }
        else {
            this.event[e] = listener;
        }
        return this;
    };
    Layout.prototype.trigger = function (e) {
        if (this.event && typeof this.event[e.type] !== 'undefined') {
            this.event[e.type](e);
        }
    };
    Layout.prototype.kick = function () {
        while (!this.tick())
            ;
    };
    Layout.prototype.tick = function () {
        if (this._alpha < this._threshold) {
            this._running = false;
            this.trigger({ type: EventType.end, alpha: this._alpha = 0, stress: this._lastStress });
            return true;
        }
        var n = this._nodes.length, m = this._links.length;
        var o, i;
        this._descent.locks.clear();
        for (i = 0; i < n; ++i) {
            o = this._nodes[i];
            if (o.fixed) {
                if (typeof o.px === 'undefined' || typeof o.py === 'undefined') {
                    o.px = o.x;
                    o.py = o.y;
                }
                var p = [o.px, o.py];
                this._descent.locks.add(i, p);
            }
        }
        var s1 = this._descent.rungeKutta();
        if (s1 === 0) {
            this._alpha = 0;
        }
        else if (typeof this._lastStress !== 'undefined') {
            this._alpha = s1;
        }
        this._lastStress = s1;
        this.updateNodePositions();
        this.trigger({ type: EventType.tick, alpha: this._alpha, stress: this._lastStress });
        return false;
    };
    Layout.prototype.updateNodePositions = function () {
        var x = this._descent.x[0], y = this._descent.x[1];
        var o, i = this._nodes.length;
        while (i--) {
            o = this._nodes[i];
            o.x = x[i];
            o.y = y[i];
        }
    };
    Layout.prototype.nodes = function (v) {
        if (!v) {
            if (this._nodes.length === 0 && this._links.length > 0) {
                var n = 0;
                this._links.forEach(function (l) {
                    n = Math.max(n, l.source, l.target);
                });
                this._nodes = new Array(++n);
                for (var i = 0; i < n; ++i) {
                    this._nodes[i] = {};
                }
            }
            return this._nodes;
        }
        this._nodes = v;
        return this;
    };
    Layout.prototype.groups = function (x) {
        var _this = this;
        if (!x)
            return this._groups;
        this._groups = x;
        this._rootGroup = {};
        this._groups.forEach(function (g) {
            if (typeof g.padding === "undefined")
                g.padding = 1;
            if (typeof g.leaves !== "undefined") {
                g.leaves.forEach(function (v, i) {
                    if (typeof v === 'number')
                        (g.leaves[i] = _this._nodes[v]).parent = g;
                });
            }
            if (typeof g.groups !== "undefined") {
                g.groups.forEach(function (gi, i) {
                    if (typeof gi === 'number')
                        (g.groups[i] = _this._groups[gi]).parent = g;
                });
            }
        });
        this._rootGroup.leaves = this._nodes.filter(function (v) { return typeof v.parent === 'undefined'; });
        this._rootGroup.groups = this._groups.filter(function (g) { return typeof g.parent === 'undefined'; });
        return this;
    };
    Layout.prototype.powerGraphGroups = function (f) {
        var g = powergraph.getGroups(this._nodes, this._links, this.linkAccessor, this._rootGroup);
        this.groups(g.groups);
        f(g);
        return this;
    };
    Layout.prototype.avoidOverlaps = function (v) {
        if (!arguments.length)
            return this._avoidOverlaps;
        this._avoidOverlaps = v;
        return this;
    };
    Layout.prototype.handleDisconnected = function (v) {
        if (!arguments.length)
            return this._handleDisconnected;
        this._handleDisconnected = v;
        return this;
    };
    Layout.prototype.flowLayout = function (axis, minSeparation) {
        if (!arguments.length)
            axis = 'y';
        this._directedLinkConstraints = {
            axis: axis,
            getMinSeparation: typeof minSeparation === 'number' ? function () { return minSeparation; } : minSeparation
        };
        return this;
    };
    Layout.prototype.links = function (x) {
        if (!arguments.length)
            return this._links;
        this._links = x;
        return this;
    };
    Layout.prototype.constraints = function (c) {
        if (!arguments.length)
            return this._constraints;
        this._constraints = c;
        return this;
    };
    Layout.prototype.distanceMatrix = function (d) {
        if (!arguments.length)
            return this._distanceMatrix;
        this._distanceMatrix = d;
        return this;
    };
    Layout.prototype.size = function (x) {
        if (!x)
            return this._canvasSize;
        this._canvasSize = x;
        return this;
    };
    Layout.prototype.defaultNodeSize = function (x) {
        if (!x)
            return this._defaultNodeSize;
        this._defaultNodeSize = x;
        return this;
    };
    Layout.prototype.groupCompactness = function (x) {
        if (!x)
            return this._groupCompactness;
        this._groupCompactness = x;
        return this;
    };
    Layout.prototype.linkDistance = function (x) {
        if (!x) {
            return this._linkDistance;
        }
        this._linkDistance = typeof x === "function" ? x : +x;
        this._linkLengthCalculator = null;
        return this;
    };
    Layout.prototype.linkType = function (f) {
        this._linkType = f;
        return this;
    };
    Layout.prototype.convergenceThreshold = function (x) {
        if (!x)
            return this._threshold;
        this._threshold = typeof x === "function" ? x : +x;
        return this;
    };
    Layout.prototype.alpha = function (x) {
        if (!arguments.length)
            return this._alpha;
        else {
            x = +x;
            if (this._alpha) {
                if (x > 0)
                    this._alpha = x;
                else
                    this._alpha = 0;
            }
            else if (x > 0) {
                if (!this._running) {
                    this._running = true;
                    this.trigger({ type: EventType.start, alpha: this._alpha = x });
                    this.kick();
                }
            }
            return this;
        }
    };
    Layout.prototype.getLinkLength = function (link) {
        return typeof this._linkDistance === "function" ? +(this._linkDistance(link)) : this._linkDistance;
    };
    Layout.setLinkLength = function (link, length) {
        link.length = length;
    };
    Layout.prototype.getLinkType = function (link) {
        return typeof this._linkType === "function" ? this._linkType(link) : 0;
    };
    Layout.prototype.symmetricDiffLinkLengths = function (idealLength, w) {
        var _this = this;
        if (w === void 0) { w = 1; }
        this.linkDistance(function (l) { return idealLength * l.length; });
        this._linkLengthCalculator = function () { return linklengths_1.symmetricDiffLinkLengths(_this._links, _this.linkAccessor, w); };
        return this;
    };
    Layout.prototype.jaccardLinkLengths = function (idealLength, w) {
        var _this = this;
        if (w === void 0) { w = 1; }
        this.linkDistance(function (l) { return idealLength * l.length; });
        this._linkLengthCalculator = function () { return linklengths_1.jaccardLinkLengths(_this._links, _this.linkAccessor, w); };
        return this;
    };
    Layout.prototype.start = function (initialUnconstrainedIterations, initialUserConstraintIterations, initialAllConstraintsIterations, gridSnapIterations, keepRunning) {
        var _this = this;
        if (initialUnconstrainedIterations === void 0) { initialUnconstrainedIterations = 0; }
        if (initialUserConstraintIterations === void 0) { initialUserConstraintIterations = 0; }
        if (initialAllConstraintsIterations === void 0) { initialAllConstraintsIterations = 0; }
        if (gridSnapIterations === void 0) { gridSnapIterations = 0; }
        if (keepRunning === void 0) { keepRunning = true; }
        var i, j, n = this.nodes().length, N = n + 2 * this._groups.length, m = this._links.length, w = this._canvasSize[0], h = this._canvasSize[1];
        var x = new Array(N), y = new Array(N);
        var G = null;
        var ao = this._avoidOverlaps;
        this._nodes.forEach(function (v, i) {
            v.index = i;
            if (typeof v.x === 'undefined') {
                v.x = w / 2, v.y = h / 2;
            }
            x[i] = v.x, y[i] = v.y;
        });
        if (this._linkLengthCalculator)
            this._linkLengthCalculator();
        var distances;
        if (this._distanceMatrix) {
            distances = this._distanceMatrix;
        }
        else {
            distances = (new shortestpaths_1.Calculator(N, this._links, Layout.getSourceIndex, Layout.getTargetIndex, function (l) { return _this.getLinkLength(l); })).DistanceMatrix();
            G = descent_1.Descent.createSquareMatrix(N, function () { return 2; });
            this._links.forEach(function (l) {
                if (typeof l.source == "number")
                    l.source = _this._nodes[l.source];
                if (typeof l.target == "number")
                    l.target = _this._nodes[l.target];
            });
            this._links.forEach(function (e) {
                var u = Layout.getSourceIndex(e), v = Layout.getTargetIndex(e);
                G[u][v] = G[v][u] = e.weight || 1;
            });
        }
        var D = descent_1.Descent.createSquareMatrix(N, function (i, j) {
            return distances[i][j];
        });
        if (this._rootGroup && typeof this._rootGroup.groups !== 'undefined') {
            var i = n;
            var addAttraction = function (i, j, strength, idealDistance) {
                G[i][j] = G[j][i] = strength;
                D[i][j] = D[j][i] = idealDistance;
            };
            this._groups.forEach(function (g) {
                addAttraction(i, i + 1, _this._groupCompactness, 0.1);
                x[i] = 0, y[i++] = 0;
                x[i] = 0, y[i++] = 0;
            });
        }
        else
            this._rootGroup = { leaves: this._nodes, groups: [] };
        var curConstraints = this._constraints || [];
        if (this._directedLinkConstraints) {
            this.linkAccessor.getMinSeparation = this._directedLinkConstraints.getMinSeparation;
            curConstraints = curConstraints.concat(linklengths_1.generateDirectedEdgeConstraints(n, this._links, this._directedLinkConstraints.axis, (this.linkAccessor)));
        }
        this.avoidOverlaps(false);
        this._descent = new descent_1.Descent([x, y], D);
        this._descent.locks.clear();
        for (var i = 0; i < n; ++i) {
            var o = this._nodes[i];
            if (o.fixed) {
                o.px = o.x;
                o.py = o.y;
                var p = [o.x, o.y];
                this._descent.locks.add(i, p);
            }
        }
        this._descent.threshold = this._threshold;
        this.initialLayout(initialUnconstrainedIterations, x, y);
        if (curConstraints.length > 0)
            this._descent.project = new rectangle_1.Projection(this._nodes, this._groups, this._rootGroup, curConstraints).projectFunctions();
        this._descent.run(initialUserConstraintIterations);
        this.separateOverlappingComponents(w, h);
        this.avoidOverlaps(ao);
        if (ao) {
            this._nodes.forEach(function (v, i) { v.x = x[i], v.y = y[i]; });
            this._descent.project = new rectangle_1.Projection(this._nodes, this._groups, this._rootGroup, curConstraints, true).projectFunctions();
            this._nodes.forEach(function (v, i) { x[i] = v.x, y[i] = v.y; });
        }
        this._descent.G = G;
        this._descent.run(initialAllConstraintsIterations);
        if (gridSnapIterations) {
            this._descent.snapStrength = 1000;
            this._descent.snapGridSize = this._nodes[0].width;
            this._descent.numGridSnapNodes = n;
            this._descent.scaleSnapByMaxH = n != N;
            var G0 = descent_1.Descent.createSquareMatrix(N, function (i, j) {
                if (i >= n || j >= n)
                    return G[i][j];
                return 0;
            });
            this._descent.G = G0;
            this._descent.run(gridSnapIterations);
        }
        this.updateNodePositions();
        this.separateOverlappingComponents(w, h);
        return keepRunning ? this.resume() : this;
    };
    Layout.prototype.initialLayout = function (iterations, x, y) {
        if (this._groups.length > 0 && iterations > 0) {
            var n = this._nodes.length;
            var edges = this._links.map(function (e) { return ({ source: e.source.index, target: e.target.index }); });
            var vs = this._nodes.map(function (v) { return ({ index: v.index }); });
            this._groups.forEach(function (g, i) {
                vs.push({ index: g.index = n + i });
            });
            this._groups.forEach(function (g, i) {
                if (typeof g.leaves !== 'undefined')
                    g.leaves.forEach(function (v) { return edges.push({ source: g.index, target: v.index }); });
                if (typeof g.groups !== 'undefined')
                    g.groups.forEach(function (gg) { return edges.push({ source: g.index, target: gg.index }); });
            });
            new Layout()
                .size(this.size())
                .nodes(vs)
                .links(edges)
                .avoidOverlaps(false)
                .linkDistance(this.linkDistance())
                .symmetricDiffLinkLengths(5)
                .convergenceThreshold(1e-4)
                .start(iterations, 0, 0, 0, false);
            this._nodes.forEach(function (v) {
                x[v.index] = vs[v.index].x;
                y[v.index] = vs[v.index].y;
            });
        }
        else {
            this._descent.run(iterations);
        }
    };
    Layout.prototype.separateOverlappingComponents = function (width, height) {
        var _this = this;
        if (!this._distanceMatrix && this._handleDisconnected) {
            var x_1 = this._descent.x[0], y_1 = this._descent.x[1];
            this._nodes.forEach(function (v, i) { v.x = x_1[i], v.y = y_1[i]; });
            var graphs = handledisconnected_1.separateGraphs(this._nodes, this._links);
            handledisconnected_1.applyPacking(graphs, width, height, this._defaultNodeSize);
            this._nodes.forEach(function (v, i) {
                _this._descent.x[0][i] = v.x, _this._descent.x[1][i] = v.y;
                if (v.bounds) {
                    v.bounds.setXCentre(v.x);
                    v.bounds.setYCentre(v.y);
                }
            });
        }
    };
    Layout.prototype.resume = function () {
        return this.alpha(0.1);
    };
    Layout.prototype.stop = function () {
        return this.alpha(0);
    };
    Layout.prototype.prepareEdgeRouting = function (nodeMargin) {
        if (nodeMargin === void 0) { nodeMargin = 0; }
        this._visibilityGraph = new geom_1.TangentVisibilityGraph(this._nodes.map(function (v) {
            return v.bounds.inflate(-nodeMargin).vertices();
        }));
    };
    Layout.prototype.routeEdge = function (edge, ah, draw) {
        if (ah === void 0) { ah = 5; }
        var lineData = [];
        var vg2 = new geom_1.TangentVisibilityGraph(this._visibilityGraph.P, { V: this._visibilityGraph.V, E: this._visibilityGraph.E }), port1 = { x: edge.source.x, y: edge.source.y }, port2 = { x: edge.target.x, y: edge.target.y }, start = vg2.addPoint(port1, edge.source.index), end = vg2.addPoint(port2, edge.target.index);
        vg2.addEdgeIfVisible(port1, port2, edge.source.index, edge.target.index);
        if (typeof draw !== 'undefined') {
            draw(vg2);
        }
        var sourceInd = function (e) { return e.source.id; }, targetInd = function (e) { return e.target.id; }, length = function (e) { return e.length(); }, spCalc = new shortestpaths_1.Calculator(vg2.V.length, vg2.E, sourceInd, targetInd, length), shortestPath = spCalc.PathFromNodeToNode(start.id, end.id);
        if (shortestPath.length === 1 || shortestPath.length === vg2.V.length) {
            var route = rectangle_1.makeEdgeBetween(edge.source.innerBounds, edge.target.innerBounds, ah);
            lineData = [route.sourceIntersection, route.arrowStart];
        }
        else {
            var n = shortestPath.length - 2, p = vg2.V[shortestPath[n]].p, q = vg2.V[shortestPath[0]].p, lineData = [edge.source.innerBounds.rayIntersection(p.x, p.y)];
            for (var i = n; i >= 0; --i)
                lineData.push(vg2.V[shortestPath[i]].p);
            lineData.push(rectangle_1.makeEdgeTo(q, edge.target.innerBounds, ah));
        }
        return lineData;
    };
    Layout.getSourceIndex = function (e) {
        return typeof e.source === 'number' ? e.source : e.source.index;
    };
    Layout.getTargetIndex = function (e) {
        return typeof e.target === 'number' ? e.target : e.target.index;
    };
    Layout.linkId = function (e) {
        return Layout.getSourceIndex(e) + "-" + Layout.getTargetIndex(e);
    };
    Layout.dragStart = function (d) {
        if (isGroup(d)) {
            Layout.storeOffset(d, Layout.dragOrigin(d));
        }
        else {
            Layout.stopNode(d);
            d.fixed |= 2;
        }
    };
    Layout.stopNode = function (v) {
        v.px = v.x;
        v.py = v.y;
    };
    Layout.storeOffset = function (d, origin) {
        if (typeof d.leaves !== 'undefined') {
            d.leaves.forEach(function (v) {
                v.fixed |= 2;
                Layout.stopNode(v);
                v._dragGroupOffsetX = v.x - origin.x;
                v._dragGroupOffsetY = v.y - origin.y;
            });
        }
        if (typeof d.groups !== 'undefined') {
            d.groups.forEach(function (g) { return Layout.storeOffset(g, origin); });
        }
    };
    Layout.dragOrigin = function (d) {
        if (isGroup(d)) {
            return {
                x: d.bounds.cx(),
                y: d.bounds.cy()
            };
        }
        else {
            return d;
        }
    };
    Layout.drag = function (d, position) {
        if (isGroup(d)) {
            if (typeof d.leaves !== 'undefined') {
                d.leaves.forEach(function (v) {
                    d.bounds.setXCentre(position.x);
                    d.bounds.setYCentre(position.y);
                    v.px = v._dragGroupOffsetX + position.x;
                    v.py = v._dragGroupOffsetY + position.y;
                });
            }
            if (typeof d.groups !== 'undefined') {
                d.groups.forEach(function (g) { return Layout.drag(g, position); });
            }
        }
        else {
            d.px = position.x;
            d.py = position.y;
        }
    };
    Layout.dragEnd = function (d) {
        if (isGroup(d)) {
            if (typeof d.leaves !== 'undefined') {
                d.leaves.forEach(function (v) {
                    Layout.dragEnd(v);
                    delete v._dragGroupOffsetX;
                    delete v._dragGroupOffsetY;
                });
            }
            if (typeof d.groups !== 'undefined') {
                d.groups.forEach(Layout.dragEnd);
            }
        }
        else {
            d.fixed &= ~6;
        }
    };
    Layout.mouseOver = function (d) {
        d.fixed |= 4;
        d.px = d.x, d.py = d.y;
    };
    Layout.mouseOut = function (d) {
        d.fixed &= ~4;
    };
    return Layout;
}());
exports.Layout = Layout;

},{"./descent":12,"./geom":13,"./handledisconnected":15,"./linklengths":18,"./powergraph":19,"./rectangle":22,"./shortestpaths":23}],17:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var shortestpaths_1 = require("./shortestpaths");
var descent_1 = require("./descent");
var rectangle_1 = require("./rectangle");
var linklengths_1 = require("./linklengths");
var Link3D = (function () {
    function Link3D(source, target) {
        this.source = source;
        this.target = target;
    }
    Link3D.prototype.actualLength = function (x) {
        var _this = this;
        return Math.sqrt(x.reduce(function (c, v) {
            var dx = v[_this.target] - v[_this.source];
            return c + dx * dx;
        }, 0));
    };
    return Link3D;
}());
exports.Link3D = Link3D;
var Node3D = (function () {
    function Node3D(x, y, z) {
        if (x === void 0) { x = 0; }
        if (y === void 0) { y = 0; }
        if (z === void 0) { z = 0; }
        this.x = x;
        this.y = y;
        this.z = z;
    }
    return Node3D;
}());
exports.Node3D = Node3D;
var Layout3D = (function () {
    function Layout3D(nodes, links, idealLinkLength) {
        if (idealLinkLength === void 0) { idealLinkLength = 1; }
        var _this = this;
        this.nodes = nodes;
        this.links = links;
        this.idealLinkLength = idealLinkLength;
        this.constraints = null;
        this.useJaccardLinkLengths = true;
        this.result = new Array(Layout3D.k);
        for (var i = 0; i < Layout3D.k; ++i) {
            this.result[i] = new Array(nodes.length);
        }
        nodes.forEach(function (v, i) {
            for (var _i = 0, _a = Layout3D.dims; _i < _a.length; _i++) {
                var dim = _a[_i];
                if (typeof v[dim] == 'undefined')
                    v[dim] = Math.random();
            }
            _this.result[0][i] = v.x;
            _this.result[1][i] = v.y;
            _this.result[2][i] = v.z;
        });
    }
    ;
    Layout3D.prototype.linkLength = function (l) {
        return l.actualLength(this.result);
    };
    Layout3D.prototype.start = function (iterations) {
        var _this = this;
        if (iterations === void 0) { iterations = 100; }
        var n = this.nodes.length;
        var linkAccessor = new LinkAccessor();
        if (this.useJaccardLinkLengths)
            linklengths_1.jaccardLinkLengths(this.links, linkAccessor, 1.5);
        this.links.forEach(function (e) { return e.length *= _this.idealLinkLength; });
        var distanceMatrix = (new shortestpaths_1.Calculator(n, this.links, function (e) { return e.source; }, function (e) { return e.target; }, function (e) { return e.length; })).DistanceMatrix();
        var D = descent_1.Descent.createSquareMatrix(n, function (i, j) { return distanceMatrix[i][j]; });
        var G = descent_1.Descent.createSquareMatrix(n, function () { return 2; });
        this.links.forEach(function (_a) {
            var source = _a.source, target = _a.target;
            return G[source][target] = G[target][source] = 1;
        });
        this.descent = new descent_1.Descent(this.result, D);
        this.descent.threshold = 1e-3;
        this.descent.G = G;
        if (this.constraints)
            this.descent.project = new rectangle_1.Projection(this.nodes, null, null, this.constraints).projectFunctions();
        for (var i = 0; i < this.nodes.length; i++) {
            var v = this.nodes[i];
            if (v.fixed) {
                this.descent.locks.add(i, [v.x, v.y, v.z]);
            }
        }
        this.descent.run(iterations);
        return this;
    };
    Layout3D.prototype.tick = function () {
        this.descent.locks.clear();
        for (var i = 0; i < this.nodes.length; i++) {
            var v = this.nodes[i];
            if (v.fixed) {
                this.descent.locks.add(i, [v.x, v.y, v.z]);
            }
        }
        return this.descent.rungeKutta();
    };
    Layout3D.dims = ['x', 'y', 'z'];
    Layout3D.k = Layout3D.dims.length;
    return Layout3D;
}());
exports.Layout3D = Layout3D;
var LinkAccessor = (function () {
    function LinkAccessor() {
    }
    LinkAccessor.prototype.getSourceIndex = function (e) { return e.source; };
    LinkAccessor.prototype.getTargetIndex = function (e) { return e.target; };
    LinkAccessor.prototype.getLength = function (e) { return e.length; };
    LinkAccessor.prototype.setLength = function (e, l) { e.length = l; };
    return LinkAccessor;
}());

},{"./descent":12,"./linklengths":18,"./rectangle":22,"./shortestpaths":23}],18:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function unionCount(a, b) {
    var u = {};
    for (var i in a)
        u[i] = {};
    for (var i in b)
        u[i] = {};
    return Object.keys(u).length;
}
function intersectionCount(a, b) {
    var n = 0;
    for (var i in a)
        if (typeof b[i] !== 'undefined')
            ++n;
    return n;
}
function getNeighbours(links, la) {
    var neighbours = {};
    var addNeighbours = function (u, v) {
        if (typeof neighbours[u] === 'undefined')
            neighbours[u] = {};
        neighbours[u][v] = {};
    };
    links.forEach(function (e) {
        var u = la.getSourceIndex(e), v = la.getTargetIndex(e);
        addNeighbours(u, v);
        addNeighbours(v, u);
    });
    return neighbours;
}
function computeLinkLengths(links, w, f, la) {
    var neighbours = getNeighbours(links, la);
    links.forEach(function (l) {
        var a = neighbours[la.getSourceIndex(l)];
        var b = neighbours[la.getTargetIndex(l)];
        la.setLength(l, 1 + w * f(a, b));
    });
}
function symmetricDiffLinkLengths(links, la, w) {
    if (w === void 0) { w = 1; }
    computeLinkLengths(links, w, function (a, b) { return Math.sqrt(unionCount(a, b) - intersectionCount(a, b)); }, la);
}
exports.symmetricDiffLinkLengths = symmetricDiffLinkLengths;
function jaccardLinkLengths(links, la, w) {
    if (w === void 0) { w = 1; }
    computeLinkLengths(links, w, function (a, b) {
        return Math.min(Object.keys(a).length, Object.keys(b).length) < 1.1 ? 0 : intersectionCount(a, b) / unionCount(a, b);
    }, la);
}
exports.jaccardLinkLengths = jaccardLinkLengths;
function generateDirectedEdgeConstraints(n, links, axis, la) {
    var components = stronglyConnectedComponents(n, links, la);
    var nodes = {};
    components.forEach(function (c, i) {
        return c.forEach(function (v) { return nodes[v] = i; });
    });
    var constraints = [];
    links.forEach(function (l) {
        var ui = la.getSourceIndex(l), vi = la.getTargetIndex(l), u = nodes[ui], v = nodes[vi];
        if (u !== v) {
            constraints.push({
                axis: axis,
                left: ui,
                right: vi,
                gap: la.getMinSeparation(l)
            });
        }
    });
    return constraints;
}
exports.generateDirectedEdgeConstraints = generateDirectedEdgeConstraints;
function stronglyConnectedComponents(numVertices, edges, la) {
    var nodes = [];
    var index = 0;
    var stack = [];
    var components = [];
    function strongConnect(v) {
        v.index = v.lowlink = index++;
        stack.push(v);
        v.onStack = true;
        for (var _i = 0, _a = v.out; _i < _a.length; _i++) {
            var w = _a[_i];
            if (typeof w.index === 'undefined') {
                strongConnect(w);
                v.lowlink = Math.min(v.lowlink, w.lowlink);
            }
            else if (w.onStack) {
                v.lowlink = Math.min(v.lowlink, w.index);
            }
        }
        if (v.lowlink === v.index) {
            var component = [];
            while (stack.length) {
                w = stack.pop();
                w.onStack = false;
                component.push(w);
                if (w === v)
                    break;
            }
            components.push(component.map(function (v) { return v.id; }));
        }
    }
    for (var i = 0; i < numVertices; i++) {
        nodes.push({ id: i, out: [] });
    }
    for (var _i = 0, edges_1 = edges; _i < edges_1.length; _i++) {
        var e = edges_1[_i];
        var v_1 = nodes[la.getSourceIndex(e)], w = nodes[la.getTargetIndex(e)];
        v_1.out.push(w);
    }
    for (var _a = 0, nodes_1 = nodes; _a < nodes_1.length; _a++) {
        var v = nodes_1[_a];
        if (typeof v.index === 'undefined')
            strongConnect(v);
    }
    return components;
}
exports.stronglyConnectedComponents = stronglyConnectedComponents;

},{}],19:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var PowerEdge = (function () {
    function PowerEdge(source, target, type) {
        this.source = source;
        this.target = target;
        this.type = type;
    }
    return PowerEdge;
}());
exports.PowerEdge = PowerEdge;
var Configuration = (function () {
    function Configuration(n, edges, linkAccessor, rootGroup) {
        var _this = this;
        this.linkAccessor = linkAccessor;
        this.modules = new Array(n);
        this.roots = [];
        if (rootGroup) {
            this.initModulesFromGroup(rootGroup);
        }
        else {
            this.roots.push(new ModuleSet());
            for (var i = 0; i < n; ++i)
                this.roots[0].add(this.modules[i] = new Module(i));
        }
        this.R = edges.length;
        edges.forEach(function (e) {
            var s = _this.modules[linkAccessor.getSourceIndex(e)], t = _this.modules[linkAccessor.getTargetIndex(e)], type = linkAccessor.getType(e);
            s.outgoing.add(type, t);
            t.incoming.add(type, s);
        });
    }
    Configuration.prototype.initModulesFromGroup = function (group) {
        var moduleSet = new ModuleSet();
        this.roots.push(moduleSet);
        for (var i = 0; i < group.leaves.length; ++i) {
            var node = group.leaves[i];
            var module = new Module(node.id);
            this.modules[node.id] = module;
            moduleSet.add(module);
        }
        if (group.groups) {
            for (var j = 0; j < group.groups.length; ++j) {
                var child = group.groups[j];
                var definition = {};
                for (var prop in child)
                    if (prop !== "leaves" && prop !== "groups" && child.hasOwnProperty(prop))
                        definition[prop] = child[prop];
                moduleSet.add(new Module(-1 - j, new LinkSets(), new LinkSets(), this.initModulesFromGroup(child), definition));
            }
        }
        return moduleSet;
    };
    Configuration.prototype.merge = function (a, b, k) {
        if (k === void 0) { k = 0; }
        var inInt = a.incoming.intersection(b.incoming), outInt = a.outgoing.intersection(b.outgoing);
        var children = new ModuleSet();
        children.add(a);
        children.add(b);
        var m = new Module(this.modules.length, outInt, inInt, children);
        this.modules.push(m);
        var update = function (s, i, o) {
            s.forAll(function (ms, linktype) {
                ms.forAll(function (n) {
                    var nls = n[i];
                    nls.add(linktype, m);
                    nls.remove(linktype, a);
                    nls.remove(linktype, b);
                    a[o].remove(linktype, n);
                    b[o].remove(linktype, n);
                });
            });
        };
        update(outInt, "incoming", "outgoing");
        update(inInt, "outgoing", "incoming");
        this.R -= inInt.count() + outInt.count();
        this.roots[k].remove(a);
        this.roots[k].remove(b);
        this.roots[k].add(m);
        return m;
    };
    Configuration.prototype.rootMerges = function (k) {
        if (k === void 0) { k = 0; }
        var rs = this.roots[k].modules();
        var n = rs.length;
        var merges = new Array(n * (n - 1));
        var ctr = 0;
        for (var i = 0, i_ = n - 1; i < i_; ++i) {
            for (var j = i + 1; j < n; ++j) {
                var a = rs[i], b = rs[j];
                merges[ctr] = { id: ctr, nEdges: this.nEdges(a, b), a: a, b: b };
                ctr++;
            }
        }
        return merges;
    };
    Configuration.prototype.greedyMerge = function () {
        for (var i = 0; i < this.roots.length; ++i) {
            if (this.roots[i].modules().length < 2)
                continue;
            var ms = this.rootMerges(i).sort(function (a, b) { return a.nEdges == b.nEdges ? a.id - b.id : a.nEdges - b.nEdges; });
            var m = ms[0];
            if (m.nEdges >= this.R)
                continue;
            this.merge(m.a, m.b, i);
            return true;
        }
    };
    Configuration.prototype.nEdges = function (a, b) {
        var inInt = a.incoming.intersection(b.incoming), outInt = a.outgoing.intersection(b.outgoing);
        return this.R - inInt.count() - outInt.count();
    };
    Configuration.prototype.getGroupHierarchy = function (retargetedEdges) {
        var _this = this;
        var groups = [];
        var root = {};
        toGroups(this.roots[0], root, groups);
        var es = this.allEdges();
        es.forEach(function (e) {
            var a = _this.modules[e.source];
            var b = _this.modules[e.target];
            retargetedEdges.push(new PowerEdge(typeof a.gid === "undefined" ? e.source : groups[a.gid], typeof b.gid === "undefined" ? e.target : groups[b.gid], e.type));
        });
        return groups;
    };
    Configuration.prototype.allEdges = function () {
        var es = [];
        Configuration.getEdges(this.roots[0], es);
        return es;
    };
    Configuration.getEdges = function (modules, es) {
        modules.forAll(function (m) {
            m.getEdges(es);
            Configuration.getEdges(m.children, es);
        });
    };
    return Configuration;
}());
exports.Configuration = Configuration;
function toGroups(modules, group, groups) {
    modules.forAll(function (m) {
        if (m.isLeaf()) {
            if (!group.leaves)
                group.leaves = [];
            group.leaves.push(m.id);
        }
        else {
            var g = group;
            m.gid = groups.length;
            if (!m.isIsland() || m.isPredefined()) {
                g = { id: m.gid };
                if (m.isPredefined())
                    for (var prop in m.definition)
                        g[prop] = m.definition[prop];
                if (!group.groups)
                    group.groups = [];
                group.groups.push(m.gid);
                groups.push(g);
            }
            toGroups(m.children, g, groups);
        }
    });
}
var Module = (function () {
    function Module(id, outgoing, incoming, children, definition) {
        if (outgoing === void 0) { outgoing = new LinkSets(); }
        if (incoming === void 0) { incoming = new LinkSets(); }
        if (children === void 0) { children = new ModuleSet(); }
        this.id = id;
        this.outgoing = outgoing;
        this.incoming = incoming;
        this.children = children;
        this.definition = definition;
    }
    Module.prototype.getEdges = function (es) {
        var _this = this;
        this.outgoing.forAll(function (ms, edgetype) {
            ms.forAll(function (target) {
                es.push(new PowerEdge(_this.id, target.id, edgetype));
            });
        });
    };
    Module.prototype.isLeaf = function () {
        return this.children.count() === 0;
    };
    Module.prototype.isIsland = function () {
        return this.outgoing.count() === 0 && this.incoming.count() === 0;
    };
    Module.prototype.isPredefined = function () {
        return typeof this.definition !== "undefined";
    };
    return Module;
}());
exports.Module = Module;
function intersection(m, n) {
    var i = {};
    for (var v in m)
        if (v in n)
            i[v] = m[v];
    return i;
}
var ModuleSet = (function () {
    function ModuleSet() {
        this.table = {};
    }
    ModuleSet.prototype.count = function () {
        return Object.keys(this.table).length;
    };
    ModuleSet.prototype.intersection = function (other) {
        var result = new ModuleSet();
        result.table = intersection(this.table, other.table);
        return result;
    };
    ModuleSet.prototype.intersectionCount = function (other) {
        return this.intersection(other).count();
    };
    ModuleSet.prototype.contains = function (id) {
        return id in this.table;
    };
    ModuleSet.prototype.add = function (m) {
        this.table[m.id] = m;
    };
    ModuleSet.prototype.remove = function (m) {
        delete this.table[m.id];
    };
    ModuleSet.prototype.forAll = function (f) {
        for (var mid in this.table) {
            f(this.table[mid]);
        }
    };
    ModuleSet.prototype.modules = function () {
        var vs = [];
        this.forAll(function (m) {
            if (!m.isPredefined())
                vs.push(m);
        });
        return vs;
    };
    return ModuleSet;
}());
exports.ModuleSet = ModuleSet;
var LinkSets = (function () {
    function LinkSets() {
        this.sets = {};
        this.n = 0;
    }
    LinkSets.prototype.count = function () {
        return this.n;
    };
    LinkSets.prototype.contains = function (id) {
        var result = false;
        this.forAllModules(function (m) {
            if (!result && m.id == id) {
                result = true;
            }
        });
        return result;
    };
    LinkSets.prototype.add = function (linktype, m) {
        var s = linktype in this.sets ? this.sets[linktype] : this.sets[linktype] = new ModuleSet();
        s.add(m);
        ++this.n;
    };
    LinkSets.prototype.remove = function (linktype, m) {
        var ms = this.sets[linktype];
        ms.remove(m);
        if (ms.count() === 0) {
            delete this.sets[linktype];
        }
        --this.n;
    };
    LinkSets.prototype.forAll = function (f) {
        for (var linktype in this.sets) {
            f(this.sets[linktype], Number(linktype));
        }
    };
    LinkSets.prototype.forAllModules = function (f) {
        this.forAll(function (ms, lt) { return ms.forAll(f); });
    };
    LinkSets.prototype.intersection = function (other) {
        var result = new LinkSets();
        this.forAll(function (ms, lt) {
            if (lt in other.sets) {
                var i = ms.intersection(other.sets[lt]), n = i.count();
                if (n > 0) {
                    result.sets[lt] = i;
                    result.n += n;
                }
            }
        });
        return result;
    };
    return LinkSets;
}());
exports.LinkSets = LinkSets;
function intersectionCount(m, n) {
    return Object.keys(intersection(m, n)).length;
}
function getGroups(nodes, links, la, rootGroup) {
    var n = nodes.length, c = new Configuration(n, links, la, rootGroup);
    while (c.greedyMerge())
        ;
    var powerEdges = [];
    var g = c.getGroupHierarchy(powerEdges);
    powerEdges.forEach(function (e) {
        var f = function (end) {
            var g = e[end];
            if (typeof g == "number")
                e[end] = nodes[g];
        };
        f("source");
        f("target");
    });
    return { groups: g, powerEdges: powerEdges };
}
exports.getGroups = getGroups;

},{}],20:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var PairingHeap = (function () {
    function PairingHeap(elem) {
        this.elem = elem;
        this.subheaps = [];
    }
    PairingHeap.prototype.toString = function (selector) {
        var str = "", needComma = false;
        for (var i = 0; i < this.subheaps.length; ++i) {
            var subheap = this.subheaps[i];
            if (!subheap.elem) {
                needComma = false;
                continue;
            }
            if (needComma) {
                str = str + ",";
            }
            str = str + subheap.toString(selector);
            needComma = true;
        }
        if (str !== "") {
            str = "(" + str + ")";
        }
        return (this.elem ? selector(this.elem) : "") + str;
    };
    PairingHeap.prototype.forEach = function (f) {
        if (!this.empty()) {
            f(this.elem, this);
            this.subheaps.forEach(function (s) { return s.forEach(f); });
        }
    };
    PairingHeap.prototype.count = function () {
        return this.empty() ? 0 : 1 + this.subheaps.reduce(function (n, h) {
            return n + h.count();
        }, 0);
    };
    PairingHeap.prototype.min = function () {
        return this.elem;
    };
    PairingHeap.prototype.empty = function () {
        return this.elem == null;
    };
    PairingHeap.prototype.contains = function (h) {
        if (this === h)
            return true;
        for (var i = 0; i < this.subheaps.length; i++) {
            if (this.subheaps[i].contains(h))
                return true;
        }
        return false;
    };
    PairingHeap.prototype.isHeap = function (lessThan) {
        var _this = this;
        return this.subheaps.every(function (h) { return lessThan(_this.elem, h.elem) && h.isHeap(lessThan); });
    };
    PairingHeap.prototype.insert = function (obj, lessThan) {
        return this.merge(new PairingHeap(obj), lessThan);
    };
    PairingHeap.prototype.merge = function (heap2, lessThan) {
        if (this.empty())
            return heap2;
        else if (heap2.empty())
            return this;
        else if (lessThan(this.elem, heap2.elem)) {
            this.subheaps.push(heap2);
            return this;
        }
        else {
            heap2.subheaps.push(this);
            return heap2;
        }
    };
    PairingHeap.prototype.removeMin = function (lessThan) {
        if (this.empty())
            return null;
        else
            return this.mergePairs(lessThan);
    };
    PairingHeap.prototype.mergePairs = function (lessThan) {
        if (this.subheaps.length == 0)
            return new PairingHeap(null);
        else if (this.subheaps.length == 1) {
            return this.subheaps[0];
        }
        else {
            var firstPair = this.subheaps.pop().merge(this.subheaps.pop(), lessThan);
            var remaining = this.mergePairs(lessThan);
            return firstPair.merge(remaining, lessThan);
        }
    };
    PairingHeap.prototype.decreaseKey = function (subheap, newValue, setHeapNode, lessThan) {
        var newHeap = subheap.removeMin(lessThan);
        subheap.elem = newHeap.elem;
        subheap.subheaps = newHeap.subheaps;
        if (setHeapNode !== null && newHeap.elem !== null) {
            setHeapNode(subheap.elem, subheap);
        }
        var pairingNode = new PairingHeap(newValue);
        if (setHeapNode !== null) {
            setHeapNode(newValue, pairingNode);
        }
        return this.merge(pairingNode, lessThan);
    };
    return PairingHeap;
}());
exports.PairingHeap = PairingHeap;
var PriorityQueue = (function () {
    function PriorityQueue(lessThan) {
        this.lessThan = lessThan;
    }
    PriorityQueue.prototype.top = function () {
        if (this.empty()) {
            return null;
        }
        return this.root.elem;
    };
    PriorityQueue.prototype.push = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var pairingNode;
        for (var i = 0, arg; arg = args[i]; ++i) {
            pairingNode = new PairingHeap(arg);
            this.root = this.empty() ?
                pairingNode : this.root.merge(pairingNode, this.lessThan);
        }
        return pairingNode;
    };
    PriorityQueue.prototype.empty = function () {
        return !this.root || !this.root.elem;
    };
    PriorityQueue.prototype.isHeap = function () {
        return this.root.isHeap(this.lessThan);
    };
    PriorityQueue.prototype.forEach = function (f) {
        this.root.forEach(f);
    };
    PriorityQueue.prototype.pop = function () {
        if (this.empty()) {
            return null;
        }
        var obj = this.root.min();
        this.root = this.root.removeMin(this.lessThan);
        return obj;
    };
    PriorityQueue.prototype.reduceKey = function (heapNode, newKey, setHeapNode) {
        if (setHeapNode === void 0) { setHeapNode = null; }
        this.root = this.root.decreaseKey(heapNode, newKey, setHeapNode, this.lessThan);
    };
    PriorityQueue.prototype.toString = function (selector) {
        return this.root.toString(selector);
    };
    PriorityQueue.prototype.count = function () {
        return this.root.count();
    };
    return PriorityQueue;
}());
exports.PriorityQueue = PriorityQueue;

},{}],21:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var TreeBase = (function () {
    function TreeBase() {
        this.findIter = function (data) {
            var res = this._root;
            var iter = this.iterator();
            while (res !== null) {
                var c = this._comparator(data, res.data);
                if (c === 0) {
                    iter._cursor = res;
                    return iter;
                }
                else {
                    iter._ancestors.push(res);
                    res = res.get_child(c > 0);
                }
            }
            return null;
        };
    }
    TreeBase.prototype.clear = function () {
        this._root = null;
        this.size = 0;
    };
    ;
    TreeBase.prototype.find = function (data) {
        var res = this._root;
        while (res !== null) {
            var c = this._comparator(data, res.data);
            if (c === 0) {
                return res.data;
            }
            else {
                res = res.get_child(c > 0);
            }
        }
        return null;
    };
    ;
    TreeBase.prototype.lowerBound = function (data) {
        return this._bound(data, this._comparator);
    };
    ;
    TreeBase.prototype.upperBound = function (data) {
        var cmp = this._comparator;
        function reverse_cmp(a, b) {
            return cmp(b, a);
        }
        return this._bound(data, reverse_cmp);
    };
    ;
    TreeBase.prototype.min = function () {
        var res = this._root;
        if (res === null) {
            return null;
        }
        while (res.left !== null) {
            res = res.left;
        }
        return res.data;
    };
    ;
    TreeBase.prototype.max = function () {
        var res = this._root;
        if (res === null) {
            return null;
        }
        while (res.right !== null) {
            res = res.right;
        }
        return res.data;
    };
    ;
    TreeBase.prototype.iterator = function () {
        return new Iterator(this);
    };
    ;
    TreeBase.prototype.each = function (cb) {
        var it = this.iterator(), data;
        while ((data = it.next()) !== null) {
            cb(data);
        }
    };
    ;
    TreeBase.prototype.reach = function (cb) {
        var it = this.iterator(), data;
        while ((data = it.prev()) !== null) {
            cb(data);
        }
    };
    ;
    TreeBase.prototype._bound = function (data, cmp) {
        var cur = this._root;
        var iter = this.iterator();
        while (cur !== null) {
            var c = this._comparator(data, cur.data);
            if (c === 0) {
                iter._cursor = cur;
                return iter;
            }
            iter._ancestors.push(cur);
            cur = cur.get_child(c > 0);
        }
        for (var i = iter._ancestors.length - 1; i >= 0; --i) {
            cur = iter._ancestors[i];
            if (cmp(data, cur.data) > 0) {
                iter._cursor = cur;
                iter._ancestors.length = i;
                return iter;
            }
        }
        iter._ancestors.length = 0;
        return iter;
    };
    ;
    return TreeBase;
}());
exports.TreeBase = TreeBase;
var Iterator = (function () {
    function Iterator(tree) {
        this._tree = tree;
        this._ancestors = [];
        this._cursor = null;
    }
    Iterator.prototype.data = function () {
        return this._cursor !== null ? this._cursor.data : null;
    };
    ;
    Iterator.prototype.next = function () {
        if (this._cursor === null) {
            var root = this._tree._root;
            if (root !== null) {
                this._minNode(root);
            }
        }
        else {
            if (this._cursor.right === null) {
                var save;
                do {
                    save = this._cursor;
                    if (this._ancestors.length) {
                        this._cursor = this._ancestors.pop();
                    }
                    else {
                        this._cursor = null;
                        break;
                    }
                } while (this._cursor.right === save);
            }
            else {
                this._ancestors.push(this._cursor);
                this._minNode(this._cursor.right);
            }
        }
        return this._cursor !== null ? this._cursor.data : null;
    };
    ;
    Iterator.prototype.prev = function () {
        if (this._cursor === null) {
            var root = this._tree._root;
            if (root !== null) {
                this._maxNode(root);
            }
        }
        else {
            if (this._cursor.left === null) {
                var save;
                do {
                    save = this._cursor;
                    if (this._ancestors.length) {
                        this._cursor = this._ancestors.pop();
                    }
                    else {
                        this._cursor = null;
                        break;
                    }
                } while (this._cursor.left === save);
            }
            else {
                this._ancestors.push(this._cursor);
                this._maxNode(this._cursor.left);
            }
        }
        return this._cursor !== null ? this._cursor.data : null;
    };
    ;
    Iterator.prototype._minNode = function (start) {
        while (start.left !== null) {
            this._ancestors.push(start);
            start = start.left;
        }
        this._cursor = start;
    };
    ;
    Iterator.prototype._maxNode = function (start) {
        while (start.right !== null) {
            this._ancestors.push(start);
            start = start.right;
        }
        this._cursor = start;
    };
    ;
    return Iterator;
}());
exports.Iterator = Iterator;
var Node = (function () {
    function Node(data) {
        this.data = data;
        this.left = null;
        this.right = null;
        this.red = true;
    }
    Node.prototype.get_child = function (dir) {
        return dir ? this.right : this.left;
    };
    ;
    Node.prototype.set_child = function (dir, val) {
        if (dir) {
            this.right = val;
        }
        else {
            this.left = val;
        }
    };
    ;
    return Node;
}());
var RBTree = (function (_super) {
    __extends(RBTree, _super);
    function RBTree(comparator) {
        var _this = _super.call(this) || this;
        _this._root = null;
        _this._comparator = comparator;
        _this.size = 0;
        return _this;
    }
    RBTree.prototype.insert = function (data) {
        var ret = false;
        if (this._root === null) {
            this._root = new Node(data);
            ret = true;
            this.size++;
        }
        else {
            var head = new Node(undefined);
            var dir = false;
            var last = false;
            var gp = null;
            var ggp = head;
            var p = null;
            var node = this._root;
            ggp.right = this._root;
            while (true) {
                if (node === null) {
                    node = new Node(data);
                    p.set_child(dir, node);
                    ret = true;
                    this.size++;
                }
                else if (RBTree.is_red(node.left) && RBTree.is_red(node.right)) {
                    node.red = true;
                    node.left.red = false;
                    node.right.red = false;
                }
                if (RBTree.is_red(node) && RBTree.is_red(p)) {
                    var dir2 = ggp.right === gp;
                    if (node === p.get_child(last)) {
                        ggp.set_child(dir2, RBTree.single_rotate(gp, !last));
                    }
                    else {
                        ggp.set_child(dir2, RBTree.double_rotate(gp, !last));
                    }
                }
                var cmp = this._comparator(node.data, data);
                if (cmp === 0) {
                    break;
                }
                last = dir;
                dir = cmp < 0;
                if (gp !== null) {
                    ggp = gp;
                }
                gp = p;
                p = node;
                node = node.get_child(dir);
            }
            this._root = head.right;
        }
        this._root.red = false;
        return ret;
    };
    ;
    RBTree.prototype.remove = function (data) {
        if (this._root === null) {
            return false;
        }
        var head = new Node(undefined);
        var node = head;
        node.right = this._root;
        var p = null;
        var gp = null;
        var found = null;
        var dir = true;
        while (node.get_child(dir) !== null) {
            var last = dir;
            gp = p;
            p = node;
            node = node.get_child(dir);
            var cmp = this._comparator(data, node.data);
            dir = cmp > 0;
            if (cmp === 0) {
                found = node;
            }
            if (!RBTree.is_red(node) && !RBTree.is_red(node.get_child(dir))) {
                if (RBTree.is_red(node.get_child(!dir))) {
                    var sr = RBTree.single_rotate(node, dir);
                    p.set_child(last, sr);
                    p = sr;
                }
                else if (!RBTree.is_red(node.get_child(!dir))) {
                    var sibling = p.get_child(!last);
                    if (sibling !== null) {
                        if (!RBTree.is_red(sibling.get_child(!last)) && !RBTree.is_red(sibling.get_child(last))) {
                            p.red = false;
                            sibling.red = true;
                            node.red = true;
                        }
                        else {
                            var dir2 = gp.right === p;
                            if (RBTree.is_red(sibling.get_child(last))) {
                                gp.set_child(dir2, RBTree.double_rotate(p, last));
                            }
                            else if (RBTree.is_red(sibling.get_child(!last))) {
                                gp.set_child(dir2, RBTree.single_rotate(p, last));
                            }
                            var gpc = gp.get_child(dir2);
                            gpc.red = true;
                            node.red = true;
                            gpc.left.red = false;
                            gpc.right.red = false;
                        }
                    }
                }
            }
        }
        if (found !== null) {
            found.data = node.data;
            p.set_child(p.right === node, node.get_child(node.left === null));
            this.size--;
        }
        this._root = head.right;
        if (this._root !== null) {
            this._root.red = false;
        }
        return found !== null;
    };
    ;
    RBTree.is_red = function (node) {
        return node !== null && node.red;
    };
    RBTree.single_rotate = function (root, dir) {
        var save = root.get_child(!dir);
        root.set_child(!dir, save.get_child(dir));
        save.set_child(dir, root);
        root.red = true;
        save.red = false;
        return save;
    };
    RBTree.double_rotate = function (root, dir) {
        root.set_child(!dir, RBTree.single_rotate(root.get_child(!dir), !dir));
        return RBTree.single_rotate(root, dir);
    };
    return RBTree;
}(TreeBase));
exports.RBTree = RBTree;

},{}],22:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var vpsc_1 = require("./vpsc");
var rbtree_1 = require("./rbtree");
function computeGroupBounds(g) {
    g.bounds = typeof g.leaves !== "undefined" ?
        g.leaves.reduce(function (r, c) { return c.bounds.union(r); }, Rectangle.empty()) :
        Rectangle.empty();
    if (typeof g.groups !== "undefined")
        g.bounds = g.groups.reduce(function (r, c) { return computeGroupBounds(c).union(r); }, g.bounds);
    g.bounds = g.bounds.inflate(g.padding);
    return g.bounds;
}
exports.computeGroupBounds = computeGroupBounds;
var Rectangle = (function () {
    function Rectangle(x, X, y, Y) {
        this.x = x;
        this.X = X;
        this.y = y;
        this.Y = Y;
    }
    Rectangle.empty = function () { return new Rectangle(Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY); };
    Rectangle.prototype.cx = function () { return (this.x + this.X) / 2; };
    Rectangle.prototype.cy = function () { return (this.y + this.Y) / 2; };
    Rectangle.prototype.overlapX = function (r) {
        var ux = this.cx(), vx = r.cx();
        if (ux <= vx && r.x < this.X)
            return this.X - r.x;
        if (vx <= ux && this.x < r.X)
            return r.X - this.x;
        return 0;
    };
    Rectangle.prototype.overlapY = function (r) {
        var uy = this.cy(), vy = r.cy();
        if (uy <= vy && r.y < this.Y)
            return this.Y - r.y;
        if (vy <= uy && this.y < r.Y)
            return r.Y - this.y;
        return 0;
    };
    Rectangle.prototype.setXCentre = function (cx) {
        var dx = cx - this.cx();
        this.x += dx;
        this.X += dx;
    };
    Rectangle.prototype.setYCentre = function (cy) {
        var dy = cy - this.cy();
        this.y += dy;
        this.Y += dy;
    };
    Rectangle.prototype.width = function () {
        return this.X - this.x;
    };
    Rectangle.prototype.height = function () {
        return this.Y - this.y;
    };
    Rectangle.prototype.union = function (r) {
        return new Rectangle(Math.min(this.x, r.x), Math.max(this.X, r.X), Math.min(this.y, r.y), Math.max(this.Y, r.Y));
    };
    Rectangle.prototype.lineIntersections = function (x1, y1, x2, y2) {
        var sides = [[this.x, this.y, this.X, this.y],
            [this.X, this.y, this.X, this.Y],
            [this.X, this.Y, this.x, this.Y],
            [this.x, this.Y, this.x, this.y]];
        var intersections = [];
        for (var i = 0; i < 4; ++i) {
            var r = Rectangle.lineIntersection(x1, y1, x2, y2, sides[i][0], sides[i][1], sides[i][2], sides[i][3]);
            if (r !== null)
                intersections.push({ x: r.x, y: r.y });
        }
        return intersections;
    };
    Rectangle.prototype.rayIntersection = function (x2, y2) {
        var ints = this.lineIntersections(this.cx(), this.cy(), x2, y2);
        return ints.length > 0 ? ints[0] : null;
    };
    Rectangle.prototype.vertices = function () {
        return [
            { x: this.x, y: this.y },
            { x: this.X, y: this.y },
            { x: this.X, y: this.Y },
            { x: this.x, y: this.Y }
        ];
    };
    Rectangle.lineIntersection = function (x1, y1, x2, y2, x3, y3, x4, y4) {
        var dx12 = x2 - x1, dx34 = x4 - x3, dy12 = y2 - y1, dy34 = y4 - y3, denominator = dy34 * dx12 - dx34 * dy12;
        if (denominator == 0)
            return null;
        var dx31 = x1 - x3, dy31 = y1 - y3, numa = dx34 * dy31 - dy34 * dx31, a = numa / denominator, numb = dx12 * dy31 - dy12 * dx31, b = numb / denominator;
        if (a >= 0 && a <= 1 && b >= 0 && b <= 1) {
            return {
                x: x1 + a * dx12,
                y: y1 + a * dy12
            };
        }
        return null;
    };
    Rectangle.prototype.inflate = function (pad) {
        return new Rectangle(this.x - pad, this.X + pad, this.y - pad, this.Y + pad);
    };
    return Rectangle;
}());
exports.Rectangle = Rectangle;
function makeEdgeBetween(source, target, ah) {
    var si = source.rayIntersection(target.cx(), target.cy()) || { x: source.cx(), y: source.cy() }, ti = target.rayIntersection(source.cx(), source.cy()) || { x: target.cx(), y: target.cy() }, dx = ti.x - si.x, dy = ti.y - si.y, l = Math.sqrt(dx * dx + dy * dy), al = l - ah;
    return {
        sourceIntersection: si,
        targetIntersection: ti,
        arrowStart: { x: si.x + al * dx / l, y: si.y + al * dy / l }
    };
}
exports.makeEdgeBetween = makeEdgeBetween;
function makeEdgeTo(s, target, ah) {
    var ti = target.rayIntersection(s.x, s.y);
    if (!ti)
        ti = { x: target.cx(), y: target.cy() };
    var dx = ti.x - s.x, dy = ti.y - s.y, l = Math.sqrt(dx * dx + dy * dy);
    return { x: ti.x - ah * dx / l, y: ti.y - ah * dy / l };
}
exports.makeEdgeTo = makeEdgeTo;
var Node = (function () {
    function Node(v, r, pos) {
        this.v = v;
        this.r = r;
        this.pos = pos;
        this.prev = makeRBTree();
        this.next = makeRBTree();
    }
    return Node;
}());
var Event = (function () {
    function Event(isOpen, v, pos) {
        this.isOpen = isOpen;
        this.v = v;
        this.pos = pos;
    }
    return Event;
}());
function compareEvents(a, b) {
    if (a.pos > b.pos) {
        return 1;
    }
    if (a.pos < b.pos) {
        return -1;
    }
    if (a.isOpen) {
        return -1;
    }
    if (b.isOpen) {
        return 1;
    }
    return 0;
}
function makeRBTree() {
    return new rbtree_1.RBTree(function (a, b) { return a.pos - b.pos; });
}
var xRect = {
    getCentre: function (r) { return r.cx(); },
    getOpen: function (r) { return r.y; },
    getClose: function (r) { return r.Y; },
    getSize: function (r) { return r.width(); },
    makeRect: function (open, close, center, size) { return new Rectangle(center - size / 2, center + size / 2, open, close); },
    findNeighbours: findXNeighbours
};
var yRect = {
    getCentre: function (r) { return r.cy(); },
    getOpen: function (r) { return r.x; },
    getClose: function (r) { return r.X; },
    getSize: function (r) { return r.height(); },
    makeRect: function (open, close, center, size) { return new Rectangle(open, close, center - size / 2, center + size / 2); },
    findNeighbours: findYNeighbours
};
function generateGroupConstraints(root, f, minSep, isContained) {
    if (isContained === void 0) { isContained = false; }
    var padding = root.padding, gn = typeof root.groups !== 'undefined' ? root.groups.length : 0, ln = typeof root.leaves !== 'undefined' ? root.leaves.length : 0, childConstraints = !gn ? []
        : root.groups.reduce(function (ccs, g) { return ccs.concat(generateGroupConstraints(g, f, minSep, true)); }, []), n = (isContained ? 2 : 0) + ln + gn, vs = new Array(n), rs = new Array(n), i = 0, add = function (r, v) { rs[i] = r; vs[i++] = v; };
    if (isContained) {
        var b = root.bounds, c = f.getCentre(b), s = f.getSize(b) / 2, open = f.getOpen(b), close = f.getClose(b), min = c - s + padding / 2, max = c + s - padding / 2;
        root.minVar.desiredPosition = min;
        add(f.makeRect(open, close, min, padding), root.minVar);
        root.maxVar.desiredPosition = max;
        add(f.makeRect(open, close, max, padding), root.maxVar);
    }
    if (ln)
        root.leaves.forEach(function (l) { return add(l.bounds, l.variable); });
    if (gn)
        root.groups.forEach(function (g) {
            var b = g.bounds;
            add(f.makeRect(f.getOpen(b), f.getClose(b), f.getCentre(b), f.getSize(b)), g.minVar);
        });
    var cs = generateConstraints(rs, vs, f, minSep);
    if (gn) {
        vs.forEach(function (v) { v.cOut = [], v.cIn = []; });
        cs.forEach(function (c) { c.left.cOut.push(c), c.right.cIn.push(c); });
        root.groups.forEach(function (g) {
            var gapAdjustment = (g.padding - f.getSize(g.bounds)) / 2;
            g.minVar.cIn.forEach(function (c) { return c.gap += gapAdjustment; });
            g.minVar.cOut.forEach(function (c) { c.left = g.maxVar; c.gap += gapAdjustment; });
        });
    }
    return childConstraints.concat(cs);
}
function generateConstraints(rs, vars, rect, minSep) {
    var i, n = rs.length;
    var N = 2 * n;
    console.assert(vars.length >= n);
    var events = new Array(N);
    for (i = 0; i < n; ++i) {
        var r = rs[i];
        var v = new Node(vars[i], r, rect.getCentre(r));
        events[i] = new Event(true, v, rect.getOpen(r));
        events[i + n] = new Event(false, v, rect.getClose(r));
    }
    events.sort(compareEvents);
    var cs = new Array();
    var scanline = makeRBTree();
    for (i = 0; i < N; ++i) {
        var e = events[i];
        var v = e.v;
        if (e.isOpen) {
            scanline.insert(v);
            rect.findNeighbours(v, scanline);
        }
        else {
            scanline.remove(v);
            var makeConstraint = function (l, r) {
                var sep = (rect.getSize(l.r) + rect.getSize(r.r)) / 2 + minSep;
                cs.push(new vpsc_1.Constraint(l.v, r.v, sep));
            };
            var visitNeighbours = function (forward, reverse, mkcon) {
                var u, it = v[forward].iterator();
                while ((u = it[forward]()) !== null) {
                    mkcon(u, v);
                    u[reverse].remove(v);
                }
            };
            visitNeighbours("prev", "next", function (u, v) { return makeConstraint(u, v); });
            visitNeighbours("next", "prev", function (u, v) { return makeConstraint(v, u); });
        }
    }
    console.assert(scanline.size === 0);
    return cs;
}
function findXNeighbours(v, scanline) {
    var f = function (forward, reverse) {
        var it = scanline.findIter(v);
        var u;
        while ((u = it[forward]()) !== null) {
            var uovervX = u.r.overlapX(v.r);
            if (uovervX <= 0 || uovervX <= u.r.overlapY(v.r)) {
                v[forward].insert(u);
                u[reverse].insert(v);
            }
            if (uovervX <= 0) {
                break;
            }
        }
    };
    f("next", "prev");
    f("prev", "next");
}
function findYNeighbours(v, scanline) {
    var f = function (forward, reverse) {
        var u = scanline.findIter(v)[forward]();
        if (u !== null && u.r.overlapX(v.r) > 0) {
            v[forward].insert(u);
            u[reverse].insert(v);
        }
    };
    f("next", "prev");
    f("prev", "next");
}
function generateXConstraints(rs, vars) {
    return generateConstraints(rs, vars, xRect, 1e-6);
}
exports.generateXConstraints = generateXConstraints;
function generateYConstraints(rs, vars) {
    return generateConstraints(rs, vars, yRect, 1e-6);
}
exports.generateYConstraints = generateYConstraints;
function generateXGroupConstraints(root) {
    return generateGroupConstraints(root, xRect, 1e-6);
}
exports.generateXGroupConstraints = generateXGroupConstraints;
function generateYGroupConstraints(root) {
    return generateGroupConstraints(root, yRect, 1e-6);
}
exports.generateYGroupConstraints = generateYGroupConstraints;
function removeOverlaps(rs) {
    var vs = rs.map(function (r) { return new vpsc_1.Variable(r.cx()); });
    var cs = generateXConstraints(rs, vs);
    var solver = new vpsc_1.Solver(vs, cs);
    solver.solve();
    vs.forEach(function (v, i) { return rs[i].setXCentre(v.position()); });
    vs = rs.map(function (r) { return new vpsc_1.Variable(r.cy()); });
    cs = generateYConstraints(rs, vs);
    solver = new vpsc_1.Solver(vs, cs);
    solver.solve();
    vs.forEach(function (v, i) { return rs[i].setYCentre(v.position()); });
}
exports.removeOverlaps = removeOverlaps;
var IndexedVariable = (function (_super) {
    __extends(IndexedVariable, _super);
    function IndexedVariable(index, w) {
        var _this = _super.call(this, 0, w) || this;
        _this.index = index;
        return _this;
    }
    return IndexedVariable;
}(vpsc_1.Variable));
exports.IndexedVariable = IndexedVariable;
var Projection = (function () {
    function Projection(nodes, groups, rootGroup, constraints, avoidOverlaps) {
        if (rootGroup === void 0) { rootGroup = null; }
        if (constraints === void 0) { constraints = null; }
        if (avoidOverlaps === void 0) { avoidOverlaps = false; }
        var _this = this;
        this.nodes = nodes;
        this.groups = groups;
        this.rootGroup = rootGroup;
        this.avoidOverlaps = avoidOverlaps;
        this.variables = nodes.map(function (v, i) {
            return v.variable = new IndexedVariable(i, 1);
        });
        if (constraints)
            this.createConstraints(constraints);
        if (avoidOverlaps && rootGroup && typeof rootGroup.groups !== 'undefined') {
            nodes.forEach(function (v) {
                if (!v.width || !v.height) {
                    v.bounds = new Rectangle(v.x, v.x, v.y, v.y);
                    return;
                }
                var w2 = v.width / 2, h2 = v.height / 2;
                v.bounds = new Rectangle(v.x - w2, v.x + w2, v.y - h2, v.y + h2);
            });
            computeGroupBounds(rootGroup);
            var i = nodes.length;
            groups.forEach(function (g) {
                _this.variables[i] = g.minVar = new IndexedVariable(i++, typeof g.stiffness !== "undefined" ? g.stiffness : 0.01);
                _this.variables[i] = g.maxVar = new IndexedVariable(i++, typeof g.stiffness !== "undefined" ? g.stiffness : 0.01);
            });
        }
    }
    Projection.prototype.createSeparation = function (c) {
        return new vpsc_1.Constraint(this.nodes[c.left].variable, this.nodes[c.right].variable, c.gap, typeof c.equality !== "undefined" ? c.equality : false);
    };
    Projection.prototype.makeFeasible = function (c) {
        var _this = this;
        if (!this.avoidOverlaps)
            return;
        var axis = 'x', dim = 'width';
        if (c.axis === 'x')
            axis = 'y', dim = 'height';
        var vs = c.offsets.map(function (o) { return _this.nodes[o.node]; }).sort(function (a, b) { return a[axis] - b[axis]; });
        var p = null;
        vs.forEach(function (v) {
            if (p) {
                var nextPos = p[axis] + p[dim];
                if (nextPos > v[axis]) {
                    v[axis] = nextPos;
                }
            }
            p = v;
        });
    };
    Projection.prototype.createAlignment = function (c) {
        var _this = this;
        var u = this.nodes[c.offsets[0].node].variable;
        this.makeFeasible(c);
        var cs = c.axis === 'x' ? this.xConstraints : this.yConstraints;
        c.offsets.slice(1).forEach(function (o) {
            var v = _this.nodes[o.node].variable;
            cs.push(new vpsc_1.Constraint(u, v, o.offset, true));
        });
    };
    Projection.prototype.createConstraints = function (constraints) {
        var _this = this;
        var isSep = function (c) { return typeof c.type === 'undefined' || c.type === 'separation'; };
        this.xConstraints = constraints
            .filter(function (c) { return c.axis === "x" && isSep(c); })
            .map(function (c) { return _this.createSeparation(c); });
        this.yConstraints = constraints
            .filter(function (c) { return c.axis === "y" && isSep(c); })
            .map(function (c) { return _this.createSeparation(c); });
        constraints
            .filter(function (c) { return c.type === 'alignment'; })
            .forEach(function (c) { return _this.createAlignment(c); });
    };
    Projection.prototype.setupVariablesAndBounds = function (x0, y0, desired, getDesired) {
        this.nodes.forEach(function (v, i) {
            if (v.fixed) {
                v.variable.weight = v.fixedWeight ? v.fixedWeight : 1000;
                desired[i] = getDesired(v);
            }
            else {
                v.variable.weight = 1;
            }
            var w = (v.width || 0) / 2, h = (v.height || 0) / 2;
            var ix = x0[i], iy = y0[i];
            v.bounds = new Rectangle(ix - w, ix + w, iy - h, iy + h);
        });
    };
    Projection.prototype.xProject = function (x0, y0, x) {
        if (!this.rootGroup && !(this.avoidOverlaps || this.xConstraints))
            return;
        this.project(x0, y0, x0, x, function (v) { return v.px; }, this.xConstraints, generateXGroupConstraints, function (v) { return v.bounds.setXCentre(x[v.variable.index] = v.variable.position()); }, function (g) {
            var xmin = x[g.minVar.index] = g.minVar.position();
            var xmax = x[g.maxVar.index] = g.maxVar.position();
            var p2 = g.padding / 2;
            g.bounds.x = xmin - p2;
            g.bounds.X = xmax + p2;
        });
    };
    Projection.prototype.yProject = function (x0, y0, y) {
        if (!this.rootGroup && !this.yConstraints)
            return;
        this.project(x0, y0, y0, y, function (v) { return v.py; }, this.yConstraints, generateYGroupConstraints, function (v) { return v.bounds.setYCentre(y[v.variable.index] = v.variable.position()); }, function (g) {
            var ymin = y[g.minVar.index] = g.minVar.position();
            var ymax = y[g.maxVar.index] = g.maxVar.position();
            var p2 = g.padding / 2;
            g.bounds.y = ymin - p2;
            ;
            g.bounds.Y = ymax + p2;
        });
    };
    Projection.prototype.projectFunctions = function () {
        var _this = this;
        return [
            function (x0, y0, x) { return _this.xProject(x0, y0, x); },
            function (x0, y0, y) { return _this.yProject(x0, y0, y); }
        ];
    };
    Projection.prototype.project = function (x0, y0, start, desired, getDesired, cs, generateConstraints, updateNodeBounds, updateGroupBounds) {
        this.setupVariablesAndBounds(x0, y0, desired, getDesired);
        if (this.rootGroup && this.avoidOverlaps) {
            computeGroupBounds(this.rootGroup);
            cs = cs.concat(generateConstraints(this.rootGroup));
        }
        this.solve(this.variables, cs, start, desired);
        this.nodes.forEach(updateNodeBounds);
        if (this.rootGroup && this.avoidOverlaps) {
            this.groups.forEach(updateGroupBounds);
            computeGroupBounds(this.rootGroup);
        }
    };
    Projection.prototype.solve = function (vs, cs, starting, desired) {
        var solver = new vpsc_1.Solver(vs, cs);
        solver.setStartingPositions(starting);
        solver.setDesiredPositions(desired);
        solver.solve();
    };
    return Projection;
}());
exports.Projection = Projection;

},{"./rbtree":21,"./vpsc":24}],23:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var pqueue_1 = require("./pqueue");
var Neighbour = (function () {
    function Neighbour(id, distance) {
        this.id = id;
        this.distance = distance;
    }
    return Neighbour;
}());
var Node = (function () {
    function Node(id) {
        this.id = id;
        this.neighbours = [];
    }
    return Node;
}());
var QueueEntry = (function () {
    function QueueEntry(node, prev, d) {
        this.node = node;
        this.prev = prev;
        this.d = d;
    }
    return QueueEntry;
}());
var Calculator = (function () {
    function Calculator(n, es, getSourceIndex, getTargetIndex, getLength) {
        this.n = n;
        this.es = es;
        this.neighbours = new Array(this.n);
        var i = this.n;
        while (i--)
            this.neighbours[i] = new Node(i);
        i = this.es.length;
        while (i--) {
            var e = this.es[i];
            var u = getSourceIndex(e), v = getTargetIndex(e);
            var d = getLength(e);
            this.neighbours[u].neighbours.push(new Neighbour(v, d));
            this.neighbours[v].neighbours.push(new Neighbour(u, d));
        }
    }
    Calculator.prototype.DistanceMatrix = function () {
        var D = new Array(this.n);
        for (var i = 0; i < this.n; ++i) {
            D[i] = this.dijkstraNeighbours(i);
        }
        return D;
    };
    Calculator.prototype.DistancesFromNode = function (start) {
        return this.dijkstraNeighbours(start);
    };
    Calculator.prototype.PathFromNodeToNode = function (start, end) {
        return this.dijkstraNeighbours(start, end);
    };
    Calculator.prototype.PathFromNodeToNodeWithPrevCost = function (start, end, prevCost) {
        var q = new pqueue_1.PriorityQueue(function (a, b) { return a.d <= b.d; }), u = this.neighbours[start], qu = new QueueEntry(u, null, 0), visitedFrom = {};
        q.push(qu);
        while (!q.empty()) {
            qu = q.pop();
            u = qu.node;
            if (u.id === end) {
                break;
            }
            var i = u.neighbours.length;
            while (i--) {
                var neighbour = u.neighbours[i], v = this.neighbours[neighbour.id];
                if (qu.prev && v.id === qu.prev.node.id)
                    continue;
                var viduid = v.id + ',' + u.id;
                if (viduid in visitedFrom && visitedFrom[viduid] <= qu.d)
                    continue;
                var cc = qu.prev ? prevCost(qu.prev.node.id, u.id, v.id) : 0, t = qu.d + neighbour.distance + cc;
                visitedFrom[viduid] = t;
                q.push(new QueueEntry(v, qu, t));
            }
        }
        var path = [];
        while (qu.prev) {
            qu = qu.prev;
            path.push(qu.node.id);
        }
        return path;
    };
    Calculator.prototype.dijkstraNeighbours = function (start, dest) {
        if (dest === void 0) { dest = -1; }
        var q = new pqueue_1.PriorityQueue(function (a, b) { return a.d <= b.d; }), i = this.neighbours.length, d = new Array(i);
        while (i--) {
            var node = this.neighbours[i];
            node.d = i === start ? 0 : Number.POSITIVE_INFINITY;
            node.q = q.push(node);
        }
        while (!q.empty()) {
            var u = q.pop();
            d[u.id] = u.d;
            if (u.id === dest) {
                var path = [];
                var v = u;
                while (typeof v.prev !== 'undefined') {
                    path.push(v.prev.id);
                    v = v.prev;
                }
                return path;
            }
            i = u.neighbours.length;
            while (i--) {
                var neighbour = u.neighbours[i];
                var v = this.neighbours[neighbour.id];
                var t = u.d + neighbour.distance;
                if (u.d !== Number.MAX_VALUE && v.d > t) {
                    v.d = t;
                    v.prev = u;
                    q.reduceKey(v.q, v, function (e, q) { return e.q = q; });
                }
            }
        }
        return d;
    };
    return Calculator;
}());
exports.Calculator = Calculator;

},{"./pqueue":20}],24:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var PositionStats = (function () {
    function PositionStats(scale) {
        this.scale = scale;
        this.AB = 0;
        this.AD = 0;
        this.A2 = 0;
    }
    PositionStats.prototype.addVariable = function (v) {
        var ai = this.scale / v.scale;
        var bi = v.offset / v.scale;
        var wi = v.weight;
        this.AB += wi * ai * bi;
        this.AD += wi * ai * v.desiredPosition;
        this.A2 += wi * ai * ai;
    };
    PositionStats.prototype.getPosn = function () {
        return (this.AD - this.AB) / this.A2;
    };
    return PositionStats;
}());
exports.PositionStats = PositionStats;
var Constraint = (function () {
    function Constraint(left, right, gap, equality) {
        if (equality === void 0) { equality = false; }
        this.left = left;
        this.right = right;
        this.gap = gap;
        this.equality = equality;
        this.active = false;
        this.unsatisfiable = false;
        this.left = left;
        this.right = right;
        this.gap = gap;
        this.equality = equality;
    }
    Constraint.prototype.slack = function () {
        return this.unsatisfiable ? Number.MAX_VALUE
            : this.right.scale * this.right.position() - this.gap
                - this.left.scale * this.left.position();
    };
    return Constraint;
}());
exports.Constraint = Constraint;
var Variable = (function () {
    function Variable(desiredPosition, weight, scale) {
        if (weight === void 0) { weight = 1; }
        if (scale === void 0) { scale = 1; }
        this.desiredPosition = desiredPosition;
        this.weight = weight;
        this.scale = scale;
        this.offset = 0;
    }
    Variable.prototype.dfdv = function () {
        return 2.0 * this.weight * (this.position() - this.desiredPosition);
    };
    Variable.prototype.position = function () {
        return (this.block.ps.scale * this.block.posn + this.offset) / this.scale;
    };
    Variable.prototype.visitNeighbours = function (prev, f) {
        var ff = function (c, next) { return c.active && prev !== next && f(c, next); };
        this.cOut.forEach(function (c) { return ff(c, c.right); });
        this.cIn.forEach(function (c) { return ff(c, c.left); });
    };
    return Variable;
}());
exports.Variable = Variable;
var Block = (function () {
    function Block(v) {
        this.vars = [];
        v.offset = 0;
        this.ps = new PositionStats(v.scale);
        this.addVariable(v);
    }
    Block.prototype.addVariable = function (v) {
        v.block = this;
        this.vars.push(v);
        this.ps.addVariable(v);
        this.posn = this.ps.getPosn();
    };
    Block.prototype.updateWeightedPosition = function () {
        this.ps.AB = this.ps.AD = this.ps.A2 = 0;
        for (var i = 0, n = this.vars.length; i < n; ++i)
            this.ps.addVariable(this.vars[i]);
        this.posn = this.ps.getPosn();
    };
    Block.prototype.compute_lm = function (v, u, postAction) {
        var _this = this;
        var dfdv = v.dfdv();
        v.visitNeighbours(u, function (c, next) {
            var _dfdv = _this.compute_lm(next, v, postAction);
            if (next === c.right) {
                dfdv += _dfdv * c.left.scale;
                c.lm = _dfdv;
            }
            else {
                dfdv += _dfdv * c.right.scale;
                c.lm = -_dfdv;
            }
            postAction(c);
        });
        return dfdv / v.scale;
    };
    Block.prototype.populateSplitBlock = function (v, prev) {
        var _this = this;
        v.visitNeighbours(prev, function (c, next) {
            next.offset = v.offset + (next === c.right ? c.gap : -c.gap);
            _this.addVariable(next);
            _this.populateSplitBlock(next, v);
        });
    };
    Block.prototype.traverse = function (visit, acc, v, prev) {
        var _this = this;
        if (v === void 0) { v = this.vars[0]; }
        if (prev === void 0) { prev = null; }
        v.visitNeighbours(prev, function (c, next) {
            acc.push(visit(c));
            _this.traverse(visit, acc, next, v);
        });
    };
    Block.prototype.findMinLM = function () {
        var m = null;
        this.compute_lm(this.vars[0], null, function (c) {
            if (!c.equality && (m === null || c.lm < m.lm))
                m = c;
        });
        return m;
    };
    Block.prototype.findMinLMBetween = function (lv, rv) {
        this.compute_lm(lv, null, function () { });
        var m = null;
        this.findPath(lv, null, rv, function (c, next) {
            if (!c.equality && c.right === next && (m === null || c.lm < m.lm))
                m = c;
        });
        return m;
    };
    Block.prototype.findPath = function (v, prev, to, visit) {
        var _this = this;
        var endFound = false;
        v.visitNeighbours(prev, function (c, next) {
            if (!endFound && (next === to || _this.findPath(next, v, to, visit))) {
                endFound = true;
                visit(c, next);
            }
        });
        return endFound;
    };
    Block.prototype.isActiveDirectedPathBetween = function (u, v) {
        if (u === v)
            return true;
        var i = u.cOut.length;
        while (i--) {
            var c = u.cOut[i];
            if (c.active && this.isActiveDirectedPathBetween(c.right, v))
                return true;
        }
        return false;
    };
    Block.split = function (c) {
        c.active = false;
        return [Block.createSplitBlock(c.left), Block.createSplitBlock(c.right)];
    };
    Block.createSplitBlock = function (startVar) {
        var b = new Block(startVar);
        b.populateSplitBlock(startVar, null);
        return b;
    };
    Block.prototype.splitBetween = function (vl, vr) {
        var c = this.findMinLMBetween(vl, vr);
        if (c !== null) {
            var bs = Block.split(c);
            return { constraint: c, lb: bs[0], rb: bs[1] };
        }
        return null;
    };
    Block.prototype.mergeAcross = function (b, c, dist) {
        c.active = true;
        for (var i = 0, n = b.vars.length; i < n; ++i) {
            var v = b.vars[i];
            v.offset += dist;
            this.addVariable(v);
        }
        this.posn = this.ps.getPosn();
    };
    Block.prototype.cost = function () {
        var sum = 0, i = this.vars.length;
        while (i--) {
            var v = this.vars[i], d = v.position() - v.desiredPosition;
            sum += d * d * v.weight;
        }
        return sum;
    };
    return Block;
}());
exports.Block = Block;
var Blocks = (function () {
    function Blocks(vs) {
        this.vs = vs;
        var n = vs.length;
        this.list = new Array(n);
        while (n--) {
            var b = new Block(vs[n]);
            this.list[n] = b;
            b.blockInd = n;
        }
    }
    Blocks.prototype.cost = function () {
        var sum = 0, i = this.list.length;
        while (i--)
            sum += this.list[i].cost();
        return sum;
    };
    Blocks.prototype.insert = function (b) {
        b.blockInd = this.list.length;
        this.list.push(b);
    };
    Blocks.prototype.remove = function (b) {
        var last = this.list.length - 1;
        var swapBlock = this.list[last];
        this.list.length = last;
        if (b !== swapBlock) {
            this.list[b.blockInd] = swapBlock;
            swapBlock.blockInd = b.blockInd;
        }
    };
    Blocks.prototype.merge = function (c) {
        var l = c.left.block, r = c.right.block;
        var dist = c.right.offset - c.left.offset - c.gap;
        if (l.vars.length < r.vars.length) {
            r.mergeAcross(l, c, dist);
            this.remove(l);
        }
        else {
            l.mergeAcross(r, c, -dist);
            this.remove(r);
        }
    };
    Blocks.prototype.forEach = function (f) {
        this.list.forEach(f);
    };
    Blocks.prototype.updateBlockPositions = function () {
        this.list.forEach(function (b) { return b.updateWeightedPosition(); });
    };
    Blocks.prototype.split = function (inactive) {
        var _this = this;
        this.updateBlockPositions();
        this.list.forEach(function (b) {
            var v = b.findMinLM();
            if (v !== null && v.lm < Solver.LAGRANGIAN_TOLERANCE) {
                b = v.left.block;
                Block.split(v).forEach(function (nb) { return _this.insert(nb); });
                _this.remove(b);
                inactive.push(v);
            }
        });
    };
    return Blocks;
}());
exports.Blocks = Blocks;
var Solver = (function () {
    function Solver(vs, cs) {
        this.vs = vs;
        this.cs = cs;
        this.vs = vs;
        vs.forEach(function (v) {
            v.cIn = [], v.cOut = [];
        });
        this.cs = cs;
        cs.forEach(function (c) {
            c.left.cOut.push(c);
            c.right.cIn.push(c);
        });
        this.inactive = cs.map(function (c) { c.active = false; return c; });
        this.bs = null;
    }
    Solver.prototype.cost = function () {
        return this.bs.cost();
    };
    Solver.prototype.setStartingPositions = function (ps) {
        this.inactive = this.cs.map(function (c) { c.active = false; return c; });
        this.bs = new Blocks(this.vs);
        this.bs.forEach(function (b, i) { return b.posn = ps[i]; });
    };
    Solver.prototype.setDesiredPositions = function (ps) {
        this.vs.forEach(function (v, i) { return v.desiredPosition = ps[i]; });
    };
    Solver.prototype.mostViolated = function () {
        var minSlack = Number.MAX_VALUE, v = null, l = this.inactive, n = l.length, deletePoint = n;
        for (var i = 0; i < n; ++i) {
            var c = l[i];
            if (c.unsatisfiable)
                continue;
            var slack = c.slack();
            if (c.equality || slack < minSlack) {
                minSlack = slack;
                v = c;
                deletePoint = i;
                if (c.equality)
                    break;
            }
        }
        if (deletePoint !== n &&
            (minSlack < Solver.ZERO_UPPERBOUND && !v.active || v.equality)) {
            l[deletePoint] = l[n - 1];
            l.length = n - 1;
        }
        return v;
    };
    Solver.prototype.satisfy = function () {
        if (this.bs == null) {
            this.bs = new Blocks(this.vs);
        }
        this.bs.split(this.inactive);
        var v = null;
        while ((v = this.mostViolated()) && (v.equality || v.slack() < Solver.ZERO_UPPERBOUND && !v.active)) {
            var lb = v.left.block, rb = v.right.block;
            if (lb !== rb) {
                this.bs.merge(v);
            }
            else {
                if (lb.isActiveDirectedPathBetween(v.right, v.left)) {
                    v.unsatisfiable = true;
                    continue;
                }
                var split = lb.splitBetween(v.left, v.right);
                if (split !== null) {
                    this.bs.insert(split.lb);
                    this.bs.insert(split.rb);
                    this.bs.remove(lb);
                    this.inactive.push(split.constraint);
                }
                else {
                    v.unsatisfiable = true;
                    continue;
                }
                if (v.slack() >= 0) {
                    this.inactive.push(v);
                }
                else {
                    this.bs.merge(v);
                }
            }
        }
    };
    Solver.prototype.solve = function () {
        this.satisfy();
        var lastcost = Number.MAX_VALUE, cost = this.bs.cost();
        while (Math.abs(lastcost - cost) > 0.0001) {
            this.satisfy();
            lastcost = cost;
            cost = this.bs.cost();
        }
        return cost;
    };
    Solver.LAGRANGIAN_TOLERANCE = -1e-4;
    Solver.ZERO_UPPERBOUND = -1e-10;
    return Solver;
}());
exports.Solver = Solver;
function removeOverlapInOneDimension(spans, lowerBound, upperBound) {
    var vs = spans.map(function (s) { return new Variable(s.desiredCenter); });
    var cs = [];
    var n = spans.length;
    for (var i = 0; i < n - 1; i++) {
        var left = spans[i], right = spans[i + 1];
        cs.push(new Constraint(vs[i], vs[i + 1], (left.size + right.size) / 2));
    }
    var leftMost = vs[0], rightMost = vs[n - 1], leftMostSize = spans[0].size / 2, rightMostSize = spans[n - 1].size / 2;
    var vLower = null, vUpper = null;
    if (lowerBound) {
        vLower = new Variable(lowerBound, leftMost.weight * 1000);
        vs.push(vLower);
        cs.push(new Constraint(vLower, leftMost, leftMostSize));
    }
    if (upperBound) {
        vUpper = new Variable(upperBound, rightMost.weight * 1000);
        vs.push(vUpper);
        cs.push(new Constraint(rightMost, vUpper, rightMostSize));
    }
    var solver = new Solver(vs, cs);
    solver.solve();
    return {
        newCenters: vs.slice(0, spans.length).map(function (v) { return v.position(); }),
        lowerBound: vLower ? vLower.position() : leftMost.position() - leftMostSize,
        upperBound: vUpper ? vUpper.position() : rightMost.position() + rightMostSize
    };
}
exports.removeOverlapInOneDimension = removeOverlapInOneDimension;

},{}],25:[function(require,module,exports){
(function(self) {
  'use strict';

  if (self.fetch) {
    return
  }

  var support = {
    searchParams: 'URLSearchParams' in self,
    iterable: 'Symbol' in self && 'iterator' in Symbol,
    blob: 'FileReader' in self && 'Blob' in self && (function() {
      try {
        new Blob()
        return true
      } catch(e) {
        return false
      }
    })(),
    formData: 'FormData' in self,
    arrayBuffer: 'ArrayBuffer' in self
  }

  if (support.arrayBuffer) {
    var viewClasses = [
      '[object Int8Array]',
      '[object Uint8Array]',
      '[object Uint8ClampedArray]',
      '[object Int16Array]',
      '[object Uint16Array]',
      '[object Int32Array]',
      '[object Uint32Array]',
      '[object Float32Array]',
      '[object Float64Array]'
    ]

    var isDataView = function(obj) {
      return obj && DataView.prototype.isPrototypeOf(obj)
    }

    var isArrayBufferView = ArrayBuffer.isView || function(obj) {
      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
    }
  }

  function normalizeName(name) {
    if (typeof name !== 'string') {
      name = String(name)
    }
    if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
      throw new TypeError('Invalid character in header field name')
    }
    return name.toLowerCase()
  }

  function normalizeValue(value) {
    if (typeof value !== 'string') {
      value = String(value)
    }
    return value
  }

  // Build a destructive iterator for the value list
  function iteratorFor(items) {
    var iterator = {
      next: function() {
        var value = items.shift()
        return {done: value === undefined, value: value}
      }
    }

    if (support.iterable) {
      iterator[Symbol.iterator] = function() {
        return iterator
      }
    }

    return iterator
  }

  function Headers(headers) {
    this.map = {}

    if (headers instanceof Headers) {
      headers.forEach(function(value, name) {
        this.append(name, value)
      }, this)

    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function(name) {
        this.append(name, headers[name])
      }, this)
    }
  }

  Headers.prototype.append = function(name, value) {
    name = normalizeName(name)
    value = normalizeValue(value)
    var list = this.map[name]
    if (!list) {
      list = []
      this.map[name] = list
    }
    list.push(value)
  }

  Headers.prototype['delete'] = function(name) {
    delete this.map[normalizeName(name)]
  }

  Headers.prototype.get = function(name) {
    var values = this.map[normalizeName(name)]
    return values ? values[0] : null
  }

  Headers.prototype.getAll = function(name) {
    return this.map[normalizeName(name)] || []
  }

  Headers.prototype.has = function(name) {
    return this.map.hasOwnProperty(normalizeName(name))
  }

  Headers.prototype.set = function(name, value) {
    this.map[normalizeName(name)] = [normalizeValue(value)]
  }

  Headers.prototype.forEach = function(callback, thisArg) {
    Object.getOwnPropertyNames(this.map).forEach(function(name) {
      this.map[name].forEach(function(value) {
        callback.call(thisArg, value, name, this)
      }, this)
    }, this)
  }

  Headers.prototype.keys = function() {
    var items = []
    this.forEach(function(value, name) { items.push(name) })
    return iteratorFor(items)
  }

  Headers.prototype.values = function() {
    var items = []
    this.forEach(function(value) { items.push(value) })
    return iteratorFor(items)
  }

  Headers.prototype.entries = function() {
    var items = []
    this.forEach(function(value, name) { items.push([name, value]) })
    return iteratorFor(items)
  }

  if (support.iterable) {
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries
  }

  function consumed(body) {
    if (body.bodyUsed) {
      return Promise.reject(new TypeError('Already read'))
    }
    body.bodyUsed = true
  }

  function fileReaderReady(reader) {
    return new Promise(function(resolve, reject) {
      reader.onload = function() {
        resolve(reader.result)
      }
      reader.onerror = function() {
        reject(reader.error)
      }
    })
  }

  function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader()
    var promise = fileReaderReady(reader)
    reader.readAsArrayBuffer(blob)
    return promise
  }

  function readBlobAsText(blob) {
    var reader = new FileReader()
    var promise = fileReaderReady(reader)
    reader.readAsText(blob)
    return promise
  }

  function readArrayBufferAsText(buf) {
    var view = new Uint8Array(buf)
    var chars = new Array(view.length)

    for (var i = 0; i < view.length; i++) {
      chars[i] = String.fromCharCode(view[i])
    }
    return chars.join('')
  }

  function bufferClone(buf) {
    if (buf.slice) {
      return buf.slice(0)
    } else {
      var view = new Uint8Array(buf.byteLength)
      view.set(new Uint8Array(buf))
      return view.buffer
    }
  }

  function Body() {
    this.bodyUsed = false

    this._initBody = function(body) {
      this._bodyInit = body
      if (!body) {
        this._bodyText = ''
      } else if (typeof body === 'string') {
        this._bodyText = body
      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
        this._bodyBlob = body
      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
        this._bodyFormData = body
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this._bodyText = body.toString()
      } else if (support.arrayBuffer && support.blob && isDataView(body)) {
        this._bodyArrayBuffer = bufferClone(body.buffer)
        // IE 10-11 can't handle a DataView body.
        this._bodyInit = new Blob([this._bodyArrayBuffer])
      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
        this._bodyArrayBuffer = bufferClone(body)
      } else {
        throw new Error('unsupported BodyInit type')
      }

      if (!this.headers.get('content-type')) {
        if (typeof body === 'string') {
          this.headers.set('content-type', 'text/plain;charset=UTF-8')
        } else if (this._bodyBlob && this._bodyBlob.type) {
          this.headers.set('content-type', this._bodyBlob.type)
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')
        }
      }
    }

    if (support.blob) {
      this.blob = function() {
        var rejected = consumed(this)
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return Promise.resolve(this._bodyBlob)
        } else if (this._bodyArrayBuffer) {
          return Promise.resolve(new Blob([this._bodyArrayBuffer]))
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as blob')
        } else {
          return Promise.resolve(new Blob([this._bodyText]))
        }
      }

      this.arrayBuffer = function() {
        if (this._bodyArrayBuffer) {
          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
        } else {
          return this.blob().then(readBlobAsArrayBuffer)
        }
      }
    }

    this.text = function() {
      var rejected = consumed(this)
      if (rejected) {
        return rejected
      }

      if (this._bodyBlob) {
        return readBlobAsText(this._bodyBlob)
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as text')
      } else {
        return Promise.resolve(this._bodyText)
      }
    }

    if (support.formData) {
      this.formData = function() {
        return this.text().then(decode)
      }
    }

    this.json = function() {
      return this.text().then(JSON.parse)
    }

    return this
  }

  // HTTP methods whose capitalization should be normalized
  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']

  function normalizeMethod(method) {
    var upcased = method.toUpperCase()
    return (methods.indexOf(upcased) > -1) ? upcased : method
  }

  function Request(input, options) {
    options = options || {}
    var body = options.body

    if (typeof input === 'string') {
      this.url = input
    } else {
      if (input.bodyUsed) {
        throw new TypeError('Already read')
      }
      this.url = input.url
      this.credentials = input.credentials
      if (!options.headers) {
        this.headers = new Headers(input.headers)
      }
      this.method = input.method
      this.mode = input.mode
      if (!body && input._bodyInit != null) {
        body = input._bodyInit
        input.bodyUsed = true
      }
    }

    this.credentials = options.credentials || this.credentials || 'omit'
    if (options.headers || !this.headers) {
      this.headers = new Headers(options.headers)
    }
    this.method = normalizeMethod(options.method || this.method || 'GET')
    this.mode = options.mode || this.mode || null
    this.referrer = null

    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
      throw new TypeError('Body not allowed for GET or HEAD requests')
    }
    this._initBody(body)
  }

  Request.prototype.clone = function() {
    return new Request(this, { body: this._bodyInit })
  }

  function decode(body) {
    var form = new FormData()
    body.trim().split('&').forEach(function(bytes) {
      if (bytes) {
        var split = bytes.split('=')
        var name = split.shift().replace(/\+/g, ' ')
        var value = split.join('=').replace(/\+/g, ' ')
        form.append(decodeURIComponent(name), decodeURIComponent(value))
      }
    })
    return form
  }

  function parseHeaders(rawHeaders) {
    var headers = new Headers()
    rawHeaders.split('\r\n').forEach(function(line) {
      var parts = line.split(':')
      var key = parts.shift().trim()
      if (key) {
        var value = parts.join(':').trim()
        headers.append(key, value)
      }
    })
    return headers
  }

  Body.call(Request.prototype)

  function Response(bodyInit, options) {
    if (!options) {
      options = {}
    }

    this.type = 'default'
    this.status = 'status' in options ? options.status : 200
    this.ok = this.status >= 200 && this.status < 300
    this.statusText = 'statusText' in options ? options.statusText : 'OK'
    this.headers = new Headers(options.headers)
    this.url = options.url || ''
    this._initBody(bodyInit)
  }

  Body.call(Response.prototype)

  Response.prototype.clone = function() {
    return new Response(this._bodyInit, {
      status: this.status,
      statusText: this.statusText,
      headers: new Headers(this.headers),
      url: this.url
    })
  }

  Response.error = function() {
    var response = new Response(null, {status: 0, statusText: ''})
    response.type = 'error'
    return response
  }

  var redirectStatuses = [301, 302, 303, 307, 308]

  Response.redirect = function(url, status) {
    if (redirectStatuses.indexOf(status) === -1) {
      throw new RangeError('Invalid status code')
    }

    return new Response(null, {status: status, headers: {location: url}})
  }

  self.Headers = Headers
  self.Request = Request
  self.Response = Response

  self.fetch = function(input, init) {
    return new Promise(function(resolve, reject) {
      var request = new Request(input, init)
      var xhr = new XMLHttpRequest()

      xhr.onload = function() {
        var options = {
          status: xhr.status,
          statusText: xhr.statusText,
          headers: parseHeaders(xhr.getAllResponseHeaders() || '')
        }
        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')
        var body = 'response' in xhr ? xhr.response : xhr.responseText
        resolve(new Response(body, options))
      }

      xhr.onerror = function() {
        reject(new TypeError('Network request failed'))
      }

      xhr.ontimeout = function() {
        reject(new TypeError('Network request failed'))
      }

      xhr.open(request.method, request.url, true)

      if (request.credentials === 'include') {
        xhr.withCredentials = true
      }

      if ('responseType' in xhr && support.blob) {
        xhr.responseType = 'blob'
      }

      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value)
      })

      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)
    })
  }
  self.fetch.polyfill = true
})(typeof self !== 'undefined' ? self : this);

},{}],26:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var UNKNOW_IMAGE = exports.UNKNOW_IMAGE = 'data:image/png;base64,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';
var LINK_OPTIONS = exports.LINK_OPTIONS = 'data:image/png;base64,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';
var FEED_PIPE = exports.FEED_PIPE = 'data:image/png;base64,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';

},{}],27:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DataContainer = DataContainer;
exports.GroupOfZones = GroupOfZones;
exports.NodesZone = NodesZone;
/**
 * Maps is the set of the map functions
 * @typedef {Object} Maps
 * @property {[id: string]: Node} nodeMap - map id to [Node]{@link Node} - Returns Node by id and (optional) role.
 * @property {[id: string]: Link} linkMap - map id to  [Link]{@link Link} - Returns Link by id and (optional) role.
 * @property {[id: string]: Link} sourceMap - map id to  [Link]{@link Link}[] - Returns all incoming links for the node with specified id (filters by role).
 * @property {[id: string]: Link} targetMap - map id to  [Link]{@link Link}[] - Returns all outgoing links for the node with specified id (filters by role).
*/

/**
 * End elements of the graph, which were created from {@link ServerData}.
 * @typedef {Object} GraphData
 * @property {Link[]} links - List of Links of the graph
 * @property {Node[]} nodes - List of Nodes of the graph
*/

/**
 * @private
 * DataContainer - an object which is a data model of the LinegeGram. It stores and orginizes
 * data for the views and also provides set of maps (dictionaries) for links and nodes of the graph.
 * You can get this model using a LineaGram method which is called 'getGraphModel'.
 * DataContainer implements separation and filtration mechanisms, in other words,
 * you can return different data for different roles.
 * @class
 * @param {GraphData} data - Raw data - models for links and nodes of the graph.
 * @param {Parameters} parameters - Parameters set
 * 
 * @property {Maps} maps - Set of the map functions
 */
function DataContainer(data, parameters) {
    var self = this;

    if (!data) data = {};
    if (!data.nodes) data.nodes = [];
    if (!data.links) data.links = [];

    self.nodes = data.nodes;
    self.links = data.links;
    self.maps = { sourceMap: {}, targetMap: {}, nodeMap: {}, linkMap: {}, idMap: {} };
    self.zones = [];

    var _zoneSize = parameters.dataZoneSize;
    var _elementSize = parameters.elementSize;
    var _zonesInGroup = parameters.zonesInGroup;

    // If some node dont hit any real zone it will hit this one.
    var _fakeZone = new NodesZone(null, {
        x: 0,
        y: 0,
        width: 0,
        height: 0,
        elementSize: 0,
        fakeZone: true
    });
    if (_elementSize.width >= _zoneSize.width || _elementSize.height >= _zoneSize.height) {
        _zoneSize.width = _elementSize.width * 20;
        _zoneSize.height = _elementSize.height * 20;
    }

    /**
     * Returns nodes and links which are lie near the point
     * @param {Point[]} points - Array of points
     * @return {GraphData} - Nodes and Links
     * @memberof DataContainer
     * @method
    */
    self.getElementsNearThePoints = function (points) {
        var suitableZones = _zonesForPoints(points);
        var resultNodes = [];
        var resultLinks = [];

        suitableZones.forEach(function (z) {
            z.relatedNodes.forEach(function (n) {
                if (resultNodes.indexOf(n) === -1) {
                    resultNodes.push(n);
                }
            });
            z.nodes.forEach(function (n) {
                if (resultNodes.indexOf(n) === -1) {
                    resultNodes.push(n);
                }
            });
            z.links.forEach(function (l) {
                if (resultLinks.indexOf(l) === -1) {
                    resultLinks.push(l);
                }
            });
        });

        return {
            nodes: resultNodes,
            links: resultLinks
        };
    };

    /**
     * Rectangle
     * @typedef {Object} Rectangle
     * @property {number} x - Position by x axis
     * @property {number} y - Position by y axis
     * @property {number} width - Width of the rectangle
     * @property {number} height - Height of the rectangle
    */

    /**
     * Returns nodes and links which are lie into the rectangle
     * @param {Rectangle} rect - Hit rectangle
     * @return {GraphData} - Nodes and Links
     * @memberof DataContainer
     * @method
    */
    self.getElementsForRectangle = function (rect) {

        if (!rect) return { nodes: [], links: [] };
        var points = [];
        if (rect.width <= _zoneSize.width && rect.height <= _zoneSize.height) {
            points.push({ x: rect.x, y: rect.y });
            points.push({ x: rect.x + rect.width, y: rect.y });
            points.push({ x: rect.x, y: rect.y + rect.height });
            points.push({ x: rect.x + rect.width, y: rect.y + rect.height });
        } else {
            for (var x = rect.x;; x += _zoneSize.width) {
                for (var y = rect.y;; y += _zoneSize.height) {
                    points.push({
                        x: Math.min(x, rect.x + rect.width),
                        y: Math.min(y, rect.y + rect.height)
                    });
                    if (y >= rect.y + rect.height) break;
                }
                if (x >= rect.x + rect.width) break;
            }
        }
        return self.getElementsNearThePoints(points);
    };

    /**
     * Returns nodes related with the target node
     * @param {Node} node - target node
     * @return {Node[]}
     * @memberof DataContainer
     * @method
    */
    self.getRelatedNodes = function (node) {
        var neighbors = [];
        if (self.maps.targetMap[node.id]) {
            self.maps.targetMap[node.id].forEach(function (l) {
                return neighbors.push(self.maps.nodeMap[l.model.target]);
            });
        }
        if (self.maps.sourceMap[node.id]) {
            self.maps.sourceMap[node.id].forEach(function (l) {
                return neighbors.push(self.maps.nodeMap[l.model.source]);
            });
        }
        return neighbors;
    };

    /**
     * Refreshes container. It means that all maps will
     * be updated and nodes in the container will be organized.
     * @param {Node} node - Target node (optional)
     * @memberof DataContainer
     * @method
    */
    self.refresh = function (newData) {
        if (newData) {
            if (newData.nodes) {
                self.nodes = newData.nodes;
            }
            if (newData.links) {
                self.links = newData.links;
            }
        }
        _refreshMaps();
        _refreshGrid();
    };

    /**
     * Moves node from one zone to another.
     * We are using it when node is dragged to somewhere on the paper
     * @param {Node} node - target node
     * @param {Point} oldPos - previous position of the target node
     * @memberof DataContainer
     * @method
    */
    self.updateZonesForNode = function (node, oldPos) {
        var curPos = node.model.position;
        var oldZones = _zonesForPoints([oldPos]);

        oldZones.forEach(function (zone) {
            var newNodes = zone.nodes.filter(function (n) {
                return n !== node;
            });
            _clearZone(zone);
            _fillZone(zone, newNodes);
        });

        var newZones = _zonesForPoints([curPos]);
        if (newZones) {
            newZones.forEach(function (z) {
                _fillZone(z, [node]);
            });
        } else {
            _fillZone(_fakeZone, [node]);
        }
    };

    /**
     * Returns all zones which contain obtained points.
     * @private
     * @param {Point[]} points
     * @return {NodesZone[]}
    */
    function _zonesForPoints(points) {
        points = points || [];
        var suitableZones = [];

        function recursion(p, zones) {
            zones.forEach(function (z) {
                if (z.hitTest(p)) {
                    if (z instanceof GroupOfZones) {
                        recursion(p, z.zones);
                    } else if (suitableZones.indexOf(z) === -1) {
                        suitableZones.push(z);
                    }
                }
            });
        }
        points.forEach(function (p) {
            recursion(p, self.zones);
        });
        suitableZones.push(_fakeZone);

        return suitableZones;
    }

    /**
     * Calculates zones tree.
     * @private
    */
    function _refreshGrid() {
        var minX = undefined,
            minY = undefined,
            maxX = undefined,
            maxY = undefined;

        self.nodes.forEach(function (node) {
            var pos = node.model.position;
            minX = minX === undefined ? pos.x : Math.min(minX, pos.x);
            minY = minY === undefined ? pos.y : Math.min(minY, pos.y);
            maxX = maxX === undefined ? pos.x : Math.max(maxX, pos.x);
            maxY = maxY === undefined ? pos.y : Math.max(maxY, pos.y);
        });

        var zones = [];
        var nodes = [].concat(self.nodes);
        for (var x = minX, i = 0; x <= maxX; x += _zoneSize.width - _elementSize.width, i++) {
            zones[i] = [];
            for (var y = minY, j = 0; y <= maxY; y += _zoneSize.height - _elementSize.height, j++) {
                var newZone = new NodesZone(null, {
                    x: x,
                    y: y,
                    width: _zoneSize.width,
                    height: _zoneSize.height,
                    elementSize: _elementSize
                });
                nodes = _fillZone(newZone, nodes);
                zones[i][j] = newZone;
            }
        }
        self.zones = _groupZones(zones);
        self.zones.push(_fakeZone);
    }

    /**
     * Groups zones by groups of (by default) four.
     * @private
     * @param {NodeZone[]} zones
     * @return {NodeZone[] | GroupOfZones}
    */
    function _groupZones(zones) {
        var MAX_DEEP = 1000;
        var side = Math.sqrt(_zonesInGroup); // length of side of group
        var newZones = void 0;
        for (var n = 0; n < MAX_DEEP && zones.length !== 1; n++) {
            // iterations
            newZones = [];
            for (var i = 0, ni = 0; i < zones.length; i += side, ni++) {
                newZones[ni] = [];
                for (var j = 0, nj = 0; j < zones[i].length; j += side, nj++) {
                    var zonesOfGroup = [];
                    zonesOfGroup.push(zones[i][j]);
                    if (zones[i + 1] && zones[i + 1][j]) zonesOfGroup.push(zones[i + 1][j]);
                    if (zones[i] && zones[i][j + 1]) zonesOfGroup.push(zones[i][j + 1]);
                    if (zones[i + 1] && zones[i + 1][j + 1]) zonesOfGroup.push(zones[i + 1][j + 1]);
                    newZones[ni][nj] = new GroupOfZones(zonesOfGroup);
                }
            }
            zones = newZones;
        }
        if (newZones) zones = newZones;
        return zones[0] || [];
    }

    /**
     * Puts nodes and links into zone.
     * @private
     * @param {NodeZone} zone
     * @param {Node[]} nodes
     * @return {Node[]}
    */
    function _fillZone(zone, nodes) {
        var notFitedNodes = []; // indexes to remove the catched nodes from the list
        nodes.forEach(function (node) {
            if (zone.nodeHitTest(node)) {
                zone.nodes.push(node);

                self.getRelatedNodes(node).forEach(function (n) {
                    if (zone.relatedNodes.indexOf(n) === -1) {
                        zone.relatedNodes.push(n);
                    }
                });

                if (self.maps.sourceMap[node.id]) {
                    self.maps.sourceMap[node.id].forEach(function (link) {
                        zone.links.push(link);
                    });
                }
                if (self.maps.targetMap[node.id]) {
                    self.maps.targetMap[node.id].forEach(function (link) {
                        zone.links.push(link);
                    });
                }
            } else {
                notFitedNodes.push(node);
            }
        });
        return notFitedNodes;
    }

    /**
     * Clear zone - remove all data from the zone.
     * @private
     * @param {NodeZone} zone
    */
    function _clearZone(zone) {
        zone.relatedNodes = [];
        zone.nodes = [];
        zone.links = [];
    }

    /**
     * Creates map for nodes
     * and updates aspect relations between nodes
     * @private
     * @returns nodeMap
    */
    function _createNodeMaps() {
        var nodeMap = {};
        var idMap = {};
        self.nodes.forEach(function (node) {
            nodeMap[node.id] = node;
            nodeMap[node.model.id] = node.id;
        });
        return {
            nodeMap: nodeMap,
            idMap: idMap
        };
    }

    /**
     * Creates maps for links.
     * @private
     * @param {Object} nodeMap
     * @param {Object} idMap
     * @returns {linkMap, idMap}
    */
    function _createLinkMaps(nodeMap, idMap) {
        var sourceMap = {};
        var targetMap = {};
        var linkMap = {};

        self.links.forEach(function (link) {
            linkMap[link.id] = link;
            idMap[link.model.id] = link.id;

            var source = nodeMap[link.model.source];
            var target = nodeMap[link.model.target];

            if (!sourceMap[target.id]) {
                sourceMap[target.id] = [];
            }
            sourceMap[target.id].push(link);

            if (!targetMap[source.id]) {
                targetMap[source.id] = [];
            }
            targetMap[source.id].push(link);
        });
        return {
            linkMap: linkMap,
            sourceMap: sourceMap,
            targetMap: targetMap,
            idMap: idMap
        };
    }

    /**
     * Updates maps.
     * @private
    */
    function _refreshMaps() {
        var _createNodeMaps2 = _createNodeMaps(),
            nodeMap = _createNodeMaps2.nodeMap,
            idMap = _createNodeMaps2.idMap;

        var linkMaps = _createLinkMaps(nodeMap, idMap);

        self.maps = {
            sourceMap: linkMaps.sourceMap,
            targetMap: linkMaps.targetMap,
            nodeMap: nodeMap,
            idMap: linkMaps.idMap,
            linkMap: linkMaps.linkMap
        };
    }

    self.refresh();
}
exports.default = DataContainer;

/**
 * @private
 * Object that is the leaf of the zones tree
 * @class
 * @param {NodeZone[]} zones - Array of zonnes for containing
 * @property {NodeZone[]} zones - Array of zonnes
 */

function GroupOfZones(zones) {
    var self = this;

    self.model = {};
    self.zones = zones;

    _calculateBounds();

    /**
     * @private
     * Calculates bounds of the total area of contained zones. 
    */
    function _calculateBounds() {
        var minX = undefined,
            minY = undefined,
            maxX = undefined,
            maxY = undefined;

        self.zones.forEach(function (zone) {
            minX = minX === undefined ? zone.model.x : Math.min(minX, zone.model.x);
            minY = minY === undefined ? zone.model.y : Math.min(minY, zone.model.y);
            maxX = maxX === undefined ? zone.model.x + zone.model.width : Math.max(maxX, zone.model.x + zone.model.width);
            maxY = maxY === undefined ? zone.model.y + zone.model.height : Math.max(maxY, zone.model.y + zone.model.height);
        });
        self.model.x = minX;
        self.model.y = minY;
        self.model.width = maxX - minX;
        self.model.height = maxY - minY;
    }

    /**
     * Tells us whether a point fall into this group of zones or no.
     * @param {Point} point - Tested point
     * @returns {boolean}
     * @memberof GroupOfZones
     * @method
    */
    self.hitTest = function (point) {
        return point.x >= self.model.x && point.x <= self.model.x + self.model.width && point.y >= self.model.y && point.y <= self.model.y + self.model.height;
    };
}

/**
 * @private
 * Options of a NodeZone
 * @typedef {Object} NodeZoneOptions
 * @property {number} x - Position by x axis
 * @property {number} y - Position by y axis
 * @property {number} width - Width of the rectangle
 * @property {number} height - Height of the rectangle
 * @property {ElementSize} elementSize - Size of elements of the graph
 * @property {boolean} fakeZone - Is it fake zone (abstract or don't has position)
*/

/**
 * @private
 * Object that is the leaf of the tree of zones
 * @class
 * @param {Node[]} nodes - Nodes of the zone (can be undefined)
 * @param {NodeZoneOptions} parameters - Properties set
 * 
 * @property {NodeZoneOptions} model - Properties set
 */
function NodesZone(nodes, parameters) {
    var self = this;

    self.model = parameters;
    self.nodes = nodes || [];
    self.relatedNodes = [];
    self.links = [];

    var _elementSize = parameters.elementSize;

    /**
     * Tells us whether a Node fall into the zone or no.
     * @param {Node} node - Tested node
     * @returns {boolean}
     * @memberof NodesZone
     * @method
    */
    self.nodeHitTest = function (node) {
        if (self.model.fakeZone) return true;
        var nodePosition = node.model.position;

        var p1 = nodePosition;
        var p2 = { x: nodePosition.x + _elementSize.width, y: nodePosition.y };
        var p3 = { x: nodePosition.x, y: nodePosition.y + _elementSize.height };
        var p4 = { x: nodePosition.x + _elementSize.width, y: nodePosition.y + _elementSize.height };

        return self.hitTest(p1) && self.hitTest(p2) && self.hitTest(p3) && self.hitTest(p4);
    };

    /**
     * Tells us whether a point fall into the zone or no.
     * @param {Point} point - Tested point
     * @returns {boolean}
     * @memberof NodesZone
     * @method
    */
    self.hitTest = function (point) {
        return self.model.fakeZone || point.x >= self.model.x && point.x <= self.model.x + self.model.width && point.y >= self.model.y && point.y <= self.model.y + self.model.height;
    };
}

},{}],28:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.processData = processData;
exports.createAspectRelations = createAspectRelations;
var LG_GROUP_TYPE_ID = exports.LG_GROUP_TYPE_ID = 'tq-lg-group';

var NODE_MODEL_FIELDS = exports.NODE_MODEL_FIELDS = ['id', 'label', 'viewFrame', 'typeId', 'activeResource', 'resource', 'resourceType', 'position', 'defaultPosition', 'data', 'offset'];

var LINK_MODEL_FIELDS = exports.LINK_MODEL_FIELDS = ['id', 'source', 'target', 'linkType', 'group', 'data'];

/**
 * @private
 *
 * The function filters the data, sets authorities and collapses links.
 * @param {
 *  nodes: NodeModel[],
 *  links: LinkModel[]
 * } data
 */
function processData(data) {
    if (!data || !data.nodes) return;
    data.links = data.links || [];

    var nodeMap = {};

    data.nodes.forEach(function (node) {
        nodeMap[node.id] = node;
        node.position = { x: 0, y: 0 };
        // extracting additional data
        var data = {};
        Object.keys(node).forEach(function (key) {
            var notPermanentField = NODE_MODEL_FIELDS.indexOf(key) === -1;
            if (notPermanentField) {
                data[key] = node[key];
                delete node[key];
            }
        });
        node.data = data;
    });

    var destinationMap = {};
    data.links.forEach(function (rawLink) {
        if (nodeMap[rawLink.source] && nodeMap[rawLink.target]) {
            var linkCacheId = getCacheId(rawLink);

            if (destinationMap[linkCacheId]) {
                destinationMap[linkCacheId] = group(destinationMap[linkCacheId], rawLink);
            } else {
                destinationMap[linkCacheId] = rawLink;
            }
        } else {
            if (!nodeMap[rawLink.source]) {
                console.warn('Source not found! The link from ' + rawLink.source + ' to ' + rawLink.target);
            } else {
                console.warn('Target not found! The link from ' + rawLink.source + ' to ' + rawLink.target);
            }
        }
    });

    var sourceMap = {};
    var targetMap = {};
    var links = Object.keys(destinationMap).map(function (cacheId) {
        var link = destinationMap[cacheId];
        Object.keys(link).forEach(function (key) {
            var notPermanentField = LINK_MODEL_FIELDS.indexOf(key) === -1;
            if (notPermanentField) {
                data[key] = link[key];
                delete link[key];
            }
        });

        if (!sourceMap[link.target]) sourceMap[link.target] = [];
        sourceMap[link.target].push(link);

        if (!targetMap[link.source]) targetMap[link.source] = [];
        targetMap[link.source].push(link);

        return link;
    });

    return {
        nodes: Object.keys(nodeMap).map(function (key) {
            return nodeMap[key];
        }),
        links: links
    };

    function getCacheId(link) {
        return 'source:(' + link.source + ')~#~target:(' + link.target + ')';
    }

    function group(existedLink, newLink) {
        var group = existedLink.group ? existedLink : {
            id: getCacheId(existedLink),
            source: existedLink.source,
            target: existedLink.target,
            linkType: LG_GROUP_TYPE_ID, // existedLink.linkType,
            group: [existedLink]
        };
        group.group.push(newLink);
        // extracting additional data
        return group;
    }
}
exports.default = processData;

/**
 * @private
 *
 * The function filters the data, sets authorities and collapses links.
 * @param {
 *  nodes: NodeModel[],
 *  links: LinkModel[]
 * } data
 */

function createAspectRelations(nodes) {
    var aspectMap = {};
    nodes.forEach(function (node) {
        // combine nodes with the same id
        var clearId = node.model.resource;
        if (clearId) {
            if (!aspectMap[clearId]) {
                aspectMap[clearId] = [node];
            } else {
                aspectMap[clearId].push(node);
            }
        }
    });
    Object.keys(aspectMap).forEach(function (key) {
        if (aspectMap[key].length > 1) {
            aspectMap[key].forEach(function (n) {
                var index = aspectMap[key].indexOf(n);
                n.aspects = aspectMap[key].slice(0, index).concat(aspectMap[key].slice(index + 1, aspectMap[key].length));
            });
        }
    });
}

},{}],29:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DefaultDataProvider = DefaultDataProvider;
function DefaultDataProvider(parameters) {
    var self = this;
    if (!parameters) parameters = {};

    var _serverURL = parameters.serverURL || '/api/tbl/swp';
    var _defaultLineageGramViewClass = parameters.lgViewClass || 'http://edg.topbraid.solutions/model/BuildJSONforLineageModelLineageGram';
    var _vfViewClass = parameters.vfViewClass || 'edg:getViewFramesForResource';
    var _dmViewClass = parameters.dmViewClass || 'edg:DerivationMapDataService';
    var _vcViewClass = parameters.vcViewClass || 'edg:getLineageGramDataProvider';

    var _graph = parameters.graph || 'undefined';
    var _configGraph = parameters.configGraph || 'http://edg.topbraidlive.org/1.0/config/diagrams';
    var _base = parameters.base || 'undefined';

    var _reach = parameters.reach;
    var _range = parameters.range;
    var _breadth = parameters.breadth;
    var _depth = parameters.depth;

    self.fetchData = function (options) {
        return _executQuery(getFetchDataUrl(options.targetNodeId, options.viewFrame, options.lineageGramViewClass, options.diagramType, options.hasOwnProperty('offset') ? options.offset : null));
    };

    self.getViewFrames = function (resource) {
        return _executQuery(getViewFramesUrl(resource));
    };

    self.getViewClassForResource = function (resource) {
        return _executQuery(getViewClassUrl(resource));
    };

    self.relationInfo = function (relation) {
        var sourceResource = relation.source.resource;

        if (relation.source.hasOwnProperty('activeResource')) {
            sourceResource = relation.source.activeResource;
        }

        var targetResource = relation.target.resource;

        if (relation.target.hasOwnProperty('activeResource')) {
            targetResource = relation.target.activeResource;
        }

        return _executQuery(getDerivationDataUrl(sourceResource, targetResource, relation.linkType));
    };

    function getViewFramesUrl(resource) {
        return _serverURL + '?' + '_viewClass=' + _vfViewClass + '&' + 'graph=' + _graph + '&' + 'resource=' + resource + '&' + 'configGraph=' + _configGraph + '&' + '_base=' + _base;
    }

    function getViewClassUrl(resource) {
        return _serverURL + '?' + '_viewClass=' + _vcViewClass + '&' + 'graph=' + _graph + '&' + 'resource=' + resource + '&' + 'configGraph=' + _configGraph + '&' + '_base=' + _base;
    }

    function getFetchDataUrl(focusNode, viewFrame, lineageGramViewClass, diagramType, offset) {
        var dataUrl = _serverURL + '?' + '_viewClass=' + (lineageGramViewClass || _defaultLineageGramViewClass) + '&' + 'graph=' + _graph + '&' + 'focusNode=' + encodeURIComponent(focusNode) + '&' + '_base=' + _base;

        if (viewFrame) {
            dataUrl += '&viewFrame=' + viewFrame;
        }

        if (offset) {
            dataUrl += '&offset=' + offset;
        }

        if (_reach) {
            dataUrl += '&reach=' + _reach;
        }

        if (_range) {
            dataUrl += '&range=' + _range;
        }

        if (_breadth) {
            dataUrl += '&breadth=' + _breadth;
        }

        if (_depth) {
            dataUrl += '&depth=' + _depth;
        }

        if (diagramType) {
            dataUrl += '&diagramType=' + diagramType;
        }

        return dataUrl;
    }

    function _executQuery(url) {
        return fetch(url, {
            method: 'GET',
            credentials: 'same-origin',
            mode: 'cors',
            cache: 'default',
            headers: {
                'Accept': 'application/json, text/turtle',
                'Content-Type': 'application/sparql-query'
            }
        }).then(function (response) {
            if (response.ok) {
                return response.json(); // Also possible to use: response.text(); //response.type;
            } else {
                var error = new Error(response.statusText);
                error.response = response;
                throw error;
            }
        });
    }

    function getDerivationDataUrl(leftNode, rightNode, linkType) {
        var dataURL = _serverURL + '?' + '_base=' + _base + '&' + '_viewClass=' + _dmViewClass + '&' + 'leftNode=' + leftNode + '&' + 'rightNode=' + rightNode;

        if (linkType) {
            dataURL += '&linkType=' + linkType;
        }

        return dataURL;
    }
}
exports.default = DefaultDataProvider;

},{}],30:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FEED_PIPE_LINK_STYLE = exports.DEFAULT_GROUP_LINK_STYLE = exports.DEFAULT_LINK_STYLE = exports.DEFAULT_DERIVATION_MAP_LINK_STYLE = exports.LG_GROUP_TYPE_ID = exports.FEED_PIPE_TYPE = undefined;
exports.ResourceProvider = ResourceProvider;

var _lodash = require('lodash');

var _ = _interopRequireWildcard(_lodash);

var _base64Images = require('./base64Images');

var images = _interopRequireWildcard(_base64Images);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var FEED_PIPE_TYPE = exports.FEED_PIPE_TYPE = 'feedpipe';

var LG_GROUP_TYPE_ID = exports.LG_GROUP_TYPE_ID = 'tq-lg-group';

var DEFAULT_DERIVATION_MAP_LINK_STYLE = exports.DEFAULT_DERIVATION_MAP_LINK_STYLE = {
    cssClass: 'derivation-link',
    lineType: 'solid', // 'dashed'
    color: 'black',
    textColor: 'black',
    textBackgroundColor: 'white',
    thickness: 2
};

var DEFAULT_LINK_STYLE = exports.DEFAULT_LINK_STYLE = {
    cssClass: 'lineage-gram-link',
    lineType: 'solid', // 'dashed'
    color: '#3c4260',
    toolButton: {
        image: images.LINK_OPTIONS,
        width: 30,
        height: 30,
        alwaysVisible: false
    },
    thickness: 2,
    hasArrow: true
};

var DEFAULT_GROUP_LINK_STYLE = exports.DEFAULT_GROUP_LINK_STYLE = {
    cssClass: 'lineage-gram-links-group',
    lineType: 'solid', // 'dashed'
    color: '#3c4260',
    thickness: 2,
    hasArrow: true,
    toolButton: {
        alwaysVisible: true
    }
};

var FEED_PIPE_LINK_STYLE = exports.FEED_PIPE_LINK_STYLE = {
    cssClass: 'lineage-gram-feed-pipe-link',
    lineType: 'solid', // 'dashed'
    color: '#3c4260',
    toolButton: {
        image: images.FEED_PIPE,
        width: 30,
        height: 30,
        alwaysVisible: true
    },
    thickness: 3,
    hasArrow: true
};

function ResourceProvider(_parameters) {
    var self = this;

    self.getLinkStyle = _getLinkStyle;
    self.getImage = _getImage;
    self.getColor = _getColor;
    self.getIcon = _getIcon;

    function _getColor(type) {
        if (!type) {
            return 'white';
        }
        if (!type) {
            return _parameters.colors['default'];
        } else {
            return _parameters.colors[type] || _parameters.colors['default'];
        }
    }

    function _getImage(type) {
        if (!type) {
            return images.UNKNOW_IMAGE;
        }
        if (!_parameters.images[type] && type === 'link-options' || type === 'default-link-options') {
            return images.LINK_OPTIONS;
        }
        if (!_parameters.images[type] && type === 'feed-pipe' || type === 'default-feed-pipe') {
            return images.FEED_PIPE;
        }
        return _parameters.resourcePath + (_parameters.images[type] || _parameters.images['unknown'] || images.UNKNOW_IMAGE);
    }

    function _getLinkStyle(type) {
        var linkStyles = _parameters.linkStyles;
        var defaultStyle = _.cloneDeep(linkStyles['default-link-style'] || DEFAULT_LINK_STYLE);

        var linkStyle = void 0;
        if (!type) {
            linkStyle = defaultStyle || defaultStyle;
        } else {
            if (linkStyles[type]) {
                linkStyle = linkStyles[type];
            } else {
                linkStyle = defaultStyle || defaultStyle;
            }
        }
        return _.merge(defaultStyle, linkStyle);
    }

    function _getIcon(type) {
        if (!type) {
            return undefined;
        }

        return _parameters.icons[type];
    }
}

},{"./base64Images":26,"lodash":"lodash"}],31:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.DefaultUI = DefaultUI;

var _visualizationsLibrary = require('visualizations-library');

var _visualizationsLibrary2 = _interopRequireDefault(_visualizationsLibrary);

var _viewFrameButtons = require('./viewFrameButtons');

var _map = require('./map');

var _map2 = _interopRequireDefault(_map);

var _infoPanel = require('./infoPanel');

var _infoPanel2 = _interopRequireDefault(_infoPanel);

var _optionsPanel = require('./optionsPanel');

var _optionsPanel2 = _interopRequireDefault(_optionsPanel);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Parameters set for a {@link Toolbar}.
 * @typedef {Object} DefaultUIOptions
 * @property {HTMLElement | String} baseElement - Root HTMLElement
 * @property {Object.<string, LegendDescriptor>} legends
 * @property {string} neighborGramViewClass
 */

/**
 * @private
 * @param {DefaultUIOptions} options
 */
function DefaultUI(options) {
    var self = this;
    // Initialization
    // =======================================================
    var _lineageGram = options.lineageGram;
    var markup = '\n        <div class="tq-lg-default-user-ui">\n            <div id="tqLgToolbar"></div>\n            <div id="tqLgMiniMap"></div>\n            <div id="tqLgInfoPanel"></div>\n            <div id="tqLgOptionsPanel"></div>\n            <div id="tqLgSearchPanel"></div>\n        </div>\n    ';

    var _el = void 0;
    if (typeof options.baseElement === 'string') {
        _el = document.getElementById(options.baseElement);
    } else if (_typeof(options.baseElement) === 'object') {
        _el = options.baseElement;
    }
    if (!_el) return;
    _el.innerHTML = markup;

    var tqLgToolbar = _el.querySelector('#tqLgToolbar');
    var tqLgMiniMap = _el.querySelector('#tqLgMiniMap');
    var tqLgInfoPanel = _el.querySelector('#tqLgInfoPanel');
    var tqLgOptionsPanel = _el.querySelector('#tqLgOptionsPanel');
    var tqLgSearchPanel = _el.querySelector('#tqLgSearchPanel');

    var _zooming = _lineageGram.zoom();
    var _expandAll = true;
    // =======================================================

    var _coloredButtons = new _viewFrameButtons.ViewFrameButtons({
        lineageGram: _lineageGram
    });
    var _switcher = new _visualizationsLibrary2.default.Switcher({
        states: [{
            id: 'lineageDiagram',
            label: 'Lineage diagram view',
            icon: 'glyphicon glyphicon-modal-window'
        }, {
            id: 'birdEye',
            label: 'Bird eye view',
            icon: 'glyphicon glyphicon-eye-open'
        }],
        verticalOrientation: true
    });

    _switcher.on('state-changed', function (tabId) {
        _lineageGram.setCurrentView(tabId);
    });

    var _toolbar = new _visualizationsLibrary2.default.Toolbar({
        baseElement: tqLgToolbar,
        tools: [{
            id: 'tqLgSearch',
            icon: 'glyphicon glyphicon-search',
            label: 'Search'
        }, {
            id: 'tqLgZoomIn',
            icon: 'glyphicon glyphicon-zoom-in',
            label: 'Zoom in',
            callback: function callback() {
                _zooming = _lineageGram.zoomIn();
                _toolbar.rootHtml.querySelector('#tqLgZoomIn').disabled = _zooming.cur === _zooming.max;
                _toolbar.rootHtml.querySelector('#tqLgZoomOut').disabled = _zooming.cur === _zooming.min;
            }
        }, {
            id: 'tqLgZoomOut',
            icon: 'glyphicon glyphicon-zoom-out',
            label: 'Zoom out',
            callback: function callback() {
                _zooming = _lineageGram.zoomOut();
                _toolbar.rootHtml.querySelector('#tqLgZoomIn').disabled = _zooming.cur === _zooming.max;
                _toolbar.rootHtml.querySelector('#tqLgZoomOut').disabled = _zooming.cur === _zooming.min;
            }
        }, {
            id: 'tqLgZoomToFit',
            icon: 'glyphicon glyphicon-fullscreen',
            label: 'Zoom to fit',
            callback: function callback() {
                _zooming = _lineageGram.zoomToFit();
            }
        }, {
            id: 'tqLgReset',
            icon: 'glyphicon glyphicon-refresh',
            label: 'Reset layout',
            callback: function callback() {
                _lineageGram.resetLayout();
            }
        }, {
            id: 'tqLgGather',
            icon: 'glyphicon glyphicon-pushpin',
            label: 'Gather relatives',
            callback: function callback() {
                _lineageGram.combine();
            }
        }, {
            id: 'expandAll',
            icon: 'glyphicon glyphicon-resize-full',
            icon2: 'glyphicon glyphicon-resize-small',
            label: 'Expand all nodes',
            callback: function callback() {
                if (_expandAll) {
                    _lineageGram.expandAllNodes();
                } else {
                    _lineageGram.collapseAllNodes();
                }
                _expandAll = !_expandAll;
            }
        }, _coloredButtons, _switcher, {
            id: 'infoPanelBtn',
            icon: 'glyphicon glyphicon-info-sign',
            label: 'Info panel'
        }, {
            id: 'tqLgOptionsButton',
            icon: 'glyphicon glyphicon-menu-hamburger'
        }]
    });
    self.toolbar = _toolbar;

    _lineageGram.on('current-view-changed', function (viewId) {
        var disabled = viewId !== 'lineageDiagram';
        _switcher.setState(viewId);
        _toolbar.rootHtml.querySelector('#expandAll').disabled = disabled;
        _toolbar.rootHtml.querySelector('#tqLgReset').disabled = disabled;
        _toolbar.rootHtml.querySelector('#tqLgZoomIn').disabled = disabled;
        _toolbar.rootHtml.querySelector('#tqLgZoomOut').disabled = disabled;
        _toolbar.rootHtml.querySelector('#tqLgZoomToFit').disabled = disabled;
    });

    new _visualizationsLibrary2.default.SearchPanel({
        baseElement: tqLgSearchPanel,
        triggerButton: _toolbar.rootHtml.querySelector('#tqLgSearch'),
        active: false
    });

    new _infoPanel2.default({
        baseElement: tqLgInfoPanel,
        active: false,
        triggerButton: _toolbar.rootHtml.querySelector('#infoPanelBtn'),
        lineageGram: _lineageGram
    });

    new _optionsPanel2.default({
        lineageGram: _lineageGram,
        baseElement: tqLgOptionsPanel,
        active: false,
        triggerButton: _toolbar.rootHtml.querySelector('#tqLgOptionsButton'),
        legends: options.legends,
        onPressHelp: options.onPressHelp
    });

    new _map2.default({
        baseElement: tqLgMiniMap,
        active: false,
        lineageGram: _lineageGram,
        position: {
            x: 'calc(100% - 265px)',
            y: 'calc(100% - 265px)'
        }
    });
}
exports.default = DefaultUI;

},{"./infoPanel":34,"./map":35,"./optionsPanel":36,"./viewFrameButtons":38,"visualizations-library":5}],32:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.DMDefaultUI = DMDefaultUI;

var _visualizationsLibrary = require('visualizations-library');

var _visualizationsLibrary2 = _interopRequireDefault(_visualizationsLibrary);

var _dmInfoPanel = require('./dmInfoPanel');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Parameters set for a {@link Toolbar}.
 * @typedef {Object} DefaultUIOptions
 * @property {HTMLElement | String} baseElement - Root HTMLElement
 * @property {Object.<string, LegendDescriptor>} legends
 * @property {string} neighborGramViewClass
 * @property {DerivationMap} derivationMap
 */

/**
 * @private
 * @param {DefaultUIOptions} options
 */
function DMDefaultUI(options) {
    var self = this;
    var _derivationMap = options.derivationMap;
    var _base = _createBase(_getHtmlElement(options.baseElement), _getHtmlElement(options.infoPanel));
    var _expandAll = true;
    var _diagramInfo = undefined;

    // Initialization
    // ==================================================

    var baseTools = [{
        id: 'tqDMSearch',
        icon: 'glyphicon glyphicon-search',
        label: 'Search',
        callback: _openCloseSearchPanel
    }, {
        id: 'tqDMExportSVG',
        icon: 'tool-bar-svg-icon',
        label: 'Export to SVG',
        callback: function callback() {
            _derivationMap.exportToSvg();
        }
    }, {
        id: 'tqDMExportPNG',
        icon: 'tool-bar-png-icon',
        label: 'Export to PNG',
        callback: function callback() {
            _derivationMap.exportToPng();
        }
    }, {
        id: 'tqPrint',
        icon: 'glyphicon glyphicon-print',
        label: 'Print',
        callback: function callback() {
            _derivationMap.print();
        }
    }, {
        id: 'tqDMZoomIn',
        icon: 'glyphicon glyphicon-zoom-in',
        label: 'Zoom in',
        callback: function callback() {
            _derivationMap.zoomIn();
        }
    }, {
        id: 'tqDMZoomOut',
        icon: 'glyphicon glyphicon-zoom-out',
        label: 'Zoom out',
        callback: function callback() {
            _derivationMap.zoomOut();
        }
    }, {
        id: 'tqDMZoomToFit',
        icon: 'glyphicon glyphicon-fullscreen',
        label: 'Zoom to fit',
        callback: function callback() {
            _derivationMap.zoomToFit();
        }
    }, {
        id: 'infoPanelBtn',
        icon: 'glyphicon glyphicon-info-sign',
        label: 'Open Info panel'
    }, {
        id: 'expandAll',
        icon: 'glyphicon glyphicon-resize-full',
        icon2: 'glyphicon glyphicon-resize-small',
        label: 'Expand all',
        callback: function callback() {
            if (_expandAll) {
                _derivationMap.expandAllElements();
            } else {
                _derivationMap.collapseAllElements();
            }
            _expandAll = !_expandAll;
        }
    }];

    if (options.tools) {
        options.tools.forEach(function (tool) {
            if (tool.position < baseTools.length) {
                baseTools.splice(tool.position, 0, tool);
            } else {
                baseTools.push(tool);
            }
        });
    }

    self.toolbar = new _visualizationsLibrary2.default.Toolbar({
        baseElement: _base.toolbar,
        tools: baseTools
    });

    self.infoPanel = new _dmInfoPanel.DMInfoPanel({
        baseElement: _base.infoPanel,
        triggerButton: self.toolbar.rootHtml.querySelector('#infoPanelBtn')
    });

    self.infoPanel.on('size-changed', function () {
        return _derivationMap.resetFocus();
    });

    self.infoPanel.on('element-click', function (elementId) {
        _derivationMap.setSelectedElement(elementId);
    });

    _derivationMap.on('diagram-state-changed', function (stateId) {
        if (stateId === 'completed') {
            _diagramInfo = _derivationMap.getDiagramInfo();
            if (_diagramInfo && _diagramInfo.title) {
                _base.diagramTitle.innerText = _diagramInfo.title;
            } else {
                _base.diagramTitle.innerText = '';
            }
        }
    });

    // =======================================================

    var searchPaneVisible = false;
    var debounce = false;
    var searchButton = self.toolbar.rootHtml.querySelector('#tqDMSearch');
    var searchInput = _base.searchPanel.querySelector('input');
    searchInput.onkeyup = function () {
        if (debounce) clearTimeout(debounce);

        debounce = setTimeout(function () {
            var searchKey = searchInput.value;
            _derivationMap.setSearchKey(searchKey);
        }, 300);
    };
    function _openCloseSearchPanel() {
        if (searchPaneVisible) {
            _derivationMap.setSearchKey(undefined);
            _base.searchPanel.classList.add('tq-dm-hidden');
            searchButton.classList.remove('tq-ui-selected');
        } else {
            _derivationMap.setSearchKey(searchInput.value);
            _base.searchPanel.classList.remove('tq-dm-hidden');
            searchButton.classList.add('tq-ui-selected');
        }
        searchPaneVisible = !searchPaneVisible;
    }

    function _getHtmlElement(baseElement) {
        var baseHtml = void 0;
        if (typeof baseElement === 'string') {
            baseHtml = document.getElementById(baseElement);
        } else if ((typeof baseElement === 'undefined' ? 'undefined' : _typeof(baseElement)) === 'object') {
            baseHtml = baseElement;
        }
        if (!baseHtml) throw new Error('Base element is not found!');
        return baseHtml;
    }

    /**
     * Creates html markup.
     * @private
     * @param {HTMLElement} htmlNode - Root node for markup
     * @returns {Object.<string, HTMLElement>} - Map of html elements
     */
    function _createBase(htmlNode, infoPanel) {
        htmlNode.innerHTML = '';
        htmlNode.tabIndex = 1;

        var toolbarBase = document.createElement('DIV');
        toolbarBase.className = 'tq-derivation-map__toolbar';
        toolbarBase.id = 'tq-derivation-map-toolbar';
        htmlNode.appendChild(toolbarBase);

        var diagramTitleContainter = document.createElement('DIV');
        diagramTitleContainter.className = 'tq-derivation-map_container';
        var diagramTitle = document.createElement('DIV');
        diagramTitle.className = 'tq-derivation-map_container__title';
        diagramTitle.innerText = '';
        diagramTitleContainter.appendChild(diagramTitle);
        htmlNode.appendChild(diagramTitleContainter);

        var searchPanel = document.createElement('DIV');
        searchPanel.className = 'tq-derivation-map_search-pane tq-dm-hidden';
        searchPanel.innerHTML = '\n            <input\n                id="tq-dm-search-pane"\n                type="text"\n                class="tq-derivation-map_search-pane__input">\n            </input>\n        ';
        htmlNode.appendChild(searchPanel);

        return {
            searchPanel: searchPanel,
            rootHtml: htmlNode,
            infoPanel: infoPanel,
            toolbar: toolbarBase,
            diagramTitle: diagramTitle
        };
    }
}
exports.default = DMDefaultUI;

},{"./dmInfoPanel":33,"visualizations-library":5}],33:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.DMInfoPanel = DMInfoPanel;

var _subscribeable = require('../subscriptionAPI/subscribeable');

var _subscribeable2 = _interopRequireDefault(_subscribeable);

var _mapElements = require('../jointViews/derivationMap/mapElements');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @private
 * The data model for a {@link DMInfoPanel} object.
 * @typedef {Object} DMInfoPanelModel
 * @property {string|HTMLElement} baseElement - Root for this panel
 * @property {LineageGram} derivationMap - DerivationMap object.
 */

/**
 * @private
 * @class
 * @param {DMInfoPanelModel} - Data model.
 * @fires size-changed
 * @fires element-click (id:string)
*/
function DMInfoPanel(parameters) {
    _subscribeable2.default.apply(this); // make this class Subscribable
    var self = this;

    if (!parameters) parameters = {};

    var _selectedElement = parameters.selectedElement;
    var _width = 250;
    var _hidden = true;
    // ===================================================
    self.rootHtml = _getElement(parameters.baseElement);

    var _container = document.createElement('DIV');
    _container.className = 'tq-lg-dm-property-pane-container';
    self.rootHtml.appendChild(_container);

    var _triggerButton = parameters.triggerButton;
    _triggerButton.onclick = function () {
        if (_hidden) {
            _show();
        } else {
            _hide();
        }
    };

    var _slider = document.createElement('DIV');
    _slider.className = 'tq-lg-dm-slider';
    _slider.addEventListener('mousedown', function (event) {
        _onMousedown(event);
    });
    _container.appendChild(_slider);

    var _closeButton = document.createElement('DIV');
    _closeButton.setAttribute('title', 'Close info panel');
    _closeButton.className = 'tq-lg-dm-hide-button';
    _closeButton.onclick = function () {
        _hide();
    };
    _container.appendChild(_closeButton);

    self.body = document.createElement('DIV');
    _container.appendChild(self.body);
    // ===================================================
    self.id = 'derivationMapInfoPanel';
    self.redraw = _redraw;
    self.setSelectedElement = _setSelectedElement;
    self.show = _show;
    self.hidde = _hide;
    // width: 250px;

    _redraw();

    function _redraw() {
        if (_hidden) return;
        var markup = void 0;
        if (_selectedElement) {
            if (_selectedElement instanceof _mapElements.Node) {
                markup = _getNodeInfo(_selectedElement);
            } else if (_selectedElement instanceof _mapElements.Link) {
                markup = _getLinkInfo(_selectedElement);
            } else {
                markup = '\n                    <div class="tq-lg-dm-property-pane tq-lg-dm-empty">\n                        <div>Unknown type of element</div>\n                    </div>\n                ';
            }
        } else {
            markup = '\n                <div class="tq-lg-dm-property-pane tq-lg-dm-empty">\n                    <div>Select a diagram element</div>\n                </div>\n            ';
        }
        self.body.style.width = _width + 'px';
        self.body.innerHTML = markup;

        if (_selectedElement instanceof _mapElements.Node) {
            var children = self.body.querySelectorAll('.tq-lg-dm-child-button');
            for (var i = 0; i < children.length; i++) {
                children[i].onclick = function () {
                    self.trigger('element-click', this.id);
                };
            }
        } else if (_selectedElement instanceof _mapElements.Link) {
            self.body.querySelector('.tq-lg-dm-source-button').onclick = function () {
                self.trigger('element-click', this.id);
            };
            self.body.querySelector('.tq-lg-dm-target-button').onclick = function () {
                self.trigger('element-click', this.id);
            };
        } else {
            //...
        }
    }

    function _getNodeInfo(node) {
        var chilren = node.children.map(function (child) {
            return '<div\n                id="' + child.id + '"\n                title="' + child.label + '(' + child.endpointId + ')"\n                type="text"\n                class="tq-ui-property-button tq-lg-dm-child-button">\n                ' + child.label + '\n            </div>';
        }).join('');
        return '\n            <div class="tq-lg-dm-property-pane">\n                <label class="tq-label">ID</label>\n                <input\n                    value="' + node.endpointId + '"\n                    title="' + node.endpointId + '" type="text"  class="tq-ui-property" disabled>\n                </input>\n                <label class="tq-label">Diagram ID</label>\n                <input\n                    value="' + node.id + '"\n                    title="' + node.id + '"\n                    type="text"\n                    class="tq-ui-property"\n                    disabled>\n                </input>\n                <label class="tq-label">Label</label>\n                <input value="' + node.label + '" title="' + node.label + '" type="text" class="tq-ui-property" disabled></input>\n                ' + (chilren.length > 0 ? '<label class="tq-label">Children</label>' : '') + '\n                ' + chilren + '\n            </div>\n        ';
    }

    function _getLinkInfo(link) {
        return '\n            <div class="tq-lg-dm-property-pane">\n                <label class="tq-label">Label</label>\n                <input value="' + link.label + '" title="' + link.label + '" type="text" class="tq-ui-property" disabled></input>\n                <label class="tq-label">Source</label>\n                <div id="' + link.source.id + '"\n                    title="' + link.source.label + '(' + link.source.endpointId + ')"\n                    type="text"\n                    class="tq-ui-property-button tq-lg-dm-source-button">\n                    ' + link.source.label + '\n                </div>\n                <label class="tq-label">Target</label>\n                <div id="' + link.target.id + '"\n                    title="' + link.target.label + '(' + link.target.endpointId + ')"\n                    type="text"\n                    class="tq-ui-property-button tq-lg-dm-target-button">\n                    ' + link.target.label + '\n                </div>\n            </div>\n        ';
    }

    var SELECTED_CLASS = 'tq-ui-selected';
    function _show() {
        _hidden = false;
        _container.style.display = null;
        _triggerButton.classList.add(SELECTED_CLASS);
        _redraw();
        setTimeout(function () {
            self.trigger('size-changed');
        }, 0);
    }

    function _hide() {
        _hidden = true;
        _container.style.display = 'none';
        _triggerButton.classList.remove(SELECTED_CLASS);
        setTimeout(function () {
            self.trigger('size-changed');
        }, 0);
    }

    function _onMousedown(event) {
        var startX = 0;
        var MIN_WIDTH = 100;

        if (event.pageX) startX = event.pageX;else if (event.clientX) startX = event.clientX;

        window.getSelection().removeAllRanges();

        document.body.addEventListener('mousemove', _onchange);
        document.body.addEventListener('mouseup', _onmouseup);

        function _onchange(event) {
            var endX = 0;

            if (event.pageX) endX = event.pageX;else if (event.clientX) endX = event.clientX;

            var diffX = startX - endX;
            startX = endX;

            _width += diffX;
            _width = Math.max(MIN_WIDTH, _width);
            self.trigger('size-changed');
            _redraw();
        }

        function _onmouseup(event) {
            if (self._mouseMove) {
                _onchange(event, true);
                self._mouseMove = false;
            }
            document.body.onmousemove = document.body.onmouseup = null;
            document.body.removeEventListener('mousemove', _onchange);
            document.body.removeEventListener('mouseup', _onmouseup);
        }
    }

    function _setSelectedElement(element) {
        _selectedElement = element;
        _redraw();
    }
}
exports.default = DMInfoPanel;


function _getElement(el) {
    var element = void 0;
    if (typeof el === 'string') {
        element = document.getElementById(el);
    } else if ((typeof el === 'undefined' ? 'undefined' : _typeof(el)) === 'object') {
        element = el;
    }
    return element;
}

},{"../jointViews/derivationMap/mapElements":43,"../subscriptionAPI/subscribeable":66}],34:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.InfoPanel = InfoPanel;

var _lodash = require('lodash');

var _ = _interopRequireWildcard(_lodash);

var _visualizationsLibrary = require('visualizations-library');

var _visualizationsLibrary2 = _interopRequireDefault(_visualizationsLibrary);

var _subscribeable = require('../subscriptionAPI/subscribeable');

var _subscribeable2 = _interopRequireDefault(_subscribeable);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * The data model for a {@link InfoPanel} object.
 * @typedef {Object} InfoPanelModel
 * @property {string|HTMLElement} baseElement - Root for this panel
 * @property {LineageGram} lineageGram - LineageGram object.
 * @property {boolean} active - false - collapsed, true - expanded
 * @property {string|HTMLElement} triggerButton
 * @property {Function} onPressExternal
 */

/**
 * Class which is a simple UI panel.
 * This panel can represent an information about selected element
 * and also, it supports simple navigation between elements.
 * @class
 * @param {InfoPanelModel} options - Data model.
 * @fires state-changed
*/
function InfoPanel(options) {
    _subscribeable2.default.apply(this); // make this class Subscribable

    var infoTemplate = new _visualizationsLibrary2.default.InfoPanel({ launchExternal: options.lineageGram.launchExternal });

    var _lineageGram = options.lineageGram;

    _visualizationsLibrary2.default.FlyingPanel.apply(this, [{
        baseElement: options.baseElement,
        active: options.active,
        header: 'Info panel',
        triggerButton: options.triggerButton,
        launchExternal: options.onPressExternal,
        emptyBody: false,
        size: { width: '300px', height: '450px' },
        body: infoTemplate,
        resizable: true
    }]);

    _lineageGram.on('selected-element-changed', function (elementModel) {
        var graphModel = _lineageGram.getGraphModel();
        var nodeMap = graphModel.maps.nodeMap;

        if (elementModel) {
            var source = nodeMap[elementModel.source];
            var target = nodeMap[elementModel.target];

            var data = void 0;
            if (elementModel.linkType && elementModel.group) {
                data = {};
                elementModel.group.forEach(function (el) {
                    return data = _.merge(data, el.data);
                });
            } else {
                data = _.cloneDeep(elementModel.data) || {};
            }

            if (elementModel.linkType) {
                if (elementModel.linkType && !elementModel.group) {
                    data['Link type'] = elementModel.linkType;
                } else {
                    var typeMap = {};
                    elementModel.group.forEach(function (el) {
                        return typeMap[el.linkType] = el;
                    });
                    var types = Object.keys(typeMap);
                    if (types.length > 1) {
                        data['Link type'] = elementModel.linkType;
                        data['Grouped types'] = types.join(', ');
                    } else {
                        data['Link type'] = types[0];
                    }
                    data['IDs'] = elementModel.group.map(function (el) {
                        return el.id;
                    }).join(', ');
                }
            }

            if (elementModel.activeResource) data["Active Resource"] = decodeURIComponent(elementModel.activeResource);
            if (elementModel.offset) data['Offset'] = elementModel.offset;
            if (elementModel.viewFrame) data['View frame'] = elementModel.viewFrame;

            infoTemplate.setSelectedElement({
                id: elementModel.id,
                label: elementModel.label,
                resource: elementModel.resource,
                resourceType: elementModel.resourceType,
                diagramType: elementModel.diagramType,
                types: elementModel.typeId,
                source: source ? {
                    id: source.id,
                    label: source.label
                } : undefined,
                target: target ? {
                    id: target.id,
                    label: target.label
                } : undefined,
                data: data,
                relations: _getRelations(elementModel, graphModel)
            });
        } else {
            infoTemplate.setSelectedElement(undefined);
        }
    });

    infoTemplate.on('selected-element-changed', function (elementId) {
        _lineageGram.setSelectedElement(elementId);
    });

    function _getAspects(elementModel, nodes) {
        var aspects = [];
        if (elementModel.resource) {
            nodes.forEach(function (node) {
                if (node.resource === elementModel.resource) aspects.push(node);
            });
        } else {
            aspects.push(elementModel);
        }
        return aspects;
    }

    function _getRelations(elementModel, graphModel) {
        var sourceMap = graphModel.maps.sourceMap;
        var targetMap = graphModel.maps.targetMap;
        var nodeMap = graphModel.maps.nodeMap;

        var ids = _getAspects(elementModel, graphModel.nodes).map(function (a) {
            return a.id;
        });

        var sources = [];
        var targets = [];
        ids.forEach(function (id) {
            if (sourceMap[id]) {
                sources = sources.concat(sourceMap[id].map(function (l) {
                    var node = nodeMap[l.source];
                    return {
                        id: node.id,
                        label: node.label
                    };
                }));
            }
            if (targetMap[id]) {
                targets = targets.concat(targetMap[id].map(function (l) {
                    var node = nodeMap[l.target];
                    return {
                        id: node.id,
                        label: node.label
                    };
                }));
            }
        });

        if (sources && sources.length > 0 || targets && targets.length > 0) {
            return {
                incomings: sources,
                outgoings: targets
            };
        }
        return undefined;
    }
}
exports.default = InfoPanel;

},{"../subscriptionAPI/subscribeable":66,"lodash":"lodash","visualizations-library":5}],35:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.Map = Map;

var _visualizationsLibrary = require('visualizations-library');

var _visualizationsLibrary2 = _interopRequireDefault(_visualizationsLibrary);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function Map(options) {
    var markup = '\n        <div id="mapButton" class="tq-lg-map">\n            <span title="Mini map" class="tq-lg-collapse-panel_body__label glyphicon glyphicon-picture" aria-hidden="true"></span>\n        </div>\n        <div id="baseElementForMap"></div>\n    ';
    var _lineageGram = options.lineageGram;

    var _el = void 0;

    if (typeof options.baseElement === 'string') {
        _el = document.getElementById(options.baseElement);
    } else if (_typeof(options.baseElement) === 'object') {
        _el = options.baseElement;
    }
    if (!_el) return;

    _el.innerHTML = markup;

    var mapFlyingPanel = new _visualizationsLibrary2.default.FlyingPanel({
        baseElement: _el.querySelector('#baseElementForMap'),
        active: options.active,
        header: 'Map',
        triggerButton: _el.querySelector('#mapButton'),
        emptyBody: false,
        size: { width: '250px', height: '250px' },
        position: options.position,
        body: '',
        resizable: true
    });

    _lineageGram.setRootHtmlForMap(mapFlyingPanel.rootHtml.querySelector('.tq-ui-body_container'));

    mapFlyingPanel.on('size-changed', function () {
        _lineageGram.refresh('graphMap');
    });
}
exports.default = Map;

},{"visualizations-library":5}],36:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OptionsPanel = OptionsPanel;

var _subscribeable = require('../subscriptionAPI/subscribeable');

var _subscribeable2 = _interopRequireDefault(_subscribeable);

var _visualizationsLibrary = require('visualizations-library');

var _visualizationsLibrary2 = _interopRequireDefault(_visualizationsLibrary);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The data model for a {@link OptionsPanel} object.
 * @typedef {Object} OptionsPanelModel
 * @property {string|HTMLElement} baseElement - Root for this panel
 * @property {LineageGram} lineageGram - LineageGram object.
 * @property {boolean} active - false - collapsed, true - expanded
 * @property {string|HTMLElement} triggerButton
 */

/** 
 * Class which is a simple UI panel.
 * This panel can represent an information about selected element
 * and also, it supports simple navigation between elements.
 * @class
 * @param {OptionsPanelModel} options - Data model.
 * @fires state-changed
*/
function OptionsPanel(options) {
    _subscribeable2.default.apply(this); // make this class Subscribable

    var legends = options.legends || [];
    var _lineageGram = options.lineageGram;
    var self = this;

    _visualizationsLibrary2.default.FlyingPanel.apply(this, [{
        baseElement: options.baseElement,
        active: options.active,
        header: 'Options panel',
        triggerButton: options.triggerButton,
        emptyBody: true,
        size: {
            width: '400px',
            height: '500px'
        },
        removeBackground: true,
        body: new _visualizationsLibrary2.default.TabPanel({
            tabs: [{
                id: 'tqUiGeneral',
                label: 'General',
                body: '\n                        <label for="displayGroup" class="tq-label">Display</label>\n                        <div id="displayGroup" class="tq-ui-group">\n                            <div class="tq-ui-group__select-line">\n                                <select id="tqUiOrientation" size="1" name="orientation">\n                                    <option value="left-to-right">left to right</option>\n                                    <option value="right-to-left">right to left</option>\n                                    <option value="top-to-bottom">top to bottom</option>\n                                    <option value="bottom-to-top">bottom to top</option>\n                                </select>\n                                <span> - Graph orientation</span>\n                            </div>\n                            <div class="tq-ui-group__select-line">\n                                <select id="tqUiRouting" size="1" name="routing">\n                                    <option value="metro">Metro</option>\n                                    <option value="lgrouter">RailRoad</option>\n                                    <option value="normal">Normal</option>\n                                    <option value="manhattan">Manhattan</option>\n                                </select>\n                                <span> - Link routing</span>\n                            </div>\n                            <div class="tq-ui-group__select-line">\n                                <select id="tqUiLayout" size="1" name="layout">\n                                    <option value="sankey">Sankey</option>\n                                    <option value="flow-directed">Flow-directed</option>\n                                </select>\n                                <span> - Layout algorithm</span>\n                            </div>\n                            <div class="tq-ui-group__check-box-line">\n                                <span><input id="tqUiExpandCollapse" type="checkbox"></span>\n                                <span>Expand node containers to show full text labels</span>\n                            </div>\n                            <div class="tq-ui-group__check-box-line">\n                                <span><input id="tqUiClipNodes" type="checkbox"></span>\n                                <span>Nodes trimming on borders</span>\n                            </div>\n                        </div>\n                        <label for="exportGroup" class="tq-label">Export as</label>\n                        <div id="exportGroup" class="tq-ui-group tq-ui-export-group">\n                            <button id="tqUiExportSVG" title="Export diagram to SVG" class="tq-button">SVG</button>\n                            <button id="tqUiExportPNG" title="Export diagram to PNG" class="tq-button">PNG</button>\n                            <button id="tqUiPrint" title="Print" class="tq-button">\n                                <span class="glyphicon glyphicon-print"></span>\n                            </button>\n                        </div>\n                        <label for="howToUseGroup" class="tq-label">How to use</label>\n                        <div id="howToUseGroup" class="tq-ui-group tq-ui-opt-group">\n                            <button id="tqUiHelpBtn" title="Help" class="tq-button">\n                                <span class="glyphicon glyphicon-info-sign" aria-hidden="true"></span>\n                            </button>\n                            <a class="tq-button" title="Documentation" href="./documentation/index.html">DOC</a>\n                        </div>\n                    '
            }, {
                id: 'tqUiLegends',
                label: 'Legends',
                body: new _visualizationsLibrary2.default.Legends({ legends: legends })
            }]
        })
    }]);

    // General

    var svgButton = self.rootHtml.querySelector('#tqUiExportSVG');
    var pngButton = self.rootHtml.querySelector('#tqUiExportPNG');
    var printButton = self.rootHtml.querySelector('#tqUiPrint');
    var expandCollapse = self.rootHtml.querySelector('#tqUiExpandCollapse');
    var orientation = self.rootHtml.querySelector('#tqUiOrientation');
    var routing = self.rootHtml.querySelector('#tqUiRouting');
    var layout = self.rootHtml.querySelector('#tqUiLayout');
    var clipping = self.rootHtml.querySelector('#tqUiClipNodes');
    var helpButton = self.rootHtml.querySelector('#tqUiHelpBtn');

    _lineageGram.on('current-view-changed', function (viewId) {
        svgButton.disabled = viewId !== 'lineageDiagram';
        expandCollapse.disabled = viewId !== 'lineageDiagram';
    });

    svgButton.onclick = function () {
        _lineageGram.export({
            type: 'svg',
            view: 'lineageDiagram'
        });
    };
    pngButton.onclick = function () {
        _lineageGram.export({
            type: 'png'
        });
    };
    printButton.onclick = function () {
        _lineageGram.print();
    };

    expandCollapse.onchange = function () {
        if (expandCollapse.checked) {
            _lineageGram.expandAllNodes();
        } else {
            _lineageGram.collapseAllNodes();
        }
    };

    orientation.value = _lineageGram.getOrientation();
    orientation.onchange = function () {
        _lineageGram.setOrientation(orientation.value);
    };

    routing.value = _lineageGram.getRouting();
    routing.onchange = function () {
        _lineageGram.setRouting(routing.value);
    };

    layout.value = _lineageGram.getLayoutAlgorithm();
    layout.onchange = function () {
        _lineageGram.setLayoutAlgorithm(layout.value);
    };

    helpButton.onclick = options.onPressHelp;

    clipping.checked = _lineageGram.getClipping();
    clipping.onchange = function () {
        _lineageGram.setClipping(clipping.checked);
    };

    helpButton.onclick = options.onPressHelp;
}
exports.default = OptionsPanel;

},{"../subscriptionAPI/subscribeable":66,"visualizations-library":5}],37:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Splitter = Splitter;

var _rappid = require('rappid');

var joint = _interopRequireWildcard(_rappid);

var _subscribeable = require('../subscriptionAPI/subscribeable');

var _subscribeable2 = _interopRequireDefault(_subscribeable);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @private
 * 
 * Html-UI element which manage size of two splitted windows.
 * 
 * Constructor parameters:
 * ========================================
 * @param {
 *  viewFrameA: ViewFrame,
 *  viewFrameB: ViewFrame,
 * } model
 * @param {Object} parameters - parameters set
 * 
 * Public properties:
 * ========================================
 * el: HTMLELement
 * 
 * Public methods:
 * ========================================
 * on (event: string, callback: function): void
 * unsubscribe (callback: function): void
 * trigger (event: string, parameters: any): void
 * 
 * Events:
 * ===========================================
 * @fires diff({ diff: number, lastChange: boolean })
 */
function Splitter(model, parameters) {
    // Init
    // ===================================================================
    // ===================================================================
    _subscribeable2.default.apply(this); // make this class Subscribable

    var self = this;
    var _graphOrientation = parameters.graphOrientation === 'left-to-right' || parameters.graphOrientation === 'right-to-left';
    var _visible = true;

    self.model = model;
    if (parameters.graphOrientation === 'right-to-left' || parameters.graphOrientation === 'bottom-to-top') {
        _swapViewFrames();
    }

    self.el = document.createElement('DIV');
    self.el.className = _graphOrientation ? 'tq_lineage_ui__view-frame-splitter' : 'tq_lineage_ui__view-frame-splitter-vertical';
    self.el.addEventListener('mousedown', _onmousedown);

    var start = 0;
    function _onmousedown(event) {
        event = event || window.event;
        start = 0;
        window.getSelection().removeAllRanges();

        if (_graphOrientation) {
            if (event.pageX) start = event.pageX;else if (event.clientX) start = event.clientX;
        } else {
            if (event.pageY) start = event.pageY;else if (event.clientY) start = event.clientY;
        }

        document.body.addEventListener('mousemove', _onchange);
        document.body.addEventListener('mouseup', _onmouseup);

        function _onchange(event, onMouseUp) {
            event = event || window.event;
            var end = 0;

            if (_graphOrientation) {
                if (event.pageX) end = event.pageX;else if (event.clientX) end = event.clientX;
            } else {
                if (event.pageY) end = event.pageY;else if (event.clientY) end = event.clientY;
            }

            var diff = end - start;
            start = end;
            self.trigger('splitter-position-changed', { diff: _limitDiff(diff), lastChange: onMouseUp });
        }

        function _onmouseup(event) {
            _onchange(event, true);
            document.body.onmousemove = document.body.onmouseup = null;
            document.body.removeEventListener('mousemove', _onchange);
            document.body.removeEventListener('mouseup', _onmouseup);
        }
    }

    // ===================================================================
    // ===================================================================

    self.updateNeighbour = function (newNeighbour) {
        if (self.model.viewFrameB !== newNeighbour) {
            self.model.viewFrameB = newNeighbour;
        }
    };

    self.hide = function () {
        if (_visible) {
            self.el.style.display = 'none';
            _visible = false;
        }
    };

    self.show = function () {
        if (!_visible) {
            self.el.style.display = '';
            _visible = true;
        }
    };

    function _swapViewFrames() {
        var temp = model.viewFrameA;
        model.viewFrameA = model.viewFrameB;
        model.viewFrameB = temp;
    }

    function _limitDiff(diff) {
        if (diff === 0) return;
        var vfA = self.model.viewFrameA;
        var vfB = self.model.viewFrameB;

        var sideA = void 0;
        var sideB = void 0;
        var minSideShouldBe = void 0;

        if (_graphOrientation) {
            sideA = vfA.size.width;
            sideB = vfB.size.width;
            minSideShouldBe = parameters.framePadding.x * 2 + 1;
        } else {
            sideA = vfA.size.height;
            sideB = vfB.size.height;
            minSideShouldBe = parameters.framePadding.y * 2 + 1;
        }

        var resultSideA = sideA + diff;
        var resultSideB = sideB - diff;

        var limitationA = 0;
        var limitationB = 0;
        if (resultSideA < minSideShouldBe && resultSideB < minSideShouldBe) {
            return;
        }
        if (resultSideA < minSideShouldBe) {
            limitationA = minSideShouldBe - resultSideA;
        }
        if (resultSideB < minSideShouldBe) {
            limitationB = resultSideB - minSideShouldBe;
        }
        if (limitationA !== 0 || limitationB !== 0) {
            var resultDiff = Math.abs(limitationA) > Math.abs(limitationB) ? diff + limitationA : diff + limitationB;
            var _resultSideA = sideA + resultDiff;
            var _resultSideB = sideB - resultDiff;
            if (_resultSideA < minSideShouldBe || _resultSideB < minSideShouldBe) {
                return;
            }
            return resultDiff;
        } else {
            return diff;
        }
    }
}
Splitter.prototype = Object.create(joint.shapes.basic.Rect.prototype);

exports.default = Splitter;

},{"../subscriptionAPI/subscribeable":66,"rappid":"rappid"}],38:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ViewFrameButtons = ViewFrameButtons;
/**
 * ColoredButtonModel - data model for ColoredButtons in the ColoredButtonsList
 * @typedef {Object} ColoredButtonModel
 * @property {string} id - String id
 * @property {string} label - are used for implementing tooltip and icon
 * @property {string} borderColor - Border color
 * @property {string} backgroundColor - Background color
 * @property {function} callback - Function wich will be colled on mouse click on button
*/

var uniqueId = 0;

/**
 * Class is a collection of colored buttons,
 * which use first letters of the label as an icons for the buttons.
 * (Initially it was developed as a collection of collapsed viewFrames for LineageGram)
 * @class
 * @augments TQUIElement
 * @param {LineageGram} lineageGram
 * 
 * @property {ColoredButtonModel[]} buttons - list of button models
*/
function ViewFrameButtons(parameters) {
    var self = this;
    if (!parameters) throw Error('The arguments parameters shouldn\'t be undefined!');
    if (!parameters.lineageGram) throw Error('lineageGram field is undefined!');

    self.rootHtml = _initRootElement();
    self.id = parameters.lineageGram.id || 'coloredButtons-' + uniqueId++;
    self.rootHtml.id = self.id;

    var _lineageGram = parameters.lineageGram;
    var _state = {};
    var _buttons = {};
    var _overViewFrameButton = void 0;

    _createButtons();

    _lineageGram.on('view-frame-state-changed', _updateButtons);
    _lineageGram.on('history-state-changed', _createButtons);

    function _createButtons() {
        var viewFrames = _lineageGram.getViewFrames();
        var overViewFrame = _lineageGram.getOverViewFrame();

        _state = {};
        _buttons = {};
        self.rootHtml.innerHTML = '';

        if (overViewFrame) {
            _overViewFrameButton = createButton(overViewFrame);
            _overViewFrameButton.style.borderColor = null;
            _overViewFrameButton.style.backgroundColor = null;
            _overViewFrameButton.style.color = null;
            _overViewFrameButton.classList.add('tq-ui-colored-buttons-overview');
            self.rootHtml.appendChild(_overViewFrameButton);
        }

        viewFrames.forEach(function (viewFrame) {
            if (viewFrame.id !== overViewFrame.id) {
                var htmlButton = createButton(viewFrame);
                _buttons[viewFrame.id] = htmlButton;
                self.rootHtml.appendChild(htmlButton);
            }
        });

        _updateButtons();

        function createButton(viewFrame) {
            var htmlButton = document.createElement('BUTTON');

            htmlButton.className = 'tq-ui-toolbar__button tq-ui-colored-button';

            if (viewFrame.isOverView) {
                htmlButton.classList.add('tq-ui-colored-buttons-overview');
                htmlButton.onclick = function () {
                    if (_state[viewFrame.id]) {
                        _lineageGram.setFullScreenMode(false);
                    } else {
                        _lineageGram.setFullScreenMode(true);
                    }
                };
            } else {
                htmlButton.innerHTML = '<span>' + _getShortLabel(viewFrame.label) + '</span>';
                htmlButton.style.backgroundColor = viewFrame.backgroundColor || 'white';
                htmlButton.style.borderColor = viewFrame.borderColor || 'black';
                htmlButton.style.color = viewFrame.borderColor || 'black';
                htmlButton.onclick = function () {
                    if (_state[viewFrame.id]) {
                        _lineageGram.collapseViewFrame(viewFrame.id);
                    } else {
                        _lineageGram.expandViewFrame(viewFrame.id);
                    }
                };
            }

            _state[viewFrame.id] = viewFrame.expanded;
            return htmlButton;
        }
    }

    function _updateButtons() {
        var viewFrames = _lineageGram.getViewFrames();
        var overViewFrame = _lineageGram.getOverViewFrame();

        if (overViewFrame) {
            _state[overViewFrame.id] = overViewFrame.active;
            _overViewFrameButton.innerHTML = '<span>' + (overViewFrame.active ? 'F' : 'O') + '</span>';
            if (overViewFrame.active) {
                _overViewFrameButton.title = 'Switch to Frames mode';
                self.rootHtml.classList.add('tq-ui-colored-buttons-collapsed');
            } else {
                _overViewFrameButton.title = 'Switch to single frame mode';
                self.rootHtml.classList.remove('tq-ui-colored-buttons-collapsed');
            }
        }

        viewFrames.forEach(function (viewFrame) {
            if (viewFrame.id !== overViewFrame.id) {
                _state[viewFrame.id] = viewFrame.expanded;
                updateButton(viewFrame);
            }
        });

        function updateButton(viewFrame) {
            var htmlButton = _buttons[viewFrame.id];
            if (_state[viewFrame.id]) {
                htmlButton.title = 'Collapse ' + viewFrame.label;
                htmlButton.classList.remove('tq-ui-selected');
            } else {
                htmlButton.title = 'Expand ' + viewFrame.label;
                htmlButton.classList.add('tq-ui-selected');
            }
        }
    }

    function _getShortLabel(label) {
        if (!label) return;
        var words = label.match(/[a-z'\-]+/gi);
        return words.filter(function (w) {
            return w.toLowerCase() !== 'and' && w !== '&';
        }).map(function (w) {
            return w[0];
        }).join('');
    }

    function _initRootElement() {
        var el = document.createElement('DIV');
        el.className = 'tq-ui-colored-buttons-list';
        el.innerHTML = '';
        return el;
    }
}
exports.default = ViewFrameButtons;

},{}],39:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ViewFramesUI = ViewFramesUI;

var _subscribeable = require('../subscriptionAPI/subscribeable');

var _subscribeable2 = _interopRequireDefault(_subscribeable);

var _splitter = require('./splitter');

var _splitter2 = _interopRequireDefault(_splitter);

var _lineageDiagramUtils = require('../utils/lineageDiagramUtils');

var _utils = require('../utils/utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @private
 * 
 * Manages the main view of application (View-2)
 * 
 * Constructor parameters:
 * ========================================
 * @param {
 *  rootEl: HTMLElement
 *  viewFrames: Array of ViewFrame
 * } options
 * @param {Object} parameters - parameters set
 * 
 * Public methods:
 * ========================================
 * refreshState (): void
 * updateViewFrames (viewFrames: ViewFrame[]): void
 * ----------------------------------------
 * on (event: string, callback: function): void
 * unsubscribe (callback: function): void
 * trigger (event: string, parameters: any): void
 * 
 * Events:
 * ===========================================
 * @fires view-port-position-changed (ViewFrame)
 * @fires splitter-position-changed (vf: ViewFrame, diff: { diff: number, lastChange: boolean })
 * @fires view-frame-collapsed (ViewFrame, boolean)
 */
function ViewFramesUI(options, parameters) {
    // Init
    // ===================================================================
    // ===================================================================

    _subscribeable2.default.apply(this); // make this class Subscribable

    var self = this;
    var _root = options.rootEl;

    var _orientation = parameters.graphOrientation === 'right-to-left' || parameters.graphOrientation === 'bottom-to-top';
    var _graphOrientation = parameters.graphOrientation === 'left-to-right' || parameters.graphOrientation === 'right-to-left';

    var _viewManager = options.viewManager;
    var _viewFrames = _viewManager.getViewFrames() || [];
    var _viewFramesMap = (0, _utils.arrayToMap)(_viewFrames);
    var _uiSetForViewFrames = void 0;
    var _buttons4Sets = void 0;
    var _splitters = void 0;
    var _uiBody = void 0;

    _createUI();

    // ===================================================================
    // ===================================================================

    /**
     * Refreshes a state of UI. (Change arrows states)
     */
    self.refresh = _refresh;

    /**
     * Set new view manager
     * @param {Array of ViewFrame} viewFrames
     */
    self.setViewManager = function (viewManager) {
        _viewManager = viewManager;
        _viewFrames = _viewManager.getViewFrames();
        _createUI();
    };

    /**
     * It changes orientation of the graph.
     * @param {string} orientation - Values: 'left-to-right', 'right-to-left', 'top-to-bottom', 'bottom-to-top'
     * @memberof ViewFramesUI
     * @method
     */
    self.setOrientation = function (orientation) {
        _orientation = orientation === 'right-to-left' || orientation === 'bottom-to-top';
        _graphOrientation = orientation === 'left-to-right' || orientation === 'right-to-left';
        _createUI();
    };

    /**
     * Refreshes a state of UI. (Change arrows states)
     */
    function _refresh() {
        _updateViewFrames();
        _refreshUI();
        _viewFrames.forEach(function (vf) {
            if (vf.customeSized) {
                if (vf.size.width) _uiSetForViewFrames[vf.id].style.width = vf.size.width + 'px';
                if (vf.size.height) _uiSetForViewFrames[vf.id].style.height = vf.size.height + 'px';
                _uiSetForViewFrames[vf.id].style.flexGrow = 0;
            } else {
                _uiSetForViewFrames[vf.id].style.flexGrow = vf.spaceShare;
            }
        });
    }

    function _updateViewFrames() {
        _viewFrames = _viewManager.getViewFrames();
        var vfMap = (0, _utils.arrayToMap)(_viewFrames);
        _splitters.forEach(function (splitter) {
            splitter.model.viewFrameA = vfMap[splitter.model.viewFrameA.id];
            splitter.model.viewFrameB = vfMap[splitter.model.viewFrameB.id];
        });
        _viewFramesMap = (0, _utils.arrayToMap)(_viewFrames);
    }

    /**
     * Creates html navigate buttons for the views.
     */
    function _createUI() {
        if (!_root) return;else _root.innerHTML = '';

        _uiBody = document.createElement('DIV');
        _uiBody.className = 'tq_lineage_ui';
        _root.appendChild(_uiBody);
        _splitters = [];

        _uiBody.innerHTML = '';
        _uiSetForViewFrames = {};
        _buttons4Sets = {};

        var MODIFIER = 0.5;

        if (parameters.graphOrientation === 'right-to-left') {
            _uiBody.style.flexDirection = 'row-reverse';
        } else if (parameters.graphOrientation === 'top-to-bottom') {
            _uiBody.style.flexDirection = 'column';
        } else if (parameters.graphOrientation === 'bottom-to-top') {
            _uiBody.style.flexDirection = 'column-reverse';
        } else {
            // horizontal
            _uiBody.style.flexDirection = 'row';
        }

        _viewFrames.forEach(function (vf, index, arr) {
            var viewFrameUi = document.createElement('DIV');
            viewFrameUi.id = (0, _lineageDiagramUtils.cacheIdForViewFrameUI)(vf);
            if (_orientation) {
                viewFrameUi.className = 'tq_lineage_ui_view-frame_' + parameters.graphOrientation;
            } else {
                viewFrameUi.className = 'tq_lineage_ui_view-frame_' + parameters.graphOrientation;
            }

            if (vf.customeSized) {
                if (vf.size.width) viewFrameUi.style.width = vf.size.width + 'px';
                if (vf.size.height) viewFrameUi.style.height = vf.size.height + 'px';
                viewFrameUi.style.flexGrow = 0;
            } else {
                viewFrameUi.style.flexGrow = vf.spaceShare;
            }
            _uiBody.appendChild(viewFrameUi);

            var up = document.createElement('IMG');
            up.className = 'tq_lineage_ui__button tq_lineage_ui__up-button';
            up.onclick = function () {
                var viewFrame = _viewFramesMap[vf.id];
                var curPos = viewFrame.viewPortPosition;
                self.trigger('view-port-position-changed', {
                    id: vf.id,
                    viewPortPosition: { x: curPos.x, y: curPos.y - viewFrame.size.height * MODIFIER }
                });
            };
            viewFrameUi.appendChild(up);

            var down = document.createElement('IMG');
            down.className = 'tq_lineage_ui__button tq_lineage_ui__down-button';
            down.onclick = function () {
                var viewFrame = _viewFramesMap[vf.id];
                var curPos = viewFrame.viewPortPosition;
                self.trigger('view-port-position-changed', {
                    id: vf.id,
                    viewPortPosition: { x: curPos.x, y: curPos.y + viewFrame.size.height * MODIFIER }
                });
            };
            viewFrameUi.appendChild(down);

            var left = document.createElement('IMG');
            left.className = 'tq_lineage_ui__button tq_lineage_ui__left-button';
            left.onclick = function () {
                var viewFrame = _viewFramesMap[vf.id];
                var curPos = viewFrame.viewPortPosition;
                self.trigger('view-port-position-changed', {
                    id: vf.id,
                    viewPortPosition: { x: curPos.x - viewFrame.size.width * MODIFIER, y: curPos.y }
                });
            };
            viewFrameUi.appendChild(left);

            var right = document.createElement('IMG');
            right.className = 'tq_lineage_ui__button tq_lineage_ui__right-button';
            right.onclick = function () {
                var viewFrame = _viewFramesMap[vf.id];
                var curPos = viewFrame.viewPortPosition;
                self.trigger('view-port-position-changed', {
                    id: vf.id,
                    viewPortPosition: { x: curPos.x + viewFrame.size.width * MODIFIER, y: curPos.y }
                });
            };
            viewFrameUi.appendChild(right);

            var collapse = document.createElement('IMG');
            collapse.className = 'tq_lineage_ui__button tq_lineage_ui__collapse-button';
            collapse.onclick = function () {
                self.trigger('view-frame-collapsed', { id: vf.id, expanded: false });
            };
            viewFrameUi.appendChild(collapse);

            _buttons4Sets[vf.id] = {
                up: up,
                down: down,
                left: left,
                right: right
            };

            if (index !== arr.length - 1) {
                var splitter = new _splitter2.default({
                    viewFrameA: vf,
                    viewFrameB: arr[index + 1]
                }, parameters);
                _splitters.push(splitter);
                _uiBody.appendChild(splitter.el);
                splitter.on('splitter-position-changed', function (diff) {
                    self.trigger('splitter-position-changed', [splitter, diff]);
                });
            }

            _uiSetForViewFrames[vf.id] = viewFrameUi;
        });

        _refreshUI();
    }

    /**
     * Refresh navigation buttons. Button isn't active if the viewPort can't move by this direction.
     */
    function _refreshUI() {
        if (!_root) return;
        _refreshSplittersState();

        _viewFrames.forEach(function (vf) {
            var check = (0, _lineageDiagramUtils.checkPagination)(vf);

            _uiSetForViewFrames[vf.id].style.display = vf.active ? '' : 'none';

            var up = _buttons4Sets[vf.id].up;
            var down = _buttons4Sets[vf.id].down;
            var left = _buttons4Sets[vf.id].left;
            var right = _buttons4Sets[vf.id].right;

            up.style.cursor = check.canMoveUp ? 'pointer' : 'not-allowed';
            down.style.cursor = check.canMoveDown ? 'pointer' : 'not-allowed';
            left.style.cursor = check.canMoveLeft ? 'pointer' : 'not-allowed';
            right.style.cursor = check.canMoveRight ? 'pointer' : 'not-allowed';

            up.style.opacity = check.canMoveUp ? '' : '0.03';
            down.style.opacity = check.canMoveDown ? '' : '0.03';
            left.style.opacity = check.canMoveLeft ? '' : '0.03';
            right.style.opacity = check.canMoveRight ? '' : '0.03';
        });
    }

    function _refreshSplittersState() {
        var activeFrames = _viewFrames.filter(function (vf) {
            return vf.active;
        }).sort(function (a, b) {
            var posA = a.position;
            var posB = b.position;
            if (_graphOrientation) {
                return posA.x - posB.x;
            } else {
                return posA.y - posB.y;
            }
        });
        var activeIds = activeFrames.map(function (vf) {
            return vf.id;
        });

        if (_orientation) {
            _splitters.forEach(function (splitter) {
                updateSplitter(splitter);
            });
        } else {
            for (var i = _splitters.length - 1; i >= 0; i--) {
                updateSplitter(_splitters[i]);
            }
        }

        function updateSplitter(splitter) {
            if (splitter.model.viewFrameA.active) {
                var neighbour = getNeighbour(splitter.model.viewFrameA.id);
                if (!neighbour) {
                    splitter.hide();
                } else {
                    splitter.updateNeighbour(neighbour);
                    splitter.show();
                }
            } else {
                splitter.hide();
            }
        }

        function getNeighbour(viewFrameId) {
            if (!viewFrameId) return null;
            var index = activeIds.indexOf(viewFrameId);
            if (index >= 0 && index < activeIds.length - 1) {
                return activeFrames[index + 1];
            } else {
                return null;
            }
        }
    }
}
exports.default = ViewFramesUI;

},{"../subscriptionAPI/subscribeable":66,"../utils/lineageDiagramUtils":69,"../utils/utils":70,"./splitter":37}],40:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.processData = processData;

var _lodash = require('lodash');

var _mapElements = require('./mapElements');

var _resourceProvider = require('../../data/resourceProvider');

function processData(rawData, parameters) {
    var topNodeModels = processNodes(rawData.nodes, parameters);
    var derivationMapNodes = createDiagramNodes(topNodeModels, parameters);

    var mapLinkModels = processLinks(rawData.edges, derivationMapNodes);
    // Create fake link if there are no links at all (it means we have a problem with a data)
    // ===================================
    if (mapLinkModels.length === 0 && topNodeModels.length === 2) {
        var topIds = topNodeModels.map(function (tm) {
            return tm.id;
        });
        var topViews = derivationMapNodes.filter(function (n) {
            return topIds.indexOf(n.id) !== -1;
        });
        mapLinkModels.push({
            source: topViews[0],
            target: topViews[1],
            label: ''
        });
    }
    // ===================================
    var finalLinkModels = groupLinks(mapLinkModels, parameters);
    var derivationMapLinks = finalLinkModels.map(function (model) {
        return new _mapElements.Link(model, parameters);
    });
    return {
        elements: derivationMapNodes,
        links: derivationMapLinks
    };
}
exports.default = processData;


function processLinks(rawLinks, derivationMapNodes) {
    if (!rawLinks) return [];

    var nodeMap = {};
    derivationMapNodes.forEach(function (node) {
        if (nodeMap[node.endpointId]) {
            nodeMap[node.endpointId].push(node);
        } else {
            nodeMap[node.endpointId] = [node];
        }
    });

    // const existingLinks = {};
    // rawLinks.forEach(link => {
    //     (nodeMap[link.source] || []).forEach(source => {
    //         (nodeMap[link.target] || []).forEach(target => {
    //             if (!(existingLinks[source.id] && existingLinks[source.id][target.id])) {
    //                 const finalLink = {
    //                     source: source,
    //                     target: target,
    //                     label: link.label || getLabelFromId(link.id),
    //                     typeId: link.id,
    //                 };

    //                 [source.id].concat(source.orderedPossibleIds).forEach(sourceId => {
    //                     if (!existingLinks[sourceId]) existingLinks[sourceId] = {};
    //                     [target.id].concat(target.orderedPossibleIds).forEach(targetId => {
    //                         existingLinks[sourceId][targetId] = finalLink;
    //                     });
    //                 });
    //             }
    //         });
    //     });
    // });

    // const links = [];
    // Object.keys(existingLinks).forEach(sourceId => {
    //     Object.keys(existingLinks[sourceId]).forEach(targetId => {
    //         const link = existingLinks[sourceId][targetId];
    //         if (links.indexOf(link) === -1) {
    //             links.push(link);
    //         }
    //     });
    // });

    var uniqMap = {};
    var links = [];
    rawLinks.forEach(function (link) {
        var sources = nodeMap[link.source];
        var targets = nodeMap[link.target];
        if (sources && targets) {
            var linkId = cacheFunction(link);
            if (!uniqMap[linkId]) {
                uniqMap[linkId] = link;
                sources.forEach(function (source) {
                    targets.forEach(function (target) {
                        links.push({
                            source: source,
                            target: target,
                            label: link.label || getLabelFromId(link.id),
                            typeId: link.id
                        });
                    });
                });
            }
        }
    });

    return links;

    function cacheFunction(rawLink) {
        return rawLink.source + '~#tqDMLink#~' + rawLink.target;
    }
}

function groupLinks(linkModels, parameters) {
    var groupsBySource = {};
    var groupsByTarget = {};

    linkModels.forEach(function (linkModel) {
        var typeId = linkModel.typeId || linkModel.label;
        var sourceCacheId = cacheFunction(typeId, linkModel.source.id);
        if (!groupsBySource[sourceCacheId]) {
            groupsBySource[sourceCacheId] = [];
            groupsBySource[sourceCacheId].source = linkModel.source;
            groupsBySource[sourceCacheId].label = linkModel.label;
            groupsBySource[sourceCacheId].typeId = typeId;
        }
        groupsBySource[sourceCacheId].push(linkModel);

        var targetCacheId = cacheFunction(typeId, linkModel.target.id);
        if (!groupsByTarget[targetCacheId]) {
            groupsByTarget[targetCacheId] = [];
            groupsByTarget[targetCacheId].target = linkModel.target;
            groupsByTarget[targetCacheId].label = linkModel.label;
            groupsByTarget[targetCacheId].typeId = typeId;
        }
        groupsByTarget[targetCacheId].push(linkModel);
    });

    Object.keys(groupsBySource).forEach(function (groupId) {
        var group = groupsBySource[groupId];
        var crossedElements = group.length > 1 ? group : [];
        var crossNode = new _mapElements.GraphCrossNode({ crossedElements: crossedElements });
        var sourceLink = new _mapElements.GraphLink({
            source: group.source,
            target: crossNode,
            label: group.label,
            typeId: group.typeId,
            crossedElements: crossedElements
        }, parameters);
        crossedElements.forEach(function (linkModel) {
            var targetLink = new _mapElements.GraphCrossLink({
                typeId: group.typeId,
                source: crossNode,
                target: linkModel.target,
                label: ''
            });
            linkModel.graphPrimitives = [crossNode, sourceLink, targetLink];
            linkModel.groupedBy = 'source';
        }, parameters);
    });

    Object.keys(groupsByTarget).forEach(function (groupId) {
        var group = groupsByTarget[groupId];
        var crossedElements = group.length > 1 ? group.filter(function (linkModel) {
            return !linkModel.graphPrimitives;
        }) : [];
        var crossNode = new _mapElements.GraphCrossNode({ crossedElements: crossedElements });
        var targetLink = new _mapElements.GraphCrossLink({
            source: crossNode,
            target: group.target,
            label: group.label,
            typeId: group.typeId,
            crossedElements: crossedElements
        }, parameters);
        crossedElements.forEach(function (linkModel) {
            var sourceLink = new _mapElements.GraphLink({
                typeId: group.typeId,
                source: linkModel.source,
                target: crossNode,
                label: ''
            }, parameters);
            linkModel.graphPrimitives = [crossNode, sourceLink, targetLink];
            linkModel.groupedBy = 'target';
        });
    });

    return linkModels;

    function cacheFunction(label, terminalId) {
        return label + '~#tqDMLink#~' + terminalId;
    }
}

function processNodes(rawNodes, parameters) {
    var topNodesMap = {};
    var allNodesMap = {};
    var parentMap = {};
    var res = new _resourceProvider.ResourceProvider(parameters);

    rawNodes.forEach(function (rawNode) {
        if (rawNode.id) {
            var children = parentMap[rawNode.id];
            var typeIcon = res.getIcon(rawNode.type);
            var model = allNodesMap[rawNode.id] || createModel(rawNode, children, typeIcon);
            allNodesMap[rawNode.id] = model;
            delete parentMap[rawNode.id];

            if (rawNode.parent) {
                if (allNodesMap[rawNode.parent]) {
                    allNodesMap[rawNode.parent].children.push(model);
                } else {
                    if (!parentMap[rawNode.parent]) parentMap[rawNode.parent] = [];
                    parentMap[rawNode.parent].push(model);
                }
            } else if (!topNodesMap[rawNode.id]) {
                topNodesMap[rawNode.id] = model;
            }
        }
    });

    // Process orphan nodes.
    // There were links to them but no defenitions.
    Object.keys(parentMap).forEach(function (id) {
        topNodesMap[id] = createModel({
            id: id,
            label: getLabelFromId(id),
            children: parentMap[id]
        });
    });

    var topNodes = Object.keys(topNodesMap).map(function (key) {
        return topNodesMap[key];
    });

    // remove cycles
    var processedNodesMap = {};
    function recursion(rootNode) {
        var childrenIds = {};
        rootNode.children = rootNode.children.filter(function (child) {
            if (!processedNodesMap[child.id] && !childrenIds[child.id]) {
                childrenIds[child.id] = true;
                processedNodesMap[child.id] = true;
                recursion(child);
                processedNodesMap[child.id] = false;
                return true;
            } else {
                return false;
            }
        });
    }

    return topNodes.filter(function (top) {
        if (!processedNodesMap[top.id]) {
            processedNodesMap[top.id] = true;
            recursion(top);
            processedNodesMap[top.id] = false;
            return true;
        } else {
            return false;
        }
    });
}

function createModel(rawNode, children, typeIcon) {
    return {
        id: (0, _lodash.uniqueId)('mapElement'),
        endpointId: rawNode.id,
        label: rawNode.label || getLabelFromId(rawNode.id),
        children: children || [],
        resourceType: rawNode.resourceType || 'undefined',
        resource: rawNode.resource || 'undefined',
        type: rawNode.type || 'undefined',
        collapsed: rawNode.collapsed,
        icon: rawNode.icon || typeIcon
    };
}

function createDiagramNodes(topNodeModels, parameters) {
    var derivationMapNodes = [];

    function copy(element, dublicationMap) {
        var dublication = dublicationMap || {};
        if (!dublication[element.id]) {
            var clonedElement = (0, _lodash.clone)(element);
            clonedElement.id = (0, _lodash.uniqueId)('copyOfMapElement');

            dublication[element.id] = clonedElement;
            clonedElement.children = element.children.map(function (child) {
                return copy(child, dublication);
            });
        }
        return dublication[element.id];
    }

    function createGroup(model1, model2) {
        return {
            id: (0, _lodash.uniqueId)('Group'),
            label: 'Group',
            endpointId: 'none',
            children: [model1, model2],
            synthetic: true,
            collapsed: true
        };
    }

    function addToGroup(group, model) {
        group.children.push(model);
    }

    // if there is more then one topElement for some model
    var topElementForId = {};
    var filteredTopModels = {};
    topNodeModels.forEach(function (topElement) {
        recursion(topElement);

        function recursion(curModel) {
            if (topElementForId[curModel.id]) {
                if (!topElementForId[curModel.id].synthetic && topElement.id !== topElementForId[curModel.id].id) {
                    delete filteredTopModels[topElement.id];
                    delete filteredTopModels[topElementForId[curModel.id].id];

                    topElementForId[curModel.id] = createGroup(topElementForId[curModel.id], topElement);

                    filteredTopModels[topElementForId[curModel.id].id] = topElementForId[curModel.id];
                } else {
                    addToGroup(topElementForId[curModel.id], topElement);
                }
                return copy(curModel);
            } else {
                topElementForId[curModel.id] = topElement;
                filteredTopModels[topElement.id] = topElement;
                curModel.children = curModel.children.map(function (child) {
                    return recursion(child);
                });
                return curModel;
            }
        }
    });

    Object.keys(filteredTopModels).forEach(function (topElementId) {
        var topElement = filteredTopModels[topElementId];

        var graphNode = new _mapElements.GraphNode(topElement, parameters);
        var processedNodes = {};
        recursion(topElement, []);

        function recursion(curModel, possibleIds) {
            if (!processedNodes[curModel.id]) {
                var model = (0, _lodash.cloneDeep)(curModel);
                model.orderedPossibleIds = possibleIds;
                model.graphNode = graphNode;

                processedNodes[curModel.id] = new _mapElements.Node(model, parameters);
                processedNodes[curModel.id].children = curModel.children.map(function (child) {
                    return recursion(child, possibleIds.concat([curModel.id]));
                });
                derivationMapNodes.push(processedNodes[curModel.id]);
            }
            return processedNodes[curModel.id];
        }
    });

    return derivationMapNodes;
}

function getLabelFromId(id) {
    var terms = id.split('/');
    var slashLabel = terms[terms.length - 1];
    if (slashLabel) {
        return slashLabel;
    } else {
        var hashIndex = id.indexOf('#');
        if (hashIndex !== -1) {
            var hashLabel = id.substring(hashIndex, id.length - 1);
            return hashLabel;
        } else {
            return id;
        }
    }
}

},{"../../data/resourceProvider":30,"./mapElements":43,"lodash":"lodash"}],41:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getDefaultParametersSet = getDefaultParametersSet;
exports.DerivationMap = DerivationMap;

var _visualizationsLibrary = require('visualizations-library');

var _visualizationsLibrary2 = _interopRequireDefault(_visualizationsLibrary);

var _lodash = require('lodash');

var _ = _interopRequireWildcard(_lodash);

var _dataProcessing = require('./dataProcessing');

var _dataProcessing2 = _interopRequireDefault(_dataProcessing);

var _mapElements = require('./mapElements');

var mapElements = _interopRequireWildcard(_mapElements);

var _mapLayout = require('./mapLayout');

var _dmDefaultUI = require('../../htmlUI/dmDefaultUI');

var _resourceProvider = require('../../data/resourceProvider');

var _dataUtils = require('../../utils/dataUtils');

var _subscribeable = require('../../subscriptionAPI/subscribeable');

var _subscribeable2 = _interopRequireDefault(_subscribeable);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Link style definition for DM
 * @typedef {Object} DMLinkStyleDefinition
 * @property {string} cssClass - CSS class which will be attached to the svg component
 * @property {string} lineType - 'solid' or 'dashed'
 * @property {string} color - Color of the line
 * @property {string} textColor - Color of the text on the line
 * @property {string} textBackgroundColor - Color of the background of the text on the line
 * @property {number} thickness
*/

/**
 * Set of parameters for Derivation Map
 * @typedef {Object} DerivationMapParameters
 * @property {Object.<string, LinkStyleDefinition>} linkStyles - Map between the linkTypes and LinkStyles.
 * @property {number} defaultElementWidth
 * @property {number} defaultElementHeight
 * @property {number} defaultLinkLabelLength
 * @property {number} defaultLayoutStep
 * @property {Function} errorCallBack - it is called in response to warnings and errors
*/

/**
 * Returns default set of parameters
 * @returns {DerivationMapParameters}
 */
function getDefaultParametersSet() {
    return {
        defaultElementWidth: 250,
        defaultElementHeight: 250,
        defaultLinkLabelLength: 100,
        defaultLayoutStep: 150,
        linkStyles: {
            'default-link-style': _resourceProvider.DEFAULT_DERIVATION_MAP_LINK_STYLE
            // Example:
            // 'type-id-1234': {
            //     lineType: 'dashed', // 'solid'
            //     cssClass: 'class-123'
            //     color: 'green',
            //     textColor: 'blue',
            //     textBackgroundColor: 'yellow',
            //     thickness: 5,
            // },
        },
        icons: {
            'SQL script': 'glyphicon glyphicon-cog',
            'Database Table': 'glyphicon glyphicon-folder-close'
        },
        tools: [],
        errorCallBack: undefined // It is called in response to warnings and errors
    };
}

/**
 * @private
 * @class
 * Displays derivation view for selected link
 *
 * Constructor parameters:
 * ========================================
 * @param {
 *  dataProvider: DataContainer
 *  rootElement: HTMLElement
 *  relation: { source: string, target: string }
 * } options
 * @param {DerivationMapParameters} parameters - parameters set
 *
 * Public properties:
 * ========================================
 * relation: { source: string, target: string }
 *
 * Public methods:
 * ========================================
 * openWithRelation (relation: { source: string, target: string }) - Initializes DM diagram
 * exportToSvg()
 * exportToPng()
 * resetFocus()
 * zoomIn()
 * zoomOut()
 * zoomToFit()
 * print()
 * ----------------------------------------
 * on (event: string, callback: function): void
 * unsubscribe (callback: function): void
 * trigger (event: string, parameters: any): void
 *
 * Events:
 * ========================================
 * @fires diagram-state-changed (stateId: string)
 */
function DerivationMap(properties, parameters) {
    var _this = this;

    _subscribeable2.default.apply(this);

    var defaultParameterSet = getDefaultParametersSet();
    // Merging parameters default and user
    var _parameters = _.merge(defaultParameterSet, parameters || {});

    var _errorCallback = function _errorCallback(e) {
        if (_parameters.errorCallback && _parameters.errorCallback instanceof Function) {
            var error = typeof e === 'string' ? new Error(e) : e;
            _parameters.errorCallback.call(_this, error);
        }
    };

    /**
     * State changed event - fires when DM state changes.
     * E.g. from a fetching state to a rendering state.
     * The state string identifier is returned as a parameter of the event
     * @event diagram-state-changed
     * @type {Object}
     * @property {string} state - Parameter can take the following values: 'fetching' | 'rendering' | 'completed' | 'error'
    */

    var self = this;
    var _dataProvider = properties.dataProvider;
    var _base = _createBase(properties.rootElement);

    var _layout = new _mapLayout.MapLayout({
        rootElement: _base.derivationMapRootHtml
    }, _parameters);
    var _progressScreen = new _visualizationsLibrary2.default.ProgressScreen({
        baseElement: _base.container
    });

    var _selectedElement = undefined;
    var _diagramInfo = undefined;

    // Initialization
    // ==================================================

    var _defaultUI = new _dmDefaultUI.DMDefaultUI({
        baseElement: _base.toolbar,
        infoPanel: _base.infoPanel,
        tools: _parameters.tools || null,
        derivationMap: self
    });

    if (properties.relation) {
        _openWithRelation(properties.relation);
    }

    // Public functions
    // ==================================================

    self.relation;
    self.openWithRelation = _openWithRelation;

    self.resetFocus = function () {
        _layout.zoom();
    };

    self.getSelectedElement = function () {
        return _selectedElement;
    };

    self.setSelectedElement = function (elementId) {
        var selectedELement = _layout.getNodes().find(function (el) {
            return el.id === elementId;
        });
        _setSelectedElement(selectedELement);
    };

    self.setSearchKey = function (key) {
        _layout.setSearchKey(key);
    };

    self.expandAllElements = function () {
        _layout.getNodes().forEach(function (el) {
            el.expand();
        });
    };

    self.collapseAllElements = function () {
        _layout.getNodes().forEach(function (el) {
            el.collapse();
        });
    };

    self.exportToSvg = function () {
        _layout.export({ type: 'svg' });
    };

    self.exportToPng = function () {
        _layout.export({ type: 'png' });
    };

    self.zoomIn = function () {
        _layout.zoom(0.2, { max: 4 });
    };

    self.zoomOut = function () {
        _layout.zoom(-0.2, { min: 0.2 });
    };

    self.zoomToFit = function () {
        _layout.zoom();
    };

    self.print = function () {
        _layout.print();
    };

    self.getDiagramInfo = function () {
        return _diagramInfo;
    };

    // Private functions
    // ==================================================

    function _openWithRelation(relation) {
        _setSelectedElement(undefined);
        if (relation) {
            if (!self.relation || relation.source !== self.relation.source || relation.target !== self.relation.target || relation.linkType !== self.relation.linkType) {
                _layout.clear();
                self.relation = relation;
                _setDiagramState('fetching');
                _dataProvider.relationInfo(relation).then(function (rawData) {
                    _setDiagramState('rendering');

                    (0, _dataUtils.checkDmRawData)(rawData);

                    _diagramInfo = rawData.diagramInfo;

                    var mapElements = (0, _dataProcessing2.default)(rawData, _parameters);
                    _layout.setElements(mapElements.elements.concat(mapElements.links), _diagramInfo);
                    self.resetFocus();
                    _subscribeOnElements();
                    _setDiagramState('completed');
                }).catch(function (e) {
                    var error = typeof e === 'string' ? new Error(e) : e;

                    _setDiagramState('error', error.message);
                    _errorCallback(error);

                    console.error(error.message);
                    console.error(error.stack);
                });
            } else {
                self.resetFocus();
            }
        } else {
            var errorText = 'The relation you want to use is empty!';
            var error = new Error(errorText);
            _setDiagramState('error', errorText);
            _errorCallback(error);
            throw error;
        }
    }

    function _subscribeOnElements() {
        _layout.getNodes().forEach(function (el) {
            el.on('element-click', function () {
                _setSelectedElement(el);
            });
            el.on('collapse-button-click', function () {
                var model = el.getModel();
                if (model.collapsed) {
                    el.expand();
                } else {
                    el.collapse();
                }
            });
        });

        _layout.getLinks().forEach(function (el) {
            el.on('element-click', function () {
                _setSelectedElement(el);
            });
        });
    }

    _layout.on('blank-click', function () {
        return _setSelectedElement(undefined);
    });

    function _setSelectedElement(element) {
        if (_selectedElement) _selectedElement.highlighting(false);
        _selectedElement = element;

        if (_selectedElement) _selectedElement.highlighting(true);
        _defaultUI.infoPanel.setSelectedElement(element);

        self.trigger('selected-element-changed', _getModel(element));
    }

    /**
     * Sets state of indicator
     * @private
     * @param {string} state - fetching | rendering | completed
     * @param {string} message - Custom message
     */
    function _setDiagramState(state, message) {
        self.state = state;
        if (state === 'fetching') {
            _progressScreen.setState('active', message || 'Fetching data');
        } else if (state === 'rendering') {
            _progressScreen.setState('active', message || 'Rendering graph');
        } else if (state === 'completed') {
            _progressScreen.setState('completed');
        } else if (state === 'error') {
            _progressScreen.setState('error', message || 'Error has occurred!');
        }
        self.trigger('diagram-state-changed', message || state);
    }

    function _getModel(element) {
        if (element instanceof mapElements.Node) {
            return {
                id: element.id,
                label: element.label,
                resource: element.resource,
                parent: element.parent,
                resourceType: element.resourceType,
                diagramType: 'node',
                endpointId: element.endpointId
            };
        } else if (element instanceof mapElements.Link) {
            return {
                id: element.id,
                source: element.source.endpointId,
                target: element.target.endpointId,
                diagramType: 'link',
                typeId: element.typeId
            };
        } else {
            return undefined;
        }
    }

    /**
     * Creates html markup.
     * @private
     * @param {HTMLElement} htmlNode - Root node for markup
     * @returns {Object.<string, HTMLElement>} - Map of html elements
     */
    function _createBase(htmlNode) {
        htmlNode.innerHTML = '';
        htmlNode.tabIndex = 1;

        var rowContainer = document.createElement('DIV');
        rowContainer.className = 'tq-row-container';
        htmlNode.appendChild(rowContainer);

        var baseDiv = document.createElement('DIV');
        baseDiv.className = 'tq-derivation-map';
        baseDiv.id = 'tq-derivation-map';
        rowContainer.appendChild(baseDiv);

        var derivationMapRootHtml = document.createElement('DIV');
        derivationMapRootHtml.className = 'tq-derivation-map-diagram';
        derivationMapRootHtml.id = 'tq-derivation-map-diagram';
        baseDiv.appendChild(derivationMapRootHtml);

        var progressIndication = document.createElement('DIV');
        progressIndication.className = 'tq-lg-progress-screen';
        baseDiv.appendChild(progressIndication);

        var toolbarBase = document.createElement('DIV');
        toolbarBase.className = 'tq-derivation-map__toolbar';
        toolbarBase.id = 'tq-derivation-map-toolbar';
        baseDiv.appendChild(toolbarBase);

        var infoPanel = document.createElement('DIV');
        infoPanel.className = 'tq-row-container__properties-pane';
        infoPanel.id = 'tq-properties-pane';
        rowContainer.appendChild(infoPanel);

        return {
            container: htmlNode,
            baseDiv: baseDiv,
            infoPanel: infoPanel,
            toolbar: toolbarBase,
            derivationMapRootHtml: derivationMapRootHtml,
            progress: progressIndication
        };
    }
}

exports.default = DerivationMap;

},{"../../data/resourceProvider":30,"../../htmlUI/dmDefaultUI":32,"../../subscriptionAPI/subscribeable":66,"../../utils/dataUtils":67,"./dataProcessing":40,"./mapElements":43,"./mapLayout":44,"lodash":"lodash","visualizations-library":5}],42:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.dmrouter = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _utils = require('../../utils/utils');

var _lineageDiagramUtils = require('../../utils/lineageDiagramUtils');

var ELEMENT_OFFSET = 10;

var dmrouter = exports.dmrouter = function () {
    return function (manualVertices, opts, linkView) {
        this._findConnectionPoints([]);

        return buildWay(this.sourcePoint, this.targetPoint);

        function buildWay(start, finish) {
            var elements = linkView.model.graph.getElements().map(function (el) {
                var rect = el.getBBox();
                var center = rect.center();
                return {
                    el: el,
                    rect: rect,
                    distA: (0, _utils.getDist)(center, start)
                };
            }).sort(function (a, b) {
                if (a.dist > b.dist) return -1;else if (a.dist < b.dist) return 1;else return 0;
            });
            var line = { p1: start, p2: finish };

            for (var i = 0; i < elements.length; i++) {
                var element = elements[i];
                var rect = element.rect;

                var elementSides = [{ p1: { x: rect.x, y: rect.y }, p2: { x: rect.x + rect.width, y: rect.y } }, { p1: { x: rect.x, y: rect.y }, p2: { x: rect.x, y: rect.y + rect.height } }, { p1: { x: rect.x, y: rect.y + rect.height }, p2: { x: rect.x + rect.width, y: rect.y + rect.height } }, { p1: { x: rect.x + rect.width, y: rect.y }, p2: { x: rect.x + rect.width, y: rect.y + rect.height } }];

                var intersectionPoints = elementSides.map(function (side) {
                    return (0, _lineageDiagramUtils.getCrosPoint)(line.p1, line.p2, side.p1, side.p2);
                }).filter(function (point) {
                    return point;
                });
                var intersectWithObject = intersectionPoints.length !== 0;

                if (intersectWithObject) {
                    var _ret = function () {
                        var elementPoints = [{ x: rect.x - ELEMENT_OFFSET, y: rect.y - ELEMENT_OFFSET }, { x: rect.x + rect.width + ELEMENT_OFFSET, y: rect.y - ELEMENT_OFFSET }, { x: rect.x + rect.width + ELEMENT_OFFSET, y: rect.y + rect.height + ELEMENT_OFFSET }, { x: rect.x - ELEMENT_OFFSET, y: rect.y + rect.height + ELEMENT_OFFSET }];
                        var allPoints = elementPoints.concat([start, finish]);
                        var hull = getConvexHull(allPoints);

                        var cahce = hull.map(function (p) {
                            return pointToString(p);
                        });
                        var startIndex = cahce.indexOf(pointToString(start));
                        var endIndex = cahce.indexOf(pointToString(finish));

                        var way1 = [];
                        if (startIndex !== -1 && endIndex !== -1) {
                            for (var j = startIndex; j !== endIndex; j++) {
                                if (j >= hull.length) {
                                    j = 0;
                                }
                                if (j !== startIndex && j !== endIndex) way1.push(hull[j]);
                                if (way1.length >= hull.length) break;
                            }
                            var way2 = hull.filter(function (p, i) {
                                return i !== startIndex && i !== endIndex && way1.indexOf(p) === -1;
                            });

                            way1 = correctDirection(start, way1);
                            way2 = correctDirection(start, way2);

                            var fullWay1 = [start].concat(way1).concat(finish);
                            var fullWay2 = [start].concat(way2).concat(finish);
                            var length1 = calculateWayLength(fullWay1);
                            var length2 = calculateWayLength(fullWay2);
                            var way = length1 < length2 ? way1 : way2;

                            return {
                                v: way
                            };
                        }
                    }();

                    if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
                }
            }
            return [];
        }
    };
}();

function correctDirection(start, way) {
    var firstPoint = way[0];
    var lastPoint = way[way.length - 1];

    if (way.length > 0) {
        if ((0, _utils.getDist)(firstPoint, start) > (0, _utils.getDist)(lastPoint, start)) {
            way.reverse();
        }
    }

    return way;
}

function calculateWayLength(way) {
    var length = 0;
    for (var i = 0; i < way.length - 1; i++) {
        var from = way[i];
        var to = way[i + 1];
        length += (0, _utils.getDist)(from, to);
    }
    return length;
}

function pointToString(p) {
    return '' + p.x + ':' + p.y;
}

function getConvexHull(nodes) {
    var points = [].concat(nodes);
    points.sort(function (a, b) {
        return a.x != b.x ? a.x - b.x : a.y - b.y;
    });

    var n = points.length;
    var hull = [];

    for (var i = 0; i < 2 * n; i++) {
        var j = i < n ? i : 2 * n - 1 - i;
        while (hull.length >= 2 && removeMiddle(hull[hull.length - 2], hull[hull.length - 1], points[j])) {
            hull.pop();
        }hull.push(points[j]);
    }
    hull.pop();

    var filterDublication = {};
    return hull.filter(function (p) {
        var id = getId(p);
        if (filterDublication[id]) return false;
        filterDublication[id] = p;
        return true;
    });

    function removeMiddle(a, b, c) {
        var cross = (a.x - b.x) * (c.y - b.y) - (a.y - b.y) * (c.x - b.x);
        // const dot = (a.x - b.x) * (c.x - b.x) + (a.y - b.y) * (c.y - b.y);
        return cross < 0; // || (cross == 0 && dot <= 0);
    }

    function getId(point) {
        return point.x + ':' + point.y;
    }
}

},{"../../utils/lineageDiagramUtils":69,"../../utils/utils":70}],43:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Z_INDEXES = exports.LINK_LABEL_FONT_SIZE = undefined;
exports.Node = Node;
exports.Link = Link;
exports.GraphNode = GraphNode;
exports.GraphCrossNode = GraphCrossNode;
exports.GraphLink = GraphLink;
exports.GraphCrossLink = GraphCrossLink;
exports.getPortId = getPortId;
exports.getLinkMarkerTarget = getLinkMarkerTarget;

var _rappid = require('rappid');

var joint = _interopRequireWildcard(_rappid);

var _subscribeable = require('../../subscriptionAPI/subscribeable');

var _subscribeable2 = _interopRequireDefault(_subscribeable);

var _resourceProvider = require('../../data/resourceProvider');

var _lineRouting = require('./lineRouting');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var DEFAULT_LINK_TYPE = 'derivation-link';
var MARKER_TARGET = {
    fill: 'black',
    stroke: 'black',
    d: 'M 10 0 L 0 5 L 10 10 z'
};
var LINK_LABEL_FONT_SIZE = exports.LINK_LABEL_FONT_SIZE = 16;
var Z_INDEXES = exports.Z_INDEXES = {
    NODE: 30,
    SELECTED_ELEMENT: 20,
    LINK: 15,
    BLURED_NODE: 10,
    BLURED_LINK: 5
};

joint.routers.dmrouter = _lineRouting.dmrouter;

/**
 * Node
 * @private
 * @class
 * ==========================================
 * @fires element-click
 * @fires collapse-button-click
 * @fires ports-state-changed
 * @fires element-state-changed
 * @fires position-changed
 */
function Node(options, parameters) {
    _subscribeable2.default.apply(this);

    /**
     * It fires when user click on node.
     * @event element-click
     * @type {Object}
     * @property {MouseEvent} event - origin MouseEvtnt
    */

    var self = this;
    var _graphNode = options.graphNode || new GraphNode(options.model, parameters);

    self.id = options.id;
    self.endpointId = options.endpointId;
    self.resourceType = options.resourceType;
    self.parent = options.parent;
    self.label = options.label;
    self.children = options.children;
    self.orderedPossibleIds = options.orderedPossibleIds;
    self.resource = options.resource;

    self.highlighting = function (value) {
        if (value !== undefined) {
            if (value) {
                _graphNode.setHighlightedId(self.id);
            } else if (self.id === _graphNode.highlightedId) {
                _graphNode.setHighlightedId(undefined);
            }
        }
        return _graphNode.highlightedId === self.id;
    };

    self.collapse = function () {
        _graphNode._collapseElement(self.id);
    };

    self.expand = function () {
        _graphNode._expandElement(self.id);
    };

    self.show = function () {
        // not implemented..
    };

    self.hide = function () {
        // not implemented..
    };

    self.isVisible = function () {
        return true;
    };

    self.getCells = function () {
        return [_graphNode];
    };

    self.getPort = function () {
        return {
            id: _getAvailablePortId(),
            primitive: _graphNode
        };
    };

    self.getModel = _getModel;

    self.getPortPosition = function (direction) {
        var svgObject = _graphNode.attr('.' + getPortId(_getAvailablePortId(), direction));
        var primitivePosition = self.getPort().primitive.position();
        if (svgObject) {
            return {
                x: svgObject['ref-x'] + primitivePosition.x,
                y: svgObject['ref-y'] + primitivePosition.y
            };
        } else {
            return primitivePosition;
        }
    };

    self.onPaperCellPointerDown = function () {
        // ...
    };

    _graphNode.on('ports-state-changed', function () {
        self.trigger('ports-state-changed');
    });

    _graphNode.on('elements-state-changed', function () {
        self.trigger('element-state-changed');
    });

    _graphNode.on('body-click', function (_ref) {
        var event = _ref.event,
            elementId = _ref.elementId;

        if (self.id === elementId) {
            self.trigger('element-click', event);
        }
    });

    _graphNode.on('change:position', function () {
        self.trigger('position-changed');
    });

    _graphNode.on('collapse-button-click', function (elementId) {
        if (elementId === self.id) {
            self.trigger('collapse-button-click');
        }
    });

    function _getModel() {
        return _graphNode.elementsMap[self.id];
    }

    function _getAvailablePortId() {
        var model = _getModel();
        if (!model.invisible) {
            return self.id;
        }
        for (var i = 0; i < self.orderedPossibleIds.length; i++) {
            var curId = self.orderedPossibleIds[i];
            if (_graphNode.elementsMap[curId].invisible) {
                var prevId = self.orderedPossibleIds[i - 1];
                return prevId;
            }
        }
        return self.orderedPossibleIds[self.orderedPossibleIds.length - 1];
    }
}

/**
 * Link
 * @private
 * @class
 * ==========================================
 */
function Link(options, parameters) {
    _subscribeable2.default.apply(this);

    var self = this;

    self.source = options.source;
    self.target = options.target;
    self.label = options.label;
    self.typeId = options.typeId;
    self.groupedBy = options.groupedBy; // source | target | undefined

    var _getConnectionParamet = _getConnectionParameters(),
        source = _getConnectionParamet.source,
        target = _getConnectionParamet.target;

    var primitivesAreDefined = options.graphPrimitives && options.graphPrimitives.length > 0;
    var _graphPrimitives = primitivesAreDefined ? options.graphPrimitives : [new GraphLink({
        typeId: options.typeId,
        source: source,
        target: target,
        label: _getLabel()
    }, parameters)];

    _refreshPorts();

    self.getCells = function () {
        return _graphPrimitives;
    };

    var _highlighted = false;
    self.highlighting = function (value) {
        if (value !== undefined) {
            _highlighted = value;
            _graphPrimitives.forEach(function (primitive) {
                if (value) {
                    primitive.highlight();
                } else {
                    primitive.unhighlight();
                }
            });
        }
        return _highlighted;
    };

    self.show = function () {
        _graphPrimitives.forEach(function (primitive) {
            return primitive.show();
        });
    };

    self.hide = function () {
        _graphPrimitives.forEach(function (primitive) {
            return primitive.hide();
        });
    };

    self.isVisible = function () {
        return !self.get('hidden');
    };

    self.onPaperCellPointerDown = function (cell) {
        var cellIsMyPrimitive = _graphPrimitives.indexOf(cell) !== -1;
        if (cellIsMyPrimitive) {
            self.trigger('element-click', event);
        }
    };

    self.alignCrossNode = _alignCrossNode;
    self.getCrossNode = _getCrossNode;

    function _getCrossNode() {
        var isCrossed = _graphPrimitives.length > 1;
        if (isCrossed) {
            return _graphPrimitives[0];
        } else {
            return undefined;
        }
    }

    function _alignCrossNode() {
        var crossNode = _getCrossNode();
        if (!crossNode) return;

        var crossedElements = crossNode.getCrossedElements();
        var firstCrossedElement = crossedElements[0];
        var groupedBySource = firstCrossedElement.groupedBy === 'source';
        var DEFAULT_PADDING = 30;
        var sumY = 0;
        var minX = Infinity;
        var maxX = -Infinity;

        crossedElements.forEach(function (crossedLinks) {
            var allignTo = groupedBySource ? crossedLinks.target.getPortPosition('in') : crossedLinks.source.getPortPosition('out');

            sumY += allignTo.y;
            minX = Math.min(minX, allignTo.x);
            maxX = Math.max(maxX, allignTo.x);
        });
        var xPosition = groupedBySource ? minX - DEFAULT_PADDING : maxX + DEFAULT_PADDING;
        var yPosition = sumY / crossedElements.length;
        crossNode.position(xPosition, yPosition);
    }

    function _getLabel() {
        return joint.util.breakText(self.label, {
            width: parameters.defaultLinkLabelLength
        }, { 'font-size': LINK_LABEL_FONT_SIZE });
    }

    function _refreshPorts() {
        var _getConnectionParamet2 = _getConnectionParameters(),
            targetTopId = _getConnectionParamet2.targetTopId,
            source = _getConnectionParamet2.source,
            target = _getConnectionParamet2.target;

        var sourcePrimitive = _graphPrimitives[1] || _graphPrimitives[0];
        var targetPrimitive = _graphPrimitives[2] || _graphPrimitives[0];

        var targetLinkStyle = targetPrimitive.getLinkStyle();
        if (target.id === targetTopId) {
            targetPrimitive.attr('.marker-target', getLinkMarkerTarget(targetLinkStyle));
            targetPrimitive.trigger('updateMarkers');
        } else {
            targetPrimitive.removeAttr('.marker-target');
            targetPrimitive.trigger('updateMarkers');
        }

        sourcePrimitive.prop({ source: source });
        targetPrimitive.prop({ target: target });

        _alignCrossNode();
    }

    function _getConnectionParameters() {
        var sourcePort = self.source.getPort();
        var targetPort = self.target.getPort();

        var sourcePosition = sourcePort.primitive.position();
        var targetPosition = targetPort.primitive.position();

        var reverse = sourcePosition.x > targetPosition.x;
        var source = {
            id: sourcePort.primitive.id,
            port: getPortId(sourcePort.id, reverse ? 'in' : 'out')
        };
        var target = {
            id: targetPort.primitive.id,
            port: getPortId(targetPort.id, reverse ? 'out' : 'in')
        };

        return {
            sourceTopId: sourcePort.id,
            targetTopId: targetPort.id,
            source: source,
            target: target
        };
    }

    self.source.on('element-state-changed', _refreshPorts);
    self.target.on('element-state-changed', _refreshPorts);
    self.source.on('ports-state-changed', _alignCrossNode);
    self.target.on('ports-state-changed', _alignCrossNode);
    self.source.on('position-changed', _refreshPorts);
    self.target.on('position-changed', _refreshPorts);
}

/**
 * JointNode
 * @private
 * @class
 * ==========================================
 * @fires body-click
 * @fires highlighted-id
 */
function GraphNode(model, parameters) {
    var self = this;

    /**
     * It fires when user click on node.
     * @event body-click
     * @type {Object}
     * @property {
     *  event: MouseEvent, // original mouse event
     *  elementId: string, // id of the clicked element
     * }
    */

    self.elementsMap = _getFlatElementsMap(model);
    self.model = model;
    self.scale = 1;
    self.activePorts = {};

    joint.shapes.basic.Generic.apply(self, [{
        id: model.id,
        markup: '<g class="rotatable">\n            <g class="scalable export-anchor">\n                <rect class="body"/>\n            </g>\n            ' + _portsTemplate() + '\n        </g>',
        type: 'graph-derivation-node.GraphNode',
        position: { x: 0, y: 0 },
        z: Z_INDEXES.NODE,
        size: {
            width: parameters.defaultElementWidth,
            height: parameters.defaultElementHeight
        },
        attrs: {
            rect: {
                stroke: 'transparent'
            },
            circle: {
                r: 0,
                fill: 'red'
            },
            '.dn-in-port': {
                ref: '.body',
                'ref-x': 0,
                'ref-y': 0
            },
            '.dn-out-port': {
                ref: '.body',
                'ref-x': parameters.defaultElementWidth + 20,
                'ref-y': 0
            }
        }
    }]);

    self.set('collapsed', false);
    self.sctollTop = 0;

    self.setHighlightedId = function (targetId) {
        self.highlightedId = targetId;
        var changedIds = _updateState(this.model);
        changedIds.concat(_updateVisibility(this.model));
        self.trigger('elements-state-changed', [changedIds]);
        self.prop({ z: Z_INDEXES.NODE });
    };

    self._collapseElement = function (elementId) {
        if (elementId) {
            self.elementsMap[elementId].collapsed = true;
            var changedIds = _updateVisibility(self.elementsMap[elementId]);
            changedIds.push(elementId);
            if (changedIds.length > 0) self.trigger('elements-state-changed', [changedIds]);
        } else {
            self.set('collapsed', true);
        }
    };

    self._expandElement = function (elementId) {
        if (elementId) {
            self.elementsMap[elementId].collapsed = false;
            var changedIds = _updateVisibility(self.elementsMap[elementId]);
            changedIds.push(elementId);
            if (changedIds.length > 0) self.trigger('elements-state-changed', [changedIds]);
        } else {
            self.set('collapsed', false);
        }
    };

    self.onClickCollapseButton = function (elementId) {
        self.trigger('collapse-button-click', elementId);
    };

    self.updatePorts = function () {
        self.trigger('ports-state-changed');
    };

    self.fireClickEvent = function (event, elementId) {
        self.trigger('body-click', {
            event: event,
            elementId: elementId
        });
    };

    self.getAllChildren = _getAllChildren;

    self.activePorts = {};
    self.refresh = function () {
        self.trigger('redraw-view');
    };

    self.setScale = function (scale) {
        self.scale = scale;
    };

    self.setSearchKey = function (searchKey) {
        self.searchKey = searchKey ? searchKey.toLowerCase() : undefined;

        var changedIds = _updateVisibility(this.model);
        self.trigger('elements-state-changed', [changedIds]);
    };

    function _updateState(rootModel) {
        var highlightedId = self.highlightedId;
        var changedIds = [];

        updateState(rootModel);

        return changedIds;

        function updateState(model) {
            var isSelected = model.id === highlightedId;

            var containSelectedElement = false;
            model.children.forEach(function (child) {
                containSelectedElement = updateState(child) || containSelectedElement;
            });

            var newCollapsedState = model.collapsed && !containSelectedElement;
            if (Boolean(newCollapsedState) !== Boolean(model.collapsed)) changedIds.push(model.id);
            model.collapsed = newCollapsedState;

            return isSelected || containSelectedElement;
        }
    }

    function _updateVisibility(rootModel) {
        var searchKey = self.searchKey;
        var changedIds = [];

        updateVisibility(rootModel, false);

        return changedIds;

        function updateVisibility(model, parentInvisible) {
            var notContainKey = !searchKey || model.label.toLowerCase().indexOf(searchKey) === -1;
            var invisible = parentInvisible && notContainKey;

            var noVisibleChildren = true;
            model.children.forEach(function (child) {
                noVisibleChildren = updateVisibility(child, parentInvisible || model.collapsed) && noVisibleChildren;
            });
            var newVisibiblity = invisible && noVisibleChildren;
            if (Boolean(newVisibiblity) !== Boolean(model.invisible)) changedIds.push(model.id);
            model.invisible = invisible && noVisibleChildren;

            return model.invisible;
        }
    }

    function _getAllChildren() {
        return Object.keys(self.elementsMap).map(function (id) {
            return self.elementsMap[id];
        });
    }

    function _getFlatElementsMap(model) {
        var elementsMap = {};
        recursion(model, false);
        return elementsMap;

        function recursion(element, invisible) {
            if (!elementsMap[element.id]) {
                elementsMap[element.id] = element;
                element.invisible = invisible;
                element.children.map(function (child) {
                    recursion(child, element.collapsed);
                });
            }
        }
    }

    function _portsTemplate() {
        return _getAllChildren().map(function (element) {
            var inPortId = getPortId(element.id, 'in');
            var outPortId = getPortId(element.id, 'out');

            return '\n                <circle class="dn-in-port ' + inPortId + '" port="' + inPortId + '"/>\n                <circle class="dn-out-port ' + outPortId + '" port="' + outPortId + '"/>\n            ';
        }).join('');
    }
}
GraphNode.prototype = Object.create(joint.shapes.devs.Model.prototype);

var DEFAULT_CROSS_NODE_SIZE = {
    width: 1, height: 1
};
/**
 * JointCrossNode
 * @private
 * @class
 * ==========================================
 */
function GraphCrossNode(model) {
    var self = this;

    self.model = model;
    self.hidden = false;

    joint.shapes.basic.Generic.apply(self, [{
        type: 'derivationCrossNode',
        markup: '<g class="rotatable">\n            <g class="scalable export-anchor">\n                <circle class="body"/>\n            </g>\n        </g>',
        size: DEFAULT_CROSS_NODE_SIZE,
        z: Z_INDEXES.LINK,
        attrs: {
            circle: {
                r: '5px',
                stroke: 'black',
                'stroke-width': 3
            }
        }
    }]);

    self.highlight = function () {
        self.hidden = false;
        self.prop({ z: Z_INDEXES.SELECTED_ELEMENT });
        self.set('highlighted', true);
    };

    self.unhighlight = function () {
        self.prop({ z: Z_INDEXES.LINK });
        self.set('highlighted', false);
    };

    self.show = function () {
        self.hidden = false;
        self.prop({ z: Z_INDEXES.LINK });
        self.trigger('update-state');
    };

    self.hide = function () {
        self.hidden = true;
        self.prop({ z: Z_INDEXES.BLURED_LINK });
        self.trigger('update-state');
    };

    self.getCrossedElements = function () {
        return self.model.crossedElements;
    };

    self.refresh = function () {
        self.trigger('redraw-view');
    };

    self.setScale = function (scale) {
        self.scale = scale;
    };
}
GraphCrossNode.prototype = Object.create(joint.shapes.basic.Generic.prototype);

/**
 * DMLinkModel - data model for a {@link Link} object
 * @typedef {Object} DMLinkModel
 * @property {string} typeId - Link type identifyer
 * @property {GraphNode} target - Target Node
 * @property {GraphNode} source - Source Node
 * @property {string} label - Text in the middle of the link
 * @property {string} linktype - Type of the Link
 * @property {GraphLink[]} crossedElements - in case of the link is a part of grouped links
*/

/**
 * JointLink
 * @private
 * @class
 * @param {DMLinkModel} model
 * @param {Paramters} parameters
 * ==========================================
 */
function GraphLink(model, parameters) {
    var self = this;

    self.model = model;
    self.hidden = false;

    var _res = new _resourceProvider.ResourceProvider(parameters);
    var _linkStyle = _res.getLinkStyle(model.typeId);
    var types = [DEFAULT_LINK_TYPE];

    if (_linkStyle.cssClass && _linkStyle.cssClass !== DEFAULT_LINK_TYPE) {
        types.push(_linkStyle.cssClass);
    }

    joint.dia.Link.apply(self, [{
        type: types.join(' '),
        z: Z_INDEXES.LINK,
        source: model.source,
        target: model.target,
        attrs: _getLinkAttributes(_linkStyle),
        labels: [{
            position: .5,
            attrs: {
                rect: { fill: _linkStyle.textBackgroundColor },
                text: { fill: _linkStyle.textColor, text: model.label }
            }
        }],
        connector: { name: 'rounded' },
        // connector: { name: 'jumpover', args: { type: 'gap' }},
        router: {
            name: 'dmrouter'
        }
    }]);

    self.highlight = function () {
        self.hidden = false;
        self.prop({ z: Z_INDEXES.SELECTED_ELEMENT });
        self.set('highlighted', true);
    };

    self.unhighlight = function () {
        self.prop({ z: Z_INDEXES.LINK });
        self.set('highlighted', false);
    };

    self.getLinkStyle = function () {
        return _linkStyle;
    };

    self.show = function () {
        self.hidden = false;
        self.prop({ z: Z_INDEXES.LINK });
        self.trigger('update-state');
    };

    self.hide = function () {
        self.hidden = true;
        self.prop({ z: Z_INDEXES.BLURED_LINK });
        self.trigger('update-state');
    };

    function _getLinkAttributes(linkStyle, hasArrow) {
        var attributes = {};
        attributes['.connection'] = {
            stroke: linkStyle.color,
            'stroke-width': linkStyle.thickness,
            'stroke-dasharray': linkStyle.lineType === 'solid' ? undefined : '5,5'
        };
        attributes['.marker-target'] = hasArrow ? getLinkMarkerTarget(linkStyle) : undefined;
        return attributes;
    }
}
GraphLink.prototype = Object.create(joint.dia.Link.prototype);

/**
 * JointLink
 * @private
 * @class
 * ==========================================
 */
function GraphCrossLink(model, paramters) {
    var self = this;

    self.model = model;

    GraphLink.apply(self, [model, paramters]);

    self.getCrossedElements = function () {
        return self.model.crossedElements;
    };
}
GraphCrossLink.prototype = Object.create(GraphLink.prototype);

function getPortId(portId, direction) {
    var isTarget = direction === 'in';
    return (isTarget ? 'In_' : 'Out_') + 'Port_' + encodeURI(portId);
}

function getLinkMarkerTarget(linkStyle) {
    return {
        fill: linkStyle.color,
        stroke: linkStyle.color,
        d: MARKER_TARGET.d,
        'stroke-width': linkStyle.thickness
    };
}

},{"../../data/resourceProvider":30,"../../subscriptionAPI/subscribeable":66,"./lineRouting":42,"rappid":"rappid"}],44:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MapLayout = MapLayout;

var _rappid = require('rappid');

var joint = _interopRequireWildcard(_rappid);

var _fileSaverjs = require('file-saverjs');

var _fileSaverjs2 = _interopRequireDefault(_fileSaverjs);

var _mapViews = require('./mapViews');

var _mapElements = require('./mapElements');

var _toSvg = require('../toSvg');

var _subscribeable = require('../../subscriptionAPI/subscribeable');

var _subscribeable2 = _interopRequireDefault(_subscribeable);

var _sankey = require('../../layout/sankey');

var _sankey2 = _interopRequireDefault(_sankey);

var _layout = require('../../layout/layout');

var _layoutUtils = require('../../utils/layoutUtils');

var _dataUtils = require('../../utils/dataUtils');

var _lineageDiagramUtils = require('../../utils/lineageDiagramUtils');

var _utils = require('../../utils/utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

joint.shapes['graph-derivation-node'] = {
    GraphNode: _mapElements.GraphNode,
    GraphNodeView: _mapViews.GraphNodeView
};

/**
 * Set of options for derivation map layout class.
 * @typedef {Object} DMLayoutOptions
 * @property {HTMLElement} rootElement
 * @property {string} lineType - 'solid' or 'dashed'
 * @property {string} color - Color of the line
 * @property {string} textColor - Color of the text on the line
 * @property {string} textBackgroundColor - Color of the background of the text on the line
 * @property {number} thickness
*/

/**
 * @private
 * @param {DMLayoutOptions} properties
 * @fires blank-click
 */
function MapLayout(properties, parameters) {
    _subscribeable2.default.apply(this);

    var self = this;
    var _graph = new joint.dia.Graph();
    var _startPoint = undefined;

    var _paper = new joint.dia.Paper({
        model: _graph,
        // elementView: GraphNodeView,
        linkView: _mapViews.GraphLinkView,
        gridSize: 1,
        preventContextMenu: false,
        interactive: function interactive() {
            return { vertexAdd: false };
        },
        width: 5000,
        height: 5000
    });
    var _paperScroller = new joint.ui.PaperScroller({
        paper: _paper,
        autoResizePaper: true
    });

    var _nodes = [];
    var _links = [];

    properties.rootElement.innerHTML = '';
    properties.rootElement.appendChild(_paperScroller.render().el);

    // Initialization
    // =======================================================
    // =======================================================
    // =======================================================

    /**
     * Handling multiple link situations - bends them so they don't cross
     * @private
    */

    // Just refreshes related elements on changes.
    _graph.on('change:source change:target', _refreshRelatedElement);

    _paper.on('blank:pointerdown', function (event, x, y) {
        _startPoint = { x: event.pageX, y: event.pageY };
        _paperScroller.startPanning(event, x, y);
    });
    _paper.on('blank:pointerclick', function (event) {
        if (!_startPoint) return;

        var newPoint = { x: event.pageX, y: event.pageY };
        var OFFSET_THRESHOLD = 5;
        var offsetExceedThreshold = Math.abs(newPoint.x - _startPoint.x) < OFFSET_THRESHOLD || Math.abs(newPoint.x - _startPoint.x) < OFFSET_THRESHOLD;
        if (offsetExceedThreshold) {
            self.trigger('blank-click', event);
        }
        _startPoint = undefined;
    });
    _paper.on('cell:pointerdown', function (cellView) {
        _nodes.forEach(function (el) {
            if (el.onPaperCellPointerDown) el.onPaperCellPointerDown(cellView.model);
        });
        _links.forEach(function (el) {
            if (el.onPaperCellPointerDown) el.onPaperCellPointerDown(cellView.model);
        });
    });

    var onMouseWheel = function onMouseWheel(evt, x, y, delta) {
        if (evt.ctrlKey) {
            self.zoom(0.1 * (delta < 0 ? -1 : 1), { max: 4 });
            evt.preventDefault();
        }
    };
    _paper.on('cell:mousewheel', function (cell, evt, x, y, delta) {
        return onMouseWheel(evt, x, y, delta);
    });
    _paper.on('blank:mousewheel', onMouseWheel);

    // =======================================================
    // =======================================================
    // =======================================================

    self.getNodes = function () {
        return _nodes;
    };

    self.getLinks = function () {
        return _links;
    };

    self.getGraphNodes = function () {
        return _graph.getElements();
    };

    self.getGraphLinks = function () {
        return _graph.getLinks();
    };

    self.clear = function () {
        _nodes = [];
        _links = [];
        _graph.clear();
    };

    self.zoom = function (scaleDiff, opt) {
        if (!scaleDiff) {
            _paperScroller.zoomToFit();
            _paperScroller.zoom(-0.2, { max: 2, min: 0.2 });
        } else {
            _paperScroller.zoom(scaleDiff, opt);
        }
        var newScale = _paperScroller._sx;

        _graph.getElements().forEach(function (node) {
            node.setScale(newScale);
            node.refresh();
        });
    };

    self.setElements = function (newElements, diagramInfo) {
        var newNodes = [];
        var newLinks = [];
        newElements.forEach(function (el) {
            if (el instanceof _mapElements.Node) {
                newNodes.push(el);
            } else if (el instanceof _mapElements.Link) {
                newLinks.push(el);
            }
        });

        _nodes = _nodes.concat(newNodes);
        _links = _links.concat(newLinks);

        var processedIds = {};
        var cells = [];

        newElements.forEach(function (element) {
            var elementCells = element.getCells();
            elementCells.forEach(function (cell) {
                if (!processedIds[cell.id]) {
                    processedIds[cell.id] = true;
                    cells.push(cell);
                }
            });
        });
        cells.sort(function (cell1, cell2) {
            var c1 = cell1 instanceof joint.shapes.basic.Generic ? 1 : 0;
            var c2 = cell2 instanceof joint.shapes.basic.Generic ? 1 : 0;
            return c2 - c1;
        });
        _graph.addCells(cells);

        cells.forEach(function (cell) {
            return _refreshRelatedElement(cell);
        });
        _subscribeOnElements();
        _doLayout(diagramInfo);
        setTimeout(function () {
            _doLayout(diagramInfo);
            self.zoom();
        }, 100);
    };

    /**
     * Exports graph to png or svg file
     * @param {
     *  name?: string - file name
     *  type?: string - (png/svg)
     * } options
    */
    self.export = function (options) {
        var fileName = options.name || 'DM_lineage_diagram_snapshot_' + (0, _dataUtils.date2String)(new Date());

        if (options.type === 'png') {
            (0, _toSvg.toDataURL)(_paper, {
                backgroundColor: 'white',
                svgOptions: {
                    elementsToRemoveSelector: '',
                    convertHtml: true
                }
            }).then(function (base64URL) {
                saveData(base64URL, fileName, 'png');
            }).catch(function (error) {
                if (typeof error === 'string') alert(error);else alert('This type of export is not supported in the Internet Explorer');
                console.error(error);
            });
        } else {
            (0, _toSvg.exportToSVG)(_paper, {
                elementsToRemoveSelector: '',
                convertHtml: true
            }).then(function (svgString) {
                saveData(svgString, fileName, 'svg');
            }).catch(function (error) {
                alert(error);
                console.error(error);
            });
        }

        function saveData(data, fileName, type) {
            var blob = void 0;
            if (type === 'svg') {
                blob = new Blob([data], { type: type });
            } else if (type === 'png') {
                blob = (0, _dataUtils.png2Blob)(data);
            }
            (0, _fileSaverjs2.default)(blob, fileName + '.' + type);
        }
    };

    /**
     * Shows print dialog.
    */
    self.print = function () {
        (0, _toSvg.toDataURL)(_paper, {
            backgroundColor: 'white',
            svgOptions: {
                elementsToRemoveSelector: '',
                convertHtml: true
            }
        }).then(function (base64URL) {
            var printWindow = window.open('', undefined, 'width=1280,height=720');
            if (printWindow) {
                printWindow.document.write('\n                    <html>\n                        <body>\n                            <img src="' + base64URL + '"/>\n                        </body>\n                    </html>\n                ');
                printWindow.document.querySelector('img').onload = function () {
                    printWindow.document.close();
                    printWindow.print();
                };
            } else {
                alert('You should unblock popup windows for the current url to be able to print this diagram!');
            }
        }).catch(function (error) {
            if (typeof error === 'string') alert(error);else alert('This type of export is not supported in the Internet Explorer');
            console.error(error);
        });
    };

    self.setSearchKey = function (searchKey) {
        _graph.getElements().forEach(function (node) {
            node.setSearchKey(searchKey);
        });
    };

    function _doLayout(diagramInfo) {
        // todo: refactor this algorithm
        var sourceId = diagramInfo ? diagramInfo.sourceId : undefined;
        var targetId = diagramInfo ? diagramInfo.targetId : undefined;
        var centerX = _paperScroller.options.baseWidth / 2;
        var centerY = _paperScroller.options.baseHeight / 2;

        var elements = (0, _layoutUtils.convertDMElementsToLayoutModels)(_nodes, _links);
        (0, _layout.removeCycles)(elements.nodes, elements.links);
        tqSankeyLayout(elements.nodes, elements.links, sourceId, targetId);

        var jointElements = (0, _layoutUtils.convertJointElementsToLayoutModels)(_graph.getElements(), _graph.getLinks());
        (0, _layout.removeCycles)(jointElements.nodes, jointElements.links);
        tqSankeyLayout(jointElements.nodes, jointElements.links, sourceId, targetId);

        var depthMap = (0, _utils.arrayToMap)(jointElements.nodes.map(function (je) {
            return { id: je.id, depth: je.y };
        }));

        var maxCol = -Infinity;
        elements.nodes.forEach(function (n) {
            maxCol = Math.max(n.x, maxCol);
        });

        var possibleXes = {};
        var order = {};
        elements.nodes.forEach(function (node) {
            possibleXes[node.x] = true;
        });
        var possibleColumnsList = Object.keys(possibleXes).map(function (px) {
            return Math.round(+px);
        });
        possibleColumnsList.sort(function (x1, x2) {
            if (x1 > x2) {
                return 1;
            } else if (x1 < x2) {
                return -1;
            } else {
                return 0;
            }
        }).forEach(function (x, index) {
            return order[x] = index;
        });

        var stepX = parameters.defaultElementWidth + parameters.defaultLayoutStep;
        var startPosition = centerX - stepX * (possibleColumnsList.length + 1) / 2;

        var columns = {};
        elements.nodes.forEach(function (node) {
            var originalNode = node.originalNode;
            var x = startPosition + stepX * order[Math.round(node.x)];
            if (!columns[x]) columns[x] = [];
            columns[x].push(originalNode);
        });

        var BOTTOM_MARGIN = 50;
        Object.keys(columns).forEach(function (key) {
            var column = columns[key];
            var totalHeight = 0;
            column.forEach(function (el, index) {
                var theLast = index === column.length - 1;
                var step = theLast ? 0 : BOTTOM_MARGIN;
                totalHeight += el.get('size').height + step;
            });
            column.sort(function (e1, e2) {
                var e1Depth = depthMap[e1.id] ? depthMap[e1.id].depth : 0;
                var e2Depth = depthMap[e2.id] ? depthMap[e2.id].depth : 0;

                if (e1Depth > e2Depth) {
                    return 1;
                } else if (e1Depth < e2Depth) {
                    return -1;
                } else {
                    return 0;
                }
            });
            var startY = centerY - totalHeight / 2;
            var x = +key;
            var curY = 0;
            column.forEach(function (el, index) {
                var isLast = index === column.length - 1;
                var step = isLast ? 0 : BOTTOM_MARGIN;
                el.position(x, startY + curY);
                curY += el.get('size').height + step;
            });
        });

        _paperScroller.center(centerX, centerY);

        // We hide dublications using highlighter.
        // That's why we need to be sure that nodes are
        // on the page, so we use requestAnimationFrame
        setTimeout(function () {
            _alignCrossNodes();
            _graph.getLinks().forEach(function (link) {
                _adjustAllVertices(link);
            });
            _hideDublications();
        }, 300);
    }

    // adjusting vertices
    // =============================================

    _graph.on('change:source change:target update-vertices', _adjustVertices);
    _paper.on('cell:pointerup', _adjustVertices);

    function _adjustAllVertices() {
        setTimeout(function () {
            _graph.getLinks().forEach(function (link) {
                (0, _lineageDiagramUtils.adjustVertices)(_graph, link);
            });
        }, 100);
    }

    function _adjustVertices(cell) {
        setTimeout(function () {
            (0, _lineageDiagramUtils.adjustVertices)(_graph, cell);
        }, 100);
    }

    // =============================================

    function _subscribeOnElements() {
        _nodes.forEach(function (node) {
            node.on('element-state-changed', function () {
                _adjustVertices(node.getPort().primitive);
            });
        });
    }

    function _refreshRelatedElement(cell) {
        if (cell instanceof _mapElements.GraphLink) {
            var elementsToUpdate = {};

            var link = cell;
            var prevSourceDescriptor = link.previous('source');
            var prevTargetDescriptor = link.previous('target');
            var prevSource = prevSourceDescriptor ? _graph.getCell(prevSourceDescriptor.id) : undefined;
            var prevTarget = prevTargetDescriptor ? _graph.getCell(prevTargetDescriptor.id) : undefined;

            var sourceDescriptor = link.get('source');
            var targetDescriptor = link.get('target');
            var source = _graph.getCell(sourceDescriptor.id);
            var target = _graph.getCell(targetDescriptor.id);

            if (prevSource && prevSource.activePorts) {
                elementsToUpdate[prevSource.id] = prevSource;
                var portId = prevSourceDescriptor.port;
                prevSource.activePorts[portId] = prevSource.activePorts[portId] || {};
                delete prevSource.activePorts[portId][link.id];
            }
            if (prevTarget && prevTarget.activePorts) {
                elementsToUpdate[prevTarget.id] = prevTarget;
                var _portId = prevTargetDescriptor.port;
                prevTarget.activePorts[_portId] = prevTarget.activePorts[_portId] || {};
                delete prevTarget.activePorts[_portId][link.id];
            }

            if (source.activePorts) {
                elementsToUpdate[source.id] = source;
                source.activePorts[sourceDescriptor.port] = source.activePorts[sourceDescriptor.port] || {};
                source.activePorts[sourceDescriptor.port][link.id] = link;
            }

            if (target.activePorts) {
                elementsToUpdate[target.id] = target;
                target.activePorts[targetDescriptor.port] = target.activePorts[targetDescriptor.port] || {};
                target.activePorts[targetDescriptor.port][link.id] = link;
            }

            Object.keys(elementsToUpdate).forEach(function (elId) {
                return elementsToUpdate[elId].refresh();
            });
            _hideDublications();
            _alignCrossNodes();
        }
    }

    function _alignCrossNodes() {
        var tempMap = {};
        var uniqueCrossLinks = [];
        _links.forEach(function (link) {
            var crossNode = link.getCrossNode();
            if (crossNode && !tempMap[crossNode.id]) {
                tempMap[crossNode.id] = true;
                uniqueCrossLinks.push(link);
            }
        });

        uniqueCrossLinks.forEach(function (l) {
            return l.alignCrossNode();
        });
    }

    function _hideDublications() {
        var uniqueMap = {};
        _links.forEach(function (link) {
            var typeId = /*link.typeId ||*/link.label;
            var sourcePortId = link.source.getPort().id;
            var targetPortId = link.target.getPort().id;
            var cacheKey = cacheFunction(typeId, sourcePortId, targetPortId);
            var isHighlighted = link.highlighting();
            if (isHighlighted || !uniqueMap[cacheKey]) {
                if (uniqueMap[cacheKey]) {
                    uniqueMap[cacheKey].hide();
                }
                uniqueMap[cacheKey] = link;
                link.show();
            } else {
                link.hide();
            }
        });

        function cacheFunction(label, sourcePortId, targetPortId) {
            return label + '~#tqDMLink#~' + sourcePortId + '~#tqDMLink#~' + targetPortId;
        }
    }
}
exports.default = MapLayout;


function tqSankeyLayout(nodes, links, sourceId, targetId, saveOrder) {
    var sankeyLayout = (0, _sankey2.default)().step([10, 10]).groups([{
        nodes: nodes,
        links: links
    }]).nodeWidth(1).nodeHeight(1).nodes(nodes).saveOrder(saveOrder).links(links);

    if (sourceId && targetId) {
        sankeyLayout.computeNodeBreadths = function (nodes) {
            nodes.forEach(function (node) {
                var nodeId = node.originalNode.model.resource;
                node.x = nodeId === sourceId ? 0 : nodeId === targetId ? 2 : 1;
                node.dx === 1;
            });
        };
    }
    sankeyLayout.layout(2000);
}

},{"../../layout/layout":57,"../../layout/sankey":58,"../../subscriptionAPI/subscribeable":66,"../../utils/dataUtils":67,"../../utils/layoutUtils":68,"../../utils/lineageDiagramUtils":69,"../../utils/utils":70,"../toSvg":54,"./mapElements":43,"./mapViews":45,"file-saverjs":2,"rappid":"rappid"}],45:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CSS_CLASS_NUMBER = exports.MAX_NODE_HEIGHT = undefined;
exports.GraphNodeView = GraphNodeView;
exports.GraphLinkView = GraphLinkView;

var _rappid = require('rappid');

var joint = _interopRequireWildcard(_rappid);

var _mapElements = require('./mapElements');

var _utils = require('../../utils/utils');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function GraphNodeView() {
    joint.dia.ElementView.apply(this, arguments);
}

var MAX_NODE_HEIGHT = exports.MAX_NODE_HEIGHT = 200;
var CSS_CLASS_NUMBER = exports.CSS_CLASS_NUMBER = 3;

GraphNodeView.prototype = Object.create(joint.dia.ElementView.prototype);
GraphNodeView.prototype._processedIds; // prevent cycles
GraphNodeView.prototype._scale = 1; // default scale

GraphNodeView.prototype.initialize = function () {
    var _this = this;

    joint.dia.ElementView.prototype.initialize.apply(this, arguments);
    this._processedIds = {};
    this.parts = {};

    var box = document.createElement('DIV');
    box.className = 'derivation-node';
    box.id = this.model.id;
    box.onmousedown = function (event) {
        (0, _utils.onDragStart)(event, function (diff) {
            var curPos = _this.model.position();
            _this.model.position(curPos.x + diff.x / _this._scale, curPos.y + diff.y / _this._scale);
            event.stopPropagation();
        }, function (event) {
            if (_this.model.graph) _this.model.graph.trigger('update-vertices', event);
        });
        event.stopPropagation();
    };

    this.parts['box'] = box;

    var scroller = this._createScroller();
    box.appendChild(scroller);
    this.parts['scroller'] = scroller;

    var header = this._createHeader(this.model.model);
    box.appendChild(header);
    this.parts['header'] = header;

    var body = this._createBody(this.model.model);
    box.appendChild(body);
    this.parts['body'] = body;

    var collapseButton = this._createCollapseButton();
    header.appendChild(collapseButton);
    this.parts['collapseButton'] = collapseButton;

    this.model.on('change', this._updateBox, this);
    this.model.on('remove', this._removeBox, this);
    this.model.on('redraw-view', this.debouncedRender, this);
    this.model.on('elements-state-changed', this.debouncedRender, this);
    this.model.on('ports-state-changed', this._updatePorts, this);
    this.model.on('change:collapsed', this.debouncedRender, this);

    this._update();
};

GraphNodeView.prototype.debouncer;
GraphNodeView.prototype.debouncedRender = function () {
    var _this2 = this;

    cancelAnimationFrame(this.debouncer);
    this.debouncer = requestAnimationFrame(function () {
        _this2.render();
    });
};

GraphNodeView.prototype.render = function () {
    this._processedIds = {};
    joint.dia.ElementView.prototype.render.apply(this, arguments);
    var box = this.parts['box'];
    if (this.paper) {
        this._update();
        this.paper.$el.prepend(box);
        this._updateScroller();
        return this;
    } else {
        return this;
    }
};

GraphNodeView.prototype._update = function (components) {
    var _this3 = this;

    this._updateBody();

    components = components || this.model.getAllChildren();
    components.forEach(function (model) {
        return _this3._updateModel(model);
    });

    this._updateCollapseButton();
    this._updateBox();
    this._updatePorts();
};

GraphNodeView.prototype._updateBox = function () {
    var box = this.parts['box'];

    var elementBBox = this.model.getBBox();
    var height = box.getBoundingClientRect().height / this._scale;

    box.style.width = elementBBox.width + 'px';
    this.model.resize(elementBBox.width, height);

    var x_error = elementBBox.width / 2;
    var y_error = height / 2;
    box.style.left = (elementBBox.x + x_error) * this.model.scale - x_error + 'px';
    box.style.top = (elementBBox.y + y_error) * this.model.scale - y_error + 'px';

    this._scale = this.model.scale;
    box.style.transform = 'scale(' + this._scale + ')';
};

GraphNodeView.prototype._updatePorts = function () {
    var box = this.parts['box'];
    var body = this.parts['body'];
    var freshPorts = {};
    var size = this.model.get('size');
    this.model.getAllChildren().forEach(function (element) {
        var inPortId = (0, _mapElements.getPortId)(element.id, 'in');
        var outPortId = (0, _mapElements.getPortId)(element.id, 'out');
        var htmlElement = box.querySelector('#' + element.id);

        var header = htmlElement ? htmlElement.querySelector('.dn-group_header') : undefined;
        var portHtmlElement = void 0;
        if (header) {
            portHtmlElement = header;
        } else {
            portHtmlElement = htmlElement;
        }
        if (portHtmlElement) {
            var offsetTop = getOffsetTop(portHtmlElement);
            var clientHeight = portHtmlElement.clientHeight;
            var scrollToTop = body.scrollTop;
            var minY = body.offsetTop;
            var maxY = body.clientHeight + minY;
            var middlePoint = -scrollToTop + offsetTop + clientHeight / 2;
            var refY = Math.max(Math.min(middlePoint, maxY), minY);

            freshPorts['.' + inPortId] = {
                ref: '.body',
                'ref-y': refY,
                'ref-x': 0
            };
            freshPorts['.' + outPortId] = {
                ref: '.body',
                'ref-y': refY,
                'ref-x': size.width
            };
        }
    });

    this.model.attr(freshPorts);

    function getOffsetTop(element) {
        if (element.className !== 'derivation-node') {
            return element.offsetTop + element.clientTop + (element.offsetParent ? getOffsetTop(element.offsetParent) : 0);
        } else {
            return 0;
        }
    }
};

GraphNodeView.prototype._createScroller = function () {
    var _this4 = this;

    var scroller = document.createElement('DIV');
    scroller.className = 'derivation-node_body-scroller';
    scroller.onscroll = function () {
        _this4.parts['body'].scrollTop = _this4.model.sctollTop = scroller.scrollTop;
        _this4.model.updatePorts();
    };
    var bodySize = document.createElement('DIV');
    bodySize.className = 'derivation-node_body-scroller__size';
    scroller.appendChild(bodySize);

    return scroller;
};

GraphNodeView.prototype._updateScroller = function () {
    var scroller = this.parts['scroller'];
    var body = this.parts['body'];
    var collapseButton = this.parts['collapseButton'];

    var bbox = body.firstChild.getBoundingClientRect();
    var bodyHeight = bbox.height / this._scale;
    var bodyWidth = bbox.width / this._scale;
    if (scroller.firstChild) {
        // for IE11
        scroller.firstChild.style.height = bodyHeight + 'px';
        scroller.firstChild.style.width = bodyWidth + 'px';
    }
    var exceedSize = bodyHeight <= MAX_NODE_HEIGHT;
    var isScrollable = exceedSize || !this.model.get('collapsed');
    collapseButton.style.display = exceedSize ? 'none' : null;
    scroller.style.display = isScrollable ? 'none' : null;

    body.scrollTop = this.model.sctollTop;
    scroller.scrollTop = this.model.sctollTop;
};

GraphNodeView.prototype._removeBox = function () {
    this.parts['box'].parentNode.removeChild(this.parts['box']);
    this.parts = {};
};

GraphNodeView.prototype._createBody = function (model) {
    var body = document.createElement('DIV');
    body.className = 'derivation-node_body';
    var renderedModel = this._createModel(model, 0);
    body.appendChild(renderedModel);

    return body;
};

GraphNodeView.prototype._updateBody = function () {
    var body = this.parts['body'];

    if (this.model.get('collapsed')) {
        body.style.maxHeight = MAX_NODE_HEIGHT + 'px';
    } else {
        body.style.maxHeight = null;
    }
};

GraphNodeView.prototype._createCollapseButton = function () {
    var _this5 = this;

    var collapseButton = document.createElement('IMG');
    collapseButton.className = 'derivation-node-collapse-button';
    collapseButton.onclick = function () {
        if (_this5.model.get('collapsed')) {
            _this5.model._expandElement();
        } else {
            _this5.model._collapseElement();
        }
    };

    return collapseButton;
};

GraphNodeView.prototype._updateCollapseButton = function () {
    var collapseButton = this.parts['collapseButton'];
    if (this.model.get('collapsed')) {
        collapseButton.classList.add('collapsed');
    } else {
        collapseButton.classList.remove('collapsed');
    }
};

GraphNodeView.prototype._createHeader = function (model) {
    var header = document.createElement('DIV');
    header.className = 'derivation-node_header';

    var label = document.createElement('LABEL');
    label.className = 'derivation-node_header__label';
    label.innerText = model.title || '';

    header.appendChild(label);

    return header;
};

GraphNodeView.prototype._createModel = function (model, deep) {
    if (!this._processedIds[model.id]) {
        this._processedIds[model.id] = true;

        var modelView = void 0;
        if (model.children.length > 0) {
            modelView = this._createGroup(model, deep);
        } else {
            modelView = this._createElement(model, deep);
        }
        this.parts[model.id] = modelView;
        return modelView;
    }
};

GraphNodeView.prototype._updateModel = function (model) {
    if (model.children.length > 0) {
        this._updateGroup(model);
    } else {
        this._updateElement(model);
    }
};

GraphNodeView.prototype._createGroup = function (rootModel, deep) {
    var _this6 = this;

    var icon = rootModel.icon ? '<span class="dn-header-icon"><i class="' + rootModel.icon + '"></i></span>' : '';
    var groupElement = document.createElement('div');
    var cssClass = 'derivation-node_group_' + deep % (CSS_CLASS_NUMBER + 1);
    groupElement.id = rootModel.id;
    groupElement.className = cssClass + ' dn-group';
    groupElement.innerHTML = '\n        <div class="dn-group_header">\n            <span class="dn-arrow dn__incoming-arrow">\n                <div class="dn-arrow-triangle"></div>\n            </span>\n            <img/>\n            <div class="dn-group_header__label"  title="' + (rootModel.endpointId + '(type: ' + rootModel.type + ')') + '">\n                ' + icon + '\n                <label>' + rootModel.label + '</label>\n            </div>\n            <span class="dn-arrow dn__outgoing-arrow">\n                <div class="dn-arrow-triangle"></div>\n            </span>\n        </div>\n        <ul class="derivation-node_list-of-elements"></ul>\n    ';

    var activeHeaderArea = groupElement.querySelector('.dn-group_header__label');
    activeHeaderArea.onclick = function (event) {
        _this6.model.fireClickEvent(event, groupElement.id);
        event.stopPropagation();
    };

    var children = groupElement.querySelector('.derivation-node_list-of-elements');
    rootModel.children.forEach(function (element) {
        var renderedModel = _this6._createModel(element, deep + 1);
        if (renderedModel) {
            children.appendChild(renderedModel);
        }
    });

    var collapseButton = groupElement.querySelector('.dn-group img');
    collapseButton.onclick = function (event) {
        event.stopPropagation();
        _this6.model.onClickCollapseButton(rootModel.id);
    };

    return groupElement;
};

GraphNodeView.prototype._updateGroup = function (rootModel) {
    var groupElement = this.parts[rootModel.id];

    groupElement.style.display = rootModel.invisible ? 'none' : null;
    if (rootModel.invisible) return;

    var noVisibleChildren = !rootModel.children || rootModel.children.filter(function (child) {
        return !child.invisible;
    }).length === 0;
    if (rootModel.collapsed && noVisibleChildren) {
        groupElement.classList.add('dn-collapsed');
    } else {
        groupElement.classList.remove('dn-collapsed');
    }

    if (rootModel.collapsed && noVisibleChildren) {
        groupElement.classList.add('dn-collapsed');
    } else {
        groupElement.classList.remove('dn-collapsed');
    }

    var isHighlighted = this.model.highlightedId === rootModel.id;
    if (isHighlighted) {
        groupElement.classList.add('tq-dm-highlighted');
    } else {
        groupElement.classList.remove('tq-dm-highlighted');
    }

    var htmlInPorts = groupElement.querySelector('.dn-arrow.dn__incoming-arrow');
    var htmlInTriangel = htmlInPorts.querySelector('.dn-arrow-triangle');
    var inPortId = (0, _mapElements.getPortId)(rootModel.id, 'in');
    var incomingLinksMap = this.model.activePorts[inPortId] || {};
    var activeInLinks = Object.keys(incomingLinksMap).map(function (key) {
        return incomingLinksMap[key];
    });
    var inPortVisible = activeInLinks.length > 0 && rootModel !== this.model.model;
    var needInArrow = activeInLinks && checkArrow(this.model, activeInLinks);
    htmlInPorts.style.display = inPortVisible ? null : 'none';
    htmlInTriangel.style.display = needInArrow ? null : 'none';

    var htmlOutPorts = groupElement.querySelector('.dn-arrow.dn__outgoing-arrow');
    var htmlOutTriangel = htmlOutPorts.querySelector('.dn-arrow-triangle');
    var outPortId = (0, _mapElements.getPortId)(rootModel.id, 'out');
    var outgoingLinksMap = this.model.activePorts[outPortId] || {};
    var activeOutLinks = Object.keys(outgoingLinksMap).map(function (key) {
        return outgoingLinksMap[key];
    });
    var needOutArrow = activeOutLinks && checkArrow(this.model, activeOutLinks);
    var outPortVisible = activeOutLinks.length > 0 && rootModel !== this.model.model;
    htmlOutPorts.style.display = outPortVisible ? null : 'none';
    htmlOutTriangel.style.display = needOutArrow ? null : 'none';

    var img = groupElement.querySelector('.dn-group_header img');
    img.className = rootModel.collapsed ? 'dn-collapsed' : '';

    var label = groupElement.querySelector('.dn-group_header__label label');
    label.innerHTML = getColoredLabel(rootModel.label, this.model.searchKey);
};

GraphNodeView.prototype._createElement = function (rootModel, deep) {
    var _this7 = this;

    var element = document.createElement('div');
    var icon = rootModel.icon ? '<span class="dn-header-icon"><i class="' + rootModel.icon + '"></i></span>' : '';

    element.className = 'dn-element derivation-node_element_' + deep;
    element.id = rootModel.id;
    element.onclick = function (event) {
        _this7.model.fireClickEvent(event, element.id);
        event.stopPropagation();
    };
    element.innerHTML = '\n        <span class="dn-arrow dn__incoming-arrow">\n            <div class="dn-arrow-triangle"></div>\n        </span>\n        <div class="dn-element_center">\n            ' + icon + '\n            <label title="' + (rootModel.endpointId + '(type: ' + rootModel.type + ')') + '">\n                ' + rootModel.label + '\n            </label>\n        </div>\n        <span class="dn-arrow dn__outgoing-arrow">\n            <div class="dn-arrow-triangle"></div>\n        </span>\n    ';

    return element;
};

GraphNodeView.prototype._updateElement = function (rootModel) {
    var element = this.parts[rootModel.id];

    element.style.display = rootModel.invisible ? 'none' : null;
    if (rootModel.invisible) return;

    var htmlInPorts = element.querySelector('.dn-arrow.dn__incoming-arrow');
    var htmlInTriangel = htmlInPorts.querySelector('.dn-arrow-triangle');
    var inPortId = (0, _mapElements.getPortId)(rootModel.id, 'in');
    var incomingLinksMap = this.model.activePorts[inPortId] || {};
    var activeInLinks = Object.keys(incomingLinksMap).map(function (key) {
        return incomingLinksMap[key];
    });
    var inPortVisible = activeInLinks.length > 0 && rootModel !== this.model.model;
    var needInArrow = activeInLinks && checkArrow(this.model, activeInLinks);
    htmlInPorts.style.display = inPortVisible ? null : 'none';
    htmlInTriangel.style.display = needInArrow ? null : 'none';

    var htmlOutPorts = element.querySelector('.dn-arrow.dn__outgoing-arrow');
    var htmlOutTriangel = htmlOutPorts.querySelector('.dn-arrow-triangle');
    var outPortId = (0, _mapElements.getPortId)(rootModel.id, 'out');
    var outgoingLinksMap = this.model.activePorts[outPortId] || {};
    var activeOutLinks = Object.keys(outgoingLinksMap).map(function (key) {
        return outgoingLinksMap[key];
    });
    var needOutArrow = activeOutLinks && checkArrow(this.model, activeOutLinks);
    var outPortVisible = activeOutLinks.length > 0 && rootModel !== this.model.model;
    htmlOutPorts.style.display = outPortVisible ? null : 'none';
    htmlOutTriangel.style.display = needOutArrow ? null : 'none';

    var isHighlighted = this.model.highlightedId === rootModel.id;
    if (isHighlighted) {
        element.classList.add('tq-dm-highlighted');
    } else {
        element.classList.remove('tq-dm-highlighted');
    }

    var label = element.querySelector('.dn-element_center label');
    label.innerHTML = getColoredLabel(rootModel.label, this.model.searchKey);
};

function getColoredLabel(label, key) {
    if (!key) return label;
    var lowerCaseLabel = label.toLowerCase();
    var keyIndex = lowerCaseLabel.indexOf(key);

    if (keyIndex === -1) {
        return label;
    } else if (keyIndex === 0) {
        var firstPart = label.substring(0, key.length);
        var secondPart = label.substring(key.length, label.length);
        return '<i class="tq-dm-highlighted-key">' + firstPart + '</i>' + secondPart;
    } else if (keyIndex + key.length === label.length) {
        var _firstPart = label.substring(0, keyIndex);
        var _secondPart = label.substring(keyIndex, label.length);
        return _firstPart + '<i class="tq-dm-highlighted-key">' + _secondPart + '</i>';
    } else {
        var _firstPart2 = label.substring(0, keyIndex);
        var _secondPart2 = label.substring(keyIndex, keyIndex + key.length);
        var thirdPart = label.substring(keyIndex + key.length, label.length);
        return _firstPart2 + '<i class="tq-dm-highlighted-key">' + _secondPart2 + '</i>' + thirdPart;
    }
}

/**
 * @private
 * The GraphLinkView class. Mainly in charge of link highlighting.
 * Listen to events and apply highlighters.
 * @class
 * @augments joint.dia.LinkView
 * @param {NodeModel} dataModel - Model of graph node
 * @param {Parameters} parameters - The set of parameters
*/
function GraphLinkView() {
    joint.dia.LinkView.apply(this, arguments);
}
GraphLinkView.prototype = Object.create(joint.dia.LinkView.prototype);
GraphLinkView.prototype.initialize = function () {
    joint.dia.LinkView.prototype.initialize.apply(this, arguments);
    this.listenTo(this.model, 'change:highlighted change:blured update-state', onEvent);
    this.listenTo(this.model, 'updateMarkers', this.updateMarkers);
};

GraphLinkView.prototype.updateMarkers = function () {
    this._markerCache = {};
    this.render();
};

GraphLinkView.prototype.render = function () {
    joint.dia.LinkView.prototype.render.apply(this, arguments);
};

var LG_DM_CELL_HIGHLIGHTER = {
    highlighter: {
        name: 'addClass',
        options: {
            className: 'tq-dm-highlighted'
        }
    }
};
var LG_DM_CELL_BLURER = {
    highlighter: {
        name: 'addClass',
        options: {
            className: 'tq-dm-blured'
        }
    }
};

var LG_DM_CELL_HIDDEN = {
    highlighter: {
        name: 'addClass',
        options: {
            className: 'tq-dm-hidden'
        }
    }
};

function onEvent() {
    if (this.model.get('highlighted')) {
        this.highlight(null, LG_DM_CELL_HIGHLIGHTER);
    } else {
        this.unhighlight(null, LG_DM_CELL_HIGHLIGHTER);
    }
    if (this.model.get('blured')) {
        this.highlight(null, LG_DM_CELL_BLURER);
    } else {
        this.unhighlight(null, LG_DM_CELL_BLURER);
    }
    if (this.model.hidden) {
        this.highlight(null, LG_DM_CELL_HIDDEN);
    } else {
        this.unhighlight(null, LG_DM_CELL_HIDDEN);
    }
}

function checkArrow(self, links) {
    for (var i = 0; i < links.length; i++) {
        var link = links[i];

        if (link.get('target').id === self.id) {
            return true;
        }
    }
    return false;
}

},{"../../utils/utils":70,"./mapElements":43,"rappid":"rappid"}],46:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AspectLink = AspectLink;

var _rappid = require('rappid');

var joint = _interopRequireWildcard(_rappid);

var _resourceProvider = require('../../data/resourceProvider');

var _elements = require('./elements');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @private
 * AspectLinkModel - data model of an AspectLink object
 * @typedef {Object} AspectLinkModel
 * @property {Node | TerminationNode} target - Target Node
 * @property {Node | TerminationNode} source - Source Node
*/

/**
 * @private
 * The graph Link based on joint.dia.Link.
 * @class
 * @augments joint.dia.Link
 * @param {AspectLinkModel} options
 * @param {Parameters} parameters - The set of parameters
 * @property {SimpleLinkModel} model - Data model 
*/
function AspectLink(options, parameters) {
    var self = this;

    var _res = new _resourceProvider.ResourceProvider(parameters);

    var source = { id: options.source.id, port: 'clipRectPort' };
    var target = { id: options.target.id, port: 'clipRectPort' };

    var linkColor = _res.getColor('aspectLink');

    joint.dia.Link.apply(self, [{
        id: options.id,
        type: 'aspect-link',
        source: source,
        target: target,
        z: _elements.Z_INDEXES.ASPECT_LINK,
        attrs: {
            '.connection': {
                stroke: linkColor,
                'stroke-dasharray': '10, 10',
                'stroke-width': '5px'
            },
            '.marker-source': {
                fill: linkColor,
                stroke: linkColor,
                d: 'M0,3a3,3 0 1,0 6,0a3,3 0 1,0 -6,0'
            },
            '.marker-target': {
                fill: linkColor,
                stroke: linkColor,
                d: 'M0,3a3,3 0 1,0 6,0a3,3 0 1,0 -6,0'
            }
        },
        // variants for the experimenting
        connector: { name: 'rounded' }
    }]);

    /**
     * Blurs the AspectLink.
     * @memberof AspectLink
     * @method
    */
    self.blure = function () {
        self.set('blured', true);
    };

    /**
     * Removes blur from the AspectLink.
     * @memberof AspectLink
     * @method
    */
    self.unblure = function () {
        self.set('blured', false);
    };

    /**
     * Hides the AspectLink.
     * @memberof AspectLink
     * @method
    */
    self.hide = function () {
        self.set('hidden', true);
    };

    /**
     * Shows the AspectLink.
     * @memberof AspectLink
     * @method
    */
    self.show = function () {
        self.set('hidden', false);
    };

    self.model = { source: options.source.id, target: options.target.id };
}
AspectLink.prototype = Object.create(joint.dia.Link.prototype);

},{"../../data/resourceProvider":30,"./elements":47,"rappid":"rappid"}],47:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Z_INDEXES = exports.AspectLink = exports.TerminationLink = exports.TerminationNode = exports.Link = exports.Node = undefined;
exports.NodeView = NodeView;
exports.LinkView = LinkView;

var _rappid = require('rappid');

var joint = _interopRequireWildcard(_rappid);

var _lodash = require('lodash');

var _ = _interopRequireWildcard(_lodash);

var _node = require('./node');

var _link = require('./link');

var _terminationLink = require('./terminationLink');

var _terminationNode = require('./terminationNode');

var _aspectLink = require('./aspectLink');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

exports.Node = _node.Node;
exports.Link = _link.Link;
exports.TerminationNode = _terminationNode.TerminationNode;
exports.TerminationLink = _terminationLink.TerminationLink;
exports.AspectLink = _aspectLink.AspectLink;


var V = joint.V;
var g = joint.g;

var Z_INDEXES = exports.Z_INDEXES = {
    ASPECT_LINK: 25,
    TERMINATION_ELEMENT: 25,
    SELECTED_ELEMENT: 30,
    NODE: 20,
    LINK: 15,
    BLURED_NODE: 10,
    BLURED_LINK: 5,
    VIEW_FRAME: 1
};

var LG_CELL_HIGHLIGHTER = {
    highlighter: {
        name: 'addClass',
        options: {
            className: 'tq-lg-highlighted'
        }
    }
};
var LG_CELL_HIDDEN = {
    highlighter: {
        name: 'addClass',
        options: {
            className: 'tq-lg-hidden-element'
        }
    }
};
var LG_CELL_BLURER = {
    highlighter: {
        name: 'addClass',
        options: {
            className: 'tq-lg-blured'
        }
    }
};
var LG_SHORT_LABEL = {
    highlighter: {
        name: 'addClass',
        options: {
            className: 'tq-lg-short-label'
        }
    }
};
var LG_DRAGGED_NODE = {
    highlighter: {
        name: 'addClass',
        options: {
            className: 'tq-lg-dragged-node'
        }
    }
};

function getClass() {
    if (this.model.get('highlighted')) {
        this.highlight(null, LG_CELL_HIGHLIGHTER);
    } else {
        this.unhighlight(null, LG_CELL_HIGHLIGHTER);
    }
    if (this.model.get('blured')) {
        this.highlight(null, LG_CELL_BLURER);
    } else {
        this.unhighlight(null, LG_CELL_BLURER);
    }
    if (this.model.get('hidden')) {
        this.highlight(null, LG_CELL_HIDDEN);
    } else {
        this.unhighlight(null, LG_CELL_HIDDEN);
    }
    if (this.model.get('short-label')) {
        this.highlight(null, LG_SHORT_LABEL);
    } else {
        this.unhighlight(null, LG_SHORT_LABEL);
    }
    if (this.model.get('dragged')) {
        this.highlight(null, LG_DRAGGED_NODE);
    } else {
        this.unhighlight(null, LG_DRAGGED_NODE);
    }
}

/**
 * @private
 * The LinkView class. Mainly in charge of node highlighting.
 * Listen to events and apply highlighters.
 * @class
 * @augments joint.dia.LinkView
 * @param {NodeModel} dataModel - Model of graph node
 * @param {ver} parameters - The set of parameters
*/
function NodeView() {
    joint.dia.ElementView.apply(this, arguments);
}
NodeView.prototype = Object.create(joint.dia.ElementView.prototype);
NodeView.prototype.initialize = function () {
    joint.dia.ElementView.prototype.initialize.apply(this, arguments);
    this.listenTo(this.model, ['change:dragged', 'change:highlighted', 'change:blured', 'change:hidden', 'refresh-highlighting', 'change:short-label'].join(' '), this.debouncedHighlighting);
};
NodeView.prototype.debouncer;
NodeView.prototype.debouncedHighlighting = function () {
    var _this = this;

    cancelAnimationFrame(this.debouncer);
    this.debouncer = requestAnimationFrame(function () {
        getClass.call(_this);
    });
};

/**
 * @private
 * The LinkView class. Mainly in charge of link highlighting.
 * Listen to events and apply highlighters.
 * @class
 * @augments joint.dia.LinkView
 * @param {NodeModel} dataModel - Model of graph node
 * @param {Parameters} parameters - The set of parameters
*/
function LinkView() {
    joint.dia.LinkView.apply(this, arguments);
}
LinkView.prototype.render = function () {
    joint.dia.LinkView.prototype.render.apply(this, arguments);
};
LinkView.prototype = Object.create(joint.dia.LinkView.prototype);
LinkView.prototype.initialize = function () {
    joint.dia.LinkView.prototype.initialize.apply(this, arguments);

    this.listenTo(this.model, ['change:highlighted', 'change:blured', 'change:hidden', 'refresh-highlighting'].join(' '), this.debouncedHighlighting);
};
LinkView.prototype.getPointAtLength = function (k) {
    return this._V.connection.node.getPointAtLength(this._V.connection.node.getTotalLength() * k);
};
LinkView.prototype.debouncer;
LinkView.prototype.debouncedHighlighting = function () {
    var _this2 = this;

    cancelAnimationFrame(this.debouncer);
    this.debouncer = requestAnimationFrame(function () {
        getClass.call(_this2);
    });
};
LinkView.prototype.updateToolsPosition = function () {
    var _this3 = this;

    if (!this._V.linkTools) return this;

    // Move the tools a bit to the target position but don't cover the `sourceArrowhead` marker.
    // Note that the offset is hardcoded here. The offset should be always
    // more than the `this.$('.marker-arrowhead[end="source"]')[0].bbox().width` but looking
    // this up all the time would be slow.

    var scale = '';
    var connectionLength = this.getConnectionLength();

    // Firefox returns connectionLength=NaN in odd cases (for bezier curves).
    // In that case we won't update tools position at all.
    if (!_.isNaN(connectionLength)) {

        // If the link is too short, make the tools half the size and the offset twice as low.
        if (connectionLength < this.options.shortLinkLength) {
            scale = 'scale(.5)';
        }

        this._toolCache.forEach(function (tool, index, arr) {
            var i = index + 1;
            var l = arr.length + 1;
            var k = i / l;
            var toolPosition = _this3.getPointAtLength(k);
            if (tool.node instanceof SVGGElement) {
                tool.attr('transform', 'translate(' + toolPosition.x + ', ' + toolPosition.y + ') ' + scale);

                if (_this3.options.doubleLinkTools && connectionLength >= _this3.options.longLinkLength) {
                    var newPosition = _this3.getPointAtLength(k /*connectionLength - doubleLinkToolsOffset*/);
                    _this3._tool2Cache.attr('transform', 'translate(' + newPosition.x + ', ' + newPosition.y + ') ' + scale);
                    _this3._tool2Cache.attr('visibility', 'visible');
                } else if (_this3.options.doubleLinkTools) {
                    _this3._tool2Cache.attr('visibility', 'hidden');
                }
            }
        });
    }

    return this;
};

LinkView.prototype.renderTools = function () {

    if (!this._V.linkTools) return this;

    // Tools are a group of clickable elements that manipulate the whole link.
    // A good example of this is the remove tool that removes the whole link.
    // Tools appear after hovering the link close to the `source` element/point of the link
    // but are offset a bit so that they don't cover the `marker-arrowhead`.

    var htmlTools = this._V.linkTools.node;
    var toolTemplate = joint.util.template(this.model.get('toolMarkup') || this.model.toolMarkup);
    var vTools = V(toolTemplate());

    var tools;
    if (vTools instanceof Array) {
        tools = vTools;
    } else {
        tools = [vTools];
    }

    tools.forEach(function (tool) {
        htmlTools.appendChild(tool.node);
    });

    // Cache the tool node so that the `updateToolsPosition()` can update the tool position quickly.
    this._toolCache = tools;

    return this;
};

var overridedFunction = LinkView.prototype.getConnectionPoint;
LinkView.prototype.getConnectionPoint = function (end, selectorOrPoint, referenceSelectorOrPoint) {
    var connectionPoint = overridedFunction.apply(this, arguments);

    var limitBox = void 0;
    _.isEmpty(selectorOrPoint) && (selectorOrPoint = { x: 0, y: 0 });
    _.isEmpty(referenceSelectorOrPoint) && (referenceSelectorOrPoint = { x: 0, y: 0 });

    if (!selectorOrPoint.id) {
        var point = g.point(selectorOrPoint);
        limitBox = {
            x: point.x,
            y: point.y,
            width: 0,
            height: 0,
            center: function center() {
                return point;
            }
        };
    } else {
        limitBox = end === 'source' ? this.sourceBBox : this.targetBBox;
    }
    var limitCeter = limitBox.center();

    var rightBorder = Math.round(limitCeter.x + limitBox.width / 2);
    var leftBorder = Math.round(limitCeter.x - limitBox.width / 2);
    var bottomBorder = Math.round(limitCeter.y + limitBox.height / 2);
    var topBorder = Math.round(limitCeter.y - limitBox.height / 2);

    var xInside = leftBorder < connectionPoint.x && connectionPoint.x < rightBorder;
    var yInside = topBorder < connectionPoint.y && connectionPoint.y < bottomBorder;
    var isInTheBody = xInside && yInside;

    if (isInTheBody) {
        var rightDist = rightBorder - connectionPoint.x;
        var leftDist = connectionPoint.x - leftBorder;
        var bottomDist = bottomBorder - connectionPoint.y;
        var topDist = connectionPoint.y - topBorder;

        var minDist = Math.min(rightDist, leftDist, bottomDist, topDist);

        if (rightDist === minDist) {
            connectionPoint.offset(rightDist, 0);
        } else if (leftDist === minDist) {
            connectionPoint.offset(-leftDist, 0);
        } else if (topDist === minDist) {
            connectionPoint.offset(0, -topDist);
        } else if (bottomDist === minDist) {
            connectionPoint.offset(0, bottomDist);
        }
    }

    var reference = void 0;
    var spotBbox = end === 'source' ? this.sourceBBox : this.targetBBox;
    if (!referenceSelectorOrPoint.id) {
        reference = g.point(referenceSelectorOrPoint);
    } else {
        var referenceBbox = end === 'source' ? this.targetBBox : this.sourceBBox;

        reference = g.rect(referenceBbox).intersectionWithLineFromCenterToPoint(g.rect(spotBbox).center());
        reference = reference || g.rect(referenceBbox).center();
    }

    var alignX = Math.abs(reference.x - connectionPoint.x);
    var alignY = Math.abs(reference.y - connectionPoint.y);

    var routerId = this.model.get('router') && this.model.get('router').name;
    var specialRouter = routerId && (routerId === 'lgrouter' || routerId === 'metro');
    if (this.model instanceof _link.Link && specialRouter) {
        if (alignX <= alignY) {
            connectionPoint.offset(reference.x - connectionPoint.x, 0);
        } else {
            connectionPoint.offset(0, reference.y - connectionPoint.y);
        }
    }

    connectionPoint = g.point({
        x: Math.max(Math.min(Math.round(connectionPoint.x), rightBorder), leftBorder),
        y: Math.max(Math.min(Math.round(connectionPoint.y), bottomBorder), topBorder)
    });

    return connectionPoint;
};

},{"./aspectLink":46,"./link":48,"./node":49,"./terminationLink":50,"./terminationNode":51,"lodash":"lodash","rappid":"rappid"}],48:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ALWAYS_VISIBLE_TOOL_BUTTONS = exports.DEFAULT_LINK_TYPE = undefined;
exports.Link = Link;

var _rappid = require('rappid');

var joint = _interopRequireWildcard(_rappid);

var _resourceProvider = require('../../data/resourceProvider');

var _elements = require('./elements');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var DEFAULT_LINK_TYPE = exports.DEFAULT_LINK_TYPE = 'lineage-gram-link';
var ALWAYS_VISIBLE_TOOL_BUTTONS = exports.ALWAYS_VISIBLE_TOOL_BUTTONS = 'lg-visible-tool-buttons';

/**
 * LinkModel - data model for a {@link Link} object
 * @typedef {Object} LinkModel
 * @property {string} id - Link identifyer
 * @property {string} target - Target Node id
 * @property {string} source - Source Node id
 * @property {string} linktype - Type of the Link
*/

/**
 * The graph Link class which is  based on joint.dia.Link. Is the one of the main elements of the LineageFram.
 * Represents existing relation of the parts of the dataset.  Has specific type and id.
 * @class
 * @private
 * @augments joint.dia.Link
 * 
 * @param {LinkModel} dataModel - Data model
 * @param {Parameters} parameters - The set of parameters
 * 
 * @property {LinkModel} model - Data model
 * @property {TerminationLink} terminationLink - Termination link which
 * represents this link, when the node is out of the viewFrame
 * @property {boolean} highlighted - Tells wheter highlighted link or not (use method get to get this property, e.g. link.get('highlighted'))
 * @property {boolean} blured - Tells wheter blured link or not (use method get to get this property, e.g. link.get('blured'))
*/
function Link(dataModel, parameters) {
    var self = this;
    var _res = new _resourceProvider.ResourceProvider(parameters);

    self.terminationLinks = [];
    self.highlighted = false;
    self.blured = false;

    var _linkStyle = void 0;
    var _toolMarkup = void 0;
    if (dataModel.group) {
        var existedTypeIds = [];
        var groupTools = dataModel.group.filter(function (model) {
            var decision = existedTypeIds.indexOf(model.linkType) === -1;
            if (decision) {
                existedTypeIds.push(model.linkType);
            }
            return decision;
        }).map(function (model) {
            return {
                linkType: model.linkType,
                linkStyle: _res.getLinkStyle(model.linkType)
            };
        });

        if (groupTools.length === 1) _linkStyle = groupTools[0].linkStyle;else _linkStyle = _res.getLinkStyle(dataModel.linkType);
        _toolMarkup = _getToolMarkup(groupTools);
    } else {
        _linkStyle = _res.getLinkStyle(dataModel.linkType);
        _toolMarkup = _getToolMarkup([{
            linkType: dataModel.linkType,
            linkStyle: _linkStyle
        }]);
    }

    var types = [DEFAULT_LINK_TYPE];
    if (_linkStyle.cssClass && _linkStyle.cssClass !== DEFAULT_LINK_TYPE) {
        types.push(_linkStyle.cssClass);
    }

    if (_linkStyle.toolButton.alwaysVisible) {
        types.push(ALWAYS_VISIBLE_TOOL_BUTTONS);
    }

    joint.dia.Link.apply(self, [{
        type: types.join(' '),
        source: { id: dataModel.source, port: 'clipRectPort' },
        target: { id: dataModel.target, port: 'clipRectPort' },
        z: _elements.Z_INDEXES.LINK,
        attrs: _getLinkAttributes(_linkStyle),
        connector: { name: 'rounded' },
        // connector: { name: 'jumpover', args: { type: 'gap' }},
        router: {
            name: dataModel.routing,
            args: {
                excludeTypes: ['viewFrame', 'terminationLink', 'terminationNode', 'view-frame-splitter', 'view-frame-splitter-vertical', 'aspectLink'],
                maximumLoops: 3000,
                maxAllowedDirectionChange: 3000
            }
        },
        toolMarkup: _toolMarkup
    }]);

    function _getLinkAttributes(linkStyle) {
        var attributes = {};
        attributes['.connection'] = {
            stroke: linkStyle.color,
            'stroke-width': linkStyle.thickness,
            'stroke-dasharray': linkStyle.lineType === 'solid' ? undefined : '5,5'
        };
        if (linkStyle.hasArrow) {
            attributes['.marker-source'] = {
                fill: linkStyle.color,
                stroke: linkStyle.color,
                d: 'M0,3a3,3 0 1,0 6,0a3,3 0 1,0 -6,0',
                'stroke-width': linkStyle.thickness
            };
            attributes['.marker-target'] = {
                fill: linkStyle.color,
                stroke: linkStyle.color,
                d: 'M 10 0 L 0 5 L 10 10 z',
                'stroke-width': linkStyle.thickness
            };
        }
        return attributes;
    }

    function _getToolMarkup(linkTools) {
        return linkTools.map(function (linkTool) {
            var linkTypeId = linkTool.linkType;
            var tool = linkTool.linkStyle.toolButton;
            var width = tool.width || 30;
            var hieght = tool.hieght || 30;
            return '<g class="link-tool">\n                <g class="tool-options" event="link:options" linkType="' + linkTypeId + '">\n                    <image\n                        width="' + width + '"\n                        height="' + hieght + '"\n                        x="-' + width / 2 + '"\n                        y="-' + hieght / 2 + '"\n                        xlink:href="' + tool.image + '"\n                        onerror="this.setAttribute( \'xlink:href\', \'' + _res.getImage('default-link-options') + '\' );"\n                    />\n                    <title>Open derivation map' + (linkTypeId ? ' for ' + linkTypeId : '') + '</title>\n                </g>\n            </g>';
        }).join();
    }

    /**
     * Tells us whether the link is currently
     * on the graph (in the any of view frames) or not
     * @returns {boolena}
     */
    self.isOnTheGraph = function () {
        return self.graph ? true : false;
    };

    /**
     * Highlights the Link.
     * @memberof Link
     * @method
    */
    self.select = function () {
        self.terminationLinks.forEach(function (tl) {
            return tl.select(true);
        });
        if (self.get('blured')) self.unblure();
        if (self.get('hidden')) self.show();
        self.prop({ z: _elements.Z_INDEXES.SELECTED_ELEMENT });
        self.set('highlighted', true);
    };

    /**
     * Removes highlighting from the Link.
     * @memberof Link
     * @method
    */
    self.unselect = function () {
        self.terminationLinks.forEach(function (tl) {
            return tl.unselect(true);
        });
        self.prop({ z: _elements.Z_INDEXES.LINK });
        self.set('highlighted', false);
    };

    /**
     * Blurs the Link.
     * @memberof Link
     * @method
    */
    self.blure = function () {
        if (self.get('highlighted')) return;
        self.terminationLinks.forEach(function (tl) {
            return tl.blure(true);
        });
        self.prop({ z: _elements.Z_INDEXES.BLURED_LINK });
        self.set('blured', true);
    };

    /**
     * Removes blur from the Link.
     * @memberof Link
     * @method
    */
    self.unblure = function () {
        self.terminationLinks.forEach(function (tl) {
            return tl.unblure(true);
        });
        self.prop({ z: _elements.Z_INDEXES.LINK });
        self.set('blured', false);
    };

    /**
     * Hides the Link.
     * @memberof Link
     * @method
    */
    self.hide = function () {
        self.terminationLinks.forEach(function (tl) {
            return tl.hide(true);
        });
        self.set('hidden', true);
    };

    /**
     * Shows the Link.
     * @memberof Link
     * @method
    */
    self.show = function () {
        self.terminationLinks.forEach(function (tl) {
            return tl.show(true);
        });
        self.set('hidden', false);
    };

    /**
     * Refreshes highlighters of the view of this element.
     * @memberof Link
     * @method
    */
    self.refreshHighlighting = function () {
        self.trigger('refresh-highlighting', self);
    };

    self.model = dataModel;
}
Link.prototype = Object.create(joint.dia.Link.prototype);

},{"../../data/resourceProvider":30,"./elements":47,"rappid":"rappid"}],49:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EXPANDED_NODE_GROWING = exports.FONT_SIZE = exports.IMG_PADDING = exports.BODY_PADDING = exports.LABEL_LINE_HEIGHT = exports.LABEL_TOP_BOTTOM_PADDING = exports.LABEL_LEFT_RIGHT_PADDING = undefined;
exports.Node = Node;

var _rappid = require('rappid');

var joint = _interopRequireWildcard(_rappid);

var _lodash = require('lodash');

var _resourceProvider = require('../../data/resourceProvider');

var _elements = require('./elements');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var LABEL_LEFT_RIGHT_PADDING = exports.LABEL_LEFT_RIGHT_PADDING = 5;
var LABEL_TOP_BOTTOM_PADDING = exports.LABEL_TOP_BOTTOM_PADDING = 10;
var LABEL_LINE_HEIGHT = exports.LABEL_LINE_HEIGHT = 20;
var BODY_PADDING = exports.BODY_PADDING = 25;
var IMG_PADDING = exports.IMG_PADDING = 10;
var FONT_SIZE = exports.FONT_SIZE = 16;
var EXPANDED_NODE_GROWING = exports.EXPANDED_NODE_GROWING = 1.5;

/**
 * NodeModel - data model for a {@link Node} object
 * @typedef {Object} NodeModel
 * @property {string} id - Node identifyer
 * @property {string} label - Title of the Node,
 * @property {string} viewFrame - Id of ViewFrame wich will include this node
 * @property {string} typeId - Type identifyer
*/

/**
 * The graph Node class which is based on joint.shapes.basic.Generic. Is the one of the main elements of the LineageFram.
 * Represents existing part of the dataset with specified image, color, type and id and placed in separated ViewFrame.
 * @class
 * @private
 * @augments joint.shapes.basic.Generic
 * @param {NodeModel} dataModel - Model of graph node
 * @param {Parameters} parameters - The set of parameters
 * 
 * @property {Node[]} aspects - Copies of this node in other frames
 * @property {NodeModel} model - Data model
 * @property {TerminationNode[]} terminationNodes - Termination nodes which exists on in the frame
 * @property {boolean} highlighted - Tells wheter highlighted node or not (use method get to get this property, e.g. node.get('highlighted'))
 * @property {boolean} blured - Tells wheter blured node or not (use method get to get this property, e.g. node.get('blured'))
 * @property {ViewFrame} viewFrameOwnerId - Exists only if element was dragged from one to another frame
 * @property {boolean} dragged - If somebody is dragging this Node now, then true.
*/
function Node(dataModel, parameters) {
    var self = this;
    var _size = parameters.elementSize;
    var _res = new _resourceProvider.ResourceProvider(parameters);

    var _isVerticalOriented = parameters.graphOrientation === 'top-to-bottom' || parameters.graphOrientation === 'bottom-to-top';

    self.model = dataModel;
    self.terminationNodes = [];
    self.aspects = [];
    self.viewFrameOwnerId = null;
    self.dragged = false;
    self.blured = false;
    self.highlighted = false;
    self.size = { width: _size.width, height: _size.height, maxWidth: _size.width, maxHeight: _size.height };

    var image = _res.getImage(dataModel.typeId);

    var ID = (0, _lodash.uniqueId)('Node');
    joint.shapes.basic.Generic.apply(self, [{
        type: 'lineage-gram-node',
        id: ID,
        position: { x: 0, y: 0 },
        markup: '<g class="rotatable" clip-path="url(' + ('#' + ID + '_clipPath') + ')">\n                    <g class="scalable">\n                        <rect class="body"/>\n                    </g>\n                    <rect class="tq-lg-body"></rect>\n                    <image class="scalable" onerror="this.setAttribute( \'xlink:href\', \'' + _res.getImage() + '\' );"/>\n                    <text class="label"/>\n                </g>\n                <rect class="clipRect"></rect>\n                <defs>\n                    <clipPath id="' + (ID + '_clipPath') + '">\n                        <rect class="clipRect"></rect>\n                    </clipPath>\n                </defs>',
        size: self.size,
        attrs: {
            'circle': {
                fill: 'transparent',
                stroke: 'transparent',
                r: 1
            },
            '.clipRect': {
                port: 'clipRectPort',
                width: self.size.width,
                height: self.size.height,
                fill: 'transparent',
                opacity: 0,
                'stroke-width': 0,
                rx: 5,
                ry: 5
            },
            '.body': {
                'stroke-width': 0,
                fill: 'transparent',
                rx: 5,
                ry: 5
            },
            '.label': {
                fill: _res.getColor('text'),
                'font-size': FONT_SIZE,
                'alignment-baseline': 'hanging',
                ref: '.body',
                tooltip: self.model.label,
                y: 0
            },
            '.tq-lg-body': {
                'ref-x': .5,
                'x-alignment': 'middle',
                'y-alignment': 'top',
                ref: '.body',
                rx: 5,
                ry: 5,
                stroke: _res.getColor(dataModel.typeId)
            },
            image: {
                'xlink:href': image,
                'ref-x': .5,
                ref: '.body',
                'x-alignment': 'middle',
                'y-alignment': 'top'
            },
            '.label tspan': {
                dy: LABEL_LINE_HEIGHT
            }
        },
        z: _elements.Z_INDEXES.NODE
    }]);

    // =====================================

    var _blockSubscription = false;
    var oldPosition = self.position;
    self.position = function (x, y) {
        _blockSubscription = true;
        var result = oldPosition.call(self, x, y);
        _blockSubscription = false;
        return result;
    };
    self.on('change:position', function () {
        if (_blockSubscription) return;
        self.setClipping(undefined);
    });

    self.on('change:size', function (cell, size) {
        self.attr({
            '.clipRect': {
                width: size.width,
                height: size.height
            }
        });
    });

    self.on('change:expanded', function () {
        _refreshSize(self.collapsedSize);
    });

    // =====================================

    _refreshSize(self.size);

    self.set('expanded', false);

    self.setSize = function (size) {
        if (self.collapsedSize.width !== size.width || self.collapsedSize.height !== size.height || self.size.maxWidth !== size.maxWidth || self.size.maxHeight !== size.maxHeight) {
            _refreshSize(size);
        }
    };

    self.setOrientation = function (orientation) {
        _isVerticalOriented = orientation === 'top-to-bottom' || orientation === 'bottom-to-top';
    };

    /**
     * Tells us whether the node is currently
     * on the graph (in the any of view frames) or not
     * @returns {boolena}
     */
    self.isOnTheGraph = function () {
        return self.graph ? true : false;
    };

    self.calculateSize = function (size) {
        var calculations = _calculateNode(size);
        return {
            width: calculations.width,
            height: calculations.height,
            maxWidth: calculations.maxWidth,
            maxHeight: calculations.maxHeight
        };
    };

    /**
     * Highlights the Node.
     * @param {boolean} once - Boolean flag to protect code from recursion (optional)
     * @memberof Node
     * @method
    */
    self.select = function (once) {
        self.terminationNodes.forEach(function (tn) {
            return tn.select(true);
        });
        if (!once) self.aspects.forEach(function (a) {
            return a.select(true);
        });
        if (self.get('blured')) self.unblure();
        if (self.get('hidden')) self.show();
        self.prop({ z: _elements.Z_INDEXES.SELECTED_ELEMENT });
        self.set('highlighted', true);
    };

    /**
     * Removes highlighting from the Node.
     * @param {boolean} once - Boolean flag to protect code from recursion (optional)
     * @memberof Node
     * @method
    */
    self.unselect = function (once) {
        self.terminationNodes.forEach(function (tn) {
            return tn.unselect(true);
        });
        if (!once) self.aspects.forEach(function (a) {
            return a.unselect(true);
        });
        self.prop({ z: _elements.Z_INDEXES.NODE });
        self.set('highlighted', false);
    };

    /**
     * Blurs the Node.
     * @memberof Node
     * @method
    */
    self.blure = function () {
        if (self.get('highlighted')) return;
        self.terminationNodes.forEach(function (tn) {
            return tn.blure(true);
        });
        self.prop({ z: _elements.Z_INDEXES.BLURED_NODE });
        self.set('blured', true);
    };

    /**
     * Removes blur from the Node.
     * @memberof Node
     * @method
    */
    self.unblure = function () {
        self.terminationNodes.forEach(function (tn) {
            return tn.unblure(true);
        });
        self.prop({ z: _elements.Z_INDEXES.NODE });
        self.set('blured', false);
    };

    /**
     * Hides the Node.
     * @memberof Node
     * @method
    */
    self.hide = function () {
        self.terminationNodes.forEach(function (tn) {
            return tn.hide(true);
        });
        self.set('hidden', true);
    };

    /**
     * Shows the Node.
     * @memberof Node
     * @method
    */
    self.show = function () {
        self.terminationNodes.forEach(function (tn) {
            return tn.show(true);
        });
        self.set('hidden', false);
    };

    /**
     * Refreshes highlighters of the view of this element.
     * @memberof Link
     * @method
    */
    self.refreshHighlighting = function () {
        self.trigger('refresh-highlighting', self);
    };

    /**
     * Sets offset and size of clipping rectangle.
     * @param {Point} point - Offset of the clipping rectangle
     * @memberof Node
     * @method
    */
    self.setClipping = function (point) {
        point = point || { x: 0, y: 0 };

        var x = point.x > 0 ? point.x : 0;
        var y = point.y > 0 ? point.y : 0;
        var width = self.size.width - Math.abs(point.x);
        var height = self.size.height - Math.abs(point.y);

        self.attr({
            '.clipRect': {
                x: x,
                y: y,
                width: width > 0 ? width : 0,
                height: height > 0 ? height : 0
            }
        });
    };

    function _refreshSize(size) {
        self.collapsedSize = size;

        var calculations = _calculateNode(size);
        self.size = {
            width: calculations.width,
            height: calculations.height,
            maxWidth: calculations.maxWidth,
            maxHeight: calculations.maxHeight
        };

        var scale = calculations.scale;
        var bodyPadding = BODY_PADDING * scale;
        var topBottomPadding = LABEL_TOP_BOTTOM_PADDING * scale;
        var labelLineHeight = LABEL_LINE_HEIGHT * scale;

        self.attr({
            '.tq-lg-body': {
                width: calculations.rectWidth,
                height: calculations.rectHeight,
                'ref-y': bodyPadding
            },
            image: {
                width: Math.max(0, calculations.rectWidth - IMG_PADDING * 2),
                height: Math.max(0, calculations.rectHeight - IMG_PADDING * 2),
                'ref-y': bodyPadding + IMG_PADDING
            },
            '.label': {
                text: calculations.label,
                'ref-y': bodyPadding + topBottomPadding + calculations.rectHeight + FONT_SIZE * scale - labelLineHeight
            },
            '.label tspan': {
                'font-size': FONT_SIZE * scale,
                dy: labelLineHeight
            }
        });

        self.resize(self.size.width, self.size.height);
        self.set('short-label', calculations.shortLabel);
    }

    var _catchedResult = null;
    function _calculateNode(size) {
        if (_catchedResult && _catchedResult.inSize.width === size.width && _catchedResult.inSize.height === size.height && _catchedResult.inSize.maxWidth === size.maxWidth && _catchedResult.inSize.maxHeight === size.maxHeight && _catchedResult.expanded === self.get('expanded')) {
            return _catchedResult.outSize;
        }

        var width = void 0;
        var height = void 0;
        if (!self.get('expanded')) {
            width = size.width;
            height = size.height;
        } else {
            width = Math.min(size.maxWidth, size.width * EXPANDED_NODE_GROWING);
            height = Math.min(size.maxHeight, size.height * EXPANDED_NODE_GROWING);
        }

        var xScale = size.width / parameters.elementSize.width;
        var yScale = size.height / parameters.elementSize.height;
        var scale = Math.min(xScale, yScale);
        var bodyPadding = BODY_PADDING * scale;
        var labelLineHeight = LABEL_LINE_HEIGHT * scale;

        var calculations = {
            width: width,
            height: height,
            maxWidth: size.maxWidth,
            maxHeight: size.maxHeight,
            rectWidth: width - bodyPadding * 2,
            rectHeight: height - bodyPadding * 2,
            scale: scale,
            shortLabel: false
        };

        if (self.model.label) {
            calculations.height -= bodyPadding;

            var fontSize = FONT_SIZE * scale;
            var leftRightPadding = LABEL_LEFT_RIGHT_PADDING * scale * 2;
            var topBottomPadding = LABEL_TOP_BOTTOM_PADDING * scale * 2;

            var label = _breakTextByLines(self.model.label, width - leftRightPadding, fontSize);

            var labelHeight = 0;
            var substrings = label.split('\n');

            if (substrings.length > 1) {
                var maxRowCount = (_isVerticalOriented ? 2 : 3) + (self.get('expanded') ? 1 : 0);

                if (substrings.length > maxRowCount) calculations.shortLabel = true;

                substrings = substrings.slice(0, maxRowCount);

                if (_isVerticalOriented) {
                    var finalLabel = substrings.join(' ') + (calculations.shortLabel ? '...' : '');
                    var labelWidth = _getTextWidth(finalLabel, fontSize + 'px sans-serif');
                    calculations.width = labelWidth + leftRightPadding * substrings.length;
                    calculations.label = finalLabel;
                    labelHeight = fontSize + topBottomPadding;
                } else {
                    // We use dy property for each line that's why font-size goes only one time into acount.
                    // Because dx is distance between top lines of each text line. And for a full text height we add font size of lust line.
                    labelHeight = fontSize + topBottomPadding + (substrings.length - 1) * labelLineHeight;
                    calculations.label = substrings.join('\n') + (calculations.shortLabel ? '...' : '');
                }
            } else {
                labelHeight = fontSize + topBottomPadding;
                calculations.label = self.model.label;
            }

            calculations.height += labelHeight;
            calculations.labelHeight = labelHeight;
            calculations.expanded = self.get('expanded');
        }
        _catchedResult = {
            inSize: size,
            outSize: calculations,
            expanded: calculations.expanded
        };

        return calculations;
    }

    function _breakTextByLines(label, width, fontSize) {
        var brokenText = joint.util.breakText(label, {
            width: width
        }, { 'font-size': fontSize });

        var lines = brokenText.split('\n');

        if (lines.length > 1) {
            var lastChild = lines[lines.length - 1];
            var MIN_CHARACTER_NUMBER = 4;

            if (lastChild.length < MIN_CHARACTER_NUMBER) {
                var diff = MIN_CHARACTER_NUMBER - lastChild.length;
                var threshold = lines.length - (diff + 1);
                // max error is 3 extra letters, so I hope it's OK.
                var numberOfStealedNodes = Math.round(diff / Math.min(diff, lines.length - 1));

                var prevRest = '';
                var offset = 0;
                var newLines = lines.map(function (line, index, arr) {
                    if (index >= threshold) {
                        var isLastLine = index === arr.length - 1;
                        var fullLine = prevRest + line;
                        offset += numberOfStealedNodes;
                        if (isLastLine) {
                            return fullLine;
                        } else {
                            prevRest = fullLine.substring(fullLine.length - offset, fullLine.length);
                            return fullLine.substring(0, fullLine.length - offset);
                        }
                    } else {
                        return line;
                    }
                });

                return newLines.join('\n');
            } else {
                return brokenText;
            }
        } else {
            return label;
        }
    }

    /**
     * @private
     * Update size of element. Takes collapsed size,
     * and if element are expanded trying to set a twise size.
     * @param {Size} size 
    */

    /**
     * @private
     * @param {string} text 
     * @param {string} font 
    */
    function _getTextWidth(text, font) {
        var canvas = _getTextWidth.canvas || (_getTextWidth.canvas = document.createElement('CANVAS'));
        var context = canvas.getContext('2d');
        context.font = font;
        var metrics = context.measureText(text);
        return metrics.width;
    }
}

Node.prototype = Object.create(joint.shapes.devs.Model.prototype);

},{"../../data/resourceProvider":30,"./elements":47,"lodash":"lodash","rappid":"rappid"}],50:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TerminationLink = TerminationLink;

var _rappid = require('rappid');

var joint = _interopRequireWildcard(_rappid);

var _resourceProvider = require('../../data/resourceProvider');

var _elements = require('./elements');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @private
 * TerminationLinkOptions - options for TerminationLink object
 * @typedef {Object} TerminationLinkOptions
 * @property {Link} link - Original link
 * @property {Node} target - Target Node
 * @property {Node} source - Source Node
*/

/**
 * @private
 * SimpleLinkModel - data model of a TerminationLink object
 * @typedef {Object} SimpleLinkModel - Data model
 * @property {string} target - Target Node id
 * @property {string} source - Source Node id
*/

/**
 * @private
 * The graph Link based on joint.dia.Link.
 * @class
 * @augments joint.dia.Link
 * 
 * @param {TerminationLinkOptions} options - options for TerminationLink object
 * @param {Parameters} parameters - the set of parameters
 * 
 * @property {Link} originalLink - Original Link - the link to a node which is out of the ViewFrmae
 * @property {boolean} highlighted - Tells wheter highlighted link or not (use method get to get this property, e.g. link.get('highlighted'))
 * @property {boolean} blured - Tells wheter blured link or not (use method get to get this property, e.g. link.get('blured'))
 * @property {SimpleLinkModel} model - Data model 
*/
function TerminationLink(options, parameters) {
    var self = this;
    var _res = new _resourceProvider.ResourceProvider(parameters);

    self.originalLink = options.link;
    self.highlighted = false;
    self.blured = false;
    self.originalLink.terminationLinks.push(self);

    var source = { id: options.source.id, port: 'clipRectPort' };
    var target = { id: options.target.id, port: 'clipRectPort' };

    var linkColor = _res.getColor('terminationLink');

    joint.dia.Link.apply(self, [{
        type: 'termination-link',
        source: source,
        target: target,
        z: _elements.Z_INDEXES.TERMINATION_ELEMENT,
        attrs: {
            '.connection': {
                stroke: linkColor,
                'stroke-width': parameters.linkThickness * (1 + (self.originalLink.model.thickness || 0)),
                'stroke-dasharray': '5,5'
            },
            '.marker-source': {
                fill: linkColor,
                stroke: linkColor,
                'stroke-width': parameters.linkThickness * (1 + (self.originalLink.model.thickness || 0)),
                d: 'M0,3a3,3 0 1,0 6,0a3,3 0 1,0 -6,0'
            },
            '.marker-target': {
                fill: linkColor,
                stroke: linkColor,
                'stroke-width': parameters.linkThickness * (1 + (self.originalLink.model.thickness || 0)),
                d: 'M 10 0 L 0 5 L 10 10 z'
            }
        },
        connector: { name: 'rounded' }
    }]);

    /**
     * Highlights the TerminationLink.
     * @param {boolean} once - Boolean flag to protect code from recursion (optional)
     * @memberof TerminationLink
     * @method
    */
    self.select = function (once) {
        if (!once) self.originalLink.select(true);
        if (self.get('blured')) self.unblure();
        if (self.get('hidden')) self.show();
        self.prop({ z: _elements.Z_INDEXES.SELECTED_ELEMENT });
        self.set('highlighted', true);
    };

    /**
     * Removes highlighting from the TerminationLink.
     * @param {boolean} once - Boolean flag to protect code from recursion (optional)
     * @memberof TerminationLink
     * @method
    */
    self.unselect = function (once) {
        if (!once) self.originalLink.unselect(true);
        self.prop({ z: _elements.Z_INDEXES.TERMINATION_ELEMENT });
        self.set('highlighted', false);
    };

    /**
     * Blurs the TerminationLink.
     * @param {boolean} once - Boolean flag to protect code from recursion (optional)
     * @memberof TerminationLink
     * @method
    */
    self.blure = function (once) {
        if (self.get('highlighted')) return;
        if (!once) self.originalLink.blure(true);
        self.prop({ z: _elements.Z_INDEXES.BLURED_LINK });
        self.set('blured', true);
    };

    /**
     * Removes blur from the TerminationLink.
     * @param {boolean} once - Boolean flag to protect code from recursion (optional)
     * @memberof TerminationLink
     * @method
    */
    self.unblure = function (once) {
        if (!once) self.originalLink.unblure(true);
        self.prop({ z: _elements.Z_INDEXES.TERMINATION_ELEMENT });
        self.set('blured', false);
    };

    /**
     * Hides the TerminationLink.
     * @param {boolean} once - Boolean flag to protect code from recursion (optional)
     * @memberof TerminationLink
     * @method
    */
    self.hide = function (once) {
        if (!once) self.originalLink.hide(true);
        self.set('hidden', true);
    };

    /**
     * Shows the TerminationLink.
     * @param {boolean} once - Boolean flag to protect code from recursion (optional)
     * @memberof TerminationLink
     * @method
    */
    self.show = function (once) {
        if (!once) self.originalLink.show(true);
        self.set('hidden', false);
    };

    /**
     * Refreshes highlighters of the view of this element.
     * @memberof Link
     * @method
    */
    self.refreshHighlighting = function () {
        _synchronizeWithOrigin();
        self.trigger('refresh-highlighting', self);
    };

    /**
     * Reset highlighting for the TerminationLink.
     * @memberof TerminationLink
     * @method
    */
    function _synchronizeWithOrigin() {
        if (self.originalLink.get('highlighted')) {
            self.set('highlighted', true, { silent: true });
        } else {
            self.set('highlighted', false, { silent: true });
        }
        if (self.originalLink.get('blured')) {
            self.set('blured', true, { silent: true });
        } else {
            self.set('blured', false, { silent: true });
        }
    }

    self.model = { source: options.source.id, target: options.target.id };
    self.refreshHighlighting();

    var onRemove = self.remove;

    /**
     * Removes link from the paper.
     * @memberof TerminationLink
     * @method
    */
    self.remove = function () {
        var index = self.originalLink.terminationLinks.indexOf(self);
        self.originalLink.terminationLinks.splice(index, 1);
        onRemove.call(self);
    };
}
TerminationLink.prototype = Object.create(joint.dia.Link.prototype);

},{"../../data/resourceProvider":30,"./elements":47,"rappid":"rappid"}],51:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TerminationNode = TerminationNode;

var _rappid = require('rappid');

var joint = _interopRequireWildcard(_rappid);

var _resourceProvider = require('../../data/resourceProvider');

var _elements = require('./elements');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @private
 * TerminationNodeModel - data model of a TerminationNode object
 * @typedef {Object} TerminationNodeModel
 * @property {Point} position - Node identifyer
 * @property {Node} node - Original node
*/

/**
 * @private
 * The graph TerminationNode based on joint.shapes.basic.Rect.
 * @class
 * @augments joint.shapes.basic.Rect
 * 
 * @param {TerminationNodeModel} options - Data model
 * @param {Parameters} parameters - The set of parameters
 * 
 * @property {Node} originalNode - The original node,
 * which is out of the viewFrame so we use termination instead
 * @property {Node[]} related - List of the nodes related with this node
 * @property {boolean} highlighted - Tells wheter highlighted node or not (use method get to get this property, e.g. node.get('highlighted'))
 * @property {boolean} blured - Tells wheter blured node or not (use method get to get this property, e.g. node.get('blured'))
 * @property {boolean} removed - Is the node removed from the paper
*/
function TerminationNode(options, parameters) {
    var self = this;
    var _res = new _resourceProvider.ResourceProvider(parameters);

    self.originalNode = options.node;
    self.highlighted = false;
    self.blured = false;
    self.related = [];
    self.size = parameters.terminationNodeSize;

    options.node.terminationNodes.push(self);

    joint.shapes.basic.Generic.apply(self, [{
        markup: '<g class="rotatable">\n                    <g class="scalable">\n                        <rect class="body"/>\n                    </g>\n                    <rect class="tq-lg-body"/>\n                    <text/>\n                </g>',
        type: 'termination-node',
        position: options.position,
        size: parameters.terminationNodeSize,
        attrs: {
            '.body': {
                port: 'clipRectPort',
                fill: 'transparent',
                'stroke-width': 0,
                rx: 10,
                ry: 10
            },
            '.tq-lg-body': {
                'ref-x': .5,
                'ref-y': .5,
                'x-alignment': 'middle',
                'y-alignment': 'middle',
                width: parameters.terminationNodeSize.width - 10,
                height: parameters.terminationNodeSize.height - 10,
                ref: '.body',
                rx: 2,
                ry: 2,
                stroke: _res.getColor(options.node.model.typeId),
                fill: 'white',
                port: 'clipRectPort'
            },
            text: {
                text: 'Ð¡',
                fill: _res.getColor(options.node.model.typeId),
                stroke: _res.getColor(options.node.model.typeId),
                'ref-x': .5,
                'ref-y': .55,
                ref: '.body',
                tooltip: self.originalNode.model.label // see the line 221 at lineageGram.js
            }

        },
        z: _elements.Z_INDEXES.TERMINATION_ELEMENT
    }]);

    var _isDragging = true;
    var oldPosition = self.position;
    self.position = function (x, y) {
        _isDragging = false;
        var result = oldPosition.call(self, x, y);
        _isDragging = true;
        return result;
    };
    self.on('change:position', function () {
        if (_isDragging) self.set('dragged', _isDragging);
    });
    self.on('change:dragged', function () {
        var oldSize = self.size;
        var oldPos = self.position();

        if (self.get('dragged')) {
            self.size = {
                width: self.originalNode.size.width,
                height: self.originalNode.size.height
            };
            self.attr({
                text: {
                    text: '+',
                    'ref-y': .51
                },
                '.body': {
                    rx: 0,
                    ry: 0
                }
            });
            self.resize(self.size.width, self.size.height);
            self.position(oldPos.x - (self.size.width - oldSize.width) / 2, oldPos.y - (self.size.height - oldSize.height) / 2);
        } else {
            self.size = {
                width: parameters.terminationNodeSize.width,
                height: parameters.terminationNodeSize.height
            };
            self.attr({
                text: {
                    text: 'C',
                    'ref-y': .55
                },
                '.body': {
                    rx: 10,
                    ry: 10
                }
            });
            self.resize(self.size.width, self.size.height);

            self.position(oldPos.x + (self.size.width - oldSize.width) / 2, oldPos.y + (self.size.height - oldSize.height) / 2);
        }
    });

    /**
     * Highlights the TerminationNode.
     * @param {boolean} once - Boolean flag to protect code from recursion (optional)
     * @memberof TerminationNode
     * @method
    */
    self.select = function (once) {
        if (self.originalNode && !once) self.originalNode.select(true);
        if (self.get('blured')) self.unblure();
        if (self.get('hidden')) self.show();
        self.prop({ z: _elements.Z_INDEXES.SELECTED_ELEMENT });
        self.set('highlighted', true);
    };

    /**
     * Removes highlighting from the TerminationNode.
     * @param {boolean} once - Boolean flag to protect code from recursion (optional)
     * @memberof TerminationNode
     * @method
    */
    self.unselect = function (once) {
        if (self.originalNode && !once) self.originalNode.unselect(true);
        self.prop({ z: _elements.Z_INDEXES.TERMINATION_ELEMENT });
        self.set('highlighted', false);
    };

    /**
      * Blurs the TerminationNode.
      * @param {boolean} once - Boolean flag to protect code from recursion (optional)
      * @memberof TerminationNode
      * @method
     */
    self.blure = function (once) {
        if (self.get('highlighted')) return;
        if (self.originalNode && !once) self.originalNode.blure(true);
        self.prop({ z: _elements.Z_INDEXES.BLURED_NODE });
        self.set('blured', true);
    };

    /**
     * Removes blur from the TerminationNode.
     * @param {boolean} once - Boolean flag to protect code from recursion (optional)
     * @memberof TerminationNode
     * @method
    */
    self.unblure = function (once) {
        if (self.originalNode && !once) self.originalNode.unblure(true);
        self.prop({ z: _elements.Z_INDEXES.TERMINATION_ELEMENT });
        self.set('blured', false);
    };

    /**
      * Blurs the TerminationNode.
      * @param {boolean} once - Boolean flag to protect code from recursion (optional)
      * @memberof TerminationNode
      * @method
     */
    self.hide = function (once) {
        if (self.originalNode && !once) self.originalNode.hide(true);
        self.set('hidden', true);
    };

    /**
     * Removes blur from the TerminationNode.
     * @param {boolean} once - Boolean flag to protect code from recursion (optional)
     * @memberof TerminationNode
     * @method
    */
    self.show = function (once) {
        if (self.originalNode && !once) self.originalNode.show(true);
        self.set('hidden', false);
    };

    /**
     * Refreshes highlighters of the view of this element.
     * @memberof Link
     * @method
    */
    self.refreshHighlighting = function () {
        _synchronizeWithOrigin();
        self.trigger('refresh-highlighting', self);
    };

    function _synchronizeWithOrigin() {
        if (self.originalNode.get('highlighted')) {
            self.set('highlighted', true, { silent: true });
        } else {
            self.set('highlighted', false, { silent: true });
        }
        if (self.originalNode.get('blured')) {
            self.set('blured', true, { silent: true });
        } else {
            self.set('blured', false, { silent: true });
        }
    }

    var onRemove = self.remove;

    /**
     * Removes node from the paper.
     * @memberof TerminationNode
     * @method
    */
    self.remove = function () {
        var index = self.originalNode.terminationNodes.indexOf(self);
        self.originalNode.terminationNodes.splice(index, 1);
        onRemove.call(self);
    };

    self.refreshHighlighting();
}
TerminationNode.prototype = Object.create(joint.shapes.basic.Rect.prototype);

},{"../../data/resourceProvider":30,"./elements":47,"rappid":"rappid"}],52:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = LineageDiagram;

var _rappid = require('rappid');

var joint = _interopRequireWildcard(_rappid);

var _fileSaverjs = require('file-saverjs');

var _fileSaverjs2 = _interopRequireDefault(_fileSaverjs);

var _lodash = require('lodash');

var _ = _interopRequireWildcard(_lodash);

var _viewManager2 = require('./viewManager');

var _routingManager2 = require('./linkRoutingManager/routingManager');

var _viewFrame = require('./viewFrame');

var _elements = require('./graphElements/elements');

var _viewFramesUI2 = require('../htmlUI/viewFramesUI');

var _viewFramesUI3 = _interopRequireDefault(_viewFramesUI2);

var _subscribeable = require('../subscriptionAPI/subscribeable');

var _subscribeable2 = _interopRequireDefault(_subscribeable);

var _toSvg = require('./toSvg');

var _layout = require('../layout/layout');

var _dataUtils = require('../utils/dataUtils');

var _utils = require('../utils/utils');

var _lineageDiagramUtils = require('../utils/lineageDiagramUtils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var DIRECTION = {
    UP: 38,
    DOWN: 40,
    LEFT: 37,
    RIGHT: 39
};

/**
 * @private
 * @class
 * Manages the main view of application (View-2)
 * All changes goes through the render function.
 *
 * Constructor parameters:
 * ========================================
 * @param {
 *  dataContainer: DataContainer
 *  graphPlace: HTMLElement
 *  viewFrames: ViewFrameModels
 * } options
 * @param {Parameters} parameters - parameters set
 *
 * Public properties:
 * ========================================
 * selectedElement: Node|Link
 *
 * Public methods:
 * ========================================
 * redraw: (options: {
    viewFrames: ViewFramePublicModel[];
    selectedElement: (Node|Link);
    path: { [id: string]: (Node|Link) };
    quickUpdate: boolean;
    updateBounds: boolean;
    paperOptions: {
        orientation: Orientation;
        width: number;
        height:number;
        scale: Point;
    };
    elementOptions: {
        elementSize: ElementSize;
 * }) => void;
 * delayedRedraw: (options: { ... see redraw}) => void;
 * openViewFrame: (id:string) => void;
 * closeViewFrame: (id:string) => void;
 * openOverViewFrame: () => void;
 * closeOverViewFrame: () => void;
 * updateNodesPositions: (nodes: Node[]) => void;
 * combine: () => void;
 * resetLayout: () => void;
 * refresh: () => void;
 * getSelectedElement: () => (Node|Link);
 * getVisibleCells: () => (Node|Link|ViewFrame|TerminationNode|TerminationLink);
 * getVisibleNodes: () => (Node|ViewFrame|TerminationNode);
 * getVisibleLinks: () => (Link|TerminationLink);
 * setSelectedElement: (element: (Node|Link|undefined), focusOn: boolean) => void;
 * positionViewPort: (vf: ViewFramePublicModel, point: Point, animation: boolean) => void;
 * export: () => void;
 * print: () => void;
 * setData: (dataContainer: DataContainer, viewFrames: ViewFrameDefinition[]) => void;
 * scale: (scale: Point) => void; - Sets and limits value of the scale of the graph
 * zoomIn: () => void;
 * zoomOut: () => void;
 * zoomToFit: () => void;
 * setOrientation: (orientation: Orientation) => void; Values: 'left-to-right', 'right-to-left', 'top-to-bottom', 'bottom-to-top'
 * getViewFrames: () => ViewFramePublicModel[];
 * translateViewPort (vf: ViewFrame, dx: number, dy: number, animation: boolean)
 * ----------------------------------------
 * on (event: string, callback: function) => void
 * unsubscribe (callback: function) => void
 * trigger (event: string, parameters: any) => void
 *
 * Events:
 * ========================================
 * @fires selected-element-changed (Node|Link)
 * @fires scale-changed (scale)
 * @fires view-frames-state-changed (ViewFrame, boolean)
 * @fires view-frames-size-or-position-changed (ViewFrame, boolean)
 * @fires cell-double-click (cell)
 * @fires cell-single-click (cell)
 * @fires link-options-click (Link)
 * @fires nodes-position-changed
 */
function LineageDiagram(options, parameters) {
    // Init
    // ===================================================================
    // ===================================================================
    _subscribeable2.default.apply(this); // make this class Subscribable

    var _base = _createBase(options.graphPlace);

    // Creating a joint graph and joint paper
    var _graph = new joint.dia.Graph();
    var _paper = new joint.dia.Paper({
        el: _base.diagram,
        model: _graph,
        elementView: _elements.NodeView,
        linkView: _elements.LinkView,
        gridSize: 1,
        interactive: function interactive() {
            return { vertexAdd: false };
        },
        preventContextMenu: false,
        width: '100%',
        height: '100%'
    });

    var _scale = parameters.defaultScale;
    var _dataContainer = void 0;

    var _orientation = parameters.graphOrientation;
    var _fullScreenMode = parameters.fullScreenMode;
    var _path = null; // highlighting path
    var _mask = parameters.mask; // highlighting path
    var _selectedElement = null;
    var _routingManager = void 0;
    var _viewFramesUI = void 0;
    var _viewManager = void 0;

    var self = this;
    var _keyboard = new joint.ui.Keyboard();
    var _scaleBounds = _.clone(parameters.scaleBounds);
    var _overViewScaleBounds = _.clone(parameters.overViewScaleBounds);
    var _scaleStep = parameters.scaleStep;

    _setData(options.dataContainer, options.viewFrames);
    _subscribeOnEvents();
    // ===================================================================
    // ===================================================================

    /**
     * Drawing options (deprecated)
     * @typedef {Object} DrawingOptions
     * @param {boolean} quickUpdate - don't updates links and remove them.
     * @param {Array of ViewFrame} viewFrames - update only limitted number of viewFrames.
    */

    /**
     * @private
     * Updates the graph's state, - Add/remove
     * visible Nodes and TerminationNodes
     * @param {DrawingOptions} options
     */
    self.redraw = _redraw;
    /**
     * Same as redraw but it's quick update
     * with delayed full redraw (debouncer).
     */
    self.delayedRedraw = _delayedRedraw;

    /**
     * Opens ViewFrame with specified id
     * @param {string} viewFrameId
     */
    self.openViewFrame = _openViewFrame;

    /**
     * Closes ViewFrame with specified id
     * @param {string} viewFrameId
     */
    self.closeViewFrame = _closeViewFrame;

    /**
     * Changes mode fullScreen/viewFrame.
     * @param {boolean} value
    */
    self.setFullScreenMode = _setFullScreenMode;

    /**
     * Opens OverViewFrame
     * @param {string} viewFrameId
     */
    self.openOverViewFrame = function () {
        return _openViewFrame(_viewManager.getOverViewFrame().id);
    };

    /**
     * Closes OverViewFrame
     * @param {string} viewFrameId
     */
    self.closeOverViewFrame = function () {
        return _closeViewFrame(_viewManager.getOverViewFrame().id);
    };

    /**
     * Updates layout positions of the nodes using paper positions
     * @param {Node[]} nodes
     */
    self.updateNodesPositions = _updateNodesPositions;

    /**
     * Groups nodes around selected
     * and highlights neighbours
     */
    self.combine = _combine;

    /**
     * Restore nodes positions
     */
    self.resetLayout = _resetLayout;

    /**
     * Refreshes all viewFrames bounds.
     */
    self.refresh = _refresh;

    /**
     * @returns {Node|Link}.
    */
    self.getSelectedElement = function () {
        return _selectedElement;
    };

    /**
     * @returns {(Node|Link|ViewFrame|TerminationNode|TerminationLink)}.
    */
    self.getVisibleCells = function () {
        return _graph.getCells();
    };

    /**
     * @returns {(Node|ViewFrame|TerminationNode)}.
    */
    self.getVisibleNodes = function () {
        return _graph.getElements();
    };

    /**
     * @returns {(Link|TerminationLink)}.
    */
    self.getVisibleLinks = function () {
        return _graph.getLinks();
    };

    /**
     * Sets selected element
     * @param {Node|Link|undefined}.
    */
    self.setSelectedElement = function (element, focusOn) {
        if (element) {
            _select(element, focusOn);
        } else {
            _unselect();
        }
    };

    /**
     * It sets offset for all elements into the viewPort.
     * @param {ViewFrame} viewFrame
     * @param {Point} point
     * @param {boolean} animation - it's optional
     * @param {function} callback - it's called after focus
     * @fires view-frames-size-or-position-changed
    */
    self.positionViewPort = function (viewFramePublicModel, point, animation, callback) {
        var relevantViewFrame = _viewManager.getViewFrameById(viewFramePublicModel.id);
        _positionViewPort(relevantViewFrame, point, animation, function () {
            callback();
            var changedViewFrame = _viewManager.getViewFrameById(viewFramePublicModel.id);
            self.trigger('view-frames-size-or-position-changed', [[changedViewFrame]]);
        });
    };

    /**
     * Exports graph to png or svg file.
     * @param {
     *  name?: string - file name
     *  type?: string - (png/svg)
     * } options
    */
    self.export = function (options) {
        if (!options) options = {};
        var fileName = options.name || 'LG_lineage_diagram_snapshot_' + (0, _dataUtils.date2String)(new Date());

        if (options.type === 'png') {
            (0, _toSvg.toDataURL)(_paper, {
                backgroundColor: 'white',
                svgOptions: {
                    elementsToRemoveSelector: '',
                    convertImagesToDataUris: true
                }
            }).then(function (base64URL) {
                saveData(base64URL, fileName, 'png');
            }).catch(function (error) {
                if (typeof error === 'string') alert(error);else alert('This type of export is not supported in the Internet Explorer');
                console.error(error);
            });
        } else {
            (0, _toSvg.exportToSVG)(_paper, {
                elementsToRemoveSelector: '',
                convertImagesToDataUris: true
            }).then(function (svgString) {
                saveData(svgString, fileName, 'svg');
            }).catch(function (error) {
                alert(error);
                console.error(error);
            });
        }

        function saveData(data, fileName, type) {
            var blob = void 0;
            if (type === 'svg') {
                blob = new Blob([data], { type: type });
            } else if (type === 'png') {
                blob = (0, _dataUtils.png2Blob)(data);
            }
            (0, _fileSaverjs2.default)(blob, fileName + '.' + type);
        }
    };

    /**
     * Shows print dialog.
    */
    self.print = function () {
        (0, _toSvg.exportToSVG)(_paper, {
            preserveDimensions: false,
            elementsToRemoveSelector: '',
            convertImagesToDataUris: true,
            pdfMode: true
        }).then(function (svgString) {
            var printWindow = window.open('', undefined, 'width=1280,height=720');
            if (printWindow) {
                printWindow.document.write(svgString);
                printWindow.document.close();
                printWindow.print();
            } else {
                alert('You should unblock popup windows for the current url to be able to print this diagram!');
            }
        });
    };

    /**
     * Define data container with nodes and links for the Jointjs view (view-2)
     * and path it to the forms
     * @param {DataContainer} dataContainer - data for the graph
     * @param {ViewFramePublicModel[]} viewFrames - view frames
    */
    self.setData = _setData;

    self.setRouting = function (routingId) {
        _routingManager.setRouting(routingId);
    };

    self.getRouting = function () {
        return _routingManager.getRouting();
    };

    self.scale = function (scale) {
        if (scale) {
            _updateScale(scale);
            _limitViewPortsPostions(_viewManager.getViewFrames());
        }
        return _scale;
    };

    /**
     * Increases scale of the graph.
     * And redraw it after that.
     */
    self.zoomIn = function () {
        _updateScale({
            x: _scale.x + _scaleStep,
            y: _scale.y + _scaleStep
        });
        _delayedRedraw(undefined, function () {
            _limitViewPortsPostions(_viewManager.getViewFrames());
            self.trigger('scale-changed', _scale);
        });
    };

    /**
     * Decreases scale of the graph.
     * And redraw it after that.
     */
    self.zoomOut = function () {
        _updateScale({
            x: _scale.x - _scaleStep,
            y: _scale.y - _scaleStep
        });
        _delayedRedraw(undefined, function () {
            _limitViewPortsPostions(_viewManager.getViewFrames());
            self.trigger('scale-changed', _scale);
        });
    };

    /**
     * Increases scale of the graph.
     * And redraw it after that.
     */
    self.zoomToFit = function () {
        var overViewFrame = _viewManager.getOverViewFrame();
        var nodeBounds = overViewFrame.nodeBounds;
        var width = _paper.el.clientWidth - _viewManager2.FRAME_OUT_MARGIN * 2;
        var height = _paper.el.clientHeight - _viewManager2.FRAME_OUT_MARGIN * 2;

        var scale = overViewFrame.scale;
        var necessarySize = (0, _utils.globalToScaledSize)({
            width: nodeBounds.width,
            height: nodeBounds.height
        }, scale);
        var xRatio = width / (necessarySize.width + parameters.framePadding.x * 2);
        var yRatio = height / (necessarySize.height + parameters.framePadding.y * 2);
        var minRatio = Math.min(xRatio, yRatio);
        _updateScale({
            x: _scale.x * minRatio,
            y: _scale.y * minRatio
        });
        _delayedRedraw(undefined, function () {
            _limitViewPortsPostions(_viewManager.getViewFrames());
            self.trigger('scale-changed', _scale);
        });
    };

    /**
     * It changes orientation of the graph.
     * @param {string} orientation - Values: 'left-to-right', 'right-to-left', 'top-to-bottom', 'bottom-to-top'
     * @memberof LineageDiagram
     * @method
     */
    self.setOrientation = function (orientation) {
        _orientation = orientation;
        _redraw();
        _viewFramesUI.setOrientation(orientation);
    };

    /**
     * Returns all ViewFrames
     * @memberof LineageDiagram
     * @method
     * @returns {ViewFramePublicModel[]}
     */
    self.getViewFrames = function () {
        return _viewManager.getViewFrames();
    };

    /**
     * Returns one ViewFrame by id 
     * @memberof LineageDiagram
     * @method
     * @param {string} viewFrameId
     * @returns {ViewFramePublicModel}
    */
    self.getViewFrameById = function (viewFrameId) {
        return _viewManager.getViewFrameById(viewFrameId);
    };

    /**
     * Returns one ViewFrame by id 
     * @memberof LineageDiagram
     * @method
     * @returns {ViewFramePublicModel}
    */
    self.getOverViewFrame = function () {
        return _viewManager.getOverViewFrame();
    };

    self.setMask = function (mask) {
        _mask = mask;
        _redraw();
    };

    self.getMask = function () {
        return _mask;
    };

    self.isFullScreenMode = function () {
        return _viewManager.isFullScreenMode();
    };

    function _redraw(options) {
        _routingManager.resetRouting();
        _routingManager.setBounds({
            x: _viewManager2.FRAME_OUT_MARGIN + parameters.frameBorderWidth,
            y: _viewManager2.FRAME_OUT_MARGIN + parameters.frameBorderWidth,
            width: _paper.el.clientWidth - (_viewManager2.FRAME_OUT_MARGIN + parameters.frameBorderWidth) * 2,
            height: _paper.el.clientHeight - (_viewManager2.FRAME_OUT_MARGIN + parameters.frameBorderWidth) * 2
        });

        options = options || {};
        var renderOptions = {
            viewFrames: options.viewFrames,
            fullScreenMode: options.fullScreenMode,
            selectedElement: _selectedElement,
            path: _path,
            mask: _mask,
            quickUpdate: options.quickUpdate,
            updateBounds: options.updateBounds,
            paperOptions: {
                orientation: _orientation,
                width: _paper.el.clientWidth,
                height: _paper.el.clientHeight,
                scale: _scale
            },
            elementOptions: {
                elementSize: options.elementSize
            }
        };

        if (!renderOptions.quickUpdate) clearTimeout(_timeoutRef);

        _graph.startBatch('remove');
        if (renderOptions.quickUpdate) _graph.removeCells(_graph.getLinks());

        var renderData = _viewManager.prepareRenderData(renderOptions);

        renderData = _removeDeprecatedAndExistingCells(renderData);
        _graph.stopBatch('remove');

        _graph.startBatch('add');
        _graph.addCells(renderData);
        _graph.stopBatch('add');

        _updateHighlighting(renderData);
        _viewFramesUI.refresh();
        // console.log('Redraw' + (renderOptions.quickUpdate ? ' (quick)' : ''));
    }

    var _timeoutRef = 0;
    var _blockMultipleQueries = false;
    function _delayedRedraw(options, callback) {
        if (_blockMultipleQueries) return;
        clearTimeout(_timeoutRef);
        options = options || {};

        var quickOptions = _.cloneDeep(options) || {};
        quickOptions.quickUpdate = true;

        _blockMultipleQueries = true;
        requestAnimationFrame(function () {
            _blockMultipleQueries = false;
        });
        _redraw(quickOptions);

        _timeoutRef = setTimeout(function () {
            options.quickUpdate = false;
            // console.log(`Redraw (delay:start-${_timeoutRef}) => `);
            _redraw(options);
            if (callback) callback();
        }, 150);
        // console.log(`Redraw (delay:wait-${_timeoutRef})`);
    }

    function _removeDeprecatedAndExistingCells(newCells) {
        var oldCells = _graph.getCells();
        var cellMap = {};

        newCells.forEach(function (cell) {
            cellMap[cell.id] = cell;
        });
        oldCells.forEach(function (cell) {
            if (!cellMap[cell.id]) {
                cell.remove();
            } else {
                delete cellMap[cell.id];
            }
        });

        return Object.keys(cellMap).map(function (key) {
            return cellMap[key];
        });
    }

    function _updateHighlighting(cells) {
        cells.forEach(function (cell) {
            if (cell.refreshHighlighting) {
                cell.refreshHighlighting();
            }
        });
    }

    function _combine() {
        var selectedElementIsNode = _selectedElement instanceof _elements.Node;
        if (selectedElementIsNode) {
            var selectedNode = _selectedElement;
            var nodeMap = _dataContainer.maps.nodeMap;
            var sourceMap = _dataContainer.maps.sourceMap;
            var targetMap = _dataContainer.maps.targetMap;

            var relativeLinks = (sourceMap[selectedNode.id] || []).concat(targetMap[selectedNode.id] || []);
            var relativeNodes = relativeLinks.map(function (l) {
                if (l.model.source !== selectedNode.id) return nodeMap[l.model.source];else if (l.model.target !== selectedNode.id) return nodeMap[l.model.target];else if (l.model.source === l.model.target) return nodeMap[l.model.source];
            });

            var newPositions = (0, _layout.combineOperation)({
                selectedNode: selectedNode,
                relativeLinks: relativeLinks,
                relativeNodes: relativeNodes,
                scale: _scale
            }, parameters);

            var targetViewFrameId = (0, _lineageDiagramUtils.getViewFrameIdForNode)(selectedNode);
            var newPath = {};
            var affectedViewFramesMap = {};
            relativeNodes.forEach(function (node) {
                var curPosition = (0, _utils.getGlobalNodePosition)(node);
                node.model.position = newPositions[node.id];
                _dataContainer.updateZonesForNode(node, curPosition);

                var viewFrame = _viewManager.getViewFrameForNode(node);
                affectedViewFramesMap[viewFrame.id] = viewFrame;
                node.viewFrameOwnerId = targetViewFrameId;
                newPath[node.id] = node;
            });
            newPath[selectedNode.id] = selectedNode;

            relativeLinks.forEach(function (link) {
                newPath[link.id] = link;
            });

            _path = newPath;

            var affectedViewFrames = Object.keys(affectedViewFramesMap).map(function (key) {
                return affectedViewFramesMap[key];
            });
            _redraw({ viewFrames: affectedViewFrames, updateBounds: true });
            _limitViewPortsPostions(affectedViewFrames);
        }
    }

    /**
     * Removes all from the paper besides viewFrames.
     */
    function _clear() {
        _unselect();
        _graph.clear();
        _viewManager = undefined;
    }

    /**
     * Define data container with nodes and links for the Jointjs view (view-2)
     * and path it to the forms
     * @param {DataContainer} dataContainer - data for the graph
     * @param {ViewFramePublicModel[]} viewFrames - view frames
    */
    function _setData(dataContainer, viewFrames) {
        _clear();

        _dataContainer = dataContainer;
        _routingManager = new _routingManager2.RoutingManager({
            links: _dataContainer.links,
            bounds: {
                x: _viewManager2.FRAME_OUT_MARGIN + parameters.frameBorderWidth,
                y: _viewManager2.FRAME_OUT_MARGIN + parameters.frameBorderWidth,
                width: _paper.el.clientWidth - (_viewManager2.FRAME_OUT_MARGIN + parameters.frameBorderWidth) * 2,
                height: _paper.el.clientHeight - (_viewManager2.FRAME_OUT_MARGIN + parameters.frameBorderWidth) * 2
            }
        }, parameters);
        _viewManager = new _viewManager2.ViewManager({
            dataContainer: dataContainer,
            viewFrames: viewFrames,
            fullScreenMode: _fullScreenMode
        }, parameters);

        _viewFramesUI = _createViewFramesUI(_viewManager);

        _viewManager.on('change-view-port-position', function (viewFrame) {
            _redraw({ viewFrames: [viewFrame], quickUpdate: true });
        });

        _correctScale();
        _redraw();
    }

    /**
     * @param {string} viewFrameId 
     * @fires view-frames-size-or-position-changed
     */
    function _openViewFrame(viewFrameId) {
        var viewFrame = _viewManager.getViewFrameById(viewFrameId);
        if (!viewFrame) return;

        viewFrame.expanded = true;
        var viewFrames = [viewFrame];

        _redraw({ viewFrames: viewFrames });

        self.trigger('view-frames-state-changed', [viewFrames]);

        _limitViewPortsPostions(_viewManager.getViewFrames().filter(function (vf) {
            return vf.active;
        }));
    }

    function _closeViewFrame(viewFrameId) {
        var viewFrame = _viewManager.getViewFrameById(viewFrameId);
        if (!viewFrame) return;

        viewFrame.expanded = false;
        var viewFrames = [viewFrame];

        _redraw({ viewFrames: viewFrames });

        self.trigger('view-frames-state-changed', [viewFrames]);

        _limitViewPortsPostions(_viewManager.getViewFrames().filter(function (vf) {
            return vf.active;
        }));
    }

    function _setFullScreenMode(value) {
        _fullScreenMode = value;

        if (!_fullScreenMode) {
            _scale = {
                x: Math.max(Math.min(_scale.x, _scaleBounds.max), _scaleBounds.min),
                y: Math.max(Math.min(_scale.y, _scaleBounds.max), _scaleBounds.min)
            };
        }

        _redraw({ fullScreenMode: value });

        var viewFrames = _viewManager.getViewFrames();
        self.trigger('view-frames-state-changed', [viewFrames]);

        if (value) {
            var overViewFrame = _viewManager.getOverViewFrame();
            _limitViewPortPostion(overViewFrame, function () {
                _redraw();
                self.trigger('view-frames-size-or-position-changed', [[overViewFrame]]);
            });
        } else {
            _limitViewPortsPostions(viewFrames.filter(function (vf) {
                return vf.active;
            }));
        }
    }

    /**
     * Sets and limits value of the scale of the graph.
     * @param {number} scale
     * @returns {number}
     * =================
     * @fires scale-changed
     */
    function _updateScale(scale) {
        var fullScreen = _viewManager.isFullScreenMode();

        scale = scale || _scale;
        if (fullScreen) {
            _scale = {
                x: Math.max(Math.min(scale.x, _overViewScaleBounds.max), _overViewScaleBounds.min),
                y: Math.max(Math.min(scale.y, _overViewScaleBounds.max), _overViewScaleBounds.min)
            };
        } else {
            _scale = {
                x: Math.max(Math.min(scale.x, _scaleBounds.max), _scaleBounds.min),
                y: Math.max(Math.min(scale.y, _scaleBounds.max), _scaleBounds.min)
            };
        }
        return _scale;
    }

    function _correctScale() {
        var viewFramesNumber = _viewManager.getViewFrames().length;
        var width = _paper.el.clientWidth - _viewManager2.FRAME_OUT_MARGIN * 2;
        var height = _paper.el.clientHeight - _viewManager2.FRAME_OUT_MARGIN * 2;

        var cutedWidth = width - _viewManager2.DISTANCE_BETWEEN_FRAMES * (viewFramesNumber - 1);
        var cutedHeight = height - _viewManager2.DISTANCE_BETWEEN_FRAMES * (viewFramesNumber - 1);

        var minHorNum = 4; // it's for max scale because when we have max scale we also have minimum node number
        var minVertNum = 3;

        var maxHorNum = 8; // it's for min scale because when we have min scale we also have maximum node number
        var maxVertNum = 7;

        var nodeSize = {
            width: parameters.elementSize.width,
            height: parameters.elementSize.height
        };
        var step = {
            x: parameters.layoutStep.x,
            y: parameters.layoutStep.y
        };

        var minScale = getScaleForNodeNumber(maxHorNum, maxVertNum);
        var maxScale = getScaleForNodeNumber(minHorNum, minVertNum);

        // parameters.defaultScale = scale;
        _scaleBounds.min = Math.max(minScale.x, minScale.y);
        _scaleBounds.max = Math.min(maxScale.x, maxScale.y);
        // _setScale(scale);

        function getScaleForNodeNumber(horNum, vertNum) {
            var curXValue = horNum * nodeSize.width + (horNum - 1) * step.x;
            var curYValue = vertNum * nodeSize.height + (horNum - 1) * step.y;

            var scale = void 0;
            if (Math.abs(cutedWidth - curXValue) >= Math.abs(cutedHeight - curYValue)) {
                scale = {
                    x: cutedWidth / curXValue,
                    y: cutedWidth / curXValue
                };
            } else {
                scale = {
                    x: cutedHeight / curYValue,
                    y: cutedHeight / curYValue
                };
            }

            return scale;
        }
    }

    function _findNextNode(direction) {
        if (!_selectedElement) return undefined;
        var curPos = void 0;
        if (_selectedElement instanceof _elements.Node) {
            curPos = (0, _utils.getGlobalNodePosition)(_selectedElement);
        } else {
            var source = _dataContainer.maps.nodeMap[_selectedElement.model.source];
            var sourcePos = source.model.position;
            var target = _dataContainer.maps.nodeMap[_selectedElement.model.target];
            var targetPos = target.model.position;
            if (direction === DIRECTION.UP) {
                if (source.model.y < target.model.y) {
                    return source;
                } else {
                    return target;
                }
            } else if (direction === DIRECTION.DOWN) {
                if (source.model.y > target.model.y) {
                    return source;
                } else {
                    return target;
                }
            } else if (direction === DIRECTION.LEFT) {
                if (sourcePos.x < targetPos.x) {
                    return source;
                } else {
                    return target;
                }
            } else if (direction === DIRECTION.RIGHT) {
                if (sourcePos.x > targetPos.x) {
                    return source;
                } else {
                    return target;
                }
            }
        }

        var prevNodes = []; // to break cycling
        return getNextNode(curPos);

        function getNextNode(curPos) {
            function diffToNode(node) {
                var nodePosition = (0, _utils.getGlobalNodePosition)(node);
                return {
                    x: curPos.x - nodePosition.x,
                    y: curPos.y - nodePosition.y
                };
            }

            var X_STEP = parameters.dataZoneSize.width;
            var Y_STEP = parameters.dataZoneSize.height;
            var rect = {
                x: curPos.x - X_STEP / 2,
                y: curPos.y - Y_STEP / 2,
                width: X_STEP,
                height: Y_STEP
            };

            var nodes = _dataContainer.getElementsForRectangle(rect).nodes.filter(function (n) {
                return prevNodes.indexOf(n) === -1;
            });
            if (nodes.length === 0) return _selectedElement;
            prevNodes = nodes;

            var nextElements = void 0;
            if (direction === DIRECTION.UP) {
                nextElements = nodes.filter(function (n) {
                    var dist = diffToNode(n);
                    return dist.y > 0 && Math.abs(dist.y) > Math.abs(dist.x);
                });
                if (nextElements.length === 0) {
                    return getNextNode({
                        x: curPos.x,
                        y: curPos.y - Y_STEP
                    });
                }
            } else if (direction === DIRECTION.DOWN) {
                nextElements = nodes.filter(function (n) {
                    var dist = diffToNode(n);
                    return dist.y < 0 && Math.abs(dist.y) > Math.abs(dist.x);
                });
                if (nextElements.length === 0) {
                    return getNextNode({
                        x: curPos.x,
                        y: curPos.y + Y_STEP
                    });
                }
            } else if (direction === DIRECTION.LEFT) {
                nextElements = nodes.filter(function (n) {
                    var dist = diffToNode(n);
                    return dist.x > 0 && Math.abs(dist.y) < Math.abs(dist.x);
                });
                if (nextElements.length === 0) {
                    return getNextNode({
                        x: curPos.x - X_STEP,
                        y: curPos.y
                    });
                }
            } else if (direction === DIRECTION.RIGHT) {
                nextElements = nodes.filter(function (n) {
                    var dist = diffToNode(n);
                    return dist.x < 0 && Math.abs(dist.y) < Math.abs(dist.x);
                });
                if (nextElements.length === 0) {
                    return getNextNode({
                        x: curPos.x + X_STEP,
                        y: curPos.y
                    });
                }
            }
            nextElements.sort(function (a, b) {
                var aPos = (0, _utils.getGlobalNodePosition)(a);
                var bPos = (0, _utils.getGlobalNodePosition)(b);
                var aDist = (0, _utils.getDist)(aPos, curPos);
                var bDist = (0, _utils.getDist)(bPos, curPos);

                if (aDist > bDist) {
                    return 1;
                } else if (aDist < bDist) {
                    return -1;
                } else {
                    return 0;
                }
            });
            return nextElements[0];
        }
    }

    /**
     * Subscribes on paper and Keyboard events.
     */
    function _subscribeOnEvents() {
        var queryAnimationFrame = void 0;

        _paper.on('link:options', function (cellView, event) {
            var linkType = event.target.parentNode.getAttribute('linkType');
            self.trigger('link-options-click', {
                link: cellView.model,
                linkType: linkType
            });
        });

        _keyboard.on({
            'up down left right': function upDownLeftRight(evt) {
                cancelAnimationFrame(queryAnimationFrame);
                queryAnimationFrame = requestAnimationFrame(function () {
                    _select(_findNextNode(evt.keyCode), true);
                    evt.stopPropagation();
                });
            }
        });

        var _clickCounter = 0;
        _paper.on('cell:pointerup', function (cellView, event) {
            var isViewFrame = cellView.model instanceof _viewFrame.ViewFrame;
            if (isViewFrame) {
                onSingleClick(cellView, event);
                _clickCounter = 0;
            } else {
                if (_clickCounter > 1) {
                    onDoubleClick(cellView, event);
                    _clickCounter = 0;
                } else {
                    setTimeout(function () {
                        if (_clickCounter === 1) onSingleClick(cellView, event);
                        _clickCounter = 0;
                    }, 200);
                }
            }

            function onSingleClick(cellView, event) {
                var isDragging = Math.abs(_mouseDownPosition.x - event.pageX) > 5 || Math.abs(_mouseDownPosition.y - event.pageY);
                var cell = cellView.model;
                if (cell instanceof _viewFrame.ViewFrame) {
                    var viewFrame = _viewManager.getViewFrameById(cell.id);
                    // ViewFrame click
                    // ================================
                    if (!isDragging) _unselect();
                    _limitViewPortPostion(viewFrame, function () {
                        _redraw();
                        self.trigger('view-frames-size-or-position-changed', [[_viewManager.getViewFrameById(cell.id)]]);
                    });
                    // ================================
                } else {
                    // Node/Link click
                    // ================================
                    var draggingNode = isDragging && (cell instanceof _elements.Node || cell instanceof _elements.TerminationNode);
                    var clickTerminationNode = cell instanceof _elements.TerminationNode;
                    var clickOnNodeOrLink = !(cell instanceof _elements.AspectLink); // Exclude AspectLink
                    if (draggingNode) {
                        _updateNodesPositions([cell]);
                    } else if (clickTerminationNode) {
                        _select(cell, true);
                    } else if (clickOnNodeOrLink) {
                        _select(cell);
                    }
                    // ================================
                }
                self.trigger('cell-single-click', cellView.model);
            }

            function onDoubleClick(cellView) {
                var element = cellView.model;
                if (element instanceof _elements.Node) {
                    element.set('expanded', !cellView.model.get('expanded'));
                    _updateNodesPositions([element]);
                }
                self.trigger('cell-double-click', cellView.model);
            }
        });

        var _mouseDownPosition = { x: 0, y: 0 };
        _paper.on('cell:pointerdown', function (cell, event) {
            _mouseDownPosition = { x: event.pageX, y: event.pageY };
            _clickCounter++;
        });

        _paper.on('cell:mousewheel', function (cell, evt, x, y, delta) {
            var SCROLL_STEP = 100;
            var viewFrame = _viewManager.getVieFrameByScreenPoint({ x: x, y: y });

            if (viewFrame) {
                if (evt.shiftKey) {
                    viewFrame.viewPortPosition.x += (delta < 0 ? 1 : -1) * SCROLL_STEP;
                    viewFrame.viewPortPosition = (0, _utils.limitPointPosition)(viewFrame.viewPortPosition, viewFrame.viewPortPositionBounds);
                    _delayedRedraw({ viewFrames: [viewFrame] }, function () {
                        self.trigger('view-frames-size-or-position-changed', [[viewFrame]]);
                    });
                } else if (evt.ctrlKey) {
                    var diff = delta > 0 ? _scaleStep : -_scaleStep;
                    var scale = {
                        x: _scale.x + diff,
                        y: _scale.y + diff
                    };
                    _updateScale(scale);
                    _delayedRedraw(undefined, function () {
                        _limitViewPortsPostions(_viewManager.getViewFrames());
                        self.trigger('scale-changed', scale);
                    });
                } else {
                    viewFrame.viewPortPosition.y += (delta < 0 ? 1 : -1) * SCROLL_STEP;
                    viewFrame.viewPortPosition = (0, _utils.limitPointPosition)(viewFrame.viewPortPosition, viewFrame.viewPortPositionBounds);
                    _delayedRedraw({ viewFrames: [viewFrame] }, function () {
                        self.trigger('view-frames-size-or-position-changed', [[viewFrame]]);
                    });
                }
                evt.preventDefault();
            }
        });

        window.onresize = function () {
            _correctScale();
            _delayedRedraw(undefined, function () {
                self.trigger('scale-changed');
            });
        };
    }

    function _updateNodesPositions(nodes) {
        var changedViewFrames = [];
        var overViewFrame = _viewManager.getOverViewFrame();

        nodes.forEach(function (n) {
            var node = (0, _dataUtils.getBaseElement)(n);
            var isTerminationNode = n instanceof _elements.TerminationNode;
            var viewFrameByPosition = _viewManager.getVieFrameForNodeByPosition(n);

            var prevOwnerFrame = _viewManager.getViewFrameOwner(node) || overViewFrame;
            var viewFrame = void 0;

            viewFrame = viewFrameByPosition || prevOwnerFrame;
            var draggedElementPosition = n.position(); // could be termination node

            if (isTerminationNode) {
                draggedElementPosition.x -= (node.size.width - n.size.width) / 2;
                draggedElementPosition.y -= (node.size.height - n.size.height) / 2;
            }

            var newGlobalPosition = (0, _utils.localToGlobalPoint)(draggedElementPosition, _fullScreenMode ? overViewFrame.scale : viewFrame.scale, _fullScreenMode ? overViewFrame : viewFrame);
            var oldGlobalPosition = (0, _utils.getGlobalNodePosition)(node);

            node.model.position = newGlobalPosition;
            node.viewFrameOwnerId = viewFrame.id;

            _dataContainer.updateZonesForNode(node, oldGlobalPosition);

            var addedFrameIds = changedViewFrames.map(function (vf) {
                return vf.id;
            });
            var prevOwnerNotAddedInList = addedFrameIds.indexOf(prevOwnerFrame.id) === -1;
            var viewFrameNotAddedInList = addedFrameIds.indexOf(viewFrame.id) === -1;
            if (prevOwnerNotAddedInList && prevOwnerFrame.active) {
                prevOwnerFrame.updateBounds = true;
                changedViewFrames.push(prevOwnerFrame);
            }
            if (viewFrameNotAddedInList && viewFrame.active) {
                viewFrame.updateBounds = true;
                changedViewFrames.push(viewFrame);
            }
        });

        if (_fullScreenMode) {
            overViewFrame.updateBounds = true;
            changedViewFrames.push(overViewFrame);
        }

        _redraw({ viewFrames: changedViewFrames });
        _limitViewPortsPostions(changedViewFrames, function () {
            self.trigger('nodes-position-changed', [nodes]);
        });
    }

    /**
     * Creates ui for ViewFrames.
     */
    function _createViewFramesUI(viewManager) {
        if (_base.ui) {
            var viewFramesUI = new _viewFramesUI3.default({
                rootEl: _base.ui,
                viewManager: viewManager
            }, parameters);

            viewFramesUI.on('splitter-position-changed', function (s, diffObj) {
                var isHorizontalOrientated = _orientation === 'left-to-right' || _orientation === 'right-to-left';
                var diff = diffObj.diff;
                var vfA = s.model.viewFrameA;
                var vfB = s.model.viewFrameB;
                var thereIsDifference = diff !== undefined && diff !== null;
                if (thereIsDifference) {
                    if (isHorizontalOrientated) {
                        vfA.size.width += diff;
                        vfB.size.width -= diff;
                        vfB.position.x += diff;
                    } else {
                        vfA.size.height += diff;
                        vfB.size.height -= diff;
                        vfB.position.y += diff;
                    }
                    vfA.customeSized;
                    vfB.customeSized;
                }
                if (diffObj.lastChange) {
                    _redraw({ viewFrames: [vfA, vfB], quickUpdate: false });
                    _limitViewPortsPostions([vfA, vfB]);
                } else if (thereIsDifference) {
                    _redraw({ viewFrames: [vfA, vfB], quickUpdate: true });
                }
            });

            viewFramesUI.on('view-port-position-changed', function (viewFrame) {
                var relevantViewFrame = _viewManager.getViewFrameById(viewFrame.id);
                _positionViewPort(relevantViewFrame, viewFrame.viewPortPosition, parameters.animation, function () {
                    var changedViewFrame = _viewManager.getViewFrameById(viewFrame.id);
                    self.trigger('view-frames-size-or-position-changed', [[changedViewFrame]]);
                });
            });

            viewFramesUI.on('view-frame-collapsed', function (viewFrame) {
                viewFrame.expanded = false;
                _closeViewFrame(viewFrame.id);
            });

            return viewFramesUI;
        }
    }

    /**
    * Creates html base for diagram.
    */
    function _createBase(baseDiv) {
        baseDiv.innerHTML = '';

        var diagram = document.createElement('DIV');
        diagram.className = 'tq-lg-lineage-diagram';
        diagram.id = 'tq_lineage-graph';
        baseDiv.appendChild(diagram);

        var ui = document.createElement('DIV');
        ui.className = 'tq-lg-lineage-ui';
        baseDiv.appendChild(ui);

        return { ui: ui, diagram: diagram };
    }

    /**
     * Clears selected object.
     * @param {boolean} silent - blocks throwing of event
     * @fires selected-element-changed
     */
    function _unselect(silent) {
        if (_selectedElement) {
            _path = null;
            _selectedElement.unselect();
            _selectedElement = null;

            if (!silent) {
                _redraw();
                self.trigger('selected-element-changed', null);
            }
        }
    }

    /**
     * Sets selected object and changes viewPort position if it's needed.
     * @param {Node|Link} element
     * @param {boolean} focusOn
     * ========================
     * @fires selected-element-changed
     */
    function _select(element, focusOn) {
        var selectedElement = (0, _dataUtils.getBaseElement)(element);

        if (selectedElement !== _selectedElement) {
            if (_selectedElement) _selectedElement.unselect();
            _selectedElement = selectedElement;
            _selectedElement.select();
        }

        if (focusOn) {
            _focusOnElement(_selectedElement, function () {
                _path = (0, _lineageDiagramUtils.getPath)(_selectedElement, _dataContainer);
                _redraw();
                self.trigger('selected-element-changed', element);
            });
        } else {
            setTimeout(function () {
                _path = (0, _lineageDiagramUtils.getPath)(_selectedElement, _dataContainer);
                _redraw();
                self.trigger('selected-element-changed', element);
            }, 0);
        }
    }

    /**
     * It moves position of the viewPort so that
     * the selected element appears in the senter of the viewPort
     * @param {Node|Link} element
     * @param {function} callback - _focusOnElement can be asynchronous depends on animation mode
     */
    function _focusOnElement(element, callback) {
        var focusNode = null;
        if (element instanceof _elements.Link) {
            focusNode = _dataContainer.maps.nodeMap[element.model.source];
        } else if (element instanceof _elements.Node) {
            focusNode = element;
        }
        if (focusNode) {
            var viewFrame = _viewManager.getViewFrameForNode(focusNode);
            if (!viewFrame.active) {
                _redraw({ viewFrames: [{ id: viewFrame.id, expanded: true }], quickUpdate: true });
                viewFrame = _viewManager.getViewFrameById(viewFrame.id);
                self.trigger('view-frames-state-changed', [[viewFrame]]);
            }
            var nodeSize = (0, _utils.getGlobalNodeSize)(focusNode, viewFrame.scale);
            var nodePosition = (0, _utils.getGlobalNodePosition)(focusNode);
            var viewPortSize = (0, _utils.scaledToGlobalSize)(viewFrame.size, viewFrame.scale);

            var targetPosition = { // Global
                x: nodePosition.x + (nodeSize.width - viewPortSize.width) / 2,
                y: nodePosition.y + (nodeSize.height - viewPortSize.height) / 2
            };

            _positionViewPort(viewFrame, targetPosition, parameters.animation, function () {
                callback();
                var changedViewFrame = _viewManager.getViewFrameById(viewFrame.id);
                self.trigger('view-frames-size-or-position-changed', [[changedViewFrame]]);
            });
        }
    }

    /**
     * All viewPort position changes should be performed through this methods.
     * _positionViewPort (exclude scale)
     * It's needed to stop animation in case of animation haven't been done.
     */

    /**
     * It sets offset for all elements into the viewPort.
     * @param {ViewFrame} viewFrame
     * @param {Point} point
     * @param {boolean} animation - it's optional
     * @param {function} callback - it's called after focus
     */
    function _positionViewPort(viewFrame, point, animation, callback) {
        var relevatnViewFrame = _viewManager.getViewFrameById(viewFrame.id);
        var targetPos = (0, _utils.limitPointPosition)(point, relevatnViewFrame.viewPortPositionBounds);
        var viewPortPosition = relevatnViewFrame.viewPortPosition;
        var targetIsReached = viewPortPosition.x === targetPos.x && viewPortPosition.y === targetPos.y;

        if (!animation || targetIsReached || !viewFrame.active) {
            cancelAnimationFrame(_animationId);
            viewFrame.viewPortPosition = targetPos;
            _redraw({ viewFrames: [viewFrame], quickUpdate: true });
            if (callback) callback();
        } else {
            _animatedViewPortChanging(relevatnViewFrame, targetPos, callback);
        }
    }

    function _limitViewPortsPostions(viewFrames, callback) {
        recursiveCall(0);

        function recursiveCall(index) {
            var viewFrame = viewFrames[index];
            if (!viewFrame) {
                if (callback) callback();
                return;
            }

            var targetViewFrame = _viewManager.getViewFrameById(viewFrame.id);
            if (!targetViewFrame) {
                if (callback) callback();
                return;
            }

            _limitViewPortPostion(targetViewFrame, function () {
                if (index < viewFrames.length) {
                    recursiveCall(index + 1);
                } else {
                    var changedViewFramesModels = viewFrames.map(function (vf) {
                        return _viewManager.getViewFrameById(vf.id);
                    });
                    self.trigger('view-frames-size-or-position-changed', [changedViewFramesModels]);
                    if (callback) callback();
                }
            });
        }
    }

    function _limitViewPortPostion(viewFrame, callback) {
        var limittedPosition = (0, _utils.limitPointPosition)(viewFrame.viewPortPosition, viewFrame.viewPortPositionBounds);
        var positionIsIncorrect = limittedPosition.x !== viewFrame.viewPortPosition.x || limittedPosition.y !== viewFrame.viewPortPosition.y;
        if (positionIsIncorrect) {
            _positionViewPort(viewFrame, limittedPosition, parameters.animation, callback);
        } else if (callback) {
            callback();
        }
    }

    /**
     * Chages viewPort position smoothly from current position to target.
     * @param {ViewFrame} vf
     * @param {Point} targetPos
     * @param {function} callback
     */
    var _animationId = undefined;
    function _animatedViewPortChanging(viewFrame, targetPos, callback) {
        var startPos = viewFrame.viewPortPosition;

        var diffX = (0, _utils.getDiff)(startPos.x, targetPos.x);
        var diffY = (0, _utils.getDiff)(startPos.y, targetPos.y);
        var scale = viewFrame.scale || _scale;
        var defaultStepX = parameters.animationStep / scale.x;
        var defaultStepY = parameters.animationStep / scale.y;

        var stepX = void 0,
            stepY = void 0;
        if (diffX > diffY) {
            stepX = defaultStepX;
            stepY = defaultStepX * (diffY / diffX);
        } else {
            stepX = defaultStepY * (diffX / diffY);
            stepY = defaultStepY;
        }

        var startDistance = (0, _utils.getDist)(viewFrame.viewPortPosition, targetPos);

        cancelAnimationFrame(_animationId);

        var time = void 0;
        reqursiveAnimation();

        function reqursiveAnimation(oldPos) {
            _animationId = requestAnimationFrame(function () {
                var now = new Date().getTime();
                var timeRate = 1000 / (now - time) || parameters.minFrameRate;

                var tModifier = 1;
                if (parameters.minFrameRate > timeRate) {
                    tModifier = parameters.minFrameRate / timeRate;
                }
                if (timeRate > parameters.maxFrameRate) {
                    tModifier = parameters.maxFrameRate / timeRate;
                }
                time = now;

                var curPos = viewFrame.viewPortPosition;
                var targetIsReached = curPos.x === targetPos.x && curPos.y === targetPos.y;
                var weAreNotMoving = oldPos && curPos.x === oldPos.x && curPos.y === oldPos.y;

                if (targetIsReached || weAreNotMoving) {
                    _delayedRedraw({ viewFrames: [viewFrame] });
                    // _redraw({ viewFrames: [viewFrame], quickUpdate: false });
                    cancelAnimationFrame(_animationId);
                    if (callback) callback();
                    return;
                } else {
                    var _diffX = (0, _utils.getDiff)(curPos.x, targetPos.x);
                    var _diffY = (0, _utils.getDiff)(curPos.y, targetPos.y);

                    var newPos = { x: curPos.x, y: curPos.y };

                    var curDistance = (0, _utils.getDist)(curPos, targetPos);
                    var k = 1 - Math.cos(Math.PI * (startDistance - curDistance) / startDistance) * 0.3;

                    var finalStepX = stepX;
                    var finalStepY = stepY;

                    if (newPos.x !== targetPos.x) {
                        var d = Math.min(_diffX, finalStepX * k * tModifier);
                        newPos.x += curPos.x < targetPos.x ? d : -d;
                    }
                    if (newPos.y !== targetPos.y) {
                        var _d = Math.min(Math.abs(_diffY), finalStepY * k * tModifier);
                        newPos.y += curPos.y < targetPos.y ? _d : -_d;
                    }
                    viewFrame.viewPortPosition = newPos;

                    _redraw({ viewFrames: [viewFrame], quickUpdate: true });

                    reqursiveAnimation(curPos);
                }
            });
        }
    }

    /**
     * Refreshes all viewFrames bounds.
     */
    function _refresh(viewFrames) {
        viewFrames = viewFrames || _viewManager.getViewFrames();
        _redraw({ viewFrames: viewFrames, updateBounds: true });
        _limitViewPortsPostions(viewFrames);
    }

    function _resetLayout() {
        var viewFrameAffectedIds = {};
        var overViewFrameId = _viewManager.getOverViewFrame().id;

        _dataContainer.nodes.forEach(function (node) {
            if (node.model.defaultPosition) {
                var curPos = (0, _utils.getGlobalNodePosition)(node);
                node.model.position = node.model.defaultPosition;
                _dataContainer.updateZonesForNode(node, curPos);
                if (node.viewFrameOwnerId) viewFrameAffectedIds[node.viewFrameOwnerId] = true;

                var isFullScreenMode = _viewManager.isFullScreenMode();
                viewFrameAffectedIds[isFullScreenMode ? overViewFrameId : node.model.viewFrame] = true;
                delete node.viewFrameOwnerId;
            }
        });
        var viewFrames = Object.keys(viewFrameAffectedIds).map(function (key) {
            return { id: key, updateBounds: true };
        });
        _redraw({ viewFrames: viewFrames });
        _limitViewPortsPostions(viewFrames);
    }
}

},{"../htmlUI/viewFramesUI":39,"../layout/layout":57,"../subscriptionAPI/subscribeable":66,"../utils/dataUtils":67,"../utils/lineageDiagramUtils":69,"../utils/utils":70,"./graphElements/elements":47,"./linkRoutingManager/routingManager":53,"./toSvg":54,"./viewFrame":55,"./viewManager":56,"file-saverjs":2,"lodash":"lodash","rappid":"rappid"}],53:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ENABLE_ROUTINGS = undefined;
exports.RoutingManager = RoutingManager;

var _lodash = require('lodash');

var _ = _interopRequireWildcard(_lodash);

var _rappid = require('rappid');

var joint = _interopRequireWildcard(_rappid);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var g = joint.g;
var LINK_OFFSET = 7;

var ENABLE_ROUTINGS = exports.ENABLE_ROUTINGS = ['metro', 'normal', 'manhattan', 'orthogonal', 'lgrouter'];

/**
 * RoutingManager
 * @private
 * @param {linkRouting, links, bounds} options 
 * @param {*} parameters 
 */
function RoutingManager(options, parameters) {
    var self = this;

    var _links = void 0;
    var _routing = options.linkRouting || parameters.linkRouting;

    var _vertexMap = {};
    var _idToVertex = {};
    var _bounds = options.bounds;

    self.setData = _setData;
    self.setRouting = _setRouting;
    self.resetRouting = _resetRouting;
    self.setBounds = _setBounds;

    self.getRouting = function () {
        return _routing;
    };

    function _init() {
        _setData(options.links);
        joint.routers.lgrouter = lgrouter;
        joint.routers.metro = newMetro;
    }

    function _setBounds(bounds) {
        _bounds = bounds;
    }

    function _setData(links) {
        _links = links;
        _updateLinkRouting();
    }

    function _setRouting(routing) {
        var isUnknownRoutingId = ENABLE_ROUTINGS.indexOf(routing) === -1;
        if (isUnknownRoutingId) {
            routing = 'metro';
        }
        if (routing !== _routing) {
            _routing = routing;
            _updateLinkRouting();
        }
    }

    function _updateLinkRouting() {
        _vertexMap = {};
        _idToVertex = {};
        _links.forEach(function (link) {
            var router = {
                name: _routing,
                args: link.get('router').args
            };
            link.set('router', router, link.isOnTheGraph() ? {} : { silent: true });
        });
    }

    function _resetRouting() {
        _vertexMap = {};
        _idToVertex = {};
    }

    // Routers
    // =========================================

    var lgrouter = function () {
        return function (manualVertices, opts, linkView) {
            var defaultCofig = {
                step: 10
            };
            var vertices = joint.routers.manhattan(manualVertices, _.extend({}, defaultCofig, opts), linkView);

            this._findConnectionPoints(vertices);

            var allVertices = findIntermediateVertices([this.sourcePoint].concat(vertices).concat([this.targetPoint]),
            // vertices.length > 0 ? vertices : [this.sourceBBox.center(), this.targetBBox.center()],
            defaultCofig.step);

            var translatedVertices = [];
            clearVertices(linkView);

            var maxOffset = { x: 0, y: 0 };
            for (var i = 0; i < allVertices.length; i++) {
                var prevVertex = allVertices[i - 1];
                var vertex = allVertices[i];
                var nextVertex = allVertices[i + 1];
                vertex.type = getPositionType(prevVertex, vertex, nextVertex);
                maxOffset = getOffset(vertex, maxOffset);
            }

            allVertices.forEach(function (vertex) {
                var newVertex = storeVeertex(vertex, maxOffset, linkView);
                if (vertices.indexOf(vertex) !== -1) {
                    translatedVertices.push(newVertex);
                }
            });

            return translatedVertices.map(function (vertex) {
                return {
                    x: Math.min(Math.max(vertex.x, _bounds.x), _bounds.x + _bounds.width),
                    y: Math.min(Math.max(vertex.y, _bounds.y), _bounds.y + _bounds.height)
                };
            });
        };
    }();

    var newMetro = function () {
        var config = {
            // cost of a diagonal step (calculated if not defined).
            diagonalCost: null,
            // an array of directions to find next points on the route
            directions: function directions() {
                var step = this.step;
                var diagonalCost = this.diagonalCost || Math.ceil(Math.sqrt(step * step << 1));

                return [{ offsetX: step, offsetY: 0, cost: step }, { offsetX: step, offsetY: step, cost: diagonalCost }, { offsetX: 0, offsetY: step, cost: step }, { offsetX: -step, offsetY: step, cost: diagonalCost }, { offsetX: -step, offsetY: 0, cost: step }, { offsetX: -step, offsetY: -step, cost: diagonalCost }, { offsetX: 0, offsetY: -step, cost: step }, { offsetX: step, offsetY: -step, cost: diagonalCost }];
            },
            maxAllowedDirectionChange: 45,
            // a simple route used in situations, when main routing method fails
            // (exceed loops, inaccessible).
            fallbackRoute: function fallbackRoute(from, to) {
                // Find a route which breaks by 45 degrees ignoring all obstacles.
                var theta = from.theta(to);

                var a = { x: to.x, y: from.y };
                var b = { x: from.x, y: to.y };

                if (theta % 180 > 90) {
                    var t = a;
                    a = b;
                    b = t;
                }

                var p1 = theta % 90 < 45 ? a : b;
                var l1 = g.line(from, p1);
                var alpha = 90 * Math.ceil(theta / 90);
                var p2 = g.point.fromPolar(l1.squaredLength(), g.toRad(alpha + 135), p1);
                var l2 = g.line(to, p2);
                var point = l1.intersection(l2);

                return point ? [point.round(), to] : [to];
            }
        };

        // public function
        return function (vertices, opts, linkView) {
            return lgrouter.call(this, vertices, _.extend({}, config, opts), linkView);
        };
    }();

    // =========================================

    function getPositionType(prevVertex, vertex, nextVertex) {
        if (prevVertex || nextVertex) {
            var x = Math.round(vertex.x);
            var y = Math.round(vertex.y);
            var equalX = (!prevVertex || Math.round(prevVertex.x) === x) && (!nextVertex || Math.round(nextVertex.x) === x);
            var equalY = (!prevVertex || Math.round(prevVertex.y) === y) && (!nextVertex || Math.round(nextVertex.y) === y);
            if (equalX) {
                return 'vertical';
            } else if (equalY) {
                return 'horizontal';
            } else {
                return 'point';
            }
        } else {
            return 'point';
        }
    }

    function applyOffset(vertex, offset) {
        var isHorizontal = vertex.type === 'horizontal';
        var isVerical = vertex.type === 'vertical';
        return {
            x: vertex.x + (isHorizontal ? 0 : offset.x),
            y: vertex.y + (isVerical ? 0 : offset.y),
            type: vertex.type
        };
    }

    function getId(vertex) {
        return Math.round(vertex.x) + '@' + Math.round(vertex.y) + ':' + vertex.type;
    }

    // function getOffset (vertex, defaultOffset) {
    //     const curVertex = applyOffset(vertex, defaultOffset);
    //     const vId = getId(curVertex);

    //     if (_vertexMap[vId]) {
    //         const isHorizontal = vertex.type === 'horizontal'; 
    //         const isVerical = vertex.type === 'vertical';
    //         return getOffset (vertex, {
    //             x: defaultOffset.x + (isHorizontal ? 0 : -LINK_OFFSET),
    //             y: defaultOffset.y + (isVerical ? 0 : LINK_OFFSET),
    //         });
    //     } else {
    //         return defaultOffset;
    //     }
    // }

    function getOffset(vertex, defaultOffset) {
        var isHorizontal = vertex.type === 'horizontal';
        var isVerical = vertex.type === 'vertical';

        var curOffset = defaultOffset;
        var curVertex = applyOffset(vertex, defaultOffset);
        var curId = getId(curVertex);

        var xType = defaultOffset.x === 0 ? 'trigger' : defaultOffset.x > 0 ? 'rise' : 'fall';
        var yType = defaultOffset.y === 0 ? 'trigger' : defaultOffset.y > 0 ? 'rise' : 'fall';
        var xTrigger = 1;
        var yTrigger = 1;
        var xStep = 0;
        var yStep = 0;
        while (_vertexMap[curId]) {
            curOffset = { x: defaultOffset.x, y: defaultOffset.y };
            if (xType === 'trigger') {
                xTrigger = -xTrigger;
                if (xTrigger < 0) {
                    xStep++;
                }
            } else if (xType === 'rise') {
                xStep++;
            } else {
                xStep--;
            }
            if (yType === 'trigger') {
                yTrigger = -yTrigger;
                if (yTrigger < 0) {
                    yStep++;
                }
            } else if (yType === 'rise') {
                yStep++;
            } else {
                yStep--;
            }
            curOffset = {
                x: defaultOffset.x + (isHorizontal ? 0 : xStep * LINK_OFFSET * xTrigger),
                y: defaultOffset.y + (isVerical ? 0 : yStep * LINK_OFFSET * yTrigger)
            };

            curVertex = applyOffset(vertex, curOffset);
            curId = getId(curVertex);
        }

        return curOffset;
    }

    function clearVertices(linkView) {
        if (_idToVertex[linkView.model.id]) {
            _idToVertex[linkView.model.id].forEach(function (vertexId) {
                delete _vertexMap[vertexId];
            });
            delete _idToVertex[linkView.model.id];
        }
    }

    function storeVeertex(vertex, offset, linkView) {
        var newVertex = applyOffset(vertex, offset);

        var vertexId = getId(newVertex);
        _vertexMap[vertexId] = newVertex;

        if (!_idToVertex[linkView.model.id]) {
            _idToVertex[linkView.model.id] = [];
        }
        _idToVertex[linkView.model.id].push(vertexId);
        return newVertex;
    }

    function findIntermediateVertices(vertices, step) {
        var allVertices = [];
        var prev = undefined;
        vertices.forEach(function (vertex) {
            if (prev !== undefined) {
                var isVertical = prev.x === vertex.x;
                var isHorizontal = prev.y === vertex.y;

                if (isVertical) {
                    if (prev.y < vertex.y) {
                        for (var y = prev.y + step; y < vertex.y; y += step) {
                            allVertices.push({ x: vertex.x, y: y });
                        }
                    } else {
                        for (var _y = prev.y - step; _y > vertex.y; _y -= step) {
                            allVertices.push({ x: vertex.x, y: _y });
                        }
                    }
                } else if (isHorizontal) {
                    if (prev.x < vertex.x) {
                        for (var x = prev.x + step; x < vertex.x; x += step) {
                            allVertices.push({ x: x, y: vertex.y });
                        }
                    } else {
                        for (var _x = prev.x - step; _x > vertex.x; _x -= step) {
                            allVertices.push({ x: _x, y: vertex.y });
                        }
                    }
                }
            }
            allVertices.push(vertex);
            prev = vertex;
        });

        return allVertices;
    }

    _init();
}

},{"lodash":"lodash","rappid":"rappid"}],54:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EXCLUDED_ELEMENTS = exports.PNG_CONTENT_PADDING = exports.FOREIGN_OBJECT_PADDING = undefined;
exports.exportToSVG = exportToSVG;
exports.toDataURL = toDataURL;
exports.fitRectKeepingAspectRatio = fitRectKeepingAspectRatio;

var _lodash = require('lodash');

var _ = _interopRequireWildcard(_lodash);

var _rappid = require('rappid');

var joint = _interopRequireWildcard(_rappid);

var _elements = require('./graphElements/elements');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var FOREIGN_OBJECT_PADDING = exports.FOREIGN_OBJECT_PADDING = 2; // in px
var PNG_CONTENT_PADDING = exports.PNG_CONTENT_PADDING = 1; // in px
var EXCLUDED_ELEMENTS = exports.EXCLUDED_ELEMENTS = ['.dn-arrow', 'img', '.derivation-node_body-scroller'];

function exportToSVG(paper, props) {
    props = props || {};

    var vpTransform = paper.viewport.getAttribute('transform');
    paper.viewport.removeAttribute('transform');

    // const paperBoundingBox = paper.viewport.getBBox();
    var paperBoundingBox = paper.getContentBBox();
    var svgCopy = props.convertHtml ? createSVGCopy(paper) : simpleClone(paper);

    paper.viewport.setAttribute('transform', vpTransform || '');

    if (props.pdfMode) {
        svgCopy.removeAttribute('style');
        svgCopy.setAttribute('preserveAspectRatio', 'xMidYMid meet');
        svgCopy.removeAttribute('height');
        if (props.preserveDimensions) {
            svgCopy.setAttribute('width', paperBoundingBox.width.toString());
        } else {
            svgCopy.setAttribute('width', '100%');
        }

        var PADDING = 40;
        svgCopy.setAttribute('viewBox', [paperBoundingBox.x - PADDING, paperBoundingBox.y - PADDING, paperBoundingBox.x + paperBoundingBox.width + PADDING, paperBoundingBox.y + paperBoundingBox.height + PADDING].join(' '));
    } else {
        svgCopy.removeAttribute('style');
        if (props.preserveDimensions) {
            svgCopy.setAttribute('width', paperBoundingBox.width.toString());
            svgCopy.setAttribute('height', paperBoundingBox.height.toString());
        } else {
            svgCopy.setAttribute('width', '100%');
            svgCopy.setAttribute('height', '100%');
        }

        svgCopy.setAttribute('viewBox', '' + paperBoundingBox.x + ' ' + paperBoundingBox.y + ' ' + paperBoundingBox.width + ' ' + paperBoundingBox.height);
    }

    var isIE = !window.ActiveXObject && 'ActiveXObject' in window;

    if (isIE) {
        alignText(svgCopy.querySelectorAll('text'));

        //Shim SVGElement classList
        if (!Object.getOwnPropertyDescriptor(SVGElement.prototype, 'classList')) {
            if (HTMLElement && Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'classList')) {
                var descriptor = Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'classList');
                Object.defineProperty(SVGElement.prototype, 'classList', descriptor);
            }
        }
    }

    // workaround to include only ontodia-related stylesheets
    var cssStrings = extractCSSFromPaper(svgCopy);

    var defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
    defs.id = 'extracted-styles'; // For IE-EDGE
    cssStrings.forEach(function (cssString, index) {
        var mocDiv = document.createElement('DIV');
        mocDiv.id = 'extracted-file-' + index;
        mocDiv.innerHTML = '<style>' + cssStrings + '</style>';
        defs.appendChild(mocDiv.firstChild);
    });
    svgCopy.insertBefore(defs, svgCopy.firstChild);

    if (props.elementsToRemoveSelector) {
        processNodes(svgCopy.querySelectorAll(props.elementsToRemoveSelector), function (node) {
            return node.remove();
        });
    }
    return convertImages(svgCopy.querySelectorAll('image')).then(function () {
        return new XMLSerializer().serializeToString(svgCopy);
    });
}

function alignText(textBlocks) {
    processNodes(textBlocks, function (text) {
        var anchor = text.getAttribute('text-anchor');
        var transform = text.getAttribute('transform');
        if (anchor === 'middle' && transform.indexOf('translate')) {
            text.removeAttribute('text-anchor');
            var y = transform.match(/,([\d,.]+)\)/)[1];
            text.setAttribute('transform', 'translate(' + _elements.LABEL_LEFT_RIGHT_PADDING + ', ' + y + ')');
        }
    });
}

function convertImages(images) {
    var promises = [];
    processNodes(images, function (image) {
        promises.push(new Promise(function (resolve) {
            if (!image) resolve();

            // Firefox uses `href`, all the others 'xlink:href'
            var url = image.getAttribute('xlink:href') || image.getAttribute('href');

            joint.util.imageToDataUri(url, function (err, dataUri) {
                image.setAttribute('xlink:href', dataUri);
                resolve();
            });
        }));
    });
    return Promise.all(promises);
}

var EXCLUDED_SELECTORS = ['body'];
function extractCSSFromPaper(paper) {
    var cssTexts = [];
    var allElements = paper.querySelectorAll('*');

    var allowedCssClasses = [];
    for (var i = 0; i < allElements.length; i++) {
        var element = allElements[i];

        var classesList = element.classList;
        for (var j = 0; j < classesList.length; j++) {
            allowedCssClasses.push(classesList[j]);
        }
    }

    for (var _i = 0; _i < document.styleSheets.length; _i++) {
        var cssClasses = void 0;
        try {
            var cssFile = document.styleSheets[_i];
            cssClasses = cssFile.cssRules || cssFile.rules;
            if (!cssClasses) {
                continue;
            }
        } catch (e) {
            continue;
        }

        var cssClassText = [];

        for (var _j = 0; _j < cssClasses.length; _j++) {
            var rule = cssClasses[_j];
            var doesContainAllowedClass = containsAllowedClass(rule.selectorText, allowedCssClasses);
            var allowedSelector = EXCLUDED_SELECTORS.indexOf(rule.selectorText) === -1 && doesContainAllowedClass;
            if (rule instanceof CSSStyleRule && allowedSelector) {
                cssClassText.push(rule.cssText);
            }
        }

        cssTexts.push(cssClassText.join('\n'));
    }

    function containsAllowedClass(cssSelector, allowedCssClasses) {
        if (!cssSelector) return true;
        for (var _i2 = 0; _i2 < allowedCssClasses.length; _i2++) {
            if (cssSelector.indexOf(allowedCssClasses[_i2]) !== -1) {
                return true;
            }
        }
        return false;
    }

    return cssTexts;
}

function simpleClone(paper) {
    var svgClone = paper.svg.cloneNode(true);
    return svgClone;
}

function createSVGCopy(paper) {
    var svgClone = paper.svg.cloneNode(true);
    var cells = paper.model.get('cells');
    processNodes(svgClone.querySelectorAll('g.element'), function (cellView) {
        var id = cellView.getAttribute('model-id');
        var htmlView = paper.el.querySelector('.derivation-node[id=\'' + id + '\']');
        if (!htmlView) {
            return;
        }

        var content = void 0;
        var isItIE11 = Boolean(navigator.userAgent.match(/Trident.*rv\:11\./));
        if (isItIE11) {
            content = processHTML(htmlView, EXCLUDED_ELEMENTS);
        } else {
            content = document.createElementNS('http://www.w3.org/2000/svg', 'foreignObject');
            var cell = cells.get(id);
            var cellSize = cell.get('size');

            content.setAttribute('width', cellSize.width + FOREIGN_OBJECT_PADDING);
            content.setAttribute('height', cellSize.height + FOREIGN_OBJECT_PADDING);

            var htmlContent = htmlView.cloneNode(true);
            htmlContent.style.transform = null;

            var body = htmlView.querySelector('.derivation-node_body');
            var newBodies = htmlContent.querySelector('.derivation-node_body');
            if (body.scrollTop !== 0) {
                newBodies.firstChild.style.marginTop = -body.scrollTop + 'px';
            }
            content.appendChild(htmlContent);
        }

        cellView.setAttribute('class', cellView.getAttribute('class'));

        var anchor = cellView.querySelector('.export-anchor');
        anchor.removeAttribute('transform');

        var root = cellView.querySelector('.body');
        anchor.removeChild(root);
        anchor.appendChild(content);
    });

    return svgClone;
}

function processHTML(htmlView, excludedElements) {
    var g = document.createElementNS('http://www.w3.org/2000/svg', 'g');

    function recursion(htmlRoot) {
        if (htmlRoot instanceof HTMLElement) {
            if (checkElement(htmlRoot)) {
                var rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                var offsetTop = getOffsetTop(htmlRoot);
                var offsetLeft = getOffsetLeft(htmlRoot);
                var style = window.getComputedStyle(htmlRoot);

                // svgRect.setAttribute('className', htmlRoot.className);
                rect.setAttribute('fill', style.backgroundColor);
                rect.setAttribute('stroke', style.borderColor);
                rect.setAttribute('stroke-width', style.borderWidth);
                rect.setAttribute('x', offsetLeft);
                rect.setAttribute('y', offsetTop);
                rect.setAttribute('width', style.width);
                rect.setAttribute('height', style.height);

                g.appendChild(rect);
                processNodes(htmlRoot.childNodes, function (child) {
                    recursion(child, true);
                });
            }
        } else if (htmlRoot instanceof Text) {
            var textContent = htmlRoot.textContent.trim();
            if (textContent.length === 0) return;

            var text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            var parent = htmlRoot.parentNode;

            var _offsetTop = getOffsetTop(parent);
            var _offsetLeft = getOffsetLeft(parent);
            var _style = window.getComputedStyle(parent);

            text.setAttribute('fill', _style.color);
            text.setAttribute('alignment-baseline', 'hanging');
            text.setAttribute('x', _offsetLeft);
            text.setAttribute('y', _offsetTop);

            var maxCharNumber = getMaxCharNumber(textContent, +_style.width.substring(0, _style.width.length - 2), _style.font);
            if (maxCharNumber === textContent.length) {
                text.textContent = textContent;
            } else {
                var ELIPSIS_LENGTH = 2;
                text.textContent = textContent.substring(0, maxCharNumber - ELIPSIS_LENGTH) + '...';
            }

            g.appendChild(text);
        }
    }

    function checkElement(element) {
        for (var i = 0; i < excludedElements.length; i++) {
            // IE11 fix
            var matches = element.matches ? element.matches : element.msMatchesSelector;
            if (matches.apply(element, [excludedElements[i]])) {
                return false;
            }
        }
        return true;
    }

    function getOffsetTop(element) {
        if (element.className !== 'derivation-node') {
            return element.offsetTop + element.clientTop + (element.offsetParent ? getOffsetTop(element.offsetParent) : 0);
        } else {
            return 0;
        }
    }

    function getOffsetLeft(element) {
        if (element.className !== 'derivation-node') {
            return element.offsetLeft + element.clientLeft + (element.offsetParent ? getOffsetLeft(element.offsetParent) : 0);
        } else {
            return 0;
        }
    }

    function getMaxCharNumber(text, maxWidth, font) {
        var canvas = document.createElement('canvas');
        var ctx = canvas.getContext('2d');
        ctx.font = font;

        var textWidth = ctx.measureText(text).width;
        if (textWidth <= maxWidth) {
            return text.length;
        } else {
            var FIT_CORRECTION = 0.85;
            return Math.floor(text.length * (maxWidth / textWidth) * FIT_CORRECTION);
        }
    }

    recursion(htmlView);

    return g;
}

function processNodes(nodes, callback) {
    for (var i = 0; i < nodes.length; i++) {
        callback(nodes[i]);
    }
}

function toDataURL(paper, options) {
    return new Promise(function (resolve) {
        var svgOptions = _.clone(options.svgOptions);

        var oldToSvg = paper.toSVG;
        paper.toSVG = function (callback) {
            exportToSVG(paper, svgOptions).then(function (svgString) {
                callback(svgString);
            });
        };
        paper.toPNG(function (image) {
            resolve(image);
        });
        paper.toSVG = oldToSvg;
    });
}

function fitRectKeepingAspectRatio(sourceWidth, sourceHeight, targetWidth, targetHeight) {
    if (!targetWidth && !targetHeight) {
        return { width: sourceWidth, height: sourceHeight };
    }
    var ratio = sourceWidth / sourceHeight;
    targetWidth = targetWidth || targetHeight * ratio;
    targetHeight = targetHeight || targetWidth / ratio;

    if (targetHeight * ratio <= targetWidth) {
        return { width: targetHeight * ratio, height: targetHeight };
    } else {
        return { width: targetWidth, height: targetWidth / ratio };
    }
}

exports.default = exportToSVG;

},{"./graphElements/elements":47,"lodash":"lodash","rappid":"rappid"}],55:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ViewFrame = ViewFrame;
exports.OverViewFrame = OverViewFrame;

var _rappid = require('rappid');

var joint = _interopRequireWildcard(_rappid);

var _utils = require('../utils/utils');

var _elements = require('./graphElements/elements');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var HOR_LABEL_PADDING = 8;
var VERT_LABEL_PADDING = 6;
var FONT_SIZE = 11;
var DEFAULT_FRAME_SIZE = { width: 50, height: 50 };

/**
 * Bounds
 * @typedef {Object} Bounds
 * @property {number} maxX
 * @property {number} minX
 * @property {number} maxY
 * @property {number} minY
 * @property {number} width
 * @property {number} height
*/

/**
 * @private
 * @class
 * ViewFrame of the main view (View-2).
 * Provides visible elements to the LineageDiagram.
 * Based on joint.shapes.basic.Rect.
 *
 * Constructor parameters:
 * ========================================
 * @param {
 *  dataContainer: DataContainer
 *  id: string
 *  backgroundColor: string
 *  borderColor: string
 *  spaceShare: number
 * } options
 * @param {Parameters} parameters - parameters set
 *
 * Public properties:
 * ========================================
 * id: string
 * model: @param options
 * constPosition: Point
 * size: Size (width, height)
 * movingByItself: boolena - it's flag to block a moving
 *
 * Public methods:
 * ========================================
 * refreshNodeState: (node: Node) => void;
 * getNodes: () => Node[];
 * updateBounds: () => void;
 * clear: () => void;
 * getNodeBounds: () => Bounds;
 * getViewPortBounds: () => Bounds;
 * setData: (dataContainer: DataContainer) => void
 * getVisibleCells: () => { nodes: Node[], link: Link[] };
 * calculateVisibleCells: () => void;
 * setPosition: (pos: Point) => void;
 * setSize: (size: Size) => void;
 * positionViewPort: (x: number, y: number) => Point;
 * resetSize: () => void;
 * hitScaledPointTest (point: Point) => boolean;
 * hitTest (node: Node, partialHit: boolean) => boolean;
 * ownerTest (node: Node) => boolean;
 * setScale: (scale: Point) => void;
 * getScale: () => Point;
 * setElementSize: (size: ElementSize) => void;
 * getElementSize: () => ElementSize;
 * limitNodePosition: (node: Node) => void;
 *
 * Events
 * ========================================
 * @fires change:correctPostion (limittedPoint: Point)
 * @fires change-view-port-position (newPosition: Point)
 *
 */
function ViewFrame(options, parameters) {
    // Init
    // ===================================================================
    // ===================================================================

    var self = this;
    self.id = options.id;
    self.model = options;
    self.constPosition = { x: 0, y: 0 };

    self.size = DEFAULT_FRAME_SIZE;
    self.movingByItself = false;

    if (options.singleMode) {
        options.dataContainer.nodes.forEach(function (n) {
            return n.viewFrameOwnerId = self.id;
        });
    }

    self.selectedElement;

    var _cachedResult = void 0;
    var _nodeBounds = void 0;
    var _viewPortPositionBounds = void 0;
    var _dataContainer = options.dataContainer;
    var _scale = void 0;
    var _viewPortPosition = { x: 0, y: 0 }; // global coordinates
    var _defaultElementSize = parameters.elementSize;
    var _referenceSize = _defaultElementSize;
    var _viewPortBounds = void 0;

    var _framePadding = parameters.framePadding;
    var label = joint.util.breakText(options.label, {
        width: self.size.width - HOR_LABEL_PADDING * 2
    });

    joint.shapes.basic.Rect.apply(self, [{
        id: options.id,
        type: 'viewFrame',
        position: { x: 0, y: 0 },
        size: self.size,
        attrs: {
            rect: {
                fill: options.backgroundColor,

                stroke: options.borderColor,
                class: 'body view-frame',
                width: self.size.width,
                height: self.size.height,
                'stroke-width': parameters.frameBorderWidth
            },
            text: {
                'x-alignment': 'left',
                'text-anchor': 'left',
                'font-weight': 'bold',
                ref: 'rect',
                'ref-x': HOR_LABEL_PADDING,
                'ref-y': VERT_LABEL_PADDING + FONT_SIZE,
                text: label.indexOf('\n') === -1 ? label : label.substring(0, label.indexOf('\n')) + '...',
                fill: options.borderColor
            }
        },
        z: _elements.Z_INDEXES.VIEW_FRAME
    }]);

    if (self.model.width) self.model.width = Math.abs(Math.max(self.model.width, parameters.framePadding.x * 2 + 1));
    if (self.model.height) self.model.height = Math.abs(Math.max(self.model.height, parameters.framePadding.y * 2 + 1));

    self.on('change:position', function (cell, position) {
        if (!self.movingByItself) {
            self.movingByItself = true;
            self.position(self.constPosition.x, self.constPosition.y);
            self.movingByItself = false;

            var scaledOffset = {
                x: self.constPosition.x - position.x,
                y: self.constPosition.y - position.y
            };
            var globalOffset = (0, _utils.scaledToGlobalPoint)(scaledOffset, _scale);

            var newViewPortPosition = {
                x: _viewPortPosition.x + globalOffset.x,
                y: _viewPortPosition.y + globalOffset.y
            };
            self.trigger('change-view-port-position', newViewPortPosition);
        }
    });

    _init(options, parameters);

    self.set('correctPostion', null);

    // ===================================================================
    // ===================================================================

    // CallBack to override
    // self._onChangeBounds = undefined;

    /**
     * Update position and size of the node.
     * @param {Node} node
    */
    self.refreshNodeState = _refreshNodeState;

    /**
     * Returns list of nodes which viewFrame owns.
     * @returns {Array of Node}
    */
    self.getNodes = _getNodes;

    /**
     * Recaclulate viewPort bounds
    */
    self.updateBounds = _updateBounds;

    /**
     * Clear caches.
    */
    self.clear = _clear;

    /**
     * ViewFrame public model
     * @typedef {Object} Bounds
     * @property {number} minX
     * @property {number} maxX
     * @property {number} minY
     * @property {number} maxY
     * @property {number} width
     * @property {number} height
    */

    /**
     * Returns bounds of viewFrame in paper coordinates without padding.
     * @returns {Bounds}
    */
    self.getNodeBounds = function () {
        return _nodeBounds;
    };

    /**
     * Returns bounds of viewFrame in paper coordinates.
    */
    self.getViewPortBounds = function () {
        return _viewPortBounds;
    };

    /**
     * Returns bounds of viewFrame in paper coordinates.
    */
    self.getViewPortPositionBounds = function () {
        return _viewPortPositionBounds;
    };

    /**
     * Returns all visible in this viewport cells (Links|Nodes e.t.c.)
     * @returns {
     *  nodes: Node[],
     *  links: Link[],
     * }
     */
    self.getVisibleCells = function () {
        if (!_cachedResult) self.calculateVisibleCells();
        return _cachedResult;
    };

    /**
     * Calculate list of all visible in this viewport cells
     * @param {ViewFrameRenderOptions} options
     */
    self.calculateVisibleCells = function (options) {
        options = options || {};
        _referenceSize = _calculateReferenceNodeSize(options.elementSize || _defaultElementSize);
        _viewPortBounds = _getViewPortBounds();

        var globalSize = (0, _utils.scaledToGlobalSize)(self.size, _scale);
        var globalRectangle = {
            x: _viewPortPosition.x,
            y: _viewPortPosition.y,
            width: globalSize.width,
            height: globalSize.height
        };
        var activeElements = _dataContainer.getElementsForRectangle(globalRectangle);

        var visibleNodeMap = {};
        var visibleNodes = activeElements.nodes.filter(function (node) {
            var isNodeVisible = _ownerTest(node) && _hitTestByGlobalPosition(node);
            if (isNodeVisible) visibleNodeMap[node.id] = node;
            return isNodeVisible;
        });

        visibleNodes.forEach(function (node) {
            _refreshNodeState(node);
        });

        _cachedResult = {
            nodes: visibleNodes,
            links: activeElements.links
        };
    };

    /**
     * Sets position of the viewFrame on the paper
     * @returns {
     *  nodes: Node[],
     *  links: Link[],
     * }
     */
    self.setPosition = function (pos) {
        self.movingByItself = true;
        self.constPosition = pos;
        self.position(self.constPosition.x, self.constPosition.y);
        self.movingByItself = false;
    };

    /**
     * Changes size of the view-port-jointjs element.
     * @param {Size} size
     * @param {boolean} remember
     */
    self.setSize = _setSize;

    /**
     * It sets offset for all elements into the viewPort.
     * @param {number} x
     * @param {number} y
     * @param {boolean} force - disables the limit
     * @returns {Point}
     */
    self.positionViewPort = _positionViewPort;

    /**
     * Resets size.
     */
    self.resetSize = function () {
        self.model.width = undefined;
        self.model.height = undefined;
    };

    /**
     * Tells us whether the
     * point is in the viewPort of ViewFrame or not
     * @param {number} scale
     * @returns {boolean}
    */
    self.hitScaledPointTest = _hitScaledPointTest;

    /**
     * Tells us whether the
     * node is in the viewPort of ViewFrame or not
     * @param {Node} node
     * @returns {boolean}
    */
    self.hitTestByScaledPosition = _hitTestByScaledPosition;

    self.hitTestByGlobalPosition = _hitAreaTestByGlobalPosition;

    /**
     * Tells us whether the
     * ViewFrame is owner of the passed node or not
     * function for overriding
     * @param {Node} node
     * @returns {boolean}
    */
    // self._ownerTest - to override

    /**
     * Sets the scale of the viewFrame.
     * @param {Point} scale
    */
    self.setScale = _setScale;
    // self._scaleWillApplied; - to override

    /**
     * Returns the scale of the viewFrame.
     * @returns {number}
    */
    self.getScale = _getScale;

    /**
     * Sets the default element size.
     * @param {ElementSize} elementSize
    */
    self.setElementSize = function (elementSize) {
        _defaultElementSize = elementSize;
        _updateBounds();
        _limitViewPortPosition();
    };

    /**
     * Returns the default element size.
    */
    self.getElementSize = function () {
        return _defaultElementSize;
    };

    self.limitNodePosition = function (node) {
        var nodeScaledSize = node.calculateSize(_referenceSize); // scaled
        var scaledViewPortBounds = (0, _utils.globalToScaledBounds)(_viewPortPositionBounds);
        var nodeMinScaledPosition = (0, _utils.getScaledNodePosition)(node, _scale);

        var limitByMin = (0, _utils.limitPointPosition)(nodeMinScaledPosition, scaledViewPortBounds);
        var nodeMaxScaledPosition = {
            x: limitByMin.x + nodeScaledSize.width,
            y: limitByMin.y + nodeScaledSize.height
        };
        var limitByMax = (0, _utils.limitPointPosition)(nodeMaxScaledPosition, scaledViewPortBounds);
        var position = (0, _utils.scaledToGlobalPoint)(limitByMax, _scale);

        node.model.position = position;
    };

    function _init(options) {
        if (options.scale) {
            _scale = options.scale;
        } else if (self._scaleWillApplied) {
            _scale = self._scaleWillApplied(parameters.defaultScale);
        } else {
            _scale = parameters.defaultScale;
        }
        if (options.nodeBounds) {
            _nodeBounds = options.nodeBounds;
        } else {
            _nodeBounds = _calculateBounds();
        }
        if (options.viewPortPosition) {
            _viewPortPosition = options.viewPortPosition;
        }
        if (options.viewPortPositionBounds) {
            _viewPortPositionBounds = options.viewPortPositionBounds;
        } else {
            _viewPortPositionBounds = _calculateViewPortPositionBounds();
        }
        _viewPortBounds = _getViewPortBounds();
    }

    /**
     * Sets the scale of the viewFrame.
     * @param {Point} scale
    */
    function _setScale(scale) {
        if (self._scaleWillApplied) {
            _scale = self._scaleWillApplied(scale);
        } else {
            _scale = scale;
        }
        _updateBounds();
        _limitViewPortPosition();
    }

    /**
     * Returns the scale of the viewFrame.
     * @returns {number}
    */
    function _getScale() {
        return _scale;
    }

    function _clear() {
        _cachedResult = undefined;
    }

    /**
     * It sets offset for all elements into the viewPort.
     * @param {number} x
     * @param {number} y
     * @param {boolean} force - disables the limit
     * @returns {Point}
     */
    function _positionViewPort(x, y) {
        if (x !== undefined) _viewPortPosition.x = x;
        if (y !== undefined) _viewPortPosition.y = y;

        return { x: _viewPortPosition.x, y: _viewPortPosition.y };
    }

    /**
     * Returns list of nodes which viewFrame owns.
     * @returns {Array of Node}
    */
    function _getNodes() {
        return _dataContainer.nodes.filter(function (n) {
            return _ownerTest(n);
        });
    }

    /**
     * Changes size of the view-port-jointjs element.
     * @param {Size} size
     * @param {boolean} remember
     */
    function _setSize(size) {
        self.movingByItself = true;

        // it's best solution to fix the svg exporting
        // and for better compatibility IE11
        self.attr({
            'rect': {
                width: size.width,
                height: size.height
            }
        });
        // =================================
        self.resize(size.width, size.height);
        self.size = size;
        self.model.width = size.width;
        self.model.height = size.height;

        self.movingByItself = false;

        var label = joint.util.breakText(options.label, {
            width: self.size.width - HOR_LABEL_PADDING * 2
        });
        var completeLabel = label.indexOf('\n') === -1 ? label : label.substring(0, label.indexOf('\n')) + '...';
        self.attr('text/text', completeLabel);
    }

    /**
     * Update position and size of the node.
    */
    function _refreshNodeState(node) {
        var nodePosition = (0, _utils.getLocalNodePosition)(node, _scale, self);
        node.position(nodePosition.x, nodePosition.y);
        node.setSize(_referenceSize);
        if (parameters.clipNodes) {
            _clipNode(node);
        }
    }

    function _updateBounds() {
        _nodeBounds = _calculateBounds();
        _viewPortPositionBounds = _calculateViewPortPositionBounds();
    }

    /**
     * Recalculate bounds of view port.
    */
    function _calculateBounds() {
        var bounds = {
            minX: Infinity,
            maxX: -Infinity,
            minY: Infinity,
            maxY: -Infinity,
            width: undefined,
            height: undefined
        };

        var nodes = _getNodes();
        if (nodes.length !== 0) {

            nodes.forEach(function (node) {
                var pos = (0, _utils.getGlobalNodePosition)(node);
                var size = (0, _utils.scaledToGlobalSize)(node.calculateSize(_referenceSize), _scale);

                bounds.minX = Math.min(bounds.minX, pos.x);
                if (bounds.minX === pos.x) bounds.minXNode = node;

                bounds.maxX = Math.max(bounds.maxX, pos.x + size.width);
                if (bounds.maxX === pos.x + size.width) bounds.maxXNode = node;

                bounds.minY = Math.min(bounds.minY, pos.y);
                if (bounds.minY === pos.y) bounds.minYNode = node;

                bounds.maxY = Math.max(bounds.maxY, pos.y + size.height);
                if (bounds.maxY === pos.y + size.height) bounds.maxYNode = node;
            });

            bounds.width = bounds.maxX - bounds.minX;
            bounds.height = bounds.maxY - bounds.minY;
        } else {
            bounds.minX = 0;
            bounds.minY = 0;
            bounds.maxX = 0;
            bounds.maxY = 0;
            bounds.width = 0;
            bounds.height = 0;
        }

        return bounds;
    }

    /**
     * Returns bounds of view port.
     * @returns {
     *  maxX: number
     *  minX: number
     *  maxY: number
     *  minY: number
     * }
    */
    function _calculateViewPortPositionBounds() {
        if (!_nodeBounds) return null;
        // _bounds - global coord
        var viewFrameGlobalSize = (0, _utils.scaledToGlobalSize)(self.size, _scale);
        var boundsWithPadding = (0, _utils.extendBounds)(_nodeBounds, _framePadding);

        var viewPortBounds = {
            minX: boundsWithPadding.minX,
            maxX: boundsWithPadding.maxX - viewFrameGlobalSize.width,
            minY: boundsWithPadding.minY,
            maxY: boundsWithPadding.maxY - viewFrameGlobalSize.height,
            width: boundsWithPadding.maxX - viewFrameGlobalSize.width - boundsWithPadding.minX,
            height: boundsWithPadding.maxY - viewFrameGlobalSize.height - boundsWithPadding.minY
        };

        if (viewPortBounds.width < 0) {
            var diffX = (viewFrameGlobalSize.width - boundsWithPadding.width) / 2;
            viewPortBounds.minX = boundsWithPadding.minX - diffX;
            viewPortBounds.maxX = viewPortBounds.minX;
            viewPortBounds.width = 0;
        }

        if (viewPortBounds.height < 0) {
            var diffY = (viewFrameGlobalSize.height - boundsWithPadding.height) / 2;
            viewPortBounds.minY = boundsWithPadding.minY - diffY;
            viewPortBounds.maxY = viewPortBounds.minY;
            viewPortBounds.height = 0;
        }

        return viewPortBounds;
    }

    /**
    * Returns bounds of view port.
    * @returns {
    *  maxX: number
    *  minX: number
    *  maxY: number
    *  minY: number
    * }
    */
    function _getViewPortBounds() {
        var globalViewPortSize = (0, _utils.scaledToGlobalSize)(self.size, _scale);
        return {
            minX: _viewPortPosition.x,
            maxX: _viewPortPosition.x + globalViewPortSize.width,
            minY: _viewPortPosition.y,
            maxY: _viewPortPosition.y + globalViewPortSize.height,
            width: _viewPortPosition.x + globalViewPortSize.width - _viewPortPosition.x,
            height: _viewPortPosition.y + globalViewPortSize.height - _viewPortPosition.y
        };
    }

    /**
     * Limits position of the view port.
     * @returns {Point}
    */
    function _limitViewPortPosition() {
        _viewPortPosition = (0, _utils.limitPointPosition)(_viewPortPosition, _viewPortPositionBounds);
    }

    /**
     * Tells us whether a Node fall into the viewport or no.
     * @param {Node} node
     * @param {boolean} partialHit
     * @returns {boolean}
    */
    function _hitTestByGlobalPosition(node, partialHit) {
        var nodePosition = (0, _utils.getGlobalNodePosition)(node);

        var nodeScaledSize = node.calculateSize(_referenceSize);
        var nodeSize = (0, _utils.scaledToGlobalSize)(nodeScaledSize, _scale);

        var p1 = nodePosition;
        var p2 = { x: nodePosition.x + nodeSize.width, y: nodePosition.y };
        var p3 = { x: nodePosition.x, y: nodePosition.y + nodeSize.height };
        var p4 = { x: nodePosition.x + nodeSize.width, y: nodePosition.y + nodeSize.height };

        var hitP1 = _hitGlobalPointTest(p1);
        var hitP2 = _hitGlobalPointTest(p2);
        var hitP3 = _hitGlobalPointTest(p3);
        var hitP4 = _hitGlobalPointTest(p4);

        var fullHit = hitP1 && hitP2 && hitP3 && hitP4;
        var borderHit = hitP1 || hitP2 || hitP3 || hitP4;

        if (parameters.clipNodes) {
            return borderHit;
        } else {
            return partialHit && borderHit || !partialHit && fullHit;
        }
    }

    function _hitAreaTestByGlobalPosition(node, viewFrame) {
        var scaledPosition = node.position();
        var nodePosition = (0, _utils.localToGlobalPoint)(scaledPosition, _scale, viewFrame || self);

        var nodeScaledSize = node.calculateSize(_referenceSize);
        var nodeSize = (0, _utils.scaledToGlobalSize)(nodeScaledSize, _scale);

        var p1 = nodePosition;
        var p2 = { x: nodePosition.x + nodeSize.width, y: nodePosition.y };
        var p3 = { x: nodePosition.x, y: nodePosition.y + nodeSize.height };
        var p4 = { x: nodePosition.x + nodeSize.width, y: nodePosition.y + nodeSize.height };

        var hitP1 = _hitAreaGlobalPointTest(p1);
        var hitP2 = _hitAreaGlobalPointTest(p2);
        var hitP3 = _hitAreaGlobalPointTest(p3);
        var hitP4 = _hitAreaGlobalPointTest(p4);

        var borderHit = hitP1 || hitP2 || hitP3 || hitP4;

        return borderHit;
    }

    function _hitTestByScaledPosition(node) {
        var scaledPosition = node.position();

        var p1 = scaledPosition;
        var p2 = { x: scaledPosition.x + node.size.width, y: scaledPosition.y };
        var p3 = { x: scaledPosition.x, y: scaledPosition.y + node.size.height };
        var p4 = { x: scaledPosition.x + node.size.width, y: scaledPosition.y + node.size.height };

        var hitP1 = _hitScaledPointTest(p1);
        var hitP2 = _hitScaledPointTest(p2);
        var hitP3 = _hitScaledPointTest(p3);
        var hitP4 = _hitScaledPointTest(p4);

        return hitP1 || hitP2 || hitP3 || hitP4;
    }

    function _hitGlobalPointTest(p) {
        return _viewPortBounds.minX <= p.x && p.x <= _viewPortBounds.maxX && _viewPortBounds.minY <= p.y && p.y <= _viewPortBounds.maxY;
    }

    function _hitAreaGlobalPointTest(p) {
        return _nodeBounds.minX <= p.x && p.x <= _nodeBounds.maxX && _nodeBounds.minY <= p.y && p.y <= _nodeBounds.maxY;
    }

    function _hitScaledPointTest(p) {
        return self.constPosition.x <= p.x && self.constPosition.x + self.size.width >= p.x && self.constPosition.y <= p.y && self.constPosition.y + self.size.height >= p.y;
    }

    function _ownerTest(node) {
        if (self._ownerTest) {
            return self._ownerTest(node);
        }
        var customeOwner = node.viewFrameOwnerId;
        var ownerIsMe = node.viewFrameOwnerId === self.id;
        var meIsNativeOwner = self.id === node.model.viewFrame;
        return customeOwner && ownerIsMe || meIsNativeOwner && !customeOwner;
    }

    /**
     * Calculate the clip point, which
     * tells us how far the node go out of the border of viewFrame.
     * And after calculation the function pass this point into the node.
     * @param {Node} node
    */
    function _clipNode(node) {
        var nodePosition = (0, _utils.getGlobalNodePosition)(node);
        var nodeScaledSize = node.calculateSize(_referenceSize);
        var nodeSize = (0, _utils.scaledToGlobalSize)(nodeScaledSize, _scale);

        var p1 = nodePosition;
        var p2 = { x: nodePosition.x + nodeSize.width, y: nodePosition.y };
        var p3 = { x: nodePosition.x, y: nodePosition.y + nodeSize.height };
        var p4 = { x: nodePosition.x + nodeSize.width, y: nodePosition.y + nodeSize.height };

        var globalOffset = { x: 0, y: 0 };

        var o = getPointOffset(p1);
        globalOffset.x = Math.abs(o.x) > Math.abs(globalOffset.x) ? o.x : globalOffset.x;
        globalOffset.y = Math.abs(o.y) > Math.abs(globalOffset.y) ? o.y : globalOffset.y;

        o = getPointOffset(p2);
        globalOffset.x = Math.abs(o.x) > Math.abs(globalOffset.x) ? o.x : globalOffset.x;
        globalOffset.y = Math.abs(o.y) > Math.abs(globalOffset.y) ? o.y : globalOffset.y;

        o = getPointOffset(p3);
        globalOffset.x = Math.abs(o.x) > Math.abs(globalOffset.x) ? o.x : globalOffset.x;
        globalOffset.y = Math.abs(o.y) > Math.abs(globalOffset.y) ? o.y : globalOffset.y;

        o = getPointOffset(p4);
        globalOffset.x = Math.abs(o.x) > Math.abs(globalOffset.x) ? o.x : globalOffset.x;
        globalOffset.y = Math.abs(o.y) > Math.abs(globalOffset.y) ? o.y : globalOffset.y;

        var scaledOffset = (0, _utils.globalToScaledPoint)(globalOffset, _scale);
        node.setClipping(scaledOffset);

        function getPointOffset(p) {
            var offset = { x: 0, y: 0 };
            if (_viewPortBounds.minX > p.x) {
                offset.x = _viewPortBounds.minX - p.x;
            } else if (_viewPortBounds.maxX < p.x) {
                offset.x = _viewPortBounds.maxX - p.x;
            }
            if (_viewPortBounds.minY > p.y) {
                offset.y = _viewPortBounds.minY - p.y;
            } else if (_viewPortBounds.maxY < p.y) {
                offset.y = _viewPortBounds.maxY - p.y;
            }
            return offset;
        }
    }

    /**
     * Returns current size for node with considering scale.
     * @param {Node} node
     * @returns {Size}
    */
    function _calculateReferenceNodeSize(elementSize) {
        var minScale = Math.min(_scale.x, _scale.y);
        var scaledElementSize = (0, _utils.globalToScaledSize)(elementSize, {
            x: minScale, y: minScale
        });
        // const scaledElementSize = globalToScaledSize(elementSize, _scale);

        var maxBoundedWidth = self.size.width - parameters.framePadding.x;
        var maxWidth = maxBoundedWidth >= elementSize.minWidth / 3 ? maxBoundedWidth : self.size.width;

        var maxBoundedHeight = self.size.height - parameters.framePadding.y;
        var maxHeight = maxBoundedHeight >= elementSize.minHeight ? maxBoundedHeight : self.size.height;

        var referenceSize = {
            width: Math.min(Math.max(elementSize.minWidth, Math.min(scaledElementSize.width, elementSize.maxWidth)), maxWidth),
            height: Math.min(Math.max(elementSize.minHeight, Math.min(scaledElementSize.height, elementSize.maxHeight)), maxHeight),
            maxWidth: maxWidth,
            maxHeight: maxHeight
        };

        return referenceSize;
    }
}
ViewFrame.prototype = Object.create(joint.shapes.basic.Rect.prototype);
exports.default = ViewFrame;

/**
 * @private
 * @class
 * It's special viewFrame to show all Nodes selected nodes.
 * All nodes are passed with options for parent class.
 * @augments ViewFrame.
 * And this class has the same methods, fields and parameters as ViewFrame.
 */

function OverViewFrame(options, parameters) {
    var self = this;
    var _ratioModifyer = 1;

    self._ownerTest = function () {
        return true;
    };

    self._scaleWillApplied = function (scale) {
        if (_ratioModifyer > 1) {
            return {
                x: scale.x,
                y: scale.x * _ratioModifyer
            };
        } else {
            return {
                x: scale.y / _ratioModifyer,
                y: scale.y
            };
        }
    };

    ViewFrame.apply(self, [options, parameters]);
    _init();

    function _init() {
        var paperSize = (0, _utils.getElementSize)(parameters.graphPlace);
        var nodeBounds = self.getNodeBounds();

        var widthIsScalable = nodeBounds.width && nodeBounds.minXNode !== nodeBounds.maxXNode;
        var heightIsScalable = nodeBounds.height && nodeBounds.minYNode !== nodeBounds.maxYNode;
        if (widthIsScalable && heightIsScalable) {
            var xRatio = paperSize.width / nodeBounds.width;
            var yRatio = paperSize.height / nodeBounds.height;

            if (xRatio !== yRatio) {
                _ratioModifyer = yRatio / xRatio;
            }
        }
    }
}
OverViewFrame.prototype = Object.create(ViewFrame.prototype);

},{"../utils/utils":70,"./graphElements/elements":47,"rappid":"rappid"}],56:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FRAME_OUT_MARGIN = exports.DISTANCE_BETWEEN_FRAMES = undefined;
exports.ViewManager = ViewManager;

var _lodash = require('lodash');

var _ = _interopRequireWildcard(_lodash);

var _viewFrame = require('./viewFrame');

var _elements = require('./graphElements/elements');

var _subscribeable = require('../subscriptionAPI/subscribeable');

var _subscribeable2 = _interopRequireDefault(_subscribeable);

var _lineageDiagramUtils = require('../utils/lineageDiagramUtils');

var _utils = require('../utils/utils');

var _dataUtils = require('../utils/dataUtils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var DISTANCE_BETWEEN_FRAMES = exports.DISTANCE_BETWEEN_FRAMES = 20;
var FRAME_OUT_MARGIN = exports.FRAME_OUT_MARGIN = 20;

/**
 * ViewManager options.
 * @typedef {Object} ViewMangerOptions
 * @property {DataContainer} dataContainer
 * @property {ViewFramePublicModel[]} viewFrames
*/

/**
 * Manage ViewFrames and collect data
 * from them to return to the lineageDiagram render
 * @private
 * @param {ViewMangerOptions} options 
 * @param {Parameters} parameters 
 * @fires change-view-port-position
 * Public methods:
 * ========================================
 * prepareRenderData: (renderOptions) => (Node|Link|ViewFrame)[]
 * getViewFrameForNode: () => ViewFramePublicModel;
 * getVieFrameForNodeByPosition: (node) => ViewFramePublicModel;
 * getViewFrameById: () => ViewFramePublicModel;
 * getOverViewFrame: () => ViewFramePublicModel;
 * fullScreenMode: () => boolean;
 * getViewFrames: () => ViewFramePublicModel[];
 */
function ViewManager(options, parameters) {
    _subscribeable2.default.apply(this); // make this class Subscribable
    var self = this;

    var _terminationNodeSize = parameters.terminationNodeSize;

    var _terminationCellCache = {};
    var _aspectLinksCahe = {};
    var _renderOptions = {};
    var _viewFramesMap = {};
    var _state = {};
    var _dataContainer = void 0;
    var _overViewFrame = void 0;
    var _viewFrames = void 0;
    var _allFrames = void 0;

    var _fullScreenMode = void 0; // changeable

    _init(options, parameters);

    // ===================================================================
    // ===================================================================

    /**
     * Paper render options.
     * @typedef {Object} PaperRenderOptions
     * @property orientation: _orientation,
     * @property width: _paper.el.clientWidth,
     * @property height: _paper.el.clientHeight,
     * @property scale: _scale,
    */

    /**
     * Element render options.
     * @typedef {Object} ElementRenderOptions
     * @property {ElementSize} elementSize
    */

    /**
     * Render options.
     * @typedef {Object} RenderOptions
     * @property {ViewFramePublicModel[]} viewFrames
     * @property {boolean} fullScreenMode
     * @property {Object.<string, (Node|Link)>} path
     * @property {Object.<string, (Node|Link)>} mask
     * @property {boolean} updateBounds
     * @property {boolean} quickUpdate
     * @property {PaperRenderOptions} paperOptions
     * @property {ElementRenderOptions} elementOptions
    */

    /**
     * 1. Takes render data from the ViewFrames,
     * 2. Updates ViewFrames state
     * 3. Changes size and scale of viewFrames
     * 4. Updates highlighting
     * @param {RenderOptions} renderOptions
     * @returns {(Node|Link|ViewFrame)[]}
     */
    self.prepareRenderData = function (renderOptions) {
        _updateViewFrames(renderOptions);

        var visibleViewFrames = _getVisibleViewFrames();
        var viewFrameResults = visibleViewFrames.map(function (vf) {
            return vf.getVisibleCells();
        });
        var renderResults = _calculateRenderData(viewFrameResults, renderOptions);
        _setHighlighting(renderResults, renderOptions);

        return visibleViewFrames.concat(renderResults);
    };

    /**
     * Returns ViewFrame for the node which currently renders this node.
     * @param {Node} node
     * @returns {ViewFramePublicModel}
    */
    self.getViewFrameForNode = function (node) {
        return _getViewFramePublicModel(_getViewFrameForNode(node));
    };

    /**
     * Returns ViewFrame which currently owns this node.
     * @param {Node} node
     * @returns {ViewFramePublicModel}
    */
    self.getViewFrameOwner = function (node) {
        var viewFrameId = (0, _lineageDiagramUtils.getViewFrameIdForNode)(node);
        return _getViewFramePublicModel(_viewFramesMap[viewFrameId]);
    };

    /**
     * Returns ViewFrame for the node by his position.
     * @param {Node} node
     * @returns {ViewFramePublicModel | undefined}
    */
    self.getVieFrameForNodeByPosition = function (node) {
        if (_fullScreenMode) return undefined;

        var visibleFrames = _getVisibleViewFrames();
        for (var i = 0; i < visibleFrames.length; i++) {
            var vf = visibleFrames[i];

            if (vf.hitTestByScaledPosition(node)) return _getViewFramePublicModel(vf);
        }
        return undefined;
    };

    /**
     * Returns ViewFrame for the node by his position.
     * @param {Point} point
     * @returns {ViewFramePublicModel}
    */
    self.getVieFrameByScreenPoint = function (point) {
        var visibleFrames = _getVisibleViewFrames();
        for (var i = 0; i < visibleFrames.length; i++) {
            var vf = visibleFrames[i];
            if (vf.hitScaledPointTest(point)) {
                return _getViewFramePublicModel(vf);
            }
        }
        return undefined;
    };

    /**
     * Restores default size of ViewFrames
     */
    self.resetFrameLayout = function () {
        _viewFrames.forEach(function (vf) {
            vf.resetSize();
        });
    };

    /**
     * Returns ViewFrame by id
     * @param {string} id
     * @returns {ViewFramePublicModel | undefined}
     */
    self.getViewFrameById = function (viewFrameId) {
        return _getViewFramePublicModel(_viewFramesMap[viewFrameId]);
    };

    /**
     * Returns OverViewFrame
     * @returns {ViewFramePublicModel}
     */
    self.getOverViewFrame = function () {
        return _getViewFramePublicModel(_overViewFrame);
    };

    /**
     * Tells us whether overView is active or not
     * @returns {boolean}
     */
    self.isFullScreenMode = function () {
        return _fullScreenMode;
    };

    /**
     * Returns all ViewFrames
     * @returns {ViewFramePublicModel[]}
    */
    self.getViewFrames = function () {
        return _allFrames.map(function (vf) {
            return _getViewFramePublicModel(vf);
        });
    };

    /**
     * ViewFrame public model
     * @typedef {Object} ViewFramePublicModel
     * @property {string} id - Identifyer
     * @property {string} label - Label in the top-right corner
     * @property {string} backgroundColor - Bacground color
     * @property {string} borderColor - Border color
     * @property {boolean} active - Is on the screen
     * @property {boolean} expanded - Is expanded
     * @property {Point} position - Real position on the paper
     * @property {Point} viewPortPosition - Position of the viewPort
     * @property {Bounds} bounds - Real visual bounds of active zone of viewFrame (Zone around nodes)
     * @property {Size} size - Real size of viewFrame
     * @property {boolean} customeSized - Tells us whether size was changed by user or not
     * @property {Bounds} viewPortPositionBounds - Min max values of the position of the viewPort
     * @property {number} spaceShare - relative size of view frame (horizontal/vertical depends on orientation)
     * @property {boolean} updateBounds - Flag to pass into the render pipline
    */

    /**
     * @private
     * @param {ViewFrame} viewFrame
     * @returns {ViewFramePublicModel}
     */
    function _getViewFramePublicModel(viewFrame) {
        if (!viewFrame) return;
        var customeSized = viewFrame.model.width || viewFrame.model.height;

        var isActive = viewFrame === _overViewFrame ? _fullScreenMode : _fullScreenMode ? false : _state[viewFrame.model.id];

        var isExpanded = viewFrame === _overViewFrame ? _fullScreenMode : _state[viewFrame.model.id];

        return {
            id: viewFrame.model.id,
            label: viewFrame.model.label,
            backgroundColor: viewFrame.model.backgroundColor,
            borderColor: viewFrame.model.borderColor,
            active: isActive,
            expanded: isExpanded,
            position: viewFrame.position(), // local
            viewPortPosition: viewFrame.positionViewPort(), // global
            viewPortPositionBounds: viewFrame.getViewPortPositionBounds(), // global
            viewPortBounds: viewFrame.getViewPortBounds(), // global
            nodeBounds: viewFrame.getNodeBounds(), // global
            size: { width: viewFrame.size.width, height: viewFrame.size.height }, // local
            customeSized: customeSized,
            spaceShare: viewFrame.model.spaceShare,
            updateBounds: false,
            isOverView: viewFrame === _overViewFrame,
            scale: viewFrame.getScale()
        };
    }

    /**
     * Updates data model
     * @param {DataContainer} dataContainer - data for the graph
    */
    function _init(options, parameters) {
        _dataContainer = options.dataContainer;
        var map = {};
        var state = {};

        // Create OverView frame
        _overViewFrame = new _viewFrame.OverViewFrame({
            id: 'overViewFrame',
            label: 'Overview',
            dataContainer: _dataContainer,
            resurrectElements: true,
            borderColor: '#23b0f4',
            backgroundColor: '#f4f4ff',
            spaceShare: 1
        }, parameters);
        map[_overViewFrame.id] = _overViewFrame;

        // Create list of ViewFrames
        _viewFrames = options.viewFrames.map(function (model) {
            state[model.id] = model.expanded;
            var viewFrameOptions = _.cloneDeep(model);
            viewFrameOptions.dataContainer = options.dataContainer;
            var viewFrame = new _viewFrame.ViewFrame(viewFrameOptions, parameters);
            map[viewFrame.id] = viewFrame;
            return viewFrame;
        });
        _allFrames = _viewFrames.concat(_overViewFrame);

        _state = state;
        _viewFramesMap = map;
        _fullScreenMode = options.fullScreenMode;

        _subscribeOnViewFrameEvents(_allFrames);
    }

    /**
     * Updates states of viewFrames using renderOptions
     * @param {RenderOptions} renderOptions
    */
    function _updateViewFrames(renderOptions) {
        var newPaperOptions = renderOptions.paperOptions;
        var previousPaperOptions = _renderOptions.paperOptions || {};
        var viewFrameOptions = (0, _utils.arrayToMap)(renderOptions.viewFrames || []);

        var isScaleChanged = !previousPaperOptions.scale || previousPaperOptions.scale.x !== newPaperOptions.scale.x || previousPaperOptions.scale.y !== newPaperOptions.scale.y;
        var isPaperSizeChanged = previousPaperOptions.width !== newPaperOptions.width || previousPaperOptions.height !== newPaperOptions.height;
        var isOrientationChanged = previousPaperOptions.orientation !== newPaperOptions.orientation;

        var oldElementSize = (_renderOptions.elementOptions || {}).elementSize;
        var elementSize = renderOptions.elementOptions.elementSize;
        var isElementSizeChanged = elementSize && (!oldElementSize || elementSize.width !== oldElementSize.width || elementSize.height !== oldElementSize.height || elementSize.minWidth !== oldElementSize.minWidth || elementSize.minHeight !== oldElementSize.minHeight || elementSize.maxWidth !== oldElementSize.maxWidth || elementSize.maxHeight !== oldElementSize.maxHeight);

        var fullScreenModeChanged = renderOptions.fullScreenMode !== undefined && renderOptions.fullScreenMode !== _fullScreenMode;
        var viewFramesStateChanged = _updateViewFrameVisibility(viewFrameOptions) && !_fullScreenMode || fullScreenModeChanged;

        if (fullScreenModeChanged) {
            _fullScreenMode = renderOptions.fullScreenMode;
        }

        var paperOptionsChanged = renderOptions.updateBounds || isPaperSizeChanged || isOrientationChanged || isScaleChanged || viewFramesStateChanged;
        var resizeViewFrames = isPaperSizeChanged || isOrientationChanged || viewFramesStateChanged;

        if (isElementSizeChanged) {
            _setElementsSize(elementSize);
        }
        if (resizeViewFrames) {
            _resizeViewFrames(newPaperOptions);
        }
        if (isScaleChanged) {
            _scaleViewFrames(newPaperOptions.scale);
        }
        if (paperOptionsChanged || isElementSizeChanged || isScaleChanged) {
            _refreshViewFramesBounds();
        }

        _allFrames.forEach(function (viewFrame) {
            var recalculateVisibleElements = false;
            var newViewFrameData = viewFrameOptions[viewFrame.id];

            if (newViewFrameData) {
                var oldViewFrameData = _getViewFramePublicModel(viewFrame);

                var updateBounds = newViewFrameData.updateBounds;
                var portPositionChanged = newViewFrameData.viewPortPosition && (newViewFrameData.viewPortPosition.x !== oldViewFrameData.viewPortPosition.x || newViewFrameData.viewPortPosition.y !== oldViewFrameData.viewPortPosition.y);
                var sizeChanged = newViewFrameData.size && (newViewFrameData.size.width !== oldViewFrameData.size.width || newViewFrameData.size.height !== oldViewFrameData.size.height);
                var positionChanged = newViewFrameData.position && (newViewFrameData.position.x !== oldViewFrameData.position.x || newViewFrameData.position.y !== oldViewFrameData.position.y);

                if (sizeChanged && !resizeViewFrames) {
                    viewFrame.setSize(newViewFrameData.size, newViewFrameData.customeSized);
                    recalculateVisibleElements = true;
                }

                if (positionChanged && !resizeViewFrames) {
                    viewFrame.setPosition(newViewFrameData.position);
                }

                if (updateBounds || sizeChanged && !resizeViewFrames) {
                    viewFrame.updateBounds();
                    recalculateVisibleElements = true;
                }

                if (portPositionChanged && !resizeViewFrames) {
                    viewFrame.positionViewPort(newViewFrameData.viewPortPosition.x, newViewFrameData.viewPortPosition.y);
                    recalculateVisibleElements = true;
                }
            }
            var isExpanded = _state[viewFrame.id] || viewFrame === _overViewFrame && _fullScreenMode;
            var recalculateContent = isExpanded && (recalculateVisibleElements || paperOptionsChanged || isElementSizeChanged);
            if (recalculateContent) {
                viewFrame.calculateVisibleCells();
            }
        });

        _renderOptions = renderOptions;
    }

    /**
     * Updates state of viewFrames (visible/invisible)
     * @param {ViewFramePublicModel[]} viewFrameOptions
     */
    function _updateViewFrameVisibility(viewFrameOptions) {
        var atLeastOneVisibilityChanged = false;
        _viewFrames.forEach(function (viewFrame) {
            var newViewFrameData = viewFrameOptions[viewFrame.id];
            if (newViewFrameData && newViewFrameData.expanded !== undefined) {
                var visibilitiChanged = newViewFrameData.expanded !== _state[viewFrame.id];
                _state[viewFrame.id] = newViewFrameData.expanded;
                atLeastOneVisibilityChanged = atLeastOneVisibilityChanged || visibilitiChanged;
            }
        });
        return atLeastOneVisibilityChanged;
    }

    /**
     * Changes default element size for all ViewFrames
     * @param {ElementSize} elementSize 
     */
    function _setElementsSize(elementSize) {
        _allFrames.forEach(function (vf) {
            vf.setElementSize(elementSize);
        });
    }

    /**
     * Recalculates bounds for all ViewFrames
     * and allign ViewFrames
    */
    function _refreshViewFramesBounds() {
        _allFrames.forEach(function (vf) {
            vf.updateBounds();
            vf.positionViewPort();
        });
    }

    /**
     * Sets and limits value of the scale for the graph.
     * @param {number} scale
     */
    function _scaleViewFrames(scale) {
        if (scale) {
            _allFrames.forEach(function (vf) {
                var oldScale = vf.getScale();
                var pos = vf.positionViewPort();

                vf.setScale(scale);
                var newScale = vf.getScale(); // overViewFrame changes scale before apply

                var scaledSize = vf.get('size');
                var oldSize = (0, _utils.scaledToGlobalSize)(scaledSize, oldScale);
                var newSize = (0, _utils.scaledToGlobalSize)(scaledSize, newScale);

                var curCenter = {
                    x: pos.x + oldSize.width / 2,
                    y: pos.y + oldSize.height / 2
                };

                vf.positionViewPort(curCenter.x - newSize.width / 2, curCenter.y - newSize.height / 2);
            });
        }
    }

    /**
     * Refresh ViewFrames:
     * Adjust viewFrames size to a paper
     * @param {boolean} updateScale
     */
    function _resizeViewFrames(options) {
        var visibleFrames = _getVisibleViewFrames();
        var vfNumber = visibleFrames.length;
        var isHorizontalOrientated = options.orientation === 'left-to-right' || options.orientation === 'right-to-left';

        if (options.width === 0 || options.height === 0 || vfNumber <= 0) return;
        var totalShare = 0;
        visibleFrames.forEach(function (vf) {
            totalShare += vf.model.spaceShare;
        });

        var width = options.width - FRAME_OUT_MARGIN * 2;
        var height = options.height - FRAME_OUT_MARGIN * 2;

        var cutedWidth = width - DISTANCE_BETWEEN_FRAMES * (vfNumber - 1);
        var cutedHeight = height - DISTANCE_BETWEEN_FRAMES * (vfNumber - 1);

        var segmentWidth = cutedWidth / totalShare;
        var segmentHeight = cutedHeight / totalShare;

        var scale = 1;
        var length = 0;
        var freeLength = 0;
        visibleFrames.forEach(function (viewFrame) {
            if (isHorizontalOrientated) {
                if (viewFrame.model.width) {
                    length += viewFrame.model.width;
                } else {
                    freeLength += segmentWidth * (viewFrame.model.spaceShare || 1);
                }
            } else {
                if (viewFrame.model.height) {
                    length += viewFrame.model.height;
                } else {
                    freeLength += segmentHeight * (viewFrame.model.spaceShare || 1);
                }
            }
        });

        if (isHorizontalOrientated) {
            scale = (cutedWidth - freeLength) / length;
        } else {
            scale = (cutedHeight - freeLength) / length;
        }

        var curPoint = { x: FRAME_OUT_MARGIN, y: FRAME_OUT_MARGIN };

        if (options.orientation === 'top-to-bottom') {

            visibleFrames.forEach(function (vf) {
                if (vf.model.width) vf.model.width = undefined;
                if (vf.model.height) vf.model.height *= scale;

                var MINIMAL_VF_SIZE = { width: 1, height: 1 };
                var size = {
                    width: Math.max(width, MINIMAL_VF_SIZE.width),
                    height: Math.max(vf.model.height ? vf.model.height : segmentHeight * (vf.model.spaceShare || 1), MINIMAL_VF_SIZE.height)
                };

                vf.setPosition(curPoint);
                vf.setSize(size);

                curPoint = { x: FRAME_OUT_MARGIN, y: curPoint.y + size.height + DISTANCE_BETWEEN_FRAMES };
            });
        } else if (options.orientation === 'bottom-to-top') {

            for (var i = visibleFrames.length - 1; i >= 0; i--) {
                var vf = visibleFrames[i];

                if (vf.model.width) vf.model.width = undefined;
                if (vf.model.height) vf.model.height *= scale;

                var size = {
                    width: width,
                    height: vf.model.height ? vf.model.height : segmentHeight * (vf.model.spaceShare || 1)
                };

                vf.setPosition(curPoint);
                vf.setSize(size);

                curPoint = { x: FRAME_OUT_MARGIN, y: curPoint.y + size.height + DISTANCE_BETWEEN_FRAMES };
            }
        } else if (options.orientation === 'right-to-left') {

            for (var _i = visibleFrames.length - 1; _i >= 0; _i--) {
                var _vf = visibleFrames[_i];

                if (_vf.model.width) _vf.model.width *= scale;
                if (_vf.model.height) _vf.model.height = undefined;

                var _size = {
                    width: _vf.model.width ? _vf.model.width : segmentWidth * (_vf.model.spaceShare || 1),
                    height: height
                };

                _vf.setPosition(curPoint);
                _vf.setSize(_size);

                curPoint = { x: curPoint.x + _size.width + DISTANCE_BETWEEN_FRAMES, y: FRAME_OUT_MARGIN };
            }
        } else {
            // horizontal

            visibleFrames.forEach(function (vf) {
                if (vf.model.width) vf.model.width *= scale;
                if (vf.model.height) vf.model.height = undefined;

                var size = {
                    width: vf.model.width ? vf.model.width : segmentWidth * (vf.model.spaceShare || 1),
                    height: height
                };

                vf.setPosition(curPoint);
                vf.setSize(size);

                curPoint = { x: curPoint.x + size.width + DISTANCE_BETWEEN_FRAMES, y: FRAME_OUT_MARGIN };
            });
        }

        visibleFrames.forEach(function (viewFrame) {
            viewFrame.updateBounds();
            // We want not to be in the empty space after resizing but somwhere near the nodes.
            var viewPortPositionBounds = viewFrame.getViewPortPositionBounds();
            var visibleCells = viewFrame.getVisibleCells();
            if (!visibleCells || visibleCells.nodes.length === 0) {
                var nodes = viewFrame.getNodes();
                if (nodes.length > 0) {
                    var nodeToFocus = nodes[Math.round(Math.random() * (nodes.length - 1))];
                    var nodeScaledPos = (0, _utils.getScaledNodePosition)(nodeToFocus, options.scale);
                    var newPosition = {
                        x: nodeScaledPos.x - (viewFrame.size.width - nodeToFocus.size.width) / 2,
                        y: nodeScaledPos.y - (viewFrame.size.height - nodeToFocus.size.height) / 2
                    };
                    var _limitedPoint = (0, _utils.limitPointPosition)(newPosition, viewPortPositionBounds);
                    viewFrame.positionViewPort(_limitedPoint.x, _limitedPoint.y);
                }
            }
            var limitedPoint = (0, _utils.limitPointPosition)(viewFrame.positionViewPort(), viewPortPositionBounds);
            viewFrame.positionViewPort(limitedPoint.x, limitedPoint.y);
        });
    }

    /**
     * Get data (Cells) from ViewFrames,
     * processes it (add termination and aspect elements)
     * and returns to the render pipline
     * @returns {(Link|Node|TerminationNode|TerminationLink|AspectLink)[]}
     */
    function _calculateRenderData(viewFrameResults, renderOptions) {
        var nodes = [];
        var links = [];
        var badLinks = [];
        var visibleNodeMap = {};

        viewFrameResults.forEach(function (result) {
            return result.nodes.forEach(function (node) {
                visibleNodeMap[node.id] = node;
                nodes.push(node);
            });
        });

        viewFrameResults.forEach(function (result) {
            return result.links.forEach(function (link) {
                if (visibleNodeMap[link.model.source] && visibleNodeMap[link.model.target]) {
                    if (!renderOptions.quickUpdate) links.push(link);
                } else if (visibleNodeMap[link.model.source] || visibleNodeMap[link.model.target]) {
                    badLinks.push(link);
                }
            });
        });

        var terminationCellMap = {};
        var terminationNodes = [];
        var terminationLinks = [];
        if (renderOptions.selectedElement) {
            var selectedNodes = _getSelectedNodes(renderOptions.selectedElement);
            selectedNodes.forEach(function (selectedNode) {
                var terminationOrigins = _getTerminationOrigins(selectedNode, visibleNodeMap, badLinks);
                var viewFrame = _getViewFrameForNode(selectedNode);

                if (viewFrame && (_state[viewFrame.id] || _fullScreenMode)) {
                    terminationOrigins.nodes.forEach(function (node) {
                        var nodeCacheId = node.id + '_at_' + viewFrame.id;
                        var terminationNode = _terminationCellCache[nodeCacheId];
                        if (terminationNode) {
                            terminationNode.set('dragged', false);
                        } else {
                            terminationNode = new _elements.TerminationNode({
                                node: node
                            }, parameters);
                        }
                        terminationCellMap[nodeCacheId] = terminationNode;
                        var position = _getTerminationNodePosition(terminationNode, viewFrame, renderOptions);
                        terminationNode.position(position.x, position.y);
                        terminationNodes.push(terminationNode);
                    });
                    if (!renderOptions.quickUpdate) {
                        terminationOrigins.links.forEach(function (link) {
                            var linkCacheId = link.id + '_at_' + viewFrame.id;
                            var sourceCacheId = link.model.source + '_at_' + viewFrame.id;
                            var targetCacheId = link.model.target + '_at_' + viewFrame.id;
                            var terminationLink = _terminationCellCache[linkCacheId] || new _elements.TerminationLink({
                                link: link,
                                source: terminationCellMap[sourceCacheId] || visibleNodeMap[link.model.source],
                                target: terminationCellMap[targetCacheId] || visibleNodeMap[link.model.target]
                            }, parameters);
                            terminationCellMap[linkCacheId] = terminationLink;
                            terminationLinks.push(terminationLink);
                        });
                    }
                }
            });

            var link = renderOptions.selectedElement;
            var addTerminationLinks = link instanceof _elements.Link && (!(visibleNodeMap[link.model.source] || visibleNodeMap[link.model.target]) || renderOptions.quickUpdate);
            if (addTerminationLinks) {
                var nodeMap = _dataContainer.maps.nodeMap;

                var sourceViewFrame = _getViewFrameForNode(nodeMap[link.model.source]);
                var targetViewFrame = _getViewFrameForNode(nodeMap[link.model.target]);

                if (sourceViewFrame && targetViewFrame) {
                    var sourceViewFrameId = sourceViewFrame.id;
                    var targetViewFrameId = targetViewFrame.id;

                    var sourceCacheId = link.model.source + '_at_' + sourceViewFrameId;
                    var targetCacheId = link.model.target + '_at_' + targetViewFrameId;

                    var source = terminationCellMap[sourceCacheId] || visibleNodeMap[link.model.source];
                    var target = terminationCellMap[targetCacheId] || visibleNodeMap[link.model.target];

                    var linkCacheId = source.id + '~#~' + target.id;
                    var terminationLink = _terminationCellCache[linkCacheId] || new _elements.TerminationLink({
                        link: link,
                        source: source,
                        target: target
                    }, parameters);
                    terminationCellMap[linkCacheId] = terminationLink;
                    terminationLinks.push(terminationLink);
                }
            }
        }
        _terminationCellCache = terminationCellMap;

        var visibleNodes = nodes.concat(terminationNodes);
        var aspectLinks = renderOptions.quickUpdate ? [] : _calculateAspectLinks(visibleNodes);
        var visibleLinks = links.concat(terminationLinks).concat(aspectLinks);

        return visibleNodes.concat(visibleLinks);
    }

    /**
     * If the Link is selected then we represent
     * it as two selected nodes
     * @param {Node|Link} selectedElement
     * @returns {Node[]}
     */
    function _getSelectedNodes(selectedElement) {
        var nodeMap = _dataContainer.maps.nodeMap;
        var isNode = selectedElement instanceof _elements.Node;
        return isNode ? [selectedElement] : [nodeMap[selectedElement.model.source], nodeMap[selectedElement.model.target]];
    }

    /**
     * If the Link is selected then we represent
     * it as two selected nodes
     * @param {Node} selectedNode
     * @param {Object.<string, Node>} visibleNodeMap - Visible nodes
     * @param {Link[]} badLinks - Links which have either source either target is not visible
     * @returns {Node[], Link[]}
     */
    function _getTerminationOrigins(selectedNode, visibleNodeMap, badLinks) {
        var terminationOriginNodes = [];
        var terminationOriginLinks = [];
        var processedCellIds = {};
        var nodeMap = _dataContainer.maps.nodeMap;

        var isSelectedNodeVisible = visibleNodeMap[selectedNode.id];
        if (isSelectedNodeVisible) {
            badLinks.forEach(function (link) {
                if (!processedCellIds[link.id]) {
                    processedCellIds[link.id] = true;
                    var isLinkConnectedToSelectedNode = link.model.source === selectedNode.id || link.model.target === selectedNode.id;
                    var terminationsHaveViewFrames = link.model.source === selectedNode.id ? _getViewFrameForNode(nodeMap[link.model.target]) : _getViewFrameForNode(nodeMap[link.model.source]);
                    if (isLinkConnectedToSelectedNode && terminationsHaveViewFrames) {
                        terminationOriginLinks.push(link);

                        var sourceIsntVisible = !visibleNodeMap[link.model.source];
                        if (sourceIsntVisible && !processedCellIds[link.model.source]) {
                            processedCellIds[link.model.source] = true;
                            terminationOriginNodes.push(nodeMap[link.model.source]);
                        }

                        var targetIsntVisible = !visibleNodeMap[link.model.target];
                        if (targetIsntVisible && !processedCellIds[link.model.target]) {
                            processedCellIds[link.model.target] = true;
                            terminationOriginNodes.push(nodeMap[link.model.target]);
                        }
                    }
                }
            });
        } else {
            terminationOriginNodes.push(selectedNode);
            badLinks.forEach(function (link) {
                if (!processedCellIds[link.id]) {
                    processedCellIds[link.id] = true;
                    var isLinkConnectedToSelectedNode = link.model.source === selectedNode.id || link.model.target === selectedNode.id;
                    if (isLinkConnectedToSelectedNode) {
                        terminationOriginLinks.push(link);
                    }
                }
            });
        }

        return {
            nodes: terminationOriginNodes,
            links: terminationOriginLinks
        };
    }

    /**
     * Returns position for the termination node.
     * @param {TerminationNode} terminationNode
     * @param {ViewFrame} viewFrame
     * @param {RenderOption} renderOptions
     * @returns {Point}
    */
    function _getTerminationNodePosition(terminationNode, viewFrame, renderOptions) {
        var originalNode = terminationNode.originalNode;
        var viewFrameSize = viewFrame.size; // local size
        var viewFramePosition = viewFrame.position(); // local position
        var nodeSize = originalNode.size; // local size

        var topLeft = viewFramePosition;
        var topRight = { x: viewFramePosition.x + viewFrameSize.width, y: viewFramePosition.y };
        var bottomLeft = { x: viewFramePosition.x, y: viewFramePosition.y + viewFrameSize.height };
        var bottomRight = { x: viewFramePosition.x + viewFrameSize.width, y: viewFramePosition.y + viewFrameSize.height };

        var calculationPoints = getCalculationPoints();
        var sourcePoint = calculationPoints.sourcePoint;
        var terminationPoint = calculationPoints.terminationPoint;

        // choose a side for termination node

        var crossPoint = (0, _lineageDiagramUtils.getCrosPoint)(sourcePoint, terminationPoint, topLeft, bottomLeft); // left

        if (!crossPoint) {
            crossPoint = (0, _lineageDiagramUtils.getCrosPoint)(sourcePoint, terminationPoint, topLeft, topRight); // top
        }
        if (!crossPoint) {
            crossPoint = (0, _lineageDiagramUtils.getCrosPoint)(sourcePoint, terminationPoint, topRight, bottomRight); // right
        }
        if (!crossPoint) {
            crossPoint = (0, _lineageDiagramUtils.getCrosPoint)(sourcePoint, terminationPoint, bottomLeft, bottomRight); // bottom
        }

        if (crossPoint) {
            return {
                x: crossPoint.x - _terminationNodeSize.width / 2,
                y: crossPoint.y - _terminationNodeSize.height / 2
            };
        } else {
            return {
                x: Math.min(Math.max(terminationPoint.x + nodeSize.width / 2, viewFramePosition.x), viewFramePosition.x + viewFrameSize.width),
                y: Math.min(Math.max(terminationPoint.y + nodeSize.height / 2, viewFramePosition.y), viewFramePosition.y + viewFrameSize.height)
            };
        }

        function getCalculationPoints() {
            var sourcePoint = {
                x: viewFramePosition.x + viewFrameSize.width / 2,
                y: viewFramePosition.y + viewFrameSize.height / 2
            };

            var ownerViewFrame = _getViewFrameForNode(originalNode);
            var scale = ownerViewFrame.getScale();
            var nodePosition = (0, _utils.getLocalNodePosition)(originalNode, scale, ownerViewFrame);
            var terminationPoint = {
                x: nodePosition.x + nodeSize.width / 2,
                y: nodePosition.y + nodeSize.height / 2
            };

            var pointIsInTheFrame = viewFrame.hitScaledPointTest(terminationPoint);
            if (pointIsInTheFrame) {
                var distToLeft = terminationPoint.x - viewFramePosition.x;
                var distToTop = terminationPoint.y - viewFramePosition.y;
                var distToRight = viewFramePosition.x + viewFrameSize.width - terminationPoint.x;
                var distToBottom = viewFramePosition.y + viewFrameSize.height - terminationPoint.y;

                var min = Infinity;
                [distToLeft, distToTop, distToRight, distToBottom].forEach(function (dist) {
                    min = Math.min(min, dist);
                });

                if (min === distToLeft) {
                    terminationPoint.x -= min;
                } else if (min === distToRight) {
                    terminationPoint.x += min;
                } else if (min === distToTop) {
                    terminationPoint.y -= min;
                } else {
                    terminationPoint.y += min;
                }
            }

            // Sometime it's confusing for users when
            // nodes are in the leftViewFrame but termination nodes goes to the right
            if (ownerViewFrame.id !== viewFrame.id) {
                var ids = _allFrames.map(function (vf) {
                    return vf.id;
                });
                var viewFrameIndex = ids.indexOf(viewFrame.id);
                var ownerViewFrameIndex = ids.indexOf(ownerViewFrame.id);
                var orientation = renderOptions.paperOptions.orientation;
                var isHorizontalOrientated = orientation === 'left-to-right' || orientation === 'right-to-left';
                if (viewFrameIndex < ownerViewFrameIndex) {
                    if (isHorizontalOrientated) {
                        terminationPoint.x = bottomRight.x;
                    } else {
                        terminationPoint.y = bottomRight.y;
                    }
                } else {
                    if (isHorizontalOrientated) {
                        terminationPoint.x = topLeft.x;
                    } else {
                        terminationPoint.y = topLeft.y;
                    }
                }
            }

            return {
                sourcePoint: sourcePoint,
                terminationPoint: terminationPoint
            };
        }
    }

    /**
     * Creates (or get from cache) aspect links
     * @param {Node[]} nodes - visible nodes
     * @returns {AspectLink[]}
    */
    function _calculateAspectLinks(nodes) {
        var aspectLinksCache = {};
        var nodeMap = (0, _utils.arrayToMap)(nodes);
        nodes.forEach(function (node) {
            var aspects = (0, _dataUtils.getBaseElement)(node).aspects;
            aspects.forEach(function (aspect) {
                var visibleTerminations = aspect.terminationNodes.filter(function (tn) {
                    return nodeMap[tn.id];
                });
                var atLeastOneTermination = visibleTerminations.length > 0;
                var aspectWillOnThePaper = nodeMap[aspect.id] || atLeastOneTermination;
                var viewFrameOwner = _getViewFrameForNode(aspect);
                var viewFrameOwnerIsVisible = _state[viewFrameOwner.id] || _fullScreenMode;
                if (aspectWillOnThePaper && viewFrameOwnerIsVisible) {
                    var aspectInstances = nodeMap[aspect.id] ? [aspect] : visibleTerminations;

                    aspectInstances.forEach(function (aspectInstance) {
                        var cachedLink = getFromCahe(node, aspectInstance);
                        var aspectLink = cachedLink || createAspectLink(node, aspectInstance);

                        aspectLinksCache[aspectLink.id] = aspectLink;
                    });
                }
            });
        });
        _aspectLinksCahe = aspectLinksCache;
        var aspectLinks = Object.keys(aspectLinksCache).map(function (id) {
            return _aspectLinksCahe[id];
        });
        return aspectLinks;

        function createAspectLink(node, aspect) {
            var id = node.id + '~#~' + aspect.id;

            return new _elements.AspectLink({
                id: id,
                source: node,
                target: aspect
            }, parameters);
        }

        function getFromCahe(node, aspect) {
            var id = node.id + '~#~' + aspect.id;
            var reverseId = aspect.id + '~#~' + node.id;

            var linkFromLocal = aspectLinksCache[id] || aspectLinksCache[reverseId];
            var linkFromGlobal = _aspectLinksCahe[id] || _aspectLinksCahe[reverseId];
            return linkFromLocal || linkFromGlobal;
        }
    }

    /**
     * Changes highlighting of the elements
     * @param {(Node|Link|TerminationNode|TerminationLink)[]} cells
     * @param {RenderOption} renderOptions
    */
    function _setHighlighting(cells, renderOptions) {
        var path = renderOptions.path;
        var mask = renderOptions.mask;

        cells.forEach(function (cell) {
            var baseCell = (0, _dataUtils.getBaseElement)(cell);
            if (mask && baseCell !== renderOptions.selectedElement) {
                if (mask[baseCell.id]) {
                    baseCell.hide();
                } else {
                    baseCell.show();
                }
            }
            if (baseCell === renderOptions.selectedElement) {
                baseCell.select();
            } else if (path && !path[baseCell.id]) {
                baseCell.blure();
            } else {
                baseCell.unblure();
            }
        });
    }

    /**
     * Returns list of visible viewFrames
     * @returns {ViewFrame[]}
    */
    function _getVisibleViewFrames() {
        return _fullScreenMode ? [_overViewFrame] : _viewFrames.filter(function (vf) {
            return _state[vf.id];
        });
    }

    /**
     * Returns viewFrame for the node.
     * @param {Node} node
     * @returns {ViewFrame | undefined}
     */
    function _getViewFrameForNode(node) {
        if (_fullScreenMode) {
            return _overViewFrame;
        } else {
            var viewFrameId = (0, _lineageDiagramUtils.getViewFrameIdForNode)(node);
            return _viewFramesMap[viewFrameId];
        }
    }

    /**
     * Subscribes on viewFrame events
    */
    function _subscribeOnViewFrameEvents() {
        _allFrames.forEach(function (viewFrame) {
            viewFrame.on('change-view-port-position', function (newViewPortPosition) {
                if (viewFrame.movingByItself) return;

                var viewFramePublicModel = _getViewFramePublicModel(viewFrame);
                viewFramePublicModel.viewPortPosition = newViewPortPosition;

                self.trigger('change-view-port-position', viewFramePublicModel);
            });
        });
    }
}

exports.default = ViewManager;

},{"../subscriptionAPI/subscribeable":66,"../utils/dataUtils":67,"../utils/lineageDiagramUtils":69,"../utils/utils":70,"./graphElements/elements":47,"./viewFrame":55,"lodash":"lodash"}],57:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.combineOperation = combineOperation;
exports.doLayout = doLayout;
exports.removeCycles = removeCycles;

var _webcola = require('webcola');

var cola = _interopRequireWildcard(_webcola);

var _lodash = require('lodash');

var _ = _interopRequireWildcard(_lodash);

var _sankey = require('./sankey');

var _sankey2 = _interopRequireDefault(_sankey);

var _utils = require('../utils/utils');

var _layoutUtils = require('../utils/layoutUtils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @private
 * @param {{
 *  selectedNode: Node,
 *  relativeLinks: Link[],
 *  relativeNodes: Node[],
 * }} options 
 * @param {Parameters} parameters - parameters set
 */
function combineOperation(options, parameters) {
    var scale = options.scale;

    var startPosition = (0, _utils.getGlobalNodePosition)(options.selectedNode);
    var combinedNodes = [options.selectedNode].concat(options.relativeNodes);

    var elements = (0, _layoutUtils.convertLGElementsToLayoutModels)(combinedNodes, options.relativeLinks, {
        scale: scale
    });
    var nodes = elements.nodes;
    var links = elements.links;
    var selectedLayoutNode = nodes[0];

    var layoutOptions = {
        nodes: nodes,
        links: links,
        step: parameters.layoutStep,
        element: parameters.elementSize,
        iterations: parameters.layoutIterations
    };
    tqForceLayout(layoutOptions);

    var result = {};
    nodes.forEach(function (layoutNode) {
        if (layoutNode !== selectedLayoutNode) {
            layoutNode.x = startPosition.x + (layoutNode.x - selectedLayoutNode.x);
            layoutNode.y = startPosition.y + (layoutNode.y - selectedLayoutNode.y);
        }
        result[layoutNode.originalNode.id] = {
            x: layoutNode.x,
            y: layoutNode.y
        };
    });

    return result;
}

/**
 * @private 
 * 
 * Calculates positions for nodes.
 * @param {Array} nodeModels - list of the native nodes
 * @param {Array} nativeLinks - list of the native links
 * @param {Parameters} parameters - parameters set
 */
function doLayout(nodeModels, linkModels, viewFrames, parameters) {
    if (!parameters) return;

    var elements = (0, _layoutUtils.convertNativeToLayoutModels)(nodeModels, linkModels, parameters);
    var nodes = elements.nodes;
    var links = elements.links;
    var isHorizontal = parameters.graphOrientation === 'right-to-left' || parameters.graphOrientation === 'left-to-right';

    removeCycles(nodes, links);

    var groups = breakByGroups(nodes, links, viewFrames, parameters);

    var layoutOptions = {
        groups: groups,
        nodes: nodes,
        links: links,
        isHorizontal: isHorizontal,
        step: parameters.layoutStep,
        element: parameters.elementSize,
        iterations: parameters.layoutIterations
    };

    if (parameters.layoutAlgorithm === 'flow-directed') {
        tqFlowLayout(layoutOptions);
    } else {
        tqSankeyLayout(layoutOptions);
    }
    applyLayout();

    function applyLayout() {
        // Calculating min points
        var minX = Infinity,
            minY = Infinity;
        nodes.forEach(function (node) {
            minX = Math.min(minX, node.x);
            minY = Math.min(minY, node.y);
        });

        var maxX = nodes.length > 0 ? -Infinity : 0;
        var canvasPadding = Math.max(parameters.elementSize.width, parameters.elementSize.height) * 2 * parameters.scaleBounds.max;
        nodes.forEach(function (node) {
            node.originalNode.position.x = node.x - minX + canvasPadding;
            node.originalNode.position.y = node.y - minY + canvasPadding;
            maxX = Math.max(maxX, node.originalNode.position.x);
        });

        if (parameters.graphOrientation === 'right-to-left' || parameters.graphOrientation === 'bottom-to-top') {
            nodeModels.forEach(function (node) {
                node.position.x = maxX - node.position.x;
            });
        }

        if (!isHorizontal) {
            nodeModels.forEach(function (node) {
                var x = node.position.x;
                node.position.x = node.position.y;
                node.position.y = x;
            });
        }

        nodeModels.forEach(function (node) {
            node.defaultPosition = _.clone(node.position);
        });
    }
}

function removeCycles(nodes, links) {
    nodes.forEach(function (n) {
        var repeatMap = {};
        var linksToRemove = [];

        recursion(n);

        linksToRemove.forEach(function (link) {
            links.splice(links.indexOf(link), 1);
            link.target.sourceLinks.splice(link.target.sourceLinks.indexOf(link), 1);
            link.source.targetLinks.splice(link.source.targetLinks.indexOf(link), 1);
        });

        function recursion(node) {
            repeatMap[node.id] = true;
            node.targetLinks.forEach(function (link) {
                if (!repeatMap[link.target.id]) {
                    recursion(link.target);
                } else {
                    linksToRemove.push(link);
                }
            });
            repeatMap[node.id] = false;
        }
    });
}

function breakByGroups(nodes, links, viewFrames, parameters) {
    var nodeMap = (0, _utils.arrayToMap)(nodes);
    var groups = {};
    var paperSize = (0, _utils.getElementSize)(parameters.graphPlace);
    var isHorizontal = parameters.graphOrientation === 'left-to-right' || parameters.graphOrientation === 'right-to-left';
    var totalShare = viewFrames.reduce(function (accumulator, viewFrame) {
        return accumulator + viewFrame.spaceShare;
    }, 0);
    viewFrames.forEach(function (viewFrame) {
        if (!groups[viewFrame.id]) groups[viewFrame.id] = {
            id: viewFrame.id,
            prefferedSize: {
                width: isHorizontal ? paperSize.width / totalShare * viewFrame.spaceShare : paperSize.height / totalShare * viewFrame.spaceShare,
                height: isHorizontal ? paperSize.height : paperSize.width
            },
            nodes: [],
            links: []
        };

        var lastNodes = [];
        nodes.forEach(function (node) {
            if (node.viewFrame === viewFrame.id) {
                groups[viewFrame.id].nodes.push(node);
            } else {
                lastNodes.push(node);
            }
        });
        nodes = lastNodes;

        var lastLinks = [];
        links.forEach(function (l) {
            if (nodeMap[l.source.id].viewFrame === viewFrame.id && nodeMap[l.target.id].viewFrame === viewFrame.id) {
                groups[viewFrame.id].links.push(l);
            } else if (nodeMap[l.source.id].viewFrame !== viewFrame.id && nodeMap[l.target.id].viewFrame !== viewFrame.id) {
                lastLinks.push(l);
            }
        });
        links = lastLinks;
    });
    groups['unknown'] = { id: 'unknown', nodes: nodes, links: links };
    return Object.keys(groups).map(function (key) {
        return groups[key];
    });
}

function tqSankeyLayout(options) {
    var step = options.isHorizontal ? [options.step.x || 100, options.step.y || 15] : [options.step.y || 15, options.step.x || 100];
    options.step = options.step || {};
    (0, _sankey2.default)().step(step).nodeWidth(options.element.width).nodeHeight(options.element.height).nodes(options.nodes).links(options.links).groups(options.groups).layout(options.iterations);
}

function tqFlowLayout(options) {
    tqSankeyLayout(options);

    var layout = new cola.Layout().nodes(options.nodes).links(options.links).convergenceThreshold(1e-9).jaccardLinkLengths(options.step.x * 2 || 400).flowLayout('x', options.step.x * 2 || 400).avoidOverlaps(true).handleDisconnected(true);
    layout.start(100, 0, 50, undefined, false);
}

function tqForceLayout(options) {
    var layout = new cola.Layout().nodes(options.nodes).links(options.links).convergenceThreshold(1e-9).jaccardLinkLengths(options.step.x * 1.5 || 350).avoidOverlaps(true).handleDisconnected(true);
    layout.start(100, 0, 50, undefined, false);
}

},{"../utils/layoutUtils":68,"../utils/utils":70,"./sankey":58,"lodash":"lodash","webcola":6}],58:[function(require,module,exports){
'use strict';

var _layoutUtils = require('../utils/layoutUtils');

var utils = _interopRequireWildcard(_layoutUtils);

var _utils = require('../utils/utils');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var Sankey = function Sankey() {
    var sankey = {},
        nodeWidth = 24,
        nodeHeight = 8,
        size = [1, 1],
        step = [100, 30],
        nodes = [],
        groups = [],
        saveOrder = false,
        links = [];

    sankey.nodeWidth = function (_) {
        if (!arguments.length) return nodeWidth;
        nodeWidth = +_;
        return sankey;
    };

    sankey.nodeHeight = function (_) {
        if (!arguments.length) return nodeHeight;
        nodeHeight = +_;
        return sankey;
    };

    sankey.nodes = function (_) {
        if (!arguments.length) return nodes;
        nodes = _;
        return sankey;
    };

    sankey.saveOrder = function (_) {
        if (!arguments.length) return saveOrder;
        saveOrder = _;
        return sankey;
    };

    sankey.groups = function (_) {
        if (!arguments.length) return groups;
        groups = _;
        return sankey;
    };

    sankey.links = function (_) {
        if (!arguments.length) return links;
        links = _;
        return sankey;
    };

    sankey.step = function (_) {
        if (!arguments.length) return step;
        step = _;
        return sankey;
    };

    sankey.computeNodeBreadths = undefined;

    sankey.layout = function (iterations) {
        computeNodeLinks();
        computeNodeValues();

        if (sankey.computeNodeBreadths) sankey.computeNodeBreadths(nodes, links, groups);else computeNodeBreadths();

        computeNodeDepths(iterations);
        computeLinkDepths();
        return sankey;
    };

    sankey.relayout = function () {
        computeLinkDepths();
        return sankey;
    };

    sankey.link = function () {
        var curvature = .5;

        function link(d) {
            var x0 = d.source.x + d.source.dx,
                x1 = d.target.x,
                xi = utils.interpolateNumber(x0, x1),
                x2 = xi(curvature),
                x3 = xi(1 - curvature),
                y0 = d.source.y + d.sy + d.dy / 2,
                y1 = d.target.y + d.ty + d.dy / 2;
            return 'M' + x0 + ',' + y0 + 'C' + x2 + ',' + y0 + ' ' + x3 + ',' + y1 + ' ' + x1 + ',' + y1;
        }

        link.curvature = function (_) {
            if (!arguments.length) return curvature;
            curvature = +_;
            return link;
        };

        return link;
    };

    // Populate the sourceLinks and targetLinks for each node.
    // Also, if the source and target are not objects, assume they are indices.
    function computeNodeLinks() {
        nodes.forEach(function (node) {
            node.sourceLinks = [];
            node.targetLinks = [];
        });
        links.forEach(function (link) {
            var source = link.source,
                target = link.target;
            if (typeof source === 'number') source = link.source = nodes[link.source];
            if (typeof target === 'number') target = link.target = nodes[link.target];
            source.sourceLinks.push(link);
            target.targetLinks.push(link);
        });
    }

    // Compute the value (size) of each node by summing the associated links.
    function computeNodeValues() {
        nodes.forEach(function (node) {
            node.value = Math.max(utils.sum(node.sourceLinks, value), utils.sum(node.targetLinks, value)) || 1;
        });
    }

    // Iteratively assign the breadth (x-position) for each node.
    // Nodes are assigned the maximum breadth of incoming neighbors plus one;
    // nodes with no incoming links are assigned breadth zero, while
    // nodes with no outgoing links are assigned the maximum breadth.

    function computeNodeBreadths() {
        groups.forEach(function (group) {
            var nodesOfGrpoup = (0, _utils.arrayToMap)(group.nodes);
            var remainingNodes = group.nodes;
            var nextNodes = void 0;

            remainingNodes.sort(function (n1, n2) {
                var result = getLinks(n2.sourceLinks).length - getLinks(n1.sourceLinks).length;
                if (result === 0) {
                    return getLinks(n2.targetLinks).length - getLinks(n1.targetLinks).length;
                } else {
                    return result;
                }
            });

            var x = 0;
            var startX = x;
            while (remainingNodes.length > 0) {
                nextNodes = [];
                remainingNodes.forEach(function (node) {
                    node.x = x;
                    node.dx = nodeWidth;

                    // Here we are going to use iverse direction to make nodes closer to their targets
                    // so we pass targetLinks instead of sourceLinks
                    getLinks(node.targetLinks).forEach(function (link) {
                        if (nextNodes.indexOf(link.source) < 0) {
                            nextNodes.push(link.source);
                        }
                    });
                });
                remainingNodes = nextNodes;
                ++x;
            }
            group.breadth = x - startX;

            // Revert direction back
            group.nodes.forEach(function (node) {
                node.x = startX + (x - 1) - node.x;
            });

            function getLinks(links) {
                return links.filter(function (l) {
                    return nodesOfGrpoup[l.source.id];
                });
            }
        });

        var curXPosition = 0;
        groups.forEach(function (group) {
            var groupSize = calculateGroupWidth(group);

            if (group.prefferedSize && group.breadth > 1) {
                groupSize = Math.max(groupSize, group.prefferedSize.width /* * maxK */);
            }
            var kx = group.breadth > 1 ? groupSize / (group.breadth - 1) : 0;
            group.nodes.forEach(function (node) {
                node.x = curXPosition + node.x * kx;
            });
            curXPosition += groupSize + step[0] + nodeWidth;
        });

        function calculateGroupWidth(group) {
            return (group.breadth - 1) * (step[0] + nodeWidth);
        }
    }

    function computeHeight(nodesByBreadth) {
        var maxColumnHeight = 0;
        nodesByBreadth.forEach(function (nodes) {
            maxColumnHeight = Math.max(maxColumnHeight, nodes.length);
        });
        size[1] = maxColumnHeight * nodeHeight + (maxColumnHeight - 1) * step[1];
    }

    function computeNodeDepths(iterations) {
        var nodesByBreadth = utils.nest().key(function (d) {
            return d.x;
        }).sortKeys(function (a, b) {
            return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
        }).entries(nodes).map(function (d) {
            return d.values;
        });

        computeHeight(nodesByBreadth);

        initializeNodeDepth();
        resolveCollisions();
        for (var alpha = 1; iterations > 0; --iterations) {
            relaxRightToLeft(alpha *= .99);
            resolveCollisions();
            relaxLeftToRight(alpha);
            resolveCollisions();
            if (saveOrder) restoreOrder();
        }
        floorToModule();

        function initializeNodeDepth() {
            var ky = utils.min(nodesByBreadth, function (nodes) {
                return (size[1] - (nodes.length - 1) * nodeHeight) / utils.sum(nodes, value);
            });

            nodesByBreadth.forEach(function (nodes) {
                nodes.forEach(function (node, i) {
                    node.y = i;
                    node.dy = node.value * ky;
                });
            });

            links.forEach(function (link) {
                link.dy = link.value * ky;
            });
        }

        function relaxLeftToRight(alpha) {
            nodesByBreadth.forEach(function (nodes) {
                nodes.forEach(function (node) {
                    if (node.targetLinks.length) {
                        var y = utils.sum(node.targetLinks, weightedSource) / utils.sum(node.targetLinks, value);
                        node.y += (y - center(node)) * alpha;
                    }
                });
            });

            function weightedSource(link) {
                return center(link.source) * link.value;
            }
        }

        function relaxRightToLeft(alpha) {
            nodesByBreadth.slice().reverse().forEach(function (nodes) {
                nodes.forEach(function (node) {
                    if (node.sourceLinks.length) {
                        var y = utils.sum(node.sourceLinks, weightedTarget) / utils.sum(node.sourceLinks, value);
                        node.y += (y - center(node)) * alpha;
                    }
                });
            });

            function weightedTarget(link) {
                return center(link.target) * link.value;
            }
        }

        function floorToModule() {
            nodesByBreadth.forEach(function (nodes) {
                var placeMap = {};
                nodes.forEach(function (node) {
                    var fullStep = step[1] + nodeHeight;
                    var y = node.y - node.y % fullStep;
                    while (placeMap[y]) {
                        y += fullStep;
                    }
                    node.y = y;
                    placeMap[y] = true;
                });
            });
        }

        function restoreOrder() {
            nodesByBreadth.forEach(function (nodes) {
                for (var i = 0; i < nodes.length; i++) {
                    var nodeA = nodes[i];
                    for (var j = i; j < nodes.length; j++) {
                        var nodeB = nodes[j];
                        if (nodeA.order < nodeB.order && nodeA.y > nodeB.y) {
                            var tempY = nodeA.y;
                            nodeA.y = nodeB.y;
                            nodeB.y = tempY;
                        }
                    }
                }
            });
        }

        function resolveCollisions() {
            nodesByBreadth.forEach(function (nodes) {
                var node,
                    dy,
                    y0 = 0,
                    n = nodes.length,
                    i;

                // Push any overlapping nodes down.
                nodes.sort(ascendingDepth);
                for (i = 0; i < n; ++i) {
                    node = nodes[i];
                    dy = y0 - node.y;
                    if (dy > 0) node.y += dy;
                    y0 = node.y + node.dy + nodeHeight;
                }

                // If the bottommost node goes outside the bounds, push it back up.
                dy = y0 - nodeHeight - size[1];
                if (dy > 0) {
                    y0 = node.y -= dy;

                    // Push any overlapping nodes back up.
                    for (i = n - 2; i >= 0; --i) {
                        node = nodes[i];
                        dy = node.y + node.dy + nodeHeight - y0;
                        if (dy > 0) node.y -= dy;
                        y0 = node.y;
                    }
                }
            });
        }

        function ascendingDepth(a, b) {
            return a.y - b.y;
        }
    }

    function computeLinkDepths() {
        nodes.forEach(function (node) {
            node.sourceLinks.sort(ascendingTargetDepth);
            node.targetLinks.sort(ascendingSourceDepth);
        });
        nodes.forEach(function (node) {
            var sy = 0,
                ty = 0;
            node.sourceLinks.forEach(function (link) {
                link.sy = sy;
                sy += link.dy;
            });
            node.targetLinks.forEach(function (link) {
                link.ty = ty;
                ty += link.dy;
            });
        });

        function ascendingSourceDepth(a, b) {
            return a.source.y - b.source.y;
        }

        function ascendingTargetDepth(a, b) {
            return a.target.y - b.target.y;
        }
    }

    function center(node) {
        return node.y + node.dy / 2;
    }

    function value(link) {
        return link.value;
    }

    return sankey;
};
module.exports = Sankey;

},{"../utils/layoutUtils":68,"../utils/utils":70}],59:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.getDefaultParametersSet = getDefaultParametersSet;
exports.LineageGram = LineageGram;

var _visualizationsLibrary = require('visualizations-library');

var _visualizationsLibrary2 = _interopRequireDefault(_visualizationsLibrary);

var _rappid = require('rappid');

var joint = _interopRequireWildcard(_rappid);

var _layout = require('./layout/layout');

var layout = _interopRequireWildcard(_layout);

var _elements = require('./jointViews/graphElements/elements');

var graphElements = _interopRequireWildcard(_elements);

var _lodash = require('lodash');

var _ = _interopRequireWildcard(_lodash);

var _lineageDiagram2 = require('./jointViews/lineageDiagram');

var _lineageDiagram3 = _interopRequireDefault(_lineageDiagram2);

var _derivationMap2 = require('./jointViews/derivationMap/derivationMap');

var _derivationMap3 = _interopRequireDefault(_derivationMap2);

var _graphMap2 = require('./sigmaViews/graphMap');

var _graphMap3 = _interopRequireDefault(_graphMap2);

var _birdEye2 = require('./sigmaViews/birdEye');

var _birdEye3 = _interopRequireDefault(_birdEye2);

var _dataContainer2 = require('./data/dataContainer');

var _dataContainer3 = _interopRequireDefault(_dataContainer2);

var _stateStorage2 = require('./stateStorage');

var _stateStorage3 = _interopRequireDefault(_stateStorage2);

var _subscribeable = require('./subscriptionAPI/subscribeable');

var _subscribeable2 = _interopRequireDefault(_subscribeable);

var _resourceProvider = require('./data/resourceProvider');

var _dataUtils = require('./utils/dataUtils');

var _dataProcessing = require('./data/dataProcessing');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Class which provides data for the LineageGram.
 * @interface DataProvider
 */

/**
 * The function which returns nodes and link models for the graph.
 * @function
 * @name DataProvider#fetchData
 * @param {string} targetNodeId
 * @param {string} viewFrame
 * @param {string} lineageGramViewClass
 * @param {string} diagramType
   @param {number} offset
 * @returns {Promise<ServerData>} Promise which provides graph data.
 */

/**
* The function which returns nodes and link models for the graph.
* @function
* @name DataProvider#getViewFrames
* @param {string} resource
* @returns {Promise<ViewFrameDefinition[]>} Promise which provides graph data.
*/

/**
* The function which returns nodes and link models for the graph.
* @function
* @name DataProvider#getViewClassForResource
* @param {string} resource
* @returns {Promise<{dataProvider: string}>} Promise which provides graph data.
*/

/**
* The function which returns nodes and link models for the graph.
* @function
* @name DataProvider#relationInfo
* @param {Link} relation
* @returns {Promise<DerivationMapData>} Promise which provides graph data.
*/

/**
* Represents a node model which is extended by diagramType field
* @typedef {Object} PublicNodeModel
* @property {string} id
* @property {string} label
* @property {string} resource
* @property {string} resourceType
* @property {string} diagramType
* @property {string} typeId
* @property {string} viewFrame
* @property {any} data
*/

/**
* Represents a link model which is extended by diagramType field
* @typedef {Object} PublicLinkModel
* @property {string} id
* @property {string} source
* @property {string} target
* @property {string} diagramType
* @property {string} linkType
* @property {any} data
*/

/**
 * Represents a dataProvider response which includes
 * links and nodes for the LineageGram
 * @typedef {Object} ServerData
 * @property {string} diagramType
 * @property {string} focusNode - IRI of focusNode
 * @property {LinkModel[]} links - Link models
 * @property {NodeModel[]} nodes - Node models
*/

/**
 * Represents a state
 * @typedef {Object} HistoryState
 * @property {Link[]} links - Links
 * @property {Node[]} nodes - Nodes
 * @property {ViewFrameDefinition[]} viewFrames
 * @property {Node} focusNode - Focus node for the state
*/

/**
 * Size
 * @typedef {Object} Size
 * @property {number} width - Width
 * @property {number} height - Height
*/

/**
 * Point
 * @typedef {Object} Point
 * @property {number} x - X
 * @property {number} y - Y
*/

/**
 * View frame definition,
 * @typedef {Object} ViewFrameDefinition
 * @property {string} id - View frame identifyer
 * @property {string} label - Title of the view frame,
 * @property {string} borderColor - Color of the border
 * @property {string} backgroundColor - Color of the background
 * @property {number} spaceShare - How much the view frame will take
 * @property {boolean} collapsed - Define default state
 * from whole space of the graph (You can take it as persents or flex grow)
*/

/**
 * Link tool button definition
 * @typedef {Object} LinkToolButton
 * @property {string} image - path to image
 * @property {number} width
 * @property {number} height
*/

/**
 * Link style definition
 * @typedef {Object} LinkStyleDefinition
 * @property {string} cssClass - CSS class which will be attached to the svg component
 * @property {string} lineType - 'solid' or 'dashed'
 * @property {string} color - Color of the line
 * @property {number} thickness
 * @property {boolean} hasArrow - Tells us whether line has a termination arrow or not
 * @property {LinkToolButton} toolButton
*/

/**
 * Size of the nodes of the graph (maximum, minimum, default)
 * @typedef {Object} ElementSize
 * @property {number} width - Default width of the nodes
 * @property {number} height - Default height of the nodes
 * @property {number} minWidth - Minimum width of the nodes
 * @property {number} maxWidth - Maximum width of the nodes
 * @property {number} minHeight - Minimum height of the nodes
 * @property {number} maxHeight - Maximum height of the nodes
*/

/**
 * Scale bounds.
 * @typedef {Object} ScaleBounds
 * @property {number} min
 * @property {number} max
*/

/**
 * In fact the object is a map between colors and keys (ids) of elements,
 * but there are number of default color keys.
 * @typedef {Object.<string, string>} Colors
 * @property {string} terminationText - Color of the text on termination nodes
 * @property {string} text - Color of the text on the graph's nodes,
 * @property {string} unknown - Color for nodes whose id is unknown
 * @property {string} default - Default color for nodes
 * @property {string} selected - Color of elements which are selected
 * @property {string} blured - Color for blured elements
 * @property {string} link - Color for links
 * @property {string} terminationLink - Color for termination links
 * @property {string} aspectLink - Color for aspect links
*/

/**
 * Tool button.
 * @typedef {Object} LinkToolButton
 * @property {string} image - src or xhref for tool button
 * @property {number} width - button width
 * @property {string} height - button height
*/

/**
 * Default parameters set for LineageGram. You can pass any of these parameters into the constructor during the LineageGram initialization.
 * @typedef {Object} Parameters
 * @property {string|HTMLElement} graphPlace - Identifier of the root html element for binding graph or just root HTMLElement
 * @property {string|HTMLElement} mapRootHtml - Identifier of the root html element for binding map or just root html element
 * @property {DataProvider} dataProvider - Function that resieves and returns data for the graph
 * @property {string} focusNode - Focus node id
 *
 * @property {function} launchExternal - It can be called in order to get more information about some element in derivation map and in main class.
 *
 * @property {ElementSize} elementSize - Size of the nodes of the graph
 * @property {ElementSize} overViewElementSize - Size of the nodes of the graph in OverViewFrame
 *
 * @property {number} layoutStep - Distance between elements of the graph
 * @property {number} layoutIterations - How much iterations will be done during the layout algorithm
 * @property {number} offsetBetweenGroups - Additional offset between groups of nodes (viewFrame groups)
 *
 * @property {Colors} colors - Color map
 *
 * @property {boolean} animation - If it's true, the animation is allowed. By default - true
 * @property {number} maxFrameRate - Maximum speed of animation. By defaul - 50 frames per second
 * @property {number} minFrameRate - Minimum speed of animation. By defaul - 10 frames per second
 * @property {number} animationStep - How far viewFrame position is changing per animation frame
 *
 * @property {ViewFrameDefinition[]} - View frames definition
 * @property {boolean} fullScreenMode - Defines whether we want to open LG in full-screen-mode or in the regular mode
 *
 * @property {Object.<string, string>} images - Map between node types and image urls.
 * @property {Object.<string, string>} icons - Map between node types and icons (css).
 * @property {string} resourcePath - Prefix for resources like images (optional)
 * @property {boolean} usePOSTExecutor - to make able use post requests for sparqlProvider
 * @property {Point} framePadding - ViewPorts enabled area expanded by this value
 *
 * @property {boolean} clipNodes - Tells us do or not clipping nodes by viewFrames
 * @property {number} frameBorderWidth - Width of the frame border
 *
 * @property {boolean} showCollapsedFrames - Tells whether hide or show collapsed viewFrmaes in the bottom of the graph.
 *
 * @property {Point} defaultScale
 * @property {ScaleBounds} scaleBounds - Contains minimal(min) and maximum(max) values of the scale.
 * @property {ScaleBounds} overViewScaleBounds - Contains minimal(min) and maximum(max) values of the scale for OverViewFrame.
 * @property {number} scaleStep - How much scale changes per step.
 *
 * @property {Size} terminationNodeSize - Size of the termination nodes
 * @property {Size} dataZoneSize - Size of zones in data container. Zones are grouping and sorting in special areas to implement binary searching
 * @property {number} zonesInGroup - Grouping data zones in bigger groups by groups of (for example) four
 * @property {string} linkRouting - Links routing (based on jointjs routings: metro/normal/manhattan/orthogonal)
 *
 * @property {Object.<string, LinkStyleDefinition>} linkStyles - Map between the linkTypes and LinkStyles.
 * @property {string} graphOrientation - Orientation of the graph. Can be: 'left-to-right', 'right-to-left', 'top-to-bottom', 'bottom-to-top'
 * @property {DerivationMapParameters} derivationMap - parameters set for DerivationMap
 * @property {Object.<string, boolean>} mask - map of elements. Elements in the mask will be hidden
 * @property {Function} errorCallBack - it is called in response to warnings and errors
*/

/**
 * Returns default set of parameters
 * @returns {Parameters}
 */
function getDefaultParametersSet() {
    return {
        // initialization
        graphPlace: undefined, // Identifier of the root html element for binding graph
        mapRootHtml: undefined, // Identifier of the root html element for binding map or just root HTMLElement
        dataProvider: undefined,
        focusNode: undefined,

        // Elements
        elementSize: { width: 120, height: 120, minWidth: 45, maxWidth: 550, minHeight: 45, maxHeight: 550 }, // default element size
        overViewElementSize: { width: 120, height: 120, minWidth: 5, maxWidth: 550, minHeight: 5, maxHeight: 550 }, // default element size for the OverViewFrame

        // Layout
        layoutStep: { x: 200, y: 100 }, // Distance between elements of the graph
        layoutIterations: 32, // How much iterations will have been done during the layout algorithm
        offsetBetweenGroups: 150, // Additional offset between groups of nodes (viewFrame groups)

        // Color scheme
        colors: { // color map
            'edg:DatabaseColumn': '#23b0f4',
            'edg:SoftwareProgram': 'green',
            'http://edg.topbraid.solutions/model/SoftwareProgram': 'green',
            'http://edg.topbraid.solutions/model/Report': '#23b0f4',
            'http://edg.topbraid.solutions/model/ReportColumn': '#ff7410',

            'terminationText': 'white',
            'text': 'black',
            'unknown': 'black',
            'default': 'black',
            'selected': 'red',
            'blured': 'rgba(100, 100, 100, 0.3)',
            'terminationLink': '#9094a8',
            'aspectLink': 'rgba(0, 255, 0, 0.5)'
        },

        // Animation
        animation: true, // swithc off/on the animation
        maxFrameRate: 50,
        minFrameRate: 10,
        animationStep: 60,

        // View frames definition
        fullScreenMode: true, // Defines whether we want to open LG in full-screen-mode or in the regular mode
        viewFrames: [
            // {
            //     id: 'fullPanel', // identifier of the frame must be unique
            //     label: 'All',   // label in the right-top corner
            //     borderColor: '#23b0f4',
            //     backgroundColor: '#f4f4ff',
            //     // It tells how much space will takes this frame on the paper.
            //     // |[1][ 2 ][  3   ]| or
            //     // |[  50  ][  50  ]| or
            //     // |[10][10][10][10]|
            //     spaceShare: 1,
            // }
        ],

        // Images for types
        images: { // map of images for types of elements
            'edg:DatabaseColumn': 'src/resources/images/table.png',
            'edg:Table': 'src/resources/images/table.png',
            'edg:SoftwareProgram': 'src/resources/images/app.png',
            'http://edg.topbraid.solutions/model/SoftwareProgram': 'src/resources/images/app.png',
            'edg:LineageModel': 'src/resources/images/form.png',
            'edg:Schedule': 'src/resources/images/column.png',
            // 'link-options': 'src/resources/images/derivation-map.png',
            // 'feed-pipe': 'src/resources/images/feed-pipe.png',
            'unknown': 'src/resources/images/unknown.png' // It will work only for unknown types
        }, // if you want change it for lost images,
        // you should change it in the bottom of './jointViews/graphElements.js'

        resourcePath: '', // prefix for resources like images (optional)
        launchExternal: null, //optional
        usePOSTExecutor: false, // to make able use post requests for sparqlProvider

        // Be careful! If you want to change it, you should remember about css (.tq_lineage_ui e.t.c.)
        framePadding: { x: 55, y: 55 }, // viewPorts enabled area expanded by this value

        clipNodes: false, // tells us do or not clipping nodes by viewFrames.
        frameBorderWidth: 3, // styling

        showCollapsedFrames: false,

        defaultScale: { x: 1.0, y: 1.0 }, // It's necessary for calculations
        scaleBounds: { min: 0.7, max: 1.5 },
        overViewScaleBounds: { min: 0.01, max: 2 }, // scale bounds for overView frame
        scaleStep: 0.1, // step of scale changing

        terminationNodeSize: { width: 30, height: 30 }, // size of the termination nodes
        dataZoneSize: { width: 800, height: 600 }, // size of zones in data container. Zones are grouping and sorting in special areas to implement binary searching
        zonesInGroup: 4, // grouping data zones in bigger groups by groups of (for example) four
        linkRouting: 'metro', // links routing (based on jointjs routings: metro/normal/manhattan/orthogonal)

        linkStyles: {
            'default-link-style': _resourceProvider.DEFAULT_LINK_STYLE,
            'feedpipe': _resourceProvider.FEED_PIPE_LINK_STYLE,
            'tq-lg-group': _resourceProvider.DEFAULT_GROUP_LINK_STYLE
            // Example:
            // 'feedpipe': {
            //     cssClass: 'lineage-gram-feed-pipe-link',
            //     lineType: 'solid', // 'dashed'
            //     color: '#3c4260',
            //     toolButton: {
            //         image: 'src/resources/images/feed-pipe.png',
            //         width: 30,
            //         height: 30,
            //         alwaysVisible: true,
            //     },
            //     thickness: 3,
            //     hasArrow: true,
            // },
        },
        diagramType: undefined,
        graphOrientation: 'left-to-right', // Can be: 'left-to-right', 'right-to-left', 'top-to-bottom', 'bottom-to-top'
        layoutAlgorithm: 'sankey', // Can be: 'sankey', 'flow-directed'
        derivationMap: (0, _derivationMap2.getDefaultParametersSet)(),
        mask: undefined, // Map of elements. Elements in the mask will be hidden

        errorCallBack: undefined // It is called in response to warnings and errors
    };
}

/**
 * The main class of the library, that manage all views and data.
 * Creates two view on the initialization stage. The first view is a Lineage diagram view.
 * The second view is a Bird Eye view. Also the map can be placed on the page if the mapRootHtmlId
 * was specified in the passed parameters.
 * @class
 * @augments Subscribable
 * @param {Parameters} parameters - Parameters set
 *
 * @fires selected-element-changed
 * @fires history-state-changed
 * @fires focus-node-changed
 * @fires current-view-changed
 * @fires scale-value-changed
 * @fires diagram-state-changed
 * @fires view-frame-state-changed
 * @fires derivation-map-state-changed
 * @fires derivation-map-state-init
 */
function LineageGram(parameters) {
    var _this = this;

    // Events
    // ===================================================================
    // ===================================================================

    /**
     * Element selected event - fires when object changes element selection
     * Selected element is returned as a parameter of the event.
     * @event selected-element-changed
     * @type {Object}
     * @property {PublicNodeModel|PublicLinkModel|undefined} element - SelectedElement
    */

    /**
     * It fires when new element is selected as focusNode.
     * @event focus-node-changed
     * @type {Object}
     * @property {PublicNodeModel} element - FocusNode model
    */

    /**
     * View switched event - fires when current view is changed
     * View id is returned as a parameter of the event
     * @event current-view-changed
     * @type {Object}
     * @property {string} viewId - SelectedView can take the following values: 'lineageDiagram', 'birdEye' or 'none'
    */

    /**
     * Scale changed event - fires when scale value of the Lineage Diagram view is changed.
     * [New scale value]{@link Scale} is returned as a parameter of the event
     * @event scale-value-changed
     * @type {Object}
     * @property {Scale} scale - New scale object.
    */

    /**
     * State changed event - fires when LineageGram state is changed.
     * E.g. from a fetching state to a rendering state.
     * The state string identifier is returned as a parameter of the event
     * @event diagram-state-changed
     * @type {Object}
     * @property {string} state - Parameter can take the following values: 'fetching' | 'rendering' | 'completed' | 'error'
    */

    /**
     * It fires when user is navigating along the history.
     * @event history-state-changed
     * @type {Object}
     * @property {HistoryState[]} states - List of states
     * @property {number} currentIndex - order number of the current state in the list
    */

    /**
     * View frame state changed - fires when the View frame is being collapsed or expanded.
     * @event view-frame-state-changed
     * @type {Object}
     * @property {string} id - id of the changed ViewFrame
     * @property {boolean} value - true - expanded, false - collapsed
    */

    // Init
    // ===================================================================
    // ===================================================================
    _subscribeable2.default.apply(this); // make this class Subscribable

    var self = this; // Save pointer to a context

    var _state = 'initial';
    var _selectedElement = null;
    var _focusElement = void 0;
    var _currentView = 'lineageDiagram'; // Set the lineageDiagram view as a current view


    var defaultParameterSet = getDefaultParametersSet(); // Geting default parameters set
    // If the parameter set includes viewFrames definition, clear the viewFrames definition in the default set for a correct merging
    // (We don't want to get extra viewFrames from the default set.)
    if (parameters && parameters.viewFrames && parameters.viewFrames.length > 0) defaultParameterSet.viewFrames = undefined;
    // Merging default parameters set and custome parameters set
    var _parameters = _.merge(defaultParameterSet, parameters);

    var _errorCallback = function _errorCallback(e) {
        if (_parameters.errorCallback && _parameters.errorCallback instanceof Function) {
            var error = typeof e === 'string' ? new Error(e) : e;
            _parameters.errorCallback.call(_this, error);
        }
    };

    // If the graphPlace is undefined we stop the working process.
    if (!parameters.graphPlace) throw new Error('The graph place isn\'t specified');
    var graphPlaceHtml = void 0;
    if (typeof parameters.graphPlace === 'string') {
        graphPlaceHtml = document.getElementById(parameters.graphPlace);
    } else if (_typeof(parameters.graphPlace) === 'object') {
        graphPlaceHtml = parameters.graphPlace;
    } else {
        throw new Error('The graph place isn\'t specified or specided incorrectly');
    }
    // Creating html markup.
    var _base = _createBase(graphPlaceHtml);
    var _dataProvider = _parameters.dataProvider;
    var _stateStorage = new _stateStorage3.default(_parameters);
    var _progressScreen = new _visualizationsLibrary2.default.ProgressScreen({
        baseElement: _base.container
    });

    // Creating the data container.
    var _dataContainer = void 0;

    var _lineageDiagram = void 0; // Lineage diagram view
    var _birdEye = void 0; // BirdEye biew
    var _derivationMap = void 0;
    var _graphMap = void 0; // define variable
    var _derivationMapPanel = void 0;

    var _diagramType = _parameters.diagramType;

    self.launchExternal = _parameters.launchExternal;

    _createComponents();

    _fetchDiagram({
        focusNodeId: _parameters.focusNode,
        viewFrames: _parameters.viewFrames,
        lineageGramViewClass: _parameters.lineageGramViewClass,
        diagramType: _diagramType
    });

    // ===================================================================
    // ===================================================================

    /**
     * Recovers nodes positions to the initial.
     * @memberof LineageGram
     * @method
     */
    self.resetLayout = function () {
        if (_state !== 'completed') return;
        _lineageDiagram.resetLayout();
    };

    /**
     * @typedef {Object} Scale
     * @property {number} min - The minimum value
     * @property {number} max - The maximum value
     * @property {number} cur - The current value
    */

    /**
     * Changes scale of the main view by the step (defaul: ++0.1).
     * @returns {Scale}
     * @memberof LineageGram
     * @method
     */
    self.zoomIn = function () {
        if (_state === 'completed') {
            _lineageDiagram.zoomIn();
            if (_graphMap) _graphMap.redraw({ viewFrames: _lineageDiagram.getViewFrames() });
        }
        return {
            min: _parameters.scaleBounds.min,
            max: _parameters.scaleBounds.max,
            cur: _state === 'completed' ? _lineageDiagram.scale() : _parameters.defaultScale
        };
    };

    /**
     * Changes scale of the main view to be able to fit whole diagram in the screen.
     * @returns {Scale}
     * @memberof LineageGram
     * @method
     */
    self.zoomToFit = function () {
        if (_state === 'completed') {
            _zoomToFit();
        }
        return {
            min: _parameters.scaleBounds.min,
            max: _parameters.scaleBounds.max,
            cur: _state === 'completed' ? _lineageDiagram.scale() : _parameters.defaultScale
        };
    };

    /**
     * Returns current view id
     * @return {string} currentViewId -'lineageDiagram' | 'birdEye' | 'none'
     * @memberof LineageGram
     * @method
     */
    self.getCurrentView = function () {
        return _currentView;
    };

    /**
     * Returns current state
     * @returns {string} state - 'fetching' | 'active' | 'completed' | 'error'
     * @memberof LineageGram
     * @method
     */
    self.getState = function () {
        return _state;
    };

    /**
     * Changes scale of the main view by the step (defaul: --0.1).
     * @returns {Scale}
     * @memberof LineageGram
     * @method
     */
    self.zoomOut = function () {
        if (_state === 'completed') {
            _lineageDiagram.zoomOut();
            if (_graphMap) _graphMap.redraw({ viewFrames: _lineageDiagram.getViewFrames() });
        }
        return {
            min: _parameters.scaleBounds.min,
            max: _parameters.scaleBounds.max,
            cur: _state === 'completed' ? _lineageDiagram.scale() : _parameters.defaultScale
        };
    };

    /**
     * Changes scale of the main Lineage Diagram view.
     * @param {Point} scale
     * @returns {Scale}
     * @memberof LineageGram
     * @method
     */
    self.zoom = function zoom(scale) {
        if (_state === 'completed') {
            if (scale) {
                _lineageDiagram.scale(scale);
            }
            _lineageDiagram.redraw();
        }
        return {
            min: _parameters.scaleBounds.min,
            max: _parameters.scaleBounds.max,
            cur: _state === 'completed' ? _lineageDiagram.scale() : _parameters.defaultScale
        };
    };

    /**
     * Object which passed into the export function in LineageGram
     * @typedef {Object} ExportParams
     * @property {string} name - The file name
     * @property {string} type - (png/svg)
     * @property {string} view - BirdEye / lineageGram
    */

    /**
     * Exports the graph in a png or svg file.
     * @param {ExportParams} options
     * @memberof LineageGram
     * @method
    */
    self.export = function (options) {
        if (_state !== 'completed') return;

        if (!options) options = {};
        options.view = options.view || _currentView;
        if (options.view === 'lineageDiagram') {
            _lineageDiagram.export({
                name: options.name,
                type: options.type
            });
        } else if (options.view === 'birdEye') {
            _birdEye.export();
        }
    };

    /**
     * Shows print dialog.
     * @memberof LineageGram
     * @method
    */
    self.print = function () {
        if (_currentView === 'lineageDiagram') {
            _lineageDiagram.print();
        } else if (_currentView === 'birdEye') {
            _birdEye.print();
        }
    };

    /**
     * Expands all nodes
     * @memberof LineageGram
     * @method
    */
    self.expandAllNodes = function () {
        var nodes = _dataContainer.nodes;
        nodes.forEach(function (node) {
            node.set('expanded', true);
        });
        if (_currentView === 'lineageDiagram') {
            _lineageDiagram.refresh();
        }
    };

    /**
     * Collapses all nodes
     * @memberof LineageGram
     * @method
    */
    self.collapseAllNodes = function () {
        var nodes = _dataContainer.nodes;
        nodes.forEach(function (node) {
            node.set('expanded', false);
        });
        if (_currentView === 'lineageDiagram') {
            _lineageDiagram.refresh();
        }
    };

    /**
     * This function creates map, using html element with specified ID as a root element.
     * @param {string|HTMLElement} mapRootHtml - ID of root element or HTMLElement
     * @memberof LineageGram
     * @method
     */
    self.setRootHtmlForMap = function (mapRootHtml) {
        var mapHTMLElement = _getMapHTML(mapRootHtml);
        _parameters.mapRootHtml = mapRootHtml;
        _base.mapHTMLElement = mapHTMLElement;

        if (_state !== 'completed') return;

        _updateMap(_dataContainer, _lineageDiagram.getViewFrames());
    };

    /**
     * It changes layout algorithm for the graph.
     * @param {string} orientation - Values: 'sankey', 'flow-directed'
     * @memberof LineageGram
     * @method
     */
    self.setLayoutAlgorithm = function (algorithmId) {
        if (algorithmId === 'sankey' || algorithmId === 'flow-directed') {
            _parameters.layoutAlgorithm = algorithmId;

            var nodes = _dataContainer.nodes.map(function (n) {
                var model = n.model;
                delete model.defaultPosition;
                model.viewFrameOwnerId = null;
                return model;
            });
            var links = _dataContainer.links.map(function (l) {
                return {
                    id: l.model.id,
                    source: l.model.sourceType,
                    target: l.model.targetType
                };
            });

            var viewFrames = _lineageDiagram.getViewFrames();

            layout.doLayout(nodes, links, viewFrames, _parameters);
            _dataContainer.refresh();
            _lineageDiagram.refresh();
            _birdEye.refresh();
            if (_graphMap) _graphMap.redraw({
                viewFrames: _lineageDiagram.getViewFrames()
            });
        }
    };

    /**
     * Returns layout algorithm which is currently used for diagram.
     * @memberof LineageGram
     * @method
     * @returns {string} routing: metro/normal/manhattan
     */
    self.getLayoutAlgorithm = function () {
        return _parameters.layoutAlgorithm;
    };

    /**
     * It changes orientation of the graph
     * @param {string} orientation - Values: 'left-to-right', 'right-to-left', 'top-to-bottom', 'bottom-to-top'
     * @memberof LineageGram
     * @method
     */
    self.setOrientation = function (orientation) {
        if (_state !== 'completed') return;

        if (orientation && (orientation === 'left-to-right' || orientation === 'right-to-left' || orientation === 'top-to-bottom' || orientation === 'bottom-to-top')) {
            _parameters.graphOrientation = orientation;

            var nodes = _dataContainer.nodes.map(function (n) {
                var model = n.model;
                model.default_x = undefined;
                model.default_y = undefined;
                model.viewFrameOwnerId = null;
                n.setOrientation(orientation);
                return model;
            });
            var links = _dataContainer.links.map(function (link) {
                return {
                    id: link.model.id,
                    source: link.model.sourceType,
                    target: link.model.targetType
                };
            });

            var viewFrames = _lineageDiagram.getViewFrames();

            layout.doLayout(nodes, links, viewFrames, _parameters);
            _dataContainer.refresh();
            _lineageDiagram.setOrientation(orientation);
            _birdEye.refresh();
            if (_graphMap) _graphMap.refresh({
                viewFrames: _lineageDiagram.getViewFrames()
            });
        }
    };

    /**
     * It returns orientation of the graph
     * @memberof LineageGram
     * @method
     * @returns {string} oreintation - Values: 'left-to-right', 'right-to-left', 'top-to-bottom', 'bottom-to-top'
     */
    self.getOrientation = function () {
        return _parameters.graphOrientation;
    };

    /**
     * Refreshes LineageGram - refreshes all views and adjust size of the canvas.
     * @memberof LineageGram
     * @param {string} target - 'lineageDiagram' | 'birdEye' | 'graphMap'
     * @method
     */
    self.refresh = function (target) {
        if (_state !== 'completed') return;

        if (_currentView === 'lineageDiagram') {
            if (!target || target === 'lineageDiagram') _lineageDiagram.redraw();
        } else {
            if (!target || target === 'birdEye') _birdEye.refresh();
        }
        if (_graphMap && (!target || target === 'graphMap')) _graphMap.refresh({
            viewFrames: _lineageDiagram.getViewFrames()
        });
    };

    /**
     * ViewFrmaes public data
     * @typedef {Object} ViewFramePublicModel
     * @property {string} id - Identifier
     * @property {string} label - Text label
     * @property {string} borderColor - CSS border color
     * @property {string} backgroundColor - CSS bacground color
    */

    /**
     * Get ViewFrames states.
     * @returns {ViewFramePublicModel[]} states - key -> id, value -> true - expanded, false - collapsed
     * @memberof LineageGram
     * @method
     */
    self.getViewFrames = function () {
        if (_state !== 'completed') return [];

        return _lineageDiagram.getViewFrames();
    };

    /**
     * Returns one ViewFrame by id
     * @memberof LineageGram
     * @method
     * @param {string} viewFrameId
     * @returns {ViewFramePublicModel}
    */
    self.getViewFrameById = function (viewFrameId) {
        if (_state !== 'completed') return undefined;

        return _lineageDiagram.getViewFrameById(viewFrameId);
    };

    /**
     * Returns one ViewFrame by id
     * @memberof LineageGram
     * @method
     * @returns {ViewFramePublicModel}
    */
    self.getOverViewFrame = function () {
        if (_state !== 'completed') return undefined;

        return _lineageDiagram.getOverViewFrame();
    };

    /**
     * Collapse the ViewFrame with specified Id.
     * @param {string} viewFrameId - id of the target ViewFrame
     * @memberof LineageGram
     * @method
     */
    self.collapseViewFrame = function (viewFrameId) {
        if (_state !== 'completed') return;
        _lineageDiagram.closeViewFrame(viewFrameId);
    };

    /**
     * Expand ViewFrame with specified Id.
     * @param {string} viewFrameId - id of the target ViewFrame
     * @memberof LineageGram
     * @method
     */
    self.expandViewFrame = function (viewFrameId) {
        if (_state !== 'completed') return;
        _lineageDiagram.openViewFrame(viewFrameId);
    };

    /**
     * Collapses/Expands OverViewFrame.
     * @param {boolean} value
     * @memberof LineageGram
     * @method
    */
    self.setFullScreenMode = function (value) {
        if (_state !== 'completed') return;
        _lineageDiagram.setFullScreenMode(value);
    };

    /**
     * Collapses/Expands OverViewFrame.
     * @param {boolean} value
     * @memberof LineageGram
     * @method
    */
    self.isFullScreenMode = function () {
        if (_state !== 'completed') return _parameters.fullScreenMode;
        return _lineageDiagram.isFullScreenMode();
    };

    /**
     * Groups relative to selected node
     * nodes around  the selected node and highlight them.
     * @memberof LineageGram
     * @method
    */
    self.combine = function () {
        _lineageDiagram.combine();
    };

    /**
     * Finds elements by id(s) and sets it as selected.
     * @param {string|null} id1 - Selected element id or source element id of the link
     * @param {string} id2 - Target element id
     * @returns {Node|Link} - Selected element
     * @memberof LineageGram
     * @method
     */
    self.setSelectedElement = function (id1, id2) {
        if (id1 === undefined) return;

        if (id1 !== null) {
            var selectedElement = _getElementById(id1, id2);
            _setSelectedElement(selectedElement);
        } else {
            _setSelectedElement(null);
        }
    };

    /**
     * Rebuilds diagramm with new focus node
     * @param {string} focusNode - Focus node id
     * @memberof LineageGram
     * @method
     */
    self.setFocusNode = function (focusNodeId) {
        var focusNode = _getElementById(focusNodeId);

        if (!(focusNode instanceof graphElements.Node)) {
            console.error('Incorrect value of element');
            return;
        }

        _stateStorage.updateState(_getHistoryState());
        _setDiagramState('fetching');

        var focusResource = focusNode.model.resource;

        if (focusNode.model.hasOwnProperty('activeResource')) {
            focusResource = focusNode.model.activeResource;
        }

        _fetchDiagram({
            focusNodeId: focusResource,
            viewFrame: focusNode.model.viewFrame,
            offset: focusNode.model.hasOwnProperty('offset') ? focusNode.model.offset : null,
            diagramType: _diagramType
        });
    };

    /**
     * Returns to previous selected node (Restores previous diagram)
     * @memberof LineageGram
     * @method
     */
    self.undoState = function () {
        _stateStorage.updateState(_getHistoryState());
        var previousState = _stateStorage.undoState();
        if (previousState) _loadState(previousState);
    };

    /**
     * Returns to next selected node
     * (Node which had been selected before the state was restored)
     * @memberof LineageGram
     * @method
     */
    self.redoState = function () {
        _stateStorage.updateState(_getHistoryState());
        var nextState = _stateStorage.redoState();
        if (nextState) _loadState(nextState);
    };

    /**
     * Returns public model of selected element
     * @returns {PublicLinkModel|PublicNodeModel} selectedElement
     * @memberof LineageGram
     * @method
     */
    self.getSelectedElement = function () {
        return _getModel(_selectedElement);
    };

    /**
     * Returns public model of focus element.
     * Element which was used to build diagram around
     * @returns {PublicLinkModel|PublicNodeModel} focusElement
     * @memberof LineageGram
     * @method
     */
    self.getFocusElement = function () {
        return _getModel(_focusElement);
    };

    /**
    * Returns the current derivation map.
    * @returns {DerivationMap} derviationMap
    * @memberof lineageGram
    * @method
    */
    self.getDerivationMap = function () {
        if (_state === 'completed') {
            return _derivationMap;
        } else {
            return undefined;
        }
    };

    self.getNodes = function () {
        if (_state !== 'completed') return [];
        return _dataContainer.nodes.map(function (n) {
            return _getModel(n);
        });
    };

    self.getLinks = function () {
        if (_state !== 'completed') return [];
        return _dataContainer.links.map(function (l) {
            return _getModel(l);
        });
    };

    /**
     * Graphs public maps
     * @typedef {Object} PublicGraphMaps
     * @property {Object.<string, PublicNodeModel>} nodeMap
     * @property {Object.<string, PublicLinkModel>} linkMap
     * @property {Object.<string, PublicLinkModel>} sourceMap
     * @property {Object.<string, PublicLinkModel>} targetMap
    */

    /**
     * Graph model
     * @typedef {Object} PublicGraphModel
     * @property {PublicNodeModel[]} nodes
     * @property {PublicLinkModel[]} links
     * @property {PublicGraphMaps} maps
    */

    /**
     * Returns a data model of LineagGram.
     * @returns {PublicGraphModel}
     * @memberof LineageGram
     * @method
     */
    self.getGraphModel = function () {
        if (_state !== 'completed') return {};

        var graphModel = {
            nodes: _dataContainer.nodes.map(function (n) {
                return _getModel(n);
            }),
            links: _dataContainer.links.map(function (l) {
                return _getModel(l);
            }),
            maps: {
                nodeMap: {},
                linkMap: {},
                sourceMap: {},
                targetMap: {}
            }
        };

        graphModel.nodes.forEach(function (nodeModel) {
            graphModel.maps.nodeMap[nodeModel.id] = nodeModel;
        });
        graphModel.links.forEach(function (linkModel) {
            graphModel.maps.linkMap[linkModel.id] = linkModel;

            if (!graphModel.maps.sourceMap[linkModel.target]) {
                graphModel.maps.sourceMap[linkModel.target] = [];
            }
            if (!graphModel.maps.targetMap[linkModel.source]) {
                graphModel.maps.targetMap[linkModel.source] = [];
            }

            graphModel.maps.sourceMap[linkModel.target].push(linkModel);
            graphModel.maps.targetMap[linkModel.source].push(linkModel);
        });

        return graphModel;
    };

    /**
     * Sets current view. Method takes string identifier of the view as a parameter
     * @param {string} - viewId can be 'lineageDiagram' or 'birdEye' or 'none'
     * @memberof LineageGram
     * @method
     */
    self.setCurrentView = function (viewId) {
        if (viewId === 'lineageDiagram') {
            _showJointGraph();
        } else if (viewId === 'birdEye') {
            _showSigmaGraph();
        } else if (viewId === 'none') {
            _hideViews();
        }
    };
    self.setCurrentView(_currentView);

    /**
     * Sets links routing which is based
     * on jointjs routings: metro | normal | manhattan | orthogonal
     * @param {string} routingId - metro | normal | manhattan | orthogonal
     * @memberof LineageGram
     * @method
     */
    self.setRouting = function (routingId) {
        if (_state === 'completed') {
            _lineageDiagram.setRouting(routingId);
        }
    };

    /**
     * Returns routing which is currently applied for all links.
     * @memberof LineageGram
     * @method
     * @returns {string} routing: metro | normal | manhattan | orthogonal
     */
    self.getRouting = function () {
        if (_state === 'completed') {
            return _lineageDiagram.getRouting();
        } else {
            return parameters.linkRouting;
        }
    };

    /**
     * Sets value of the parameter which tells us wheter we should
     * trim nodes by the borders or not.
     * @memberof LineageGram
     * @param {boolean} clipping
     * @method
     */
    self.setClipping = function (clipping) {
        _parameters.clipNodes = clipping;
        if (_state === 'completed') {
            _lineageDiagram.redraw();
        }
    };

    /**
     * Returns value of the parameter which tells us wheter we
     * trim nodes by the borders or not.
     * @memberof LineageGram
     * @method
     * @returns {boolean} clipping
     */
    self.getClipping = function () {
        return _parameters.clipNodes;
    };

    self.setMask = function (publicMask) {
        var idMap = _dataContainer.maps.idMap;
        var mask = {};
        Object.keys(publicMask).forEach(function (id) {
            var diagramId = idMap[id];
            mask[diagramId] = publicMask[id];
        });
        _lineageDiagram.setMask(mask);
    };

    self.getMask = function () {
        var mask = _lineageDiagram.getMask();
        var nodeMap = _dataContainer.maps.nodeMap;
        var linkMap = _dataContainer.maps.linkMap;
        var publicMask = {};
        if (mask) {
            Object.keys(mask).forEach(function (key) {
                if (mask[key]) {
                    var element = _getModel(nodeMap[key] || linkMap[key]);
                    if (element) {
                        publicMask[element.id] = element;
                    }
                }
            });
        }
        return publicMask;
    };

    /**
     * Fetches diagram using passed options
     * @param {{
     *      focusNodeId: string,
     *      viewFrames: ViewFrameDefinition[],
     *      viewFrame: string
     *      lineageGramViewClass: string,
     *      diagramType: string,
     * }}
     * @memberof LineageGram
     * @method
     * @private
     */
    function _fetchDiagram(options) {
        var targetNodeId = options.focusNodeId;
        var viewFrame = options.viewFrame;
        var diagramType = options.diagramType;
        var offset = options.hasOwnProperty('offset') ? options.offset : null;

        // Switch the loading indicator in state 'fetching'
        // Request data through data provider
        _setDiagramState('fetching');
        if (!_dataProvider) {
            var errorMessage = 'Data provider is not specified!';
            var error = new Error(errorMessage);
            _setDiagramState('error', errorMessage);
            _errorCallback(error);
            throw error;
        }
        if (!_dataProvider.fetchData) {
            var _errorMessage = 'Data provider has incorrect interface! (There is no \'fetchData\' method)';
            var _error = new Error(_errorMessage);
            _setDiagramState('error', _errorMessage);
            _errorCallback(_error);
            throw _error;
        }

        var viewFramesPromise = options.viewFrames && options.viewFrames.length > 0 ? Promise.resolve({ frames: options.viewFrames }) : _dataProvider.getViewFrames(targetNodeId);
        var viewClassPromise = options.lineageGramViewClass ? Promise.resolve(options.lineageGramViewClass) : _dataProvider.getViewClassForResource(targetNodeId);

        return Promise.all([viewFramesPromise, viewClassPromise]).then(function (values) {
            var viewFrames = values[0].frames;
            var viewClass = values[1].dataProvider;

            return _dataProvider.fetchData({
                targetNodeId: targetNodeId,
                viewFrame: viewFrame,
                lineageGramViewClass: viewClass,
                diagramType: diagramType,
                offset: offset
            }).then(function (rawData) {
                _setDiagramState('rendering');

                (0, _dataUtils.checkLgRawData)(rawData);

                var dataContainer = _createDataContainer(rawData, viewFrames);
                var viewFrameDefinitions = filterViewFrameList(viewFrames, dataContainer);
                var publicViewFrameModels = viewFrameDefinitions.map(function (d) {
                    return (0, _dataUtils.defenitionToPublicModel)(d, _lineageDiagram.isFullScreenMode());
                });

                _updateComponents(dataContainer, publicViewFrameModels);

                _diagramType = rawData.diagramType;
                _dataContainer = dataContainer;
                _stateStorage.pushState(_getHistoryState());

                var focusNodeId = rawData.focusNode || (rawData.nodes[0] ? rawData.nodes[0].id : focusNodeId);
                var focusElement = _getElementById(focusNodeId);
                _focusElement = focusElement;

                _setSelectedElement(focusElement);
                _setDiagramState('completed');

                self.trigger('focus-node-changed', _getModel(focusElement));
                self.trigger('history-state-changed', _stateStorage.getHistory());
            });
        }).catch(function (e) {
            var error = typeof e === 'string' ? new Error(e) : e;

            _setDiagramState('error', error.message);
            _errorCallback(error);

            console.error(error.message);
            console.error(error.stack);
        });

        /**
         * Removes empty viewFrames
         * @private
         * @param {ViewFrameDefinition[]} viewFrames
         * @param {DataContainer} dataContainer
         * @returns {ViewFrame[]}
         */
        function filterViewFrameList(viewFrames, dataContainer) {
            var activeViewFrames = {};
            dataContainer.nodes.forEach(function (n) {
                activeViewFrames[n.model.viewFrame] = true;
            });
            var result = viewFrames.filter(function (vf) {
                return activeViewFrames[vf.id];
            });
            if (result.length > 0) {
                return result;
            } else {
                return [];
            }
        }
    }

    /**
     * @private
     * Finds elements by id(s).
     * @param {string} id1 - Selected element id or source element id of the link
     * @param {string} id2 - Target element id
     * @returns {Node|Link} - Selected element
    */
    function _getElementById(id1, id2) {
        if (!id2) {
            var elements = _dataContainer.nodes.concat(_dataContainer.links);
            for (var i = 0; i < elements.length; i++) {
                if (elements[i].model.resource === id1 || elements[i].model.id === id1) {
                    return elements[i];
                }
            }
        } else {
            var nodeMap = _dataContainer.maps.nodeMap;
            var links = _dataContainer.links;
            for (var _i = 0; _i < links.length; _i++) {
                var source = nodeMap[links[_i].model.source];
                var target = nodeMap[links[_i].model.target];
                if (source.resource === id1 && target.resource === id2 || source.resource === id2 && target.resource === id1 || source.id === id1 && target.id === id2 || source.id === id2 && target.id === id1) {
                    return links[_i];
                }
            }
        }
        return undefined;
    }

    /**
     * @private
     * Checks passed element and set it as a selected. Refreshes this value for the views.
     * @param {Node|Link} - Selected element
    */
    function _setSelectedElement(selectedElement) {
        // It shoudln't be undefined, but it can be null
        if (selectedElement === undefined) {
            throw Error('Incorrect value of selected element');
        }

        if (_graphMap) _graphMap.setSelectedElement(selectedElement);
        if (_currentView === 'lineageDiagram') _lineageDiagram.setSelectedElement(selectedElement, true);
        if (_currentView === 'birdEye') _birdEye.setSelectedElement(selectedElement);
    }

    /**
     * @private
     * Returns current state.
     * @returns {HistoryState} current state
    */
    function _getHistoryState() {
        var overViewFrame = _lineageDiagram.getOverViewFrame();
        return {
            nodes: _dataContainer.nodes,
            links: _dataContainer.links,
            focusElement: _focusElement,
            viewFrames: _lineageDiagram.getViewFrames().filter(function (vf) {
                return vf.id !== overViewFrame.id;
            }),
            selectedElement: _selectedElement
        };
    }

    /**
     * @private
     * Restores diagram using the passed state.
     * @param {HistoryState} state - target state
    */
    function _loadState(state) {
        try {
            _setDiagramState('rendering');
            setTimeout(function () {
                var dataContainer = new _dataContainer3.default({
                    nodes: state.nodes,
                    links: state.links
                }, _parameters);

                _updateComponents(dataContainer, state.viewFrames);

                _dataContainer = dataContainer;

                var elementToSelect = state.selectedElement === undefined ? state.focusElement : state.selectedElement;
                _focusElement = state.focusElement;

                _selectedElement = elementToSelect;
                _setSelectedElement(elementToSelect);
                _setDiagramState('completed');

                self.trigger('focus-node-changed', _getModel(state.focusElement));
                self.trigger('history-state-changed', _stateStorage.getHistory());
            }, 0);
        } catch (error) {
            _setDiagramState('error');
            if (typeof error === 'string') {
                console.error(error);
            } else {
                console.error(error.message);
                console.error(error.stack);
            }
        }
    }

    /**
     * @private
     * Changes scale of the main view to be able to fit whole diagram in the screen.
    */
    function _zoomToFit() {
        _lineageDiagram.zoomToFit();
        if (_graphMap) _graphMap.redraw({
            viewFrames: _lineageDiagram.getViewFrames(),
            scale: _lineageDiagram.scale()
        });
    }

    /**
     * @private
     * Creates dataContainer (diagram model) using passed raw data.
     * @param {ServerData} rawData - data
     * @param {ViewFrameDefinition[]} viewFrames - View frame defenitions
    */
    function _createDataContainer(rawData, viewFrames) {
        // if we don't get any data, we create an empty datat
        if (!rawData) rawData = { nodes: [], links: [] };
        if (!rawData.nodes) rawData.nodes = [];
        if (!rawData.links) rawData.links = [];

        // The function filters the data, sets authorities and collapses links.
        var data = (0, _dataProcessing.processData)(rawData);
        // Find and set place for each element of the data set
        layout.doLayout(data.nodes, data.links, viewFrames, _parameters);

        // This two lines create nodes and links from data models
        var jointNodes = (0, _dataUtils.createJointNodes)(data.nodes, _parameters);
        var jointLinks = (0, _dataUtils.createJointLinks)(data.links, jointNodes, _parameters);

        (0, _dataProcessing.createAspectRelations)(jointNodes);

        // Update data container by new nodes and links
        return new _dataContainer3.default({
            nodes: jointNodes,
            links: jointLinks
        }, _parameters);
    }

    /**
     * Initializes (or refreshes if not the first time)
     * the LineageGram - Creates (Refreshes) the main views.
     * @private
     */
    function _createComponents() {
        var emptyDataContainer = new _dataContainer3.default({
            nodes: [],
            links: []
        }, _parameters);
        var emptyList = [];
        // Creates the first view - LineageDiagram
        _createLineageDiagram(emptyDataContainer, emptyList);
        // Creates a sigma graph map on the private root.
        // _createMap(emptyDataContainer, emptyList);
        // Creates the second view - BirdEye (Historically - SigmaPathView)
        _createBirdEye(emptyDataContainer);
        _createDerivationMap(_dataProvider);

        _addHoverHandler();
    }

    /**
     * Updates (or refreshes if not the first time)
     * the LineageGram - Creates (Refreshes) the main views.
     * @private
     */
    function _updateComponents(dataContainer, viewFrames) {
        // Updates the first view - LineageDiagram
        _updateLineageDiagram(dataContainer, viewFrames);
        // Updates a sigma graph map on the private root.
        _updateMap(dataContainer, _lineageDiagram.getViewFrames());
        // Updates the second view - BirdEye (Historically - SigmaPathView)
        _updateBirdEye(dataContainer);

        _zoomToFit();
    }

    // Inner functions
    // ==============================================
    function _createLineageDiagram(dataContainer, viewFrames) {
        _lineageDiagram = new _lineageDiagram3.default({
            graphPlace: _base.lineageDiagram,
            dataContainer: dataContainer,
            viewFrames: viewFrames,
            fullScreenMode: _parameters.fullScreenMode
        }, _parameters);

        _lineageDiagram.on('selected-element-changed', function (eventObject) {
            if (_state !== 'completed') return;

            if (_currentView === 'lineageDiagram' && _state === 'completed') {
                if (_graphMap) _graphMap.setSelectedElement(eventObject);
                _selectedElement = (0, _dataUtils.getBaseElement)(eventObject);
                self.trigger('selected-element-changed', _getModel(_selectedElement));
            }
        });

        _lineageDiagram.on('scale-changed', function (newScale) {
            if (_state !== 'completed') return;

            if (_graphMap) _graphMap.redraw({
                viewFrames: _lineageDiagram.getViewFrames(),
                scale: newScale
            });
            self.trigger('scale-value-changed', {
                min: _parameters.scaleBounds.min,
                max: _parameters.scaleBounds.max,
                cur: _lineageDiagram.scale()
            });
        });

        _lineageDiagram.on('view-frames-state-changed', function (viewFrames) {
            if (_state !== 'completed') return;

            if (_graphMap) {
                _graphMap.redraw({ viewFrames: viewFrames });
            }
            self.trigger('view-frame-state-changed', viewFrames);
        });

        _lineageDiagram.on('view-frames-size-or-position-changed', function (viewFrames) {
            if (_state !== 'completed') return;

            if (_graphMap) {
                _graphMap.redraw({ viewFrames: viewFrames });
            }
        });

        _lineageDiagram.on('nodes-position-changed', function () {
            if (_state !== 'completed') return;

            if (_graphMap) {
                _graphMap.redraw();
            }
            _birdEye.redraw();
        });

        _lineageDiagram.on('cell-double-click', function (eventObject) {
            if (_state !== 'completed') return;

            if (_currentView === 'lineageDiagram') {
                if (eventObject instanceof graphElements.Link || eventObject instanceof graphElements.TerminationLink) {
                    _lineageDiagram.setSelectedElement(eventObject);
                    var link = eventObject.originalLink || eventObject;
                    _showDerivationMap(link);
                }
            }
        });

        _lineageDiagram.on('link-options-click', function (event) {
            if (_state !== 'completed') return;

            var link = event.link;
            var linkType = event.linkType;
            if (_currentView === 'lineageDiagram') {
                _showDerivationMap(link, linkType);
            }
        });
    }

    function _updateLineageDiagram(dataContainer, viewFrames) {
        _lineageDiagram.setData(dataContainer, viewFrames);
        _lineageDiagram.scale(_parameters.defaultScale);
    }

    function _addHoverHandler() {
        // Init the tooltip tool for termintation nodes.
        new joint.ui.Tooltip({
            rootTarget: document.body,
            target: '.termination-node',
            direction: 'auto',
            padding: 15,
            content: function content(cell) {
                return cell.getElementsByTagName('text')[0].attributes.tooltip.value;
            }
        });

        new joint.ui.Tooltip({
            rootTarget: document.body,
            target: '.tq-lg-short-label',
            direction: 'auto',
            padding: 15,
            content: function content(cell) {
                return cell.getElementsByTagName('text')[0].attributes.tooltip.value;
            }
        });
    }

    function _createDerivationMap(dataProvider) {
        _derivationMapPanel = new _visualizationsLibrary2.default.FlyingPanel({
            baseElement: _base.derivationMap,
            active: false,
            header: 'Derivation Map',
            emptyBody: false,
            size: { width: 'calc(100% - 200px)', height: 'calc(100% - 200px)' },
            position: { x: '100px', y: '100px' },
            body: '',
            resizable: true
        });

        _derivationMapPanel.on('size-changed', function () {
            return _derivationMap.resetFocus();
        });

        _derivationMap = new _derivationMap3.default({
            rootElement: _derivationMapPanel.rootHtml.querySelector('.tq-ui-body_container'),
            dataProvider: dataProvider
        }, _parameters.derivationMap);

        self.trigger('derivation-map-state-changed');
        self.trigger('derivation-map-state-init', _derivationMap);
    }

    function _createBirdEye(dataContainer) {
        _birdEye = new _birdEye3.default({
            el: _base.sigmaGraph,
            scale: _lineageDiagram.scale(),
            dataContainer: dataContainer
        }, _parameters);

        _birdEye.on('selected-element-changed', function (eventObject) {
            if (_state !== 'completed') return;

            if (_currentView === 'birdEye') {
                if (_graphMap) _graphMap.setSelectedElement(eventObject);
                _selectedElement = (0, _dataUtils.getBaseElement)(eventObject);
                self.trigger('selected-element-changed', _getModel(_selectedElement));
            }
        });

        _birdEye.on('cell-double-click', function (eventObject) {
            if (_state !== 'completed') return;

            if (_currentView === 'birdEye') {
                if (eventObject instanceof graphElements.Link || eventObject instanceof graphElements.TerminationLink) {
                    _birdEye.setSelectedElement(eventObject);
                    var links = eventObject.originalLink || eventObject;
                    _showDerivationMap(links);
                }
            }
        });
    }

    function _updateBirdEye(dataContainer) {
        _birdEye.setData(dataContainer);
    }

    /**
     * Creates the map If not created.
     * @private
     * @param {DataContainer} dataContainer
     * @param {ViewFramePublicModel[]} viewFrames
     * @returns {ViewFrame[]}
     */
    function _createMap(dataContainer, viewFrames) {
        if (_base.mapHTMLElement) {
            _graphMap = new _graphMap3.default({
                el: _base.mapHTMLElement,
                scale: _lineageDiagram.scale(),
                viewFrames: viewFrames,
                dataContainer: dataContainer
            }, _parameters);

            _graphMap.on('selected-element-changed', function (node) {
                if (_state !== 'completed') return;

                if (_currentView === 'lineageDiagram') {
                    var nodeIsInvisible = _lineageDiagram.getVisibleNodes().indexOf(node) === -1;
                    _lineageDiagram.setSelectedElement(node, nodeIsInvisible);
                }
                if (_currentView === 'birdEye') _birdEye.setSelectedElement(node);

                _selectedElement = (0, _dataUtils.getBaseElement)(node);
                self.trigger('selected-element-changed', _getModel(_selectedElement));
            });

            _graphMap.on('view-frames-position-changed', function (viewFrames) {
                if (_state !== 'completed') return;

                if (viewFrames.length === 0) return;
                var index = 0;

                recursion(viewFrames[index++]);

                function recursion(viewFrame) {
                    _lineageDiagram.positionViewPort(viewFrame, viewFrame.viewPortPosition, _parameters.animation, function () {
                        if (viewFrame[index]) {
                            recursion(viewFrames[index++]);
                        }
                    });
                }
            });
        }

        return _graphMap;
    }

    /**
     * Updates the map.
     * @private
     * @param {DataContainer} dataContainer
     * @param {ViewFramePublicModel[]} viewFrames
     * @returns {ViewFrame[]}
     */
    function _updateMap(dataContainer, viewFrames) {
        if (_graphMap) {
            _graphMap.setData(dataContainer, viewFrames);
        } else {
            _createMap(dataContainer, viewFrames);
        }
    }

    /**
     *
     * @param {Link|Node|TerminationLink|TerminationNode} element
     * @returns {PublicNodeModel|PublicLinkModel}
     */
    function _getModel(element) {
        if (!element) return;

        var elementModel = _.cloneDeep(element.model);
        elementModel.blured = Boolean(element.get('blured'));
        elementModel.highlighted = Boolean(element.get('highlighted'));

        if (element instanceof graphElements.Node) {
            elementModel.diagramType = 'node';
        } else if (element instanceof graphElements.Link) {
            elementModel.source = elementModel.sourceType;
            elementModel.target = elementModel.targetType;
            delete elementModel.sourceType;
            delete elementModel.targetType;
            elementModel.diagramType = 'link';
        }
        return elementModel;
    }

    /**
     * Opens derivation map window.
     * @param {Link} link
     * @param {string} linkType
     * @private
     */
    function _showDerivationMap(link, linkType) {
        if (link instanceof graphElements.Link) {
            var nodeMap = _dataContainer.maps.nodeMap;
            _derivationMap.openWithRelation({
                source: nodeMap[link.model.source].model,
                target: nodeMap[link.model.target].model,
                linkType: linkType
            });
            _derivationMapPanel.show();
        }
    }

    /**
     * Sets state of indicator
     * @private
     * @param {string} state - fetching | rendering | completed | error
     * @param {string} message - Custom message
     */
    function _setDiagramState(state, message) {
        _state = state;

        if (state === 'fetching') {
            _progressScreen.setState('active', message || 'Fetching data');
        } else if (state === 'rendering') {
            _progressScreen.setState('active', message || 'Rendering graph');
        } else if (state === 'completed') {
            _progressScreen.setState('completed');
        } else if (state === 'error') {
            _progressScreen.setState('error', message || 'Error has occurred!');
        }
        self.trigger('diagram-state-changed', state);
    }

    /**
     * Creates html markup.
     * @private
     * @param {HTMLElement} htmlNode - Root node for markup
     * @returns {Object.<string, HTMLElement>} - Map of html elements
     */
    function _createBase(htmlNode) {
        htmlNode.innerHTML = '';
        htmlNode.tabIndex = 1;

        var baseDiv = document.createElement('DIV');
        baseDiv.className = 'tq_lineage';
        baseDiv.id = 'tq_lineage';
        htmlNode.appendChild(baseDiv);

        var lineageDiagram = document.createElement('DIV');
        lineageDiagram.className = 'tq_lineage__graph';
        lineageDiagram.id = 'tq_lineage-graph';
        baseDiv.appendChild(lineageDiagram);

        var sigmaGraph = document.createElement('DIV');
        sigmaGraph.className = 'tq_lineage__sigma_graph';
        sigmaGraph.id = 'tq_lineage-sigma-graph';
        baseDiv.appendChild(sigmaGraph);

        var derivationMap = document.createElement('DIV');
        baseDiv.appendChild(derivationMap);

        return {
            container: htmlNode,
            baseDiv: baseDiv,
            lineageDiagram: lineageDiagram,
            sigmaGraph: sigmaGraph,
            derivationMap: derivationMap,
            mapHTMLElement: _getMapHTML(_parameters.mapRootHtml)
        };
    }

    /**
     * @private
     * Creates html markup for map.
     * @param {string|HTMLElement} mapRootHtml - ID of root element or HTMLElement
     * @returns {HTMLElement}
     */
    function _getMapHTML(mapRootHtml) {
        var mapRootHtmlHtml = void 0;
        if (typeof mapRootHtml === 'string') {
            mapRootHtmlHtml = document.getElementById(mapRootHtml);
        } else if ((typeof mapRootHtml === 'undefined' ? 'undefined' : _typeof(mapRootHtml)) === 'object') {
            mapRootHtmlHtml = mapRootHtml;
        } else {
            return {};
        }

        var mapHTMLElement = void 0;
        if (mapRootHtmlHtml) {
            // check element
            // Clear a content of the map root html element
            mapRootHtmlHtml.innerHTML = '';
            // Create a private root for map into the public root.
            // (User can change style of public root)
            mapHTMLElement = document.createElement('DIV');
            mapHTMLElement.className = 'tq-lg__map';
            mapRootHtmlHtml.appendChild(mapHTMLElement); // adding the private root into the public
        }
        return mapHTMLElement;
    }

    /**
     * @private
     * Makes the view-1 visible and the view-2 invisible.
     * @fires current-view-changed
     */
    function _showSigmaGraph() {
        _base.sigmaGraph.style.opacity = 1;
        _base.sigmaGraph.style.pointerEvents = 'auto';

        _base.lineageDiagram.style.opacity = 0;
        _base.lineageDiagram.style.pointerEvents = 'none';

        if (_state === 'completed') {
            if (_currentView !== 'none') {
                _birdEye.setSelectedElement(_lineageDiagram.getSelectedElement());
                _birdEye.refresh();
            } else {
                _lineageDiagram.resize();
                _birdEye.sigmaGraph.refresh();
            }
        }

        _currentView = 'birdEye';
        self.trigger('current-view-changed', _currentView);
    }

    /**
     * @private
     * Makes the view-2 visible and the view-1 invisible.
     * @fires current-view-changed
     */
    function _showJointGraph() {
        _base.sigmaGraph.style.opacity = 0;
        _base.sigmaGraph.style.pointerEvents = 'none';

        _base.lineageDiagram.style.opacity = 1;
        _base.lineageDiagram.style.pointerEvents = 'auto';

        if (_state === 'completed') {
            if (_currentView !== 'none') {
                if (_birdEye.selectedElement) {
                    var visibleNodes = _lineageDiagram.getVisibleNodes();
                    var isSelectedNode = _birdEye.selectedElement instanceof graphElements.Node;
                    var nodeIsInvisible = visibleNodes.indexOf(_birdEye.selectedElement) === -1;
                    var isSelectedLink = _birdEye.selectedElement instanceof graphElements.Link;
                    var allOfTheEndsIsInvisible = visibleNodes.indexOf(_dataContainer.maps.nodeMap[_birdEye.selectedElement.model.source]) === -1;
                    var focusOn = isSelectedNode && nodeIsInvisible || isSelectedLink && allOfTheEndsIsInvisible;

                    _lineageDiagram.setSelectedElement(_birdEye.selectedElement, focusOn);
                } else {
                    _lineageDiagram.redraw();
                }
            } else {
                _lineageDiagram.resize();
                _lineageDiagram.redraw();
            }
        }

        _currentView = 'lineageDiagram';
        self.trigger('current-view-changed', _currentView);
    }

    /**
     * @private
     * Makes the view-2 and the view-1 invisible.
     * @fires current-view-changed
     */
    function _hideViews() {
        // _base.container.className = 'tq_lineage_disable';
        _base.sigmaGraph.style.opacity = 0;
        _base.sigmaGraph.style.pointerEvents = 'none';
        _base.lineageDiagram.style.opacity = 0;
        _base.lineageDiagram.style.pointerEvents = 'none';

        _currentView = 'none';
        self.trigger('current-view-changed', _currentView);
    }
}
exports.default = LineageGram;

},{"./data/dataContainer":27,"./data/dataProcessing":28,"./data/resourceProvider":30,"./jointViews/derivationMap/derivationMap":41,"./jointViews/graphElements/elements":47,"./jointViews/lineageDiagram":52,"./layout/layout":57,"./sigmaViews/birdEye":61,"./sigmaViews/graphMap":62,"./stateStorage":65,"./subscriptionAPI/subscribeable":66,"./utils/dataUtils":67,"lodash":"lodash","rappid":"rappid","visualizations-library":5}],60:[function(require,module,exports){
'use strict';

var _lineageGram = require('./lineageGram');

var LineageGram = _interopRequireWildcard(_lineageGram);

var _defaultDataProvider = require('./data/defaultDataProvider');

var _defaultDataProvider2 = _interopRequireDefault(_defaultDataProvider);

var _infoPanel = require('./htmlUI/infoPanel');

var _infoPanel2 = _interopRequireDefault(_infoPanel);

var _optionsPanel = require('./htmlUI/optionsPanel');

var _optionsPanel2 = _interopRequireDefault(_optionsPanel);

var _map = require('./htmlUI/map');

var _map2 = _interopRequireDefault(_map);

var _defaultUI = require('./htmlUI/defaultUI');

var _defaultUI2 = _interopRequireDefault(_defaultUI);

var _derivationMap = require('./jointViews/derivationMap/derivationMap');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

require('es6-promise').Promise;
require('whatwg-fetch');

module.exports = {
    LineageGram: LineageGram.LineageGram,
    getDefaultParametersSet: LineageGram.getDefaultParametersSet,
    DefaultDataProvider: _defaultDataProvider2.default,
    DerivationMap: _derivationMap.DerivationMap,
    uiUtils: {
        DefaultUI: _defaultUI2.default,
        Map: _map2.default,
        InfoPanel: _infoPanel2.default,
        OptionsPanel: _optionsPanel2.default
    }
};

},{"./data/defaultDataProvider":29,"./htmlUI/defaultUI":31,"./htmlUI/infoPanel":34,"./htmlUI/map":35,"./htmlUI/optionsPanel":36,"./jointViews/derivationMap/derivationMap":41,"./lineageGram":59,"es6-promise":1,"whatwg-fetch":25}],61:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BirdEye = BirdEye;

var _sigmaBase = require('./sigmaBase');

var _sigmaBase2 = _interopRequireDefault(_sigmaBase);

var _elements = require('../jointViews/graphElements/elements');

var graphElements = _interopRequireWildcard(_elements);

var _lineageDiagramUtils = require('../utils/lineageDiagramUtils');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** 
 * @private
 * @class
 * Mini map in the right-bottom corner,
 * which shows the full graph with viewFrame's positions without links
 * @augments SigmaBase
*/
function BirdEye(options, parameters) {
    var self = this;
    var _colors = parameters.colors;
    var _path = null;

    _sigmaBase2.default.apply(self, [options, parameters]);

    var oldSetSelectedElement = self.setSelectedElement;
    self.setSelectedElement = function (element) {
        var selectedElement = void 0;
        if (element instanceof graphElements.Node || element instanceof graphElements.TerminationNode) {
            selectedElement = element.originalNode || element;
        } else if (element instanceof graphElements.Link) {
            var link = element.originalLink || element;
            selectedElement = link;
        } else {
            selectedElement = null;
        }

        if (self.selectedElement !== selectedElement) {
            if (selectedElement) {
                _path = (0, _lineageDiagramUtils.getPath)(selectedElement, self._dataContainer);
            } else {
                _path = null;
            }
        }
        oldSetSelectedElement.call(self, selectedElement);
    };

    self._refreshNodes = function () {
        var nodeMap = self._dataContainer.maps.nodeMap;

        self.sigmaGraph.graph.nodes().forEach(function (sigmaNode) {
            if (nodeMap[sigmaNode.id]) {
                var node = nodeMap[sigmaNode.id];
                var model = node.model;
                sigmaNode.x = model.position.x;
                sigmaNode.y = model.position.y;

                sigmaNode.color = self.selectedElement && (node.id === self.selectedElement.id || self.selectedElement.aspects && self.selectedElement.aspects.filter(function (a) {
                    return a.id === node.id;
                }).length > 0) ? _colors['selected'] : !_path || _path[node.id] ? _colors[model.typeId] : _colors['blured'];
            }
        });
    };

    self._refreshViewFrames = function () {};

    self._refreshLinks = function () {
        self.sigmaGraph.graph.edges().forEach(function (l) {
            l.size = self.selectedElement && l.id === self.selectedElement.id ? 5 : 1, l.color = !_path || _path[l.id] ? self.selectedElement && l.id === self.selectedElement.id ? _colors['selected'] : self._aspectLinks[l.id] ? _colors['aspectLink'] : _colors['link'] : _colors['blured'];
        });
    };

    self._initialize();
}

BirdEye.prototype = Object.create(_sigmaBase2.default.prototype);

exports.default = BirdEye;

},{"../jointViews/graphElements/elements":47,"../utils/lineageDiagramUtils":69,"./sigmaBase":63}],62:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.GraphMap = GraphMap;

var _sigmaBase = require('./sigmaBase');

var _sigmaBase2 = _interopRequireDefault(_sigmaBase);

var _elements = require('../jointViews/graphElements/elements');

var graphElements = _interopRequireWildcard(_elements);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** 
 * @private
 * @class
 * Mini map in the right-bottom corner,
 * which shows the full graph with viewFrame's positions without links
 * @augments SigmaBase
 * @fires view-frames-position-changed (params: ViewFramePublicModel[])
*/
function GraphMap(options, parameters) {
    var self = this;
    var _viewFramesMap = {};
    options.viewFrames.forEach(function (vf) {
        return _viewFramesMap[vf.id] = vf;
    });

    _sigmaBase2.default.apply(self, [options, parameters]);

    self._getData = function () {
        return { nodes: self._dataContainer.nodes, links: [] };
    };

    /**
     * Redefinition
     */
    var oldSetSelectedElement = self.setSelectedElement;
    self.setSelectedElement = function (element) {
        var selectedElement = void 0;
        if (element instanceof graphElements.Node || element instanceof graphElements.TerminationNode) {
            selectedElement = element.originalNode || element;
        } else if (element instanceof graphElements.Link) {
            var link = element.originalLink || element;
            selectedElement = link;
        } else {
            selectedElement = null;
        }

        var graph = self.sigmaGraph.graph;
        if (self.selectedElement instanceof graphElements.Link) {
            graph.dropEdge(self.selectedElement.id);
        }
        if (selectedElement instanceof graphElements.Link) {
            graph.addEdge(self._createLink(selectedElement));
        }
        oldSetSelectedElement.call(self, selectedElement);
    };

    var overrideRedraw = self.redraw;
    self.redraw = function (renderOptions) {
        overrideRedraw(renderOptions);
        renderOptions = renderOptions || {};
        if (renderOptions.viewFrames) renderOptions.viewFrames.forEach(function (vf) {
            return _viewFramesMap[vf.id] = vf;
        });
    };

    var overridedSetData = self.setData;
    self.setData = function (dataContainer, viewFrames) {
        overridedSetData(dataContainer, viewFrames);
        _viewFramesMap = {};
        viewFrames.forEach(function (vf) {
            return _viewFramesMap[vf.id] = vf;
        });
    };

    /**
     * Updates viewFrames state. 
     * @param {ViewFramePublicModel} viewFrames
     */
    var _oldImplementation = self._refreshViewFrames;
    self._refreshViewFrames = function (viewFrames) {
        _oldImplementation(viewFrames);
        viewFrames.forEach(function (vf) {
            return _viewFramesMap[vf.id] = vf;
        });
    };

    /**
     * Redefinition.
     */
    self._subscribeOnEvents = function () {
        self.sigmaGraph.bind('clickStage', function (e) {
            var globalClickPoint = _connvertPoint(e);
            var viewFrames = Object.keys(_viewFramesMap).map(function (key) {
                return _viewFramesMap[key];
            });
            for (var i = 0; i < viewFrames.length; i++) {
                var viewFrame = viewFrames[i];
                if (!viewFrame.active) continue;

                var bounds = {
                    minX: viewFrame.viewPortPositionBounds.minX,
                    minY: viewFrame.viewPortPositionBounds.minY,
                    maxX: viewFrame.viewPortPositionBounds.maxX + viewFrame.viewPortBounds.width,
                    maxY: viewFrame.viewPortPositionBounds.maxY + viewFrame.viewPortBounds.height
                };

                var pointHitsTheBounds = bounds.minX <= globalClickPoint.x && globalClickPoint.x <= bounds.maxX && bounds.minY <= globalClickPoint.y && globalClickPoint.y <= bounds.maxY;
                if (pointHitsTheBounds) {
                    var viewFrameOptions = {
                        id: viewFrame.id,
                        viewPortPosition: {
                            x: globalClickPoint.x - viewFrame.size.width / 2,
                            y: globalClickPoint.y - viewFrame.size.height / 2
                        }
                    };
                    self.trigger('view-frames-position-changed', [[viewFrameOptions]]);
                }
            }
        });

        self.sigmaGraph.bind('clickNode', function (evt) {
            var node = evt.data.node ? self._dataContainer.maps.nodeMap[evt.data.node.id] : null;
            self.setSelectedElement(node);
            self.trigger('selected-element-changed', node);
        });

        self.sigmaGraph.bind('clickEdge', function (evt) {
            var link = evt.data.edge ? self._dataContainer.maps.linkMap[evt.data.edge.id] : null;
            self.setSelectedElement(link);
            self.trigger('selected-element-changed', link);
        });
    };

    /** 
     * Calculates sigma paper point to joint paper point.
     * @param {
     *  data: {
     *      cptor: {
     *          clientX,
     *          clientY
     *      }
     *  }
     * } event
    */
    function _connvertPoint(event) {
        var renderer = self.sigmaGraph.renderers[0];
        var _prefix = renderer.options.prefix;
        return executeNodeMouseMove();

        function executeNodeMouseMove() {
            var offset = _calculateOffset(renderer.container),
                x = event.data.captor.clientX - offset.left,
                y = event.data.captor.clientY - offset.top,
                cos = Math.cos(self.sigmaGraph.camera.angle),
                sin = Math.sin(self.sigmaGraph.camera.angle),
                nodes = self.sigmaGraph.graph.nodes(),
                ref = [];

            // Getting and derotating the reference coordinates.
            for (var i = 0; i < 2; i++) {
                var n = nodes[i];
                var aux = {
                    x: n.x * cos + n.y * sin,
                    y: n.y * cos - n.x * sin,
                    renX: n[_prefix + 'x'],
                    renY: n[_prefix + 'y']
                };
                ref.push(aux);
            }

            // Applying linear interpolation.
            // if the nodes are on top of each other, we use the camera ratio to interpolate
            if (ref[0].x === ref[1].x && ref[0].y === ref[1].y) {
                var xRatio = ref[0].renX === 0 ? 1 : ref[0].renX;
                var yRatio = ref[0].renY === 0 ? 1 : ref[0].renY;
                x = ref[0].x / xRatio * (x - ref[0].renX) + ref[0].x;
                y = ref[0].y / yRatio * (y - ref[0].renY) + ref[0].y;
            } else {
                xRatio = (ref[1].renX - ref[0].renX) / (ref[1].x - ref[0].x);
                yRatio = (ref[1].renY - ref[0].renY) / (ref[1].y - ref[0].y);

                // if the coordinates are the same, we use the other ratio to interpolate
                if (ref[1].x === ref[0].x) {
                    xRatio = yRatio;
                }

                if (ref[1].y === ref[0].y) {
                    yRatio = xRatio;
                }

                x = (x - ref[0].renX) / xRatio + ref[0].x;
                y = (y - ref[0].renY) / yRatio + ref[0].y;
            }

            return { x: x * cos - y * sin, y: y * cos + x * sin };
        }
    }

    // Calculates the global offset of the given element more accurately than
    // element.offsetTop and element.offsetLeft.
    function _calculateOffset(element) {
        var style = window.getComputedStyle(element);
        var getCssProperty = function getCssProperty(prop) {
            return parseInt(style.getPropertyValue(prop).replace('px', '')) || 0;
        };
        return {
            left: element.getBoundingClientRect().left + getCssProperty('padding-left'),
            top: element.getBoundingClientRect().top + getCssProperty('padding-top')
        };
    }

    self._initialize();
}
GraphMap.prototype = Object.create(_sigmaBase2.default.prototype);

exports.default = GraphMap;

},{"../jointViews/graphElements/elements":47,"./sigmaBase":63}],63:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SigmaBase = SigmaBase;

var _sigma = require('sigma');

var _sigma2 = _interopRequireDefault(_sigma);

var _sigmaRenderers = require('./sigmaPlagins/sigma.renderers.snapshot/sigma.renderers.snapshot');

var SigmaSnapshotPlugin = _interopRequireWildcard(_sigmaRenderers);

var _subscribeable = require('../subscriptionAPI/subscribeable');

var _subscribeable2 = _interopRequireDefault(_subscribeable);

var _elements = require('../jointViews/graphElements/elements');

var graphElements = _interopRequireWildcard(_elements);

var _fileSaverjs = require('file-saverjs');

var _fileSaverjs2 = _interopRequireDefault(_fileSaverjs);

var _dataUtils = require('../utils/dataUtils');

var _utils = require('../utils/utils');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

SigmaSnapshotPlugin.usePlugin(_sigma2.default);

/** 
 * @private
 * @class
 * It's the base class for sigma views.
 * 
 * Constructor parameters:
 * ========================================
 * @param {
 *  dataContainer: DataContainer
 *  viewFrames: ViewFramePublicModel[]
 *  el: HTMLElement
 *  selectedElement: Node|Link
 *  scale:number
 * } options
 * @param {Parameters} parameters - parameters set
 * 
 * Public properties:
 * ========================================
 * selectedElement: Node|Link
 * 
 * Public methods:
 * ========================================
 * setSelectedElement: (element: Node|Link) => void
 * setData: (dataContainer: DataContainer, viewFrames: ViewFrame[]) => void
 * setScale: (scale: number) => void
 * refresh: () => void
 * export: (name?: string) => void
 * print: () => void
 * redraw: () => void
 * ----------------------------------------
 * on (event: string, callback: function): void
 * unsubscribe (callback: function): void
 * trigger (event: string, parameters: any): void
 * 
 * Events:
 * ========================================
 * @fires selected-element-changed (params: Node|Link)
 * @fires cell-double-click (params: Node|Link)
*/
function SigmaBase(options, parameters) {

    _subscribeable2.default.apply(this); // make this class Subscribable

    var self = this;
    var _colors = parameters.colors;

    var _maxNodeSize = 0;
    var _rootElement = void 0;
    var _sigmaFrames = {};

    self._aspectLinks = {};
    self.selectedElement;
    self._dataContainer; // to override


    /**
     * Runs initialization. It's executed after creation by descendant
     */
    self._initialize = function () {
        _initialize(options.dataContainer, options.viewFrames, options.el, options.selectedElement, options.scale);
    };

    /**
     * It's kind of constructor, which called after creation the object.
     * @param {DataContainer} dataContainer
     * @param {Array of ViewFrame} viewFrames
     * @param {HTMLElement} rootElement
     * @param {Node|Link} selectedElement
     * @param {number} scale
    */
    function _initialize(dataContainer, viewFrames, rootElement, selectedElement) {
        _rootElement = rootElement;
        self.selectedElement = selectedElement;
        viewFrames = viewFrames || [];
        self._dataContainer = dataContainer;

        var data = self._getData();
        var g = {
            nodes: [],
            edges: []
        };

        data.nodes.forEach(function (node) {
            var newNode = self._createNode(node);
            g.nodes.push(newNode);
        });

        data.links.forEach(function (link) {
            var newLink = self._createLink(link);
            g.edges.push(newLink);
        });

        var aspectLinks = _createAspectLinks(data.nodes);
        aspectLinks.forEach(function (al) {
            g.edges.push(al);
        });

        _maxNodeSize = _getNodeSize();

        self.sigmaGraph = new _sigma2.default({
            graph: g,
            container: _rootElement,
            settings: {
                minNodeSize: 0,
                maxNodeSize: _maxNodeSize,
                nodesPowRatio: 1,
                enableEdgeHovering: true,
                edgeHoverColor: 'edge',
                defaultEdgeHoverColor: '#000',
                edgeHoverSizeRatio: 4,
                edgeHoverExtremities: true,
                autoResize: false,
                clone: false,
                doubleClickZoomingRatio: 1
            }
        });
        self._subscribeOnEvents();
        _maxNodeSize = _getNodeSize();
        self.sigmaGraph.settings('maxNodeSize', _maxNodeSize);

        viewFrames.forEach(function (viewFrame) {
            if (viewFrame.active) {
                _addViewFrame(viewFrame);
            } else {
                _sigmaFrames[viewFrame.id] = _createSigmaFrame(viewFrame);
            }
        });

        self.sigmaGraph.refresh();
    }

    /**
     * Exports graph to png file
     * @param {string} diagramName
    */
    self.export = function (diagramName) {
        var fileName = diagramName || 'LG_bird_eye_snapshot_' + (0, _dataUtils.date2String)(new Date());
        var data = self.sigmaGraph.renderers[0].snapshot({
            format: 'png',
            download: false,
            background: 'transparent',
            labels: true,
            filename: fileName
        });

        (0, _fileSaverjs2.default)((0, _dataUtils.png2Blob)(data), fileName + '.png');
    };

    /**
     * Exports graph to pdf file
     * @param {string} diagramName
    */
    self.print = function (diagramName) {
        var fileName = diagramName || 'LG_bird_eye_snapshot_' + (0, _dataUtils.date2String)(new Date());
        var data = self.sigmaGraph.renderers[0].snapshot({
            format: 'png',
            download: false,
            background: 'transparent',
            labels: true,
            filename: fileName
        });
        var printWindow = window.open('', undefined, 'width=1280,height=720');
        if (printWindow) {
            printWindow.document.write('\n                <html>\n                    <body>\n                        <img src="' + data + '"/>\n                    </body>\n                </html>\n            ');
            printWindow.document.querySelector('img').onload = function () {
                printWindow.document.close();
                printWindow.print();
            };
        } else {
            alert('You should unblock popup windows for the current url to be able to print this diagram!');
        }
    };

    /**
     * Sets selected element.
     * @param {Node|Link} element
    */
    self.setSelectedElement = function (element) {
        var selectedElement = void 0;
        if (element instanceof graphElements.Node || element instanceof graphElements.TerminationNode) {
            selectedElement = element.originalNode || element;
        } else if (element instanceof graphElements.Link) {
            var link = element.originalLink || element;
            selectedElement = link;
        } else {
            selectedElement = null;
        }

        var refresh = self.selectedElement !== selectedElement;
        self.selectedElement = selectedElement;
        if (refresh) self.redraw();
    };

    /**
     * Sets new data container
     * @param {DataContainer} dataContainer
     * @param {ViewFramePublicModel[]} viewFrames
    */
    self.setData = function (dataContainer, viewFrames) {
        self.selectedElement = null;
        self._dataContainer = dataContainer;
        viewFrames = viewFrames || [];

        var data = self._getData();

        self.sigmaGraph.graph.clear();
        _maxNodeSize = _getNodeSize();
        self.sigmaGraph.settings('maxNodeSize', _maxNodeSize);

        data.nodes.forEach(function (node) {
            var newNode = self._createNode(node);
            self.sigmaGraph.graph.addNode(newNode);
        });

        viewFrames.forEach(function (viewFrame) {
            var frame = _createSigmaFrame(viewFrame);
            _sigmaFrames[viewFrame.id] = frame;
            if (viewFrame.active) {
                _addViewFrame(viewFrame);
            } else {
                _sigmaFrames[viewFrame.id] = _createSigmaFrame(viewFrame);
            }
        });

        var aspectLinks = _createAspectLinks(data.nodes);
        aspectLinks.forEach(function (al) {
            self.sigmaGraph.graph.addEdge(al);
        });

        data.links.forEach(function (link) {
            var newLink = self._createLink(link);
            self.sigmaGraph.graph.addEdge(newLink);
        });

        self.sigmaGraph.refresh();
        self.redraw();
    };

    var debouncer = void 0;
    /**
     * Redraws all graph. Mainly - updates colors of elements
     * @param {viewFrames, scale, nodes, fullScreenMode} options
     */
    self.redraw = function (options) {
        options = options || {};

        _maxNodeSize = _getNodeSize();
        self.sigmaGraph.settings('maxNodeSize', _maxNodeSize);

        cancelAnimationFrame(debouncer);
        debouncer = requestAnimationFrame(function () {
            self._refreshNodes();
            self._refreshLinks();

            if (options.viewFrames) {
                self._refreshViewFrames(options.viewFrames);
            }

            self.sigmaGraph.refresh();
        });
    };

    // can be overrided
    self.refresh = function () {
        self.redraw();
    };

    /**
     * Updates links states. 
     */
    self._refreshLinks = function () {
        var edges = self.sigmaGraph.graph.edges();
        edges.forEach(function (l) {
            if (l.id.indexOf('__top') === -1 && l.id.indexOf('__bottom') === -1 && l.id.indexOf('__left') === -1 && l.id.indexOf('__right') === -1) {
                l.size = self.selectedElement && l.id === self.selectedElement.id ? 5 : 1, l.color = self.selectedElement && l.id === self.selectedElement.id ? _colors['selected'] : self._aspectLinks[l.id] ? _colors['aspectLink'] : _colors['link'];
            }
        });
    };

    /**
     * Updates nodes states. 
     */
    self._refreshNodes = function () {
        var nodeMap = self._dataContainer.maps.nodeMap;
        var nodes = self.sigmaGraph.graph.nodes();
        nodes.forEach(function (sigmaNode) {
            if (nodeMap[sigmaNode.id]) {
                var node = nodeMap[sigmaNode.id];
                var position = (0, _utils.getGlobalNodePosition)(node);
                sigmaNode.x = position.x;
                sigmaNode.y = position.y;
                sigmaNode.color = self.selectedElement && (self.selectedElement.id === sigmaNode.id || self.selectedElement.aspects && self.selectedElement.aspects.filter(function (a) {
                    return a.id === sigmaNode.id;
                }).length > 0) ? _colors['selected'] : _colors[node.model.typeId];
            }
        });
    };

    /**
     * Updates viewFrames state. 
     * @param {ViewFramePublicModel[]} viewFrames
     */
    self._refreshViewFrames = function (viewFrames) {
        viewFrames.forEach(function (viewFrame) {
            if (viewFrame.active) {
                var frame = _sigmaFrames[viewFrame.id];
                var points = _getFramesPoints(viewFrame);

                frame.p1.x = points.p1.x;
                frame.p1.y = points.p1.y;

                frame.p2.x = points.p2.x;
                frame.p2.y = points.p2.y;

                frame.p3.x = points.p3.x;
                frame.p3.y = points.p3.y;

                frame.p4.x = points.p4.x;
                frame.p4.y = points.p4.y;

                _addViewFrame(viewFrame);
            } else {
                _removeViewFrame(viewFrame);
            }
        });
    };

    /**
     * Adds viewFrame on the sigma graph.
     * @param {ViewFramePublicModel} viewFrame
     */
    function _addViewFrame(viewFrame) {
        var frame = _sigmaFrames[viewFrame.id] = _sigmaFrames[viewFrame.id] || _createSigmaFrame(viewFrame);
        if (!viewFrame || frame.active) return;

        self.sigmaGraph.graph.addNode(frame.p1);
        self.sigmaGraph.graph.addNode(frame.p2);
        self.sigmaGraph.graph.addNode(frame.p3);
        self.sigmaGraph.graph.addNode(frame.p4);

        self.sigmaGraph.graph.addEdge(frame.top);
        self.sigmaGraph.graph.addEdge(frame.bottom);
        self.sigmaGraph.graph.addEdge(frame.left);
        self.sigmaGraph.graph.addEdge(frame.right);

        frame.active = true;
    }

    /**
     * Removes viewFrame from the sigma graph.
     * @param {ViewFramePublicModel} viewFrame
     */
    function _removeViewFrame(viewFrame) {
        if (!viewFrame || !_sigmaFrames[viewFrame.id].active) return;

        self.sigmaGraph.graph.dropEdge(viewFrame.id + '__top');
        self.sigmaGraph.graph.dropEdge(viewFrame.id + '__bottom');
        self.sigmaGraph.graph.dropEdge(viewFrame.id + '__left');
        self.sigmaGraph.graph.dropEdge(viewFrame.id + '__right');

        self.sigmaGraph.graph.dropNode(viewFrame.id + '__TL');
        self.sigmaGraph.graph.dropNode(viewFrame.id + '__BL');
        self.sigmaGraph.graph.dropNode(viewFrame.id + '__TR');
        self.sigmaGraph.graph.dropNode(viewFrame.id + '__BR');

        _sigmaFrames[viewFrame.id].active = false;
    }

    /**
     * Returns links and nodes.
     * @returns {{Node[], Link[]}}
     */
    self._getData = function () {
        return { nodes: self._dataContainer.nodes, links: self._dataContainer.links };
    };

    /**
     * Creates sigma node from jointjs node.
     * @param {Node} node 
     */
    self._createNode = function (node) {
        var position = (0, _utils.getGlobalNodePosition)(node);
        var model = node.model;
        return {
            id: node.id,
            label: model.label,
            x: position.x,
            y: position.y,
            size: 1,
            color: node === self.selectedElement || self.selectedElement && self.selectedElement.aspects && self.selectedElement.aspects.filter(function (a) {
                return a.id === node.id;
            }).length > 0 ? _colors['selected'] : _colors[model.typeId]
        };
    };

    /**
     * Creates sigma edge from jointjs link.
     * @param {Link} link 
     */
    self._createLink = function (link) {
        return {
            id: link.id,
            source: link.model.source,
            target: link.model.target,
            size: link === self.selectedElement ? 5 : 1,
            color: link === self.selectedElement ? _colors['selected'] : 'black'
        };
    };

    /**
     * Subscribes on events.
     * @fires: selected-element-changed (params: Node|Link)
     * @fires: cell-double-click (params: Node|Link)
     */
    self._subscribeOnEvents = function () {
        self.sigmaGraph.bind('clickNode clickStage', function (e) {
            return _onClick(e, function (event) {
                var node = event.data.node ? self._dataContainer.maps.nodeMap[event.data.node.id] : null;
                if (node || !event.data.captor.isDragging && !node) {
                    self.setSelectedElement(node);
                    self.trigger('selected-element-changed', node);
                }
            }, function (event) {
                var element = event.data.edge ? self._dataContainer.maps.linkMap[event.data.edge.id] : null;
                self.trigger('cell-double-click', element);
            });
        });

        self.sigmaGraph.bind('clickEdge', function (e) {
            return _onClick(e, function (event) {
                var link = event.data.edge ? self._dataContainer.maps.linkMap[event.data.edge.id] : null;
                self.setSelectedElement(link);
                self.trigger('selected-element-changed', link);
            }, function (event) {
                var element = event.data.edge ? self._dataContainer.maps.linkMap[event.data.edge.id] : null;
                self.trigger('cell-double-click', element);
            });
        });
    };

    /**
     * Returns default size for nodes. 
     */
    function _getNodeSize() {
        var result = void 0;
        if (self._dataContainer.nodes.length <= 0) return 0;
        if (self.sigmaGraph) {
            var renderer = self.sigmaGraph.renderers[0] || { width: _rootElement.clientWidth, height: _rootElement.clientHeight };
            if (parameters.elementSize.width > parameters.elementSize.height) {
                result = renderer.width / (parameters.elementSize.width + parameters.layoutStep.x);
            } else {
                result = renderer.height / (parameters.elementSize.height + parameters.layoutStep.y);
            }
        } else {
            result = 5;
        }
        if (self._getNodeSize) return self._getNodeSize(result);else return result;
    }

    /**
     * Creates aspect links.
     * @param {Node[]} nodes
     */
    function _createAspectLinks(nodes) {
        self._aspectLinks = {};
        var linksToReturn = [];
        nodes.forEach(function (node) {
            var aspects = node.aspects;

            aspects.forEach(function (aspect) {
                addLink(node, aspect);
            });
        });

        function addLink(node, aspect) {
            var id1 = node.id + '~#tqLgAspectLink#~' + aspect.id;
            var id2 = aspect.id + '~#tqLgAspectLink#~' + node.id;

            if (!self._aspectLinks[id1] && !self._aspectLinks[id2]) {
                var al = {
                    id: id1,
                    source: node.id,
                    target: aspect.id,
                    color: _colors['aspectLink']
                };
                self._aspectLinks[id1] = al;
                linksToReturn.push(al);
            }
        }

        return linksToReturn;
    }

    /**
     * Creates sigma notation of the joint viewFrame and places on the sigma graph.
     * @param {ViewFramePublicModel} viewFrame
     */
    function _createSigmaFrame(viewFrame) {
        var points = _getFramesPoints(viewFrame);
        var color = viewFrame.borderColor;

        // nodes

        var p1 = {
            id: viewFrame.id + '__TL',
            label: viewFrame.id,
            x: points.p1.x,
            y: points.p1.y,
            size: 0.3,
            color: color
        };

        var p2 = {
            id: viewFrame.id + '__BL',
            label: viewFrame.id,
            x: points.p3.x,
            y: points.p3.y,
            size: 0.3,
            color: color
        };

        var p3 = {
            id: viewFrame.id + '__TR',
            label: viewFrame.id,
            x: points.p2.x,
            y: points.p2.y,
            size: 0.3,
            color: color
        };

        var p4 = {
            id: viewFrame.id + '__BR',
            label: viewFrame.id,
            x: points.p4.x,
            y: points.p4.y,
            size: 0.3,
            color: color
        };

        // Edges

        var top = {
            id: viewFrame.id + '__top',
            source: viewFrame.id + '__TL',
            target: viewFrame.id + '__TR',
            size: 10,
            color: color
        };

        var bottom = {
            id: viewFrame.id + '__bottom',
            source: viewFrame.id + '__BL',
            target: viewFrame.id + '__BR',
            size: 10,
            color: color
        };

        var left = {
            id: viewFrame.id + '__left',
            source: viewFrame.id + '__TL',
            target: viewFrame.id + '__BL',
            size: 10,
            color: color
        };

        var right = {
            id: viewFrame.id + '__right',
            source: viewFrame.id + '__TR',
            target: viewFrame.id + '__BR',
            size: 10,
            color: color
        };

        return {
            p1: p1,
            p2: p2,
            p3: p3,
            p4: p4,

            top: top,
            bottom: bottom,
            left: left,
            right: right,

            active: false
        };
    }

    function _getFramesPoints(viewFrame) {
        var p1 = {
            x: viewFrame.viewPortBounds.minX,
            y: viewFrame.viewPortBounds.minY
        };
        var p2 = { x: p1.x + viewFrame.viewPortBounds.width, y: p1.y };
        var p3 = { x: p1.x, y: p1.y + viewFrame.viewPortBounds.height };
        var p4 = { x: p1.x + viewFrame.viewPortBounds.width, y: p1.y + viewFrame.viewPortBounds.height };

        return {
            p1: p1,
            p2: p2,
            p3: p3,
            p4: p4
        };
    }

    // Fixing the sigma bug with horizontal/vertical lines hovering.
    // ========================================================================
    _sigma2.default.utils.isPointOnSegment = function (x, y, x1, y1, x2, y2, epsilon) {
        // http://stackoverflow.com/a/328122
        var crossProduct = Math.abs((y - y1) * (x2 - x1) - (x - x1) * (y2 - y1)),
            d = _sigma2.default.utils.getDistance(x1, y1, x2, y2),
            nCrossProduct = crossProduct / d; // normalized cross product

        return nCrossProduct < epsilon && Math.min(x1, x2) - epsilon <= x && x <= Math.max(x1, x2) + epsilon && Math.min(y1, y2) - epsilon <= y && y <= Math.max(y1, y2) + epsilon;
    };

    var _clicks = 0;
    function _onClick(event, clickCallback, doubleClickCallback) {
        _clicks++;

        if (_clicks >= 2) {
            _clicks = 0;
            doubleClickCallback(event);
        } else if (_clicks === 1) {
            setTimeout(function () {
                if (_clicks === 1) {
                    clickCallback(event);
                }
                _clicks = 0;
            }, 250);
        }
    }
}
exports.default = SigmaBase;

},{"../jointViews/graphElements/elements":47,"../subscriptionAPI/subscribeable":66,"../utils/dataUtils":67,"../utils/utils":70,"./sigmaPlagins/sigma.renderers.snapshot/sigma.renderers.snapshot":64,"file-saverjs":2,"sigma":4}],64:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.usePlugin = usePlugin;
function usePlugin(sigma) {

    /**
     * Sigma Renderer Snapshot Utility
     * ================================
     *
     * The aim of this plugin is to enable users to retrieve a static image
     * of the graph being rendered.
     *
     * Author: Guillaume Plique (Yomguithereal)
     * Version: 0.0.1
     */

    // Terminating if sigma were not to be found
    if (typeof sigma === 'undefined') throw 'sigma.renderers.snapshot: sigma not in scope.';

    // Constants
    var CONTEXTS = ['scene', 'edges', 'nodes', 'labels'],
        TYPES = {
        png: 'image/png',
        jpg: 'image/jpeg',
        gif: 'image/gif',
        tiff: 'image/tiff'
    };

    // Utilities
    function download(dataUrl, extension, filename) {

        // Anchor
        var anchor = document.createElement('a');
        anchor.setAttribute('href', dataUrl);
        anchor.setAttribute('download', filename || 'graph.' + extension);

        // Click event
        var event = document.createEvent('MouseEvent');
        event.initMouseEvent('click', true, false, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);

        anchor.dispatchEvent(event);
        anchor = undefined;
    }

    // Main function
    function snapshot(params) {
        params = params || {};

        // Enforcing
        if (params.format && !(params.format in TYPES)) throw Error('sigma.renderers.snaphot: unsupported format "' + params.format + '".');

        var self = this,
            webgl = this instanceof sigma.renderers.webgl,
            doneContexts = [];

        // Creating a false canvas where we'll merge the other
        var merged = document.createElement('canvas'),
            mergedContext = merged.getContext('2d'),
            sized = false;

        // Iterating through context
        CONTEXTS.forEach(function (name) {
            if (!self.contexts[name]) return;

            if (params.labels === false && name === 'labels') return;

            var canvas = self.domElements[name] || self.domElements['scene'],
                context = self.contexts[name];

            if (~doneContexts.indexOf(context)) return;

            if (!sized) {
                merged.width = webgl && context instanceof WebGLRenderingContext ? canvas.width / 2 : canvas.width;
                merged.height = webgl && context instanceof WebGLRenderingContext ? canvas.height / 2 : canvas.height;
                sized = true;

                // Do we want a background color?
                if (params.background) {
                    mergedContext.rect(0, 0, merged.width, merged.height);
                    mergedContext.fillStyle = params.background;
                    mergedContext.fill();
                }
            }

            if (context instanceof WebGLRenderingContext) mergedContext.drawImage(canvas, 0, 0, canvas.width / 2, canvas.height / 2);else mergedContext.drawImage(canvas, 0, 0);

            doneContexts.push(context);
        });

        var dataUrl = merged.toDataURL(TYPES[params.format || 'png']);

        if (params.download) download(dataUrl, params.format || 'png', params.filename);

        // Cleaning
        mergedContext = undefined;
        merged = undefined;
        doneContexts = undefined;

        return dataUrl;
    }

    // Extending canvas and webl renderers
    sigma.renderers.canvas.prototype.snapshot = snapshot;
    sigma.renderers.webgl.prototype.snapshot = snapshot;
}
exports.default = usePlugin;

},{}],65:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.StateStorage = StateStorage;

var _lodash = require('lodash');

var DEFAULT_DECK_LENGTH = 4;

/**
 * Store states of LG. States is a Diagrams rendered around focusNode.
 * @class
 * @private
 * Constructor parameters
 *  @param {Parameters} parameters

 * Public methods:
 * pushState: () => void
 * getHistory: () => {
 *  states: { nodes: Node[], links: Link[], focusNode: Node }[],
 *  currentIndex: number,
 * }
 * undoState: () => void
 * redoState: () => void
 */
function StateStorage(parameters) {
    var self = this;
    if (!parameters) parameters = {};

    var _stateDeck = [];
    var _maxDeckLength = parameters.deckLength || DEFAULT_DECK_LENGTH;
    var _currentIndex = -1;

    self.pushState = function (state) {
        if (_stateDeck.length - 1 > _currentIndex) {
            _stateDeck.splice(_currentIndex + 1, _stateDeck.length);
        }
        _stateDeck.push(state);
        _check();
        _currentIndex = _stateDeck.length - 1;
    };

    self.updateState = function (state) {
        _stateDeck[_currentIndex] = state;
    };

    self.getHistory = function () {
        return {
            states: (0, _lodash.cloneDeep)(_stateDeck),
            currentIndex: _currentIndex
        };
    };

    self.undoState = function () {
        if (_currentIndex > 0) {
            _currentIndex--;
            return _returnState();
        } else {
            return null;
        }
    };

    self.redoState = function () {
        if (_currentIndex + 1 < _stateDeck.length) {
            _currentIndex++;
            return _returnState();
        } else {
            return null;
        }
    };

    function _returnState() {
        return _stateDeck[_currentIndex];
    }

    function _check() {
        if (_stateDeck.length > _maxDeckLength) _stateDeck.shift();
    }
}

exports.default = StateStorage;

},{"lodash":"lodash"}],66:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Subscribable = Subscribable;

var _lodash = require('lodash');

var _ = _interopRequireWildcard(_lodash);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/** 
 * It's base class which provides subscription API for successors.
 * @class
*/
function Subscribable() {
    var self = this;
    self._subscribtions = {};

    /**
     * Method allows to subscribe on a some specific event.
     * @param {string} event - event id
     * @param {function} callback - event handler
     * @memberof Subscribable
     * @method
    */
    self.on = function (event, callback) {
        if (!self._subscribtions[event]) self._subscribtions[event] = [];
        if (callback && callback instanceof Function) {
            self._subscribtions[event].push(callback);
        } else {
            throw new Error('Illegal type of callback!');
        }
    };

    /**
     * Method allows to unsubscribe from a some specific event.
     * @param {function} callback - event handler
     * @memberof Subscribable
     * @method
    */
    self.unsubscribe = function (callback) {
        _.values(self._subscribtions).forEach(function (subscribers) {
            var index = subscribers.indexOf(callback);
            if (index !== -1) subscribers.splice(index, 1);
        });
    };

    /**
     * Method which fires the event.
     * @param {string} event - event id
     * @param {Object[]} parameters
     * @memberof Subscribable
     * @method
    */
    self.trigger = function (event, parameters) {
        var _this = this;

        if (!(parameters instanceof Array)) parameters = [parameters];
        if (self._subscribtions && self._subscribtions[event]) {
            self._subscribtions[event].forEach(function (c) {
                c.apply(_this, parameters);
            });
        }
    };
}
exports.default = Subscribable;

},{"lodash":"lodash"}],67:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getBaseElement = getBaseElement;
exports.checkLgRawData = checkLgRawData;
exports.checkDmRawData = checkDmRawData;
exports.defenitionToPublicModel = defenitionToPublicModel;
exports.createJointNodes = createJointNodes;
exports.createJointLinks = createJointLinks;
exports.date2String = date2String;
exports.png2Blob = png2Blob;

var _lodash = require('lodash');

var _ = _interopRequireWildcard(_lodash);

var _elements = require('../jointViews/graphElements/elements');

var graphElements = _interopRequireWildcard(_elements);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function getBaseElement(element) {
    if (!element) return null;
    return element.originalLink || element.originalNode || element;
}

function checkLgRawData(data) {
    if (!data.links && !data.nodes) {
        throw new Error('There is no data to show!');
    }
    if (data.nodes) {
        if (!(data.nodes instanceof Array)) {
            throw new Error('\'nodes\' should be an Array, but it is object!');
        } else if (data.nodes.length === 0) {
            throw new Error('There is no data to show!');
        }
    } else {
        throw new Error('There is no nodes information in the data, so we have nothing to show!');
    }
    if (data.links && !(data.links instanceof Array)) {
        throw new Error('\'links\' should be an Array, but it is object!');
    }
    return true;
}

function checkDmRawData(data) {
    if (!data.edges && !data.nodes) {
        throw new Error('There is no data to show!');
    }
    if (data.nodes) {
        if (!(data.nodes instanceof Array)) {
            throw new Error('\'nodes\' should be an Array, but it is object!');
        } else if (data.nodes.length === 0) {
            throw new Error('There is no data to show!');
        }
    } else {
        throw new Error('There is no nodes information in the data, so we have nothing to show!');
    }
    if (data.links && !(data.edges instanceof Array)) {
        throw new Error('\'links\' should be an Array, but it is object!');
    }
    return true;
}

/**
 * View frame definition,
 * @typedef {Object} ViewFrameDefinition
 * @property {string} id - View frame identifyer
 * @property {string} label - Title of the view frame,
 * @property {string} borderColor - Color of the border
 * @property {string} backgroundColor - Color of the background
 * @property {number} spaceShare - How much the view frame will take
 * @property {boolean} collapsed - Define default state
 * from whole space of the graph (You can take it as persents or flex grow)
*/

function defenitionToPublicModel(defenition, fullScreenMode) {
    var isActive = fullScreenMode ? false : !defenition.collapsed;

    return {
        id: defenition.id,
        label: defenition.label,
        backgroundColor: defenition.backgroundColor,
        borderColor: defenition.borderColor,
        active: isActive,
        expanded: !defenition.collapsed,
        position: undefined,
        viewPortPosition: undefined,
        viewPortPositionBounds: undefined,
        viewPortBounds: undefined,
        nodeBounds: undefined,
        size: undefined,
        customeSized: false,
        spaceShare: defenition.spaceShare,
        updateBounds: false,
        isOverView: false
    };
}

/**
 * @private
 * Cretes joint nodes from nodeModels
 * @param {
 *      Array of {
            id: string,
            label: string,
            viewFrame: string,
            typeId: string,
            resourceType: string,
            resource: string,
 *      }
 * } NodeModels - list of models
 * @returns {Array of Node} list of joint nodes
 */
function createJointNodes(nodeModels, parameters) {
    var jointNodes = [];
    nodeModels.forEach(function (node) {
        jointNodes.push(new graphElements.Node(node, parameters));
    });
    return jointNodes;
}

/**
 * @private
 * Cretes joint links from models (nativeLinks)
 * @param {
 *      Array of {
 *          id: string,
 *          target: string,
 *          source: string,
 *      }
 * } nativeLinks - list of models
 * @returns {Link[]} list of joint links
 */
function createJointLinks(linkModels, jointNodes, parameters) {
    var jointLinks = [];
    var idMap = {};
    jointNodes.forEach(function (node) {
        idMap[node.model.id] = node.id;
    });
    linkModels.forEach(function (link) {
        var linkModel = _.cloneDeep(link);
        linkModel.sourceType = link.source;
        linkModel.targetType = link.target;
        linkModel.source = idMap[link.source];
        linkModel.target = idMap[link.target];
        linkModel.routing = parameters.linkRouting;
        var newLink = new graphElements.Link(linkModel, parameters);
        jointLinks.push(newLink);
    });
    return jointLinks;
}

function date2String(date) {
    return padStr(date.getFullYear()) + '_' + padStr(1 + date.getMonth()) + '_' + padStr(date.getDate()) + '_' + padStr(date.getHours()) + '_' + padStr(date.getMinutes()) + '_' + padStr(date.getSeconds());

    function padStr(i) {
        return i < 10 ? '0' + i : '' + i;
    }
}

function png2Blob(dataURI) {
    // convert base64 to raw binary data held in a string
    // doesn't handle URLEncoded DataURIs - see SO answer #6850276 for code that does this
    var byteString = atob(dataURI.split(',')[1]);

    // write the bytes of the string to an ArrayBuffer
    var ab = new ArrayBuffer(byteString.length);
    var ia = new Uint8Array(ab);
    for (var i = 0; i < byteString.length; i++) {
        ia[i] = byteString.charCodeAt(i);
    }

    // write the ArrayBuffer to a blob, and you're done
    var bb = new Blob([ab], { type: 'image/png' });
    return bb;
}

},{"../jointViews/graphElements/elements":47,"lodash":"lodash"}],68:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.convertNativeToLayoutModels = convertNativeToLayoutModels;
exports.convertLGElementsToLayoutModels = convertLGElementsToLayoutModels;
exports.convertDMElementsToLayoutModels = convertDMElementsToLayoutModels;
exports.convertJointElementsToLayoutModels = convertJointElementsToLayoutModels;
exports.sum = sum;
exports.map$1 = map$1;
exports.nest = nest;
exports.reinterpolate = reinterpolate;
exports.min = min;

var _utils = require('./utils');

function convertNativeToLayoutModels(nodeModels, linkModels, parameters) {
    var size = parameters.elementSize;
    var nodes = nodeModelsToLayoutNodes(nodeModels, parameters.elementSize);
    var links = linkModelsToLayoutLinks(linkModels, nodes);

    return {
        nodes: nodes,
        links: links
    };

    function nodeModelsToLayoutNodes(nodeModels) {
        return nodeModels.map(function (nodeModel) {
            return nodeModelToLayoutNode(nodeModel);
        });
    }

    function linkModelsToLayoutLinks(linkModels, nodes) {
        var nodeMap = (0, _utils.arrayToMap)(nodes);
        var links = linkModels.map(function (link) {
            return linkModelToLayoutLink(link, nodeMap);
        }).filter(function (link) {
            return link.source && link.target && link.source !== link.target;
        });
        links.forEach(function (link) {
            link.source.targetLinks.push(link);
            link.target.sourceLinks.push(link);
        });
        return links;
    }

    function nodeModelToLayoutNode(nodeModel) {
        return {
            id: nodeModel.id,
            x: nodeModel.position.x || Math.random(),
            y: nodeModel.position.y || Math.random(),
            originalNode: nodeModel,
            width: size.width,
            height: size.height,
            targetLinks: [],
            sourceLinks: [],
            viewFrame: nodeModel.viewFrame
        };
    }

    function linkModelToLayoutLink(linkModel, nodeMap) {
        var source = nodeMap[linkModel.source];
        var target = nodeMap[linkModel.target];
        return {
            originalLink: linkModel,
            source: source,
            target: target,
            value: 1
        };
    }
}

function convertLGElementsToLayoutModels(lgNodes, lgLinks, options) {
    var scale = options.scale;
    var nodes = lgNodes.map(function (node) {
        return nodeToLayoutNode(node);
    });
    var links = linksToLayoutLinks(lgLinks, nodes);

    return {
        nodes: nodes,
        links: links
    };

    function linksToLayoutLinks(link, nodes) {
        var nodeMap = (0, _utils.arrayToMap)(nodes);
        var links = link.map(function (link) {
            return linkToLayoutLink(link, nodeMap);
        }).filter(function (link) {
            return link.source && link.target && link.source !== link.target;
        });
        links.forEach(function (link) {
            link.source.targetLinks.push(link);
            link.target.sourceLinks.push(link);
        });
        return links;
    }

    function nodeToLayoutNode(node) {
        var position = (0, _utils.getGlobalNodePosition)(node);
        var size = (0, _utils.scaledToGlobalSize)(node.size, scale);
        return {
            id: node.id,
            x: position.x,
            y: position.y,
            originalNode: node,
            width: size.width,
            heigth: size.heigth,
            targetLinks: [],
            sourceLinks: []
        };
    }

    function linkToLayoutLink(link, nodeMap) {
        var source = nodeMap[link.model.source];
        var target = nodeMap[link.model.target];
        return {
            originalLink: link,
            source: source,
            target: target,
            value: 1
        };
    }
}

function convertDMElementsToLayoutModels(dmNodes, dmLinks) {
    var nodeMap = (0, _utils.arrayToMap)(dmNodes.map(function (node) {
        return nodeToLayoutNode(node);
    }));
    var links = linksToLayoutLinks(dmLinks, nodeMap);

    return {
        nodes: (0, _utils.mapToArray)(nodeMap),
        links: links
    };

    function linksToLayoutLinks(link, nodeMap) {
        var links = link.map(function (link) {
            return linkToLayoutLink(link, nodeMap);
        }).filter(function (link) {
            return link.source && link.target && link.source !== link.target;
        });
        links.forEach(function (link) {
            link.source.targetLinks.push(link);
            link.target.sourceLinks.push(link);
        });
        return links;
    }

    function nodeToLayoutNode(node) {
        var portPosition = node.getPortPosition();
        var portPrimitive = node.getPort().primitive;
        return {
            id: portPrimitive.id,
            x: 0,
            y: 0,
            originalNode: portPrimitive,
            targetLinks: [],
            sourceLinks: [],
            order: portPosition.y
        };
    }

    function linkToLayoutLink(link, nodeMap) {
        var sourcePrimitive = link.source.getPort().primitive;
        var targetPrimitive = link.target.getPort().primitive;

        var source = nodeMap[sourcePrimitive.id];
        var target = nodeMap[targetPrimitive.id];

        return {
            cacheId: cachLinkFunction(sourcePrimitive, targetPrimitive),
            originalLink: link,
            source: source,
            target: target,
            value: 1
        };
    }

    function cachLinkFunction(source, target) {
        return source.id + '~#tqDMLink#~' + target.id;
    }
}

function convertJointElementsToLayoutModels(jNodes, jLinks) {
    var nodeMap = (0, _utils.arrayToMap)(jNodes.map(function (node) {
        return nodeToLayoutNode(node);
    }));
    var links = linksToLayoutLinks(jLinks, nodeMap);

    return {
        nodes: (0, _utils.mapToArray)(nodeMap),
        links: links
    };

    function linksToLayoutLinks(link, nodeMap) {
        var links = link.map(function (link) {
            return linkToLayoutLink(link, nodeMap);
        }).filter(function (link) {
            return link.source && link.target && link.source !== link.target;
        });
        links.forEach(function (link) {
            link.source.targetLinks.push(link);
            link.target.sourceLinks.push(link);
        });
        return links;
    }

    function nodeToLayoutNode(node) {
        return {
            id: node.id,
            originalNode: node,
            x: 0,
            y: 0,
            targetLinks: [],
            sourceLinks: []
        };
    }

    function linkToLayoutLink(link, nodeMap) {
        var source = nodeMap[link.get('source').id];
        var target = nodeMap[link.get('target').id];

        return {
            originalLink: link,
            source: source,
            target: target,
            value: 1
        };
    }
}

function sum(array, f) {
    var s = 0,
        n = array.length,
        a = void 0,
        i = -1;

    if (f == null) {
        while (++i < n) {
            a = +array[i];
            if (a) s += a;
        }
    } else {
        while (++i < n) {
            a = +f(array[i], i, array);
            if (a) s += a;
        }
    }

    return s;
}

var prefix = '$';
function Map() {}
Map.prototype = map$1.prototype = {
    constructor: Map,
    has: function has(key) {
        return prefix + key in this;
    },
    get: function get(key) {
        return this[prefix + key];
    },
    set: function set(key, value) {
        this[prefix + key] = value;
        return this;
    },
    remove: function remove(key) {
        var property = prefix + key;
        return property in this && delete this[property];
    },
    clear: function clear() {
        for (var property in this) {
            if (property[0] === prefix) delete this[property];
        }
    },
    keys: function keys() {
        var keys = [];
        for (var property in this) {
            if (property[0] === prefix) keys.push(property.slice(1));
        }return keys;
    },
    values: function values() {
        var values = [];
        for (var property in this) {
            if (property[0] === prefix) values.push(this[property]);
        }return values;
    },
    entries: function entries() {
        var entries = [];
        for (var property in this) {
            if (property[0] === prefix) entries.push({ key: property.slice(1), value: this[property] });
        }return entries;
    },
    size: function size() {
        var size = 0;
        for (var property in this) {
            if (property[0] === prefix) ++size;
        }return size;
    },
    empty: function empty() {
        for (var property in this) {
            if (property[0] === prefix) return false;
        }return true;
    },
    each: function each(f) {
        for (var property in this) {
            if (property[0] === prefix) f(this[property], property.slice(1), this);
        }
    }
};

function map$1(object, f) {
    var map = new Map();

    // Copy constructor.
    if (object instanceof Map) object.each(function (value, key) {
        map.set(key, value);
    });

    // Index array by numeric index or specified key function.
    else if (Array.isArray(object)) {
            var i = -1,
                n = object.length,
                o = void 0;

            if (f == null) while (++i < n) {
                map.set(i, object[i]);
            } else while (++i < n) {
                map.set(f(o = object[i], i, object), o);
            }
        }

        // Convert object to map.
        else if (object) for (var key in object) {
                map.set(key, object[key]);
            }return map;
}

function nest() {
    var keys = [],
        _sortKeys = [],
        _sortValues = void 0,
        _rollup = void 0,
        nest = void 0;

    function apply(array, depth, createResult, setResult) {
        if (depth >= keys.length) return _rollup != null ? _rollup(array) : _sortValues != null ? array.sort(_sortValues) : array;

        var i = -1,
            n = array.length,
            key = keys[depth++],
            keyValue = void 0,
            value = void 0,
            valuesByKey = map$1(),
            values = void 0,
            result = createResult();

        while (++i < n) {
            values = valuesByKey.get(keyValue = key(value = array[i]) + '');
            if (values) {
                values.push(value);
            } else {
                valuesByKey.set(keyValue, [value]);
            }
        }

        valuesByKey.each(function (values, key) {
            setResult(result, key, apply(values, depth, createResult, setResult));
        });

        return result;
    }

    function _entries(map, depth) {
        if (++depth > keys.length) return map;
        var array = void 0,
            sortKey = _sortKeys[depth - 1];
        if (_rollup != null && depth >= keys.length) array = map.entries();else array = [], map.each(function (v, k) {
            array.push({ key: k, values: _entries(v, depth) });
        });
        return sortKey != null ? array.sort(function (a, b) {
            return sortKey(a.key, b.key);
        }) : array;
    }

    return nest = {
        object: function object(array) {
            return apply(array, 0, createObject, setObject);
        },
        map: function map(array) {
            return apply(array, 0, createMap, setMap);
        },
        entries: function entries(array) {
            return _entries(apply(array, 0, createMap, setMap), 0);
        },
        key: function key(d) {
            keys.push(d);return nest;
        },
        sortKeys: function sortKeys(order) {
            _sortKeys[keys.length - 1] = order;return nest;
        },
        sortValues: function sortValues(order) {
            _sortValues = order;return nest;
        },
        rollup: function rollup(f) {
            _rollup = f;return nest;
        }
    };

    function createObject() {
        return {};
    }

    function setObject(object, key, value) {
        object[key] = value;
    }

    function createMap() {
        return map$1();
    }

    function setMap(map, key, value) {
        map.set(key, value);
    }
}

function reinterpolate(a, b) {
    return a = +a, b -= a, function (t) {
        return a + b * t;
    };
}

function min(array, f) {
    var i = -1,
        n = array.length,
        a = void 0,
        b = void 0;

    if (f == null) {
        while (++i < n) {
            if ((b = array[i]) != null && b >= b) {
                a = b;break;
            }
        }while (++i < n) {
            if ((b = array[i]) != null && a > b) a = b;
        }
    } else {
        while (++i < n) {
            if ((b = f(array[i], i, array)) != null && b >= b) {
                a = b;break;
            }
        }while (++i < n) {
            if ((b = f(array[i], i, array)) != null && a > b) a = b;
        }
    }

    return a;
}

},{"./utils":70}],69:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.GAP = undefined;
exports.cacheIdForViewFrameUI = cacheIdForViewFrameUI;
exports.getViewFrameIdForNode = getViewFrameIdForNode;
exports.checkPagination = checkPagination;
exports.getCrosPoint = getCrosPoint;
exports.adjustVertices = adjustVertices;
exports.getPath = getPath;

var _rappid = require('rappid');

var joint = _interopRequireWildcard(_rappid);

var _lodash = require('lodash');

var _ = _interopRequireWildcard(_lodash);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function cacheIdForViewFrameUI(viewFrame) {
    return 'tq-lg-view-frame-ui-' + viewFrame.id;
}

function getViewFrameIdForNode(node) {
    return node.viewFrameOwnerId || node.model.viewFrame;
}

function checkPagination(viewFrame) {
    var viewPortPositionBounds = viewFrame.viewPortPositionBounds;
    var viewPortPosition = viewFrame.viewPortPosition;

    return {
        canMoveUp: viewPortPositionBounds && viewPortPosition.y > viewPortPositionBounds.minY,
        canMoveDown: viewPortPositionBounds && viewPortPosition.y < viewPortPositionBounds.maxY,
        canMoveLeft: viewPortPositionBounds && viewPortPosition.x > viewPortPositionBounds.minX,
        canMoveRight: viewPortPositionBounds && viewPortPosition.x < viewPortPositionBounds.maxX
    };
}

/**
 * @private
 * Returns point of crossing of two lines
 * @param {Point} p1 - the first point of line-1
 * @param {Point} p2 - the second point of line-1
 * @param {Point} p3 - the first point of line-2
 * @param {Point} p4 - the second point of line-2
 * @returns {Point}
 */
function getCrosPoint(p1, p2, p3, p4) {
    var x1 = p1.x;
    var y1 = p1.y;

    var x2 = p2.x;
    var y2 = p2.y;

    var x3 = p3.x;
    var y3 = p3.y;

    var x4 = p4.x;
    var y4 = p4.y;

    var k1 = void 0,
        k2 = void 0,
        b1 = void 0,
        b2 = void 0;
    var rx = void 0,
        ry = void 0,
        xx = void 0,
        yy = void 0;
    var res = {};

    if (x1 == x2 && x3 == x4) return null;
    if (x1 === x2) {
        k2 = (y3 - y4) / (x3 - x4);
        b2 = y3 - k2 * x3;

        rx = x1;
        ry = k2 * rx + b2;
    } else if (x3 === x4) {
        k1 = (y1 - y2) / (x1 - x2);
        b1 = y1 - k1 * x1;

        rx = x3;
        ry = k1 * rx + b1;
    } else {
        k1 = (y1 - y2) / (x1 - x2);
        b1 = y1 - k1 * x1;

        k2 = (y3 - y4) / (x3 - x4);
        b2 = y3 - k2 * x3;

        if (k1 == k2) {
            return null;
        }

        rx = (b2 - b1) / (k1 - k2);
        ry = k1 * rx + b1;
    }

    if (y2 < y1) {
        yy = y1;
        y1 = y2;
        y2 = yy;
    }
    if (y4 < y3) {
        yy = y3;
        y3 = y4;
        y4 = yy;
    }
    if (x2 < x1) {
        xx = x1;
        x1 = x2;
        x2 = xx;
    }
    if (x4 < x3) {
        xx = x3;
        x3 = x4;
        x4 = xx;
    }
    res.x = rx;
    res.y = ry;
    var error = 1;
    if (x1 - error <= res.x && res.x <= x2 + error && x3 - error <= res.x && res.x <= x4 + error && y1 - error <= res.y && res.y <= y2 + error && y3 - error <= res.y && res.y <= y4 + error) {
        return res;
    } else {
        return null;
    }
}

// This is the maximum distance between links
var GAP = exports.GAP = 10; // px
// Only for Derivation map
function adjustVertices(graph, cell) {
    if (!cell) {
        graph.getLinks().forEach(function (link) {
            adjustVertices(graph, link);
        });
        return;
    }
    // If the cell is a view, find its model.
    cell = cell.model && cell.model.get ? cell.model : cell;

    if (cell instanceof joint.dia.Element) {
        graph.getConnectedLinks(cell).forEach(function (link) {
            adjustVertices(graph, link);
        });
        return;
    }

    if (cell.hidden) return;
    cell.set('vertices', []);

    // The cell is a link. Let's find its source and target models.
    var srcId = cell.get('source').id || cell.previous('source').id;
    var trgId = cell.get('target').id || cell.previous('target').id;
    var srcPort = cell.get('source').port || cell.previous('source').port;
    var trgPort = cell.get('target').port || cell.previous('target').port;

    // If one of the ends is not a model, the link has no siblings.
    if (!srcId || !trgId) return;

    var siblings = graph.getLinks().filter(function (sibling) {
        if (sibling.hidden) return false;
        var _srcId = sibling.get('source').id;
        var _trgId = sibling.get('target').id;
        var _srcPort = sibling.get('source').port;
        var _trgPort = sibling.get('target').port;

        var sameEndsSameDirection = _srcId === srcId && _trgId === trgId && _srcPort === srcPort && _trgPort === trgPort;
        var sameEndsSameOppositeDirection = _srcId === trgId && _trgId === srcId && _srcPort === trgPort && _trgPort === srcPort;
        return sameEndsSameDirection || sameEndsSameOppositeDirection;
    });

    switch (siblings.length) {
        case 0:
        case 1:
            break;
        default:
            {
                // There is more than one siblings. We need to create vertices.
                // First of all we'll find the middle point of the link.
                var srcCell = graph.getCell(srcId);
                var srcPosition = srcCell.position();
                var _srcPort2 = srcCell.attr('.' + cell.get('source').port);
                if (!_srcPort2) return;
                var srcPortPosition = {
                    x: _srcPort2['ref-x'] + srcPosition.x,
                    y: _srcPort2['ref-y'] + srcPosition.y,
                    theta: joint.g.point.prototype.theta
                };
                var trgCell = graph.getCell(trgId);
                var trgPosition = trgCell.position();
                var _trgPort2 = trgCell.attr('.' + cell.get('target').port);
                if (!_trgPort2) return;
                var trgPortPosition = {
                    x: _trgPort2['ref-x'] + trgPosition.x,
                    y: _trgPort2['ref-y'] + trgPosition.y
                };
                var midPoint = joint.g.line(srcPortPosition, trgPortPosition).midpoint();

                // Then find the angle it forms.
                var theta = srcPortPosition.theta(trgPortPosition);
                var cellIndex = siblings.indexOf(cell);

                // We want the offset values to be calculated as follows 0, 20, 20, 40, 40, 60, 60 ..
                var offset = GAP * Math.ceil((cellIndex + (siblings.length % 2 === 0 ? 1 : 0)) / 2);

                // Now we need the vertices to be placed at points which are 'offset' pixels distant
                // from the first link and forms a perpendicular angle to it. And as index goes up
                // alternate left and right.
                //
                //  ^  odd indexes 
                //  |
                //  |---->  index 0 line (straight line between a source center and a target center.
                //  |
                //  v  even indexes
                var sign = cellIndex % 2 ? 1 : -1;
                var angle = joint.g.toRad(theta + sign * 90);

                // We found the vertex.
                var vertex = joint.g.point.fromPolar(offset, angle, midPoint);

                cell.set('vertices', [{ x: vertex.x, y: vertex.y }]);
            }}
}

function getPath(selectedElement, dataContainer) {
    var sourceMap = dataContainer.maps.sourceMap;
    var targetMap = dataContainer.maps.targetMap;
    var nodeMap = dataContainer.maps.nodeMap;

    var pathNodes = {};
    var pathLinksWest = {};
    var pathLinksEast = {};

    if (nodeMap[selectedElement.id]) {
        selectNode(selectedElement, true);
        selectNode(selectedElement, false);
    } else {
        pathLinksWest[selectedElement.id] = selectedElement;
        pathLinksEast[selectedElement.id] = selectedElement;
        selectNode(nodeMap[selectedElement.model.target], true);
        selectNode(nodeMap[selectedElement.model.source], false);
    }

    function selectNode(curNode, direction) {
        pathNodes[curNode.id] = curNode;
        curNode.aspects.forEach(function (aspect) {
            return pathNodes[aspect.id] = aspect;
        });
        var links = direction ? targetMap[curNode.id] : sourceMap[curNode.id];
        if (links) {
            links.forEach(function (link) {
                if (!pathLinksEast[link.id] && direction || !pathLinksWest[link.id] && !direction) {
                    if (direction) {
                        pathLinksEast[link.id] = link;
                    } else {
                        pathLinksWest[link.id] = link;
                    }
                    selectNode(nodeMap[direction ? link.model.target : link.model.source], direction);
                }
            });
        }
    }

    return _.merge(pathLinksEast, pathLinksWest, pathNodes);
}

},{"lodash":"lodash","rappid":"rappid"}],70:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.limitPointPosition = limitPointPosition;
exports.getScaledViewFramePosition = getScaledViewFramePosition;
exports.getGlobalViewPortPosition = getGlobalViewPortPosition;
exports.getGlobalNodePosition = getGlobalNodePosition;
exports.getScaledNodePosition = getScaledNodePosition;
exports.getLocalNodePosition = getLocalNodePosition;
exports.getGlobalNodeSize = getGlobalNodeSize;
exports.getScaledNodeSize = getScaledNodeSize;
exports.globalToScaledPoint = globalToScaledPoint;
exports.scaledToGlobalPoint = scaledToGlobalPoint;
exports.globalToLocalPoint = globalToLocalPoint;
exports.localToGlobalPoint = localToGlobalPoint;
exports.localToScaledPoint = localToScaledPoint;
exports.scaledToLocalPoint = scaledToLocalPoint;
exports.globalToScaledSize = globalToScaledSize;
exports.scaledToGlobalSize = scaledToGlobalSize;
exports.globalToScaledBounds = globalToScaledBounds;
exports.scaledToGlobalBounds = scaledToGlobalBounds;
exports.shrinkBounds = shrinkBounds;
exports.extendBounds = extendBounds;
exports.getElementSize = getElementSize;
exports.arrayToMap = arrayToMap;
exports.mapToArray = mapToArray;
exports.getDist = getDist;
exports.getDiff = getDiff;
exports.onDragStart = onDragStart;

var _lodash = require('lodash');

var _ = _interopRequireWildcard(_lodash);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @private
 * Returns limitted by bounds point value
 * @param {Point} point 
 * @param {Bounds} bounds 
 */
function limitPointPosition(point, bounds) {
    if (!bounds) return point;

    var x = Math.max(Math.min(point.x, bounds.maxX), bounds.minX);
    var y = Math.max(Math.min(point.y, bounds.maxY), bounds.minY);

    return { x: x, y: y };
}

// global = {
//     x: 1,
//     y: 1,
// }
// scaled = {
//     x: global.x * scale,
//     y: global.y * scale,
// }
// local = {
//     x: scaled.x + viewFrameScaledPos.x - viewFrameViewPortPosition.x,
//     y: scaled.y + viewFrameScaledPos.y - viewFrameViewPortPosition.y,
// }
// ====================================================
function getScaledViewFramePosition(viewFrame) {
    if (viewFrame.position instanceof Function) {
        return viewFrame.position();
    } else if (viewFrame.position) {
        return viewFrame.position;
    } else {
        throw new Error('Incorrect parameter!');
    }
}

function getGlobalViewPortPosition(viewFrame) {
    if (viewFrame.positionViewPort) {
        return viewFrame.positionViewPort();
    } else if (viewFrame.viewPortPosition) {
        return viewFrame.viewPortPosition;
    } else {
        throw new Error('Incorrect parameter!');
    }
}

function getGlobalNodePosition(node) {
    return _.clone(node.model.position);
}

function getScaledNodePosition(node, scale) {
    if (!scale) throw new Error('Scale is undefined!');

    var position = getGlobalNodePosition(node);
    return globalToScaledPoint(position, scale);
}

function getLocalNodePosition(node, scale, viewFrame) {
    if (!scale) throw new Error('Scale is undefined!');

    var position = getGlobalNodePosition(node);
    return globalToLocalPoint(position, scale, viewFrame);
}

function getGlobalNodeSize(node, scale) {
    var scaledSize = getScaledNodeSize(node);

    return scaledToGlobalSize(scaledSize, scale);
}

function getScaledNodeSize(node) {
    return node.get('size');
}

function globalToScaledPoint(point, scale) {
    if (!scale) throw new Error('Scale is undefined!');

    return {
        x: point.x * scale.x,
        y: point.y * scale.y
    };
}

function scaledToGlobalPoint(point, scale) {
    if (!scale) throw new Error('Scale is undefined!');

    return {
        x: point.x / scale.x,
        y: point.y / scale.y
    };
}

function globalToLocalPoint(point, scale, viewFrame) {
    if (!scale) throw new Error('Scale is undefined!');
    var scaledPoint = globalToScaledPoint(point, scale);

    return scaledToLocalPoint(scaledPoint, scale, viewFrame);
}

function localToGlobalPoint(point, scale, viewFrame) {
    if (!scale) throw new Error('Scale is undefined!');
    var scaledPoint = localToScaledPoint(point, scale, viewFrame);

    return scaledToGlobalPoint(scaledPoint, scale, viewFrame);
}

function localToScaledPoint(point, scale, viewFrame) {
    if (!scale) throw new Error('Scale is undefined!');

    var scaledViewFrameOffset = getScaledViewFramePosition(viewFrame);
    var globalViewPortOffset = getGlobalViewPortPosition(viewFrame);
    var scaledViewPortOffset = globalToScaledPoint(globalViewPortOffset, scale);

    return {
        x: point.x - scaledViewFrameOffset.x + scaledViewPortOffset.x,
        y: point.y - scaledViewFrameOffset.y + scaledViewPortOffset.y
    };
}

function scaledToLocalPoint(point, scale, viewFrame) {
    if (!scale) throw new Error('Scale is undefined!');

    var scaledViewFrameOffset = getScaledViewFramePosition(viewFrame);
    var globalViewPortOffset = getGlobalViewPortPosition(viewFrame);
    var scaledViewPortOffset = globalToScaledPoint(globalViewPortOffset, scale);

    return {
        x: point.x + scaledViewFrameOffset.x - scaledViewPortOffset.x,
        y: point.y + scaledViewFrameOffset.y - scaledViewPortOffset.y
    };
}

function globalToScaledSize(size, scale) {
    if (!scale) throw new Error('Scale is undefined!');
    return {
        width: size.width * scale.x,
        height: size.height * scale.y
    };
}

function scaledToGlobalSize(size, scale) {
    if (!scale) throw new Error('Scale is undefined!');
    return {
        width: size.width / scale.x,
        height: size.height / scale.y
    };
}

function globalToScaledBounds(bounds, scale) {
    var scaledMinPosition = globalToScaledPoint({ x: bounds.minX, y: bounds.minY }, scale);
    var scaledMaxPosition = globalToScaledPoint({ x: bounds.maxX, y: bounds.maxY }, scale);
    return {
        minX: scaledMinPosition.x,
        maxX: scaledMaxPosition.x,
        minY: scaledMinPosition.y,
        maxY: scaledMaxPosition.y,
        width: scaledMaxPosition.x - scaledMinPosition.x,
        height: scaledMaxPosition.y - scaledMinPosition.y
    };
}

function scaledToGlobalBounds(bounds, scale) {
    var scaledMinPosition = scaledToGlobalPoint({ x: bounds.minX, y: bounds.minY }, scale);
    var scaledMaxPosition = scaledToGlobalPoint({ x: bounds.maxX, y: bounds.maxY }, scale);
    return {
        minX: scaledMinPosition.x,
        maxX: scaledMaxPosition.x,
        minY: scaledMinPosition.y,
        maxY: scaledMaxPosition.y,
        width: scaledMaxPosition.x - scaledMinPosition.x,
        height: scaledMaxPosition.y - scaledMinPosition.y
    };
}

function shrinkBounds(bounds, paddingRectangle) {
    return {
        minX: bounds.minX + paddingRectangle.x,
        maxX: bounds.maxX - paddingRectangle.x,
        minY: bounds.minY + paddingRectangle.y,
        maxY: bounds.maxY - paddingRectangle.y,
        width: bounds.maxX - bounds.minX - paddingRectangle.x * 2,
        height: bounds.maxY - bounds.minY - paddingRectangle.y * 2
    };
}

function extendBounds(bounds, extendBy) {
    return {
        minX: bounds.minX - extendBy.x,
        maxX: bounds.maxX + extendBy.x,
        minY: bounds.minY - extendBy.y,
        maxY: bounds.maxY + extendBy.y,
        width: bounds.maxX + extendBy.x * 2 - bounds.minX,
        height: bounds.maxY + extendBy.y * 2 - bounds.minY
    };
}

// ====================================================

function getElementSize(rootId) {
    var paper = document.getElementById(rootId);
    return {
        width: paper.clientWidth,
        height: paper.clientHeight
    };
}

function arrayToMap(array, useAsId) {
    useAsId = useAsId || 'id';
    var map = {};
    array.forEach(function (el) {
        map[el[useAsId]] = el;
    });
    return map;
}

function mapToArray(map) {
    return Object.keys(map).map(function (key) {
        return map[key];
    });
}

function getDist(p1, p2) {
    return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
}

function getDiff(n1, n2) {
    var min = Math.min(n1, n2);
    if (min < 0) {
        n1 += -min;
        n2 += -min;
    }
    return Math.abs(n2 - n1);
}

function onDragStart(event, moveCallback, releaseCallback) {
    var startX = 0;
    var startY = 0;

    var pointProvider = event instanceof MouseEvent ? event : event.touches[0];

    if (pointProvider.pageX) startX = pointProvider.pageX;else if (pointProvider.clientX) startX = pointProvider.clientX;

    if (pointProvider.pageY) startY = pointProvider.pageY;else if (pointProvider.clientY) startY = pointProvider.clientY;

    window.getSelection().removeAllRanges();

    document.body.addEventListener('mousemove', _onchange);
    document.body.addEventListener('mouseup', _onend);
    document.body.addEventListener('touchmove', _onchange);
    document.body.addEventListener('touchend', _onend);

    function _onchange(event) {
        var pointProvider = event instanceof MouseEvent ? event : event.touches[0];

        var endX = 0;
        if (pointProvider.pageX) endX = pointProvider.pageX;else if (pointProvider.clientX) endX = pointProvider.clientX;

        var diffX = endX - startX;
        startX = endX;

        var endY = 0;
        if (pointProvider.pageY) endY = pointProvider.pageY;else if (pointProvider.clientY) endY = pointProvider.clientY;

        var diffY = endY - startY;
        startY = endY;

        moveCallback({ x: diffX, y: diffY });
    }

    function _onend() {
        document.body.onmousemove = document.body.onmouseup = null;
        document.body.removeEventListener('mousemove', _onchange);
        document.body.removeEventListener('mouseup', _onend);
        document.body.removeEventListener('touchmove', _onchange);
        document.body.removeEventListener('touchend', _onend);
        if (releaseCallback) releaseCallback();
    }
}

},{"lodash":"lodash"}]},{},[60])(60)
});

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvZXM2LXByb21pc2UvZGlzdC9lczYtcHJvbWlzZS5qcyIsIm5vZGVfbW9kdWxlcy9maWxlLXNhdmVyanMvRmlsZVNhdmVyLmpzIiwibm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9zaWdtYS9idWlsZC9zaWdtYS5yZXF1aXJlLmpzIiwibm9kZV9tb2R1bGVzL3Zpc3VhbGl6YXRpb25zLWxpYnJhcnkvYnVpbGQvanMvbWFpbi5taW4uanMiLCJub2RlX21vZHVsZXMvd2ViY29sYS9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3dlYmNvbGEvZGlzdC9zcmMvYWRhcHRvci5qcyIsIm5vZGVfbW9kdWxlcy93ZWJjb2xhL2Rpc3Qvc3JjL2JhdGNoLmpzIiwibm9kZV9tb2R1bGVzL3dlYmNvbGEvZGlzdC9zcmMvZDNhZGFwdG9yLmpzIiwibm9kZV9tb2R1bGVzL3dlYmNvbGEvZGlzdC9zcmMvZDN2M2FkYXB0b3IuanMiLCJub2RlX21vZHVsZXMvd2ViY29sYS9kaXN0L3NyYy9kM3Y0YWRhcHRvci5qcyIsIm5vZGVfbW9kdWxlcy93ZWJjb2xhL2Rpc3Qvc3JjL2Rlc2NlbnQuanMiLCJub2RlX21vZHVsZXMvd2ViY29sYS9kaXN0L3NyYy9nZW9tLmpzIiwibm9kZV9tb2R1bGVzL3dlYmNvbGEvZGlzdC9zcmMvZ3JpZHJvdXRlci5qcyIsIm5vZGVfbW9kdWxlcy93ZWJjb2xhL2Rpc3Qvc3JjL2hhbmRsZWRpc2Nvbm5lY3RlZC5qcyIsIm5vZGVfbW9kdWxlcy93ZWJjb2xhL2Rpc3Qvc3JjL2xheW91dC5qcyIsIm5vZGVfbW9kdWxlcy93ZWJjb2xhL2Rpc3Qvc3JjL2xheW91dDNkLmpzIiwibm9kZV9tb2R1bGVzL3dlYmNvbGEvZGlzdC9zcmMvbGlua2xlbmd0aHMuanMiLCJub2RlX21vZHVsZXMvd2ViY29sYS9kaXN0L3NyYy9wb3dlcmdyYXBoLmpzIiwibm9kZV9tb2R1bGVzL3dlYmNvbGEvZGlzdC9zcmMvcHF1ZXVlLmpzIiwibm9kZV9tb2R1bGVzL3dlYmNvbGEvZGlzdC9zcmMvcmJ0cmVlLmpzIiwibm9kZV9tb2R1bGVzL3dlYmNvbGEvZGlzdC9zcmMvcmVjdGFuZ2xlLmpzIiwibm9kZV9tb2R1bGVzL3dlYmNvbGEvZGlzdC9zcmMvc2hvcnRlc3RwYXRocy5qcyIsIm5vZGVfbW9kdWxlcy93ZWJjb2xhL2Rpc3Qvc3JjL3Zwc2MuanMiLCJub2RlX21vZHVsZXMvd2hhdHdnLWZldGNoL2ZldGNoLmpzIiwic3JjL2pzL2RhdGEvYmFzZTY0SW1hZ2VzLmpzIiwic3JjL2pzL2RhdGEvZGF0YUNvbnRhaW5lci5qcyIsInNyYy9qcy9kYXRhL2RhdGFQcm9jZXNzaW5nLmpzIiwic3JjL2pzL2RhdGEvZGVmYXVsdERhdGFQcm92aWRlci5qcyIsInNyYy9qcy9kYXRhL3Jlc291cmNlUHJvdmlkZXIuanMiLCJzcmMvanMvaHRtbFVJL2RlZmF1bHRVSS5qcyIsInNyYy9qcy9odG1sVUkvZG1EZWZhdWx0VUkuanMiLCJzcmMvanMvaHRtbFVJL2RtSW5mb1BhbmVsLmpzIiwic3JjL2pzL2h0bWxVSS9pbmZvUGFuZWwuanMiLCJzcmMvanMvaHRtbFVJL21hcC5qcyIsInNyYy9qcy9odG1sVUkvb3B0aW9uc1BhbmVsLmpzIiwic3JjL2pzL2h0bWxVSS9zcGxpdHRlci5qcyIsInNyYy9qcy9odG1sVUkvdmlld0ZyYW1lQnV0dG9ucy5qcyIsInNyYy9qcy9odG1sVUkvdmlld0ZyYW1lc1VJLmpzIiwic3JjL2pzL2pvaW50Vmlld3MvZGVyaXZhdGlvbk1hcC9kYXRhUHJvY2Vzc2luZy5qcyIsInNyYy9qcy9qb2ludFZpZXdzL2Rlcml2YXRpb25NYXAvZGVyaXZhdGlvbk1hcC5qcyIsInNyYy9qcy9qb2ludFZpZXdzL2Rlcml2YXRpb25NYXAvbGluZVJvdXRpbmcuanMiLCJzcmMvanMvam9pbnRWaWV3cy9kZXJpdmF0aW9uTWFwL21hcEVsZW1lbnRzLmpzIiwic3JjL2pzL2pvaW50Vmlld3MvZGVyaXZhdGlvbk1hcC9tYXBMYXlvdXQuanMiLCJzcmMvanMvam9pbnRWaWV3cy9kZXJpdmF0aW9uTWFwL21hcFZpZXdzLmpzIiwic3JjL2pzL2pvaW50Vmlld3MvZ3JhcGhFbGVtZW50cy9hc3BlY3RMaW5rLmpzIiwic3JjL2pzL2pvaW50Vmlld3MvZ3JhcGhFbGVtZW50cy9lbGVtZW50cy5qcyIsInNyYy9qcy9qb2ludFZpZXdzL2dyYXBoRWxlbWVudHMvbGluay5qcyIsInNyYy9qcy9qb2ludFZpZXdzL2dyYXBoRWxlbWVudHMvbm9kZS5qcyIsInNyYy9qcy9qb2ludFZpZXdzL2dyYXBoRWxlbWVudHMvdGVybWluYXRpb25MaW5rLmpzIiwic3JjL2pzL2pvaW50Vmlld3MvZ3JhcGhFbGVtZW50cy90ZXJtaW5hdGlvbk5vZGUuanMiLCJzcmMvanMvam9pbnRWaWV3cy9saW5lYWdlRGlhZ3JhbS5qcyIsInNyYy9qcy9qb2ludFZpZXdzL2xpbmtSb3V0aW5nTWFuYWdlci9yb3V0aW5nTWFuYWdlci5qcyIsInNyYy9qcy9qb2ludFZpZXdzL3RvU3ZnLmpzIiwic3JjL2pzL2pvaW50Vmlld3Mvdmlld0ZyYW1lLmpzIiwic3JjL2pzL2pvaW50Vmlld3Mvdmlld01hbmFnZXIuanMiLCJzcmMvanMvbGF5b3V0L2xheW91dC5qcyIsInNyYy9qcy9sYXlvdXQvc2Fua2V5LmpzIiwic3JjL2pzL2xpbmVhZ2VHcmFtLmpzIiwic3JjL2pzL21haW4uanMiLCJzcmMvanMvc2lnbWFWaWV3cy9iaXJkRXllLmpzIiwic3JjL2pzL3NpZ21hVmlld3MvZ3JhcGhNYXAuanMiLCJzcmMvanMvc2lnbWFWaWV3cy9zaWdtYUJhc2UuanMiLCJzcmMvanMvc2lnbWFWaWV3cy9zaWdtYVBsYWdpbnMvc2lnbWEucmVuZGVyZXJzLnNuYXBzaG90L3NpZ21hLnJlbmRlcmVycy5zbmFwc2hvdC5qcyIsInNyYy9qcy9zdGF0ZVN0b3JhZ2UuanMiLCJzcmMvanMvc3Vic2NyaXB0aW9uQVBJL3N1YnNjcmliZWFibGUuanMiLCJzcmMvanMvdXRpbHMvZGF0YVV0aWxzLmpzIiwic3JjL2pzL3V0aWxzL2xheW91dFV0aWxzLmpzIiwic3JjL2pzL3V0aWxzL2xpbmVhZ2VEaWFncmFtVXRpbHMuanMiLCJzcmMvanMvdXRpbHMvdXRpbHMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2pvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDNXlYQTs7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcmlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMWlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbFlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdFlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QWMsT0FBckI7O0FBRWhDLFlBQU0sUUFBUSxPQUFPLE1BQXJCO0FBQ0EsaUJBQVMsSUFBVDs7QUFFQSxZQUFJLE9BQU8sQ0FBWDtBQUNBLFlBQUksY0FBYyxLQUFsQixFQUF5QixPQUFPLGNBQWMsS0FBckIsQ0FBekIsS0FDSyxJQUFJLGNBQWMsT0FBbEIsRUFBMkIsT0FBTyxjQUFjLE9BQXJCOztBQUVoQyxZQUFNLFFBQVEsT0FBTyxNQUFyQjtBQUNBLGlCQUFTLElBQVQ7O0FBRUEscUJBQWEsRUFBRSxHQUFHLEtBQUwsRUFBWSxHQUFHLEtBQWYsRUFBYjtBQUNIOztBQUVELGFBQVMsTUFBVCxHQUFtQjtBQUNmLGlCQUFTLElBQVQsQ0FBYyxXQUFkLEdBQTRCLFNBQVMsSUFBVCxDQUFjLFNBQWQsR0FBMEIsSUFBdEQ7QUFDQSxpQkFBUyxJQUFULENBQWMsbUJBQWQsQ0FBa0MsV0FBbEMsRUFBK0MsU0FBL0M7QUFDQSxpQkFBUyxJQUFULENBQWMsbUJBQWQsQ0FBa0MsU0FBbEMsRUFBNkMsTUFBN0M7QUFDQSxpQkFBUyxJQUFULENBQWMsbUJBQWQsQ0FBa0MsV0FBbEMsRUFBK0MsU0FBL0M7QUFDQSxpQkFBUyxJQUFULENBQWMsbUJBQWQsQ0FBa0MsVUFBbEMsRUFBOEMsTUFBOUM7QUFDQSxZQUFJLGVBQUosRUFBcUI7QUFDeEI7QUFDRiIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSIsIi8qIVxuICogQG92ZXJ2aWV3IGVzNi1wcm9taXNlIC0gYSB0aW55IGltcGxlbWVudGF0aW9uIG9mIFByb21pc2VzL0ErLlxuICogQGNvcHlyaWdodCBDb3B5cmlnaHQgKGMpIDIwMTQgWWVodWRhIEthdHosIFRvbSBEYWxlLCBTdGVmYW4gUGVubmVyIGFuZCBjb250cmlidXRvcnMgKENvbnZlcnNpb24gdG8gRVM2IEFQSSBieSBKYWtlIEFyY2hpYmFsZClcbiAqIEBsaWNlbnNlICAgTGljZW5zZWQgdW5kZXIgTUlUIGxpY2Vuc2VcbiAqICAgICAgICAgICAgU2VlIGh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9zdGVmYW5wZW5uZXIvZXM2LXByb21pc2UvbWFzdGVyL0xJQ0VOU0VcbiAqIEB2ZXJzaW9uICAgMy4zLjFcbiAqL1xuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAgIChnbG9iYWwuRVM2UHJvbWlzZSA9IGZhY3RvcnkoKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gb2JqZWN0T3JGdW5jdGlvbih4KSB7XG4gIHJldHVybiB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiYgeCAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNGdW5jdGlvbih4KSB7XG4gIHJldHVybiB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxudmFyIF9pc0FycmF5ID0gdW5kZWZpbmVkO1xuaWYgKCFBcnJheS5pc0FycmF5KSB7XG4gIF9pc0FycmF5ID0gZnVuY3Rpb24gKHgpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBBcnJheV0nO1xuICB9O1xufSBlbHNlIHtcbiAgX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xufVxuXG52YXIgaXNBcnJheSA9IF9pc0FycmF5O1xuXG52YXIgbGVuID0gMDtcbnZhciB2ZXJ0eE5leHQgPSB1bmRlZmluZWQ7XG52YXIgY3VzdG9tU2NoZWR1bGVyRm4gPSB1bmRlZmluZWQ7XG5cbnZhciBhc2FwID0gZnVuY3Rpb24gYXNhcChjYWxsYmFjaywgYXJnKSB7XG4gIHF1ZXVlW2xlbl0gPSBjYWxsYmFjaztcbiAgcXVldWVbbGVuICsgMV0gPSBhcmc7XG4gIGxlbiArPSAyO1xuICBpZiAobGVuID09PSAyKSB7XG4gICAgLy8gSWYgbGVuIGlzIDIsIHRoYXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHNjaGVkdWxlIGFuIGFzeW5jIGZsdXNoLlxuICAgIC8vIElmIGFkZGl0aW9uYWwgY2FsbGJhY2tzIGFyZSBxdWV1ZWQgYmVmb3JlIHRoZSBxdWV1ZSBpcyBmbHVzaGVkLCB0aGV5XG4gICAgLy8gd2lsbCBiZSBwcm9jZXNzZWQgYnkgdGhpcyBmbHVzaCB0aGF0IHdlIGFyZSBzY2hlZHVsaW5nLlxuICAgIGlmIChjdXN0b21TY2hlZHVsZXJGbikge1xuICAgICAgY3VzdG9tU2NoZWR1bGVyRm4oZmx1c2gpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY2hlZHVsZUZsdXNoKCk7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBzZXRTY2hlZHVsZXIoc2NoZWR1bGVGbikge1xuICBjdXN0b21TY2hlZHVsZXJGbiA9IHNjaGVkdWxlRm47XG59XG5cbmZ1bmN0aW9uIHNldEFzYXAoYXNhcEZuKSB7XG4gIGFzYXAgPSBhc2FwRm47XG59XG5cbnZhciBicm93c2VyV2luZG93ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB1bmRlZmluZWQ7XG52YXIgYnJvd3Nlckdsb2JhbCA9IGJyb3dzZXJXaW5kb3cgfHwge307XG52YXIgQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIgPSBicm93c2VyR2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgfHwgYnJvd3Nlckdsb2JhbC5XZWJLaXRNdXRhdGlvbk9ic2VydmVyO1xudmFyIGlzTm9kZSA9IHR5cGVvZiBzZWxmID09PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgKHt9KS50b1N0cmluZy5jYWxsKHByb2Nlc3MpID09PSAnW29iamVjdCBwcm9jZXNzXSc7XG5cbi8vIHRlc3QgZm9yIHdlYiB3b3JrZXIgYnV0IG5vdCBpbiBJRTEwXG52YXIgaXNXb3JrZXIgPSB0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBpbXBvcnRTY3JpcHRzICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgTWVzc2FnZUNoYW5uZWwgIT09ICd1bmRlZmluZWQnO1xuXG4vLyBub2RlXG5mdW5jdGlvbiB1c2VOZXh0VGljaygpIHtcbiAgLy8gbm9kZSB2ZXJzaW9uIDAuMTAueCBkaXNwbGF5cyBhIGRlcHJlY2F0aW9uIHdhcm5pbmcgd2hlbiBuZXh0VGljayBpcyB1c2VkIHJlY3Vyc2l2ZWx5XG4gIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vY3Vqb2pzL3doZW4vaXNzdWVzLzQxMCBmb3IgZGV0YWlsc1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZsdXNoKTtcbiAgfTtcbn1cblxuLy8gdmVydHhcbmZ1bmN0aW9uIHVzZVZlcnR4VGltZXIoKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmVydHhOZXh0KGZsdXNoKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlTXV0YXRpb25PYnNlcnZlcigpIHtcbiAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICB2YXIgb2JzZXJ2ZXIgPSBuZXcgQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIoZmx1c2gpO1xuICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgb2JzZXJ2ZXIub2JzZXJ2ZShub2RlLCB7IGNoYXJhY3RlckRhdGE6IHRydWUgfSk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBub2RlLmRhdGEgPSBpdGVyYXRpb25zID0gKytpdGVyYXRpb25zICUgMjtcbiAgfTtcbn1cblxuLy8gd2ViIHdvcmtlclxuZnVuY3Rpb24gdXNlTWVzc2FnZUNoYW5uZWwoKSB7XG4gIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZmx1c2g7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoMCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZVNldFRpbWVvdXQoKSB7XG4gIC8vIFN0b3JlIHNldFRpbWVvdXQgcmVmZXJlbmNlIHNvIGVzNi1wcm9taXNlIHdpbGwgYmUgdW5hZmZlY3RlZCBieVxuICAvLyBvdGhlciBjb2RlIG1vZGlmeWluZyBzZXRUaW1lb3V0IChsaWtlIHNpbm9uLnVzZUZha2VUaW1lcnMoKSlcbiAgdmFyIGdsb2JhbFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBnbG9iYWxTZXRUaW1lb3V0KGZsdXNoLCAxKTtcbiAgfTtcbn1cblxudmFyIHF1ZXVlID0gbmV3IEFycmF5KDEwMDApO1xuZnVuY3Rpb24gZmx1c2goKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICB2YXIgY2FsbGJhY2sgPSBxdWV1ZVtpXTtcbiAgICB2YXIgYXJnID0gcXVldWVbaSArIDFdO1xuXG4gICAgY2FsbGJhY2soYXJnKTtcblxuICAgIHF1ZXVlW2ldID0gdW5kZWZpbmVkO1xuICAgIHF1ZXVlW2kgKyAxXSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGxlbiA9IDA7XG59XG5cbmZ1bmN0aW9uIGF0dGVtcHRWZXJ0eCgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgciA9IHJlcXVpcmU7XG4gICAgdmFyIHZlcnR4ID0gcigndmVydHgnKTtcbiAgICB2ZXJ0eE5leHQgPSB2ZXJ0eC5ydW5Pbkxvb3AgfHwgdmVydHgucnVuT25Db250ZXh0O1xuICAgIHJldHVybiB1c2VWZXJ0eFRpbWVyKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gdXNlU2V0VGltZW91dCgpO1xuICB9XG59XG5cbnZhciBzY2hlZHVsZUZsdXNoID0gdW5kZWZpbmVkO1xuLy8gRGVjaWRlIHdoYXQgYXN5bmMgbWV0aG9kIHRvIHVzZSB0byB0cmlnZ2VyaW5nIHByb2Nlc3Npbmcgb2YgcXVldWVkIGNhbGxiYWNrczpcbmlmIChpc05vZGUpIHtcbiAgc2NoZWR1bGVGbHVzaCA9IHVzZU5leHRUaWNrKCk7XG59IGVsc2UgaWYgKEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyKSB7XG4gIHNjaGVkdWxlRmx1c2ggPSB1c2VNdXRhdGlvbk9ic2VydmVyKCk7XG59IGVsc2UgaWYgKGlzV29ya2VyKSB7XG4gIHNjaGVkdWxlRmx1c2ggPSB1c2VNZXNzYWdlQ2hhbm5lbCgpO1xufSBlbHNlIGlmIChicm93c2VyV2luZG93ID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicpIHtcbiAgc2NoZWR1bGVGbHVzaCA9IGF0dGVtcHRWZXJ0eCgpO1xufSBlbHNlIHtcbiAgc2NoZWR1bGVGbHVzaCA9IHVzZVNldFRpbWVvdXQoKTtcbn1cblxuZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbikge1xuICB2YXIgX2FyZ3VtZW50cyA9IGFyZ3VtZW50cztcblxuICB2YXIgcGFyZW50ID0gdGhpcztcblxuICB2YXIgY2hpbGQgPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcihub29wKTtcblxuICBpZiAoY2hpbGRbUFJPTUlTRV9JRF0gPT09IHVuZGVmaW5lZCkge1xuICAgIG1ha2VQcm9taXNlKGNoaWxkKTtcbiAgfVxuXG4gIHZhciBfc3RhdGUgPSBwYXJlbnQuX3N0YXRlO1xuXG4gIGlmIChfc3RhdGUpIHtcbiAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNhbGxiYWNrID0gX2FyZ3VtZW50c1tfc3RhdGUgLSAxXTtcbiAgICAgIGFzYXAoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gaW52b2tlQ2FsbGJhY2soX3N0YXRlLCBjaGlsZCwgY2FsbGJhY2ssIHBhcmVudC5fcmVzdWx0KTtcbiAgICAgIH0pO1xuICAgIH0pKCk7XG4gIH0gZWxzZSB7XG4gICAgc3Vic2NyaWJlKHBhcmVudCwgY2hpbGQsIG9uRnVsZmlsbG1lbnQsIG9uUmVqZWN0aW9uKTtcbiAgfVxuXG4gIHJldHVybiBjaGlsZDtcbn1cblxuLyoqXG4gIGBQcm9taXNlLnJlc29sdmVgIHJldHVybnMgYSBwcm9taXNlIHRoYXQgd2lsbCBiZWNvbWUgcmVzb2x2ZWQgd2l0aCB0aGVcbiAgcGFzc2VkIGB2YWx1ZWAuIEl0IGlzIHNob3J0aGFuZCBmb3IgdGhlIGZvbGxvd2luZzpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICByZXNvbHZlKDEpO1xuICB9KTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgIC8vIHZhbHVlID09PSAxXG4gIH0pO1xuICBgYGBcblxuICBJbnN0ZWFkIG9mIHdyaXRpbmcgdGhlIGFib3ZlLCB5b3VyIGNvZGUgbm93IHNpbXBseSBiZWNvbWVzIHRoZSBmb2xsb3dpbmc6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgxKTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgIC8vIHZhbHVlID09PSAxXG4gIH0pO1xuICBgYGBcblxuICBAbWV0aG9kIHJlc29sdmVcbiAgQHN0YXRpY1xuICBAcGFyYW0ge0FueX0gdmFsdWUgdmFsdWUgdGhhdCB0aGUgcmV0dXJuZWQgcHJvbWlzZSB3aWxsIGJlIHJlc29sdmVkIHdpdGhcbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfSBhIHByb21pc2UgdGhhdCB3aWxsIGJlY29tZSBmdWxmaWxsZWQgd2l0aCB0aGUgZ2l2ZW5cbiAgYHZhbHVlYFxuKi9cbmZ1bmN0aW9uIHJlc29sdmUob2JqZWN0KSB7XG4gIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gIHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG5cbiAgaWYgKG9iamVjdCAmJiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QuY29uc3RydWN0b3IgPT09IENvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfVxuXG4gIHZhciBwcm9taXNlID0gbmV3IENvbnN0cnVjdG9yKG5vb3ApO1xuICBfcmVzb2x2ZShwcm9taXNlLCBvYmplY3QpO1xuICByZXR1cm4gcHJvbWlzZTtcbn1cblxudmFyIFBST01JU0VfSUQgPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMTYpO1xuXG5mdW5jdGlvbiBub29wKCkge31cblxudmFyIFBFTkRJTkcgPSB2b2lkIDA7XG52YXIgRlVMRklMTEVEID0gMTtcbnZhciBSRUpFQ1RFRCA9IDI7XG5cbnZhciBHRVRfVEhFTl9FUlJPUiA9IG5ldyBFcnJvck9iamVjdCgpO1xuXG5mdW5jdGlvbiBzZWxmRnVsZmlsbG1lbnQoKSB7XG4gIHJldHVybiBuZXcgVHlwZUVycm9yKFwiWW91IGNhbm5vdCByZXNvbHZlIGEgcHJvbWlzZSB3aXRoIGl0c2VsZlwiKTtcbn1cblxuZnVuY3Rpb24gY2Fubm90UmV0dXJuT3duKCkge1xuICByZXR1cm4gbmV3IFR5cGVFcnJvcignQSBwcm9taXNlcyBjYWxsYmFjayBjYW5ub3QgcmV0dXJuIHRoYXQgc2FtZSBwcm9taXNlLicpO1xufVxuXG5mdW5jdGlvbiBnZXRUaGVuKHByb21pc2UpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gcHJvbWlzZS50aGVuO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIEdFVF9USEVOX0VSUk9SLmVycm9yID0gZXJyb3I7XG4gICAgcmV0dXJuIEdFVF9USEVOX0VSUk9SO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRyeVRoZW4odGhlbiwgdmFsdWUsIGZ1bGZpbGxtZW50SGFuZGxlciwgcmVqZWN0aW9uSGFuZGxlcikge1xuICB0cnkge1xuICAgIHRoZW4uY2FsbCh2YWx1ZSwgZnVsZmlsbG1lbnRIYW5kbGVyLCByZWplY3Rpb25IYW5kbGVyKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUZvcmVpZ25UaGVuYWJsZShwcm9taXNlLCB0aGVuYWJsZSwgdGhlbikge1xuICBhc2FwKGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgdmFyIHNlYWxlZCA9IGZhbHNlO1xuICAgIHZhciBlcnJvciA9IHRyeVRoZW4odGhlbiwgdGhlbmFibGUsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKHNlYWxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZWFsZWQgPSB0cnVlO1xuICAgICAgaWYgKHRoZW5hYmxlICE9PSB2YWx1ZSkge1xuICAgICAgICBfcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmdWxmaWxsKHByb21pc2UsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICBpZiAoc2VhbGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNlYWxlZCA9IHRydWU7XG5cbiAgICAgIF9yZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICB9LCAnU2V0dGxlOiAnICsgKHByb21pc2UuX2xhYmVsIHx8ICcgdW5rbm93biBwcm9taXNlJykpO1xuXG4gICAgaWYgKCFzZWFsZWQgJiYgZXJyb3IpIHtcbiAgICAgIHNlYWxlZCA9IHRydWU7XG4gICAgICBfcmVqZWN0KHByb21pc2UsIGVycm9yKTtcbiAgICB9XG4gIH0sIHByb21pc2UpO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVPd25UaGVuYWJsZShwcm9taXNlLCB0aGVuYWJsZSkge1xuICBpZiAodGhlbmFibGUuX3N0YXRlID09PSBGVUxGSUxMRUQpIHtcbiAgICBmdWxmaWxsKHByb21pc2UsIHRoZW5hYmxlLl9yZXN1bHQpO1xuICB9IGVsc2UgaWYgKHRoZW5hYmxlLl9zdGF0ZSA9PT0gUkVKRUNURUQpIHtcbiAgICBfcmVqZWN0KHByb21pc2UsIHRoZW5hYmxlLl9yZXN1bHQpO1xuICB9IGVsc2Uge1xuICAgIHN1YnNjcmliZSh0aGVuYWJsZSwgdW5kZWZpbmVkLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiBfcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgcmV0dXJuIF9yZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVNYXliZVRoZW5hYmxlKHByb21pc2UsIG1heWJlVGhlbmFibGUsIHRoZW4kJCkge1xuICBpZiAobWF5YmVUaGVuYWJsZS5jb25zdHJ1Y3RvciA9PT0gcHJvbWlzZS5jb25zdHJ1Y3RvciAmJiB0aGVuJCQgPT09IHRoZW4gJiYgbWF5YmVUaGVuYWJsZS5jb25zdHJ1Y3Rvci5yZXNvbHZlID09PSByZXNvbHZlKSB7XG4gICAgaGFuZGxlT3duVGhlbmFibGUocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHRoZW4kJCA9PT0gR0VUX1RIRU5fRVJST1IpIHtcbiAgICAgIF9yZWplY3QocHJvbWlzZSwgR0VUX1RIRU5fRVJST1IuZXJyb3IpO1xuICAgIH0gZWxzZSBpZiAodGhlbiQkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGZ1bGZpbGwocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSk7XG4gICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKHRoZW4kJCkpIHtcbiAgICAgIGhhbmRsZUZvcmVpZ25UaGVuYWJsZShwcm9taXNlLCBtYXliZVRoZW5hYmxlLCB0aGVuJCQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmdWxmaWxsKHByb21pc2UsIG1heWJlVGhlbmFibGUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBfcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSkge1xuICBpZiAocHJvbWlzZSA9PT0gdmFsdWUpIHtcbiAgICBfcmVqZWN0KHByb21pc2UsIHNlbGZGdWxmaWxsbWVudCgpKTtcbiAgfSBlbHNlIGlmIChvYmplY3RPckZ1bmN0aW9uKHZhbHVlKSkge1xuICAgIGhhbmRsZU1heWJlVGhlbmFibGUocHJvbWlzZSwgdmFsdWUsIGdldFRoZW4odmFsdWUpKTtcbiAgfSBlbHNlIHtcbiAgICBmdWxmaWxsKHByb21pc2UsIHZhbHVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwdWJsaXNoUmVqZWN0aW9uKHByb21pc2UpIHtcbiAgaWYgKHByb21pc2UuX29uZXJyb3IpIHtcbiAgICBwcm9taXNlLl9vbmVycm9yKHByb21pc2UuX3Jlc3VsdCk7XG4gIH1cblxuICBwdWJsaXNoKHByb21pc2UpO1xufVxuXG5mdW5jdGlvbiBmdWxmaWxsKHByb21pc2UsIHZhbHVlKSB7XG4gIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gUEVORElORykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHByb21pc2UuX3Jlc3VsdCA9IHZhbHVlO1xuICBwcm9taXNlLl9zdGF0ZSA9IEZVTEZJTExFRDtcblxuICBpZiAocHJvbWlzZS5fc3Vic2NyaWJlcnMubGVuZ3RoICE9PSAwKSB7XG4gICAgYXNhcChwdWJsaXNoLCBwcm9taXNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfcmVqZWN0KHByb21pc2UsIHJlYXNvbikge1xuICBpZiAocHJvbWlzZS5fc3RhdGUgIT09IFBFTkRJTkcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcHJvbWlzZS5fc3RhdGUgPSBSRUpFQ1RFRDtcbiAgcHJvbWlzZS5fcmVzdWx0ID0gcmVhc29uO1xuXG4gIGFzYXAocHVibGlzaFJlamVjdGlvbiwgcHJvbWlzZSk7XG59XG5cbmZ1bmN0aW9uIHN1YnNjcmliZShwYXJlbnQsIGNoaWxkLCBvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbikge1xuICB2YXIgX3N1YnNjcmliZXJzID0gcGFyZW50Ll9zdWJzY3JpYmVycztcbiAgdmFyIGxlbmd0aCA9IF9zdWJzY3JpYmVycy5sZW5ndGg7XG5cbiAgcGFyZW50Ll9vbmVycm9yID0gbnVsbDtcblxuICBfc3Vic2NyaWJlcnNbbGVuZ3RoXSA9IGNoaWxkO1xuICBfc3Vic2NyaWJlcnNbbGVuZ3RoICsgRlVMRklMTEVEXSA9IG9uRnVsZmlsbG1lbnQ7XG4gIF9zdWJzY3JpYmVyc1tsZW5ndGggKyBSRUpFQ1RFRF0gPSBvblJlamVjdGlvbjtcblxuICBpZiAobGVuZ3RoID09PSAwICYmIHBhcmVudC5fc3RhdGUpIHtcbiAgICBhc2FwKHB1Ymxpc2gsIHBhcmVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHVibGlzaChwcm9taXNlKSB7XG4gIHZhciBzdWJzY3JpYmVycyA9IHByb21pc2UuX3N1YnNjcmliZXJzO1xuICB2YXIgc2V0dGxlZCA9IHByb21pc2UuX3N0YXRlO1xuXG4gIGlmIChzdWJzY3JpYmVycy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgY2hpbGQgPSB1bmRlZmluZWQsXG4gICAgICBjYWxsYmFjayA9IHVuZGVmaW5lZCxcbiAgICAgIGRldGFpbCA9IHByb21pc2UuX3Jlc3VsdDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN1YnNjcmliZXJzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgY2hpbGQgPSBzdWJzY3JpYmVyc1tpXTtcbiAgICBjYWxsYmFjayA9IHN1YnNjcmliZXJzW2kgKyBzZXR0bGVkXTtcblxuICAgIGlmIChjaGlsZCkge1xuICAgICAgaW52b2tlQ2FsbGJhY2soc2V0dGxlZCwgY2hpbGQsIGNhbGxiYWNrLCBkZXRhaWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsYmFjayhkZXRhaWwpO1xuICAgIH1cbiAgfVxuXG4gIHByb21pc2UuX3N1YnNjcmliZXJzLmxlbmd0aCA9IDA7XG59XG5cbmZ1bmN0aW9uIEVycm9yT2JqZWN0KCkge1xuICB0aGlzLmVycm9yID0gbnVsbDtcbn1cblxudmFyIFRSWV9DQVRDSF9FUlJPUiA9IG5ldyBFcnJvck9iamVjdCgpO1xuXG5mdW5jdGlvbiB0cnlDYXRjaChjYWxsYmFjaywgZGV0YWlsKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKGRldGFpbCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBUUllfQ0FUQ0hfRVJST1IuZXJyb3IgPSBlO1xuICAgIHJldHVybiBUUllfQ0FUQ0hfRVJST1I7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW52b2tlQ2FsbGJhY2soc2V0dGxlZCwgcHJvbWlzZSwgY2FsbGJhY2ssIGRldGFpbCkge1xuICB2YXIgaGFzQ2FsbGJhY2sgPSBpc0Z1bmN0aW9uKGNhbGxiYWNrKSxcbiAgICAgIHZhbHVlID0gdW5kZWZpbmVkLFxuICAgICAgZXJyb3IgPSB1bmRlZmluZWQsXG4gICAgICBzdWNjZWVkZWQgPSB1bmRlZmluZWQsXG4gICAgICBmYWlsZWQgPSB1bmRlZmluZWQ7XG5cbiAgaWYgKGhhc0NhbGxiYWNrKSB7XG4gICAgdmFsdWUgPSB0cnlDYXRjaChjYWxsYmFjaywgZGV0YWlsKTtcblxuICAgIGlmICh2YWx1ZSA9PT0gVFJZX0NBVENIX0VSUk9SKSB7XG4gICAgICBmYWlsZWQgPSB0cnVlO1xuICAgICAgZXJyb3IgPSB2YWx1ZS5lcnJvcjtcbiAgICAgIHZhbHVlID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3VjY2VlZGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAocHJvbWlzZSA9PT0gdmFsdWUpIHtcbiAgICAgIF9yZWplY3QocHJvbWlzZSwgY2Fubm90UmV0dXJuT3duKCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YWx1ZSA9IGRldGFpbDtcbiAgICBzdWNjZWVkZWQgPSB0cnVlO1xuICB9XG5cbiAgaWYgKHByb21pc2UuX3N0YXRlICE9PSBQRU5ESU5HKSB7XG4gICAgLy8gbm9vcFxuICB9IGVsc2UgaWYgKGhhc0NhbGxiYWNrICYmIHN1Y2NlZWRlZCkge1xuICAgICAgX3Jlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoZmFpbGVkKSB7XG4gICAgICBfcmVqZWN0KHByb21pc2UsIGVycm9yKTtcbiAgICB9IGVsc2UgaWYgKHNldHRsZWQgPT09IEZVTEZJTExFRCkge1xuICAgICAgZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChzZXR0bGVkID09PSBSRUpFQ1RFRCkge1xuICAgICAgX3JlamVjdChwcm9taXNlLCB2YWx1ZSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpbml0aWFsaXplUHJvbWlzZShwcm9taXNlLCByZXNvbHZlcikge1xuICB0cnkge1xuICAgIHJlc29sdmVyKGZ1bmN0aW9uIHJlc29sdmVQcm9taXNlKHZhbHVlKSB7XG4gICAgICBfcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgfSwgZnVuY3Rpb24gcmVqZWN0UHJvbWlzZShyZWFzb24pIHtcbiAgICAgIF9yZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICB9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIF9yZWplY3QocHJvbWlzZSwgZSk7XG4gIH1cbn1cblxudmFyIGlkID0gMDtcbmZ1bmN0aW9uIG5leHRJZCgpIHtcbiAgcmV0dXJuIGlkKys7XG59XG5cbmZ1bmN0aW9uIG1ha2VQcm9taXNlKHByb21pc2UpIHtcbiAgcHJvbWlzZVtQUk9NSVNFX0lEXSA9IGlkKys7XG4gIHByb21pc2UuX3N0YXRlID0gdW5kZWZpbmVkO1xuICBwcm9taXNlLl9yZXN1bHQgPSB1bmRlZmluZWQ7XG4gIHByb21pc2UuX3N1YnNjcmliZXJzID0gW107XG59XG5cbmZ1bmN0aW9uIEVudW1lcmF0b3IoQ29uc3RydWN0b3IsIGlucHV0KSB7XG4gIHRoaXMuX2luc3RhbmNlQ29uc3RydWN0b3IgPSBDb25zdHJ1Y3RvcjtcbiAgdGhpcy5wcm9taXNlID0gbmV3IENvbnN0cnVjdG9yKG5vb3ApO1xuXG4gIGlmICghdGhpcy5wcm9taXNlW1BST01JU0VfSURdKSB7XG4gICAgbWFrZVByb21pc2UodGhpcy5wcm9taXNlKTtcbiAgfVxuXG4gIGlmIChpc0FycmF5KGlucHV0KSkge1xuICAgIHRoaXMuX2lucHV0ID0gaW5wdXQ7XG4gICAgdGhpcy5sZW5ndGggPSBpbnB1dC5sZW5ndGg7XG4gICAgdGhpcy5fcmVtYWluaW5nID0gaW5wdXQubGVuZ3RoO1xuXG4gICAgdGhpcy5fcmVzdWx0ID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKTtcblxuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZnVsZmlsbCh0aGlzLnByb21pc2UsIHRoaXMuX3Jlc3VsdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubGVuZ3RoID0gdGhpcy5sZW5ndGggfHwgMDtcbiAgICAgIHRoaXMuX2VudW1lcmF0ZSgpO1xuICAgICAgaWYgKHRoaXMuX3JlbWFpbmluZyA9PT0gMCkge1xuICAgICAgICBmdWxmaWxsKHRoaXMucHJvbWlzZSwgdGhpcy5fcmVzdWx0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgX3JlamVjdCh0aGlzLnByb21pc2UsIHZhbGlkYXRpb25FcnJvcigpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0aW9uRXJyb3IoKSB7XG4gIHJldHVybiBuZXcgRXJyb3IoJ0FycmF5IE1ldGhvZHMgbXVzdCBiZSBwcm92aWRlZCBhbiBBcnJheScpO1xufTtcblxuRW51bWVyYXRvci5wcm90b3R5cGUuX2VudW1lcmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICB2YXIgX2lucHV0ID0gdGhpcy5faW5wdXQ7XG5cbiAgZm9yICh2YXIgaSA9IDA7IHRoaXMuX3N0YXRlID09PSBQRU5ESU5HICYmIGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHRoaXMuX2VhY2hFbnRyeShfaW5wdXRbaV0sIGkpO1xuICB9XG59O1xuXG5FbnVtZXJhdG9yLnByb3RvdHlwZS5fZWFjaEVudHJ5ID0gZnVuY3Rpb24gKGVudHJ5LCBpKSB7XG4gIHZhciBjID0gdGhpcy5faW5zdGFuY2VDb25zdHJ1Y3RvcjtcbiAgdmFyIHJlc29sdmUkJCA9IGMucmVzb2x2ZTtcblxuICBpZiAocmVzb2x2ZSQkID09PSByZXNvbHZlKSB7XG4gICAgdmFyIF90aGVuID0gZ2V0VGhlbihlbnRyeSk7XG5cbiAgICBpZiAoX3RoZW4gPT09IHRoZW4gJiYgZW50cnkuX3N0YXRlICE9PSBQRU5ESU5HKSB7XG4gICAgICB0aGlzLl9zZXR0bGVkQXQoZW50cnkuX3N0YXRlLCBpLCBlbnRyeS5fcmVzdWx0KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBfdGhlbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5fcmVtYWluaW5nLS07XG4gICAgICB0aGlzLl9yZXN1bHRbaV0gPSBlbnRyeTtcbiAgICB9IGVsc2UgaWYgKGMgPT09IFByb21pc2UpIHtcbiAgICAgIHZhciBwcm9taXNlID0gbmV3IGMobm9vcCk7XG4gICAgICBoYW5kbGVNYXliZVRoZW5hYmxlKHByb21pc2UsIGVudHJ5LCBfdGhlbik7XG4gICAgICB0aGlzLl93aWxsU2V0dGxlQXQocHJvbWlzZSwgaSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3dpbGxTZXR0bGVBdChuZXcgYyhmdW5jdGlvbiAocmVzb2x2ZSQkKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlJCQoZW50cnkpO1xuICAgICAgfSksIGkpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aGlzLl93aWxsU2V0dGxlQXQocmVzb2x2ZSQkKGVudHJ5KSwgaSk7XG4gIH1cbn07XG5cbkVudW1lcmF0b3IucHJvdG90eXBlLl9zZXR0bGVkQXQgPSBmdW5jdGlvbiAoc3RhdGUsIGksIHZhbHVlKSB7XG4gIHZhciBwcm9taXNlID0gdGhpcy5wcm9taXNlO1xuXG4gIGlmIChwcm9taXNlLl9zdGF0ZSA9PT0gUEVORElORykge1xuICAgIHRoaXMuX3JlbWFpbmluZy0tO1xuXG4gICAgaWYgKHN0YXRlID09PSBSRUpFQ1RFRCkge1xuICAgICAgX3JlamVjdChwcm9taXNlLCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3Jlc3VsdFtpXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLl9yZW1haW5pbmcgPT09IDApIHtcbiAgICBmdWxmaWxsKHByb21pc2UsIHRoaXMuX3Jlc3VsdCk7XG4gIH1cbn07XG5cbkVudW1lcmF0b3IucHJvdG90eXBlLl93aWxsU2V0dGxlQXQgPSBmdW5jdGlvbiAocHJvbWlzZSwgaSkge1xuICB2YXIgZW51bWVyYXRvciA9IHRoaXM7XG5cbiAgc3Vic2NyaWJlKHByb21pc2UsIHVuZGVmaW5lZCwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIGVudW1lcmF0b3IuX3NldHRsZWRBdChGVUxGSUxMRUQsIGksIHZhbHVlKTtcbiAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHJldHVybiBlbnVtZXJhdG9yLl9zZXR0bGVkQXQoUkVKRUNURUQsIGksIHJlYXNvbik7XG4gIH0pO1xufTtcblxuLyoqXG4gIGBQcm9taXNlLmFsbGAgYWNjZXB0cyBhbiBhcnJheSBvZiBwcm9taXNlcywgYW5kIHJldHVybnMgYSBuZXcgcHJvbWlzZSB3aGljaFxuICBpcyBmdWxmaWxsZWQgd2l0aCBhbiBhcnJheSBvZiBmdWxmaWxsbWVudCB2YWx1ZXMgZm9yIHRoZSBwYXNzZWQgcHJvbWlzZXMsIG9yXG4gIHJlamVjdGVkIHdpdGggdGhlIHJlYXNvbiBvZiB0aGUgZmlyc3QgcGFzc2VkIHByb21pc2UgdG8gYmUgcmVqZWN0ZWQuIEl0IGNhc3RzIGFsbFxuICBlbGVtZW50cyBvZiB0aGUgcGFzc2VkIGl0ZXJhYmxlIHRvIHByb21pc2VzIGFzIGl0IHJ1bnMgdGhpcyBhbGdvcml0aG0uXG5cbiAgRXhhbXBsZTpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlMSA9IHJlc29sdmUoMSk7XG4gIGxldCBwcm9taXNlMiA9IHJlc29sdmUoMik7XG4gIGxldCBwcm9taXNlMyA9IHJlc29sdmUoMyk7XG4gIGxldCBwcm9taXNlcyA9IFsgcHJvbWlzZTEsIHByb21pc2UyLCBwcm9taXNlMyBdO1xuXG4gIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uKGFycmF5KXtcbiAgICAvLyBUaGUgYXJyYXkgaGVyZSB3b3VsZCBiZSBbIDEsIDIsIDMgXTtcbiAgfSk7XG4gIGBgYFxuXG4gIElmIGFueSBvZiB0aGUgYHByb21pc2VzYCBnaXZlbiB0byBgYWxsYCBhcmUgcmVqZWN0ZWQsIHRoZSBmaXJzdCBwcm9taXNlXG4gIHRoYXQgaXMgcmVqZWN0ZWQgd2lsbCBiZSBnaXZlbiBhcyBhbiBhcmd1bWVudCB0byB0aGUgcmV0dXJuZWQgcHJvbWlzZXMnc1xuICByZWplY3Rpb24gaGFuZGxlci4gRm9yIGV4YW1wbGU6XG5cbiAgRXhhbXBsZTpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlMSA9IHJlc29sdmUoMSk7XG4gIGxldCBwcm9taXNlMiA9IHJlamVjdChuZXcgRXJyb3IoXCIyXCIpKTtcbiAgbGV0IHByb21pc2UzID0gcmVqZWN0KG5ldyBFcnJvcihcIjNcIikpO1xuICBsZXQgcHJvbWlzZXMgPSBbIHByb21pc2UxLCBwcm9taXNlMiwgcHJvbWlzZTMgXTtcblxuICBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbihhcnJheSl7XG4gICAgLy8gQ29kZSBoZXJlIG5ldmVyIHJ1bnMgYmVjYXVzZSB0aGVyZSBhcmUgcmVqZWN0ZWQgcHJvbWlzZXMhXG4gIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgLy8gZXJyb3IubWVzc2FnZSA9PT0gXCIyXCJcbiAgfSk7XG4gIGBgYFxuXG4gIEBtZXRob2QgYWxsXG4gIEBzdGF0aWNcbiAgQHBhcmFtIHtBcnJheX0gZW50cmllcyBhcnJheSBvZiBwcm9taXNlc1xuICBAcGFyYW0ge1N0cmluZ30gbGFiZWwgb3B0aW9uYWwgc3RyaW5nIGZvciBsYWJlbGluZyB0aGUgcHJvbWlzZS5cbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHRoYXQgaXMgZnVsZmlsbGVkIHdoZW4gYWxsIGBwcm9taXNlc2AgaGF2ZSBiZWVuXG4gIGZ1bGZpbGxlZCwgb3IgcmVqZWN0ZWQgaWYgYW55IG9mIHRoZW0gYmVjb21lIHJlamVjdGVkLlxuICBAc3RhdGljXG4qL1xuZnVuY3Rpb24gYWxsKGVudHJpZXMpIHtcbiAgcmV0dXJuIG5ldyBFbnVtZXJhdG9yKHRoaXMsIGVudHJpZXMpLnByb21pc2U7XG59XG5cbi8qKlxuICBgUHJvbWlzZS5yYWNlYCByZXR1cm5zIGEgbmV3IHByb21pc2Ugd2hpY2ggaXMgc2V0dGxlZCBpbiB0aGUgc2FtZSB3YXkgYXMgdGhlXG4gIGZpcnN0IHBhc3NlZCBwcm9taXNlIHRvIHNldHRsZS5cblxuICBFeGFtcGxlOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UxID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICByZXNvbHZlKCdwcm9taXNlIDEnKTtcbiAgICB9LCAyMDApO1xuICB9KTtcblxuICBsZXQgcHJvbWlzZTIgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHJlc29sdmUoJ3Byb21pc2UgMicpO1xuICAgIH0sIDEwMCk7XG4gIH0pO1xuXG4gIFByb21pc2UucmFjZShbcHJvbWlzZTEsIHByb21pc2UyXSkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xuICAgIC8vIHJlc3VsdCA9PT0gJ3Byb21pc2UgMicgYmVjYXVzZSBpdCB3YXMgcmVzb2x2ZWQgYmVmb3JlIHByb21pc2UxXG4gICAgLy8gd2FzIHJlc29sdmVkLlxuICB9KTtcbiAgYGBgXG5cbiAgYFByb21pc2UucmFjZWAgaXMgZGV0ZXJtaW5pc3RpYyBpbiB0aGF0IG9ubHkgdGhlIHN0YXRlIG9mIHRoZSBmaXJzdFxuICBzZXR0bGVkIHByb21pc2UgbWF0dGVycy4gRm9yIGV4YW1wbGUsIGV2ZW4gaWYgb3RoZXIgcHJvbWlzZXMgZ2l2ZW4gdG8gdGhlXG4gIGBwcm9taXNlc2AgYXJyYXkgYXJndW1lbnQgYXJlIHJlc29sdmVkLCBidXQgdGhlIGZpcnN0IHNldHRsZWQgcHJvbWlzZSBoYXNcbiAgYmVjb21lIHJlamVjdGVkIGJlZm9yZSB0aGUgb3RoZXIgcHJvbWlzZXMgYmVjYW1lIGZ1bGZpbGxlZCwgdGhlIHJldHVybmVkXG4gIHByb21pc2Ugd2lsbCBiZWNvbWUgcmVqZWN0ZWQ6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZTEgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHJlc29sdmUoJ3Byb21pc2UgMScpO1xuICAgIH0sIDIwMCk7XG4gIH0pO1xuXG4gIGxldCBwcm9taXNlMiA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgcmVqZWN0KG5ldyBFcnJvcigncHJvbWlzZSAyJykpO1xuICAgIH0sIDEwMCk7XG4gIH0pO1xuXG4gIFByb21pc2UucmFjZShbcHJvbWlzZTEsIHByb21pc2UyXSkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xuICAgIC8vIENvZGUgaGVyZSBuZXZlciBydW5zXG4gIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgLy8gcmVhc29uLm1lc3NhZ2UgPT09ICdwcm9taXNlIDInIGJlY2F1c2UgcHJvbWlzZSAyIGJlY2FtZSByZWplY3RlZCBiZWZvcmVcbiAgICAvLyBwcm9taXNlIDEgYmVjYW1lIGZ1bGZpbGxlZFxuICB9KTtcbiAgYGBgXG5cbiAgQW4gZXhhbXBsZSByZWFsLXdvcmxkIHVzZSBjYXNlIGlzIGltcGxlbWVudGluZyB0aW1lb3V0czpcblxuICBgYGBqYXZhc2NyaXB0XG4gIFByb21pc2UucmFjZShbYWpheCgnZm9vLmpzb24nKSwgdGltZW91dCg1MDAwKV0pXG4gIGBgYFxuXG4gIEBtZXRob2QgcmFjZVxuICBAc3RhdGljXG4gIEBwYXJhbSB7QXJyYXl9IHByb21pc2VzIGFycmF5IG9mIHByb21pc2VzIHRvIG9ic2VydmVcbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfSBhIHByb21pc2Ugd2hpY2ggc2V0dGxlcyBpbiB0aGUgc2FtZSB3YXkgYXMgdGhlIGZpcnN0IHBhc3NlZFxuICBwcm9taXNlIHRvIHNldHRsZS5cbiovXG5mdW5jdGlvbiByYWNlKGVudHJpZXMpIHtcbiAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcblxuICBpZiAoIWlzQXJyYXkoZW50cmllcykpIHtcbiAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKGZ1bmN0aW9uIChfLCByZWplY3QpIHtcbiAgICAgIHJldHVybiByZWplY3QobmV3IFR5cGVFcnJvcignWW91IG11c3QgcGFzcyBhbiBhcnJheSB0byByYWNlLicpKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBsZW5ndGggPSBlbnRyaWVzLmxlbmd0aDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgQ29uc3RydWN0b3IucmVzb2x2ZShlbnRyaWVzW2ldKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gIGBQcm9taXNlLnJlamVjdGAgcmV0dXJucyBhIHByb21pc2UgcmVqZWN0ZWQgd2l0aCB0aGUgcGFzc2VkIGByZWFzb25gLlxuICBJdCBpcyBzaG9ydGhhbmQgZm9yIHRoZSBmb2xsb3dpbmc6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgcmVqZWN0KG5ldyBFcnJvcignV0hPT1BTJykpO1xuICB9KTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgIC8vIENvZGUgaGVyZSBkb2Vzbid0IHJ1biBiZWNhdXNlIHRoZSBwcm9taXNlIGlzIHJlamVjdGVkIVxuICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgIC8vIHJlYXNvbi5tZXNzYWdlID09PSAnV0hPT1BTJ1xuICB9KTtcbiAgYGBgXG5cbiAgSW5zdGVhZCBvZiB3cml0aW5nIHRoZSBhYm92ZSwgeW91ciBjb2RlIG5vdyBzaW1wbHkgYmVjb21lcyB0aGUgZm9sbG93aW5nOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UgPSBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ1dIT09QUycpKTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgIC8vIENvZGUgaGVyZSBkb2Vzbid0IHJ1biBiZWNhdXNlIHRoZSBwcm9taXNlIGlzIHJlamVjdGVkIVxuICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgIC8vIHJlYXNvbi5tZXNzYWdlID09PSAnV0hPT1BTJ1xuICB9KTtcbiAgYGBgXG5cbiAgQG1ldGhvZCByZWplY3RcbiAgQHN0YXRpY1xuICBAcGFyYW0ge0FueX0gcmVhc29uIHZhbHVlIHRoYXQgdGhlIHJldHVybmVkIHByb21pc2Ugd2lsbCBiZSByZWplY3RlZCB3aXRoLlxuICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gIEByZXR1cm4ge1Byb21pc2V9IGEgcHJvbWlzZSByZWplY3RlZCB3aXRoIHRoZSBnaXZlbiBgcmVhc29uYC5cbiovXG5mdW5jdGlvbiByZWplY3QocmVhc29uKSB7XG4gIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gIHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG4gIHZhciBwcm9taXNlID0gbmV3IENvbnN0cnVjdG9yKG5vb3ApO1xuICBfcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gIHJldHVybiBwcm9taXNlO1xufVxuXG5mdW5jdGlvbiBuZWVkc1Jlc29sdmVyKCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdZb3UgbXVzdCBwYXNzIGEgcmVzb2x2ZXIgZnVuY3Rpb24gYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHRoZSBwcm9taXNlIGNvbnN0cnVjdG9yJyk7XG59XG5cbmZ1bmN0aW9uIG5lZWRzTmV3KCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmFpbGVkIHRvIGNvbnN0cnVjdCAnUHJvbWlzZSc6IFBsZWFzZSB1c2UgdGhlICduZXcnIG9wZXJhdG9yLCB0aGlzIG9iamVjdCBjb25zdHJ1Y3RvciBjYW5ub3QgYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb24uXCIpO1xufVxuXG4vKipcbiAgUHJvbWlzZSBvYmplY3RzIHJlcHJlc2VudCB0aGUgZXZlbnR1YWwgcmVzdWx0IG9mIGFuIGFzeW5jaHJvbm91cyBvcGVyYXRpb24uIFRoZVxuICBwcmltYXJ5IHdheSBvZiBpbnRlcmFjdGluZyB3aXRoIGEgcHJvbWlzZSBpcyB0aHJvdWdoIGl0cyBgdGhlbmAgbWV0aG9kLCB3aGljaFxuICByZWdpc3RlcnMgY2FsbGJhY2tzIHRvIHJlY2VpdmUgZWl0aGVyIGEgcHJvbWlzZSdzIGV2ZW50dWFsIHZhbHVlIG9yIHRoZSByZWFzb25cbiAgd2h5IHRoZSBwcm9taXNlIGNhbm5vdCBiZSBmdWxmaWxsZWQuXG5cbiAgVGVybWlub2xvZ3lcbiAgLS0tLS0tLS0tLS1cblxuICAtIGBwcm9taXNlYCBpcyBhbiBvYmplY3Qgb3IgZnVuY3Rpb24gd2l0aCBhIGB0aGVuYCBtZXRob2Qgd2hvc2UgYmVoYXZpb3IgY29uZm9ybXMgdG8gdGhpcyBzcGVjaWZpY2F0aW9uLlxuICAtIGB0aGVuYWJsZWAgaXMgYW4gb2JqZWN0IG9yIGZ1bmN0aW9uIHRoYXQgZGVmaW5lcyBhIGB0aGVuYCBtZXRob2QuXG4gIC0gYHZhbHVlYCBpcyBhbnkgbGVnYWwgSmF2YVNjcmlwdCB2YWx1ZSAoaW5jbHVkaW5nIHVuZGVmaW5lZCwgYSB0aGVuYWJsZSwgb3IgYSBwcm9taXNlKS5cbiAgLSBgZXhjZXB0aW9uYCBpcyBhIHZhbHVlIHRoYXQgaXMgdGhyb3duIHVzaW5nIHRoZSB0aHJvdyBzdGF0ZW1lbnQuXG4gIC0gYHJlYXNvbmAgaXMgYSB2YWx1ZSB0aGF0IGluZGljYXRlcyB3aHkgYSBwcm9taXNlIHdhcyByZWplY3RlZC5cbiAgLSBgc2V0dGxlZGAgdGhlIGZpbmFsIHJlc3Rpbmcgc3RhdGUgb2YgYSBwcm9taXNlLCBmdWxmaWxsZWQgb3IgcmVqZWN0ZWQuXG5cbiAgQSBwcm9taXNlIGNhbiBiZSBpbiBvbmUgb2YgdGhyZWUgc3RhdGVzOiBwZW5kaW5nLCBmdWxmaWxsZWQsIG9yIHJlamVjdGVkLlxuXG4gIFByb21pc2VzIHRoYXQgYXJlIGZ1bGZpbGxlZCBoYXZlIGEgZnVsZmlsbG1lbnQgdmFsdWUgYW5kIGFyZSBpbiB0aGUgZnVsZmlsbGVkXG4gIHN0YXRlLiAgUHJvbWlzZXMgdGhhdCBhcmUgcmVqZWN0ZWQgaGF2ZSBhIHJlamVjdGlvbiByZWFzb24gYW5kIGFyZSBpbiB0aGVcbiAgcmVqZWN0ZWQgc3RhdGUuICBBIGZ1bGZpbGxtZW50IHZhbHVlIGlzIG5ldmVyIGEgdGhlbmFibGUuXG5cbiAgUHJvbWlzZXMgY2FuIGFsc28gYmUgc2FpZCB0byAqcmVzb2x2ZSogYSB2YWx1ZS4gIElmIHRoaXMgdmFsdWUgaXMgYWxzbyBhXG4gIHByb21pc2UsIHRoZW4gdGhlIG9yaWdpbmFsIHByb21pc2UncyBzZXR0bGVkIHN0YXRlIHdpbGwgbWF0Y2ggdGhlIHZhbHVlJ3NcbiAgc2V0dGxlZCBzdGF0ZS4gIFNvIGEgcHJvbWlzZSB0aGF0ICpyZXNvbHZlcyogYSBwcm9taXNlIHRoYXQgcmVqZWN0cyB3aWxsXG4gIGl0c2VsZiByZWplY3QsIGFuZCBhIHByb21pc2UgdGhhdCAqcmVzb2x2ZXMqIGEgcHJvbWlzZSB0aGF0IGZ1bGZpbGxzIHdpbGxcbiAgaXRzZWxmIGZ1bGZpbGwuXG5cblxuICBCYXNpYyBVc2FnZTpcbiAgLS0tLS0tLS0tLS0tXG5cbiAgYGBganNcbiAgbGV0IHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAvLyBvbiBzdWNjZXNzXG4gICAgcmVzb2x2ZSh2YWx1ZSk7XG5cbiAgICAvLyBvbiBmYWlsdXJlXG4gICAgcmVqZWN0KHJlYXNvbik7XG4gIH0pO1xuXG4gIHByb21pc2UudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgIC8vIG9uIGZ1bGZpbGxtZW50XG4gIH0sIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgIC8vIG9uIHJlamVjdGlvblxuICB9KTtcbiAgYGBgXG5cbiAgQWR2YW5jZWQgVXNhZ2U6XG4gIC0tLS0tLS0tLS0tLS0tLVxuXG4gIFByb21pc2VzIHNoaW5lIHdoZW4gYWJzdHJhY3RpbmcgYXdheSBhc3luY2hyb25vdXMgaW50ZXJhY3Rpb25zIHN1Y2ggYXNcbiAgYFhNTEh0dHBSZXF1ZXN0YHMuXG5cbiAgYGBganNcbiAgZnVuY3Rpb24gZ2V0SlNPTih1cmwpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICAgIGxldCB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgICAgeGhyLm9wZW4oJ0dFVCcsIHVybCk7XG4gICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gaGFuZGxlcjtcbiAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnanNvbic7XG4gICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQWNjZXB0JywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICAgIHhoci5zZW5kKCk7XG5cbiAgICAgIGZ1bmN0aW9uIGhhbmRsZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IHRoaXMuRE9ORSkge1xuICAgICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgICByZXNvbHZlKHRoaXMucmVzcG9uc2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdnZXRKU09OOiBgJyArIHVybCArICdgIGZhaWxlZCB3aXRoIHN0YXR1czogWycgKyB0aGlzLnN0YXR1cyArICddJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIGdldEpTT04oJy9wb3N0cy5qc29uJykudGhlbihmdW5jdGlvbihqc29uKSB7XG4gICAgLy8gb24gZnVsZmlsbG1lbnRcbiAgfSwgZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgLy8gb24gcmVqZWN0aW9uXG4gIH0pO1xuICBgYGBcblxuICBVbmxpa2UgY2FsbGJhY2tzLCBwcm9taXNlcyBhcmUgZ3JlYXQgY29tcG9zYWJsZSBwcmltaXRpdmVzLlxuXG4gIGBgYGpzXG4gIFByb21pc2UuYWxsKFtcbiAgICBnZXRKU09OKCcvcG9zdHMnKSxcbiAgICBnZXRKU09OKCcvY29tbWVudHMnKVxuICBdKS50aGVuKGZ1bmN0aW9uKHZhbHVlcyl7XG4gICAgdmFsdWVzWzBdIC8vID0+IHBvc3RzSlNPTlxuICAgIHZhbHVlc1sxXSAvLyA9PiBjb21tZW50c0pTT05cblxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH0pO1xuICBgYGBcblxuICBAY2xhc3MgUHJvbWlzZVxuICBAcGFyYW0ge2Z1bmN0aW9ufSByZXNvbHZlclxuICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gIEBjb25zdHJ1Y3RvclxuKi9cbmZ1bmN0aW9uIFByb21pc2UocmVzb2x2ZXIpIHtcbiAgdGhpc1tQUk9NSVNFX0lEXSA9IG5leHRJZCgpO1xuICB0aGlzLl9yZXN1bHQgPSB0aGlzLl9zdGF0ZSA9IHVuZGVmaW5lZDtcbiAgdGhpcy5fc3Vic2NyaWJlcnMgPSBbXTtcblxuICBpZiAobm9vcCAhPT0gcmVzb2x2ZXIpIHtcbiAgICB0eXBlb2YgcmVzb2x2ZXIgIT09ICdmdW5jdGlvbicgJiYgbmVlZHNSZXNvbHZlcigpO1xuICAgIHRoaXMgaW5zdGFuY2VvZiBQcm9taXNlID8gaW5pdGlhbGl6ZVByb21pc2UodGhpcywgcmVzb2x2ZXIpIDogbmVlZHNOZXcoKTtcbiAgfVxufVxuXG5Qcm9taXNlLmFsbCA9IGFsbDtcblByb21pc2UucmFjZSA9IHJhY2U7XG5Qcm9taXNlLnJlc29sdmUgPSByZXNvbHZlO1xuUHJvbWlzZS5yZWplY3QgPSByZWplY3Q7XG5Qcm9taXNlLl9zZXRTY2hlZHVsZXIgPSBzZXRTY2hlZHVsZXI7XG5Qcm9taXNlLl9zZXRBc2FwID0gc2V0QXNhcDtcblByb21pc2UuX2FzYXAgPSBhc2FwO1xuXG5Qcm9taXNlLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFByb21pc2UsXG5cbiAgLyoqXG4gICAgVGhlIHByaW1hcnkgd2F5IG9mIGludGVyYWN0aW5nIHdpdGggYSBwcm9taXNlIGlzIHRocm91Z2ggaXRzIGB0aGVuYCBtZXRob2QsXG4gICAgd2hpY2ggcmVnaXN0ZXJzIGNhbGxiYWNrcyB0byByZWNlaXZlIGVpdGhlciBhIHByb21pc2UncyBldmVudHVhbCB2YWx1ZSBvciB0aGVcbiAgICByZWFzb24gd2h5IHRoZSBwcm9taXNlIGNhbm5vdCBiZSBmdWxmaWxsZWQuXG4gIFxuICAgIGBgYGpzXG4gICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uKHVzZXIpe1xuICAgICAgLy8gdXNlciBpcyBhdmFpbGFibGVcbiAgICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgICAgLy8gdXNlciBpcyB1bmF2YWlsYWJsZSwgYW5kIHlvdSBhcmUgZ2l2ZW4gdGhlIHJlYXNvbiB3aHlcbiAgICB9KTtcbiAgICBgYGBcbiAgXG4gICAgQ2hhaW5pbmdcbiAgICAtLS0tLS0tLVxuICBcbiAgICBUaGUgcmV0dXJuIHZhbHVlIG9mIGB0aGVuYCBpcyBpdHNlbGYgYSBwcm9taXNlLiAgVGhpcyBzZWNvbmQsICdkb3duc3RyZWFtJ1xuICAgIHByb21pc2UgaXMgcmVzb2x2ZWQgd2l0aCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBmaXJzdCBwcm9taXNlJ3MgZnVsZmlsbG1lbnRcbiAgICBvciByZWplY3Rpb24gaGFuZGxlciwgb3IgcmVqZWN0ZWQgaWYgdGhlIGhhbmRsZXIgdGhyb3dzIGFuIGV4Y2VwdGlvbi5cbiAgXG4gICAgYGBganNcbiAgICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgIHJldHVybiB1c2VyLm5hbWU7XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgcmV0dXJuICdkZWZhdWx0IG5hbWUnO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKHVzZXJOYW1lKSB7XG4gICAgICAvLyBJZiBgZmluZFVzZXJgIGZ1bGZpbGxlZCwgYHVzZXJOYW1lYCB3aWxsIGJlIHRoZSB1c2VyJ3MgbmFtZSwgb3RoZXJ3aXNlIGl0XG4gICAgICAvLyB3aWxsIGJlIGAnZGVmYXVsdCBuYW1lJ2BcbiAgICB9KTtcbiAgXG4gICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvdW5kIHVzZXIsIGJ1dCBzdGlsbCB1bmhhcHB5Jyk7XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdgZmluZFVzZXJgIHJlamVjdGVkIGFuZCB3ZSdyZSB1bmhhcHB5Jyk7XG4gICAgfSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIC8vIG5ldmVyIHJlYWNoZWRcbiAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAvLyBpZiBgZmluZFVzZXJgIGZ1bGZpbGxlZCwgYHJlYXNvbmAgd2lsbCBiZSAnRm91bmQgdXNlciwgYnV0IHN0aWxsIHVuaGFwcHknLlxuICAgICAgLy8gSWYgYGZpbmRVc2VyYCByZWplY3RlZCwgYHJlYXNvbmAgd2lsbCBiZSAnYGZpbmRVc2VyYCByZWplY3RlZCBhbmQgd2UncmUgdW5oYXBweScuXG4gICAgfSk7XG4gICAgYGBgXG4gICAgSWYgdGhlIGRvd25zdHJlYW0gcHJvbWlzZSBkb2VzIG5vdCBzcGVjaWZ5IGEgcmVqZWN0aW9uIGhhbmRsZXIsIHJlamVjdGlvbiByZWFzb25zIHdpbGwgYmUgcHJvcGFnYXRlZCBmdXJ0aGVyIGRvd25zdHJlYW0uXG4gIFxuICAgIGBgYGpzXG4gICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICB0aHJvdyBuZXcgUGVkYWdvZ2ljYWxFeGNlcHRpb24oJ1Vwc3RyZWFtIGVycm9yJyk7XG4gICAgfSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIC8vIG5ldmVyIHJlYWNoZWRcbiAgICB9KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgLy8gbmV2ZXIgcmVhY2hlZFxuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIC8vIFRoZSBgUGVkZ2Fnb2NpYWxFeGNlcHRpb25gIGlzIHByb3BhZ2F0ZWQgYWxsIHRoZSB3YXkgZG93biB0byBoZXJlXG4gICAgfSk7XG4gICAgYGBgXG4gIFxuICAgIEFzc2ltaWxhdGlvblxuICAgIC0tLS0tLS0tLS0tLVxuICBcbiAgICBTb21ldGltZXMgdGhlIHZhbHVlIHlvdSB3YW50IHRvIHByb3BhZ2F0ZSB0byBhIGRvd25zdHJlYW0gcHJvbWlzZSBjYW4gb25seSBiZVxuICAgIHJldHJpZXZlZCBhc3luY2hyb25vdXNseS4gVGhpcyBjYW4gYmUgYWNoaWV2ZWQgYnkgcmV0dXJuaW5nIGEgcHJvbWlzZSBpbiB0aGVcbiAgICBmdWxmaWxsbWVudCBvciByZWplY3Rpb24gaGFuZGxlci4gVGhlIGRvd25zdHJlYW0gcHJvbWlzZSB3aWxsIHRoZW4gYmUgcGVuZGluZ1xuICAgIHVudGlsIHRoZSByZXR1cm5lZCBwcm9taXNlIGlzIHNldHRsZWQuIFRoaXMgaXMgY2FsbGVkICphc3NpbWlsYXRpb24qLlxuICBcbiAgICBgYGBqc1xuICAgIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgICAgcmV0dXJuIGZpbmRDb21tZW50c0J5QXV0aG9yKHVzZXIpO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKGNvbW1lbnRzKSB7XG4gICAgICAvLyBUaGUgdXNlcidzIGNvbW1lbnRzIGFyZSBub3cgYXZhaWxhYmxlXG4gICAgfSk7XG4gICAgYGBgXG4gIFxuICAgIElmIHRoZSBhc3NpbWxpYXRlZCBwcm9taXNlIHJlamVjdHMsIHRoZW4gdGhlIGRvd25zdHJlYW0gcHJvbWlzZSB3aWxsIGFsc28gcmVqZWN0LlxuICBcbiAgICBgYGBqc1xuICAgIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgICAgcmV0dXJuIGZpbmRDb21tZW50c0J5QXV0aG9yKHVzZXIpO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKGNvbW1lbnRzKSB7XG4gICAgICAvLyBJZiBgZmluZENvbW1lbnRzQnlBdXRob3JgIGZ1bGZpbGxzLCB3ZSdsbCBoYXZlIHRoZSB2YWx1ZSBoZXJlXG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgLy8gSWYgYGZpbmRDb21tZW50c0J5QXV0aG9yYCByZWplY3RzLCB3ZSdsbCBoYXZlIHRoZSByZWFzb24gaGVyZVxuICAgIH0pO1xuICAgIGBgYFxuICBcbiAgICBTaW1wbGUgRXhhbXBsZVxuICAgIC0tLS0tLS0tLS0tLS0tXG4gIFxuICAgIFN5bmNocm9ub3VzIEV4YW1wbGVcbiAgXG4gICAgYGBgamF2YXNjcmlwdFxuICAgIGxldCByZXN1bHQ7XG4gIFxuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSBmaW5kUmVzdWx0KCk7XG4gICAgICAvLyBzdWNjZXNzXG4gICAgfSBjYXRjaChyZWFzb24pIHtcbiAgICAgIC8vIGZhaWx1cmVcbiAgICB9XG4gICAgYGBgXG4gIFxuICAgIEVycmJhY2sgRXhhbXBsZVxuICBcbiAgICBgYGBqc1xuICAgIGZpbmRSZXN1bHQoZnVuY3Rpb24ocmVzdWx0LCBlcnIpe1xuICAgICAgaWYgKGVycikge1xuICAgICAgICAvLyBmYWlsdXJlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBzdWNjZXNzXG4gICAgICB9XG4gICAgfSk7XG4gICAgYGBgXG4gIFxuICAgIFByb21pc2UgRXhhbXBsZTtcbiAgXG4gICAgYGBgamF2YXNjcmlwdFxuICAgIGZpbmRSZXN1bHQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCl7XG4gICAgICAvLyBzdWNjZXNzXG4gICAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAgIC8vIGZhaWx1cmVcbiAgICB9KTtcbiAgICBgYGBcbiAgXG4gICAgQWR2YW5jZWQgRXhhbXBsZVxuICAgIC0tLS0tLS0tLS0tLS0tXG4gIFxuICAgIFN5bmNocm9ub3VzIEV4YW1wbGVcbiAgXG4gICAgYGBgamF2YXNjcmlwdFxuICAgIGxldCBhdXRob3IsIGJvb2tzO1xuICBcbiAgICB0cnkge1xuICAgICAgYXV0aG9yID0gZmluZEF1dGhvcigpO1xuICAgICAgYm9va3MgID0gZmluZEJvb2tzQnlBdXRob3IoYXV0aG9yKTtcbiAgICAgIC8vIHN1Y2Nlc3NcbiAgICB9IGNhdGNoKHJlYXNvbikge1xuICAgICAgLy8gZmFpbHVyZVxuICAgIH1cbiAgICBgYGBcbiAgXG4gICAgRXJyYmFjayBFeGFtcGxlXG4gIFxuICAgIGBgYGpzXG4gIFxuICAgIGZ1bmN0aW9uIGZvdW5kQm9va3MoYm9va3MpIHtcbiAgXG4gICAgfVxuICBcbiAgICBmdW5jdGlvbiBmYWlsdXJlKHJlYXNvbikge1xuICBcbiAgICB9XG4gIFxuICAgIGZpbmRBdXRob3IoZnVuY3Rpb24oYXV0aG9yLCBlcnIpe1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBmYWlsdXJlKGVycik7XG4gICAgICAgIC8vIGZhaWx1cmVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZmluZEJvb29rc0J5QXV0aG9yKGF1dGhvciwgZnVuY3Rpb24oYm9va3MsIGVycikge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICBmYWlsdXJlKGVycik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvdW5kQm9va3MoYm9va3MpO1xuICAgICAgICAgICAgICB9IGNhdGNoKHJlYXNvbikge1xuICAgICAgICAgICAgICAgIGZhaWx1cmUocmVhc29uKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoKGVycm9yKSB7XG4gICAgICAgICAgZmFpbHVyZShlcnIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHN1Y2Nlc3NcbiAgICAgIH1cbiAgICB9KTtcbiAgICBgYGBcbiAgXG4gICAgUHJvbWlzZSBFeGFtcGxlO1xuICBcbiAgICBgYGBqYXZhc2NyaXB0XG4gICAgZmluZEF1dGhvcigpLlxuICAgICAgdGhlbihmaW5kQm9va3NCeUF1dGhvcikuXG4gICAgICB0aGVuKGZ1bmN0aW9uKGJvb2tzKXtcbiAgICAgICAgLy8gZm91bmQgYm9va3NcbiAgICB9KS5jYXRjaChmdW5jdGlvbihyZWFzb24pe1xuICAgICAgLy8gc29tZXRoaW5nIHdlbnQgd3JvbmdcbiAgICB9KTtcbiAgICBgYGBcbiAgXG4gICAgQG1ldGhvZCB0aGVuXG4gICAgQHBhcmFtIHtGdW5jdGlvbn0gb25GdWxmaWxsZWRcbiAgICBAcGFyYW0ge0Z1bmN0aW9ufSBvblJlamVjdGVkXG4gICAgVXNlZnVsIGZvciB0b29saW5nLlxuICAgIEByZXR1cm4ge1Byb21pc2V9XG4gICovXG4gIHRoZW46IHRoZW4sXG5cbiAgLyoqXG4gICAgYGNhdGNoYCBpcyBzaW1wbHkgc3VnYXIgZm9yIGB0aGVuKHVuZGVmaW5lZCwgb25SZWplY3Rpb24pYCB3aGljaCBtYWtlcyBpdCB0aGUgc2FtZVxuICAgIGFzIHRoZSBjYXRjaCBibG9jayBvZiBhIHRyeS9jYXRjaCBzdGF0ZW1lbnQuXG4gIFxuICAgIGBgYGpzXG4gICAgZnVuY3Rpb24gZmluZEF1dGhvcigpe1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZG4ndCBmaW5kIHRoYXQgYXV0aG9yJyk7XG4gICAgfVxuICBcbiAgICAvLyBzeW5jaHJvbm91c1xuICAgIHRyeSB7XG4gICAgICBmaW5kQXV0aG9yKCk7XG4gICAgfSBjYXRjaChyZWFzb24pIHtcbiAgICAgIC8vIHNvbWV0aGluZyB3ZW50IHdyb25nXG4gICAgfVxuICBcbiAgICAvLyBhc3luYyB3aXRoIHByb21pc2VzXG4gICAgZmluZEF1dGhvcigpLmNhdGNoKGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgICAvLyBzb21ldGhpbmcgd2VudCB3cm9uZ1xuICAgIH0pO1xuICAgIGBgYFxuICBcbiAgICBAbWV0aG9kIGNhdGNoXG4gICAgQHBhcmFtIHtGdW5jdGlvbn0gb25SZWplY3Rpb25cbiAgICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gICAgQHJldHVybiB7UHJvbWlzZX1cbiAgKi9cbiAgJ2NhdGNoJzogZnVuY3Rpb24gX2NhdGNoKG9uUmVqZWN0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbihudWxsLCBvblJlamVjdGlvbik7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHBvbHlmaWxsKCkge1xuICAgIHZhciBsb2NhbCA9IHVuZGVmaW5lZDtcblxuICAgIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBsb2NhbCA9IGdsb2JhbDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBsb2NhbCA9IHNlbGY7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxvY2FsID0gRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwb2x5ZmlsbCBmYWlsZWQgYmVjYXVzZSBnbG9iYWwgb2JqZWN0IGlzIHVuYXZhaWxhYmxlIGluIHRoaXMgZW52aXJvbm1lbnQnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBQID0gbG9jYWwuUHJvbWlzZTtcblxuICAgIGlmIChQKSB7XG4gICAgICAgIHZhciBwcm9taXNlVG9TdHJpbmcgPSBudWxsO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcHJvbWlzZVRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFAucmVzb2x2ZSgpKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gc2lsZW50bHkgaWdub3JlZFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByb21pc2VUb1N0cmluZyA9PT0gJ1tvYmplY3QgUHJvbWlzZV0nICYmICFQLmNhc3QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGxvY2FsLlByb21pc2UgPSBQcm9taXNlO1xufVxuXG5wb2x5ZmlsbCgpO1xuLy8gU3RyYW5nZSBjb21wYXQuLlxuUHJvbWlzZS5wb2x5ZmlsbCA9IHBvbHlmaWxsO1xuUHJvbWlzZS5Qcm9taXNlID0gUHJvbWlzZTtcblxucmV0dXJuIFByb21pc2U7XG5cbn0pKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lczYtcHJvbWlzZS5tYXAiLCIvKiEgRmlsZVNhdmVyLmpzIHYxLjMuNlxuICpcbiAqIEEgc2F2ZUFzKCkgRmlsZVNhdmVyIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIEJ5IFRyYXZpcyBDbGFya2UsIGh0dHBzOi8vdHJhdmlzbWNsYXJrZS5jb21cbiAqIEJ5IEVsaSBHcmV5LCBodHRwOi8vZWxpZ3JleS5jb21cbiAqXG4gKiBMaWNlbnNlOiBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS9jbGFya2V0bS9GaWxlU2F2ZXIuanMvYmxvYi9tYXN0ZXIvTElDRU5TRS5tZClcbiAqL1xuXG47KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG4gICAgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgZXhwb3J0cy5ub2RlTmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSByb290LmRvY3VtZW50ID8gZmFjdG9yeShyb290LCB0cnVlKSA6IGZ1bmN0aW9uICh3KSB7XG4gICAgICAgICAgICBpZiAoIXcuZG9jdW1lbnQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGaWxlU2F2ZXIgcmVxdWlyZXMgYSB3aW5kb3cgd2l0aCBhIGRvY3VtZW50XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhY3Rvcnkodyk7XG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZmFjdG9yeShyb290KTtcbiAgICB9XG59KHdpbmRvdyB8fCB0aGlzLCBmdW5jdGlvbiAod2luZG93LCBub0dsb2JhbCkge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgLy8gSUUgPDEwIGlzIGV4cGxpY2l0bHkgdW5zdXBwb3J0ZWRcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIgfHwgdHlwZW9mIG5hdmlnYXRvciAhPT0gXCJ1bmRlZmluZWRcIiAmJiAvTVNJRSBbMS05XVxcLi8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhclxuICAgICAgICAgICAgZG9jID0gd2luZG93LmRvY3VtZW50XG4gICAgICAgICAgICAvLyBvbmx5IGdldCBVUkwgd2hlbiBuZWNlc3NhcnkgaW4gY2FzZSBCbG9iLmpzIGhhc24ndCBvdmVycmlkZGVuIGl0IHlldFxuICAgICAgICAgICAgLCBnZXRfVVJMID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3cuVVJMIHx8IHdpbmRvdy53ZWJraXRVUkwgfHwgd2luZG93O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLCBzYXZlX2xpbmsgPSBkb2MuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiLCBcImFcIilcbiAgICAgICAgICAgICwgY2FuX3VzZV9zYXZlX2xpbmsgPSBcImRvd25sb2FkXCIgaW4gc2F2ZV9saW5rXG4gICAgICAgICAgICAsIGNsaWNrID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnQgPSBuZXcgTW91c2VFdmVudChcImNsaWNrXCIpO1xuICAgICAgICAgICAgICAgIG5vZGUuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAsIGlzX3NhZmFyaSA9IC9jb25zdHJ1Y3Rvci9pLnRlc3Qod2luZG93LkhUTUxFbGVtZW50KSB8fCB3aW5kb3cuc2FmYXJpXG4gICAgICAgICAgICAsIGlzX2Nocm9tZV9pb3MgPSAvQ3JpT1NcXC9bXFxkXSsvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudClcbiAgICAgICAgICAgICwgdGhyb3dfb3V0c2lkZSA9IGZ1bmN0aW9uIChleCkge1xuICAgICAgICAgICAgICAgICh3aW5kb3cuc2V0SW1tZWRpYXRlIHx8IHdpbmRvdy5zZXRUaW1lb3V0KShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGV4O1xuICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLCBmb3JjZV9zYXZlYWJsZV90eXBlID0gXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIlxuICAgICAgICAgICAgLy8gdGhlIEJsb2IgQVBJIGlzIGZ1bmRhbWVudGFsbHkgYnJva2VuIGFzIHRoZXJlIGlzIG5vIFwiZG93bmxvYWRmaW5pc2hlZFwiIGV2ZW50IHRvIHN1YnNjcmliZSB0b1xuICAgICAgICAgICAgLCBhcmJpdHJhcnlfcmV2b2tlX3RpbWVvdXQgPSAxMDAwICogNDAgLy8gaW4gbXNcbiAgICAgICAgICAgICwgcmV2b2tlID0gZnVuY3Rpb24gKGZpbGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmV2b2tlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmaWxlID09PSBcInN0cmluZ1wiKSB7IC8vIGZpbGUgaXMgYW4gb2JqZWN0IFVSTFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0X1VSTCgpLnJldm9rZU9iamVjdFVSTChmaWxlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gZmlsZSBpcyBhIEZpbGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGUucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQocmV2b2tlciwgYXJiaXRyYXJ5X3Jldm9rZV90aW1lb3V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICwgZGlzcGF0Y2ggPSBmdW5jdGlvbiAoZmlsZXNhdmVyLCBldmVudF90eXBlcywgZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBldmVudF90eXBlcyA9IFtdLmNvbmNhdChldmVudF90eXBlcyk7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSBldmVudF90eXBlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGlzdGVuZXIgPSBmaWxlc2F2ZXJbXCJvblwiICsgZXZlbnRfdHlwZXNbaV1dO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGxpc3RlbmVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXIuY2FsbChmaWxlc2F2ZXIsIGV2ZW50IHx8IGZpbGVzYXZlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93X291dHNpZGUoZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLCBhdXRvX2JvbSA9IGZ1bmN0aW9uIChibG9iKSB7XG4gICAgICAgICAgICAgICAgLy8gcHJlcGVuZCBCT00gZm9yIFVURi04IFhNTCBhbmQgdGV4dC8qIHR5cGVzIChpbmNsdWRpbmcgSFRNTClcbiAgICAgICAgICAgICAgICAvLyBub3RlOiB5b3VyIGJyb3dzZXIgd2lsbCBhdXRvbWF0aWNhbGx5IGNvbnZlcnQgVVRGLTE2IFUrRkVGRiB0byBFRiBCQiBCRlxuICAgICAgICAgICAgICAgIGlmICgvXlxccyooPzp0ZXh0XFwvXFxTKnxhcHBsaWNhdGlvblxcL3htbHxcXFMqXFwvXFxTKlxcK3htbClcXHMqOy4qY2hhcnNldFxccyo9XFxzKnV0Zi04L2kudGVzdChibG9iLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQmxvYihbU3RyaW5nLmZyb21DaGFyQ29kZSgweEZFRkYpLCBibG9iXSwge3R5cGU6IGJsb2IudHlwZX0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYmxvYjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICwgRmlsZVNhdmVyID0gZnVuY3Rpb24gKGJsb2IsIG5hbWUsIG5vX2F1dG9fYm9tKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFub19hdXRvX2JvbSkge1xuICAgICAgICAgICAgICAgICAgICBibG9iID0gYXV0b19ib20oYmxvYik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEZpcnN0IHRyeSBhLmRvd25sb2FkLCB0aGVuIHdlYiBmaWxlc3lzdGVtLCB0aGVuIG9iamVjdCBVUkxzXG4gICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgIGZpbGVzYXZlciA9IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgLCB0eXBlID0gYmxvYi50eXBlXG4gICAgICAgICAgICAgICAgICAgICwgZm9yY2UgPSB0eXBlID09PSBmb3JjZV9zYXZlYWJsZV90eXBlXG4gICAgICAgICAgICAgICAgICAgICwgb2JqZWN0X3VybFxuICAgICAgICAgICAgICAgICAgICAsIGRpc3BhdGNoX2FsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKGZpbGVzYXZlciwgXCJ3cml0ZXN0YXJ0IHByb2dyZXNzIHdyaXRlIHdyaXRlZW5kXCIuc3BsaXQoXCIgXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBvbiBhbnkgZmlsZXN5cyBlcnJvcnMgcmV2ZXJ0IHRvIHNhdmluZyB3aXRoIG9iamVjdCBVUkxzXG4gICAgICAgICAgICAgICAgICAgICwgZnNfZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGlzX2Nocm9tZV9pb3MgfHwgKGZvcmNlICYmIGlzX3NhZmFyaSkpICYmIHdpbmRvdy5GaWxlUmVhZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2FmYXJpIGRvZXNuJ3QgYWxsb3cgZG93bmxvYWRpbmcgb2YgYmxvYiB1cmxzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGVyLm9ubG9hZGVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVybCA9IGlzX2Nocm9tZV9pb3MgPyByZWFkZXIucmVzdWx0IDogcmVhZGVyLnJlc3VsdC5yZXBsYWNlKC9eZGF0YTpbXjtdKjsvLCAnZGF0YTphdHRhY2htZW50L2ZpbGU7Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwb3B1cCA9IHdpbmRvdy5vcGVuKHVybCwgJ19ibGFuaycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBvcHVwKSB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHVybDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gdW5kZWZpbmVkOyAvLyByZWxlYXNlIHJlZmVyZW5jZSBiZWZvcmUgZGlzcGF0Y2hpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZXNhdmVyLnJlYWR5U3RhdGUgPSBmaWxlc2F2ZXIuRE9ORTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hfYWxsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkZXIucmVhZEFzRGF0YVVSTChibG9iKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlc2F2ZXIucmVhZHlTdGF0ZSA9IGZpbGVzYXZlci5JTklUO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvbid0IGNyZWF0ZSBtb3JlIG9iamVjdCBVUkxzIHRoYW4gbmVlZGVkXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9iamVjdF91cmwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3RfdXJsID0gZ2V0X1VSTCgpLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmb3JjZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gb2JqZWN0X3VybDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9wZW5lZCA9IHdpbmRvdy5vcGVuKG9iamVjdF91cmwsIFwiX2JsYW5rXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb3BlbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFwcGxlIGRvZXMgbm90IGFsbG93IHdpbmRvdy5vcGVuLCBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2xpYnJhcnkvc2FmYXJpL2RvY3VtZW50YXRpb24vVG9vbHMvQ29uY2VwdHVhbC9TYWZhcmlFeHRlbnNpb25HdWlkZS9Xb3JraW5nd2l0aFdpbmRvd3NhbmRUYWJzL1dvcmtpbmd3aXRoV2luZG93c2FuZFRhYnMuaHRtbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IG9iamVjdF91cmw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZXNhdmVyLnJlYWR5U3RhdGUgPSBmaWxlc2F2ZXIuRE9ORTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoX2FsbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV2b2tlKG9iamVjdF91cmwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICBmaWxlc2F2ZXIucmVhZHlTdGF0ZSA9IGZpbGVzYXZlci5JTklUO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNhbl91c2Vfc2F2ZV9saW5rKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdF91cmwgPSBnZXRfVVJMKCkuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNhdmVfbGluay5ocmVmID0gb2JqZWN0X3VybDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNhdmVfbGluay5kb3dubG9hZCA9IG5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGljayhzYXZlX2xpbmspO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hfYWxsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXZva2Uob2JqZWN0X3VybCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlc2F2ZXIucmVhZHlTdGF0ZSA9IGZpbGVzYXZlci5ET05FO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZzX2Vycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAsIEZTX3Byb3RvID0gRmlsZVNhdmVyLnByb3RvdHlwZVxuICAgICAgICAgICAgLCBzYXZlQXMgPSBmdW5jdGlvbiAoYmxvYiwgbmFtZSwgbm9fYXV0b19ib20pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZpbGVTYXZlcihibG9iLCBuYW1lIHx8IGJsb2IubmFtZSB8fCBcImRvd25sb2FkXCIsIG5vX2F1dG9fYm9tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDtcbiAgICAgICAgLy8gSUUgMTArIChuYXRpdmUgc2F2ZUFzKVxuICAgICAgICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBuYXZpZ2F0b3IubXNTYXZlT3JPcGVuQmxvYikge1xuICAgICAgICAgICAgc2F2ZUFzID0gZnVuY3Rpb24gKGJsb2IsIG5hbWUsIG5vX2F1dG9fYm9tKSB7XG4gICAgICAgICAgICAgICAgbmFtZSA9IG5hbWUgfHwgYmxvYi5uYW1lIHx8IFwiZG93bmxvYWRcIjtcblxuICAgICAgICAgICAgICAgIGlmICghbm9fYXV0b19ib20pIHtcbiAgICAgICAgICAgICAgICAgICAgYmxvYiA9IGF1dG9fYm9tKGJsb2IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbmF2aWdhdG9yLm1zU2F2ZU9yT3BlbkJsb2IoYmxvYiwgbmFtZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgRlNfcHJvdG8uYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIH07XG4gICAgICAgIEZTX3Byb3RvLnJlYWR5U3RhdGUgPSBGU19wcm90by5JTklUID0gMDtcbiAgICAgICAgRlNfcHJvdG8uV1JJVElORyA9IDE7XG4gICAgICAgIEZTX3Byb3RvLkRPTkUgPSAyO1xuXG4gICAgICAgIEZTX3Byb3RvLmVycm9yID1cbiAgICAgICAgICAgIEZTX3Byb3RvLm9ud3JpdGVzdGFydCA9XG4gICAgICAgICAgICAgICAgRlNfcHJvdG8ub25wcm9ncmVzcyA9XG4gICAgICAgICAgICAgICAgICAgIEZTX3Byb3RvLm9ud3JpdGUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgRlNfcHJvdG8ub25hYm9ydCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRlNfcHJvdG8ub25lcnJvciA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZTX3Byb3RvLm9ud3JpdGVlbmQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbDtcblxuICAgICAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgICAgIGRlZmluZShcImZpbGUtc2F2ZXJqc1wiLCBbXSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzYXZlQXM7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygbm9HbG9iYWwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB3aW5kb3cuc2F2ZUFzID0gc2F2ZUFzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzYXZlQXM7XG4gICAgfVxuKSk7XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiOyhmdW5jdGlvbih1bmRlZmluZWQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBfX2luc3RhbmNlcyA9IHt9O1xuXG4gIC8qKlxuICAgKiBUaGlzIGlzIHRoZSBzaWdtYSBpbnN0YW5jZXMgY29uc3RydWN0b3IuIE9uZSBpbnN0YW5jZSBvZiBzaWdtYSByZXByZXNlbnRcbiAgICogb25lIGdyYXBoLiBJdCBpcyBwb3NzaWJsZSB0byByZXByZXNlbnQgdGhpcyBncmFwxKUgd2l0aCBzZXZlcmFsIHJlbmRlcmVyc1xuICAgKiBhdCB0aGUgc2FtZSB0aW1lLiBCeSBkZWZhdWx0LCB0aGUgZGVmYXVsdCByZW5kZXJlciAoV2ViR0wgKyBDYW52YXNcbiAgICogcG9seWZpbGwpIHdpbGwgYmUgdXNlZCBhcyB0aGUgb25seSByZW5kZXJlciwgd2l0aCB0aGUgY29udGFpbmVyIHNwZWNpZmllZFxuICAgKiBpbiB0aGUgY29uZmlndXJhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtICB7Pyp9ICAgIGNvbmYgVGhlIGNvbmZpZ3VyYXRpb24gb2YgdGhlIGluc3RhbmNlLiBUaGVyZSBhcmUgYSBsb3Qgb2ZcbiAgICogICAgICAgICAgICAgICAgICAgICAgZGlmZmVyZW50IHJlY29nbml6ZWQgZm9ybXMgdG8gaW5zdGFudGlhdGUgc2lnbWEsIGNoZWNrXG4gICAqICAgICAgICAgICAgICAgICAgICAgIGV4YW1wbGUgZmlsZXMsIGRvY3VtZW50YXRpb24gaW4gdGhpcyBmaWxlIGFuZCB1bml0XG4gICAqICAgICAgICAgICAgICAgICAgICAgIHRlc3RzIHRvIGtub3cgbW9yZS5cbiAgICogQHJldHVybiB7c2lnbWF9ICAgICAgVGhlIGZyZXNoIG5ldyBzaWdtYSBpbnN0YW5jZS5cbiAgICpcbiAgICogSW5zdGFuY2lhdGluZyBzaWdtYTpcbiAgICogKioqKioqKioqKioqKioqKioqKipcbiAgICogSWYgbm8gcGFyYW1ldGVyIGlzIGdpdmVuIHRvIHRoZSBjb25zdHJ1Y3RvciwgdGhlIGluc3RhbmNlIHdpbGwgYmUgY3JlYXRlZFxuICAgKiB3aXRob3V0IGFueSByZW5kZXJlciBvciBjYW1lcmEuIEl0IHdpbGwganVzdCBpbnN0YW50aWF0ZSB0aGUgZ3JhcGgsIGFuZFxuICAgKiBvdGhlciBtb2R1bGVzIHdpbGwgaGF2ZSB0byBiZSBpbnN0YW50aWF0ZWQgdGhyb3VnaCB0aGUgcHVibGljIG1ldGhvZHMsXG4gICAqIGxpa2UgXCJhZGRSZW5kZXJlclwiIGV0YzpcbiAgICpcbiAgICogID4gczAgPSBuZXcgc2lnbWEoKTtcbiAgICogID4gczAuYWRkUmVuZGVyZXIoe1xuICAgKiAgPiAgIHR5cGU6ICdjYW52YXMnLFxuICAgKiAgPiAgIGNvbnRhaW5lcjogJ215LWNvbnRhaW5lci1pZCdcbiAgICogID4gfSk7XG4gICAqXG4gICAqIEluIG1vc3Qgb2YgdGhlIGNhc2VzLCBzaWdtYSB3aWxsIHNpbXBseSBiZSB1c2VkIHdpdGggdGhlIGRlZmF1bHQgcmVuZGVyZXIuXG4gICAqIFRoZW4sIHNpbmNlIHRoZSBvbmx5IHJlcXVpcmVkIHBhcmFtZXRlciBpcyB0aGUgRE9NIGNvbnRhaW5lciwgdGhlcmUgYXJlXG4gICAqIHNvbWUgc2ltcGxlciB3YXkgdG8gY2FsbCB0aGUgY29uc3RydWN0b3IuIFRoZSBmb3VyIGZvbGxvd2luZyBjYWxscyBkbyB0aGVcbiAgICogZXhhY3Qgc2FtZSB0aGluZ3M6XG4gICAqXG4gICAqICA+IHMxID0gbmV3IHNpZ21hKCdteS1jb250YWluZXItaWQnKTtcbiAgICogID4gczIgPSBuZXcgc2lnbWEoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ215LWNvbnRhaW5lci1pZCcpKTtcbiAgICogID4gczMgPSBuZXcgc2lnbWEoe1xuICAgKiAgPiAgIGNvbnRhaW5lcjogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ215LWNvbnRhaW5lci1pZCcpXG4gICAqICA+IH0pO1xuICAgKiAgPiBzNCA9IG5ldyBzaWdtYSh7XG4gICAqICA+ICAgcmVuZGVyZXJzOiBbe1xuICAgKiAgPiAgICAgY29udGFpbmVyOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbXktY29udGFpbmVyLWlkJylcbiAgICogID4gICB9XVxuICAgKiAgPiB9KTtcbiAgICpcbiAgICogUmVjb2duaXplZCBwYXJhbWV0ZXJzOlxuICAgKiAqKioqKioqKioqKioqKioqKioqKioqXG4gICAqIEhlcmUgaXMgdGhlIGV4aGF1c3RpdmUgbGlzdCBvZiBldmVyeSBhY2NlcHRlZCBwYXJhbWV0ZXJzLCB3aGVuIGNhbGxpbmcgdGhlXG4gICAqIGNvbnN0cnVjdG9yIHdpdGggdG8gdG9wIGxldmVsIGNvbmZpZ3VyYXRpb24gb2JqZWN0IChmb3VydGggY2FzZSBpbiB0aGVcbiAgICogcHJldmlvdXMgZXhhbXBsZXMpOlxuICAgKlxuICAgKiAgIHs/c3RyaW5nfSBpZCAgICAgICAgVGhlIGlkIG9mIHRoZSBpbnN0YW5jZS4gSXQgd2lsbCBiZSBnZW5lcmF0ZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgIGF1dG9tYXRpY2FsbHkgaWYgbm90IHNwZWNpZmllZC5cbiAgICogICB7P2FycmF5fSAgcmVuZGVyZXJzIEFuIGFycmF5IGNvbnRhaW5pbmcgb2JqZWN0cyBkZXNjcmliaW5nIHJlbmRlcmVycy5cbiAgICogICB7P29iamVjdH0gZ3JhcGggICAgIEFuIG9iamVjdCBjb250YWluaW5nIGFuIGFycmF5IG9mIG5vZGVzIGFuZCBhbiBhcnJheVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgb2YgZWRnZXMsIHRvIGF2b2lkIGhhdmluZyB0byBhZGQgdGhlbSBieSBoYW5kIGxhdGVyLlxuICAgKiAgIHs/b2JqZWN0fSBzZXR0aW5ncyAgQW4gb2JqZWN0IGNvbnRhaW5pbmcgaW5zdGFuY2Ugc3BlY2lmaWMgc2V0dGluZ3MgdGhhdFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgd2lsbCBvdmVycmlkZSB0aGUgZGVmYXVsdCBvbmVzIGRlZmluZWQgaW4gdGhlIG9iamVjdFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgc2lnbWEuc2V0dGluZ3MuXG4gICAqL1xuICB2YXIgc2lnbWEgPSBmdW5jdGlvbihjb25mKSB7XG4gICAgLy8gTG9jYWwgdmFyaWFibGVzOlxuICAgIC8vICoqKioqKioqKioqKioqKipcbiAgICB2YXIgaSxcbiAgICAgICAgbCxcbiAgICAgICAgYSxcbiAgICAgICAgYyxcbiAgICAgICAgbyxcbiAgICAgICAgaWQ7XG5cbiAgICBzaWdtYS5jbGFzc2VzLmRpc3BhdGNoZXIuZXh0ZW5kKHRoaXMpO1xuXG4gICAgLy8gUHJpdmF0ZSBhdHRyaWJ1dGVzOlxuICAgIC8vICoqKioqKioqKioqKioqKioqKipcbiAgICB2YXIgX3NlbGYgPSB0aGlzLFxuICAgICAgICBfY29uZiA9IGNvbmYgfHwge307XG5cbiAgICAvLyBMaXR0bGUgc2hvcnRjdXQ6XG4gICAgLy8gKioqKioqKioqKioqKioqKlxuICAgIC8vIFRoZSBjb25maWd1cmF0aW9uIGlzIHN1cHBvc2VkIHRvIGhhdmUgYSBsaXN0IG9mIHRoZSBjb25maWd1cmF0aW9uXG4gICAgLy8gb2JqZWN0cyBmb3IgZWFjaCByZW5kZXJlci5cbiAgICAvLyAgLSBJZiB0aGVyZSBhcmUgbm8gY29uZmlndXJhdGlvbiBhdCBhbGwsIHRoZW4gbm90aGluZyBpcyBkb25lLlxuICAgIC8vICAtIElmIHRoZXJlIGFyZSBubyByZW5kZXJlciBsaXN0LCB0aGUgZ2l2ZW4gY29uZmlndXJhdGlvbiBvYmplY3Qgd2lsbCBiZVxuICAgIC8vICAgIGNvbnNpZGVyZWQgYXMgZGVzY3JpYmluZyB0aGUgZmlyc3QgYW5kIG9ubHkgcmVuZGVyZXIuXG4gICAgLy8gIC0gSWYgdGhlcmUgYXJlIG5vIHJlbmRlcmVyIGxpc3Qgbm9yIFwiY29udGFpbmVyXCIgb2JqZWN0LCBpdCB3aWxsIGJlXG4gICAgLy8gICAgY29uc2lkZXJlZCBhcyB0aGUgY29udGFpbmVyIGl0c2VsZiAoYSBET00gZWxlbWVudCkuXG4gICAgLy8gIC0gSWYgdGhlIGFyZ3VtZW50IHBhc3NlZCB0byBzaWdtYSgpIGlzIGEgc3RyaW5nLCBpdCB3aWxsIGJlIGNvbnNpZGVyZWRcbiAgICAvLyAgICBhcyB0aGUgSUQgb2YgdGhlIERPTSBjb250YWluZXIuXG4gICAgaWYgKFxuICAgICAgdHlwZW9mIF9jb25mID09PSAnc3RyaW5nJyB8fFxuICAgICAgX2NvbmYgaW5zdGFuY2VvZiBIVE1MRWxlbWVudFxuICAgIClcbiAgICAgIF9jb25mID0ge1xuICAgICAgICByZW5kZXJlcnM6IFtfY29uZl1cbiAgICAgIH07XG4gICAgZWxzZSBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKF9jb25mKSA9PT0gJ1tvYmplY3QgQXJyYXldJylcbiAgICAgIF9jb25mID0ge1xuICAgICAgICByZW5kZXJlcnM6IF9jb25mXG4gICAgICB9O1xuXG4gICAgLy8gQWxzbyBjaGVjayBcInJlbmRlcmVyXCIgYW5kIFwiY29udGFpbmVyXCIga2V5czpcbiAgICBvID0gX2NvbmYucmVuZGVyZXJzIHx8IF9jb25mLnJlbmRlcmVyIHx8IF9jb25mLmNvbnRhaW5lcjtcbiAgICBpZiAoIV9jb25mLnJlbmRlcmVycyB8fCBfY29uZi5yZW5kZXJlcnMubGVuZ3RoID09PSAwKVxuICAgICAgaWYgKFxuICAgICAgICB0eXBlb2YgbyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgbyBpbnN0YW5jZW9mIEhUTUxFbGVtZW50IHx8XG4gICAgICAgICh0eXBlb2YgbyA9PT0gJ29iamVjdCcgJiYgJ2NvbnRhaW5lcicgaW4gbylcbiAgICAgIClcbiAgICAgICAgX2NvbmYucmVuZGVyZXJzID0gW29dO1xuXG4gICAgLy8gUmVjZW5zZSB0aGUgaW5zdGFuY2U6XG4gICAgaWYgKF9jb25mLmlkKSB7XG4gICAgICBpZiAoX19pbnN0YW5jZXNbX2NvbmYuaWRdKVxuICAgICAgICB0aHJvdyAnc2lnbWE6IEluc3RhbmNlIFwiJyArIF9jb25mLmlkICsgJ1wiIGFscmVhZHkgZXhpc3RzLic7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2lkJywge1xuICAgICAgICB2YWx1ZTogX2NvbmYuaWRcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZCA9IDA7XG4gICAgICB3aGlsZSAoX19pbnN0YW5jZXNbaWRdKVxuICAgICAgICBpZCsrO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdpZCcsIHtcbiAgICAgICAgdmFsdWU6ICcnICsgaWRcbiAgICAgIH0pO1xuICAgIH1cbiAgICBfX2luc3RhbmNlc1t0aGlzLmlkXSA9IHRoaXM7XG5cbiAgICAvLyBJbml0aWFsaXplIHNldHRpbmdzIGZ1bmN0aW9uOlxuICAgIHRoaXMuc2V0dGluZ3MgPSBuZXcgc2lnbWEuY2xhc3Nlcy5jb25maWd1cmFibGUoXG4gICAgICBzaWdtYS5zZXR0aW5ncyxcbiAgICAgIF9jb25mLnNldHRpbmdzIHx8IHt9XG4gICAgKTtcblxuICAgIC8vIEluaXRpYWxpemUgbG9ja2VkIGF0dHJpYnV0ZXM6XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdncmFwaCcsIHtcbiAgICAgIHZhbHVlOiBuZXcgc2lnbWEuY2xhc3Nlcy5ncmFwaCh0aGlzLnNldHRpbmdzKSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbWlkZGxld2FyZXMnLCB7XG4gICAgICB2YWx1ZTogW10sXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2NhbWVyYXMnLCB7XG4gICAgICB2YWx1ZToge30sXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3JlbmRlcmVycycsIHtcbiAgICAgIHZhbHVlOiB7fSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncmVuZGVyZXJzUGVyQ2FtZXJhJywge1xuICAgICAgdmFsdWU6IHt9LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdjYW1lcmFGcmFtZXMnLCB7XG4gICAgICB2YWx1ZToge30sXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2NhbWVyYScsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbWVyYXNbMF07XG4gICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdldmVudHMnLCB7XG4gICAgICB2YWx1ZTogW1xuICAgICAgICAnY2xpY2snLFxuICAgICAgICAncmlnaHRDbGljaycsXG4gICAgICAgICdjbGlja1N0YWdlJyxcbiAgICAgICAgJ2RvdWJsZUNsaWNrU3RhZ2UnLFxuICAgICAgICAncmlnaHRDbGlja1N0YWdlJyxcbiAgICAgICAgJ2NsaWNrTm9kZScsXG4gICAgICAgICdjbGlja05vZGVzJyxcbiAgICAgICAgJ2RvdWJsZUNsaWNrTm9kZScsXG4gICAgICAgICdkb3VibGVDbGlja05vZGVzJyxcbiAgICAgICAgJ3JpZ2h0Q2xpY2tOb2RlJyxcbiAgICAgICAgJ3JpZ2h0Q2xpY2tOb2RlcycsXG4gICAgICAgICdvdmVyTm9kZScsXG4gICAgICAgICdvdmVyTm9kZXMnLFxuICAgICAgICAnb3V0Tm9kZScsXG4gICAgICAgICdvdXROb2RlcycsXG4gICAgICAgICdkb3duTm9kZScsXG4gICAgICAgICdkb3duTm9kZXMnLFxuICAgICAgICAndXBOb2RlJyxcbiAgICAgICAgJ3VwTm9kZXMnXG4gICAgICBdLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG5cbiAgICAvLyBBZGQgYSBjdXN0b20gaGFuZGxlciwgdG8gcmVkaXNwYXRjaCBldmVudHMgZnJvbSByZW5kZXJlcnM6XG4gICAgdGhpcy5faGFuZGxlciA9IChmdW5jdGlvbihlKSB7XG4gICAgICB2YXIgayxcbiAgICAgICAgICBkYXRhID0ge307XG5cbiAgICAgIGZvciAoayBpbiBlLmRhdGEpXG4gICAgICAgIGRhdGFba10gPSBlLmRhdGFba107XG5cbiAgICAgIGRhdGEucmVuZGVyZXIgPSBlLnRhcmdldDtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChlLnR5cGUsIGRhdGEpO1xuICAgIH0pLmJpbmQodGhpcyk7XG5cbiAgICAvLyBJbml0aWFsaXplIHJlbmRlcmVyczpcbiAgICBhID0gX2NvbmYucmVuZGVyZXJzIHx8IFtdO1xuICAgIGZvciAoaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgIHRoaXMuYWRkUmVuZGVyZXIoYVtpXSk7XG5cbiAgICAvLyBJbml0aWFsaXplIG1pZGRsZXdhcmVzOlxuICAgIGEgPSBfY29uZi5taWRkbGV3YXJlcyB8fCBbXTtcbiAgICBmb3IgKGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICB0aGlzLm1pZGRsZXdhcmVzLnB1c2goXG4gICAgICAgIHR5cGVvZiBhW2ldID09PSAnc3RyaW5nJyA/XG4gICAgICAgICAgc2lnbWEubWlkZGxld2FyZXNbYVtpXV0gOlxuICAgICAgICAgIGFbaV1cbiAgICAgICk7XG5cbiAgICAvLyBDaGVjayBpZiB0aGVyZSBpcyBhbHJlYWR5IGEgZ3JhcGggdG8gZmlsbCBpbjpcbiAgICBpZiAodHlwZW9mIF9jb25mLmdyYXBoID09PSAnb2JqZWN0JyAmJiBfY29uZi5ncmFwaCkge1xuICAgICAgdGhpcy5ncmFwaC5yZWFkKF9jb25mLmdyYXBoKTtcblxuICAgICAgLy8gSWYgYSBncmFwaCBpcyBnaXZlbiB0byB0aGUgdG8gdGhlIGluc3RhbmNlLCB0aGUgXCJyZWZyZXNoXCIgbWV0aG9kIGlzXG4gICAgICAvLyBkaXJlY3RseSBjYWxsZWQ6XG4gICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICB9XG5cbiAgICAvLyBEZWFsIHdpdGggcmVzaXplOlxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChfc2VsZi5zZXR0aW5ncylcbiAgICAgICAgX3NlbGYucmVmcmVzaCgpO1xuICAgIH0pO1xuICB9O1xuXG5cblxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZHMgd2lsbCBpbnN0YW50aWF0ZSBhbmQgcmVmZXJlbmNlIGEgbmV3IGNhbWVyYS4gSWYgbm8gaWQgaXNcbiAgICogc3BlY2lmaWVkLCB0aGVuIGFuIGF1dG9tYXRpYyBpZCB3aWxsIGJlIGdlbmVyYXRlZC5cbiAgICpcbiAgICogQHBhcmFtICB7P3N0cmluZ30gICAgICAgICAgICAgIGlkIEV2ZW50dWFsbHkgdGhlIGNhbWVyYSBpZC5cbiAgICogQHJldHVybiB7c2lnbWEuY2xhc3Nlcy5jYW1lcmF9ICAgIFRoZSBmcmVzaCBuZXcgY2FtZXJhIGluc3RhbmNlLlxuICAgKi9cbiAgc2lnbWEucHJvdG90eXBlLmFkZENhbWVyYSA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBjYW1lcmE7XG5cbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGlkID0gMDtcbiAgICAgIHdoaWxlICh0aGlzLmNhbWVyYXNbJycgKyBpZF0pXG4gICAgICAgIGlkKys7XG4gICAgICBpZCA9ICcnICsgaWQ7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuY2FtZXJhc1tpZF0pXG4gICAgICB0aHJvdyAnc2lnbWEuYWRkQ2FtZXJhOiBUaGUgY2FtZXJhIFwiJyArIGlkICsgJ1wiIGFscmVhZHkgZXhpc3RzLic7XG5cbiAgICBjYW1lcmEgPSBuZXcgc2lnbWEuY2xhc3Nlcy5jYW1lcmEoaWQsIHRoaXMuZ3JhcGgsIHRoaXMuc2V0dGluZ3MpO1xuICAgIHRoaXMuY2FtZXJhc1tpZF0gPSBjYW1lcmE7XG5cbiAgICAvLyBBZGQgYSBxdWFkdHJlZSB0byB0aGUgY2FtZXJhOlxuICAgIGNhbWVyYS5xdWFkdHJlZSA9IG5ldyBzaWdtYS5jbGFzc2VzLnF1YWQoKTtcblxuICAgIC8vIEFkZCBhbiBlZGdlcXVhZHRyZWUgdG8gdGhlIGNhbWVyYTpcbiAgICBpZiAoc2lnbWEuY2xhc3Nlcy5lZGdlcXVhZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjYW1lcmEuZWRnZXF1YWR0cmVlID0gbmV3IHNpZ21hLmNsYXNzZXMuZWRnZXF1YWQoKTtcbiAgICB9XG5cbiAgICBjYW1lcmEuYmluZCgnY29vcmRpbmF0ZXNVcGRhdGVkJywgZnVuY3Rpb24oZSkge1xuICAgICAgc2VsZi5yZW5kZXJDYW1lcmEoY2FtZXJhLCBjYW1lcmEuaXNBbmltYXRlZCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLnJlbmRlcmVyc1BlckNhbWVyYVtpZF0gPSBbXTtcblxuICAgIHJldHVybiBjYW1lcmE7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGtpbGxzIGEgY2FtZXJhLCBhbmQgZXZlcnkgcmVuZGVyZXIgYXR0YWNoZWQgdG8gaXQuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ3xjYW1lcmF9IHYgVGhlIGNhbWVyYSB0byBraWxsIG9yIGl0cyBJRC5cbiAgICogQHJldHVybiB7c2lnbWF9ICAgICAgICAgICBSZXR1cm5zIHRoZSBpbnN0YW5jZS5cbiAgICovXG4gIHNpZ21hLnByb3RvdHlwZS5raWxsQ2FtZXJhID0gZnVuY3Rpb24odikge1xuICAgIHYgPSB0eXBlb2YgdiA9PT0gJ3N0cmluZycgPyB0aGlzLmNhbWVyYXNbdl0gOiB2O1xuXG4gICAgaWYgKCF2KVxuICAgICAgdGhyb3cgJ3NpZ21hLmtpbGxDYW1lcmE6IFRoZSBjYW1lcmEgaXMgdW5kZWZpbmVkLic7XG5cbiAgICB2YXIgaSxcbiAgICAgICAgbCxcbiAgICAgICAgYSA9IHRoaXMucmVuZGVyZXJzUGVyQ2FtZXJhW3YuaWRdO1xuXG4gICAgZm9yIChsID0gYS5sZW5ndGgsIGkgPSBsIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICB0aGlzLmtpbGxSZW5kZXJlcihhW2ldKTtcblxuICAgIGRlbGV0ZSB0aGlzLnJlbmRlcmVyc1BlckNhbWVyYVt2LmlkXTtcbiAgICBkZWxldGUgdGhpcy5jYW1lcmFGcmFtZXNbdi5pZF07XG4gICAgZGVsZXRlIHRoaXMuY2FtZXJhc1t2LmlkXTtcblxuICAgIGlmICh2LmtpbGwpXG4gICAgICB2LmtpbGwoKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZHMgd2lsbCBpbnN0YW50aWF0ZSBhbmQgcmVmZXJlbmNlIGEgbmV3IHJlbmRlcmVyLiBUaGUgXCJ0eXBlXCJcbiAgICogYXJndW1lbnQgY2FuIGJlIHRoZSBjb25zdHJ1Y3RvciBvciBpdHMgbmFtZSBpbiB0aGUgXCJzaWdtYS5yZW5kZXJlcnNcIlxuICAgKiBwYWNrYWdlLiBJZiBubyB0eXBlIGlzIHNwZWNpZmllZCwgdGhlbiBcInNpZ21hLnJlbmRlcmVycy5kZWZcIiB3aWxsIGJlIHVzZWQuXG4gICAqIElmIG5vIGlkIGlzIHNwZWNpZmllZCwgdGhlbiBhbiBhdXRvbWF0aWMgaWQgd2lsbCBiZSBnZW5lcmF0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSAgez9vYmplY3R9ICBvcHRpb25zIEV2ZW50dWFsbHkgc29tZSBvcHRpb25zIHRvIGdpdmUgdG8gdGhlIHJlbmRlcmVyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yLlxuICAgKiBAcmV0dXJuIHtyZW5kZXJlcn0gICAgICAgICBUaGUgZnJlc2ggbmV3IHJlbmRlcmVyIGluc3RhbmNlLlxuICAgKlxuICAgKiBSZWNvZ25pemVkIHBhcmFtZXRlcnM6XG4gICAqICoqKioqKioqKioqKioqKioqKioqKipcbiAgICogSGVyZSBpcyB0aGUgZXhoYXVzdGl2ZSBsaXN0IG9mIGV2ZXJ5IGFjY2VwdGVkIHBhcmFtZXRlcnMgaW4gdGhlIFwib3B0aW9uc1wiXG4gICAqIG9iamVjdDpcbiAgICpcbiAgICogICB7P3N0cmluZ30gICAgICAgICAgICBpZCAgICAgRXZlbnR1YWxseSB0aGUgcmVuZGVyZXIgaWQuXG4gICAqICAgez8oZnVuY3Rpb258c3RyaW5nKX0gdHlwZSAgIEV2ZW50dWFsbHkgdGhlIHJlbmRlcmVyIGNvbnN0cnVjdG9yIG9yIGl0c1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lIGluIHRoZSBcInNpZ21hLnJlbmRlcmVyc1wiIHBhY2thZ2UuXG4gICAqICAgez8oY2FtZXJhfHN0cmluZyl9ICAgY2FtZXJhIEV2ZW50dWFsbHkgdGhlIHJlbmRlcmVyIGNhbWVyYSBvciBpdHNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQuXG4gICAqL1xuICBzaWdtYS5wcm90b3R5cGUuYWRkUmVuZGVyZXIgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIGlkLFxuICAgICAgICBmbixcbiAgICAgICAgY2FtZXJhLFxuICAgICAgICByZW5kZXJlcixcbiAgICAgICAgbyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvLyBQb2x5bW9ycGhpc206XG4gICAgaWYgKHR5cGVvZiBvID09PSAnc3RyaW5nJylcbiAgICAgIG8gPSB7XG4gICAgICAgIGNvbnRhaW5lcjogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobylcbiAgICAgIH07XG4gICAgZWxzZSBpZiAobyBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KVxuICAgICAgbyA9IHtcbiAgICAgICAgY29udGFpbmVyOiBvXG4gICAgICB9O1xuXG4gICAgLy8gSWYgdGhlIGNvbnRhaW5lciBzdGlsbCBpcyBhIHN0cmluZywgd2UgZ2V0IGl0IGJ5IGlkXG4gICAgaWYgKHR5cGVvZiBvLmNvbnRhaW5lciA9PT0gJ3N0cmluZycpXG4gICAgICBvLmNvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG8uY29udGFpbmVyKTtcblxuICAgIC8vIFJlZmVyZW5jZSB0aGUgbmV3IHJlbmRlcmVyOlxuICAgIGlmICghKCdpZCcgaW4gbykpIHtcbiAgICAgIGlkID0gMDtcbiAgICAgIHdoaWxlICh0aGlzLnJlbmRlcmVyc1snJyArIGlkXSlcbiAgICAgICAgaWQrKztcbiAgICAgIGlkID0gJycgKyBpZDtcbiAgICB9IGVsc2VcbiAgICAgIGlkID0gby5pZDtcblxuICAgIGlmICh0aGlzLnJlbmRlcmVyc1tpZF0pXG4gICAgICB0aHJvdyAnc2lnbWEuYWRkUmVuZGVyZXI6IFRoZSByZW5kZXJlciBcIicgKyBpZCArICdcIiBhbHJlYWR5IGV4aXN0cy4nO1xuXG4gICAgLy8gRmluZCB0aGUgZ29vZCBjb25zdHJ1Y3RvcjpcbiAgICBmbiA9IHR5cGVvZiBvLnR5cGUgPT09ICdmdW5jdGlvbicgPyBvLnR5cGUgOiBzaWdtYS5yZW5kZXJlcnNbby50eXBlXTtcbiAgICBmbiA9IGZuIHx8IHNpZ21hLnJlbmRlcmVycy5kZWY7XG5cbiAgICAvLyBGaW5kIHRoZSBnb29kIGNhbWVyYTpcbiAgICBjYW1lcmEgPSAnY2FtZXJhJyBpbiBvID9cbiAgICAgIChcbiAgICAgICAgby5jYW1lcmEgaW5zdGFuY2VvZiBzaWdtYS5jbGFzc2VzLmNhbWVyYSA/XG4gICAgICAgICAgby5jYW1lcmEgOlxuICAgICAgICAgIHRoaXMuY2FtZXJhc1tvLmNhbWVyYV0gfHwgdGhpcy5hZGRDYW1lcmEoby5jYW1lcmEpXG4gICAgICApIDpcbiAgICAgIHRoaXMuYWRkQ2FtZXJhKCk7XG5cbiAgICBpZiAodGhpcy5jYW1lcmFzW2NhbWVyYS5pZF0gIT09IGNhbWVyYSlcbiAgICAgIHRocm93ICdzaWdtYS5hZGRSZW5kZXJlcjogVGhlIGNhbWVyYSBpcyBub3QgcHJvcGVybHkgcmVmZXJlbmNlZC4nO1xuXG4gICAgLy8gSW5zdGFudGlhdGU6XG4gICAgcmVuZGVyZXIgPSBuZXcgZm4odGhpcy5ncmFwaCwgY2FtZXJhLCB0aGlzLnNldHRpbmdzLCBvKTtcbiAgICB0aGlzLnJlbmRlcmVyc1tpZF0gPSByZW5kZXJlcjtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVuZGVyZXIsICdpZCcsIHtcbiAgICAgIHZhbHVlOiBpZFxuICAgIH0pO1xuXG4gICAgLy8gQmluZCBldmVudHM6XG4gICAgaWYgKHJlbmRlcmVyLmJpbmQpXG4gICAgICByZW5kZXJlci5iaW5kKFxuICAgICAgICBbXG4gICAgICAgICAgJ2NsaWNrJyxcbiAgICAgICAgICAncmlnaHRDbGljaycsXG4gICAgICAgICAgJ2NsaWNrU3RhZ2UnLFxuICAgICAgICAgICdkb3VibGVDbGlja1N0YWdlJyxcbiAgICAgICAgICAncmlnaHRDbGlja1N0YWdlJyxcbiAgICAgICAgICAnY2xpY2tOb2RlJyxcbiAgICAgICAgICAnY2xpY2tOb2RlcycsXG4gICAgICAgICAgJ2NsaWNrRWRnZScsXG4gICAgICAgICAgJ2NsaWNrRWRnZXMnLFxuICAgICAgICAgICdkb3VibGVDbGlja05vZGUnLFxuICAgICAgICAgICdkb3VibGVDbGlja05vZGVzJyxcbiAgICAgICAgICAnZG91YmxlQ2xpY2tFZGdlJyxcbiAgICAgICAgICAnZG91YmxlQ2xpY2tFZGdlcycsXG4gICAgICAgICAgJ3JpZ2h0Q2xpY2tOb2RlJyxcbiAgICAgICAgICAncmlnaHRDbGlja05vZGVzJyxcbiAgICAgICAgICAncmlnaHRDbGlja0VkZ2UnLFxuICAgICAgICAgICdyaWdodENsaWNrRWRnZXMnLFxuICAgICAgICAgICdvdmVyTm9kZScsXG4gICAgICAgICAgJ292ZXJOb2RlcycsXG4gICAgICAgICAgJ292ZXJFZGdlJyxcbiAgICAgICAgICAnb3ZlckVkZ2VzJyxcbiAgICAgICAgICAnb3V0Tm9kZScsXG4gICAgICAgICAgJ291dE5vZGVzJyxcbiAgICAgICAgICAnb3V0RWRnZScsXG4gICAgICAgICAgJ291dEVkZ2VzJyxcbiAgICAgICAgICAnZG93bk5vZGUnLFxuICAgICAgICAgICdkb3duTm9kZXMnLFxuICAgICAgICAgICdkb3duRWRnZScsXG4gICAgICAgICAgJ2Rvd25FZGdlcycsXG4gICAgICAgICAgJ3VwTm9kZScsXG4gICAgICAgICAgJ3VwTm9kZXMnLFxuICAgICAgICAgICd1cEVkZ2UnLFxuICAgICAgICAgICd1cEVkZ2VzJ1xuICAgICAgICBdLFxuICAgICAgICB0aGlzLl9oYW5kbGVyXG4gICAgICApO1xuXG4gICAgLy8gUmVmZXJlbmNlIHRoZSByZW5kZXJlciBieSBpdHMgY2FtZXJhOlxuICAgIHRoaXMucmVuZGVyZXJzUGVyQ2FtZXJhW2NhbWVyYS5pZF0ucHVzaChyZW5kZXJlcik7XG5cbiAgICByZXR1cm4gcmVuZGVyZXI7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGtpbGxzIGEgcmVuZGVyZXIuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ3xyZW5kZXJlcn0gdiBUaGUgcmVuZGVyZXIgdG8ga2lsbCBvciBpdHMgSUQuXG4gICAqIEByZXR1cm4ge3NpZ21hfSAgICAgICAgICAgICBSZXR1cm5zIHRoZSBpbnN0YW5jZS5cbiAgICovXG4gIHNpZ21hLnByb3RvdHlwZS5raWxsUmVuZGVyZXIgPSBmdW5jdGlvbih2KSB7XG4gICAgdiA9IHR5cGVvZiB2ID09PSAnc3RyaW5nJyA/IHRoaXMucmVuZGVyZXJzW3ZdIDogdjtcblxuICAgIGlmICghdilcbiAgICAgIHRocm93ICdzaWdtYS5raWxsUmVuZGVyZXI6IFRoZSByZW5kZXJlciBpcyB1bmRlZmluZWQuJztcblxuICAgIHZhciBhID0gdGhpcy5yZW5kZXJlcnNQZXJDYW1lcmFbdi5jYW1lcmEuaWRdLFxuICAgICAgICBpID0gYS5pbmRleE9mKHYpO1xuXG4gICAgaWYgKGkgPj0gMClcbiAgICAgIGEuc3BsaWNlKGksIDEpO1xuXG4gICAgaWYgKHYua2lsbClcbiAgICAgIHYua2lsbCgpO1xuXG4gICAgZGVsZXRlIHRoaXMucmVuZGVyZXJzW3YuaWRdO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cblxuXG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGNhbGxzIHRoZSBcInJlbmRlclwiIG1ldGhvZCBvZiBlYWNoIHJlbmRlcmVyLCB3aXRoIHRoZSBzYW1lXG4gICAqIGFyZ3VtZW50cyB0aGFuIHRoZSBcInJlbmRlclwiIG1ldGhvZCwgYnV0IHdpbGwgYWxzbyBjaGVjayBpZiB0aGUgcmVuZGVyZXJcbiAgICogaGFzIGEgXCJwcm9jZXNzXCIgbWV0aG9kLCBhbmQgY2FsbCBpdCBpZiBpdCBleGlzdHMuXG4gICAqXG4gICAqIEl0IGlzIHVzZWZ1bCBmb3IgcXVhZHRyZWVzIG9yIFdlYkdMIHByb2Nlc3NpbmcsIGZvciBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtICB7P29iamVjdH0gIG9wdGlvbnMgRXZlbnR1YWxseSBzb21lIG9wdGlvbnMgdG8gZ2l2ZSB0byB0aGUgcmVmcmVzaFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2QuXG4gICAqIEByZXR1cm4ge3NpZ21hfSAgICAgICAgICAgIFJldHVybnMgdGhlIGluc3RhbmNlIGl0c2VsZi5cbiAgICpcbiAgICogUmVjb2duaXplZCBwYXJhbWV0ZXJzOlxuICAgKiAqKioqKioqKioqKioqKioqKioqKioqXG4gICAqIEhlcmUgaXMgdGhlIGV4aGF1c3RpdmUgbGlzdCBvZiBldmVyeSBhY2NlcHRlZCBwYXJhbWV0ZXJzIGluIHRoZSBcIm9wdGlvbnNcIlxuICAgKiBvYmplY3Q6XG4gICAqXG4gICAqICAgez9ib29sZWFufSBza2lwSW5kZXhhdGlvbiBBIGZsYWcgc3BlY2lmeWluZyB3ZXRoZXIgb3Igbm90IHRoZSByZWZyZXNoXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBzaG91bGQgcmVpbmRleCB0aGUgZ3JhcGggaW4gdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWFkdHJlZXMgb3Igbm90IChkZWZhdWx0OiBmYWxzZSkuXG4gICAqL1xuICBzaWdtYS5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgbCxcbiAgICAgICAgayxcbiAgICAgICAgYSxcbiAgICAgICAgYyxcbiAgICAgICAgYm91bmRzLFxuICAgICAgICBwcmVmaXggPSAwO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvLyBDYWxsIGVhY2ggbWlkZGxld2FyZTpcbiAgICBhID0gdGhpcy5taWRkbGV3YXJlcyB8fCBbXTtcbiAgICBmb3IgKGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICBhW2ldLmNhbGwoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIChpID09PSAwKSA/ICcnIDogJ3RtcCcgKyBwcmVmaXggKyAnOicsXG4gICAgICAgIChpID09PSBsIC0gMSkgPyAncmVhZHk6JyA6ICgndG1wJyArICgrK3ByZWZpeCkgKyAnOicpXG4gICAgICApO1xuXG4gICAgLy8gVGhlbiwgZm9yIGVhY2ggY2FtZXJhLCBjYWxsIHRoZSBcInJlc2NhbGVcIiBtaWRkbGV3YXJlLCB1bmxlc3MgdGhlXG4gICAgLy8gc2V0dGluZ3Mgc3BlY2lmeSBub3QgdG86XG4gICAgZm9yIChrIGluIHRoaXMuY2FtZXJhcykge1xuICAgICAgYyA9IHRoaXMuY2FtZXJhc1trXTtcbiAgICAgIGlmIChcbiAgICAgICAgYy5zZXR0aW5ncygnYXV0b1Jlc2NhbGUnKSAmJlxuICAgICAgICB0aGlzLnJlbmRlcmVyc1BlckNhbWVyYVtjLmlkXSAmJlxuICAgICAgICB0aGlzLnJlbmRlcmVyc1BlckNhbWVyYVtjLmlkXS5sZW5ndGhcbiAgICAgIClcbiAgICAgICAgc2lnbWEubWlkZGxld2FyZXMucmVzY2FsZS5jYWxsKFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgYS5sZW5ndGggPyAncmVhZHk6JyA6ICcnLFxuICAgICAgICAgIGMucmVhZFByZWZpeCxcbiAgICAgICAgICB7XG4gICAgICAgICAgICB3aWR0aDogdGhpcy5yZW5kZXJlcnNQZXJDYW1lcmFbYy5pZF1bMF0ud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMucmVuZGVyZXJzUGVyQ2FtZXJhW2MuaWRdWzBdLmhlaWdodFxuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgIGVsc2VcbiAgICAgICAgc2lnbWEubWlkZGxld2FyZXMuY29weS5jYWxsKFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgYS5sZW5ndGggPyAncmVhZHk6JyA6ICcnLFxuICAgICAgICAgIGMucmVhZFByZWZpeFxuICAgICAgICApO1xuXG4gICAgICBpZiAoIW9wdGlvbnMuc2tpcEluZGV4YXRpb24pIHtcbiAgICAgICAgLy8gRmluZCBncmFwaCBib3VuZGFyaWVzOlxuICAgICAgICBib3VuZHMgPSBzaWdtYS51dGlscy5nZXRCb3VuZGFyaWVzKFxuICAgICAgICAgIHRoaXMuZ3JhcGgsXG4gICAgICAgICAgYy5yZWFkUHJlZml4XG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gUmVmcmVzaCBxdWFkdHJlZTpcbiAgICAgICAgYy5xdWFkdHJlZS5pbmRleCh0aGlzLmdyYXBoLm5vZGVzKCksIHtcbiAgICAgICAgICBwcmVmaXg6IGMucmVhZFByZWZpeCxcbiAgICAgICAgICBib3VuZHM6IHtcbiAgICAgICAgICAgIHg6IGJvdW5kcy5taW5YLFxuICAgICAgICAgICAgeTogYm91bmRzLm1pblksXG4gICAgICAgICAgICB3aWR0aDogYm91bmRzLm1heFggLSBib3VuZHMubWluWCxcbiAgICAgICAgICAgIGhlaWdodDogYm91bmRzLm1heFkgLSBib3VuZHMubWluWVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gUmVmcmVzaCBlZGdlcXVhZHRyZWU6XG4gICAgICAgIGlmIChcbiAgICAgICAgICBjLmVkZ2VxdWFkdHJlZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgYy5zZXR0aW5ncygnZHJhd0VkZ2VzJykgJiZcbiAgICAgICAgICBjLnNldHRpbmdzKCdlbmFibGVFZGdlSG92ZXJpbmcnKVxuICAgICAgICApIHtcbiAgICAgICAgICBjLmVkZ2VxdWFkdHJlZS5pbmRleCh0aGlzLmdyYXBoLCB7XG4gICAgICAgICAgICBwcmVmaXg6IGMucmVhZFByZWZpeCxcbiAgICAgICAgICAgIGJvdW5kczoge1xuICAgICAgICAgICAgICB4OiBib3VuZHMubWluWCxcbiAgICAgICAgICAgICAgeTogYm91bmRzLm1pblksXG4gICAgICAgICAgICAgIHdpZHRoOiBib3VuZHMubWF4WCAtIGJvdW5kcy5taW5YLFxuICAgICAgICAgICAgICBoZWlnaHQ6IGJvdW5kcy5tYXhZIC0gYm91bmRzLm1pbllcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENhbGwgZWFjaCByZW5kZXJlcjpcbiAgICBhID0gT2JqZWN0LmtleXModGhpcy5yZW5kZXJlcnMpO1xuICAgIGZvciAoaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgIGlmICh0aGlzLnJlbmRlcmVyc1thW2ldXS5wcm9jZXNzKSB7XG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzKCdza2lwRXJyb3JzJykpXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXJzW2FbaV1dLnByb2Nlc3MoKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgJ1dhcm5pbmc6IFRoZSByZW5kZXJlciBcIicgKyBhW2ldICsgJ1wiIGNyYXNoZWQgb24gXCIucHJvY2VzcygpXCInXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgIHRoaXMucmVuZGVyZXJzW2FbaV1dLnByb2Nlc3MoKTtcbiAgICAgIH1cblxuICAgIHRoaXMucmVuZGVyKCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgY2FsbHMgdGhlIFwicmVuZGVyXCIgbWV0aG9kIG9mIGVhY2ggcmVuZGVyZXIuXG4gICAqXG4gICAqIEByZXR1cm4ge3NpZ21hfSBSZXR1cm5zIHRoZSBpbnN0YW5jZSBpdHNlbGYuXG4gICAqL1xuICBzaWdtYS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGksXG4gICAgICAgIGwsXG4gICAgICAgIGEsXG4gICAgICAgIHByZWZpeCA9IDA7XG5cbiAgICAvLyBDYWxsIGVhY2ggcmVuZGVyZXI6XG4gICAgYSA9IE9iamVjdC5rZXlzKHRoaXMucmVuZGVyZXJzKTtcbiAgICBmb3IgKGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICBpZiAodGhpcy5zZXR0aW5ncygnc2tpcEVycm9ycycpKVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMucmVuZGVyZXJzW2FbaV1dLnJlbmRlcigpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MoJ3ZlcmJvc2UnKSlcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICAnV2FybmluZzogVGhlIHJlbmRlcmVyIFwiJyArIGFbaV0gKyAnXCIgY3Jhc2hlZCBvbiBcIi5yZW5kZXIoKVwiJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgZWxzZVxuICAgICAgICB0aGlzLnJlbmRlcmVyc1thW2ldXS5yZW5kZXIoKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBjYWxscyB0aGUgXCJyZW5kZXJcIiBtZXRob2Qgb2YgZWFjaCByZW5kZXJlciB0aGF0IGlzIGJvdW5kIHRvXG4gICAqIHRoZSBzcGVjaWZpZWQgY2FtZXJhLiBUbyBpbXByb3ZlIHRoZSBwZXJmb3JtYW5jZXMsIGlmIHRoaXMgbWV0aG9kIGlzXG4gICAqIGNhbGxlZCB0b28gb2Z0ZW4sIHRoZSBudW1iZXIgb2YgZWZmZWN0aXZlIHJlbmRlcmluZ3MgaXMgbGltaXRhdGVkIHRvIG9uZVxuICAgKiBwZXIgZnJhbWUsIHVubGVzcyB5b3UgYXJlIHVzaW5nIHRoZSBcImZvcmNlXCIgZmxhZy5cbiAgICpcbiAgICogQHBhcmFtICB7c2lnbWEuY2xhc3Nlcy5jYW1lcmF9IGNhbWVyYSBUaGUgY2FtZXJhIHRvIHJlbmRlci5cbiAgICogQHBhcmFtICB7P2Jvb2xlYW59ICAgICAgICAgICAgIGZvcmNlICBJZiB0cnVlLCB3aWxsIHJlbmRlciB0aGUgY2FtZXJhXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0bHkuXG4gICAqIEByZXR1cm4ge3NpZ21hfSAgICAgICAgICAgICAgICAgICAgICAgUmV0dXJucyB0aGUgaW5zdGFuY2UgaXRzZWxmLlxuICAgKi9cbiAgc2lnbWEucHJvdG90eXBlLnJlbmRlckNhbWVyYSA9IGZ1bmN0aW9uKGNhbWVyYSwgZm9yY2UpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgbCxcbiAgICAgICAgYSxcbiAgICAgICAgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAoZm9yY2UpIHtcbiAgICAgIGEgPSB0aGlzLnJlbmRlcmVyc1BlckNhbWVyYVtjYW1lcmEuaWRdO1xuICAgICAgZm9yIChpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncygnc2tpcEVycm9ycycpKVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhW2ldLnJlbmRlcigpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzKCd2ZXJib3NlJykpXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICAgICdXYXJuaW5nOiBUaGUgcmVuZGVyZXIgXCInICsgYVtpXS5pZCArICdcIiBjcmFzaGVkIG9uIFwiLnJlbmRlcigpXCInXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgYVtpXS5yZW5kZXIoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCF0aGlzLmNhbWVyYUZyYW1lc1tjYW1lcmEuaWRdKSB7XG4gICAgICAgIGEgPSB0aGlzLnJlbmRlcmVyc1BlckNhbWVyYVtjYW1lcmEuaWRdO1xuICAgICAgICBmb3IgKGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MoJ3NraXBFcnJvcnMnKSlcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGFbaV0ucmVuZGVyKCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzKCd2ZXJib3NlJykpXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgICAgICAnV2FybmluZzogVGhlIHJlbmRlcmVyIFwiJyArXG4gICAgICAgICAgICAgICAgICAgIGFbaV0uaWQgK1xuICAgICAgICAgICAgICAgICAgICAnXCIgY3Jhc2hlZCBvbiBcIi5yZW5kZXIoKVwiJ1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgYVtpXS5yZW5kZXIoKTtcblxuICAgICAgICB0aGlzLmNhbWVyYUZyYW1lc1tjYW1lcmEuaWRdID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGRlbGV0ZSBzZWxmLmNhbWVyYUZyYW1lc1tjYW1lcmEuaWRdO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgY2FsbHMgdGhlIFwia2lsbFwiIG1ldGhvZCBvZiBlYWNoIG1vZHVsZSBhbmQgZGVzdHJveXMgYW55XG4gICAqIHJlZmVyZW5jZSBmcm9tIHRoZSBpbnN0YW5jZS5cbiAgICovXG4gIHNpZ21hLnByb3RvdHlwZS5raWxsID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGs7XG5cbiAgICAvLyBEaXNwYXRjaGluZyBldmVudFxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudCgna2lsbCcpO1xuXG4gICAgLy8gS2lsbCBncmFwaDpcbiAgICB0aGlzLmdyYXBoLmtpbGwoKTtcblxuICAgIC8vIEtpbGwgbWlkZGxld2FyZXM6XG4gICAgZGVsZXRlIHRoaXMubWlkZGxld2FyZXM7XG5cbiAgICAvLyBLaWxsIGVhY2ggcmVuZGVyZXI6XG4gICAgZm9yIChrIGluIHRoaXMucmVuZGVyZXJzKVxuICAgICAgdGhpcy5raWxsUmVuZGVyZXIodGhpcy5yZW5kZXJlcnNba10pO1xuXG4gICAgLy8gS2lsbCBlYWNoIGNhbWVyYTpcbiAgICBmb3IgKGsgaW4gdGhpcy5jYW1lcmFzKVxuICAgICAgdGhpcy5raWxsQ2FtZXJhKHRoaXMuY2FtZXJhc1trXSk7XG5cbiAgICBkZWxldGUgdGhpcy5yZW5kZXJlcnM7XG4gICAgZGVsZXRlIHRoaXMuY2FtZXJhcztcblxuICAgIC8vIEtpbGwgZXZlcnl0aGluZyBlbHNlOlxuICAgIGZvciAoayBpbiB0aGlzKVxuICAgICAgaWYgKHRoaXMuaGFzT3duUHJvcGVydHkoaykpXG4gICAgICAgIGRlbGV0ZSB0aGlzW2tdO1xuXG4gICAgZGVsZXRlIF9faW5zdGFuY2VzW3RoaXMuaWRdO1xuICB9O1xuXG5cblxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIGluc3RhbmNlcyBvYmplY3Qgb3IgYSBzcGVjaWZpYyBydW5uaW5nIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0gIHs/c3RyaW5nfSBpZCBFdmVudHVhbGx5IGFuIGluc3RhbmNlIElELlxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICBUaGUgcmVsYXRlZCBpbnN0YW5jZSBvciBhIGNsb25lIG9mIHRoZSBpbnN0YW5jZXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgb2JqZWN0LlxuICAgKi9cbiAgc2lnbWEuaW5zdGFuY2VzID0gZnVuY3Rpb24oaWQpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/XG4gICAgICBfX2luc3RhbmNlc1tpZF0gOlxuICAgICAgc2lnbWEudXRpbHMuZXh0ZW5kKHt9LCBfX2luc3RhbmNlcyk7XG4gIH07XG5cblxuXG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCB2ZXJzaW9uIG9mIHNpZ21hOlxuICAgKi9cbiAgc2lnbWEudmVyc2lvbiA9ICcxLjIuMSc7XG5cblxuXG5cbiAgLyoqXG4gICAqIEVYUE9SVDpcbiAgICogKioqKioqKlxuICAgKi9cbiAgaWYgKHR5cGVvZiB0aGlzLnNpZ21hICE9PSAndW5kZWZpbmVkJylcbiAgICB0aHJvdyAnQW4gb2JqZWN0IGNhbGxlZCBzaWdtYSBpcyBhbHJlYWR5IGluIHRoZSBnbG9iYWwgc2NvcGUuJztcblxuICB0aGlzLnNpZ21hID0gc2lnbWE7XG5cbn0pLmNhbGwodGhpcyk7XG5cbi8qKlxuICogY29ucmFkLmpzIGlzIGEgdGlueSBKYXZhU2NyaXB0IGpvYnMgc2NoZWR1bGVyLFxuICpcbiAqIFZlcnNpb246IDAuMS4wXG4gKiBTb3VyY2VzOiBodHRwOi8vZ2l0aHViLmNvbS9qYWNvbXlhbC9jb25yYWQuanNcbiAqIERvYzogICAgIGh0dHA6Ly9naXRodWIuY29tL2phY29teWFsL2NvbnJhZC5qcyNyZWFkbWVcbiAqXG4gKiBMaWNlbnNlOlxuICogLS0tLS0tLS1cbiAqIENvcHlyaWdodCDCqSAyMDEzIEFsZXhpcyBKYWNvbXksIFNjaWVuY2VzLVBvIG3DqWRpYWxhYlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvXG4gKiBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZVxuICogcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yXG4gKiBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVGhlIFNvZnR3YXJlIGlzIHByb3ZpZGVkIFwiYXMgaXNcIiwgd2l0aG91dCB3YXJyYW50eSBvZiBhbnkga2luZCwgZXhwcmVzcyBvclxuICogaW1wbGllZCwgaW5jbHVkaW5nIGJ1dCBub3QgbGltaXRlZCB0byB0aGUgd2FycmFudGllcyBvZiBtZXJjaGFudGFiaWxpdHksXG4gKiBmaXRuZXNzIGZvciBhIHBhcnRpY3VsYXIgcHVycG9zZSBhbmQgbm9uaW5mcmluZ2VtZW50LiBJbiBubyBldmVudCBzaGFsbCB0aGVcbiAqIGF1dGhvcnMgb3IgY29weXJpZ2h0IGhvbGRlcnMgYmUgbGlhYmxlIGZvciBhbnkgY2xhaW0sIGRhbWFnZXMgb3Igb3RoZXJcbiAqIGxpYWJpbGl0eSwgd2hldGhlciBpbiBhbiBhY3Rpb24gb2YgY29udHJhY3QsIHRvcnQgb3Igb3RoZXJ3aXNlLCBhcmlzaW5nXG4gKiBmcm9tLCBvdXQgb2Ygb3IgaW4gY29ubmVjdGlvbiB3aXRoIHRoZSBzb2Z0d2FyZSBvciB0aGUgdXNlIG9yIG90aGVyIGRlYWxpbmdzXG4gKiBpbiB0aGUgU29mdHdhcmUuXG4gKi9cbihmdW5jdGlvbihnbG9iYWwpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIENoZWNrIHRoYXQgY29ucmFkLmpzIGhhcyBub3QgYmVlbiBsb2FkZWQgeWV0OlxuICBpZiAoZ2xvYmFsLmNvbnJhZClcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbnJhZCBhbHJlYWR5IGV4aXN0cycpO1xuXG5cbiAgLyoqXG4gICAqIFBSSVZBVEUgVkFSSUFCTEVTOlxuICAgKiAqKioqKioqKioqKioqKioqKipcbiAgICovXG5cbiAgLyoqXG4gICAqIEEgZmxhZyBpbmRpY2F0aW5nIHdoZXRoZXIgY29ucmFkIGlzIHJ1bm5pbmcgb3Igbm90LlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgdmFyIF9sYXN0RnJhbWVUaW1lO1xuXG4gIC8qKlxuICAgKiBBIGZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIGNvbnJhZCBpcyBydW5uaW5nIG9yIG5vdC5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICB2YXIgX2lzUnVubmluZyA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBUaGUgaGFzaCBvZiByZWdpc3RlcmVkIGpvYnMuIEVhY2ggam9iIG11c3QgYXQgbGVhc3QgaGF2ZSBhIHVuaXF1ZSBJRFxuICAgKiB1bmRlciB0aGUga2V5IFwiaWRcIiBhbmQgYSBmdW5jdGlvbiB1bmRlciB0aGUga2V5IFwiam9iXCIuIFRoaXMgaGFzaFxuICAgKiBjb250YWlucyBlYWNoIHJ1bm5pbmcgam9iIGFuZCBlYWNoIHdhaXRpbmcgam9iLlxuICAgKlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgdmFyIF9qb2JzID0ge307XG5cbiAgLyoqXG4gICAqIFRoZSBoYXNoIG9mIGN1cnJlbnRseSBydW5uaW5nIGpvYnMuXG4gICAqXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICB2YXIgX3J1bm5pbmdKb2JzID0ge307XG5cbiAgLyoqXG4gICAqIFRoZSBhcnJheSBvZiBjdXJyZW50bHkgcnVubmluZyBqb2JzLCBzb3J0ZWQgYnkgcHJpb3JpdHkuXG4gICAqXG4gICAqIEB0eXBlIHtBcnJheX1cbiAgICovXG4gIHZhciBfc29ydGVkQnlQcmlvcml0eUpvYnMgPSBbXTtcblxuICAvKipcbiAgICogVGhlIGFycmF5IG9mIGN1cnJlbnRseSB3YWl0aW5nIGpvYnMuXG4gICAqXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICB2YXIgX3dhaXRpbmdKb2JzID0ge307XG5cbiAgLyoqXG4gICAqIFRoZSBhcnJheSBvZiBmaW5pc2hlZCBqb2JzLiBUaGV5IGFyZSBzdG9yZWQgaW4gYW4gYXJyYXksIHNpbmNlIHR3byBqb2JzXG4gICAqIHdpdGggdGhlIHNhbWUgXCJpZFwiIGNhbiBoYXBwZW4gYXQgdHdvIGRpZmZlcmVudCB0aW1lcy5cbiAgICpcbiAgICogQHR5cGUge0FycmF5fVxuICAgKi9cbiAgdmFyIF9kb25lSm9icyA9IFtdO1xuXG4gIC8qKlxuICAgKiBBIGRpcnR5IGZsYWcgdG8ga2VlcCBjb25yYWQgZnJvbSBzdGFydGluZzogSW5kZWVkLCB3aGVuIGFkZEpvYigpIGlzIGNhbGxlZFxuICAgKiB3aXRoIHNldmVyYWwgam9icywgY29ucmFkIG11c3QgYmUgc3RhcnRlZCBvbmx5IGF0IHRoZSBlbmQuIFRoaXMgZmxhZyBrZWVwc1xuICAgKiBtZSBmcm9tIGR1cGxpY2F0aW5nIHRoZSBjb2RlIHRoYXQgZWZmZWN0aXZlbHkgYWRkcyBhIGpvYi5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICB2YXIgX25vU3RhcnQgPSBmYWxzZTtcblxuICAvKipcbiAgICogQW4gaGFzaCBjb250YWluaW5nIHNvbWUgZ2xvYmFsIHNldHRpbmdzIGFib3V0IGhvdyBjb25yYWQuanMgc2hvdWxkXG4gICAqIGJlaGF2ZS5cbiAgICpcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHZhciBfcGFyYW1ldGVycyA9IHtcbiAgICBmcmFtZUR1cmF0aW9uOiAyMCxcbiAgICBoaXN0b3J5OiB0cnVlXG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgb2JqZWN0IGNvbnRhaW5zIGV2ZXJ5IGhhbmRsZXJzIGJvdW5kIHRvIGNvbnJhZCBldmVudHMuIEl0IGRvZXMgbm90XG4gICAqIHJlcXVpcmVhIGFueSBET00gaW1wbGVtZW50YXRpb24sIHNpbmNlIHRoZSBldmVudHMgYXJlIGFsbCBKYXZhU2NyaXB0LlxuICAgKlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgdmFyIF9oYW5kbGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cblxuICAvKipcbiAgICogUFJJVkFURSBGVU5DVElPTlM6XG4gICAqICoqKioqKioqKioqKioqKioqKlxuICAgKi9cblxuICAvKipcbiAgICogV2lsbCBleGVjdXRlIHRoZSBoYW5kbGVyIGV2ZXJ5dGltZSB0aGF0IHRoZSBpbmRpY2F0ZWQgZXZlbnQgKG9yIHRoZVxuICAgKiBpbmRpY2F0ZWQgZXZlbnRzKSB3aWxsIGJlIHRyaWdnZXJlZC5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfGFycmF5fG9iamVjdH0gZXZlbnRzICBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgKG9yIHRoZSBldmVudHNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXBhcmF0ZWQgYnkgc3BhY2VzKS5cbiAgICogQHBhcmFtICB7ZnVuY3Rpb24oT2JqZWN0KX0gICAgaGFuZGxlciBUaGUgaGFuZGxlciB0byBiaW5kLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgICAgICAgICAgICAgIFJldHVybnMgY29ucmFkLlxuICAgKi9cbiAgZnVuY3Rpb24gX2JpbmQoZXZlbnRzLCBoYW5kbGVyKSB7XG4gICAgdmFyIGksXG4gICAgICAgIGlfZW5kLFxuICAgICAgICBldmVudCxcbiAgICAgICAgZUFycmF5O1xuXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKVxuICAgICAgcmV0dXJuO1xuICAgIGVsc2UgaWYgKFxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgT2JqZWN0KGFyZ3VtZW50c1swXSkgPT09IGFyZ3VtZW50c1swXVxuICAgIClcbiAgICAgIGZvciAoZXZlbnRzIGluIGFyZ3VtZW50c1swXSlcbiAgICAgICAgX2JpbmQoZXZlbnRzLCBhcmd1bWVudHNbMF1bZXZlbnRzXSk7XG4gICAgZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGVBcnJheSA9XG4gICAgICAgIEFycmF5LmlzQXJyYXkoZXZlbnRzKSA/XG4gICAgICAgICAgZXZlbnRzIDpcbiAgICAgICAgICBldmVudHMuc3BsaXQoLyAvKTtcblxuICAgICAgZm9yIChpID0gMCwgaV9lbmQgPSBlQXJyYXkubGVuZ3RoOyBpICE9PSBpX2VuZDsgaSArPSAxKSB7XG4gICAgICAgIGV2ZW50ID0gZUFycmF5W2ldO1xuXG4gICAgICAgIGlmICghX2hhbmRsZXJzW2V2ZW50XSlcbiAgICAgICAgICBfaGFuZGxlcnNbZXZlbnRdID0gW107XG5cbiAgICAgICAgLy8gVXNpbmcgYW4gb2JqZWN0IGluc3RlYWQgb2YgZGlyZWN0bHkgdGhlIGhhbmRsZXIgd2lsbCBtYWtlIHBvc3NpYmxlXG4gICAgICAgIC8vIGxhdGVyIHRvIGFkZCBmbGFnc1xuICAgICAgICBfaGFuZGxlcnNbZXZlbnRdLnB1c2goe1xuICAgICAgICAgIGhhbmRsZXI6IGhhbmRsZXJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIGhhbmRsZXIgZnJvbSBhIHNwZWNpZmllZCBldmVudCAob3Igc3BlY2lmaWVkIGV2ZW50cykuXG4gICAqXG4gICAqIEBwYXJhbSAgez9zdHJpbmd9ICAgICAgICAgICBldmVudHMgIFRoZSBuYW1lIG9mIHRoZSBldmVudCAob3IgdGhlIGV2ZW50c1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXBhcmF0ZWQgYnkgc3BhY2VzKS4gSWYgdW5kZWZpbmVkLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGVuIGFsbCBoYW5kbGVycyBhcmUgcmVtb3ZlZC5cbiAgICogQHBhcmFtICB7P2Z1bmN0aW9uKE9iamVjdCl9IGhhbmRsZXIgVGhlIGhhbmRsZXIgdG8gdW5iaW5kLiBJZiB1bmRlZmluZWQsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVhY2ggaGFuZGxlciBib3VuZCB0byB0aGUgZXZlbnQgb3IgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50cyB3aWxsIGJlIHJlbW92ZWQuXG4gICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgICBSZXR1cm5zIGNvbnJhZC5cbiAgICovXG4gIGZ1bmN0aW9uIF91bmJpbmQoZXZlbnRzLCBoYW5kbGVyKSB7XG4gICAgdmFyIGksXG4gICAgICAgIGlfZW5kLFxuICAgICAgICBqLFxuICAgICAgICBqX2VuZCxcbiAgICAgICAgYSxcbiAgICAgICAgZXZlbnQsXG4gICAgICAgIGVBcnJheSA9IEFycmF5LmlzQXJyYXkoZXZlbnRzKSA/XG4gICAgICAgICAgICAgICAgICAgZXZlbnRzIDpcbiAgICAgICAgICAgICAgICAgICBldmVudHMuc3BsaXQoLyAvKTtcblxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aClcbiAgICAgIF9oYW5kbGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZWxzZSBpZiAoaGFuZGxlcikge1xuICAgICAgZm9yIChpID0gMCwgaV9lbmQgPSBlQXJyYXkubGVuZ3RoOyBpICE9PSBpX2VuZDsgaSArPSAxKSB7XG4gICAgICAgIGV2ZW50ID0gZUFycmF5W2ldO1xuICAgICAgICBpZiAoX2hhbmRsZXJzW2V2ZW50XSkge1xuICAgICAgICAgIGEgPSBbXTtcbiAgICAgICAgICBmb3IgKGogPSAwLCBqX2VuZCA9IF9oYW5kbGVyc1tldmVudF0ubGVuZ3RoOyBqICE9PSBqX2VuZDsgaiArPSAxKVxuICAgICAgICAgICAgaWYgKF9oYW5kbGVyc1tldmVudF1bal0uaGFuZGxlciAhPT0gaGFuZGxlcilcbiAgICAgICAgICAgICAgYS5wdXNoKF9oYW5kbGVyc1tldmVudF1bal0pO1xuXG4gICAgICAgICAgX2hhbmRsZXJzW2V2ZW50XSA9IGE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX2hhbmRsZXJzW2V2ZW50XSAmJiBfaGFuZGxlcnNbZXZlbnRdLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICBkZWxldGUgX2hhbmRsZXJzW2V2ZW50XTtcbiAgICAgIH1cbiAgICB9IGVsc2VcbiAgICAgIGZvciAoaSA9IDAsIGlfZW5kID0gZUFycmF5Lmxlbmd0aDsgaSAhPT0gaV9lbmQ7IGkgKz0gMSlcbiAgICAgICAgZGVsZXRlIF9oYW5kbGVyc1tlQXJyYXlbaV1dO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIGVhY2ggaGFuZGxlciBib3VuZCB0byB0aGUgZXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gIGV2ZW50cyBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgKG9yIHRoZSBldmVudHMgc2VwYXJhdGVkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBieSBzcGFjZXMpLlxuICAgKiBAcGFyYW0gIHs/T2JqZWN0fSBkYXRhICAgVGhlIGNvbnRlbnQgb2YgdGhlIGV2ZW50IChvcHRpb25hbCkuXG4gICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICBSZXR1cm5zIGNvbnJhZC5cbiAgICovXG4gIGZ1bmN0aW9uIF9kaXNwYXRjaChldmVudHMsIGRhdGEpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgaixcbiAgICAgICAgaV9lbmQsXG4gICAgICAgIGpfZW5kLFxuICAgICAgICBldmVudCxcbiAgICAgICAgZXZlbnROYW1lLFxuICAgICAgICBlQXJyYXkgPSBBcnJheS5pc0FycmF5KGV2ZW50cykgP1xuICAgICAgICAgICAgICAgICAgIGV2ZW50cyA6XG4gICAgICAgICAgICAgICAgICAgZXZlbnRzLnNwbGl0KC8gLyk7XG5cbiAgICBkYXRhID0gZGF0YSA9PT0gdW5kZWZpbmVkID8ge30gOiBkYXRhO1xuXG4gICAgZm9yIChpID0gMCwgaV9lbmQgPSBlQXJyYXkubGVuZ3RoOyBpICE9PSBpX2VuZDsgaSArPSAxKSB7XG4gICAgICBldmVudE5hbWUgPSBlQXJyYXlbaV07XG5cbiAgICAgIGlmIChfaGFuZGxlcnNbZXZlbnROYW1lXSkge1xuICAgICAgICBldmVudCA9IHtcbiAgICAgICAgICB0eXBlOiBldmVudE5hbWUsXG4gICAgICAgICAgZGF0YTogZGF0YSB8fCB7fVxuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAoaiA9IDAsIGpfZW5kID0gX2hhbmRsZXJzW2V2ZW50TmFtZV0ubGVuZ3RoOyBqICE9PSBqX2VuZDsgaiArPSAxKVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBfaGFuZGxlcnNbZXZlbnROYW1lXVtqXS5oYW5kbGVyKGV2ZW50KTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlcyB0aGUgbW9zdCBwcmlvcml0YXJ5IGpvYiBvbmNlLCBhbmQgZGVhbHMgd2l0aCBmaWxsaW5nIHRoZSBzdGF0c1xuICAgKiAoZG9uZSwgdGltZSwgYXZlcmFnZVRpbWUsIGN1cnJlbnRUaW1lLCBldGMuLi4pLlxuICAgKlxuICAgKiBAcmV0dXJuIHs/T2JqZWN0fSBSZXR1cm5zIHRoZSBqb2Igb2JqZWN0IGlmIGl0IGhhcyB0byBiZSBraWxsZWQsIG51bGwgZWxzZS5cbiAgICovXG4gIGZ1bmN0aW9uIF9leGVjdXRlRmlyc3RKb2IoKSB7XG4gICAgdmFyIGksXG4gICAgICAgIGwsXG4gICAgICAgIHRlc3QsXG4gICAgICAgIGtpbGwsXG4gICAgICAgIHB1c2hlZCA9IGZhbHNlLFxuICAgICAgICB0aW1lID0gX19kYXRlTm93KCksXG4gICAgICAgIGpvYiA9IF9zb3J0ZWRCeVByaW9yaXR5Sm9icy5zaGlmdCgpO1xuXG4gICAgLy8gRXhlY3V0ZSB0aGUgam9iIGFuZCBsb29rIGF0IHRoZSByZXN1bHQ6XG4gICAgdGVzdCA9IGpvYi5qb2IoKTtcblxuICAgIC8vIERlYWwgd2l0aCBzdGF0czpcbiAgICB0aW1lID0gX19kYXRlTm93KCkgLSB0aW1lO1xuICAgIGpvYi5kb25lKys7XG4gICAgam9iLnRpbWUgKz0gdGltZTtcbiAgICBqb2IuY3VycmVudFRpbWUgKz0gdGltZTtcbiAgICBqb2Iud2VpZ2h0VGltZSA9IGpvYi5jdXJyZW50VGltZSAvIChqb2Iud2VpZ2h0IHx8IDEpO1xuICAgIGpvYi5hdmVyYWdlVGltZSA9IGpvYi50aW1lIC8gam9iLmRvbmU7XG5cbiAgICAvLyBDaGVjayBpZiB0aGUgam9iIGhhcyB0byBiZSBraWxsZWQ6XG4gICAga2lsbCA9IGpvYi5jb3VudCA/IChqb2IuY291bnQgPD0gam9iLmRvbmUpIDogIXRlc3Q7XG5cbiAgICAvLyBSZXNldCBwcmlvcml0aWVzOlxuICAgIGlmICgha2lsbCkge1xuICAgICAgZm9yIChpID0gMCwgbCA9IF9zb3J0ZWRCeVByaW9yaXR5Sm9icy5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgIGlmIChfc29ydGVkQnlQcmlvcml0eUpvYnNbaV0ud2VpZ2h0VGltZSA+IGpvYi53ZWlnaHRUaW1lKSB7XG4gICAgICAgICAgX3NvcnRlZEJ5UHJpb3JpdHlKb2JzLnNwbGljZShpLCAwLCBqb2IpO1xuICAgICAgICAgIHB1c2hlZCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgaWYgKCFwdXNoZWQpXG4gICAgICAgIF9zb3J0ZWRCeVByaW9yaXR5Sm9icy5wdXNoKGpvYik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGtpbGwgPyBqb2IgOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEFjdGl2YXRlcyBhIGpvYiwgYnkgYWRkaW5nIGl0IHRvIHRoZSBfcnVubmluZ0pvYnMgb2JqZWN0IGFuZCB0aGVcbiAgICogX3NvcnRlZEJ5UHJpb3JpdHlKb2JzIGFycmF5LiBJdCBhbHNvIGluaXRpYWxpemVzIGl0cyBjdXJyZW50VGltZSB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSBqb2IgVGhlIGpvYiB0byBhY3RpdmF0ZS5cbiAgICovXG4gIGZ1bmN0aW9uIF9hY3RpdmF0ZUpvYihqb2IpIHtcbiAgICB2YXIgbCA9IF9zb3J0ZWRCeVByaW9yaXR5Sm9icy5sZW5ndGg7XG5cbiAgICAvLyBBZGQgdGhlIGpvYiB0byB0aGUgcnVubmluZyBqb2JzOlxuICAgIF9ydW5uaW5nSm9ic1tqb2IuaWRdID0gam9iO1xuICAgIGpvYi5zdGF0dXMgPSAncnVubmluZyc7XG5cbiAgICAvLyBBZGQgdGhlIGpvYiB0byB0aGUgcHJpb3JpdGllczpcbiAgICBpZiAobCkge1xuICAgICAgam9iLndlaWdodFRpbWUgPSBfc29ydGVkQnlQcmlvcml0eUpvYnNbbCAtIDFdLndlaWdodFRpbWU7XG4gICAgICBqb2IuY3VycmVudFRpbWUgPSBqb2Iud2VpZ2h0VGltZSAqIChqb2Iud2VpZ2h0IHx8IDEpO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemUgdGhlIGpvYiBhbmQgZGlzcGF0Y2g6XG4gICAgam9iLnN0YXJ0VGltZSA9IF9fZGF0ZU5vdygpO1xuICAgIF9kaXNwYXRjaCgnam9iU3RhcnRlZCcsIF9fY2xvbmUoam9iKSk7XG5cbiAgICBfc29ydGVkQnlQcmlvcml0eUpvYnMucHVzaChqb2IpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBtYWluIGxvb3Agb2YgY29ucmFkLmpzOlxuICAgKiAgLiBJdCBleGVjdXRlcyBqb2Igc3VjaCB0aGF0IHRoZXkgYWxsIG9jY3VwYXRlIHRoZSBzYW1lIHByb2Nlc3NpbmcgdGltZS5cbiAgICogIC4gSXQgc3RvcHMgam9icyB0aGF0IGRvIG5vdCBuZWVkIHRvIGJlIGV4ZWN1dGVkIGFueW1vcmUuXG4gICAqICAuIEl0IHRyaWdnZXJzIGNhbGxiYWNrcyB3aGVuIGl0IGlzIHJlbGV2YW50LlxuICAgKiAgLiBJdCBzdGFydHMgd2FpdGluZyBqb2JzIHdoZW4gdGhleSBuZWVkIHRvIGJlIHN0YXJ0ZWQuXG4gICAqICAuIEl0IGluamVjdHMgZnJhbWVzIHRvIGtlZXAgYSBjb25zdGFudCBmcmFwZXMgcGVyIHNlY29uZCByYXRpby5cbiAgICogIC4gSXQgc3RvcHMgaXRzZWxmIHdoZW4gdGhlcmUgYXJlIG5vIG1vcmUgam9icyB0byBleGVjdXRlLlxuICAgKi9cbiAgZnVuY3Rpb24gX2xvb3AoKSB7XG4gICAgdmFyIGssXG4gICAgICAgIG8sXG4gICAgICAgIGwsXG4gICAgICAgIGpvYixcbiAgICAgICAgdGltZSxcbiAgICAgICAgZGVhZEpvYjtcblxuICAgIC8vIERlYWwgd2l0aCB0aGUgbmV3bHkgYWRkZWQgam9icyAodGhlIF9qb2JzIG9iamVjdCk6XG4gICAgZm9yIChrIGluIF9qb2JzKSB7XG4gICAgICBqb2IgPSBfam9ic1trXTtcblxuICAgICAgaWYgKGpvYi5hZnRlcilcbiAgICAgICAgX3dhaXRpbmdKb2JzW2tdID0gam9iO1xuICAgICAgZWxzZVxuICAgICAgICBfYWN0aXZhdGVKb2Ioam9iKTtcblxuICAgICAgZGVsZXRlIF9qb2JzW2tdO1xuICAgIH1cblxuICAgIC8vIFNldCB0aGUgX2lzUnVubmluZyBmbGFnIHRvIGZhbHNlIGlmIHRoZXJlIGFyZSBubyBydW5uaW5nIGpvYjpcbiAgICBfaXNSdW5uaW5nID0gISFfc29ydGVkQnlQcmlvcml0eUpvYnMubGVuZ3RoO1xuXG4gICAgLy8gRGVhbCB3aXRoIHRoZSBydW5uaW5nIGpvYnMgKHRoZSBfcnVubmluZ0pvYnMgb2JqZWN0KTpcbiAgICB3aGlsZSAoXG4gICAgICBfc29ydGVkQnlQcmlvcml0eUpvYnMubGVuZ3RoICYmXG4gICAgICBfX2RhdGVOb3coKSAtIF9sYXN0RnJhbWVUaW1lIDwgX3BhcmFtZXRlcnMuZnJhbWVEdXJhdGlvblxuICAgICkge1xuICAgICAgZGVhZEpvYiA9IF9leGVjdXRlRmlyc3RKb2IoKTtcblxuICAgICAgLy8gRGVhbCB3aXRoIHRoZSBjYXNlIHdoZXJlIHRoZSBqb2IgaGFzIGVuZGVkOlxuICAgICAgaWYgKGRlYWRKb2IpIHtcbiAgICAgICAgX2tpbGxKb2IoZGVhZEpvYi5pZCk7XG5cbiAgICAgICAgLy8gQ2hlY2sgZm9yIHdhaXRpbmcgam9iczpcbiAgICAgICAgZm9yIChrIGluIF93YWl0aW5nSm9icylcbiAgICAgICAgICBpZiAoX3dhaXRpbmdKb2JzW2tdLmFmdGVyID09PSBkZWFkSm9iLmlkKSB7XG4gICAgICAgICAgICBfYWN0aXZhdGVKb2IoX3dhaXRpbmdKb2JzW2tdKTtcbiAgICAgICAgICAgIGRlbGV0ZSBfd2FpdGluZ0pvYnNba107XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIGNvbnJhZCBzdGlsbCBoYXMgam9icyB0byBkZWFsIHdpdGgsIGFuZCBraWxsIGl0IGlmIG5vdDpcbiAgICBpZiAoX2lzUnVubmluZykge1xuICAgICAgLy8gVXBkYXRlIHRoZSBfbGFzdEZyYW1lVGltZTpcbiAgICAgIF9sYXN0RnJhbWVUaW1lID0gX19kYXRlTm93KCk7XG5cbiAgICAgIF9kaXNwYXRjaCgnZW50ZXJGcmFtZScpO1xuICAgICAgc2V0VGltZW91dChfbG9vcCwgMCk7XG4gICAgfSBlbHNlXG4gICAgICBfZGlzcGF0Y2goJ3N0b3AnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIG9uZSBvciBtb3JlIGpvYnMsIGFuZCBzdGFydHMgdGhlIGxvb3AgaWYgbm8gam9iIHdhcyBydW5uaW5nIGJlZm9yZS4gQVxuICAgKiBqb2IgaXMgYXQgbGVhc3QgYSB1bmlxdWUgc3RyaW5nIFwiaWRcIiBhbmQgYSBmdW5jdGlvbiwgYW5kIHRoZXJlIGFyZSBzb21lXG4gICAqIHBhcmFtZXRlcnMgdGhhdCB5b3UgY2FuIHNwZWNpZnkgZm9yIGVhY2ggam9iIHRvIG1vZGlmeSB0aGUgd2F5IGNvbnJhZCB3aWxsXG4gICAqIGV4ZWN1dGUgaXQuIElmIGEgam9iIGlzIGFkZGVkIHdpdGggdGhlIFwiaWRcIiBvZiBhbm90aGVyIGpvYiB0aGF0IGlzIHdhaXRpbmdcbiAgICogb3Igc3RpbGwgcnVubmluZywgYW4gZXJyb3Igd2lsbCBiZSB0aHJvd24uXG4gICAqXG4gICAqIFdoZW4gYSBqb2IgaXMgYWRkZWQsIGl0IGlzIHJlZmVyZW5jZWQgaW4gdGhlIF9qb2JzIG9iamVjdCwgYnkgaXRzIGlkLlxuICAgKiBUaGVuLCBpZiBpdCBoYXMgdG8gYmUgZXhlY3V0ZWQgcmlnaHQgbm93LCBpdCB3aWxsIGJlIGFsc28gcmVmZXJlbmNlZCBpblxuICAgKiB0aGUgX3J1bm5pbmdKb2JzIG9iamVjdC4gSWYgaXQgaGFzIHRvIHdhaXQsIHRoZW4gaXQgd2lsbCBiZSBhZGRlZCBpbnRvIHRoZVxuICAgKiBfd2FpdGluZ0pvYnMgb2JqZWN0LCB1bnRpbCBpdCBjYW4gc3RhcnQuXG4gICAqXG4gICAqIEtlZXAgcmVhZGluZyB0aGlzIGRvY3VtZW50YXRpb24gdG8gc2VlIGhvdyB0byBjYWxsIHRoaXMgbWV0aG9kLlxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgY29ucmFkLlxuICAgKlxuICAgKiBBZGRpbmcgb25lIGpvYjpcbiAgICogKioqKioqKioqKioqKioqXG4gICAqIEJhc2ljYWxseSwgYSBqb2IgaXMgZGVmaW5lZCBieSBpdHMgc3RyaW5nIGlkIGFuZCBhIGZ1bmN0aW9uICh0aGUgam9iKS4gSXRcbiAgICogaXMgYWxzbyBwb3NzaWJsZSB0byBhZGQgc29tZSBwYXJhbWV0ZXJzOlxuICAgKlxuICAgKiAgPiBjb25yYWQuYWRkSm9iKCdteUpvYklkJywgbXlKb2JGdW5jdGlvbik7XG4gICAqICA+IGNvbnJhZC5hZGRKb2IoJ215Sm9iSWQnLCB7XG4gICAqICA+ICAgam9iOiBteUpvYkZ1bmN0aW9uLFxuICAgKiAgPiAgIHNvbWVQYXJhbWV0ZXI6IHNvbWVWYWx1ZVxuICAgKiAgPiB9KTtcbiAgICogID4gY29ucmFkLmFkZEpvYih7XG4gICAqICA+ICAgaWQ6ICdteUpvYklkJyxcbiAgICogID4gICBqb2I6IG15Sm9iRnVuY3Rpb24sXG4gICAqICA+ICAgc29tZVBhcmFtZXRlcjogc29tZVZhbHVlXG4gICAqICA+IH0pO1xuICAgKlxuICAgKiBBZGRpbmcgc2V2ZXJhbCBqb2JzOlxuICAgKiAqKioqKioqKioqKioqKioqKioqKlxuICAgKiBXaGVuIGFkZGluZyBzZXZlcmFsIGpvYnMgYXQgdGhlIHNhbWUgdGltZSwgaXQgaXMgcG9zc2libGUgdG8gc3BlY2lmeVxuICAgKiBwYXJhbWV0ZXJzIGZvciBlYWNoIG9uZSBpbmRpdmlkdWFsbHkgb3IgZm9yIGFsbDpcbiAgICpcbiAgICogID4gY29ucmFkLmFkZEpvYihbXG4gICAqICA+ICAge1xuICAgKiAgPiAgICAgaWQ6ICdteUpvYklkMScsXG4gICAqICA+ICAgICBqb2I6IG15Sm9iRnVuY3Rpb24xLFxuICAgKiAgPiAgICAgc29tZVBhcmFtZXRlcjE6IHNvbWVWYWx1ZTFcbiAgICogID4gICB9LFxuICAgKiAgPiAgIHtcbiAgICogID4gICAgIGlkOiAnbXlKb2JJZDInLFxuICAgKiAgPiAgICAgam9iOiBteUpvYkZ1bmN0aW9uMixcbiAgICogID4gICAgIHNvbWVQYXJhbWV0ZXIyOiBzb21lVmFsdWUyXG4gICAqICA+ICAgfVxuICAgKiAgPiBdLCB7XG4gICAqICA+ICAgc29tZUNvbW1vblBhcmFtZXRlcjogc29tZUNvbW1vblZhbHVlXG4gICAqICA+IH0pO1xuICAgKiAgPiBjb25yYWQuYWRkSm9iKHtcbiAgICogID4gICBteUpvYklkMTogeyxcbiAgICogID4gICAgIGpvYjogbXlKb2JGdW5jdGlvbjEsXG4gICAqICA+ICAgICBzb21lUGFyYW1ldGVyMTogc29tZVZhbHVlMVxuICAgKiAgPiAgIH0sXG4gICAqICA+ICAgbXlKb2JJZDI6IHssXG4gICAqICA+ICAgICBqb2I6IG15Sm9iRnVuY3Rpb24yLFxuICAgKiAgPiAgICAgc29tZVBhcmFtZXRlcjI6IHNvbWVWYWx1ZTJcbiAgICogID4gICB9XG4gICAqICA+IH0sIHtcbiAgICogID4gICBzb21lQ29tbW9uUGFyYW1ldGVyOiBzb21lQ29tbW9uVmFsdWVcbiAgICogID4gfSk7XG4gICAqICA+IGNvbnJhZC5hZGRKb2Ioe1xuICAgKiAgPiAgIG15Sm9iSWQxOiBteUpvYkZ1bmN0aW9uMSxcbiAgICogID4gICBteUpvYklkMjogbXlKb2JGdW5jdGlvbjJcbiAgICogID4gfSwge1xuICAgKiAgPiAgIHNvbWVDb21tb25QYXJhbWV0ZXI6IHNvbWVDb21tb25WYWx1ZVxuICAgKiAgPiB9KTtcbiAgICpcbiAgICogIFJlY29nbml6ZWQgcGFyYW1ldGVyczpcbiAgICogICoqKioqKioqKioqKioqKioqKioqKipcbiAgICogIEhlcmUgaXMgdGhlIGV4aGF1c3RpdmUgbGlzdCBvZiBldmVyeSBhY2NlcHRlZCBwYXJhbWV0ZXJzOlxuICAgKlxuICAgKiAgICB7P0Z1bmN0aW9ufSBlbmQgICAgICBBIGNhbGxiYWNrIHRvIGV4ZWN1dGUgd2hlbiB0aGUgam9iIGlzIGVuZGVkLiBJdCBpc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICBub3QgZXhlY3V0ZWQgaWYgdGhlIGpvYiBpcyBraWxsZWQgaW5zdGVhZCBvZiBlbmRlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICBcIm5hdHVyYWxseVwiLlxuICAgKiAgICB7P0ludGVnZXJ9ICBjb3VudCAgICBUaGUgbnVtYmVyIG9mIHRpbWUgdGhlIGpvYiBoYXMgdG8gYmUgZXhlY3V0ZWQuXG4gICAqICAgIHs/TnVtYmVyfSAgIHdlaWdodCAgIElmIHNwZWNpZmllZCwgdGhlIGpvYiB3aWxsIGJlIGV4ZWN1dGVkIGFzIGl0IHdhc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICBhZGRlZCBcIndlaWdodFwiIHRpbWVzLlxuICAgKiAgICB7P1N0cmluZ30gICBhZnRlciAgICBUaGUgaWQgb2YgYW5vdGhlciBqb2IgKGV2ZW50dWFsbHkgbm90IGFkZGVkIHlldCkuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgIElmIHNwZWNpZmllZCwgdGhpcyBqb2Igd2lsbCBzdGFydCBvbmx5IHdoZW4gdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgIHNwZWNpZmllZCBcImFmdGVyXCIgam9iIGlzIGVuZGVkLlxuICAgKi9cbiAgZnVuY3Rpb24gX2FkZEpvYih2MSwgdjIpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgbCxcbiAgICAgICAgbztcblxuICAgIC8vIEFycmF5IG9mIGpvYnM6XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodjEpKSB7XG4gICAgICAvLyBLZWVwIGNvbnJhZCB0byBzdGFydCB1bnRpbCB0aGUgbGFzdCBqb2IgaXMgYWRkZWQ6XG4gICAgICBfbm9TdGFydCA9IHRydWU7XG5cbiAgICAgIGZvciAoaSA9IDAsIGwgPSB2MS5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgIF9hZGRKb2IodjFbaV0uaWQsIF9fZXh0ZW5kKHYxW2ldLCB2MikpO1xuXG4gICAgICBfbm9TdGFydCA9IGZhbHNlO1xuICAgICAgaWYgKCFfaXNSdW5uaW5nKSB7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgX2xhc3RGcmFtZVRpbWU6XG4gICAgICAgIF9sYXN0RnJhbWVUaW1lID0gX19kYXRlTm93KCk7XG5cbiAgICAgICAgX2Rpc3BhdGNoKCdzdGFydCcpO1xuICAgICAgICBfbG9vcCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHYxID09PSAnb2JqZWN0Jykge1xuICAgICAgLy8gT25lIGpvYiAob2JqZWN0KTpcbiAgICAgIGlmICh0eXBlb2YgdjEuaWQgPT09ICdzdHJpbmcnKVxuICAgICAgICBfYWRkSm9iKHYxLmlkLCB2MSk7XG5cbiAgICAgIC8vIEhhc2ggb2Ygam9iczpcbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBLZWVwIGNvbnJhZCB0byBzdGFydCB1bnRpbCB0aGUgbGFzdCBqb2IgaXMgYWRkZWQ6XG4gICAgICAgIF9ub1N0YXJ0ID0gdHJ1ZTtcblxuICAgICAgICBmb3IgKGkgaW4gdjEpXG4gICAgICAgICAgaWYgKHR5cGVvZiB2MVtpXSA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIF9hZGRKb2IoaSwgX19leHRlbmQoe1xuICAgICAgICAgICAgICBqb2I6IHYxW2ldXG4gICAgICAgICAgICB9LCB2MikpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIF9hZGRKb2IoaSwgX19leHRlbmQodjFbaV0sIHYyKSk7XG5cbiAgICAgICAgX25vU3RhcnQgPSBmYWxzZTtcbiAgICAgICAgaWYgKCFfaXNSdW5uaW5nKSB7XG4gICAgICAgICAgLy8gVXBkYXRlIHRoZSBfbGFzdEZyYW1lVGltZTpcbiAgICAgICAgICBfbGFzdEZyYW1lVGltZSA9IF9fZGF0ZU5vdygpO1xuXG4gICAgICAgICAgX2Rpc3BhdGNoKCdzdGFydCcpO1xuICAgICAgICAgIF9sb29wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIC8vIE9uZSBqb2IgKHN0cmluZywgKik6XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdjEgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAoX2hhc0pvYih2MSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnW2NvbnJhZC5hZGRKb2JdIEpvYiB3aXRoIGlkIFwiJyArIHYxICsgJ1wiIGFscmVhZHkgZXhpc3RzLidcbiAgICAgICAgKTtcblxuICAgICAgLy8gT25lIGpvYiAoc3RyaW5nLCBmdW5jdGlvbik6XG4gICAgICBpZiAodHlwZW9mIHYyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG8gPSB7XG4gICAgICAgICAgaWQ6IHYxLFxuICAgICAgICAgIGRvbmU6IDAsXG4gICAgICAgICAgdGltZTogMCxcbiAgICAgICAgICBzdGF0dXM6ICd3YWl0aW5nJyxcbiAgICAgICAgICBjdXJyZW50VGltZTogMCxcbiAgICAgICAgICBhdmVyYWdlVGltZTogMCxcbiAgICAgICAgICB3ZWlnaHRUaW1lOiAwLFxuICAgICAgICAgIGpvYjogdjJcbiAgICAgICAgfTtcblxuICAgICAgLy8gT25lIGpvYiAoc3RyaW5nLCBvYmplY3QpOlxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdjIgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIG8gPSBfX2V4dGVuZChcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZDogdjEsXG4gICAgICAgICAgICBkb25lOiAwLFxuICAgICAgICAgICAgdGltZTogMCxcbiAgICAgICAgICAgIHN0YXR1czogJ3dhaXRpbmcnLFxuICAgICAgICAgICAgY3VycmVudFRpbWU6IDAsXG4gICAgICAgICAgICBhdmVyYWdlVGltZTogMCxcbiAgICAgICAgICAgIHdlaWdodFRpbWU6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIHYyXG4gICAgICAgICk7XG5cbiAgICAgIC8vIElmIG5vbmUgb2YgdGhvc2UgY2FzZXMsIHRocm93IGFuIGVycm9yOlxuICAgICAgfSBlbHNlXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignW2NvbnJhZC5hZGRKb2JdIFdyb25nIGFyZ3VtZW50cy4nKTtcblxuICAgICAgLy8gRWZmZWN0aXZlbHkgYWRkIHRoZSBqb2I6XG4gICAgICBfam9ic1t2MV0gPSBvO1xuICAgICAgX2Rpc3BhdGNoKCdqb2JBZGRlZCcsIF9fY2xvbmUobykpO1xuXG4gICAgICAvLyBDaGVjayBpZiB0aGUgbG9vcCBoYXMgdG8gYmUgc3RhcnRlZDpcbiAgICAgIGlmICghX2lzUnVubmluZyAmJiAhX25vU3RhcnQpIHtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBfbGFzdEZyYW1lVGltZTpcbiAgICAgICAgX2xhc3RGcmFtZVRpbWUgPSBfX2RhdGVOb3coKTtcblxuICAgICAgICBfZGlzcGF0Y2goJ3N0YXJ0Jyk7XG4gICAgICAgIF9sb29wKCk7XG4gICAgICB9XG5cbiAgICAvLyBJZiBub25lIG9mIHRob3NlIGNhc2VzLCB0aHJvdyBhbiBlcnJvcjpcbiAgICB9IGVsc2VcbiAgICAgIHRocm93IG5ldyBFcnJvcignW2NvbnJhZC5hZGRKb2JdIFdyb25nIGFyZ3VtZW50cy4nKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEtpbGxzIG9uZSBvciBtb3JlIGpvYnMsIGluZGljYXRlZCBieSB0aGVpciBpZHMuIEl0IGlzIG9ubHkgcG9zc2libGUgdG9cbiAgICoga2lsbCBydW5uaW5nIGpvYnMgb3Igd2FpdGluZyBqb2JzLiBJZiB5b3UgdHJ5IHRvIGtpbGwgYSBqb2IgdGhhdCBkb2VzIG5vdFxuICAgKiBleGlzdCBvciB0aGF0IGlzIGFscmVhZHkga2lsbGVkLCBhIHdhcm5pbmcgd2lsbCBiZSB0aHJvd24uXG4gICAqXG4gICAqIEBwYXJhbSAge0FycmF5fFN0cmluZ30gdjEgQSBzdHJpbmcgam9iIGlkIG9yIGFuIGFycmF5IG9mIGpvYiBpZHMuXG4gICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgUmV0dXJucyBjb25yYWQuXG4gICAqL1xuICBmdW5jdGlvbiBfa2lsbEpvYih2MSkge1xuICAgIHZhciBpLFxuICAgICAgICBsLFxuICAgICAgICBrLFxuICAgICAgICBhLFxuICAgICAgICBqb2IsXG4gICAgICAgIGZvdW5kID0gZmFsc2U7XG5cbiAgICAvLyBBcnJheSBvZiBqb2IgaWRzOlxuICAgIGlmIChBcnJheS5pc0FycmF5KHYxKSlcbiAgICAgIGZvciAoaSA9IDAsIGwgPSB2MS5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgIF9raWxsSm9iKHYxW2ldKTtcblxuICAgIC8vIE9uZSBqb2IncyBpZDpcbiAgICBlbHNlIGlmICh0eXBlb2YgdjEgPT09ICdzdHJpbmcnKSB7XG4gICAgICBhID0gW19ydW5uaW5nSm9icywgX3dhaXRpbmdKb2JzLCBfam9ic107XG5cbiAgICAgIC8vIFJlbW92ZSB0aGUgam9iIGZyb20gdGhlIGhhc2hlczpcbiAgICAgIGZvciAoaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgaWYgKHYxIGluIGFbaV0pIHtcbiAgICAgICAgICBqb2IgPSBhW2ldW3YxXTtcblxuICAgICAgICAgIGlmIChfcGFyYW1ldGVycy5oaXN0b3J5KSB7XG4gICAgICAgICAgICBqb2Iuc3RhdHVzID0gJ2RvbmUnO1xuICAgICAgICAgICAgX2RvbmVKb2JzLnB1c2goam9iKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfZGlzcGF0Y2goJ2pvYkVuZGVkJywgX19jbG9uZShqb2IpKTtcbiAgICAgICAgICBkZWxldGUgYVtpXVt2MV07XG5cbiAgICAgICAgICBpZiAodHlwZW9mIGpvYi5lbmQgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICBqb2IuZW5kKCk7XG5cbiAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIHRoZSBwcmlvcml0aWVzIGFycmF5OlxuICAgICAgYSA9IF9zb3J0ZWRCeVByaW9yaXR5Sm9icztcbiAgICAgIGZvciAoaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgaWYgKGFbaV0uaWQgPT09IHYxKSB7XG4gICAgICAgICAgYS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgaWYgKCFmb3VuZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdbY29ucmFkLmtpbGxKb2JdIEpvYiBcIicgKyB2MSArICdcIiBub3QgZm91bmQuJyk7XG5cbiAgICAvLyBJZiBub25lIG9mIHRob3NlIGNhc2VzLCB0aHJvdyBhbiBlcnJvcjpcbiAgICB9IGVsc2VcbiAgICAgIHRocm93IG5ldyBFcnJvcignW2NvbnJhZC5raWxsSm9iXSBXcm9uZyBhcmd1bWVudHMuJyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBLaWxscyBldmVyeSBydW5uaW5nLCB3YWl0aW5nLCBhbmQganVzdCBhZGRlZCBqb2JzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgY29ucmFkLlxuICAgKi9cbiAgZnVuY3Rpb24gX2tpbGxBbGwoKSB7XG4gICAgdmFyIGssXG4gICAgICAgIGpvYnMgPSBfX2V4dGVuZChfam9icywgX3J1bm5pbmdKb2JzLCBfd2FpdGluZ0pvYnMpO1xuXG4gICAgLy8gVGFrZSBldmVyeSBqb2JzIGFuZCBwdXNoIHRoZW0gaW50byB0aGUgX2RvbmVKb2JzIG9iamVjdDpcbiAgICBpZiAoX3BhcmFtZXRlcnMuaGlzdG9yeSlcbiAgICAgIGZvciAoayBpbiBqb2JzKSB7XG4gICAgICAgIGpvYnNba10uc3RhdHVzID0gJ2RvbmUnO1xuICAgICAgICBfZG9uZUpvYnMucHVzaChqb2JzW2tdKTtcblxuICAgICAgICBpZiAodHlwZW9mIGpvYnNba10uZW5kID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgIGpvYnNba10uZW5kKCk7XG4gICAgICB9XG5cbiAgICAvLyBSZWluaXRpYWxpemUgdGhlIGRpZmZlcmVudCBqb2JzIGxpc3RzOlxuICAgIF9qb2JzID0ge307XG4gICAgX3dhaXRpbmdKb2JzID0ge307XG4gICAgX3J1bm5pbmdKb2JzID0ge307XG4gICAgX3NvcnRlZEJ5UHJpb3JpdHlKb2JzID0gW107XG5cbiAgICAvLyBJbiBjYXNlIHNvbWUgam9icyBhcmUgYWRkZWQgcmlnaHQgYWZ0ZXIgdGhlIGtpbGw6XG4gICAgX2lzUnVubmluZyA9IGZhbHNlO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIGEgam9iIHdpdGggdGhlIHNwZWNpZmllZCBpZCBpcyBjdXJyZW50bHkgcnVubmluZyBvclxuICAgKiB3YWl0aW5nLCBhbmQgZmFsc2UgZWxzZS5cbiAgICpcbiAgICogQHBhcmFtICB7U3RyaW5nfSAgaWQgVGhlIGlkIG9mIHRoZSBqb2IuXG4gICAqIEByZXR1cm4gez9PYmplY3R9IFJldHVybnMgdGhlIGpvYiBvYmplY3QgaWYgaXQgZXhpc3RzLlxuICAgKi9cbiAgZnVuY3Rpb24gX2hhc0pvYihpZCkge1xuICAgIHZhciBqb2IgPSBfam9ic1tpZF0gfHwgX3J1bm5pbmdKb2JzW2lkXSB8fCBfd2FpdGluZ0pvYnNbaWRdO1xuICAgIHJldHVybiBqb2IgPyBfX2V4dGVuZChqb2IpIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCB3aWxsIHNldCB0aGUgc2V0dGluZyBzcGVjaWZpZWQgYnkgXCJ2MVwiIHRvIHRoZSB2YWx1ZSBzcGVjaWZpZWRcbiAgICogYnkgXCJ2MlwiIGlmIGJvdGggYXJlIGdpdmVuLCBhbmQgZWxzZSByZXR1cm4gdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlXG4gICAqIHNldHRpbmdzIFwidjFcIi5cbiAgICpcbiAgICogQHBhcmFtICB7U3RyaW5nfSAgIHYxIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eS5cbiAgICogQHBhcmFtICB7Pyp9ICAgICAgIHYyIEV2ZW50dWFsbHksIGEgdmFsdWUgdG8gc2V0IHRvIHRoZSBzcGVjaWZpZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5LlxuICAgKiBAcmV0dXJuIHtPYmplY3R8Kn0gUmV0dXJucyB0aGUgc3BlY2lmaWVkIHNldHRpbmdzIHZhbHVlIGlmIFwidjJcIiBpcyBub3RcbiAgICogICAgICAgICAgICAgICAgICAgIGdpdmVuLCBhbmQgY29ucmFkIGVsc2UuXG4gICAqL1xuICBmdW5jdGlvbiBfc2V0dGluZ3ModjEsIHYyKSB7XG4gICAgdmFyIG87XG5cbiAgICBpZiAodHlwZW9mIGExID09PSAnc3RyaW5nJyAmJiBhcmd1bWVudHMubGVuZ3RoID09PSAxKVxuICAgICAgcmV0dXJuIF9wYXJhbWV0ZXJzW2ExXTtcbiAgICBlbHNlIHtcbiAgICAgIG8gPSAodHlwZW9mIGExID09PSAnb2JqZWN0JyAmJiBhcmd1bWVudHMubGVuZ3RoID09PSAxKSA/XG4gICAgICAgIGExIHx8IHt9IDpcbiAgICAgICAge307XG4gICAgICBpZiAodHlwZW9mIGExID09PSAnc3RyaW5nJylcbiAgICAgICAgb1thMV0gPSBhMjtcblxuICAgICAgZm9yICh2YXIgayBpbiBvKVxuICAgICAgICBpZiAob1trXSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgIF9wYXJhbWV0ZXJzW2tdID0gb1trXTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGRlbGV0ZSBfcGFyYW1ldGVyc1trXTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBjb25yYWQgaXMgY3VycmVudGx5IHJ1bm5pbmcsIGFuZCBmYWxzZSBlbHNlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIF9pc1J1bm5pbmcuXG4gICAqL1xuICBmdW5jdGlvbiBfZ2V0SXNSdW5uaW5nKCkge1xuICAgIHJldHVybiBfaXNSdW5uaW5nO1xuICB9XG5cbiAgLyoqXG4gICAqIFVucmVmZXJlbmNlIGV2ZXJ5IGpvYiB0aGF0IGlzIHN0b3JlZCBpbiB0aGUgX2RvbmVKb2JzIG9iamVjdC4gSXQgd2lsbFxuICAgKiBub3QgYmUgcG9zc2libGUgYW55bW9yZSB0byBnZXQgc3RhdHMgYWJvdXQgdGhlc2Ugam9icywgYnV0IGl0IHdpbGwgcmVsZWFzZVxuICAgKiB0aGUgbWVtb3J5LlxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgY29ucmFkLlxuICAgKi9cbiAgZnVuY3Rpb24gX2NsZWFySGlzdG9yeSgpIHtcbiAgICBfZG9uZUpvYnMgPSBbXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc25hcHNob3Qgb2YgZXZlcnkgZGF0YSBhYm91dCBqb2JzIHRoYXQgd2FpdCB0byBiZSBzdGFydGVkLCBhcmVcbiAgICogY3VycmVudGx5IHJ1bm5pbmcgb3IgYXJlIGRvbmUuXG4gICAqXG4gICAqIEl0IGlzIHBvc3NpYmxlIHRvIGdldCBvbmx5IHJ1bm5pbmcsIHdhaXRpbmcgb3IgZG9uZSBqb2JzIGJ5IGdpdmluZ1xuICAgKiBcInJ1bm5pbmdcIiwgXCJ3YWl0aW5nXCIgb3IgXCJkb25lXCIgYXMgZmlzdCBhcmd1bWVudC5cbiAgICpcbiAgICogSXQgaXMgYWxzbyBwb3NzaWJsZSB0byBnZXQgZXZlcnkgam9iIHdpdGggYSBzcGVjaWZpZWQgaWQgYnkgZ2l2aW5nIGl0IGFzXG4gICAqIGZpcnN0IGFyZ3VtZW50LiBBbHNvLCB1c2luZyBhIFJlZ0V4cCBpbnN0ZWFkIG9mIGFuIGlkIHdpbGwgcmV0dXJuIGV2ZXJ5XG4gICAqIGpvYnMgd2hvc2UgaWRzIG1hdGNoIHRoZSBSZWdFeHAuIEFuZCB0aGVzZSB0d28gbGFzdCB1c2UgY2FzZXMgd29yayBhcyB3ZWxsXG4gICAqIGJ5IGdpdmluZyBiZWZvcmUgXCJydW5uaW5nXCIsIFwid2FpdGluZ1wiIG9yIFwiZG9uZVwiLlxuICAgKlxuICAgKiBAcmV0dXJuIHtBcnJheX0gVGhlIGFycmF5IG9mIHRoZSBtYXRjaGluZyBqb2JzLlxuICAgKlxuICAgKiBTb21lIGNhbGwgZXhhbXBsZXM6XG4gICAqICoqKioqKioqKioqKioqKioqKipcbiAgICogID4gY29ucmFkLmdldFN0YXRzKCdydW5uaW5nJylcbiAgICogID4gY29ucmFkLmdldFN0YXRzKCd3YWl0aW5nJylcbiAgICogID4gY29ucmFkLmdldFN0YXRzKCdkb25lJylcbiAgICogID4gY29ucmFkLmdldFN0YXRzKCdteUpvYicpXG4gICAqICA+IGNvbnJhZC5nZXRTdGF0cygvdGVzdC8pXG4gICAqICA+IGNvbnJhZC5nZXRTdGF0cygncnVubmluZycsICdteVJ1bm5pbmdKb2InKVxuICAgKiAgPiBjb25yYWQuZ2V0U3RhdHMoJ3J1bm5pbmcnLCAvdGVzdC8pXG4gICAqL1xuICBmdW5jdGlvbiBfZ2V0U3RhdHModjEsIHYyKSB7XG4gICAgdmFyIGEsXG4gICAgICAgIGssXG4gICAgICAgIGksXG4gICAgICAgIGwsXG4gICAgICAgIHN0YXRzLFxuICAgICAgICBwYXR0ZXJuLFxuICAgICAgICBpc1BhdHRlcm5TdHJpbmc7XG5cbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHN0YXRzID0gW107XG5cbiAgICAgIGZvciAoayBpbiBfam9icylcbiAgICAgICAgc3RhdHMucHVzaChfam9ic1trXSk7XG5cbiAgICAgIGZvciAoayBpbiBfd2FpdGluZ0pvYnMpXG4gICAgICAgIHN0YXRzLnB1c2goX3dhaXRpbmdKb2JzW2tdKTtcblxuICAgICAgZm9yIChrIGluIF9ydW5uaW5nSm9icylcbiAgICAgICAgc3RhdHMucHVzaChfcnVubmluZ0pvYnNba10pO1xuXG4gICAgICBzdGF0cyA9IHN0YXRzLmNvbmNhdChfZG9uZUpvYnMpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdjEgPT09ICdzdHJpbmcnKVxuICAgICAgc3dpdGNoICh2MSkge1xuICAgICAgICBjYXNlICd3YWl0aW5nJzpcbiAgICAgICAgICBzdGF0cyA9IF9fb2JqZWN0VmFsdWVzKF93YWl0aW5nSm9icyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3J1bm5pbmcnOlxuICAgICAgICAgIHN0YXRzID0gX19vYmplY3RWYWx1ZXMoX3J1bm5pbmdKb2JzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZG9uZSc6XG4gICAgICAgICAgc3RhdHMgPSBfZG9uZUpvYnM7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcGF0dGVybiA9IHYxO1xuICAgICAgfVxuXG4gICAgaWYgKHYxIGluc3RhbmNlb2YgUmVnRXhwKVxuICAgICAgcGF0dGVybiA9IHYxO1xuXG4gICAgaWYgKCFwYXR0ZXJuICYmICh0eXBlb2YgdjIgPT09ICdzdHJpbmcnIHx8IHYyIGluc3RhbmNlb2YgUmVnRXhwKSlcbiAgICAgIHBhdHRlcm4gPSB2MjtcblxuICAgIC8vIEZpbHRlciBqb2JzIGlmIGEgcGF0dGVybiBpcyBnaXZlbjpcbiAgICBpZiAocGF0dGVybikge1xuICAgICAgaXNQYXR0ZXJuU3RyaW5nID0gdHlwZW9mIHBhdHRlcm4gPT09ICdzdHJpbmcnO1xuXG4gICAgICBpZiAoc3RhdHMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICBhID0gc3RhdHM7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzdGF0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgYSA9IFtdO1xuXG4gICAgICAgIGZvciAoayBpbiBzdGF0cylcbiAgICAgICAgICBhID0gYS5jb25jYXQoc3RhdHNba10pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYSA9IFtdO1xuXG4gICAgICAgIGZvciAoayBpbiBfam9icylcbiAgICAgICAgICBhLnB1c2goX2pvYnNba10pO1xuXG4gICAgICAgIGZvciAoayBpbiBfd2FpdGluZ0pvYnMpXG4gICAgICAgICAgYS5wdXNoKF93YWl0aW5nSm9ic1trXSk7XG5cbiAgICAgICAgZm9yIChrIGluIF9ydW5uaW5nSm9icylcbiAgICAgICAgICBhLnB1c2goX3J1bm5pbmdKb2JzW2tdKTtcblxuICAgICAgICBhID0gYS5jb25jYXQoX2RvbmVKb2JzKTtcbiAgICAgIH1cblxuICAgICAgc3RhdHMgPSBbXTtcbiAgICAgIGZvciAoaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgaWYgKGlzUGF0dGVyblN0cmluZyA/IGFbaV0uaWQgPT09IHBhdHRlcm4gOiBhW2ldLmlkLm1hdGNoKHBhdHRlcm4pKVxuICAgICAgICAgIHN0YXRzLnB1c2goYVtpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9fY2xvbmUoc3RhdHMpO1xuICB9XG5cblxuICAvKipcbiAgICogVE9PTFMgRlVOQ1RJT05TOlxuICAgKiAqKioqKioqKioqKioqKioqXG4gICAqL1xuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHRha2VzIGFueSBudW1iZXIgb2Ygb2JqZWN0cyBhcyBhcmd1bWVudHMsIGNvcGllcyBmcm9tIGVhY2hcbiAgICogb2YgdGhlc2Ugb2JqZWN0cyBlYWNoIHBhaXIga2V5L3ZhbHVlIGludG8gYSBuZXcgb2JqZWN0LCBhbmQgZmluYWxseVxuICAgKiByZXR1cm5zIHRoaXMgb2JqZWN0LlxuICAgKlxuICAgKiBUaGUgYXJndW1lbnRzIGFyZSBwYXJzZWQgZnJvbSB0aGUgbGFzdCBvbmUgdG8gdGhlIGZpcnN0IG9uZSwgc3VjaCB0aGF0XG4gICAqIHdoZW4gdHdvIG9iamVjdHMgaGF2ZSBrZXlzIGluIGNvbW1vbiwgdGhlIFwiZWFybGllc3RcIiBvYmplY3Qgd2lucy5cbiAgICpcbiAgICogRXhhbXBsZTpcbiAgICogKioqKioqKipcbiAgICogID4gdmFyIG8xID0ge1xuICAgKiAgPiAgICAgICBhOiAxLFxuICAgKiAgPiAgICAgICBiOiAyLFxuICAgKiAgPiAgICAgICBjOiAnMydcbiAgICogID4gICAgIH0sXG4gICAqICA+ICAgICBvMiA9IHtcbiAgICogID4gICAgICAgYzogJzQnLFxuICAgKiAgPiAgICAgICBkOiBbIDUgXVxuICAgKiAgPiAgICAgfTtcbiAgICogID4gX19leHRlbmQobzEsIG8yKTtcbiAgICogID4gLy8gUmV0dXJuczoge1xuICAgKiAgPiAvLyAgIGE6IDEsXG4gICAqICA+IC8vICAgYjogMixcbiAgICogID4gLy8gICBjOiAnMycsXG4gICAqICA+IC8vICAgZDogWyA1IF1cbiAgICogID4gLy8gfTtcbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0K30gQW55IG51bWJlciBvZiBvYmplY3RzLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9ICBUaGUgbWVyZ2VkIG9iamVjdC5cbiAgICovXG4gIGZ1bmN0aW9uIF9fZXh0ZW5kKCkge1xuICAgIHZhciBpLFxuICAgICAgICBrLFxuICAgICAgICByZXMgPSB7fSxcbiAgICAgICAgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSBsIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICBmb3IgKGsgaW4gYXJndW1lbnRzW2ldKVxuICAgICAgICByZXNba10gPSBhcmd1bWVudHNbaV1ba107XG5cbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gc2ltcGx5IGNsb25lcyBhbiBvYmplY3QuIFRoaXMgb2JqZWN0IG11c3QgY29udGFpbiBvbmx5XG4gICAqIG9iamVjdHMsIGFycmF5cyBhbmQgaW1tdXRhYmxlIHZhbHVlcy4gU2luY2UgaXQgaXMgbm90IHB1YmxpYywgaXQgZG9lcyBub3RcbiAgICogZGVhbCB3aXRoIGN5Y2xpYyByZWZlcmVuY2VzLCBET00gZWxlbWVudHMgYW5kIGluc3RhbnRpYXRlZCBvYmplY3RzIC0gc29cbiAgICogdXNlIGl0IGNhcmVmdWxseS5cbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjbG9uZS5cbiAgICovXG4gIGZ1bmN0aW9uIF9fY2xvbmUoaXRlbSkge1xuICAgIHZhciByZXN1bHQsIGksIGssIGw7XG5cbiAgICBpZiAoIWl0ZW0pXG4gICAgICByZXR1cm4gaXRlbTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW0pKSB7XG4gICAgICByZXN1bHQgPSBbXTtcbiAgICAgIGZvciAoaSA9IDAsIGwgPSBpdGVtLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgcmVzdWx0LnB1c2goX19jbG9uZShpdGVtW2ldKSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgaXRlbSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJlc3VsdCA9IHt9O1xuICAgICAgZm9yIChpIGluIGl0ZW0pXG4gICAgICAgIHJlc3VsdFtpXSA9IF9fY2xvbmUoaXRlbVtpXSk7XG4gICAgfSBlbHNlXG4gICAgICByZXN1bHQgPSBpdGVtO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIHZhbHVlcyBvZiBhbiBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gVGhlIG9iamVjdC5cbiAgICogQHJldHVybiB7QXJyYXl9ICBUaGUgYXJyYXkgb2YgdmFsdWVzLlxuICAgKi9cbiAgZnVuY3Rpb24gX19vYmplY3RWYWx1ZXMobykge1xuICAgIHZhciBrLFxuICAgICAgICBhID0gW107XG5cbiAgICBmb3IgKGsgaW4gbylcbiAgICAgIGEucHVzaChvW2tdKTtcblxuICAgIHJldHVybiBhO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc2hvcnQgXCJEYXRlLm5vdygpXCIgcG9seWZpbGwuXG4gICAqXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIGN1cnJlbnQgdGltZSAoaW4gbXMpLlxuICAgKi9cbiAgZnVuY3Rpb24gX19kYXRlTm93KCkge1xuICAgIHJldHVybiBEYXRlLm5vdyA/IERhdGUubm93KCkgOiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQb2x5ZmlsbCBmb3IgdGhlIEFycmF5LmlzQXJyYXkgZnVuY3Rpb246XG4gICAqL1xuICBpZiAoIUFycmF5LmlzQXJyYXkpXG4gICAgQXJyYXkuaXNBcnJheSA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodikgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgfTtcblxuXG4gIC8qKlxuICAgKiBFWFBPUlQgUFVCTElDIEFQSTpcbiAgICogKioqKioqKioqKioqKioqKioqXG4gICAqL1xuICB2YXIgY29ucmFkID0ge1xuICAgIGhhc0pvYjogX2hhc0pvYixcbiAgICBhZGRKb2I6IF9hZGRKb2IsXG4gICAga2lsbEpvYjogX2tpbGxKb2IsXG4gICAga2lsbEFsbDogX2tpbGxBbGwsXG4gICAgc2V0dGluZ3M6IF9zZXR0aW5ncyxcbiAgICBnZXRTdGF0czogX2dldFN0YXRzLFxuICAgIGlzUnVubmluZzogX2dldElzUnVubmluZyxcbiAgICBjbGVhckhpc3Rvcnk6IF9jbGVhckhpc3RvcnksXG5cbiAgICAvLyBFdmVudHMgbWFuYWdlbWVudDpcbiAgICBiaW5kOiBfYmluZCxcbiAgICB1bmJpbmQ6IF91bmJpbmQsXG5cbiAgICAvLyBWZXJzaW9uOlxuICAgIHZlcnNpb246ICcwLjEuMCdcbiAgfTtcblxuICBpZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKVxuICAgICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gY29ucmFkO1xuICAgIGV4cG9ydHMuY29ucmFkID0gY29ucmFkO1xuICB9XG4gIGdsb2JhbC5jb25yYWQgPSBjb25yYWQ7XG59KSh0aGlzKTtcblxuLy8gSGFyZGNvZGVkIGV4cG9ydCBmb3IgdGhlIG5vZGUuanMgdmVyc2lvbjpcbnZhciBzaWdtYSA9IHRoaXMuc2lnbWEsXG4gICAgY29ucmFkID0gdGhpcy5jb25yYWQ7XG5cbnNpZ21hLmNvbnJhZCA9IGNvbnJhZDtcblxuLy8gRGlydHkgcG9seWZpbGxzIHRvIHBlcm1pdCBzaWdtYSB1c2FnZSBpbiBub2RlXG5pZiAodHlwZW9mIEhUTUxFbGVtZW50ID09PSAndW5kZWZpbmVkJylcbiAgSFRNTEVsZW1lbnQgPSBmdW5jdGlvbigpIHt9O1xuXG5pZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpXG4gIHdpbmRvdyA9IHtcbiAgICBhZGRFdmVudExpc3RlbmVyOiBmdW5jdGlvbigpIHt9XG4gIH07XG5cbmlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKVxuICAgIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHNpZ21hO1xuICBleHBvcnRzLnNpZ21hID0gc2lnbWE7XG59XG5cbjsoZnVuY3Rpb24odW5kZWZpbmVkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBpZiAodHlwZW9mIHNpZ21hID09PSAndW5kZWZpbmVkJylcbiAgICB0aHJvdyAnc2lnbWEgaXMgbm90IGRlY2xhcmVkJztcblxuICB2YXIgX3Jvb3QgPSB0aGlzO1xuXG4gIC8vIEluaXRpYWxpemUgcGFja2FnZXM6XG4gIHNpZ21hLnV0aWxzID0gc2lnbWEudXRpbHMgfHwge307XG5cbiAgLyoqXG4gICAqIE1JU0MgVVRJTFM6XG4gICAqL1xuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiB0YWtlcyBhbnkgbnVtYmVyIG9mIG9iamVjdHMgYXMgYXJndW1lbnRzLCBjb3BpZXMgZnJvbSBlYWNoXG4gICAqIG9mIHRoZXNlIG9iamVjdHMgZWFjaCBwYWlyIGtleS92YWx1ZSBpbnRvIGEgbmV3IG9iamVjdCwgYW5kIGZpbmFsbHlcbiAgICogcmV0dXJucyB0aGlzIG9iamVjdC5cbiAgICpcbiAgICogVGhlIGFyZ3VtZW50cyBhcmUgcGFyc2VkIGZyb20gdGhlIGxhc3Qgb25lIHRvIHRoZSBmaXJzdCBvbmUsIHN1Y2ggdGhhdFxuICAgKiB3aGVuIHNldmVyYWwgb2JqZWN0cyBoYXZlIGtleXMgaW4gY29tbW9uLCB0aGUgXCJlYXJsaWVzdFwiIG9iamVjdCB3aW5zLlxuICAgKlxuICAgKiBFeGFtcGxlOlxuICAgKiAqKioqKioqKlxuICAgKiAgPiB2YXIgbzEgPSB7XG4gICAqICA+ICAgICAgIGE6IDEsXG4gICAqICA+ICAgICAgIGI6IDIsXG4gICAqICA+ICAgICAgIGM6ICczJ1xuICAgKiAgPiAgICAgfSxcbiAgICogID4gICAgIG8yID0ge1xuICAgKiAgPiAgICAgICBjOiAnNCcsXG4gICAqICA+ICAgICAgIGQ6IFsgNSBdXG4gICAqICA+ICAgICB9O1xuICAgKiAgPiBzaWdtYS51dGlscy5leHRlbmQobzEsIG8yKTtcbiAgICogID4gLy8gUmV0dXJuczoge1xuICAgKiAgPiAvLyAgIGE6IDEsXG4gICAqICA+IC8vICAgYjogMixcbiAgICogID4gLy8gICBjOiAnMycsXG4gICAqICA+IC8vICAgZDogWyA1IF1cbiAgICogID4gLy8gfTtcbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0K30gQW55IG51bWJlciBvZiBvYmplY3RzLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICBUaGUgbWVyZ2VkIG9iamVjdC5cbiAgICovXG4gIHNpZ21hLnV0aWxzLmV4dGVuZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpLFxuICAgICAgICBrLFxuICAgICAgICByZXMgPSB7fSxcbiAgICAgICAgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSBsIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICBmb3IgKGsgaW4gYXJndW1lbnRzW2ldKVxuICAgICAgICByZXNba10gPSBhcmd1bWVudHNbaV1ba107XG5cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBIHNob3J0IFwiRGF0ZS5ub3coKVwiIHBvbHlmaWxsLlxuICAgKlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBjdXJyZW50IHRpbWUgKGluIG1zKS5cbiAgICovXG4gIHNpZ21hLnV0aWxzLmRhdGVOb3cgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gRGF0ZS5ub3cgPyBEYXRlLm5vdygpIDogbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRha2VzIGEgcGFja2FnZSBuYW1lIGFzIHBhcmFtZXRlciBhbmQgY2hlY2tzIGF0IGVhY2ggbGViZWwgaWYgaXQgZXhpc3RzLFxuICAgKiBhbmQgaWYgaXQgZG9lcyBub3QsIGNyZWF0ZXMgaXQuXG4gICAqXG4gICAqIEV4YW1wbGU6XG4gICAqICoqKioqKioqXG4gICAqICA+IHNpZ21hLnV0aWxzLnBrZygnYS5iLmMnKTtcbiAgICogID4gYS5iLmM7XG4gICAqICA+IC8vIE9iamVjdCB7fTtcbiAgICogID5cbiAgICogID4gc2lnbWEudXRpbHMucGtnKCdhLmIuZCcpO1xuICAgKiAgPiBhLmI7XG4gICAqICA+IC8vIE9iamVjdCB7IGM6IHt9LCBkOiB7fSB9O1xuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHBrZ05hbWUgVGhlIG5hbWUgb2YgdGhlIHBhY2thZ2UgdG8gY3JlYXRlL2ZpbmQuXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICBUaGUgcmVsYXRlZCBwYWNrYWdlLlxuICAgKi9cbiAgc2lnbWEudXRpbHMucGtnID0gZnVuY3Rpb24ocGtnTmFtZSkge1xuICAgIHJldHVybiAocGtnTmFtZSB8fCAnJykuc3BsaXQoJy4nKS5yZWR1Y2UoZnVuY3Rpb24oY29udGV4dCwgb2JqTmFtZSkge1xuICAgICAgcmV0dXJuIChvYmpOYW1lIGluIGNvbnRleHQpID9cbiAgICAgICAgY29udGV4dFtvYmpOYW1lXSA6XG4gICAgICAgIChjb250ZXh0W29iak5hbWVdID0ge30pO1xuICAgIH0sIF9yb290KTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBhIHVuaXF1ZSBpbmNyZW1lbnRhbCBudW1iZXIgSUQuXG4gICAqXG4gICAqIEV4YW1wbGU6XG4gICAqICoqKioqKioqXG4gICAqICA+IHNpZ21hLnV0aWxzLmlkKCk7XG4gICAqICA+IC8vIDE7XG4gICAqICA+XG4gICAqICA+IHNpZ21hLnV0aWxzLmlkKCk7XG4gICAqICA+IC8vIDI7XG4gICAqICA+XG4gICAqICA+IHNpZ21hLnV0aWxzLmlkKCk7XG4gICAqICA+IC8vIDM7XG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gcGtnTmFtZSBUaGUgbmFtZSBvZiB0aGUgcGFja2FnZSB0byBjcmVhdGUvZmluZC5cbiAgICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgIFRoZSByZWxhdGVkIHBhY2thZ2UuXG4gICAqL1xuICBzaWdtYS51dGlscy5pZCA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgaSA9IDA7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICsraTtcbiAgICB9O1xuICB9KSgpO1xuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHRha2VzIGFuIGhleGEgY29sb3IgKGZvciBpbnN0YW5jZSBcIiNmZmNjMDBcIiBvciBcIiNmYzBcIikgb3IgYVxuICAgKiByZ2IgLyByZ2JhIGNvbG9yIChsaWtlIFwicmdiKDI1NSwyNTUsMTIpXCIgb3IgXCJyZ2JhKDI1NSwyNTUsMTIsMSlcIikgYW5kXG4gICAqIHJldHVybnMgYW4gaW50ZWdlciBlcXVhbCB0byBcInIgKiAyNTUgKiAyNTUgKyBnICogMjU1ICsgYlwiLCB0byBnYWluIHNvbWVcbiAgICogbWVtb3J5IGluIHRoZSBkYXRhIGdpdmVuIHRvIFdlYkdMIHNoYWRlcnMuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGUgZnVuY3Rpb24gYWN0dWFsbHkgY2FjaGVzIGl0cyByZXN1bHRzIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gdmFsIFRoZSBoZXhhIG9yIHJnYmEgY29sb3IuXG4gICAqIEByZXR1cm4ge251bWJlcn0gICAgIFRoZSBudW1iZXIgdmFsdWUuXG4gICAqL1xuICB2YXIgZmxvYXRDb2xvckNhY2hlID0ge307XG5cbiAgc2lnbWEudXRpbHMuZmxvYXRDb2xvciA9IGZ1bmN0aW9uKHZhbCkge1xuXG4gICAgLy8gSXMgdGhlIGNvbG9yIGFscmVhZHkgY29tcHV0ZWQ/XG4gICAgaWYgKGZsb2F0Q29sb3JDYWNoZVt2YWxdKVxuICAgICAgcmV0dXJuIGZsb2F0Q29sb3JDYWNoZVt2YWxdO1xuXG4gICAgdmFyIG9yaWdpbmFsID0gdmFsLFxuICAgICAgICByID0gMCxcbiAgICAgICAgZyA9IDAsXG4gICAgICAgIGIgPSAwO1xuXG4gICAgaWYgKHZhbFswXSA9PT0gJyMnKSB7XG4gICAgICB2YWwgPSB2YWwuc2xpY2UoMSk7XG5cbiAgICAgIGlmICh2YWwubGVuZ3RoID09PSAzKSB7XG4gICAgICAgIHIgPSBwYXJzZUludCh2YWwuY2hhckF0KDApICsgdmFsLmNoYXJBdCgwKSwgMTYpO1xuICAgICAgICBnID0gcGFyc2VJbnQodmFsLmNoYXJBdCgxKSArIHZhbC5jaGFyQXQoMSksIDE2KTtcbiAgICAgICAgYiA9IHBhcnNlSW50KHZhbC5jaGFyQXQoMikgKyB2YWwuY2hhckF0KDIpLCAxNik7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgciA9IHBhcnNlSW50KHZhbC5jaGFyQXQoMCkgKyB2YWwuY2hhckF0KDEpLCAxNik7XG4gICAgICAgIGcgPSBwYXJzZUludCh2YWwuY2hhckF0KDIpICsgdmFsLmNoYXJBdCgzKSwgMTYpO1xuICAgICAgICBiID0gcGFyc2VJbnQodmFsLmNoYXJBdCg0KSArIHZhbC5jaGFyQXQoNSksIDE2KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHZhbC5tYXRjaCgvXiAqcmdiYT8gKlxcKC8pKSB7XG4gICAgICB2YWwgPSB2YWwubWF0Y2goXG4gICAgICAgIC9eICpyZ2JhPyAqXFwoICooWzAtOV0qKSAqLCAqKFswLTldKikgKiwgKihbMC05XSopICooLC4qKT9cXCkgKiQvXG4gICAgICApO1xuICAgICAgciA9ICt2YWxbMV07XG4gICAgICBnID0gK3ZhbFsyXTtcbiAgICAgIGIgPSArdmFsWzNdO1xuICAgIH1cblxuICAgIHZhciBjb2xvciA9IChcbiAgICAgIHIgKiAyNTYgKiAyNTYgK1xuICAgICAgZyAqIDI1NiArXG4gICAgICBiXG4gICAgKTtcblxuICAgIC8vIENhY2hpbmcgdGhlIGNvbG9yXG4gICAgZmxvYXRDb2xvckNhY2hlW29yaWdpbmFsXSA9IGNvbG9yO1xuXG4gICAgcmV0dXJuIGNvbG9yO1xuICB9O1xuXG4gICAgLyoqXG4gICAqIFBlcmZvcm0gYSB6b29tIGludG8gYSBjYW1lcmEsIHdpdGggb3Igd2l0aG91dCBhbmltYXRpb24sIHRvIHRoZVxuICAgKiBjb29yZGluYXRlcyBpbmRpY2F0ZWQgdXNpbmcgYSBzcGVjaWZpZWQgcmF0aW8uXG4gICAqXG4gICAqIFJlY29nbml6ZWQgcGFyYW1ldGVyczpcbiAgICogKioqKioqKioqKioqKioqKioqKioqKlxuICAgKiBIZXJlIGlzIHRoZSBleGhhdXN0aXZlIGxpc3Qgb2YgZXZlcnkgYWNjZXB0ZWQgcGFyYW1ldGVycyBpbiB0aGUgYW5pbWF0aW9uXG4gICAqIG9iamVjdDpcbiAgICpcbiAgICogICB7P251bWJlcn0gZHVyYXRpb24gICAgIEFuIGFtb3VudCBvZiB0aW1lIHRoYXQgbWVhbnMgdGhlIGR1cmF0aW9uIG9mIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uLiBJZiB0aGlzIHBhcmFtZXRlciBkb2Vzbid0IGV4aXN0IHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgem9vbSB3aWxsIGJlIHBlcmZvcm1lZCB3aXRob3V0IGFuaW1hdGlvbi5cbiAgICogICB7P2Z1bmN0aW9ufSBvbkNvbXBsZXRlIEEgZnVuY3Rpb24gdG8gcGVyZm9ybSBpdCBhZnRlciB0aGUgYW5pbWF0aW9uLiBJdFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgd2lsbCBiZSBwZXJmb3JtZWQgZXZlbiBpZiB0aGVyZSBpcyBubyBkdXJhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtjYW1lcmF9ICAgICBUaGUgY2FtZXJhIHdoZXJlIHBlcmZvcm0gdGhlIHpvb20uXG4gICAqIEBwYXJhbSB7eH0gICAgICAgICAgVGhlIFggY29vcmRpYW50aW9uIHdoZXJlIHRoZSB6b29tIGdvZXMuXG4gICAqIEBwYXJhbSB7eX0gICAgICAgICAgVGhlIFkgY29vcmRpYW50aW9uIHdoZXJlIHRoZSB6b29tIGdvZXMuXG4gICAqIEBwYXJhbSB7cmF0aW99ICAgICAgVGhlIHJhdGlvIHRvIGFwcGx5IGl0IHRvIHRoZSBjdXJyZW50IGNhbWVyYSByYXRpby5cbiAgICogQHBhcmFtIHs/YW5pbWF0aW9ufSBBIGRpY3Rpb25hcnkgd2l0aCBvcHRpb25zIGZvciBhIHBvc3NpYmxlIGFuaW1hdGlvbi5cbiAgICovXG4gIHNpZ21hLnV0aWxzLnpvb21UbyA9IGZ1bmN0aW9uKGNhbWVyYSwgeCwgeSwgcmF0aW8sIGFuaW1hdGlvbikge1xuICAgIHZhciBzZXR0aW5ncyA9IGNhbWVyYS5zZXR0aW5ncyxcbiAgICAgICAgY291bnQsXG4gICAgICAgIG5ld1JhdGlvLFxuICAgICAgICBhbmltYXRpb25TZXR0aW5ncyxcbiAgICAgICAgY29vcmRpbmF0ZXM7XG5cbiAgICAvLyBDcmVhdGUgdGhlIG5ld1JhdGlvIGRlYWxpbmcgd2l0aCBtaW4gLyBtYXg6XG4gICAgbmV3UmF0aW8gPSBNYXRoLm1heChcbiAgICAgIHNldHRpbmdzKCd6b29tTWluJyksXG4gICAgICBNYXRoLm1pbihcbiAgICAgICAgc2V0dGluZ3MoJ3pvb21NYXgnKSxcbiAgICAgICAgY2FtZXJhLnJhdGlvICogcmF0aW9cbiAgICAgIClcbiAgICApO1xuXG4gICAgLy8gQ2hlY2sgdGhhdCB0aGUgbmV3IHJhdGlvIGlzIGRpZmZlcmVudCBmcm9tIHRoZSBpbml0aWFsIG9uZTpcbiAgICBpZiAobmV3UmF0aW8gIT09IGNhbWVyYS5yYXRpbykge1xuICAgICAgLy8gQ3JlYXRlIHRoZSBjb29yZGluYXRlcyB2YXJpYWJsZTpcbiAgICAgIHJhdGlvID0gbmV3UmF0aW8gLyBjYW1lcmEucmF0aW87XG4gICAgICBjb29yZGluYXRlcyA9IHtcbiAgICAgICAgeDogeCAqICgxIC0gcmF0aW8pICsgY2FtZXJhLngsXG4gICAgICAgIHk6IHkgKiAoMSAtIHJhdGlvKSArIGNhbWVyYS55LFxuICAgICAgICByYXRpbzogbmV3UmF0aW9cbiAgICAgIH07XG5cbiAgICAgIGlmIChhbmltYXRpb24gJiYgYW5pbWF0aW9uLmR1cmF0aW9uKSB7XG4gICAgICAgIC8vIENvbXBsZXRlIHRoZSBhbmltYXRpb24gc2V0aW5nczpcbiAgICAgICAgY291bnQgPSBzaWdtYS5taXNjLmFuaW1hdGlvbi5raWxsQWxsKGNhbWVyYSk7XG4gICAgICAgIGFuaW1hdGlvbiA9IHNpZ21hLnV0aWxzLmV4dGVuZChcbiAgICAgICAgICBhbmltYXRpb24sXG4gICAgICAgICAge1xuICAgICAgICAgICAgZWFzaW5nOiBjb3VudCA/ICdxdWFkcmF0aWNPdXQnIDogJ3F1YWRyYXRpY0luT3V0J1xuICAgICAgICAgIH1cbiAgICAgICAgKTtcblxuICAgICAgICBzaWdtYS5taXNjLmFuaW1hdGlvbi5jYW1lcmEoY2FtZXJhLCBjb29yZGluYXRlcywgYW5pbWF0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbWVyYS5nb1RvKGNvb3JkaW5hdGVzKTtcbiAgICAgICAgaWYgKGFuaW1hdGlvbiAmJiBhbmltYXRpb24ub25Db21wbGV0ZSlcbiAgICAgICAgICBhbmltYXRpb24ub25Db21wbGV0ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBjb250cm9sIHBvaW50IGNvb3JkaW5hdGVzIGZvciBhIHF1YWRyYXRpYyBiZXppZXIgY3VydmUuXG4gICAqXG4gICAqIEBwYXJhbSAge251bWJlcn0geDEgIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHN0YXJ0IHBvaW50LlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkxICBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBzdGFydCBwb2ludC5cbiAgICogQHBhcmFtICB7bnVtYmVyfSB4MiAgVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgZW5kIHBvaW50LlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkyICBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBlbmQgcG9pbnQuXG4gICAqIEByZXR1cm4ge3gseX0gICAgICAgIFRoZSBjb250cm9sIHBvaW50IGNvb3JkaW5hdGVzLlxuICAgKi9cbiAgc2lnbWEudXRpbHMuZ2V0UXVhZHJhdGljQ29udHJvbFBvaW50ID0gZnVuY3Rpb24oeDEsIHkxLCB4MiwgeTIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogKHgxICsgeDIpIC8gMiArICh5MiAtIHkxKSAvIDQsXG4gICAgICB5OiAoeTEgKyB5MikgLyAyICsgKHgxIC0geDIpIC8gNFxuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAgKiBDb21wdXRlIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgcG9pbnQgcG9zaXRpb25lZFxuICAgICogYXQgbGVuZ3RoIHQgaW4gdGhlIHF1YWRyYXRpYyBiZXppZXIgY3VydmUuXG4gICAgKlxuICAgICogQHBhcmFtICB7bnVtYmVyfSB0ICBJbiBbMCwxXSB0aGUgc3RlcCBwZXJjZW50YWdlIHRvIHJlYWNoXG4gICAgKiAgICAgICAgICAgICAgICAgICAgIHRoZSBwb2ludCBpbiB0aGUgY3VydmUgZnJvbSB0aGUgY29udGV4dCBwb2ludC5cbiAgICAqIEBwYXJhbSAge251bWJlcn0geDEgVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgY29udGV4dCBwb2ludC5cbiAgICAqIEBwYXJhbSAge251bWJlcn0geTEgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgY29udGV4dCBwb2ludC5cbiAgICAqIEBwYXJhbSAge251bWJlcn0geDIgVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgZW5kaW5nIHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSB5MiBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBlbmRpbmcgcG9pbnQuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHhpIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGNvbnRyb2wgcG9pbnQuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHlpIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGNvbnRyb2wgcG9pbnQuXG4gICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgIHt4LHl9LlxuICAqL1xuICBzaWdtYS51dGlscy5nZXRQb2ludE9uUXVhZHJhdGljQ3VydmUgPSBmdW5jdGlvbih0LCB4MSwgeTEsIHgyLCB5MiwgeGksIHlpKSB7XG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNTYzNDUyOFxuICAgIHJldHVybiB7XG4gICAgICB4OiBNYXRoLnBvdygxIC0gdCwgMikgKiB4MSArIDIgKiAoMSAtIHQpICogdCAqIHhpICsgTWF0aC5wb3codCwgMikgKiB4MixcbiAgICAgIHk6IE1hdGgucG93KDEgLSB0LCAyKSAqIHkxICsgMiAqICgxIC0gdCkgKiB0ICogeWkgKyBNYXRoLnBvdyh0LCAyKSAqIHkyXG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICAqIENvbXB1dGUgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBwb2ludCBwb3NpdGlvbmVkXG4gICAgKiBhdCBsZW5ndGggdCBpbiB0aGUgY3ViaWMgYmV6aWVyIGN1cnZlLlxuICAgICpcbiAgICAqIEBwYXJhbSAge251bWJlcn0gdCAgSW4gWzAsMV0gdGhlIHN0ZXAgcGVyY2VudGFnZSB0byByZWFjaFxuICAgICogICAgICAgICAgICAgICAgICAgICB0aGUgcG9pbnQgaW4gdGhlIGN1cnZlIGZyb20gdGhlIGNvbnRleHQgcG9pbnQuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgxIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGNvbnRleHQgcG9pbnQuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkxIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGNvbnRleHQgcG9pbnQuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgyIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGVuZCBwb2ludC5cbiAgICAqIEBwYXJhbSAge251bWJlcn0geTIgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgZW5kIHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSBjeCBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBmaXJzdCBjb250cm9sIHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSBjeSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBmaXJzdCBjb250cm9sIHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSBkeCBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBzZWNvbmQgY29udHJvbCBwb2ludC5cbiAgICAqIEBwYXJhbSAge251bWJlcn0gZHkgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgc2Vjb25kIGNvbnRyb2wgcG9pbnQuXG4gICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgIHt4LHl9IFRoZSBwb2ludCBhdCB0LlxuICAqL1xuICBzaWdtYS51dGlscy5nZXRQb2ludE9uQmV6aWVyQ3VydmUgPVxuICAgIGZ1bmN0aW9uKHQsIHgxLCB5MSwgeDIsIHkyLCBjeCwgY3ksIGR4LCBkeSkge1xuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE1Mzk3NTk2XG4gICAgLy8gQmxlbmRpbmcgZnVuY3Rpb25zOlxuICAgIHZhciBCMF90ID0gTWF0aC5wb3coMSAtIHQsIDMpLFxuICAgICAgICBCMV90ID0gMyAqIHQgKiBNYXRoLnBvdygxIC0gdCwgMiksXG4gICAgICAgIEIyX3QgPSAzICogTWF0aC5wb3codCwgMikgKiAoMSAtIHQpLFxuICAgICAgICBCM190ID0gTWF0aC5wb3codCwgMyk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgeDogKEIwX3QgKiB4MSkgKyAoQjFfdCAqIGN4KSArIChCMl90ICogZHgpICsgKEIzX3QgKiB4MiksXG4gICAgICB5OiAoQjBfdCAqIHkxKSArIChCMV90ICogY3kpICsgKEIyX3QgKiBkeSkgKyAoQjNfdCAqIHkyKVxuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIHR3byBjb250cm9sIHBvaW50cyBmb3IgYSBzZWxmIGxvb3AgKGkuZS5cbiAgICogd2hlcmUgdGhlIHN0YXJ0IHBvaW50IGlzIGFsc28gdGhlIGVuZCBwb2ludCkgY29tcHV0ZWQgYXMgYSBjdWJpYyBiZXppZXJcbiAgICogY3VydmUuXG4gICAqXG4gICAqIEBwYXJhbSAge251bWJlcn0geCAgICBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBub2RlLlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkgICAgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgbm9kZS5cbiAgICogQHBhcmFtICB7bnVtYmVyfSBzaXplIFRoZSBub2RlIHNpemUuXG4gICAqIEByZXR1cm4ge3gxLHkxLHgyLHkyfSBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIHR3byBjb250cm9sIHBvaW50cy5cbiAgICovXG4gIHNpZ21hLnV0aWxzLmdldFNlbGZMb29wQ29udHJvbFBvaW50cyA9IGZ1bmN0aW9uKHggLCB5LCBzaXplKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHgxOiB4IC0gc2l6ZSAqIDcsXG4gICAgICB5MTogeSxcbiAgICAgIHgyOiB4LFxuICAgICAgeTI6IHkgKyBzaXplICogN1xuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50cyBvZiBhIHBsYW5lXG4gICAqIHdpdGggYW4gb3J0aG9ub3JtYWwgYmFzaXMuXG4gICAqXG4gICAqIEBwYXJhbSAge251bWJlcn0geDEgIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGZpcnN0IHBvaW50LlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkxICBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBmaXJzdCBwb2ludC5cbiAgICogQHBhcmFtICB7bnVtYmVyfSB4MiAgVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgc2Vjb25kIHBvaW50LlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkyICBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBzZWNvbmQgcG9pbnQuXG4gICAqIEByZXR1cm4ge251bWJlcn0gICAgIFRoZSBldWNsaWRpYW4gZGlzdGFuY2UuXG4gICAqL1xuICBzaWdtYS51dGlscy5nZXREaXN0YW5jZSA9IGZ1bmN0aW9uKHgwLCB5MCwgeDEsIHkxKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyh4MSAtIHgwLCAyKSArIE1hdGgucG93KHkxIC0geTAsIDIpKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgaW50ZXJzZWN0aW9uIHBvaW50cyBvZiB0d28gY2lyY2xlcy5cbiAgICpcbiAgICogQHBhcmFtICB7bnVtYmVyfSB4MCAgVGhlIFggY29vcmRpbmF0ZSBvZiBjZW50ZXIgbG9jYXRpb24gb2YgdGhlIGZpcnN0XG4gICAqICAgICAgICAgICAgICAgICAgICAgIGNpcmNsZS5cbiAgICogQHBhcmFtICB7bnVtYmVyfSB5MCAgVGhlIFkgY29vcmRpbmF0ZSBvZiBjZW50ZXIgbG9jYXRpb24gb2YgdGhlIGZpcnN0XG4gICAqICAgICAgICAgICAgICAgICAgICAgIGNpcmNsZS5cbiAgICogQHBhcmFtICB7bnVtYmVyfSByMCAgVGhlIHJhZGl1cyBvZiB0aGUgZmlyc3QgY2lyY2xlLlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgxICBUaGUgWCBjb29yZGluYXRlIG9mIGNlbnRlciBsb2NhdGlvbiBvZiB0aGUgc2Vjb25kXG4gICAqICAgICAgICAgICAgICAgICAgICAgIGNpcmNsZS5cbiAgICogQHBhcmFtICB7bnVtYmVyfSB5MSAgVGhlIFkgY29vcmRpbmF0ZSBvZiBjZW50ZXIgbG9jYXRpb24gb2YgdGhlIHNlY29uZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICBjaXJjbGUuXG4gICAqIEBwYXJhbSAge251bWJlcn0gcjEgIFRoZSByYWRpdXMgb2YgdGhlIHNlY29uZCBjaXJjbGUuXG4gICAqIEByZXR1cm4ge3hpLHlpfSAgICAgIFRoZSBjb29yZGluYXRlcyBvZiB0aGUgaW50ZXJzZWN0aW9uIHBvaW50cy5cbiAgICovXG4gIHNpZ21hLnV0aWxzLmdldENpcmNsZUludGVyc2VjdGlvbiA9IGZ1bmN0aW9uKHgwLCB5MCwgcjAsIHgxLCB5MSwgcjEpIHtcbiAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xMjIxOTgwMlxuICAgIHZhciBhLCBkeCwgZHksIGQsIGgsIHJ4LCByeSwgeDIsIHkyO1xuXG4gICAgLy8gZHggYW5kIGR5IGFyZSB0aGUgdmVydGljYWwgYW5kIGhvcml6b250YWwgZGlzdGFuY2VzIGJldHdlZW4gdGhlIGNpcmNsZVxuICAgIC8vIGNlbnRlcnM6XG4gICAgZHggPSB4MSAtIHgwO1xuICAgIGR5ID0geTEgLSB5MDtcblxuICAgIC8vIERldGVybWluZSB0aGUgc3RyYWlnaHQtbGluZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBjZW50ZXJzOlxuICAgIGQgPSBNYXRoLnNxcnQoKGR5ICogZHkpICsgKGR4ICogZHgpKTtcblxuICAgIC8vIENoZWNrIGZvciBzb2x2YWJpbGl0eTpcbiAgICBpZiAoZCA+IChyMCArIHIxKSkge1xuICAgICAgICAvLyBObyBzb2x1dGlvbi4gY2lyY2xlcyBkbyBub3QgaW50ZXJzZWN0LlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChkIDwgTWF0aC5hYnMocjAgLSByMSkpIHtcbiAgICAgICAgLy8gTm8gc29sdXRpb24uIG9uZSBjaXJjbGUgaXMgY29udGFpbmVkIGluIHRoZSBvdGhlci5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vJ3BvaW50IDInIGlzIHRoZSBwb2ludCB3aGVyZSB0aGUgbGluZSB0aHJvdWdoIHRoZSBjaXJjbGUgaW50ZXJzZWN0aW9uXG4gICAgLy8gcG9pbnRzIGNyb3NzZXMgdGhlIGxpbmUgYmV0d2VlbiB0aGUgY2lyY2xlIGNlbnRlcnMuXG5cbiAgICAvLyBEZXRlcm1pbmUgdGhlIGRpc3RhbmNlIGZyb20gcG9pbnQgMCB0byBwb2ludCAyOlxuICAgIGEgPSAoKHIwICogcjApIC0gKHIxICogcjEpICsgKGQgKiBkKSkgLyAoMi4wICogZCk7XG5cbiAgICAvLyBEZXRlcm1pbmUgdGhlIGNvb3JkaW5hdGVzIG9mIHBvaW50IDI6XG4gICAgeDIgPSB4MCArIChkeCAqIGEgLyBkKTtcbiAgICB5MiA9IHkwICsgKGR5ICogYSAvIGQpO1xuXG4gICAgLy8gRGV0ZXJtaW5lIHRoZSBkaXN0YW5jZSBmcm9tIHBvaW50IDIgdG8gZWl0aGVyIG9mIHRoZSBpbnRlcnNlY3Rpb25cbiAgICAvLyBwb2ludHM6XG4gICAgaCA9IE1hdGguc3FydCgocjAgKiByMCkgLSAoYSAqIGEpKTtcblxuICAgIC8vIERldGVybWluZSB0aGUgb2Zmc2V0cyBvZiB0aGUgaW50ZXJzZWN0aW9uIHBvaW50cyBmcm9tIHBvaW50IDI6XG4gICAgcnggPSAtZHkgKiAoaCAvIGQpO1xuICAgIHJ5ID0gZHggKiAoaCAvIGQpO1xuXG4gICAgLy8gRGV0ZXJtaW5lIHRoZSBhYnNvbHV0ZSBpbnRlcnNlY3Rpb24gcG9pbnRzOlxuICAgIHZhciB4aSA9IHgyICsgcng7XG4gICAgdmFyIHhpX3ByaW1lID0geDIgLSByeDtcbiAgICB2YXIgeWkgPSB5MiArIHJ5O1xuICAgIHZhciB5aV9wcmltZSA9IHkyIC0gcnk7XG5cbiAgICByZXR1cm4ge3hpOiB4aSwgeGlfcHJpbWU6IHhpX3ByaW1lLCB5aTogeWksIHlpX3ByaW1lOiB5aV9wcmltZX07XG4gIH07XG5cbiAgLyoqXG4gICAgKiBDaGVjayBpZiBhIHBvaW50IGlzIG9uIGEgbGluZSBzZWdtZW50LlxuICAgICpcbiAgICAqIEBwYXJhbSAge251bWJlcn0geCAgICAgICBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byBjaGVjay5cbiAgICAqIEBwYXJhbSAge251bWJlcn0geSAgICAgICBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byBjaGVjay5cbiAgICAqIEBwYXJhbSAge251bWJlcn0geDEgICAgICBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBsaW5lIHN0YXJ0IHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSB5MSAgICAgIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGxpbmUgc3RhcnQgcG9pbnQuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgyICAgICAgVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgbGluZSBlbmQgcG9pbnQuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkyICAgICAgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgbGluZSBlbmQgcG9pbnQuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IGVwc2lsb24gVGhlIHByZWNpc2lvbiAoY29uc2lkZXIgdGhlIGxpbmUgdGhpY2tuZXNzKS5cbiAgICAqIEByZXR1cm4ge2Jvb2xlYW59ICAgICAgICBUcnVlIGlmIHBvaW50IGlzIFwiY2xvc2UgdG9cIiB0aGUgbGluZVxuICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHNlZ21lbnQsIGZhbHNlIG90aGVyd2lzZS5cbiAgKi9cbiAgc2lnbWEudXRpbHMuaXNQb2ludE9uU2VnbWVudCA9IGZ1bmN0aW9uKHgsIHksIHgxLCB5MSwgeDIsIHkyLCBlcHNpbG9uKSB7XG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzI4MTIyXG4gICAgdmFyIGNyb3NzUHJvZHVjdCA9IE1hdGguYWJzKCh5IC0geTEpICogKHgyIC0geDEpIC0gKHggLSB4MSkgKiAoeTIgLSB5MSkpLFxuICAgICAgICBkID0gc2lnbWEudXRpbHMuZ2V0RGlzdGFuY2UoeDEsIHkxLCB4MiwgeTIpLFxuICAgICAgICBuQ3Jvc3NQcm9kdWN0ID0gY3Jvc3NQcm9kdWN0IC8gZDsgLy8gbm9ybWFsaXplZCBjcm9zcyBwcm9kdWN0XG5cbiAgICByZXR1cm4gKG5Dcm9zc1Byb2R1Y3QgPCBlcHNpbG9uICYmXG4gICAgIE1hdGgubWluKHgxLCB4MikgPD0geCAmJiB4IDw9IE1hdGgubWF4KHgxLCB4MikgJiZcbiAgICAgTWF0aC5taW4oeTEsIHkyKSA8PSB5ICYmIHkgPD0gTWF0aC5tYXgoeTEsIHkyKSk7XG4gIH07XG5cbiAgLyoqXG4gICAgKiBDaGVjayBpZiBhIHBvaW50IGlzIG9uIGEgcXVhZHJhdGljIGJlemllciBjdXJ2ZSBzZWdtZW50IHdpdGggYSB0aGlja25lc3MuXG4gICAgKlxuICAgICogQHBhcmFtICB7bnVtYmVyfSB4ICAgICAgIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIGNoZWNrLlxuICAgICogQHBhcmFtICB7bnVtYmVyfSB5ICAgICAgIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIGNoZWNrLlxuICAgICogQHBhcmFtICB7bnVtYmVyfSB4MSAgICAgIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGN1cnZlIHN0YXJ0IHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSB5MSAgICAgIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGN1cnZlIHN0YXJ0IHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSB4MiAgICAgIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGN1cnZlIGVuZCBwb2ludC5cbiAgICAqIEBwYXJhbSAge251bWJlcn0geTIgICAgICBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBjdXJ2ZSBlbmQgcG9pbnQuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IGNweCAgICAgVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgY3VydmUgY29udHJvbCBwb2ludC5cbiAgICAqIEBwYXJhbSAge251bWJlcn0gY3B5ICAgICBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBjdXJ2ZSBjb250cm9sIHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSBlcHNpbG9uIFRoZSBwcmVjaXNpb24gKGNvbnNpZGVyIHRoZSBsaW5lIHRoaWNrbmVzcykuXG4gICAgKiBAcmV0dXJuIHtib29sZWFufSAgICAgICAgVHJ1ZSBpZiAoeCx5KSBpcyBvbiB0aGUgY3VydmUgc2VnbWVudCxcbiAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICBmYWxzZSBvdGhlcndpc2UuXG4gICovXG4gIHNpZ21hLnV0aWxzLmlzUG9pbnRPblF1YWRyYXRpY0N1cnZlID1cbiAgICBmdW5jdGlvbih4LCB5LCB4MSwgeTEsIHgyLCB5MiwgY3B4LCBjcHksIGVwc2lsb24pIHtcbiAgICAvLyBGYWlscyBpZiB0aGUgcG9pbnQgaXMgdG9vIGZhciBmcm9tIHRoZSBleHRyZW1pdGllcyBvZiB0aGUgc2VnbWVudCxcbiAgICAvLyBwcmV2ZW50aW5nIGZvciBtb3JlIGNvc3RseSBjb21wdXRhdGlvbjpcbiAgICB2YXIgZFAxUDIgPSBzaWdtYS51dGlscy5nZXREaXN0YW5jZSh4MSwgeTEsIHgyLCB5Mik7XG4gICAgaWYgKE1hdGguYWJzKHggLSB4MSkgPiBkUDFQMiB8fCBNYXRoLmFicyh5IC0geTEpID4gZFAxUDIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgZFAxID0gc2lnbWEudXRpbHMuZ2V0RGlzdGFuY2UoeCwgeSwgeDEsIHkxKSxcbiAgICAgICAgZFAyID0gc2lnbWEudXRpbHMuZ2V0RGlzdGFuY2UoeCwgeSwgeDIsIHkyKSxcbiAgICAgICAgdCA9IDAuNSxcbiAgICAgICAgciA9IChkUDEgPCBkUDIpID8gLTAuMDEgOiAwLjAxLFxuICAgICAgICByVGhyZXNob2xkID0gMC4wMDEsXG4gICAgICAgIGkgPSAxMDAsXG4gICAgICAgIHB0ID0gc2lnbWEudXRpbHMuZ2V0UG9pbnRPblF1YWRyYXRpY0N1cnZlKHQsIHgxLCB5MSwgeDIsIHkyLCBjcHgsIGNweSksXG4gICAgICAgIGR0ID0gc2lnbWEudXRpbHMuZ2V0RGlzdGFuY2UoeCwgeSwgcHQueCwgcHQueSksXG4gICAgICAgIG9sZF9kdDtcblxuICAgIC8vIFRoaXMgYWxnb3JpdGhtIG1pbmltaXplcyB0aGUgZGlzdGFuY2UgZnJvbSB0aGUgcG9pbnQgdG8gdGhlIGN1cnZlLiBJdFxuICAgIC8vIGZpbmQgdGhlIG9wdGltYWwgdCB2YWx1ZSB3aGVyZSB0PTAgaXMgdGhlIHN0YXJ0IHBvaW50IGFuZCB0PTEgaXMgdGhlIGVuZFxuICAgIC8vIHBvaW50IG9mIHRoZSBjdXJ2ZSwgc3RhcnRpbmcgZnJvbSB0PTAuNS5cbiAgICAvLyBJdCB0ZXJtaW5hdGVzIGJlY2F1c2UgaXQgcnVucyBhIG1heGltdW0gb2YgaSBpbnRlcmF0aW9ucy5cbiAgICB3aGlsZSAoaS0tID4gMCAmJlxuICAgICAgdCA+PSAwICYmIHQgPD0gMSAmJlxuICAgICAgKGR0ID4gZXBzaWxvbikgJiZcbiAgICAgIChyID4gclRocmVzaG9sZCB8fCByIDwgLXJUaHJlc2hvbGQpKSB7XG4gICAgICBvbGRfZHQgPSBkdDtcbiAgICAgIHB0ID0gc2lnbWEudXRpbHMuZ2V0UG9pbnRPblF1YWRyYXRpY0N1cnZlKHQsIHgxLCB5MSwgeDIsIHkyLCBjcHgsIGNweSk7XG4gICAgICBkdCA9IHNpZ21hLnV0aWxzLmdldERpc3RhbmNlKHgsIHksIHB0LngsIHB0LnkpO1xuXG4gICAgICBpZiAoZHQgPiBvbGRfZHQpIHtcbiAgICAgICAgLy8gbm90IHRoZSByaWdodCBkaXJlY3Rpb246XG4gICAgICAgIC8vIGhhbGZzdGVwIGluIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb25cbiAgICAgICAgciA9IC1yIC8gMjtcbiAgICAgICAgdCArPSByO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodCArIHIgPCAwIHx8IHQgKyByID4gMSkge1xuICAgICAgICAvLyBvb3BzLCB3ZSd2ZSBnb25lIHRvbyBmYXI6XG4gICAgICAgIC8vIHJldmVydCB3aXRoIGEgaGFsZnN0ZXBcbiAgICAgICAgciA9IHIgLyAyO1xuICAgICAgICBkdCA9IG9sZF9kdDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBwcm9ncmVzczpcbiAgICAgICAgdCArPSByO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkdCA8IGVwc2lsb247XG4gIH07XG5cblxuICAvKipcbiAgICAqIENoZWNrIGlmIGEgcG9pbnQgaXMgb24gYSBjdWJpYyBiZXppZXIgY3VydmUgc2VnbWVudCB3aXRoIGEgdGhpY2tuZXNzLlxuICAgICpcbiAgICAqIEBwYXJhbSAge251bWJlcn0geCAgICAgICBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byBjaGVjay5cbiAgICAqIEBwYXJhbSAge251bWJlcn0geSAgICAgICBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byBjaGVjay5cbiAgICAqIEBwYXJhbSAge251bWJlcn0geDEgICAgICBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBjdXJ2ZSBzdGFydCBwb2ludC5cbiAgICAqIEBwYXJhbSAge251bWJlcn0geTEgICAgICBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBjdXJ2ZSBzdGFydCBwb2ludC5cbiAgICAqIEBwYXJhbSAge251bWJlcn0geDIgICAgICBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBjdXJ2ZSBlbmQgcG9pbnQuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkyICAgICAgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgY3VydmUgZW5kIHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSBjcHgxICAgIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIDFzdCBjdXJ2ZSBjb250cm9sIHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSBjcHkxICAgIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIDFzdCBjdXJ2ZSBjb250cm9sIHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSBjcHgyICAgIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIDJuZCBjdXJ2ZSBjb250cm9sIHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSBjcHkyICAgIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIDJuZCBjdXJ2ZSBjb250cm9sIHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSBlcHNpbG9uIFRoZSBwcmVjaXNpb24gKGNvbnNpZGVyIHRoZSBsaW5lIHRoaWNrbmVzcykuXG4gICAgKiBAcmV0dXJuIHtib29sZWFufSAgICAgICAgVHJ1ZSBpZiAoeCx5KSBpcyBvbiB0aGUgY3VydmUgc2VnbWVudCxcbiAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICBmYWxzZSBvdGhlcndpc2UuXG4gICovXG4gIHNpZ21hLnV0aWxzLmlzUG9pbnRPbkJlemllckN1cnZlID1cbiAgICBmdW5jdGlvbih4LCB5LCB4MSwgeTEsIHgyLCB5MiwgY3B4MSwgY3B5MSwgY3B4MiwgY3B5MiwgZXBzaWxvbikge1xuICAgIC8vIEZhaWxzIGlmIHRoZSBwb2ludCBpcyB0b28gZmFyIGZyb20gdGhlIGV4dHJlbWl0aWVzIG9mIHRoZSBzZWdtZW50LFxuICAgIC8vIHByZXZlbnRpbmcgZm9yIG1vcmUgY29zdGx5IGNvbXB1dGF0aW9uOlxuICAgIHZhciBkUDFDUDEgPSBzaWdtYS51dGlscy5nZXREaXN0YW5jZSh4MSwgeTEsIGNweDEsIGNweTEpO1xuICAgIGlmIChNYXRoLmFicyh4IC0geDEpID4gZFAxQ1AxIHx8IE1hdGguYWJzKHkgLSB5MSkgPiBkUDFDUDEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgZFAxID0gc2lnbWEudXRpbHMuZ2V0RGlzdGFuY2UoeCwgeSwgeDEsIHkxKSxcbiAgICAgICAgZFAyID0gc2lnbWEudXRpbHMuZ2V0RGlzdGFuY2UoeCwgeSwgeDIsIHkyKSxcbiAgICAgICAgdCA9IDAuNSxcbiAgICAgICAgciA9IChkUDEgPCBkUDIpID8gLTAuMDEgOiAwLjAxLFxuICAgICAgICByVGhyZXNob2xkID0gMC4wMDEsXG4gICAgICAgIGkgPSAxMDAsXG4gICAgICAgIHB0ID0gc2lnbWEudXRpbHMuZ2V0UG9pbnRPbkJlemllckN1cnZlKFxuICAgICAgICAgIHQsIHgxLCB5MSwgeDIsIHkyLCBjcHgxLCBjcHkxLCBjcHgyLCBjcHkyKSxcbiAgICAgICAgZHQgPSBzaWdtYS51dGlscy5nZXREaXN0YW5jZSh4LCB5LCBwdC54LCBwdC55KSxcbiAgICAgICAgb2xkX2R0O1xuXG4gICAgLy8gVGhpcyBhbGdvcml0aG0gbWluaW1pemVzIHRoZSBkaXN0YW5jZSBmcm9tIHRoZSBwb2ludCB0byB0aGUgY3VydmUuIEl0XG4gICAgLy8gZmluZCB0aGUgb3B0aW1hbCB0IHZhbHVlIHdoZXJlIHQ9MCBpcyB0aGUgc3RhcnQgcG9pbnQgYW5kIHQ9MSBpcyB0aGUgZW5kXG4gICAgLy8gcG9pbnQgb2YgdGhlIGN1cnZlLCBzdGFydGluZyBmcm9tIHQ9MC41LlxuICAgIC8vIEl0IHRlcm1pbmF0ZXMgYmVjYXVzZSBpdCBydW5zIGEgbWF4aW11bSBvZiBpIGludGVyYXRpb25zLlxuICAgIHdoaWxlIChpLS0gPiAwICYmXG4gICAgICB0ID49IDAgJiYgdCA8PSAxICYmXG4gICAgICAoZHQgPiBlcHNpbG9uKSAmJlxuICAgICAgKHIgPiByVGhyZXNob2xkIHx8IHIgPCAtclRocmVzaG9sZCkpIHtcbiAgICAgIG9sZF9kdCA9IGR0O1xuICAgICAgcHQgPSBzaWdtYS51dGlscy5nZXRQb2ludE9uQmV6aWVyQ3VydmUoXG4gICAgICAgIHQsIHgxLCB5MSwgeDIsIHkyLCBjcHgxLCBjcHkxLCBjcHgyLCBjcHkyKTtcbiAgICAgIGR0ID0gc2lnbWEudXRpbHMuZ2V0RGlzdGFuY2UoeCwgeSwgcHQueCwgcHQueSk7XG5cbiAgICAgIGlmIChkdCA+IG9sZF9kdCkge1xuICAgICAgICAvLyBub3QgdGhlIHJpZ2h0IGRpcmVjdGlvbjpcbiAgICAgICAgLy8gaGFsZnN0ZXAgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvblxuICAgICAgICByID0gLXIgLyAyO1xuICAgICAgICB0ICs9IHI7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0ICsgciA8IDAgfHwgdCArIHIgPiAxKSB7XG4gICAgICAgIC8vIG9vcHMsIHdlJ3ZlIGdvbmUgdG9vIGZhcjpcbiAgICAgICAgLy8gcmV2ZXJ0IHdpdGggYSBoYWxmc3RlcFxuICAgICAgICByID0gciAvIDI7XG4gICAgICAgIGR0ID0gb2xkX2R0O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIHByb2dyZXNzOlxuICAgICAgICB0ICs9IHI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGR0IDwgZXBzaWxvbjtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiAqKioqKioqKioqKipcbiAgICogRVZFTlRTIFVUSUxTOlxuICAgKiAqKioqKioqKioqKipcbiAgICovXG4gIC8qKlxuICAgKiBIZXJlIGFyZSBzb21lIHVzZWZ1bCBmdW5jdGlvbnMgdG8gdW5pZnkgZXh0cmFjdGlvbiBvZiB0aGUgaW5mb3JtYXRpb24gd2VcbiAgICogbmVlZCB3aXRoIG1vdXNlIGV2ZW50cyBhbmQgdG91Y2ggZXZlbnRzLCBmcm9tIGRpZmZlcmVudCBicm93c2VyczpcbiAgICovXG5cbiAgLyoqXG4gICAqIEV4dHJhY3QgdGhlIGxvY2FsIFggcG9zaXRpb24gZnJvbSBhIG1vdXNlIG9yIHRvdWNoIGV2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0gIHtldmVudH0gIGUgQSBtb3VzZSBvciB0b3VjaCBldmVudC5cbiAgICogQHJldHVybiB7bnVtYmVyfSAgIFRoZSBsb2NhbCBYIHZhbHVlIG9mIHRoZSBtb3VzZS5cbiAgICovXG4gIHNpZ21hLnV0aWxzLmdldFggPSBmdW5jdGlvbihlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIChlLm9mZnNldFggIT09IHVuZGVmaW5lZCAmJiBlLm9mZnNldFgpIHx8XG4gICAgICAoZS5sYXllclggIT09IHVuZGVmaW5lZCAmJiBlLmxheWVyWCkgfHxcbiAgICAgIChlLmNsaWVudFggIT09IHVuZGVmaW5lZCAmJiBlLmNsaWVudFgpXG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICogRXh0cmFjdCB0aGUgbG9jYWwgWSBwb3NpdGlvbiBmcm9tIGEgbW91c2Ugb3IgdG91Y2ggZXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSAge2V2ZW50fSAgZSBBIG1vdXNlIG9yIHRvdWNoIGV2ZW50LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9ICAgVGhlIGxvY2FsIFkgdmFsdWUgb2YgdGhlIG1vdXNlLlxuICAgKi9cbiAgc2lnbWEudXRpbHMuZ2V0WSA9IGZ1bmN0aW9uKGUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgKGUub2Zmc2V0WSAhPT0gdW5kZWZpbmVkICYmIGUub2Zmc2V0WSkgfHxcbiAgICAgIChlLmxheWVyWSAhPT0gdW5kZWZpbmVkICYmIGUubGF5ZXJZKSB8fFxuICAgICAgKGUuY2xpZW50WSAhPT0gdW5kZWZpbmVkICYmIGUuY2xpZW50WSlcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGUgcGl4ZWwgcmF0aW8gb2YgdGhlIHNjcmVlbi4gVGFraW5nIHpvb20gaW50byBhY2NvdW50XG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn0gICAgICAgIFBpeGVsIHJhdGlvIG9mIHRoZSBzY3JlZW5cbiAgICovXG4gIHNpZ21hLnV0aWxzLmdldFBpeGVsUmF0aW8gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmF0aW8gPSAxO1xuICAgIGlmICh3aW5kb3cuc2NyZWVuLmRldmljZVhEUEkgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgd2luZG93LnNjcmVlbi5sb2dpY2FsWERQSSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICB3aW5kb3cuc2NyZWVuLmRldmljZVhEUEkgPiB3aW5kb3cuc2NyZWVuLmxvZ2ljYWxYRFBJKSB7XG4gICAgICAgIHJhdGlvID0gd2luZG93LnNjcmVlbi5zeXN0ZW1YRFBJIC8gd2luZG93LnNjcmVlbi5sb2dpY2FsWERQSTtcbiAgICB9XG4gICAgZWxzZSBpZiAod2luZG93LmRldmljZVBpeGVsUmF0aW8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByYXRpbyA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuICAgIH1cbiAgICByZXR1cm4gcmF0aW87XG4gIH07XG5cbiAgLyoqXG4gICAqIEV4dHJhY3QgdGhlIHdpZHRoIGZyb20gYSBtb3VzZSBvciB0b3VjaCBldmVudC5cbiAgICpcbiAgICogQHBhcmFtICB7ZXZlbnR9ICBlIEEgbW91c2Ugb3IgdG91Y2ggZXZlbnQuXG4gICAqIEByZXR1cm4ge251bWJlcn0gICBUaGUgd2lkdGggb2YgdGhlIGV2ZW50J3MgdGFyZ2V0LlxuICAgKi9cbiAgc2lnbWEudXRpbHMuZ2V0V2lkdGggPSBmdW5jdGlvbihlKSB7XG4gICAgdmFyIHcgPSAoIWUudGFyZ2V0Lm93bmVyU1ZHRWxlbWVudCkgP1xuICAgICAgICAgICAgICBlLnRhcmdldC53aWR0aCA6XG4gICAgICAgICAgICAgIGUudGFyZ2V0Lm93bmVyU1ZHRWxlbWVudC53aWR0aDtcblxuICAgIHJldHVybiAoXG4gICAgICAodHlwZW9mIHcgPT09ICdudW1iZXInICYmIHcpIHx8XG4gICAgICAodyAhPT0gdW5kZWZpbmVkICYmIHcuYmFzZVZhbCAhPT0gdW5kZWZpbmVkICYmIHcuYmFzZVZhbC52YWx1ZSlcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFeHRyYWN0IHRoZSBjZW50ZXIgZnJvbSBhIG1vdXNlIG9yIHRvdWNoIGV2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0gIHtldmVudH0gIGUgQSBtb3VzZSBvciB0b3VjaCBldmVudC5cbiAgICogQHJldHVybiB7b2JqZWN0fSAgIFRoZSBjZW50ZXIgb2YgdGhlIGV2ZW50J3MgdGFyZ2V0LlxuICAgKi9cbiAgc2lnbWEudXRpbHMuZ2V0Q2VudGVyID0gZnVuY3Rpb24oZSkge1xuICAgIHZhciByYXRpbyA9IGUudGFyZ2V0Lm5hbWVzcGFjZVVSSS5pbmRleE9mKCdzdmcnKSAhPT0gLTEgPyAxIDpcbiAgICAgICAgc2lnbWEudXRpbHMuZ2V0UGl4ZWxSYXRpbygpO1xuICAgIHJldHVybiB7XG4gICAgICB4OiBzaWdtYS51dGlscy5nZXRXaWR0aChlKSAvICgyICogcmF0aW8pLFxuICAgICAgeTogc2lnbWEudXRpbHMuZ2V0SGVpZ2h0KGUpIC8gKDIgKiByYXRpbylcbiAgICB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0IG1vdXNlIGNvb3JkcyB0byBzaWdtYSBjb29yZHNcbiAgICpcbiAgICogQHBhcmFtICB7ZXZlbnR9ICAgZSBBIG1vdXNlIG9yIHRvdWNoIGV2ZW50LlxuICAgKiBAcGFyYW0gIHtudW1iZXI/fSB4IFRoZSB4IGNvb3JkIHRvIGNvbnZlcnRcbiAgICogQHBhcmFtICB7bnVtYmVyP30geCBUaGUgeSBjb29yZCB0byBjb252ZXJ0XG4gICAqXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgVGhlIHN0YW5kYXJkaXplZCBldmVudFxuICAgKi9cbiAgc2lnbWEudXRpbHMubW91c2VDb29yZHMgPSBmdW5jdGlvbihlLCB4LCB5KSB7XG4gICAgeCA9IHggfHwgc2lnbWEudXRpbHMuZ2V0WChlKTtcbiAgICB5ID0geSB8fCBzaWdtYS51dGlscy5nZXRZKGUpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IHggLSBzaWdtYS51dGlscy5nZXRDZW50ZXIoZSkueCxcbiAgICAgICAgeTogeSAtIHNpZ21hLnV0aWxzLmdldENlbnRlcihlKS55LFxuICAgICAgICBjbGllbnRYOiBlLmNsaWVudFgsXG4gICAgICAgIGNsaWVudFk6IGUuY2xpZW50WSxcbiAgICAgICAgY3RybEtleTogZS5jdHJsS2V5LFxuICAgICAgICBtZXRhS2V5OiBlLm1ldGFLZXksXG4gICAgICAgIGFsdEtleTogZS5hbHRLZXksXG4gICAgICAgIHNoaWZ0S2V5OiBlLnNoaWZ0S2V5XG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICogRXh0cmFjdCB0aGUgaGVpZ2h0IGZyb20gYSBtb3VzZSBvciB0b3VjaCBldmVudC5cbiAgICpcbiAgICogQHBhcmFtICB7ZXZlbnR9ICBlIEEgbW91c2Ugb3IgdG91Y2ggZXZlbnQuXG4gICAqIEByZXR1cm4ge251bWJlcn0gICBUaGUgaGVpZ2h0IG9mIHRoZSBldmVudCdzIHRhcmdldC5cbiAgICovXG4gIHNpZ21hLnV0aWxzLmdldEhlaWdodCA9IGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgaCA9ICghZS50YXJnZXQub3duZXJTVkdFbGVtZW50KSA/XG4gICAgICAgICAgICAgIGUudGFyZ2V0LmhlaWdodCA6XG4gICAgICAgICAgICAgIGUudGFyZ2V0Lm93bmVyU1ZHRWxlbWVudC5oZWlnaHQ7XG5cbiAgICByZXR1cm4gKFxuICAgICAgKHR5cGVvZiBoID09PSAnbnVtYmVyJyAmJiBoKSB8fFxuICAgICAgKGggIT09IHVuZGVmaW5lZCAmJiBoLmJhc2VWYWwgIT09IHVuZGVmaW5lZCAmJiBoLmJhc2VWYWwudmFsdWUpXG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICogRXh0cmFjdCB0aGUgd2hlZWwgZGVsdGEgZnJvbSBhIG1vdXNlIG9yIHRvdWNoIGV2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0gIHtldmVudH0gIGUgQSBtb3VzZSBvciB0b3VjaCBldmVudC5cbiAgICogQHJldHVybiB7bnVtYmVyfSAgIFRoZSB3aGVlbCBkZWx0YSBvZiB0aGUgbW91c2UuXG4gICAqL1xuICBzaWdtYS51dGlscy5nZXREZWx0YSA9IGZ1bmN0aW9uKGUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgKGUud2hlZWxEZWx0YSAhPT0gdW5kZWZpbmVkICYmIGUud2hlZWxEZWx0YSkgfHxcbiAgICAgIChlLmRldGFpbCAhPT0gdW5kZWZpbmVkICYmIC1lLmRldGFpbClcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvZmZzZXQgb2YgYSBET00gZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtICB7RE9NRWxlbWVudH0gZG9tIFRoZSBlbGVtZW50IHRvIHJldHJpZXZlIHRoZSBwb3NpdGlvbi5cbiAgICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgIFRoZSBvZmZzZXQgb2YgdGhlIERPTSBlbGVtZW50ICh0b3AsIGxlZnQpLlxuICAgKi9cbiAgc2lnbWEudXRpbHMuZ2V0T2Zmc2V0ID0gZnVuY3Rpb24oZG9tKSB7XG4gICAgdmFyIGxlZnQgPSAwLFxuICAgICAgICB0b3AgPSAwO1xuXG4gICAgd2hpbGUgKGRvbSkge1xuICAgICAgdG9wID0gdG9wICsgcGFyc2VJbnQoZG9tLm9mZnNldFRvcCk7XG4gICAgICBsZWZ0ID0gbGVmdCArIHBhcnNlSW50KGRvbS5vZmZzZXRMZWZ0KTtcbiAgICAgIGRvbSA9IGRvbS5vZmZzZXRQYXJlbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHRvcDogdG9wLFxuICAgICAgbGVmdDogbGVmdFxuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIFNpbXVsYXRlcyBhIFwiZG91YmxlIGNsaWNrXCIgZXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSB0YXJnZXQgICBUaGUgZXZlbnQgdGFyZ2V0LlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgICAgdHlwZSAgICAgVGhlIGV2ZW50IHR5cGUuXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9ufSAgICBjYWxsYmFjayBUaGUgY2FsbGJhY2sgdG8gZXhlY3V0ZS5cbiAgICovXG4gIHNpZ21hLnV0aWxzLmRvdWJsZUNsaWNrID0gZnVuY3Rpb24odGFyZ2V0LCB0eXBlLCBjYWxsYmFjaykge1xuICAgIHZhciBjbGlja3MgPSAwLFxuICAgICAgICBzZWxmID0gdGhpcyxcbiAgICAgICAgaGFuZGxlcnM7XG5cbiAgICB0YXJnZXQuX2RvdWJsZUNsaWNrSGFuZGxlciA9IHRhcmdldC5fZG91YmxlQ2xpY2tIYW5kbGVyIHx8IHt9O1xuICAgIHRhcmdldC5fZG91YmxlQ2xpY2tIYW5kbGVyW3R5cGVdID0gdGFyZ2V0Ll9kb3VibGVDbGlja0hhbmRsZXJbdHlwZV0gfHwgW107XG4gICAgaGFuZGxlcnMgPSB0YXJnZXQuX2RvdWJsZUNsaWNrSGFuZGxlclt0eXBlXTtcblxuICAgIGhhbmRsZXJzLnB1c2goZnVuY3Rpb24oZSkge1xuICAgICAgY2xpY2tzKys7XG5cbiAgICAgIGlmIChjbGlja3MgPT09IDIpIHtcbiAgICAgICAgY2xpY2tzID0gMDtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGUpO1xuICAgICAgfSBlbHNlIGlmIChjbGlja3MgPT09IDEpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBjbGlja3MgPSAwO1xuICAgICAgICB9LCBzaWdtYS5zZXR0aW5ncy5kb3VibGVDbGlja1RpbWVvdXQpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlcnNbaGFuZGxlcnMubGVuZ3RoIC0gMV0sIGZhbHNlKTtcbiAgfTtcblxuICAvKipcbiAgICogVW5iaW5kIHNpbXVsYXRlZCBcImRvdWJsZSBjbGlja1wiIGV2ZW50cy5cbiAgICpcbiAgICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IHRhcmdldCAgIFRoZSBldmVudCB0YXJnZXQuXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICAgICB0eXBlICAgICBUaGUgZXZlbnQgdHlwZS5cbiAgICovXG4gIHNpZ21hLnV0aWxzLnVuYmluZERvdWJsZUNsaWNrID0gZnVuY3Rpb24odGFyZ2V0LCB0eXBlKSB7XG4gICAgdmFyIGhhbmRsZXIsXG4gICAgICAgIGhhbmRsZXJzID0gKHRhcmdldC5fZG91YmxlQ2xpY2tIYW5kbGVyIHx8IHt9KVt0eXBlXSB8fCBbXTtcblxuICAgIHdoaWxlICgoaGFuZGxlciA9IGhhbmRsZXJzLnBvcCgpKSkge1xuICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlcik7XG4gICAgfVxuXG4gICAgZGVsZXRlICh0YXJnZXQuX2RvdWJsZUNsaWNrSGFuZGxlciB8fCB7fSlbdHlwZV07XG4gIH07XG5cblxuXG5cbiAgLyoqXG4gICAqIEhlcmUgYXJlIGp1c3Qgc29tZSBvZiB0aGUgbW9zdCBiYXNpYyBlYXNpbmcgZnVuY3Rpb25zLCB1c2VkIGZvciB0aGVcbiAgICogYW5pbWF0ZWQgY2FtZXJhIFwiZ29Ub1wiIGNhbGxzLlxuICAgKlxuICAgKiBJZiB5b3UgbmVlZCBzb21lIG1vcmUgZWFzaW5ncyBmdW5jdGlvbnMsIGRvbid0IGhlc2l0YXRlIHRvIGFkZCB0aGVtIHRvXG4gICAqIHNpZ21hLnV0aWxzLmVhc2luZ3MuIEJ1dCBJIHdpbGwgbm90IGFkZCBzb21lIG1vcmUgaGVyZSBvciBtZXJnZSBQUnNcbiAgICogY29udGFpbmluZywgYmVjYXVzZSBJIGRvIG5vdCB3YW50IHNpZ21hIHNvdXJjZXMgZnVsbCBvZiBvdmVya2lsbCBhbmQgbmV2ZXJcbiAgICogdXNlZCBzdHVmZi4uLlxuICAgKi9cbiAgc2lnbWEudXRpbHMuZWFzaW5ncyA9IHNpZ21hLnV0aWxzLmVhc2luZ3MgfHwge307XG4gIHNpZ21hLnV0aWxzLmVhc2luZ3MubGluZWFyTm9uZSA9IGZ1bmN0aW9uKGspIHtcbiAgICByZXR1cm4gaztcbiAgfTtcbiAgc2lnbWEudXRpbHMuZWFzaW5ncy5xdWFkcmF0aWNJbiA9IGZ1bmN0aW9uKGspIHtcbiAgICByZXR1cm4gayAqIGs7XG4gIH07XG4gIHNpZ21hLnV0aWxzLmVhc2luZ3MucXVhZHJhdGljT3V0ID0gZnVuY3Rpb24oaykge1xuICAgIHJldHVybiBrICogKDIgLSBrKTtcbiAgfTtcbiAgc2lnbWEudXRpbHMuZWFzaW5ncy5xdWFkcmF0aWNJbk91dCA9IGZ1bmN0aW9uKGspIHtcbiAgICBpZiAoKGsgKj0gMikgPCAxKVxuICAgICAgcmV0dXJuIDAuNSAqIGsgKiBrO1xuICAgIHJldHVybiAtIDAuNSAqICgtLWsgKiAoayAtIDIpIC0gMSk7XG4gIH07XG4gIHNpZ21hLnV0aWxzLmVhc2luZ3MuY3ViaWNJbiA9IGZ1bmN0aW9uKGspIHtcbiAgICByZXR1cm4gayAqIGsgKiBrO1xuICB9O1xuICBzaWdtYS51dGlscy5lYXNpbmdzLmN1YmljT3V0ID0gZnVuY3Rpb24oaykge1xuICAgIHJldHVybiAtLWsgKiBrICogayArIDE7XG4gIH07XG4gIHNpZ21hLnV0aWxzLmVhc2luZ3MuY3ViaWNJbk91dCA9IGZ1bmN0aW9uKGspIHtcbiAgICBpZiAoKGsgKj0gMikgPCAxKVxuICAgICAgcmV0dXJuIDAuNSAqIGsgKiBrICogaztcbiAgICByZXR1cm4gMC41ICogKChrIC09IDIpICogayAqIGsgKyAyKTtcbiAgfTtcblxuXG5cblxuICAvKipcbiAgICogKioqKioqKioqKioqXG4gICAqIFdFQkdMIFVUSUxTOlxuICAgKiAqKioqKioqKioqKipcbiAgICovXG4gIC8qKlxuICAgKiBMb2FkcyBhIFdlYkdMIHNoYWRlciBhbmQgcmV0dXJucyBpdC5cbiAgICpcbiAgICogQHBhcmFtICB7V2ViR0xDb250ZXh0fSAgICAgICAgICAgZ2wgICAgICAgICAgIFRoZSBXZWJHTENvbnRleHQgdG8gdXNlLlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgICAgICAgICAgICAgICBzaGFkZXJTb3VyY2UgVGhlIHNoYWRlciBzb3VyY2UuXG4gICAqIEBwYXJhbSAge251bWJlcn0gICAgICAgICAgICAgICAgIHNoYWRlclR5cGUgICBUaGUgdHlwZSBvZiBzaGFkZXIuXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9uKHN0cmluZyk6IHZvaWR9IGVycm9yICAgICAgICBDYWxsYmFjayBmb3IgZXJyb3JzLlxuICAgKiBAcmV0dXJuIHtXZWJHTFNoYWRlcn0gICAgICAgICAgICAgICAgICAgICAgICAgVGhlIGNyZWF0ZWQgc2hhZGVyLlxuICAgKi9cbiAgc2lnbWEudXRpbHMubG9hZFNoYWRlciA9IGZ1bmN0aW9uKGdsLCBzaGFkZXJTb3VyY2UsIHNoYWRlclR5cGUsIGVycm9yKSB7XG4gICAgdmFyIGNvbXBpbGVkLFxuICAgICAgICBzaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoc2hhZGVyVHlwZSk7XG5cbiAgICAvLyBMb2FkIHRoZSBzaGFkZXIgc291cmNlXG4gICAgZ2wuc2hhZGVyU291cmNlKHNoYWRlciwgc2hhZGVyU291cmNlKTtcblxuICAgIC8vIENvbXBpbGUgdGhlIHNoYWRlclxuICAgIGdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTtcblxuICAgIC8vIENoZWNrIHRoZSBjb21waWxlIHN0YXR1c1xuICAgIGNvbXBpbGVkID0gZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpO1xuXG4gICAgLy8gSWYgc29tZXRoaW5nIHdlbnQgd3Jvbmc6XG4gICAgaWYgKCFjb21waWxlZCkge1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGVycm9yKFxuICAgICAgICAgICdFcnJvciBjb21waWxpbmcgc2hhZGVyIFwiJyArIHNoYWRlciArICdcIjonICtcbiAgICAgICAgICBnbC5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcilcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgZ2wuZGVsZXRlU2hhZGVyKHNoYWRlcik7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gc2hhZGVyO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgcHJvZ3JhbSwgYXR0YWNoZXMgc2hhZGVycywgYmluZHMgYXR0cmliIGxvY2F0aW9ucywgbGlua3MgdGhlXG4gICAqIHByb2dyYW0gYW5kIGNhbGxzIHVzZVByb2dyYW0uXG4gICAqXG4gICAqIEBwYXJhbSAge0FycmF5LjxXZWJHTFNoYWRlcj59ICAgIHNoYWRlcnMgICBUaGUgc2hhZGVycyB0byBhdHRhY2guXG4gICAqIEBwYXJhbSAge0FycmF5LjxzdHJpbmc+fSAgICAgICAgIGF0dHJpYnMgICBUaGUgYXR0cmlicyBuYW1lcy5cbiAgICogQHBhcmFtICB7QXJyYXkuPG51bWJlcj59ICAgICAgICAgbG9jYXRpb25zIFRoZSBsb2NhdGlvbnMgZm9yIHRoZSBhdHRyaWJzLlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbihzdHJpbmcpOiB2b2lkfSBlcnJvciAgICAgQ2FsbGJhY2sgZm9yIGVycm9ycy5cbiAgICogQHJldHVybiB7V2ViR0xQcm9ncmFtfSAgICAgICAgICAgICAgICAgICAgIFRoZSBjcmVhdGVkIHByb2dyYW0uXG4gICAqL1xuICBzaWdtYS51dGlscy5sb2FkUHJvZ3JhbSA9IGZ1bmN0aW9uKGdsLCBzaGFkZXJzLCBhdHRyaWJzLCBsb2MsIGVycm9yKSB7XG4gICAgdmFyIGksXG4gICAgICAgIGxpbmtlZCxcbiAgICAgICAgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBzaGFkZXJzLmxlbmd0aDsgKytpKVxuICAgICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHNoYWRlcnNbaV0pO1xuXG4gICAgaWYgKGF0dHJpYnMpXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgYXR0cmlicy5sZW5ndGg7ICsraSlcbiAgICAgICAgZ2wuYmluZEF0dHJpYkxvY2F0aW9uKFxuICAgICAgICAgIHByb2dyYW0sXG4gICAgICAgICAgbG9jYXRpb25zID8gbG9jYXRpb25zW2ldIDogaSxcbiAgICAgICAgICBvcHRfYXR0cmlic1tpXVxuICAgICAgICApO1xuXG4gICAgZ2wubGlua1Byb2dyYW0ocHJvZ3JhbSk7XG5cbiAgICAvLyBDaGVjayB0aGUgbGluayBzdGF0dXNcbiAgICBsaW5rZWQgPSBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGdsLkxJTktfU1RBVFVTKTtcbiAgICBpZiAoIWxpbmtlZCkge1xuICAgICAgaWYgKGVycm9yKVxuICAgICAgICBlcnJvcignRXJyb3IgaW4gcHJvZ3JhbSBsaW5raW5nOiAnICsgZ2wuZ2V0UHJvZ3JhbUluZm9Mb2cocHJvZ3JhbSkpO1xuXG4gICAgICBnbC5kZWxldGVQcm9ncmFtKHByb2dyYW0pO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb2dyYW07XG4gIH07XG5cblxuXG5cbiAgLyoqXG4gICAqICoqKioqKioqKlxuICAgKiBNQVRSSUNFUzpcbiAgICogKioqKioqKioqXG4gICAqIFRoZSBmb2xsb3dpbmcgdXRpbHMgYXJlIGp1c3QgaGVyZSB0byBoZWxwIGdlbmVyYXRpbmcgdGhlIHRyYW5zZm9ybWF0aW9uXG4gICAqIG1hdHJpY2VzIGZvciB0aGUgV2ViR0wgcmVuZGVyZXJzLlxuICAgKi9cbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS51dGlscy5tYXRyaWNlcycpO1xuXG4gIC8qKlxuICAgKiBUaGUgcmV0dXJucyBhIDN4MyB0cmFuc2xhdGlvbiBtYXRyaXguXG4gICAqXG4gICAqIEBwYXJhbSAge251bWJlcn0gZHggVGhlIFggdHJhbnNsYXRpb24uXG4gICAqIEBwYXJhbSAge251bWJlcn0gZHkgVGhlIFkgdHJhbnNsYXRpb24uXG4gICAqIEByZXR1cm4ge2FycmF5fSAgICAgUmV0dXJucyB0aGUgbWF0cml4LlxuICAgKi9cbiAgc2lnbWEudXRpbHMubWF0cmljZXMudHJhbnNsYXRpb24gPSBmdW5jdGlvbihkeCwgZHkpIHtcbiAgICByZXR1cm4gW1xuICAgICAgMSwgMCwgMCxcbiAgICAgIDAsIDEsIDAsXG4gICAgICBkeCwgZHksIDFcbiAgICBdO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGUgcmV0dXJucyBhIDN4MyBvciAyeDIgcm90YXRpb24gbWF0cml4LlxuICAgKlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9ICBhbmdsZSBUaGUgcm90YXRpb24gYW5nbGUuXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59IG0yICAgIElmIHRydWUsIHRoZSBmdW5jdGlvbiB3aWxsIHJldHVybiBhIDJ4MiBtYXRyaXguXG4gICAqIEByZXR1cm4ge2FycmF5fSAgICAgICAgIFJldHVybnMgdGhlIG1hdHJpeC5cbiAgICovXG4gIHNpZ21hLnV0aWxzLm1hdHJpY2VzLnJvdGF0aW9uID0gZnVuY3Rpb24oYW5nbGUsIG0yKSB7XG4gICAgdmFyIGNvcyA9IE1hdGguY29zKGFuZ2xlKSxcbiAgICAgICAgc2luID0gTWF0aC5zaW4oYW5nbGUpO1xuXG4gICAgcmV0dXJuIG0yID8gW1xuICAgICAgY29zLCAtc2luLFxuICAgICAgc2luLCBjb3NcbiAgICBdIDogW1xuICAgICAgY29zLCAtc2luLCAwLFxuICAgICAgc2luLCBjb3MsIDAsXG4gICAgICAwLCAwLCAxXG4gICAgXTtcbiAgfTtcblxuICAvKipcbiAgICogVGhlIHJldHVybnMgYSAzeDMgb3IgMngyIGhvbW90aGV0aWMgdHJhbnNmb3JtYXRpb24gbWF0cml4LlxuICAgKlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9ICByYXRpbyBUaGUgc2NhbGluZyByYXRpby5cbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gbTIgICAgSWYgdHJ1ZSwgdGhlIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIGEgMngyIG1hdHJpeC5cbiAgICogQHJldHVybiB7YXJyYXl9ICAgICAgICAgUmV0dXJucyB0aGUgbWF0cml4LlxuICAgKi9cbiAgc2lnbWEudXRpbHMubWF0cmljZXMuc2NhbGUgPSBmdW5jdGlvbihyYXRpbywgbTIpIHtcbiAgICByZXR1cm4gbTIgPyBbXG4gICAgICByYXRpbywgMCxcbiAgICAgIDAsIHJhdGlvXG4gICAgXSA6IFtcbiAgICAgIHJhdGlvLCAwLCAwLFxuICAgICAgMCwgcmF0aW8sIDAsXG4gICAgICAwLCAwLCAxXG4gICAgXTtcbiAgfTtcblxuICAvKipcbiAgICogVGhlIHJldHVybnMgYSAzeDMgb3IgMngyIGhvbW90aGV0aWMgdHJhbnNmb3JtYXRpb24gbWF0cml4LlxuICAgKlxuICAgKiBAcGFyYW0gIHthcnJheX0gICBhICBUaGUgZmlyc3QgbWF0cml4LlxuICAgKiBAcGFyYW0gIHthcnJheX0gICBiICBUaGUgc2Vjb25kIG1hdHJpeC5cbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gbTIgSWYgdHJ1ZSwgdGhlIGZ1bmN0aW9uIHdpbGwgYXNzdW1lIGJvdGggbWF0cmljZXMgYXJlXG4gICAqICAgICAgICAgICAgICAgICAgICAgIDJ4Mi5cbiAgICogQHJldHVybiB7YXJyYXl9ICAgICAgUmV0dXJucyB0aGUgbWF0cml4LlxuICAgKi9cbiAgc2lnbWEudXRpbHMubWF0cmljZXMubXVsdGlwbHkgPSBmdW5jdGlvbihhLCBiLCBtMikge1xuICAgIHZhciBsID0gbTIgPyAyIDogMyxcbiAgICAgICAgYTAwID0gYVswICogbCArIDBdLFxuICAgICAgICBhMDEgPSBhWzAgKiBsICsgMV0sXG4gICAgICAgIGEwMiA9IGFbMCAqIGwgKyAyXSxcbiAgICAgICAgYTEwID0gYVsxICogbCArIDBdLFxuICAgICAgICBhMTEgPSBhWzEgKiBsICsgMV0sXG4gICAgICAgIGExMiA9IGFbMSAqIGwgKyAyXSxcbiAgICAgICAgYTIwID0gYVsyICogbCArIDBdLFxuICAgICAgICBhMjEgPSBhWzIgKiBsICsgMV0sXG4gICAgICAgIGEyMiA9IGFbMiAqIGwgKyAyXSxcbiAgICAgICAgYjAwID0gYlswICogbCArIDBdLFxuICAgICAgICBiMDEgPSBiWzAgKiBsICsgMV0sXG4gICAgICAgIGIwMiA9IGJbMCAqIGwgKyAyXSxcbiAgICAgICAgYjEwID0gYlsxICogbCArIDBdLFxuICAgICAgICBiMTEgPSBiWzEgKiBsICsgMV0sXG4gICAgICAgIGIxMiA9IGJbMSAqIGwgKyAyXSxcbiAgICAgICAgYjIwID0gYlsyICogbCArIDBdLFxuICAgICAgICBiMjEgPSBiWzIgKiBsICsgMV0sXG4gICAgICAgIGIyMiA9IGJbMiAqIGwgKyAyXTtcblxuICAgIHJldHVybiBtMiA/IFtcbiAgICAgIGEwMCAqIGIwMCArIGEwMSAqIGIxMCxcbiAgICAgIGEwMCAqIGIwMSArIGEwMSAqIGIxMSxcbiAgICAgIGExMCAqIGIwMCArIGExMSAqIGIxMCxcbiAgICAgIGExMCAqIGIwMSArIGExMSAqIGIxMVxuICAgIF0gOiBbXG4gICAgICBhMDAgKiBiMDAgKyBhMDEgKiBiMTAgKyBhMDIgKiBiMjAsXG4gICAgICBhMDAgKiBiMDEgKyBhMDEgKiBiMTEgKyBhMDIgKiBiMjEsXG4gICAgICBhMDAgKiBiMDIgKyBhMDEgKiBiMTIgKyBhMDIgKiBiMjIsXG4gICAgICBhMTAgKiBiMDAgKyBhMTEgKiBiMTAgKyBhMTIgKiBiMjAsXG4gICAgICBhMTAgKiBiMDEgKyBhMTEgKiBiMTEgKyBhMTIgKiBiMjEsXG4gICAgICBhMTAgKiBiMDIgKyBhMTEgKiBiMTIgKyBhMTIgKiBiMjIsXG4gICAgICBhMjAgKiBiMDAgKyBhMjEgKiBiMTAgKyBhMjIgKiBiMjAsXG4gICAgICBhMjAgKiBiMDEgKyBhMjEgKiBiMTEgKyBhMjIgKiBiMjEsXG4gICAgICBhMjAgKiBiMDIgKyBhMjEgKiBiMTIgKyBhMjIgKiBiMjJcbiAgICBdO1xuICB9O1xufSkuY2FsbCh0aGlzKTtcblxuOyhmdW5jdGlvbihnbG9iYWwpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qKlxuICAgKiBodHRwOi8vcGF1bGlyaXNoLmNvbS8yMDExL3JlcXVlc3RhbmltYXRpb25mcmFtZS1mb3Itc21hcnQtYW5pbWF0aW5nL1xuICAgKiBodHRwOi8vbXkub3BlcmEuY29tL2Vtb2xsZXIvYmxvZy8yMDExLzEyLzIwL3JlcXVlc3RhbmltYXRpb25mcmFtZS1mb3Itc21hcnQtZXItYW5pbWF0aW5nXG4gICAqIHJlcXVlc3RBbmltYXRpb25GcmFtZSBwb2x5ZmlsbCBieSBFcmlrIE3DtmxsZXIuXG4gICAqIGZpeGVzIGZyb20gUGF1bCBJcmlzaCBhbmQgVGlubyBaaWpkZWxcbiAgICogTUlUIGxpY2Vuc2VcbiAgICovXG4gIHZhciB4LFxuICAgICAgbGFzdFRpbWUgPSAwLFxuICAgICAgdmVuZG9ycyA9IFsnbXMnLCAnbW96JywgJ3dlYmtpdCcsICdvJ107XG5cbiAgZm9yICh4ID0gMDsgeCA8IHZlbmRvcnMubGVuZ3RoICYmICFnbG9iYWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lOyB4KyspIHtcbiAgICBnbG9iYWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lID1cbiAgICAgIGdsb2JhbFt2ZW5kb3JzW3hdICsgJ1JlcXVlc3RBbmltYXRpb25GcmFtZSddO1xuICAgIGdsb2JhbC5jYW5jZWxBbmltYXRpb25GcmFtZSA9XG4gICAgICBnbG9iYWxbdmVuZG9yc1t4XSArICdDYW5jZWxBbmltYXRpb25GcmFtZSddIHx8XG4gICAgICBnbG9iYWxbdmVuZG9yc1t4XSArICdDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnXTtcbiAgfVxuXG4gIGlmICghZ2xvYmFsLnJlcXVlc3RBbmltYXRpb25GcmFtZSlcbiAgICBnbG9iYWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24oY2FsbGJhY2ssIGVsZW1lbnQpIHtcbiAgICAgIHZhciBjdXJyVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpLFxuICAgICAgICAgIHRpbWVUb0NhbGwgPSBNYXRoLm1heCgwLCAxNiAtIChjdXJyVGltZSAtIGxhc3RUaW1lKSksXG4gICAgICAgICAgaWQgPSBnbG9iYWwuc2V0VGltZW91dChcbiAgICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBjYWxsYmFjayhjdXJyVGltZSArIHRpbWVUb0NhbGwpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRpbWVUb0NhbGxcbiAgICAgICAgICApO1xuXG4gICAgICBsYXN0VGltZSA9IGN1cnJUaW1lICsgdGltZVRvQ2FsbDtcbiAgICAgIHJldHVybiBpZDtcbiAgICB9O1xuXG4gIGlmICghZ2xvYmFsLmNhbmNlbEFuaW1hdGlvbkZyYW1lKVxuICAgIGdsb2JhbC5jYW5jZWxBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgICBjbGVhclRpbWVvdXQoaWQpO1xuICAgIH07XG5cbiAgLyoqXG4gICAqIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIHBvbHlmaWxsIGZvdW5kIG9uIE1ETi5cbiAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRnVuY3Rpb24vYmluZCNDb21wYXRpYmlsaXR5XG4gICAqIFB1YmxpYyBkb21haW5cbiAgICovXG4gIGlmICghRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQpXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbihvVGhpcykge1xuICAgICAgaWYgKHR5cGVvZiB0aGlzICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAvLyBDbG9zZXN0IHRoaW5nIHBvc3NpYmxlIHRvIHRoZSBFQ01BU2NyaXB0IDUgaW50ZXJuYWwgSXNDYWxsYWJsZVxuICAgICAgICAvLyBmdW5jdGlvbjpcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAnRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgLSB3aGF0IGlzIHRyeWluZyB0byBiZSBib3VuZCBpcyBub3QgY2FsbGFibGUnXG4gICAgICAgICk7XG5cbiAgICAgIHZhciBhQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSksXG4gICAgICAgICAgZlRvQmluZCA9IHRoaXMsXG4gICAgICAgICAgZk5PUCxcbiAgICAgICAgICBmQm91bmQ7XG5cbiAgICAgIGZOT1AgPSBmdW5jdGlvbigpIHt9O1xuICAgICAgZkJvdW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBmVG9CaW5kLmFwcGx5KFxuICAgICAgICAgIHRoaXMgaW5zdGFuY2VvZiBmTk9QICYmIG9UaGlzID9cbiAgICAgICAgICAgIHRoaXMgOlxuICAgICAgICAgICAgb1RoaXMsXG4gICAgICAgICAgYUFyZ3MuY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpXG4gICAgICAgICk7XG4gICAgICB9O1xuXG4gICAgICBmTk9QLnByb3RvdHlwZSA9IHRoaXMucHJvdG90eXBlO1xuICAgICAgZkJvdW5kLnByb3RvdHlwZSA9IG5ldyBmTk9QKCk7XG5cbiAgICAgIHJldHVybiBmQm91bmQ7XG4gICAgfTtcbn0pKHRoaXMpO1xuXG47KGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgaWYgKHR5cGVvZiBzaWdtYSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgdGhyb3cgJ3NpZ21hIGlzIG5vdCBkZWNsYXJlZCc7XG5cbiAgLy8gUGFja2FnZXMgaW5pdGlhbGl6YXRpb246XG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuc2V0dGluZ3MnKTtcblxuICB2YXIgc2V0dGluZ3MgPSB7XG4gICAgLyoqXG4gICAgICogR1JBUEggU0VUVElOR1M6XG4gICAgICogKioqKioqKioqKioqKioqXG4gICAgICovXG4gICAgLy8ge2Jvb2xlYW59IEluZGljYXRlcyBpZiB0aGUgZGF0YSBoYXZlIHRvIGJlIGNsb25lZCBpbiBtZXRob2RzIHRvIGFkZFxuICAgIC8vICAgICAgICAgICBub2RlcyBvciBlZGdlcy5cbiAgICBjbG9uZTogdHJ1ZSxcbiAgICAvLyB7Ym9vbGVhbn0gSW5kaWNhdGVzIGlmIG5vZGVzIFwiaWRcIiB2YWx1ZXMgYW5kIGVkZ2VzIFwiaWRcIiwgXCJzb3VyY2VcIiBhbmRcbiAgICAvLyAgICAgICAgICAgXCJ0YXJnZXRcIiB2YWx1ZXMgbXVzdCBiZSBzZXQgYXMgaW1tdXRhYmxlLlxuICAgIGltbXV0YWJsZTogdHJ1ZSxcbiAgICAvLyB7Ym9vbGVhbn0gSW5kaWNhdGVzIGlmIHNpZ21hIGNhbiBsb2cgaXRzIGVycm9ycyBhbmQgd2FybmluZ3MuXG4gICAgdmVyYm9zZTogZmFsc2UsXG5cblxuICAgIC8qKlxuICAgICAqIFJFTkRFUkVSUyBTRVRUSU5HUzpcbiAgICAgKiAqKioqKioqKioqKioqKioqKioqXG4gICAgICovXG4gICAgLy8ge3N0cmluZ31cbiAgICBjbGFzc1ByZWZpeDogJ3NpZ21hJyxcbiAgICAvLyB7c3RyaW5nfVxuICAgIGRlZmF1bHROb2RlVHlwZTogJ2RlZicsXG4gICAgLy8ge3N0cmluZ31cbiAgICBkZWZhdWx0RWRnZVR5cGU6ICdkZWYnLFxuICAgIC8vIHtzdHJpbmd9XG4gICAgZGVmYXVsdExhYmVsQ29sb3I6ICcjMDAwJyxcbiAgICAvLyB7c3RyaW5nfVxuICAgIGRlZmF1bHRFZGdlQ29sb3I6ICcjMDAwJyxcbiAgICAvLyB7c3RyaW5nfVxuICAgIGRlZmF1bHROb2RlQ29sb3I6ICcjMDAwJyxcbiAgICAvLyB7c3RyaW5nfVxuICAgIGRlZmF1bHRMYWJlbFNpemU6IDE0LFxuICAgIC8vIHtzdHJpbmd9IEluZGljYXRlcyBob3cgdG8gY2hvb3NlIHRoZSBlZGdlcyBjb2xvci4gQXZhaWxhYmxlIHZhbHVlczpcbiAgICAvLyAgICAgICAgICBcInNvdXJjZVwiLCBcInRhcmdldFwiLCBcImRlZmF1bHRcIlxuICAgIGVkZ2VDb2xvcjogJ3NvdXJjZScsXG4gICAgLy8ge251bWJlcn0gRGVmaW5lcyB0aGUgbWluaW1hbCBlZGdlJ3MgYXJyb3cgZGlzcGxheSBzaXplLlxuICAgIG1pbkFycm93U2l6ZTogMCxcbiAgICAvLyB7c3RyaW5nfVxuICAgIGZvbnQ6ICdhcmlhbCcsXG4gICAgLy8ge3N0cmluZ30gRXhhbXBsZTogJ2JvbGQnXG4gICAgZm9udFN0eWxlOiAnJyxcbiAgICAvLyB7c3RyaW5nfSBJbmRpY2F0ZXMgaG93IHRvIGNob29zZSB0aGUgbGFiZWxzIGNvbG9yLiBBdmFpbGFibGUgdmFsdWVzOlxuICAgIC8vICAgICAgICAgIFwibm9kZVwiLCBcImRlZmF1bHRcIlxuICAgIGxhYmVsQ29sb3I6ICdkZWZhdWx0JyxcbiAgICAvLyB7c3RyaW5nfSBJbmRpY2F0ZXMgaG93IHRvIGNob29zZSB0aGUgbGFiZWxzIHNpemUuIEF2YWlsYWJsZSB2YWx1ZXM6XG4gICAgLy8gICAgICAgICAgXCJmaXhlZFwiLCBcInByb3BvcnRpb25hbFwiXG4gICAgbGFiZWxTaXplOiAnZml4ZWQnLFxuICAgIC8vIHtzdHJpbmd9IFRoZSByYXRpbyBiZXR3ZWVuIHRoZSBmb250IHNpemUgb2YgdGhlIGxhYmVsIGFuZCB0aGUgbm9kZSBzaXplLlxuICAgIGxhYmVsU2l6ZVJhdGlvOiAxLFxuICAgIC8vIHtudW1iZXJ9IFRoZSBtaW5pbXVtIHNpemUgYSBub2RlIG11c3QgaGF2ZSB0byBzZWUgaXRzIGxhYmVsIGRpc3BsYXllZC5cbiAgICBsYWJlbFRocmVzaG9sZDogOCxcbiAgICAvLyB7bnVtYmVyfSBUaGUgb3ZlcnNhbXBsaW5nIGZhY3RvciB1c2VkIGluIFdlYkdMIHJlbmRlcmVyLlxuICAgIHdlYmdsT3ZlcnNhbXBsaW5nUmF0aW86IDIsXG4gICAgLy8ge251bWJlcn0gVGhlIHNpemUgb2YgdGhlIGJvcmRlciBvZiBob3ZlcmVkIG5vZGVzLlxuICAgIGJvcmRlclNpemU6IDAsXG4gICAgLy8ge251bWJlcn0gVGhlIGRlZmF1bHQgaG92ZXJlZCBub2RlIGJvcmRlcidzIGNvbG9yLlxuICAgIGRlZmF1bHROb2RlQm9yZGVyQ29sb3I6ICcjMDAwJyxcbiAgICAvLyB7bnVtYmVyfSBUaGUgaG92ZXJlZCBub2RlJ3MgbGFiZWwgZm9udC4gSWYgbm90IHNwZWNpZmllZCwgd2lsbCBoZXJpdGF0ZVxuICAgIC8vICAgICAgICAgIHRoZSBcImZvbnRcIiB2YWx1ZS5cbiAgICBob3ZlckZvbnQ6ICcnLFxuICAgIC8vIHtib29sZWFufSBJZiB0cnVlLCB0aGVuIG9ubHkgb25lIG5vZGUgY2FuIGJlIGhvdmVyZWQgYXQgYSB0aW1lLlxuICAgIHNpbmdsZUhvdmVyOiB0cnVlLFxuICAgIC8vIHtzdHJpbmd9IEV4YW1wbGU6ICdib2xkJ1xuICAgIGhvdmVyRm9udFN0eWxlOiAnJyxcbiAgICAvLyB7c3RyaW5nfSBJbmRpY2F0ZXMgaG93IHRvIGNob29zZSB0aGUgaG92ZXJlZCBub2RlcyBzaGFkb3cgY29sb3IuXG4gICAgLy8gICAgICAgICAgQXZhaWxhYmxlIHZhbHVlczogXCJub2RlXCIsIFwiZGVmYXVsdFwiXG4gICAgbGFiZWxIb3ZlclNoYWRvdzogJ2RlZmF1bHQnLFxuICAgIC8vIHtzdHJpbmd9XG4gICAgbGFiZWxIb3ZlclNoYWRvd0NvbG9yOiAnIzAwMCcsXG4gICAgLy8ge3N0cmluZ30gSW5kaWNhdGVzIGhvdyB0byBjaG9vc2UgdGhlIGhvdmVyZWQgbm9kZXMgY29sb3IuXG4gICAgLy8gICAgICAgICAgQXZhaWxhYmxlIHZhbHVlczogXCJub2RlXCIsIFwiZGVmYXVsdFwiXG4gICAgbm9kZUhvdmVyQ29sb3I6ICdub2RlJyxcbiAgICAvLyB7c3RyaW5nfVxuICAgIGRlZmF1bHROb2RlSG92ZXJDb2xvcjogJyMwMDAnLFxuICAgIC8vIHtzdHJpbmd9IEluZGljYXRlcyBob3cgdG8gY2hvb3NlIHRoZSBob3ZlcmVkIG5vZGVzIGJhY2tncm91bmQgY29sb3IuXG4gICAgLy8gICAgICAgICAgQXZhaWxhYmxlIHZhbHVlczogXCJub2RlXCIsIFwiZGVmYXVsdFwiXG4gICAgbGFiZWxIb3ZlckJHQ29sb3I6ICdkZWZhdWx0JyxcbiAgICAvLyB7c3RyaW5nfVxuICAgIGRlZmF1bHRIb3ZlckxhYmVsQkdDb2xvcjogJyNmZmYnLFxuICAgIC8vIHtzdHJpbmd9IEluZGljYXRlcyBob3cgdG8gY2hvb3NlIHRoZSBob3ZlcmVkIGxhYmVscyBjb2xvci5cbiAgICAvLyAgICAgICAgICBBdmFpbGFibGUgdmFsdWVzOiBcIm5vZGVcIiwgXCJkZWZhdWx0XCJcbiAgICBsYWJlbEhvdmVyQ29sb3I6ICdkZWZhdWx0JyxcbiAgICAvLyB7c3RyaW5nfVxuICAgIGRlZmF1bHRMYWJlbEhvdmVyQ29sb3I6ICcjMDAwJyxcbiAgICAvLyB7c3RyaW5nfSBJbmRpY2F0ZXMgaG93IHRvIGNob29zZSB0aGUgZWRnZXMgaG92ZXIgY29sb3IuIEF2YWlsYWJsZSB2YWx1ZXM6XG4gICAgLy8gICAgICAgICAgXCJlZGdlXCIsIFwiZGVmYXVsdFwiXG4gICAgZWRnZUhvdmVyQ29sb3I6ICdlZGdlJyxcbiAgICAvLyB7bnVtYmVyfSBUaGUgc2l6ZSBtdWx0aXBsaWNhdG9yIG9mIGhvdmVyZWQgZWRnZXMuXG4gICAgZWRnZUhvdmVyU2l6ZVJhdGlvOiAxLFxuICAgIC8vIHtzdHJpbmd9XG4gICAgZGVmYXVsdEVkZ2VIb3ZlckNvbG9yOiAnIzAwMCcsXG4gICAgLy8ge2Jvb2xlYW59IEluZGljYXRlcyBpZiB0aGUgZWRnZSBleHRyZW1pdGllcyBtdXN0IGJlIGhvdmVyZWQgd2hlbiB0aGVcbiAgICAvLyAgICAgICAgICAgZWRnZSBpcyBob3ZlcmVkLlxuICAgIGVkZ2VIb3ZlckV4dHJlbWl0aWVzOiBmYWxzZSxcbiAgICAvLyB7Ym9vbGVhbnN9IFRoZSBkaWZmZXJlbnQgZHJhd2luZyBtb2RlczpcbiAgICAvLyAgICAgICAgICAgZmFsc2U6IExheWVyZWQgbm90IGRpc3BsYXllZC5cbiAgICAvLyAgICAgICAgICAgdHJ1ZTogTGF5ZXJlZCBkaXNwbGF5ZWQuXG4gICAgZHJhd0VkZ2VzOiB0cnVlLFxuICAgIGRyYXdOb2RlczogdHJ1ZSxcbiAgICBkcmF3TGFiZWxzOiB0cnVlLFxuICAgIGRyYXdFZGdlTGFiZWxzOiBmYWxzZSxcbiAgICAvLyB7Ym9vbGVhbn0gSW5kaWNhdGVzIGlmIHRoZSBlZGdlcyBtdXN0IGJlIGRyYXduIGluIHNldmVyYWwgZnJhbWVzIG9yIGluXG4gICAgLy8gICAgICAgICAgIG9uZSBmcmFtZSwgYXMgdGhlIG5vZGVzIGFuZCBsYWJlbHMgYXJlIGRyYXduLlxuICAgIGJhdGNoRWRnZXNEcmF3aW5nOiBmYWxzZSxcbiAgICAvLyB7Ym9vbGVhbn0gSW5kaWNhdGVzIGlmIHRoZSBlZGdlcyBtdXN0IGJlIGhpZGRlbiBkdXJpbmcgZHJhZ2dpbmcgYW5kXG4gICAgLy8gICAgICAgICAgIGFuaW1hdGlvbnMuXG4gICAgaGlkZUVkZ2VzT25Nb3ZlOiBmYWxzZSxcbiAgICAvLyB7bnVtYmVyc30gVGhlIGRpZmZlcmVudCBiYXRjaCBzaXplcywgd2hlbiBlbGVtZW50cyBhcmUgZGlzcGxheWVkIGluXG4gICAgLy8gICAgICAgICAgIHNldmVyYWwgZnJhbWVzLlxuICAgIGNhbnZhc0VkZ2VzQmF0Y2hTaXplOiA1MDAsXG4gICAgd2ViZ2xFZGdlc0JhdGNoU2l6ZTogMTAwMCxcblxuXG5cblxuICAgIC8qKlxuICAgICAqIFJFU0NBTEUgU0VUVElOR1M6XG4gICAgICogKioqKioqKioqKioqKioqKipcbiAgICAgKi9cbiAgICAvLyB7c3RyaW5nfSBJbmRpY2F0ZXMgb2YgdG8gc2NhbGUgdGhlIGdyYXBoIHJlbGF0aXZlbHkgdG8gaXRzIGNvbnRhaW5lci5cbiAgICAvLyAgICAgICAgICBBdmFpbGFibGUgdmFsdWVzOiBcImluc2lkZVwiLCBcIm91dHNpZGVcIlxuICAgIHNjYWxpbmdNb2RlOiAnaW5zaWRlJyxcbiAgICAvLyB7bnVtYmVyfSBUaGUgbWFyZ2luIHRvIGtlZXAgYXJvdW5kIHRoZSBncmFwaC5cbiAgICBzaWRlTWFyZ2luOiAwLFxuICAgIC8vIHtudW1iZXJ9IERldGVybWluZSB0aGUgc2l6ZSBvZiB0aGUgc21hbGxlc3QgYW5kIHRoZSBiaWdnZXN0IG5vZGUgLyBlZGdlc1xuICAgIC8vICAgICAgICAgIG9uIHRoZSBzY3JlZW4uIFRoaXMgbWFwcGluZyBtYWtlcyBlYXNpZXIgdG8gZGlzcGxheSB0aGUgZ3JhcGgsXG4gICAgLy8gICAgICAgICAgYXZvaWRpbmcgdG9vIGJpZyBub2RlcyB0aGF0IHRha2UgaGFsZiBvZiB0aGUgc2NyZWVuLCBvciB0b29cbiAgICAvLyAgICAgICAgICBzbWFsbCBvbmVzIHRoYXQgYXJlIG5vdCByZWFkYWJsZS4gSWYgdGhlIHR3byBwYXJhbWV0ZXJzIGFyZVxuICAgIC8vICAgICAgICAgIGVxdWFscywgdGhlbiB0aGUgbWluaW1hbCBkaXNwbGF5IHNpemUgd2lsbCBiZSAwLiBBbmQgaWYgdGhleVxuICAgIC8vICAgICAgICAgIGFyZSBib3RoIGVxdWFsIHRvIDAsIHRoZW4gdGhlcmUgaXMgbm8gbWFwcGluZywgYW5kIHRoZSByYWRpdXNcbiAgICAvLyAgICAgICAgICBvZiB0aGUgbm9kZXMgd2lsbCBiZSB0aGVpciBzaXplLlxuICAgIG1pbkVkZ2VTaXplOiAwLjUsXG4gICAgbWF4RWRnZVNpemU6IDEsXG4gICAgbWluTm9kZVNpemU6IDEsXG4gICAgbWF4Tm9kZVNpemU6IDgsXG5cblxuXG5cbiAgICAvKipcbiAgICAgKiBDQVBUT1JTIFNFVFRJTkdTOlxuICAgICAqICoqKioqKioqKioqKioqKioqXG4gICAgICovXG4gICAgLy8ge2Jvb2xlYW59XG4gICAgdG91Y2hFbmFibGVkOiB0cnVlLFxuICAgIC8vIHtib29sZWFufVxuICAgIG1vdXNlRW5hYmxlZDogdHJ1ZSxcbiAgICAvLyB7Ym9vbGVhbn1cbiAgICBtb3VzZVdoZWVsRW5hYmxlZDogdHJ1ZSxcbiAgICAvLyB7Ym9vbGVhbn1cbiAgICBkb3VibGVDbGlja0VuYWJsZWQ6IHRydWUsXG4gICAgLy8ge2Jvb2xlYW59IERlZmluZXMgd2hldGhlciB0aGUgY3VzdG9tIGV2ZW50cyBzdWNoIGFzIFwiY2xpY2tOb2RlXCIgY2FuIGJlXG4gICAgLy8gICAgICAgICAgIHVzZWQuXG4gICAgZXZlbnRzRW5hYmxlZDogdHJ1ZSxcbiAgICAvLyB7bnVtYmVyfSBEZWZpbmVzIGJ5IGhvdyBtdWNoIG11bHRpcGxpY2F0aW5nIHRoZSB6b29taW5nIGxldmVsIHdoZW4gdGhlXG4gICAgLy8gICAgICAgICAgdXNlciB6b29tcyB3aXRoIHRoZSBtb3VzZS13aGVlbC5cbiAgICB6b29taW5nUmF0aW86IDEuNyxcbiAgICAvLyB7bnVtYmVyfSBEZWZpbmVzIGJ5IGhvdyBtdWNoIG11bHRpcGxpY2F0aW5nIHRoZSB6b29taW5nIGxldmVsIHdoZW4gdGhlXG4gICAgLy8gICAgICAgICAgdXNlciB6b29tcyBieSBkb3VibGUgY2xpY2tpbmcuXG4gICAgZG91YmxlQ2xpY2tab29taW5nUmF0aW86IDIuMixcbiAgICAvLyB7bnVtYmVyfSBUaGUgbWluaW11bSB6b29taW5nIGxldmVsLlxuICAgIHpvb21NaW46IDAuMDYyNSxcbiAgICAvLyB7bnVtYmVyfSBUaGUgbWF4aW11bSB6b29taW5nIGxldmVsLlxuICAgIHpvb21NYXg6IDIsXG4gICAgLy8ge251bWJlcn0gVGhlIGR1cmF0aW9uIG9mIGFuaW1hdGlvbnMgZm9sbG93aW5nIGEgbW91c2Ugc2Nyb2xsaW5nLlxuICAgIG1vdXNlWm9vbUR1cmF0aW9uOiAyMDAsXG4gICAgLy8ge251bWJlcn0gVGhlIGR1cmF0aW9uIG9mIGFuaW1hdGlvbnMgZm9sbG93aW5nIGEgbW91c2UgZG91YmxlIGNsaWNrLlxuICAgIGRvdWJsZUNsaWNrWm9vbUR1cmF0aW9uOiAyMDAsXG4gICAgLy8ge251bWJlcn0gVGhlIGR1cmF0aW9uIG9mIGFuaW1hdGlvbnMgZm9sbG93aW5nIGEgbW91c2UgZHJvcHBpbmcuXG4gICAgbW91c2VJbmVydGlhRHVyYXRpb246IDIwMCxcbiAgICAvLyB7bnVtYmVyfSBUaGUgaW5lcnRpYSBwb3dlciAobW91c2UgY2FwdG9yKS5cbiAgICBtb3VzZUluZXJ0aWFSYXRpbzogMyxcbiAgICAvLyB7bnVtYmVyfSBUaGUgZHVyYXRpb24gb2YgYW5pbWF0aW9ucyBmb2xsb3dpbmcgYSB0b3VjaCBkcm9wcGluZy5cbiAgICB0b3VjaEluZXJ0aWFEdXJhdGlvbjogMjAwLFxuICAgIC8vIHtudW1iZXJ9IFRoZSBpbmVydGlhIHBvd2VyICh0b3VjaCBjYXB0b3IpLlxuICAgIHRvdWNoSW5lcnRpYVJhdGlvOiAzLFxuICAgIC8vIHtudW1iZXJ9IFRoZSBtYXhpbXVtIHRpbWUgYmV0d2VlbiB0d28gY2xpY2tzIHRvIG1ha2UgaXQgYSBkb3VibGUgY2xpY2suXG4gICAgZG91YmxlQ2xpY2tUaW1lb3V0OiAzMDAsXG4gICAgLy8ge251bWJlcn0gVGhlIG1heGltdW0gdGltZSBiZXR3ZWVuIHR3byB0YXBzIHRvIG1ha2UgaXQgYSBkb3VibGUgdGFwLlxuICAgIGRvdWJsZVRhcFRpbWVvdXQ6IDMwMCxcbiAgICAvLyB7bnVtYmVyfSBUaGUgbWF4aW11bSB0aW1lIG9mIGRyYWdnaW5nIHRvIHRyaWdnZXIgaW50ZXJ0aWEuXG4gICAgZHJhZ1RpbWVvdXQ6IDIwMCxcblxuXG5cblxuICAgIC8qKlxuICAgICAqIEdMT0JBTCBTRVRUSU5HUzpcbiAgICAgKiAqKioqKioqKioqKioqKioqXG4gICAgICovXG4gICAgLy8ge2Jvb2xlYW59IERldGVybWluZXMgd2hldGhlciB0aGUgaW5zdGFuY2UgaGFzIHRvIHJlZnJlc2ggaXRzZWxmXG4gICAgLy8gICAgICAgICAgIGF1dG9tYXRpY2FsbHkgd2hlbiBhIFwicmVzaXplXCIgZXZlbnQgaXMgZGlzcGF0Y2hlZCBmcm9tIHRoZVxuICAgIC8vICAgICAgICAgICB3aW5kb3cgb2JqZWN0LlxuICAgIGF1dG9SZXNpemU6IHRydWUsXG4gICAgLy8ge2Jvb2xlYW59IERldGVybWluZXMgd2hldGhlciB0aGUgXCJyZXNjYWxlXCIgbWlkZGxld2FyZSBoYXMgdG8gYmUgY2FsbGVkXG4gICAgLy8gICAgICAgICAgIGF1dG9tYXRpY2FsbHkgZm9yIGVhY2ggY2FtZXJhIG9uIHJlZnJlc2guXG4gICAgYXV0b1Jlc2NhbGU6IHRydWUsXG4gICAgLy8ge2Jvb2xlYW59IElmIHNldCB0byBmYWxzZSwgdGhlIGNhbWVyYSBtZXRob2QgXCJnb1RvXCIgd2lsbCBiYXNpY2FsbHkgZG9cbiAgICAvLyAgICAgICAgICAgbm90aGluZy5cbiAgICBlbmFibGVDYW1lcmE6IHRydWUsXG4gICAgLy8ge2Jvb2xlYW59IElmIHNldCB0byBmYWxzZSwgdGhlIG5vZGVzIGNhbm5vdCBiZSBob3ZlcmVkLlxuICAgIGVuYWJsZUhvdmVyaW5nOiB0cnVlLFxuICAgIC8vIHtib29sZWFufSBJZiBzZXQgdG8gdHJ1ZSwgdGhlIGVkZ2VzIGNhbiBiZSBob3ZlcmVkLlxuICAgIGVuYWJsZUVkZ2VIb3ZlcmluZzogZmFsc2UsXG4gICAgLy8ge251bWJlcn0gVGhlIHNpemUgb2YgdGhlIGFyZWEgYXJvdW5kIHRoZSBlZGdlcyB0byBhY3RpdmF0ZSBob3ZlcmluZy5cbiAgICBlZGdlSG92ZXJQcmVjaXNpb246IDUsXG4gICAgLy8ge2Jvb2xlYW59IElmIHNldCB0byB0cnVlLCB0aGUgcmVzY2FsZSBtaWRkbGV3YXJlIHdpbGwgaWdub3JlIG5vZGUgc2l6ZXNcbiAgICAvLyAgICAgICAgICAgdG8gZGV0ZXJtaW5lIHRoZSBncmFwaHMgYm91bmRpbmdzLlxuICAgIHJlc2NhbGVJZ25vcmVTaXplOiBmYWxzZSxcbiAgICAvLyB7Ym9vbGVhbn0gRGV0ZXJtaW5lcyBpZiB0aGUgY29yZSBoYXMgdG8gdHJ5IHRvIGNhdGNoIGVycm9ycyBvblxuICAgIC8vICAgICAgICAgICByZW5kZXJpbmcuXG4gICAgc2tpcEVycm9yczogZmFsc2UsXG5cblxuXG5cbiAgICAvKipcbiAgICAgKiBDQU1FUkEgU0VUVElOR1M6XG4gICAgICogKioqKioqKioqKioqKioqKlxuICAgICAqL1xuICAgIC8vIHtudW1iZXJ9IFRoZSBwb3dlciBkZWdyZWVzIGFwcGxpZWQgdG8gdGhlIG5vZGVzL2VkZ2VzIHNpemUgcmVsYXRpdmVseSB0b1xuICAgIC8vICAgICAgICAgIHRoZSB6b29taW5nIGxldmVsLiBCYXNpY2FsbHk6XG4gICAgLy8gICAgICAgICAgID4gb25TY3JlZW5SID0gTWF0aC5wb3coem9vbSwgbm9kZXNQb3dSYXRpbykgKiBSXG4gICAgLy8gICAgICAgICAgID4gb25TY3JlZW5UID0gTWF0aC5wb3coem9vbSwgZWRnZXNQb3dSYXRpbykgKiBUXG4gICAgbm9kZXNQb3dSYXRpbzogMC41LFxuICAgIGVkZ2VzUG93UmF0aW86IDAuNSxcblxuXG5cblxuICAgIC8qKlxuICAgICAqIEFOSU1BVElPTlMgU0VUVElOR1M6XG4gICAgICogKioqKioqKioqKioqKioqKioqKipcbiAgICAgKi9cbiAgICAvLyB7bnVtYmVyfSBUaGUgZGVmYXVsdCBhbmltYXRpb24gdGltZS5cbiAgICBhbmltYXRpb25zVGltZTogMjAwXG4gIH07XG5cbiAgLy8gRXhwb3J0IHRoZSBwcmV2aW91c2x5IGRlc2lnbmVkIHNldHRpbmdzOlxuICBzaWdtYS5zZXR0aW5ncyA9IHNpZ21hLnV0aWxzLmV4dGVuZChzaWdtYS5zZXR0aW5ncyB8fCB7fSwgc2V0dGluZ3MpO1xufSkuY2FsbCh0aGlzKTtcblxuOyhmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qKlxuICAgKiBEaXNwYXRjaGVyIGNvbnN0cnVjdG9yLlxuICAgKlxuICAgKiBAcmV0dXJuIHtkaXNwYXRjaGVyfSBUaGUgbmV3IGRpc3BhdGNoZXIgaW5zdGFuY2UuXG4gICAqL1xuICB2YXIgZGlzcGF0Y2hlciA9IGZ1bmN0aW9uKCkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnX2hhbmRsZXJzJywge1xuICAgICAgdmFsdWU6IHt9XG4gICAgfSk7XG4gIH07XG5cblxuXG5cbiAgLyoqXG4gICAqIFdpbGwgZXhlY3V0ZSB0aGUgaGFuZGxlciBldmVyeXRpbWUgdGhhdCB0aGUgaW5kaWNhdGVkIGV2ZW50IChvciB0aGVcbiAgICogaW5kaWNhdGVkIGV2ZW50cykgd2lsbCBiZSB0cmlnZ2VyZWQuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICAgICAgICAgIGV2ZW50cyAgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IChvciB0aGUgZXZlbnRzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VwYXJhdGVkIGJ5IHNwYWNlcykuXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9uKE9iamVjdCl9IGhhbmRsZXIgVGhlIGhhbmRsZXIgdG8gYmluZC5cbiAgICogQHJldHVybiB7ZGlzcGF0Y2hlcn0gICAgICAgICAgICAgICBSZXR1cm5zIHRoZSBpbnN0YW5jZSBpdHNlbGYuXG4gICAqL1xuICBkaXNwYXRjaGVyLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24oZXZlbnRzLCBoYW5kbGVyKSB7XG4gICAgdmFyIGksXG4gICAgICAgIGwsXG4gICAgICAgIGV2ZW50LFxuICAgICAgICBlQXJyYXk7XG5cbiAgICBpZiAoXG4gICAgICBhcmd1bWVudHMubGVuZ3RoID09PSAxICYmXG4gICAgICB0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnb2JqZWN0J1xuICAgIClcbiAgICAgIGZvciAoZXZlbnRzIGluIGFyZ3VtZW50c1swXSlcbiAgICAgICAgdGhpcy5iaW5kKGV2ZW50cywgYXJndW1lbnRzWzBdW2V2ZW50c10pO1xuICAgIGVsc2UgaWYgKFxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA9PT0gMiAmJlxuICAgICAgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICkge1xuICAgICAgZUFycmF5ID0gdHlwZW9mIGV2ZW50cyA9PT0gJ3N0cmluZycgPyBldmVudHMuc3BsaXQoJyAnKSA6IGV2ZW50cztcblxuICAgICAgZm9yIChpID0gMCwgbCA9IGVBcnJheS5sZW5ndGg7IGkgIT09IGw7IGkgKz0gMSkge1xuICAgICAgICBldmVudCA9IGVBcnJheVtpXTtcblxuICAgICAgICAvLyBDaGVjayB0aGF0IGV2ZW50IGlzIG5vdCAnJzpcbiAgICAgICAgaWYgKCFldmVudClcbiAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICBpZiAoIXRoaXMuX2hhbmRsZXJzW2V2ZW50XSlcbiAgICAgICAgICB0aGlzLl9oYW5kbGVyc1tldmVudF0gPSBbXTtcblxuICAgICAgICAvLyBVc2luZyBhbiBvYmplY3QgaW5zdGVhZCBvZiBkaXJlY3RseSB0aGUgaGFuZGxlciB3aWxsIG1ha2UgcG9zc2libGVcbiAgICAgICAgLy8gbGF0ZXIgdG8gYWRkIGZsYWdzXG4gICAgICAgIHRoaXMuX2hhbmRsZXJzW2V2ZW50XS5wdXNoKHtcbiAgICAgICAgICBoYW5kbGVyOiBoYW5kbGVyXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZVxuICAgICAgdGhyb3cgJ2JpbmQ6IFdyb25nIGFyZ3VtZW50cy4nO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIGhhbmRsZXIgZnJvbSBhIHNwZWNpZmllZCBldmVudCAob3Igc3BlY2lmaWVkIGV2ZW50cykuXG4gICAqXG4gICAqIEBwYXJhbSAgez9zdHJpbmd9ICAgICAgICAgICBldmVudHMgIFRoZSBuYW1lIG9mIHRoZSBldmVudCAob3IgdGhlIGV2ZW50c1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXBhcmF0ZWQgYnkgc3BhY2VzKS4gSWYgdW5kZWZpbmVkLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGVuIGFsbCBoYW5kbGVycyBhcmUgcmVtb3ZlZC5cbiAgICogQHBhcmFtICB7P2Z1bmN0aW9uKG9iamVjdCl9IGhhbmRsZXIgVGhlIGhhbmRsZXIgdG8gdW5iaW5kLiBJZiB1bmRlZmluZWQsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVhY2ggaGFuZGxlciBib3VuZCB0byB0aGUgZXZlbnQgb3IgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50cyB3aWxsIGJlIHJlbW92ZWQuXG4gICAqIEByZXR1cm4ge2Rpc3BhdGNoZXJ9ICAgICAgICAgICAgICAgIFJldHVybnMgdGhlIGluc3RhbmNlIGl0c2VsZi5cbiAgICovXG4gIGRpc3BhdGNoZXIucHJvdG90eXBlLnVuYmluZCA9IGZ1bmN0aW9uKGV2ZW50cywgaGFuZGxlcikge1xuICAgIHZhciBpLFxuICAgICAgICBuLFxuICAgICAgICBqLFxuICAgICAgICBtLFxuICAgICAgICBrLFxuICAgICAgICBhLFxuICAgICAgICBldmVudCxcbiAgICAgICAgZUFycmF5ID0gdHlwZW9mIGV2ZW50cyA9PT0gJ3N0cmluZycgPyBldmVudHMuc3BsaXQoJyAnKSA6IGV2ZW50cztcblxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgZm9yIChrIGluIHRoaXMuX2hhbmRsZXJzKVxuICAgICAgICBkZWxldGUgdGhpcy5faGFuZGxlcnNba107XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiAoaGFuZGxlcikge1xuICAgICAgZm9yIChpID0gMCwgbiA9IGVBcnJheS5sZW5ndGg7IGkgIT09IG47IGkgKz0gMSkge1xuICAgICAgICBldmVudCA9IGVBcnJheVtpXTtcbiAgICAgICAgaWYgKHRoaXMuX2hhbmRsZXJzW2V2ZW50XSkge1xuICAgICAgICAgIGEgPSBbXTtcbiAgICAgICAgICBmb3IgKGogPSAwLCBtID0gdGhpcy5faGFuZGxlcnNbZXZlbnRdLmxlbmd0aDsgaiAhPT0gbTsgaiArPSAxKVxuICAgICAgICAgICAgaWYgKHRoaXMuX2hhbmRsZXJzW2V2ZW50XVtqXS5oYW5kbGVyICE9PSBoYW5kbGVyKVxuICAgICAgICAgICAgICBhLnB1c2godGhpcy5faGFuZGxlcnNbZXZlbnRdW2pdKTtcblxuICAgICAgICAgIHRoaXMuX2hhbmRsZXJzW2V2ZW50XSA9IGE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5faGFuZGxlcnNbZXZlbnRdICYmIHRoaXMuX2hhbmRsZXJzW2V2ZW50XS5sZW5ndGggPT09IDApXG4gICAgICAgICAgZGVsZXRlIHRoaXMuX2hhbmRsZXJzW2V2ZW50XTtcbiAgICAgIH1cbiAgICB9IGVsc2VcbiAgICAgIGZvciAoaSA9IDAsIG4gPSBlQXJyYXkubGVuZ3RoOyBpICE9PSBuOyBpICs9IDEpXG4gICAgICAgIGRlbGV0ZSB0aGlzLl9oYW5kbGVyc1tlQXJyYXlbaV1dO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIGVhY2ggaGFuZGxlciBib3VuZCB0byB0aGUgZXZlbnRcbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSAgICAgZXZlbnRzIFRoZSBuYW1lIG9mIHRoZSBldmVudCAob3IgdGhlIGV2ZW50cyBzZXBhcmF0ZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5IHNwYWNlcykuXG4gICAqIEBwYXJhbSAgez9vYmplY3R9ICAgIGRhdGEgICBUaGUgY29udGVudCBvZiB0aGUgZXZlbnQgKG9wdGlvbmFsKS5cbiAgICogQHJldHVybiB7ZGlzcGF0Y2hlcn0gICAgICAgIFJldHVybnMgdGhlIGluc3RhbmNlIGl0c2VsZi5cbiAgICovXG4gIGRpc3BhdGNoZXIucHJvdG90eXBlLmRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbihldmVudHMsIGRhdGEpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgbixcbiAgICAgICAgaixcbiAgICAgICAgbSxcbiAgICAgICAgYSxcbiAgICAgICAgZXZlbnQsXG4gICAgICAgIGV2ZW50TmFtZSxcbiAgICAgICAgc2VsZiA9IHRoaXMsXG4gICAgICAgIGVBcnJheSA9IHR5cGVvZiBldmVudHMgPT09ICdzdHJpbmcnID8gZXZlbnRzLnNwbGl0KCcgJykgOiBldmVudHM7XG5cbiAgICBkYXRhID0gZGF0YSA9PT0gdW5kZWZpbmVkID8ge30gOiBkYXRhO1xuXG4gICAgZm9yIChpID0gMCwgbiA9IGVBcnJheS5sZW5ndGg7IGkgIT09IG47IGkgKz0gMSkge1xuICAgICAgZXZlbnROYW1lID0gZUFycmF5W2ldO1xuXG4gICAgICBpZiAodGhpcy5faGFuZGxlcnNbZXZlbnROYW1lXSkge1xuICAgICAgICBldmVudCA9IHNlbGYuZ2V0RXZlbnQoZXZlbnROYW1lLCBkYXRhKTtcbiAgICAgICAgYSA9IFtdO1xuXG4gICAgICAgIGZvciAoaiA9IDAsIG0gPSB0aGlzLl9oYW5kbGVyc1tldmVudE5hbWVdLmxlbmd0aDsgaiAhPT0gbTsgaiArPSAxKSB7XG4gICAgICAgICAgdGhpcy5faGFuZGxlcnNbZXZlbnROYW1lXVtqXS5oYW5kbGVyKGV2ZW50KTtcbiAgICAgICAgICBpZiAoIXRoaXMuX2hhbmRsZXJzW2V2ZW50TmFtZV1bal0ub25lKVxuICAgICAgICAgICAgYS5wdXNoKHRoaXMuX2hhbmRsZXJzW2V2ZW50TmFtZV1bal0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5faGFuZGxlcnNbZXZlbnROYW1lXSA9IGE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBldmVudCBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gIGV2ZW50cyBUaGUgbmFtZSBvZiB0aGUgZXZlbnQuXG4gICAqIEBwYXJhbSAgez9vYmplY3R9IGRhdGEgICBUaGUgY29udGVudCBvZiB0aGUgZXZlbnQgKG9wdGlvbmFsKS5cbiAgICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgIFJldHVybnMgdGhlIGluc3RhbmNlIGl0c2VsZi5cbiAgICovXG4gIGRpc3BhdGNoZXIucHJvdG90eXBlLmdldEV2ZW50ID0gZnVuY3Rpb24oZXZlbnQsIGRhdGEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogZXZlbnQsXG4gICAgICBkYXRhOiBkYXRhIHx8IHt9LFxuICAgICAgdGFyZ2V0OiB0aGlzXG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICogQSB1c2VmdWwgZnVuY3Rpb24gdG8gZGVhbCB3aXRoIGluaGVyaXRhbmNlLiBJdCB3aWxsIG1ha2UgdGhlIHRhcmdldFxuICAgKiBpbmhlcml0IHRoZSBwcm90b3R5cGUgb2YgdGhlIGNsYXNzIGRpc3BhdGNoZXIgYXMgd2VsbCBhcyBpdHMgY29uc3RydWN0b3IuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXQgVGhlIHRhcmdldC5cbiAgICovXG4gIGRpc3BhdGNoZXIuZXh0ZW5kID0gZnVuY3Rpb24odGFyZ2V0LCBhcmdzKSB7XG4gICAgdmFyIGs7XG5cbiAgICBmb3IgKGsgaW4gZGlzcGF0Y2hlci5wcm90b3R5cGUpXG4gICAgICBpZiAoZGlzcGF0Y2hlci5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoaykpXG4gICAgICAgIHRhcmdldFtrXSA9IGRpc3BhdGNoZXIucHJvdG90eXBlW2tdO1xuXG4gICAgZGlzcGF0Y2hlci5hcHBseSh0YXJnZXQsIGFyZ3MpO1xuICB9O1xuXG5cblxuXG4gIC8qKlxuICAgKiBFWFBPUlQ6XG4gICAqICoqKioqKipcbiAgICovXG4gIGlmICh0eXBlb2YgdGhpcy5zaWdtYSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aGlzLnNpZ21hLmNsYXNzZXMgPSB0aGlzLnNpZ21hLmNsYXNzZXMgfHwge307XG4gICAgdGhpcy5zaWdtYS5jbGFzc2VzLmRpc3BhdGNoZXIgPSBkaXNwYXRjaGVyO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cylcbiAgICAgIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGRpc3BhdGNoZXI7XG4gICAgZXhwb3J0cy5kaXNwYXRjaGVyID0gZGlzcGF0Y2hlcjtcbiAgfSBlbHNlXG4gICAgdGhpcy5kaXNwYXRjaGVyID0gZGlzcGF0Y2hlcjtcbn0pLmNhbGwodGhpcyk7XG5cbjsoZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvKipcbiAgICogVGhpcyB1dGlscyBhaW1zIHRvIGZhY2lsaXRhdGUgdGhlIG1hbmlwdWxhdGlvbiBvZiBlYWNoIGluc3RhbmNlIHNldHRpbmcuXG4gICAqIFVzaW5nIGEgZnVuY3Rpb24gaW5zdGVhZCBvZiBhbiBvYmplY3QgYnJpbmdzIHR3byBtYWluIGFkdmFudGFnZXM6IEZpcnN0LFxuICAgKiBpdCB3aWxsIGJlIGVhc2llciBpbiB0aGUgZnV0dXJlIHRvIGNhdGNoIHNldHRpbmdzIHVwZGF0ZXMgdGhyb3VnaCBhXG4gICAqIGZ1bmN0aW9uIHRoYW4gYW4gb2JqZWN0LiBTZWNvbmQsIGdpdmluZyBpdCBhIGZ1bGwgb2JqZWN0IHdpbGwgXCJtZXJnZVwiIGl0XG4gICAqIHRvIHRoZSBzZXR0aW5ncyBvYmplY3QgcHJvcGVybHksIGtlZXBpbmcgdXMgdG8gaGF2ZSB0byBhbHdheXMgYWRkIGEgbG9vcC5cbiAgICpcbiAgICogQHJldHVybiB7Y29uZmlndXJhYmxlfSBUaGUgXCJzZXR0aW5nc1wiIGZ1bmN0aW9uLlxuICAgKi9cbiAgdmFyIGNvbmZpZ3VyYWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpLFxuICAgICAgICBsLFxuICAgICAgICBkYXRhID0ge30sXG4gICAgICAgIGRhdGFzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBtZXRob2QgdG8gdXNlIHRvIHNldCBvciBnZXQgYW55IHByb3BlcnR5IG9mIHRoaXMgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd8b2JqZWN0fSAgICBhMSBJZiBpdCBpcyBhIHN0cmluZyBhbmQgaWYgYTIgaXMgdW5kZWZpbmVkLFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZW4gaXQgd2lsbCByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmdcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eS4gSWYgaXQgaXMgYSBzdHJpbmcgYW5kIGlmIGEyIGlzXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0LCB0aGVuIGl0IHdpbGwgc2V0IGEyIGFzIHRoZSBwcm9wZXJ0eVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcnJlc3BvbmRpbmcgdG8gYTEsIGFuZCByZXR1cm4gdGhpcy4gSWZcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdCBpcyBhbiBvYmplY3QsIHRoZW4gZWFjaCBwYWlyIHN0cmluZyArXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0KG9yIGFueSBvdGhlciB0eXBlKSB3aWxsIGJlIHNldCBhcyBhXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHkuXG4gICAgICogQHBhcmFtICB7Kj99ICAgICAgICAgICAgICAgYTIgVGhlIG5ldyBwcm9wZXJ0eSBjb3JyZXNwb25kaW5nIHRvIGExIGlmIGExXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXMgYSBzdHJpbmcuXG4gICAgICogQHJldHVybiB7Knxjb25maWd1cmFibGV9ICAgICAgUmV0dXJucyBpdHNlbGYgb3IgdGhlIGNvcnJlc3BvbmRpbmdcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIFBvbHltb3JwaGlzbTpcbiAgICAgKiAqKioqKioqKioqKioqXG4gICAgICogSGVyZSBhcmUgc29tZSBiYXNpYyB1c2UgZXhhbXBsZXM6XG4gICAgICpcbiAgICAgKiAgPiBzZXR0aW5ncyA9IG5ldyBjb25maWd1cmFibGUoKTtcbiAgICAgKiAgPiBzZXR0aW5ncygnbXlTZXR0aW5nJywgNDIpO1xuICAgICAqICA+IHNldHRpbmdzKCdteVNldHRpbmcnKTsgLy8gTG9nczogNDJcbiAgICAgKiAgPiBzZXR0aW5ncygnbXlTZXR0aW5nJywgMTIzKTtcbiAgICAgKiAgPiBzZXR0aW5ncygnbXlTZXR0aW5nJyk7IC8vIExvZ3M6IDEyM1xuICAgICAqICA+IHNldHRpbmdzKHtteVNldHRpbmc6IDQ1Nn0pO1xuICAgICAqICA+IHNldHRpbmdzKCdteVNldHRpbmcnKTsgLy8gTG9nczogNDU2XG4gICAgICpcbiAgICAgKiBBbHNvLCBpdCBpcyBwb3NzaWJsZSB0byB1c2UgdGhlIGZ1bmN0aW9uIGFzIGEgZmFsbGJhY2s6XG4gICAgICogID4gc2V0dGluZ3Moe215U2V0dGluZzogJ2FiYyd9LCAnbXlTZXR0aW5nJyk7ICAvLyBMb2dzOiAnYWJjJ1xuICAgICAqICA+IHNldHRpbmdzKHtoaXNTZXR0aW5nOiAnYWJjJ30sICdteVNldHRpbmcnKTsgLy8gTG9nczogNDU2XG4gICAgICovXG4gICAgdmFyIHNldHRpbmdzID0gZnVuY3Rpb24oYTEsIGEyKSB7XG4gICAgICB2YXIgbyxcbiAgICAgICAgICBpLFxuICAgICAgICAgIGwsXG4gICAgICAgICAgaztcblxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGExID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoZGF0YVthMV0gIT09IHVuZGVmaW5lZClcbiAgICAgICAgICByZXR1cm4gZGF0YVthMV07XG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBkYXRhcy5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgICAgaWYgKGRhdGFzW2ldW2ExXSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIGRhdGFzW2ldW2ExXTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGExID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgYTIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiAoYTEgfHwge30pW2EyXSAhPT0gdW5kZWZpbmVkID8gYTFbYTJdIDogc2V0dGluZ3MoYTIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbyA9ICh0eXBlb2YgYTEgPT09ICdvYmplY3QnICYmIGEyID09PSB1bmRlZmluZWQpID8gYTEgOiB7fTtcblxuICAgICAgICBpZiAodHlwZW9mIGExID09PSAnc3RyaW5nJylcbiAgICAgICAgICBvW2ExXSA9IGEyO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGsgPSBPYmplY3Qua2V5cyhvKSwgbCA9IGsubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgICAgIGRhdGFba1tpXV0gPSBvW2tbaV1dO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGNvbmZpZ3VyYWJsZSBmdW5jdGlvbiwgd2l0aCBuZXcgb2JqZWN0c1xuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0Kn0gIEFueSBudW1iZXIgb2Ygb2JqZWN0cyB0byBzZWFyY2ggaW4uXG4gICAgICogQHJldHVybiB7ZnVuY3Rpb259IFJldHVybnMgdGhlIGZ1bmN0aW9uLiBDaGVjayBpdHMgZG9jdW1lbnRhdGlvbiB0byBrbm93XG4gICAgICogICAgICAgICAgICAgICAgICAgIG1vcmUgYWJvdXQgaG93IGl0IHdvcmtzLlxuICAgICAqL1xuICAgIHNldHRpbmdzLmVtYmVkT2JqZWN0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGFyZ3MgPSBkYXRhcy5jb25jYXQoXG4gICAgICAgIGRhdGFcbiAgICAgICkuY29uY2F0KFxuICAgICAgICBBcnJheS5wcm90b3R5cGUuc3BsaWNlLmNhbGwoYXJndW1lbnRzLCAwKVxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIGNvbmZpZ3VyYWJsZS5hcHBseSh7fSwgYXJncyk7XG4gICAgfTtcblxuICAgIC8vIEluaXRpYWxpemVcbiAgICBmb3IgKGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgIHNldHRpbmdzKGFyZ3VtZW50c1tpXSk7XG5cbiAgICByZXR1cm4gc2V0dGluZ3M7XG4gIH07XG5cbiAgLyoqXG4gICAqIEVYUE9SVDpcbiAgICogKioqKioqKlxuICAgKi9cbiAgaWYgKHR5cGVvZiB0aGlzLnNpZ21hICE9PSAndW5kZWZpbmVkJykge1xuICAgIHRoaXMuc2lnbWEuY2xhc3NlcyA9IHRoaXMuc2lnbWEuY2xhc3NlcyB8fCB7fTtcbiAgICB0aGlzLnNpZ21hLmNsYXNzZXMuY29uZmlndXJhYmxlID0gY29uZmlndXJhYmxlO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cylcbiAgICAgIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGNvbmZpZ3VyYWJsZTtcbiAgICBleHBvcnRzLmNvbmZpZ3VyYWJsZSA9IGNvbmZpZ3VyYWJsZTtcbiAgfSBlbHNlXG4gICAgdGhpcy5jb25maWd1cmFibGUgPSBjb25maWd1cmFibGU7XG59KS5jYWxsKHRoaXMpO1xuXG47KGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIF9tZXRob2RzID0gT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgIF9pbmRleGVzID0gT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgIF9pbml0QmluZGluZ3MgPSBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgX21ldGhvZEJpbmRpbmdzID0gT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgIF9tZXRob2RCZWZvcmVCaW5kaW5ncyA9IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICBfZGVmYXVsdFNldHRpbmdzID0ge1xuICAgICAgICBpbW11dGFibGU6IHRydWUsXG4gICAgICAgIGNsb25lOiB0cnVlXG4gICAgICB9LFxuICAgICAgX2RlZmF1bHRTZXR0aW5nc0Z1bmN0aW9uID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiBfZGVmYXVsdFNldHRpbmdzW2tleV07XG4gICAgICB9O1xuXG4gIC8qKlxuICAgKiBUaGUgZ3JhcGggY29uc3RydWN0b3IuIEl0IGluaXRpYWxpemVzIHRoZSBkYXRhIGFuZCB0aGUgaW5kZXhlcywgYW5kIGJpbmRzXG4gICAqIHRoZSBjdXN0b20gaW5kZXhlcyBhbmQgbWV0aG9kcyB0byBpdHMgb3duIHNjb3BlLlxuICAgKlxuICAgKiBSZWNvZ25pemVkIHBhcmFtZXRlcnM6XG4gICAqICoqKioqKioqKioqKioqKioqKioqKipcbiAgICogSGVyZSBpcyB0aGUgZXhoYXVzdGl2ZSBsaXN0IG9mIGV2ZXJ5IGFjY2VwdGVkIHBhcmFtZXRlcnMgaW4gdGhlIHNldHRpbmdzXG4gICAqIG9iamVjdDpcbiAgICpcbiAgICogICB7Ym9vbGVhbn0gY2xvbmUgICAgIEluZGljYXRlcyBpZiB0aGUgZGF0YSBoYXZlIHRvIGJlIGNsb25lZCBpbiBtZXRob2RzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICB0byBhZGQgbm9kZXMgb3IgZWRnZXMuXG4gICAqICAge2Jvb2xlYW59IGltbXV0YWJsZSBJbmRpY2F0ZXMgaWYgbm9kZXMgXCJpZFwiIHZhbHVlcyBhbmQgZWRnZXMgXCJpZFwiLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgXCJzb3VyY2VcIiBhbmQgXCJ0YXJnZXRcIiB2YWx1ZXMgbXVzdCBiZSBzZXQgYXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgIGltbXV0YWJsZS5cbiAgICpcbiAgICogQHBhcmFtICB7P2NvbmZpZ3VyYWJsZX0gc2V0dGluZ3MgRXZlbnR1YWxseSBhIHNldHRpbmdzIGZ1bmN0aW9uLlxuICAgKiBAcmV0dXJuIHtncmFwaH0gICAgICAgICAgICAgICAgICBUaGUgbmV3IGdyYXBoIGluc3RhbmNlLlxuICAgKi9cbiAgdmFyIGdyYXBoID0gZnVuY3Rpb24oc2V0dGluZ3MpIHtcbiAgICB2YXIgayxcbiAgICAgICAgZm4sXG4gICAgICAgIGRhdGE7XG5cbiAgICAvKipcbiAgICAgKiBEQVRBOlxuICAgICAqICoqKioqXG4gICAgICogRXZlcnkgZGF0YSB0aGF0IGlzIGNhbGxhYmxlIGZyb20gZ3JhcGggbWV0aG9kcyBhcmUgc3RvcmVkIGluIHRoaXMgXCJkYXRhXCJcbiAgICAgKiBvYmplY3QuIFRoaXMgb2JqZWN0IHdpbGwgYmUgc2VydmVkIGFzIGNvbnRleHQgZm9yIGFsbCB0aGVzZSBtZXRob2RzLFxuICAgICAqIGFuZCBpdCBpcyBwb3NzaWJsZSB0byBhZGQgb3RoZXIgdHlwZSBvZiBkYXRhIGluIGl0LlxuICAgICAqL1xuICAgIGRhdGEgPSB7XG4gICAgICAvKipcbiAgICAgICAqIFNFVFRJTkdTIEZVTkNUSU9OOlxuICAgICAgICogKioqKioqKioqKioqKioqKioqXG4gICAgICAgKi9cbiAgICAgIHNldHRpbmdzOiBzZXR0aW5ncyB8fCBfZGVmYXVsdFNldHRpbmdzRnVuY3Rpb24sXG5cbiAgICAgIC8qKlxuICAgICAgICogTUFJTiBEQVRBOlxuICAgICAgICogKioqKioqKioqKlxuICAgICAgICovXG4gICAgICBub2Rlc0FycmF5OiBbXSxcbiAgICAgIGVkZ2VzQXJyYXk6IFtdLFxuXG4gICAgICAvKipcbiAgICAgICAqIEdMT0JBTCBJTkRFWEVTOlxuICAgICAgICogKioqKioqKioqKioqKioqXG4gICAgICAgKiBUaGVzZSBpbmRleGVzIGp1c3QgaW5kZXggZGF0YSBieSBpZHMuXG4gICAgICAgKi9cbiAgICAgIG5vZGVzSW5kZXg6IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICBlZGdlc0luZGV4OiBPYmplY3QuY3JlYXRlKG51bGwpLFxuXG4gICAgICAvKipcbiAgICAgICAqIExPQ0FMIElOREVYRVM6XG4gICAgICAgKiAqKioqKioqKioqKioqKlxuICAgICAgICogVGhlc2UgaW5kZXhlcyByZWZlciBmcm9tIG5vZGUgdG8gbm9kZXMuIEVhY2gga2V5IGlzIGFuIGlkLCBhbmQgZWFjaFxuICAgICAgICogdmFsdWUgaXMgdGhlIGFycmF5IG9mIHRoZSBpZHMgb2YgcmVsYXRlZCBub2Rlcy5cbiAgICAgICAqL1xuICAgICAgaW5OZWlnaGJvcnNJbmRleDogT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgIG91dE5laWdoYm9yc0luZGV4OiBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgYWxsTmVpZ2hib3JzSW5kZXg6IE9iamVjdC5jcmVhdGUobnVsbCksXG5cbiAgICAgIGluTmVpZ2hib3JzQ291bnQ6IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICBvdXROZWlnaGJvcnNDb3VudDogT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgIGFsbE5laWdoYm9yc0NvdW50OiBPYmplY3QuY3JlYXRlKG51bGwpXG4gICAgfTtcblxuICAgIC8vIEV4ZWN1dGUgYmluZGluZ3M6XG4gICAgZm9yIChrIGluIF9pbml0QmluZGluZ3MpXG4gICAgICBfaW5pdEJpbmRpbmdzW2tdLmNhbGwoZGF0YSk7XG5cbiAgICAvLyBBZGQgbWV0aG9kcyB0byBib3RoIHRoZSBzY29wZSBhbmQgdGhlIGRhdGEgb2JqZWN0czpcbiAgICBmb3IgKGsgaW4gX21ldGhvZHMpIHtcbiAgICAgIGZuID0gX19iaW5kR3JhcGhNZXRob2QoaywgZGF0YSwgX21ldGhvZHNba10pO1xuICAgICAgdGhpc1trXSA9IGZuO1xuICAgICAgZGF0YVtrXSA9IGZuO1xuICAgIH1cbiAgfTtcblxuXG5cblxuICAvKipcbiAgICogQSBjdXN0b20gdG9vbCB0byBiaW5kIG1ldGhvZHMgc3VjaCB0aGF0IGZ1bmN0aW9uIHRoYXQgYXJlIGJvdW5kIHRvIGl0IHdpbGxcbiAgICogYmUgZXhlY3V0ZWQgYW55dGltZSB0aGUgbWV0aG9kIGlzIGNhbGxlZC5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSAgIG1ldGhvZE5hbWUgVGhlIG5hbWUgb2YgdGhlIG1ldGhvZCB0byBiaW5kLlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgc2NvcGUgICAgICBUaGUgc2NvcGUgd2hlcmUgdGhlIG1ldGhvZCBtdXN0IGJlIGV4ZWN1dGVkLlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gZm4gICAgICAgICBUaGUgbWV0aG9kIGl0c2VsZi5cbiAgICogQHJldHVybiB7ZnVuY3Rpb259ICAgICAgICAgICAgVGhlIG5ldyBtZXRob2QuXG4gICAqL1xuICBmdW5jdGlvbiBfX2JpbmRHcmFwaE1ldGhvZChtZXRob2ROYW1lLCBzY29wZSwgZm4pIHtcbiAgICB2YXIgcmVzdWx0ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgayxcbiAgICAgICAgICByZXM7XG5cbiAgICAgIC8vIEV4ZWN1dGUgXCJiZWZvcmVcIiBib3VuZCBmdW5jdGlvbnM6XG4gICAgICBmb3IgKGsgaW4gX21ldGhvZEJlZm9yZUJpbmRpbmdzW21ldGhvZE5hbWVdKVxuICAgICAgICBfbWV0aG9kQmVmb3JlQmluZGluZ3NbbWV0aG9kTmFtZV1ba10uYXBwbHkoc2NvcGUsIGFyZ3VtZW50cyk7XG5cbiAgICAgIC8vIEFwcGx5IHRoZSBtZXRob2Q6XG4gICAgICByZXMgPSBmbi5hcHBseShzY29wZSwgYXJndW1lbnRzKTtcblxuICAgICAgLy8gRXhlY3V0ZSBib3VuZCBmdW5jdGlvbnM6XG4gICAgICBmb3IgKGsgaW4gX21ldGhvZEJpbmRpbmdzW21ldGhvZE5hbWVdKVxuICAgICAgICBfbWV0aG9kQmluZGluZ3NbbWV0aG9kTmFtZV1ba10uYXBwbHkoc2NvcGUsIGFyZ3VtZW50cyk7XG5cbiAgICAgIC8vIFJldHVybiByZXM6XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH07XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgY3VzdG9tIHRvb2wgZnVuY3Rpb24gcmVtb3ZlcyBldmVyeSBwYWlyIGtleS92YWx1ZSBmcm9tIGFuIGhhc2guIFRoZVxuICAgKiBnb2FsIGlzIHRvIGF2b2lkIGNyZWF0aW5nIGEgbmV3IG9iamVjdCB3aGlsZSBzb21lIG90aGVyIHJlZmVyZW5jZXMgYXJlXG4gICAqIHN0aWxsIGhhbmdpbmcgaW4gc29tZSBzY29wZXMuLi5cbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBlbXB0eS5cbiAgICogQHJldHVybiB7b2JqZWN0fSAgICAgVGhlIGVtcHR5IG9iamVjdC5cbiAgICovXG4gIGZ1bmN0aW9uIF9fZW1wdHlPYmplY3Qob2JqKSB7XG4gICAgdmFyIGs7XG5cbiAgICBmb3IgKGsgaW4gb2JqKVxuICAgICAgaWYgKCEoJ2hhc093blByb3BlcnR5JyBpbiBvYmopIHx8IG9iai5oYXNPd25Qcm9wZXJ0eShrKSlcbiAgICAgICAgZGVsZXRlIG9ialtrXTtcblxuICAgIHJldHVybiBvYmo7XG4gIH1cblxuXG5cblxuICAvKipcbiAgICogVGhpcyBnbG9iYWwgbWV0aG9kIGFkZHMgYSBtZXRob2QgdGhhdCB3aWxsIGJlIGJvdW5kIHRvIHRoZSBmdXR1cmx5IGNyZWF0ZWRcbiAgICogZ3JhcGggaW5zdGFuY2VzLlxuICAgKlxuICAgKiBTaW5jZSB0aGVzZSBtZXRob2RzIHdpbGwgYmUgYm91bmQgdG8gdGhlaXIgc2NvcGUgd2hlbiB0aGUgaW5zdGFuY2VzIGFyZVxuICAgKiBjcmVhdGVkLCBpdCBkb2VzIG5vdCB1c2UgdGhlIHByb3RvdHlwZS4gQmVjYXVzZSBvZiB0aGF0LCBtZXRob2RzIGhhdmUgdG9cbiAgICogYmUgYWRkZWQgYmVmb3JlIGluc3RhbmNlcyBhcmUgY3JlYXRlZCB0byBtYWtlIHRoZW0gYXZhaWxhYmxlLlxuICAgKlxuICAgKiBIZXJlIGlzIGFuIGV4YW1wbGU6XG4gICAqXG4gICAqICA+IGdyYXBoLmFkZE1ldGhvZCgnZ2V0Tm9kZXNDb3VudCcsIGZ1bmN0aW9uKCkge1xuICAgKiAgPiAgIHJldHVybiB0aGlzLm5vZGVzQXJyYXkubGVuZ3RoO1xuICAgKiAgPiB9KTtcbiAgICogID5cbiAgICogID4gdmFyIG15R3JhcGggPSBuZXcgZ3JhcGgoKTtcbiAgICogID4gY29uc29sZS5sb2cobXlHcmFwaC5nZXROb2Rlc0NvdW50KCkpOyAvLyBvdXRwdXRzIDBcbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSAgIG1ldGhvZE5hbWUgVGhlIG5hbWUgb2YgdGhlIG1ldGhvZC5cbiAgICogQHBhcmFtICB7ZnVuY3Rpb259IGZuICAgICAgICAgVGhlIG1ldGhvZCBpdHNlbGYuXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICAgICAgIFRoZSBnbG9iYWwgZ3JhcGggY29uc3RydWN0b3IuXG4gICAqL1xuICBncmFwaC5hZGRNZXRob2QgPSBmdW5jdGlvbihtZXRob2ROYW1lLCBmbikge1xuICAgIGlmIChcbiAgICAgIHR5cGVvZiBtZXRob2ROYW1lICE9PSAnc3RyaW5nJyB8fFxuICAgICAgdHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nIHx8XG4gICAgICBhcmd1bWVudHMubGVuZ3RoICE9PSAyXG4gICAgKVxuICAgICAgdGhyb3cgJ2FkZE1ldGhvZDogV3JvbmcgYXJndW1lbnRzLic7XG5cbiAgICBpZiAoX21ldGhvZHNbbWV0aG9kTmFtZV0gfHwgZ3JhcGhbbWV0aG9kTmFtZV0pXG4gICAgICB0aHJvdyAnVGhlIG1ldGhvZCBcIicgKyBtZXRob2ROYW1lICsgJ1wiIGFscmVhZHkgZXhpc3RzLic7XG5cbiAgICBfbWV0aG9kc1ttZXRob2ROYW1lXSA9IGZuO1xuICAgIF9tZXRob2RCaW5kaW5nc1ttZXRob2ROYW1lXSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgX21ldGhvZEJlZm9yZUJpbmRpbmdzW21ldGhvZE5hbWVdID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIGdsb2JhbCBtZXRob2QgcmV0dXJucyB0cnVlIGlmIHRoZSBtZXRob2QgaGFzIGFscmVhZHkgYmVlbiBhZGRlZCwgYW5kXG4gICAqIGZhbHNlIGVsc2UuXG4gICAqXG4gICAqIEhlcmUgYXJlIHNvbWUgZXhhbXBsZXM6XG4gICAqXG4gICAqICA+IGdyYXBoLmhhc01ldGhvZCgnYWRkTm9kZScpOyAvLyByZXR1cm5zIHRydWVcbiAgICogID4gZ3JhcGguaGFzTWV0aG9kKCdoYXNNZXRob2QnKTsgLy8gcmV0dXJucyB0cnVlXG4gICAqICA+IGdyYXBoLmhhc01ldGhvZCgndW5leGlzdGluZ01ldGhvZCcpOyAvLyByZXR1cm5zIGZhbHNlXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gIG1ldGhvZE5hbWUgVGhlIG5hbWUgb2YgdGhlIG1ldGhvZC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gICAgICAgICAgICBUaGUgcmVzdWx0LlxuICAgKi9cbiAgZ3JhcGguaGFzTWV0aG9kID0gZnVuY3Rpb24obWV0aG9kTmFtZSkge1xuICAgIHJldHVybiAhIShfbWV0aG9kc1ttZXRob2ROYW1lXSB8fCBncmFwaFttZXRob2ROYW1lXSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgZ2xvYmFsIG1ldGhvZHMgYXR0YWNoZXMgYSBmdW5jdGlvbiB0byBhIG1ldGhvZC4gQW55dGltZSB0aGUgc3BlY2lmaWVkXG4gICAqIG1ldGhvZCBpcyBjYWxsZWQsIHRoZSBhdHRhY2hlZCBmdW5jdGlvbiBpcyBjYWxsZWQgcmlnaHQgYWZ0ZXIsIHdpdGggdGhlXG4gICAqIHNhbWUgYXJndW1lbnRzIGFuZCBpbiB0aGUgc2FtZSBzY29wZS4gVGhlIGF0dGFjaGVkIGZ1bmN0aW9uIGlzIGNhbGxlZFxuICAgKiByaWdodCBiZWZvcmUgaWYgdGhlIGxhc3QgYXJndW1lbnQgaXMgdHJ1ZSwgdW5sZXNzIHRoZSBtZXRob2QgaXMgdGhlIGdyYXBoXG4gICAqIGNvbnN0cnVjdG9yLlxuICAgKlxuICAgKiBUbyBhdHRhY2ggYSBmdW5jdGlvbiB0byB0aGUgZ3JhcGggY29uc3RydWN0b3IsIHVzZSAnY29uc3RydWN0b3InIGFzIHRoZVxuICAgKiBtZXRob2QgbmFtZSAoZmlyc3QgYXJndW1lbnQpLlxuICAgKlxuICAgKiBUaGUgbWFpbiBpZGVhIGlzIHRvIGhhdmUgYSBjbGVhbiB3YXkgdG8ga2VlcCBjdXN0b20gaW5kZXhlcyB1cCB0byBkYXRlLFxuICAgKiBmb3IgaW5zdGFuY2U6XG4gICAqXG4gICAqICA+IHZhciB0aW1lc0FkZE5vZGVDYWxsZWQgPSAwO1xuICAgKiAgPiBncmFwaC5hdHRhY2goJ2FkZE5vZGUnLCAndGltZXNBZGROb2RlQ2FsbGVkSW5jJywgZnVuY3Rpb24oKSB7XG4gICAqICA+ICAgdGltZXNBZGROb2RlQ2FsbGVkKys7XG4gICAqICA+IH0pO1xuICAgKiAgPlxuICAgKiAgPiB2YXIgbXlHcmFwaCA9IG5ldyBncmFwaCgpO1xuICAgKiAgPiBjb25zb2xlLmxvZyh0aW1lc0FkZE5vZGVDYWxsZWQpOyAvLyBvdXRwdXRzIDBcbiAgICogID5cbiAgICogID4gbXlHcmFwaC5hZGROb2RlKHsgaWQ6ICcxJyB9KS5hZGROb2RlKHsgaWQ6ICcyJyB9KTtcbiAgICogID4gY29uc29sZS5sb2codGltZXNBZGROb2RlQ2FsbGVkKTsgLy8gb3V0cHV0cyAyXG4gICAqXG4gICAqIFRoZSBpZGVhIGZvciBjYWxsaW5nIGEgZnVuY3Rpb24gYmVmb3JlIGlzIHRvIHByb3ZpZGUgcHJlLXByb2Nlc3NvcnMsIGZvclxuICAgKiBpbnN0YW5jZTpcbiAgICpcbiAgICogID4gdmFyIGNvbG9yUGFsZXR0ZSA9IHsgUGVyc29uOiAnI0MzQ0JFMScsIFBsYWNlOiAnIzlCREVCRCcgfTtcbiAgICogID4gZ3JhcGguYXR0YWNoKCdhZGROb2RlJywgJ2FwcGx5Tm9kZUNvbG9yUGFsZXR0ZScsIGZ1bmN0aW9uKG4pIHtcbiAgICogID4gICBuLmNvbG9yID0gY29sb3JQYWxldHRlW24uY2F0ZWdvcnldO1xuICAgKiAgPiB9LCB0cnVlKTtcbiAgICogID5cbiAgICogID4gdmFyIG15R3JhcGggPSBuZXcgZ3JhcGgoKTtcbiAgICogID4gbXlHcmFwaC5hZGROb2RlKHsgaWQ6ICduMCcsIGNhdGVnb3J5OiAnUGVyc29uJyB9KTtcbiAgICogID4gY29uc29sZS5sb2cobXlHcmFwaC5ub2RlcygnbjAnKS5jb2xvcik7IC8vIG91dHB1dHMgJyNDM0NCRTEnXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICBtZXRob2ROYW1lIFRoZSBuYW1lIG9mIHRoZSByZWxhdGVkIG1ldGhvZCBvclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImNvbnN0cnVjdG9yXCIuXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICBrZXkgICAgICAgIFRoZSBrZXkgdG8gaWRlbnRpZnkgdGhlIGZ1bmN0aW9uIHRvIGF0dGFjaC5cbiAgICogQHBhcmFtICB7ZnVuY3Rpb259IGZuICAgICAgICAgVGhlIGZ1bmN0aW9uIHRvIGJpbmQuXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59ICBiZWZvcmUgICAgIElmIHRydWUgdGhlIGZ1bmN0aW9uIGlzIGNhbGxlZCByaWdodCBiZWZvcmUuXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICAgICAgIFRoZSBnbG9iYWwgZ3JhcGggY29uc3RydWN0b3IuXG4gICAqL1xuICBncmFwaC5hdHRhY2ggPSBmdW5jdGlvbihtZXRob2ROYW1lLCBrZXksIGZuLCBiZWZvcmUpIHtcbiAgICBpZiAoXG4gICAgICB0eXBlb2YgbWV0aG9kTmFtZSAhPT0gJ3N0cmluZycgfHxcbiAgICAgIHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnIHx8XG4gICAgICB0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicgfHxcbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggPCAzIHx8XG4gICAgICBhcmd1bWVudHMubGVuZ3RoID4gNFxuICAgIClcbiAgICAgIHRocm93ICdhdHRhY2g6IFdyb25nIGFyZ3VtZW50cy4nO1xuXG4gICAgdmFyIGJpbmRpbmdzO1xuXG4gICAgaWYgKG1ldGhvZE5hbWUgPT09ICdjb25zdHJ1Y3RvcicpXG4gICAgICBiaW5kaW5ncyA9IF9pbml0QmluZGluZ3M7XG4gICAgZWxzZSB7XG4gICAgICBpZiAoYmVmb3JlKSB7XG4gICAgICAgIGlmICghX21ldGhvZEJlZm9yZUJpbmRpbmdzW21ldGhvZE5hbWVdKVxuICAgICAgICB0aHJvdyAnVGhlIG1ldGhvZCBcIicgKyBtZXRob2ROYW1lICsgJ1wiIGRvZXMgbm90IGV4aXN0Lic7XG5cbiAgICAgICAgYmluZGluZ3MgPSBfbWV0aG9kQmVmb3JlQmluZGluZ3NbbWV0aG9kTmFtZV07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKCFfbWV0aG9kQmluZGluZ3NbbWV0aG9kTmFtZV0pXG4gICAgICAgICAgdGhyb3cgJ1RoZSBtZXRob2QgXCInICsgbWV0aG9kTmFtZSArICdcIiBkb2VzIG5vdCBleGlzdC4nO1xuXG4gICAgICAgIGJpbmRpbmdzID0gX21ldGhvZEJpbmRpbmdzW21ldGhvZE5hbWVdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChiaW5kaW5nc1trZXldKVxuICAgICAgdGhyb3cgJ0EgZnVuY3Rpb24gXCInICsga2V5ICsgJ1wiIGlzIGFscmVhZHkgYXR0YWNoZWQgJyArXG4gICAgICAgICAgICAndG8gdGhlIG1ldGhvZCBcIicgKyBtZXRob2ROYW1lICsgJ1wiLic7XG5cbiAgICBiaW5kaW5nc1trZXldID0gZm47XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogQWxpYXMgb2YgYXR0YWNoKG1ldGhvZE5hbWUsIGtleSwgZm4sIHRydWUpLlxuICAgKi9cbiAgZ3JhcGguYXR0YWNoQmVmb3JlID0gZnVuY3Rpb24obWV0aG9kTmFtZSwga2V5LCBmbikge1xuICAgIHJldHVybiB0aGlzLmF0dGFjaChtZXRob2ROYW1lLCBrZXksIGZuLCB0cnVlKTtcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2RzIGlzIGp1c3QgYW4gaGVscGVyIHRvIGRlYWwgd2l0aCBjdXN0b20gaW5kZXhlcy4gSXQgdGFrZXMgYXNcbiAgICogYXJndW1lbnRzIHRoZSBuYW1lIG9mIHRoZSBpbmRleCBhbmQgYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSBkaWZmZXJlbnRcbiAgICogZnVuY3Rpb25zIHRvIGJpbmQgdG8gdGhlIG1ldGhvZHMuXG4gICAqXG4gICAqIEhlcmUgaXMgYSBiYXNpYyBleGFtcGxlLCB0aGF0IGNyZWF0ZXMgYW4gaW5kZXggdG8ga2VlcCB0aGUgbnVtYmVyIG9mIG5vZGVzXG4gICAqIGluIHRoZSBjdXJyZW50IGdyYXBoLiBJdCBhbHNvIGFkZHMgYSBtZXRob2QgdG8gcHJvdmlkZSBhIGdldHRlciBvbiB0aGF0XG4gICAqIG5ldyBpbmRleDpcbiAgICpcbiAgICogID4gc2lnbWEuY2xhc3Nlcy5ncmFwaC5hZGRJbmRleCgnbm9kZXNDb3VudCcsIHtcbiAgICogID4gICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24oKSB7XG4gICAqICA+ICAgICB0aGlzLm5vZGVzQ291bnQgPSAwO1xuICAgKiAgPiAgIH0sXG4gICAqICA+ICAgYWRkTm9kZTogZnVuY3Rpb24oKSB7XG4gICAqICA+ICAgICB0aGlzLm5vZGVzQ291bnQrKztcbiAgICogID4gICB9LFxuICAgKiAgPiAgIGRyb3BOb2RlOiBmdW5jdGlvbigpIHtcbiAgICogID4gICAgIHRoaXMubm9kZXNDb3VudC0tO1xuICAgKiAgPiAgIH1cbiAgICogID4gfSk7XG4gICAqICA+XG4gICAqICA+IHNpZ21hLmNsYXNzZXMuZ3JhcGguYWRkTWV0aG9kKCdnZXROb2Rlc0NvdW50JywgZnVuY3Rpb24oKSB7XG4gICAqICA+ICAgcmV0dXJuIHRoaXMubm9kZXNDb3VudDtcbiAgICogID4gfSk7XG4gICAqICA+XG4gICAqICA+IHZhciBteUdyYXBoID0gbmV3IHNpZ21hLmNsYXNzZXMuZ3JhcGgoKTtcbiAgICogID4gY29uc29sZS5sb2cobXlHcmFwaC5nZXROb2Rlc0NvdW50KCkpOyAvLyBvdXRwdXRzIDBcbiAgICogID5cbiAgICogID4gbXlHcmFwaC5hZGROb2RlKHsgaWQ6ICcxJyB9KS5hZGROb2RlKHsgaWQ6ICcyJyB9KTtcbiAgICogID4gY29uc29sZS5sb2cobXlHcmFwaC5nZXROb2Rlc0NvdW50KCkpOyAvLyBvdXRwdXRzIDJcbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSBuYW1lICAgICBUaGUgbmFtZSBvZiB0aGUgaW5kZXguXG4gICAqIEBwYXJhbSAge29iamVjdH0gYmluZGluZ3MgVGhlIG9iamVjdCBjb250YWluaW5nIHRoZSBmdW5jdGlvbnMgdG8gYmluZC5cbiAgICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgICBUaGUgZ2xvYmFsIGdyYXBoIGNvbnN0cnVjdG9yLlxuICAgKi9cbiAgZ3JhcGguYWRkSW5kZXggPSBmdW5jdGlvbihuYW1lLCBiaW5kaW5ncykge1xuICAgIGlmIChcbiAgICAgIHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJyB8fFxuICAgICAgT2JqZWN0KGJpbmRpbmdzKSAhPT0gYmluZGluZ3MgfHxcbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggIT09IDJcbiAgICApXG4gICAgICB0aHJvdyAnYWRkSW5kZXg6IFdyb25nIGFyZ3VtZW50cy4nO1xuXG4gICAgaWYgKF9pbmRleGVzW25hbWVdKVxuICAgICAgdGhyb3cgJ1RoZSBpbmRleCBcIicgKyBuYW1lICsgJ1wiIGFscmVhZHkgZXhpc3RzLic7XG5cbiAgICB2YXIgaztcblxuICAgIC8vIFN0b3JlIHRoZSBiaW5kaW5nczpcbiAgICBfaW5kZXhlc1tuYW1lXSA9IGJpbmRpbmdzO1xuXG4gICAgLy8gQXR0YWNoIHRoZSBiaW5kaW5nczpcbiAgICBmb3IgKGsgaW4gYmluZGluZ3MpXG4gICAgICBpZiAodHlwZW9mIGJpbmRpbmdzW2tdICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyAnVGhlIGJpbmRpbmdzIG11c3QgYmUgZnVuY3Rpb25zLic7XG4gICAgICBlbHNlXG4gICAgICAgIGdyYXBoLmF0dGFjaChrLCBuYW1lLCBiaW5kaW5nc1trXSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuXG5cblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgYWRkcyBhIG5vZGUgdG8gdGhlIGdyYXBoLiBUaGUgbm9kZSBtdXN0IGJlIGFuIG9iamVjdCwgd2l0aCBhXG4gICAqIHN0cmluZyB1bmRlciB0aGUga2V5IFwiaWRcIi4gRXhjZXB0IGZvciB0aGlzLCBpdCBpcyBwb3NzaWJsZSB0byBhZGQgYW55XG4gICAqIG90aGVyIGF0dHJpYnV0ZSwgdGhhdCB3aWxsIGJlIHByZXNlcnZlZCBhbGwgYWxvbmcgdGhlIG1hbmlwdWxhdGlvbnMuXG4gICAqXG4gICAqIElmIHRoZSBncmFwaCBvcHRpb24gXCJjbG9uZVwiIGhhcyBhIHRydXRoeSB2YWx1ZSwgdGhlIG5vZGUgd2lsbCBiZSBjbG9uZWRcbiAgICogd2hlbiBhZGRlZCB0byB0aGUgZ3JhcGguIEFsc28sIGlmIHRoZSBncmFwaCBvcHRpb24gXCJpbW11dGFibGVcIiBoYXMgYVxuICAgKiB0cnV0aHkgdmFsdWUsIGl0cyBpZCB3aWxsIGJlIGRlZmluZWQgYXMgaW1tdXRhYmxlLlxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9IG5vZGUgVGhlIG5vZGUgdG8gYWRkLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgVGhlIGdyYXBoIGluc3RhbmNlLlxuICAgKi9cbiAgZ3JhcGguYWRkTWV0aG9kKCdhZGROb2RlJywgZnVuY3Rpb24obm9kZSkge1xuICAgIC8vIENoZWNrIHRoYXQgdGhlIG5vZGUgaXMgYW4gb2JqZWN0IGFuZCBoYXMgYW4gaWQ6XG4gICAgaWYgKE9iamVjdChub2RlKSAhPT0gbm9kZSB8fCBhcmd1bWVudHMubGVuZ3RoICE9PSAxKVxuICAgICAgdGhyb3cgJ2FkZE5vZGU6IFdyb25nIGFyZ3VtZW50cy4nO1xuXG4gICAgaWYgKHR5cGVvZiBub2RlLmlkICE9PSAnc3RyaW5nJyAmJiB0eXBlb2Ygbm9kZS5pZCAhPT0gJ251bWJlcicpXG4gICAgICB0aHJvdyAnVGhlIG5vZGUgbXVzdCBoYXZlIGEgc3RyaW5nIG9yIG51bWJlciBpZC4nO1xuXG4gICAgaWYgKHRoaXMubm9kZXNJbmRleFtub2RlLmlkXSlcbiAgICAgIHRocm93ICdUaGUgbm9kZSBcIicgKyBub2RlLmlkICsgJ1wiIGFscmVhZHkgZXhpc3RzLic7XG5cbiAgICB2YXIgayxcbiAgICAgICAgaWQgPSBub2RlLmlkLFxuICAgICAgICB2YWxpZE5vZGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgLy8gQ2hlY2sgdGhlIFwiY2xvbmVcIiBvcHRpb246XG4gICAgaWYgKHRoaXMuc2V0dGluZ3MoJ2Nsb25lJykpIHtcbiAgICAgIGZvciAoayBpbiBub2RlKVxuICAgICAgICBpZiAoayAhPT0gJ2lkJylcbiAgICAgICAgICB2YWxpZE5vZGVba10gPSBub2RlW2tdO1xuICAgIH0gZWxzZVxuICAgICAgdmFsaWROb2RlID0gbm9kZTtcblxuICAgIC8vIENoZWNrIHRoZSBcImltbXV0YWJsZVwiIG9wdGlvbjpcbiAgICBpZiAodGhpcy5zZXR0aW5ncygnaW1tdXRhYmxlJykpXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmFsaWROb2RlLCAnaWQnLCB7XG4gICAgICAgIHZhbHVlOiBpZCxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgZWxzZVxuICAgICAgdmFsaWROb2RlLmlkID0gaWQ7XG5cbiAgICAvLyBBZGQgZW1wdHkgY29udGFpbmVycyBmb3IgZWRnZXMgaW5kZXhlczpcbiAgICB0aGlzLmluTmVpZ2hib3JzSW5kZXhbaWRdID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLm91dE5laWdoYm9yc0luZGV4W2lkXSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5hbGxOZWlnaGJvcnNJbmRleFtpZF0gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgdGhpcy5pbk5laWdoYm9yc0NvdW50W2lkXSA9IDA7XG4gICAgdGhpcy5vdXROZWlnaGJvcnNDb3VudFtpZF0gPSAwO1xuICAgIHRoaXMuYWxsTmVpZ2hib3JzQ291bnRbaWRdID0gMDtcblxuICAgIC8vIEFkZCB0aGUgbm9kZSB0byBpbmRleGVzOlxuICAgIHRoaXMubm9kZXNBcnJheS5wdXNoKHZhbGlkTm9kZSk7XG4gICAgdGhpcy5ub2Rlc0luZGV4W3ZhbGlkTm9kZS5pZF0gPSB2YWxpZE5vZGU7XG5cbiAgICAvLyBSZXR1cm4gdGhlIGN1cnJlbnQgaW5zdGFuY2U6XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBhZGRzIGFuIGVkZ2UgdG8gdGhlIGdyYXBoLiBUaGUgZWRnZSBtdXN0IGJlIGFuIG9iamVjdCwgd2l0aCBhXG4gICAqIHN0cmluZyB1bmRlciB0aGUga2V5IFwiaWRcIiwgYW5kIHN0cmluZ3MgdW5kZXIgdGhlIGtleXMgXCJzb3VyY2VcIiBhbmRcbiAgICogXCJ0YXJnZXRcIiB0aGF0IGRlc2lnbiBleGlzdGluZyBub2Rlcy4gRXhjZXB0IGZvciB0aGlzLCBpdCBpcyBwb3NzaWJsZSB0b1xuICAgKiBhZGQgYW55IG90aGVyIGF0dHJpYnV0ZSwgdGhhdCB3aWxsIGJlIHByZXNlcnZlZCBhbGwgYWxvbmcgdGhlXG4gICAqIG1hbmlwdWxhdGlvbnMuXG4gICAqXG4gICAqIElmIHRoZSBncmFwaCBvcHRpb24gXCJjbG9uZVwiIGhhcyBhIHRydXRoeSB2YWx1ZSwgdGhlIGVkZ2Ugd2lsbCBiZSBjbG9uZWRcbiAgICogd2hlbiBhZGRlZCB0byB0aGUgZ3JhcGguIEFsc28sIGlmIHRoZSBncmFwaCBvcHRpb24gXCJpbW11dGFibGVcIiBoYXMgYVxuICAgKiB0cnV0aHkgdmFsdWUsIGl0cyBpZCwgc291cmNlIGFuZCB0YXJnZXQgd2lsbCBiZSBkZWZpbmVkIGFzIGltbXV0YWJsZS5cbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSBlZGdlIFRoZSBlZGdlIHRvIGFkZC5cbiAgICogQHJldHVybiB7b2JqZWN0fSAgICAgIFRoZSBncmFwaCBpbnN0YW5jZS5cbiAgICovXG4gIGdyYXBoLmFkZE1ldGhvZCgnYWRkRWRnZScsIGZ1bmN0aW9uKGVkZ2UpIHtcbiAgICAvLyBDaGVjayB0aGF0IHRoZSBlZGdlIGlzIGFuIG9iamVjdCBhbmQgaGFzIGFuIGlkOlxuICAgIGlmIChPYmplY3QoZWRnZSkgIT09IGVkZ2UgfHwgYXJndW1lbnRzLmxlbmd0aCAhPT0gMSlcbiAgICAgIHRocm93ICdhZGRFZGdlOiBXcm9uZyBhcmd1bWVudHMuJztcblxuICAgIGlmICh0eXBlb2YgZWRnZS5pZCAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIGVkZ2UuaWQgIT09ICdudW1iZXInKVxuICAgICAgdGhyb3cgJ1RoZSBlZGdlIG11c3QgaGF2ZSBhIHN0cmluZyBvciBudW1iZXIgaWQuJztcblxuICAgIGlmICgodHlwZW9mIGVkZ2Uuc291cmNlICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgZWRnZS5zb3VyY2UgIT09ICdudW1iZXInKSB8fFxuICAgICAgICAhdGhpcy5ub2Rlc0luZGV4W2VkZ2Uuc291cmNlXSlcbiAgICAgIHRocm93ICdUaGUgZWRnZSBzb3VyY2UgbXVzdCBoYXZlIGFuIGV4aXN0aW5nIG5vZGUgaWQuJztcblxuICAgIGlmICgodHlwZW9mIGVkZ2UudGFyZ2V0ICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgZWRnZS50YXJnZXQgIT09ICdudW1iZXInKSB8fFxuICAgICAgICAhdGhpcy5ub2Rlc0luZGV4W2VkZ2UudGFyZ2V0XSlcbiAgICAgIHRocm93ICdUaGUgZWRnZSB0YXJnZXQgbXVzdCBoYXZlIGFuIGV4aXN0aW5nIG5vZGUgaWQuJztcblxuICAgIGlmICh0aGlzLmVkZ2VzSW5kZXhbZWRnZS5pZF0pXG4gICAgICB0aHJvdyAnVGhlIGVkZ2UgXCInICsgZWRnZS5pZCArICdcIiBhbHJlYWR5IGV4aXN0cy4nO1xuXG4gICAgdmFyIGssXG4gICAgICAgIHZhbGlkRWRnZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICAvLyBDaGVjayB0aGUgXCJjbG9uZVwiIG9wdGlvbjpcbiAgICBpZiAodGhpcy5zZXR0aW5ncygnY2xvbmUnKSkge1xuICAgICAgZm9yIChrIGluIGVkZ2UpXG4gICAgICAgIGlmIChrICE9PSAnaWQnICYmIGsgIT09ICdzb3VyY2UnICYmIGsgIT09ICd0YXJnZXQnKVxuICAgICAgICAgIHZhbGlkRWRnZVtrXSA9IGVkZ2Vba107XG4gICAgfSBlbHNlXG4gICAgICB2YWxpZEVkZ2UgPSBlZGdlO1xuXG4gICAgLy8gQ2hlY2sgdGhlIFwiaW1tdXRhYmxlXCIgb3B0aW9uOlxuICAgIGlmICh0aGlzLnNldHRpbmdzKCdpbW11dGFibGUnKSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZhbGlkRWRnZSwgJ2lkJywge1xuICAgICAgICB2YWx1ZTogZWRnZS5pZCxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YWxpZEVkZ2UsICdzb3VyY2UnLCB7XG4gICAgICAgIHZhbHVlOiBlZGdlLnNvdXJjZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YWxpZEVkZ2UsICd0YXJnZXQnLCB7XG4gICAgICAgIHZhbHVlOiBlZGdlLnRhcmdldCxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbGlkRWRnZS5pZCA9IGVkZ2UuaWQ7XG4gICAgICB2YWxpZEVkZ2Uuc291cmNlID0gZWRnZS5zb3VyY2U7XG4gICAgICB2YWxpZEVkZ2UudGFyZ2V0ID0gZWRnZS50YXJnZXQ7XG4gICAgfVxuXG4gICAgLy8gQWRkIHRoZSBlZGdlIHRvIGluZGV4ZXM6XG4gICAgdGhpcy5lZGdlc0FycmF5LnB1c2godmFsaWRFZGdlKTtcbiAgICB0aGlzLmVkZ2VzSW5kZXhbdmFsaWRFZGdlLmlkXSA9IHZhbGlkRWRnZTtcblxuICAgIGlmICghdGhpcy5pbk5laWdoYm9yc0luZGV4W3ZhbGlkRWRnZS50YXJnZXRdW3ZhbGlkRWRnZS5zb3VyY2VdKVxuICAgICAgdGhpcy5pbk5laWdoYm9yc0luZGV4W3ZhbGlkRWRnZS50YXJnZXRdW3ZhbGlkRWRnZS5zb3VyY2VdID1cbiAgICAgICAgT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmluTmVpZ2hib3JzSW5kZXhbdmFsaWRFZGdlLnRhcmdldF1bdmFsaWRFZGdlLnNvdXJjZV1bdmFsaWRFZGdlLmlkXSA9XG4gICAgICB2YWxpZEVkZ2U7XG5cbiAgICBpZiAoIXRoaXMub3V0TmVpZ2hib3JzSW5kZXhbdmFsaWRFZGdlLnNvdXJjZV1bdmFsaWRFZGdlLnRhcmdldF0pXG4gICAgICB0aGlzLm91dE5laWdoYm9yc0luZGV4W3ZhbGlkRWRnZS5zb3VyY2VdW3ZhbGlkRWRnZS50YXJnZXRdID1cbiAgICAgICAgT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLm91dE5laWdoYm9yc0luZGV4W3ZhbGlkRWRnZS5zb3VyY2VdW3ZhbGlkRWRnZS50YXJnZXRdW3ZhbGlkRWRnZS5pZF0gPVxuICAgICAgdmFsaWRFZGdlO1xuXG4gICAgaWYgKCF0aGlzLmFsbE5laWdoYm9yc0luZGV4W3ZhbGlkRWRnZS5zb3VyY2VdW3ZhbGlkRWRnZS50YXJnZXRdKVxuICAgICAgdGhpcy5hbGxOZWlnaGJvcnNJbmRleFt2YWxpZEVkZ2Uuc291cmNlXVt2YWxpZEVkZ2UudGFyZ2V0XSA9XG4gICAgICAgIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5hbGxOZWlnaGJvcnNJbmRleFt2YWxpZEVkZ2Uuc291cmNlXVt2YWxpZEVkZ2UudGFyZ2V0XVt2YWxpZEVkZ2UuaWRdID1cbiAgICAgIHZhbGlkRWRnZTtcblxuICAgIGlmICh2YWxpZEVkZ2UudGFyZ2V0ICE9PSB2YWxpZEVkZ2Uuc291cmNlKSB7XG4gICAgICBpZiAoIXRoaXMuYWxsTmVpZ2hib3JzSW5kZXhbdmFsaWRFZGdlLnRhcmdldF1bdmFsaWRFZGdlLnNvdXJjZV0pXG4gICAgICAgIHRoaXMuYWxsTmVpZ2hib3JzSW5kZXhbdmFsaWRFZGdlLnRhcmdldF1bdmFsaWRFZGdlLnNvdXJjZV0gPVxuICAgICAgICAgIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB0aGlzLmFsbE5laWdoYm9yc0luZGV4W3ZhbGlkRWRnZS50YXJnZXRdW3ZhbGlkRWRnZS5zb3VyY2VdW3ZhbGlkRWRnZS5pZF0gPVxuICAgICAgICB2YWxpZEVkZ2U7XG4gICAgfVxuXG4gICAgLy8gS2VlcCBjb3VudHMgdXAgdG8gZGF0ZTpcbiAgICB0aGlzLmluTmVpZ2hib3JzQ291bnRbdmFsaWRFZGdlLnRhcmdldF0rKztcbiAgICB0aGlzLm91dE5laWdoYm9yc0NvdW50W3ZhbGlkRWRnZS5zb3VyY2VdKys7XG4gICAgdGhpcy5hbGxOZWlnaGJvcnNDb3VudFt2YWxpZEVkZ2UudGFyZ2V0XSsrO1xuICAgIHRoaXMuYWxsTmVpZ2hib3JzQ291bnRbdmFsaWRFZGdlLnNvdXJjZV0rKztcblxuICAgIHJldHVybiB0aGlzO1xuICB9KTtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgZHJvcHMgYSBub2RlIGZyb20gdGhlIGdyYXBoLiBJdCBhbHNvIHJlbW92ZXMgZWFjaCBlZGdlIHRoYXQgaXNcbiAgICogYm91bmQgdG8gaXQsIHRocm91Z2ggdGhlIGRyb3BFZGdlIG1ldGhvZC4gQW4gZXJyb3IgaXMgdGhyb3duIGlmIHRoZSBub2RlXG4gICAqIGRvZXMgbm90IGV4aXN0LlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IGlkIFRoZSBub2RlIGlkLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgIFRoZSBncmFwaCBpbnN0YW5jZS5cbiAgICovXG4gIGdyYXBoLmFkZE1ldGhvZCgnZHJvcE5vZGUnLCBmdW5jdGlvbihpZCkge1xuICAgIC8vIENoZWNrIHRoYXQgdGhlIGFyZ3VtZW50cyBhcmUgdmFsaWQ6XG4gICAgaWYgKCh0eXBlb2YgaWQgIT09ICdzdHJpbmcnICYmIHR5cGVvZiBpZCAhPT0gJ251bWJlcicpIHx8XG4gICAgICAgIGFyZ3VtZW50cy5sZW5ndGggIT09IDEpXG4gICAgICB0aHJvdyAnZHJvcE5vZGU6IFdyb25nIGFyZ3VtZW50cy4nO1xuXG4gICAgaWYgKCF0aGlzLm5vZGVzSW5kZXhbaWRdKVxuICAgICAgdGhyb3cgJ1RoZSBub2RlIFwiJyArIGlkICsgJ1wiIGRvZXMgbm90IGV4aXN0Lic7XG5cbiAgICB2YXIgaSwgaywgbDtcblxuICAgIC8vIFJlbW92ZSB0aGUgbm9kZSBmcm9tIGluZGV4ZXM6XG4gICAgZGVsZXRlIHRoaXMubm9kZXNJbmRleFtpZF07XG4gICAgZm9yIChpID0gMCwgbCA9IHRoaXMubm9kZXNBcnJheS5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICBpZiAodGhpcy5ub2Rlc0FycmF5W2ldLmlkID09PSBpZCkge1xuICAgICAgICB0aGlzLm5vZGVzQXJyYXkuc3BsaWNlKGksIDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIC8vIFJlbW92ZSByZWxhdGVkIGVkZ2VzOlxuICAgIGZvciAoaSA9IHRoaXMuZWRnZXNBcnJheS5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgIGlmICh0aGlzLmVkZ2VzQXJyYXlbaV0uc291cmNlID09PSBpZCB8fCB0aGlzLmVkZ2VzQXJyYXlbaV0udGFyZ2V0ID09PSBpZClcbiAgICAgICAgdGhpcy5kcm9wRWRnZSh0aGlzLmVkZ2VzQXJyYXlbaV0uaWQpO1xuXG4gICAgLy8gUmVtb3ZlIHJlbGF0ZWQgZWRnZSBpbmRleGVzOlxuICAgIGRlbGV0ZSB0aGlzLmluTmVpZ2hib3JzSW5kZXhbaWRdO1xuICAgIGRlbGV0ZSB0aGlzLm91dE5laWdoYm9yc0luZGV4W2lkXTtcbiAgICBkZWxldGUgdGhpcy5hbGxOZWlnaGJvcnNJbmRleFtpZF07XG5cbiAgICBkZWxldGUgdGhpcy5pbk5laWdoYm9yc0NvdW50W2lkXTtcbiAgICBkZWxldGUgdGhpcy5vdXROZWlnaGJvcnNDb3VudFtpZF07XG4gICAgZGVsZXRlIHRoaXMuYWxsTmVpZ2hib3JzQ291bnRbaWRdO1xuXG4gICAgZm9yIChrIGluIHRoaXMubm9kZXNJbmRleCkge1xuICAgICAgZGVsZXRlIHRoaXMuaW5OZWlnaGJvcnNJbmRleFtrXVtpZF07XG4gICAgICBkZWxldGUgdGhpcy5vdXROZWlnaGJvcnNJbmRleFtrXVtpZF07XG4gICAgICBkZWxldGUgdGhpcy5hbGxOZWlnaGJvcnNJbmRleFtrXVtpZF07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBkcm9wcyBhbiBlZGdlIGZyb20gdGhlIGdyYXBoLiBBbiBlcnJvciBpcyB0aHJvd24gaWYgdGhlIGVkZ2VcbiAgICogZG9lcyBub3QgZXhpc3QuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gaWQgVGhlIGVkZ2UgaWQuXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgVGhlIGdyYXBoIGluc3RhbmNlLlxuICAgKi9cbiAgZ3JhcGguYWRkTWV0aG9kKCdkcm9wRWRnZScsIGZ1bmN0aW9uKGlkKSB7XG4gICAgLy8gQ2hlY2sgdGhhdCB0aGUgYXJndW1lbnRzIGFyZSB2YWxpZDpcbiAgICBpZiAoKHR5cGVvZiBpZCAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIGlkICE9PSAnbnVtYmVyJykgfHxcbiAgICAgICAgYXJndW1lbnRzLmxlbmd0aCAhPT0gMSlcbiAgICAgIHRocm93ICdkcm9wRWRnZTogV3JvbmcgYXJndW1lbnRzLic7XG5cbiAgICBpZiAoIXRoaXMuZWRnZXNJbmRleFtpZF0pXG4gICAgICB0aHJvdyAnVGhlIGVkZ2UgXCInICsgaWQgKyAnXCIgZG9lcyBub3QgZXhpc3QuJztcblxuICAgIHZhciBpLCBsLCBlZGdlO1xuXG4gICAgLy8gUmVtb3ZlIHRoZSBlZGdlIGZyb20gaW5kZXhlczpcbiAgICBlZGdlID0gdGhpcy5lZGdlc0luZGV4W2lkXTtcbiAgICBkZWxldGUgdGhpcy5lZGdlc0luZGV4W2lkXTtcbiAgICBmb3IgKGkgPSAwLCBsID0gdGhpcy5lZGdlc0FycmF5Lmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgIGlmICh0aGlzLmVkZ2VzQXJyYXlbaV0uaWQgPT09IGlkKSB7XG4gICAgICAgIHRoaXMuZWRnZXNBcnJheS5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgZGVsZXRlIHRoaXMuaW5OZWlnaGJvcnNJbmRleFtlZGdlLnRhcmdldF1bZWRnZS5zb3VyY2VdW2VkZ2UuaWRdO1xuICAgIGlmICghT2JqZWN0LmtleXModGhpcy5pbk5laWdoYm9yc0luZGV4W2VkZ2UudGFyZ2V0XVtlZGdlLnNvdXJjZV0pLmxlbmd0aClcbiAgICAgIGRlbGV0ZSB0aGlzLmluTmVpZ2hib3JzSW5kZXhbZWRnZS50YXJnZXRdW2VkZ2Uuc291cmNlXTtcblxuICAgIGRlbGV0ZSB0aGlzLm91dE5laWdoYm9yc0luZGV4W2VkZ2Uuc291cmNlXVtlZGdlLnRhcmdldF1bZWRnZS5pZF07XG4gICAgaWYgKCFPYmplY3Qua2V5cyh0aGlzLm91dE5laWdoYm9yc0luZGV4W2VkZ2Uuc291cmNlXVtlZGdlLnRhcmdldF0pLmxlbmd0aClcbiAgICAgIGRlbGV0ZSB0aGlzLm91dE5laWdoYm9yc0luZGV4W2VkZ2Uuc291cmNlXVtlZGdlLnRhcmdldF07XG5cbiAgICBkZWxldGUgdGhpcy5hbGxOZWlnaGJvcnNJbmRleFtlZGdlLnNvdXJjZV1bZWRnZS50YXJnZXRdW2VkZ2UuaWRdO1xuICAgIGlmICghT2JqZWN0LmtleXModGhpcy5hbGxOZWlnaGJvcnNJbmRleFtlZGdlLnNvdXJjZV1bZWRnZS50YXJnZXRdKS5sZW5ndGgpXG4gICAgICBkZWxldGUgdGhpcy5hbGxOZWlnaGJvcnNJbmRleFtlZGdlLnNvdXJjZV1bZWRnZS50YXJnZXRdO1xuXG4gICAgaWYgKGVkZ2UudGFyZ2V0ICE9PSBlZGdlLnNvdXJjZSkge1xuICAgICAgZGVsZXRlIHRoaXMuYWxsTmVpZ2hib3JzSW5kZXhbZWRnZS50YXJnZXRdW2VkZ2Uuc291cmNlXVtlZGdlLmlkXTtcbiAgICAgIGlmICghT2JqZWN0LmtleXModGhpcy5hbGxOZWlnaGJvcnNJbmRleFtlZGdlLnRhcmdldF1bZWRnZS5zb3VyY2VdKS5sZW5ndGgpXG4gICAgICAgIGRlbGV0ZSB0aGlzLmFsbE5laWdoYm9yc0luZGV4W2VkZ2UudGFyZ2V0XVtlZGdlLnNvdXJjZV07XG4gICAgfVxuXG4gICAgdGhpcy5pbk5laWdoYm9yc0NvdW50W2VkZ2UudGFyZ2V0XS0tO1xuICAgIHRoaXMub3V0TmVpZ2hib3JzQ291bnRbZWRnZS5zb3VyY2VdLS07XG4gICAgdGhpcy5hbGxOZWlnaGJvcnNDb3VudFtlZGdlLnNvdXJjZV0tLTtcbiAgICB0aGlzLmFsbE5laWdoYm9yc0NvdW50W2VkZ2UudGFyZ2V0XS0tO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBkZXN0cm95cyB0aGUgY3VycmVudCBpbnN0YW5jZS4gSXQgYmFzaWNhbGx5IGVtcHRpZXMgZWFjaCBpbmRleFxuICAgKiBhbmQgbWV0aG9kcyBhdHRhY2hlZCB0byB0aGUgZ3JhcGguXG4gICAqL1xuICBncmFwaC5hZGRNZXRob2QoJ2tpbGwnLCBmdW5jdGlvbigpIHtcbiAgICAvLyBEZWxldGUgYXJyYXlzOlxuICAgIHRoaXMubm9kZXNBcnJheS5sZW5ndGggPSAwO1xuICAgIHRoaXMuZWRnZXNBcnJheS5sZW5ndGggPSAwO1xuICAgIGRlbGV0ZSB0aGlzLm5vZGVzQXJyYXk7XG4gICAgZGVsZXRlIHRoaXMuZWRnZXNBcnJheTtcblxuICAgIC8vIERlbGV0ZSBpbmRleGVzOlxuICAgIGRlbGV0ZSB0aGlzLm5vZGVzSW5kZXg7XG4gICAgZGVsZXRlIHRoaXMuZWRnZXNJbmRleDtcbiAgICBkZWxldGUgdGhpcy5pbk5laWdoYm9yc0luZGV4O1xuICAgIGRlbGV0ZSB0aGlzLm91dE5laWdoYm9yc0luZGV4O1xuICAgIGRlbGV0ZSB0aGlzLmFsbE5laWdoYm9yc0luZGV4O1xuICAgIGRlbGV0ZSB0aGlzLmluTmVpZ2hib3JzQ291bnQ7XG4gICAgZGVsZXRlIHRoaXMub3V0TmVpZ2hib3JzQ291bnQ7XG4gICAgZGVsZXRlIHRoaXMuYWxsTmVpZ2hib3JzQ291bnQ7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBlbXB0aWVzIHRoZSBub2RlcyBhbmQgZWRnZXMgYXJyYXlzLCBhcyB3ZWxsIGFzIHRoZSBkaWZmZXJlbnRcbiAgICogaW5kZXhlcy5cbiAgICpcbiAgICogQHJldHVybiB7b2JqZWN0fSBUaGUgZ3JhcGggaW5zdGFuY2UuXG4gICAqL1xuICBncmFwaC5hZGRNZXRob2QoJ2NsZWFyJywgZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5ub2Rlc0FycmF5Lmxlbmd0aCA9IDA7XG4gICAgdGhpcy5lZGdlc0FycmF5Lmxlbmd0aCA9IDA7XG5cbiAgICAvLyBEdWUgdG8gR0MgaXNzdWVzLCBJIHByZWZlciBub3QgdG8gY3JlYXRlIG5ldyBvYmplY3QuIFRoZXNlIG9iamVjdHMgYXJlXG4gICAgLy8gb25seSBhdmFpbGFibGUgZnJvbSB0aGUgbWV0aG9kcyBhbmQgYXR0YWNoZWQgZnVuY3Rpb25zLCBidXQgc3RpbGwsIGl0IGlzXG4gICAgLy8gYmV0dGVyIHRvIHByZXZlbnQgZ2hvc3QgcmVmZXJlbmNlcyB0byB1bnJlbGV2YW50IGRhdGEuLi5cbiAgICBfX2VtcHR5T2JqZWN0KHRoaXMubm9kZXNJbmRleCk7XG4gICAgX19lbXB0eU9iamVjdCh0aGlzLmVkZ2VzSW5kZXgpO1xuICAgIF9fZW1wdHlPYmplY3QodGhpcy5ub2Rlc0luZGV4KTtcbiAgICBfX2VtcHR5T2JqZWN0KHRoaXMuaW5OZWlnaGJvcnNJbmRleCk7XG4gICAgX19lbXB0eU9iamVjdCh0aGlzLm91dE5laWdoYm9yc0luZGV4KTtcbiAgICBfX2VtcHR5T2JqZWN0KHRoaXMuYWxsTmVpZ2hib3JzSW5kZXgpO1xuICAgIF9fZW1wdHlPYmplY3QodGhpcy5pbk5laWdoYm9yc0NvdW50KTtcbiAgICBfX2VtcHR5T2JqZWN0KHRoaXMub3V0TmVpZ2hib3JzQ291bnQpO1xuICAgIF9fZW1wdHlPYmplY3QodGhpcy5hbGxOZWlnaGJvcnNDb3VudCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHJlYWRzIGFuIG9iamVjdCBhbmQgYWRkcyB0aGUgbm9kZXMgYW5kIGVkZ2VzLCB0aHJvdWdoIHRoZVxuICAgKiBwcm9wZXIgbWV0aG9kcyBcImFkZE5vZGVcIiBhbmQgXCJhZGRFZGdlXCIuXG4gICAqXG4gICAqIEhlcmUgaXMgYW4gZXhhbXBsZTpcbiAgICpcbiAgICogID4gdmFyIG15R3JhcGggPSBuZXcgZ3JhcGgoKTtcbiAgICogID4gbXlHcmFwaC5yZWFkKHtcbiAgICogID4gICBub2RlczogW1xuICAgKiAgPiAgICAgeyBpZDogJ24wJyB9LFxuICAgKiAgPiAgICAgeyBpZDogJ24xJyB9XG4gICAqICA+ICAgXSxcbiAgICogID4gICBlZGdlczogW1xuICAgKiAgPiAgICAge1xuICAgKiAgPiAgICAgICBpZDogJ2UwJyxcbiAgICogID4gICAgICAgc291cmNlOiAnbjAnLFxuICAgKiAgPiAgICAgICB0YXJnZXQ6ICduMSdcbiAgICogID4gICAgIH1cbiAgICogID4gICBdXG4gICAqICA+IH0pO1xuICAgKiAgPlxuICAgKiAgPiBjb25zb2xlLmxvZyhcbiAgICogID4gICBteUdyYXBoLm5vZGVzKCkubGVuZ3RoLFxuICAgKiAgPiAgIG15R3JhcGguZWRnZXMoKS5sZW5ndGhcbiAgICogID4gKTsgLy8gb3V0cHV0cyAyIDFcbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSBnIFRoZSBncmFwaCBvYmplY3QuXG4gICAqIEByZXR1cm4ge29iamVjdH0gICBUaGUgZ3JhcGggaW5zdGFuY2UuXG4gICAqL1xuICBncmFwaC5hZGRNZXRob2QoJ3JlYWQnLCBmdW5jdGlvbihnKSB7XG4gICAgdmFyIGksXG4gICAgICAgIGEsXG4gICAgICAgIGw7XG5cbiAgICBhID0gZy5ub2RlcyB8fCBbXTtcbiAgICBmb3IgKGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICB0aGlzLmFkZE5vZGUoYVtpXSk7XG5cbiAgICBhID0gZy5lZGdlcyB8fCBbXTtcbiAgICBmb3IgKGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICB0aGlzLmFkZEVkZ2UoYVtpXSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kcyByZXR1cm5zIG9uZSBvciBzZXZlcmFsIG5vZGVzLCBkZXBlbmRpbmcgb24gaG93IGl0IGlzIGNhbGxlZC5cbiAgICpcbiAgICogVG8gZ2V0IHRoZSBhcnJheSBvZiBub2RlcywgY2FsbCBcIm5vZGVzXCIgd2l0aG91dCBhcmd1bWVudC4gVG8gZ2V0IGFcbiAgICogc3BlY2lmaWMgbm9kZSwgY2FsbCBpdCB3aXRoIHRoZSBpZCBvZiB0aGUgbm9kZS4gVGhlIGdldCBtdWx0aXBsZSBub2RlLFxuICAgKiBjYWxsIGl0IHdpdGggYW4gYXJyYXkgb2YgaWRzLCBhbmQgaXQgd2lsbCByZXR1cm4gdGhlIGFycmF5IG9mIG5vZGVzLCBpblxuICAgKiB0aGUgc2FtZSBvcmRlci5cbiAgICpcbiAgICogQHBhcmFtICB7PyhzdHJpbmd8YXJyYXkpfSB2IEV2ZW50dWFsbHkgb25lIGlkLCBhbiBhcnJheSBvZiBpZHMuXG4gICAqIEByZXR1cm4ge29iamVjdHxhcnJheX0gICAgICBUaGUgcmVsYXRlZCBub2RlIG9yIGFycmF5IG9mIG5vZGVzLlxuICAgKi9cbiAgZ3JhcGguYWRkTWV0aG9kKCdub2RlcycsIGZ1bmN0aW9uKHYpIHtcbiAgICAvLyBDbG9uZSB0aGUgYXJyYXkgb2Ygbm9kZXMgYW5kIHJldHVybiBpdDpcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICByZXR1cm4gdGhpcy5ub2Rlc0FycmF5LnNsaWNlKDApO1xuXG4gICAgLy8gUmV0dXJuIHRoZSByZWxhdGVkIG5vZGU6XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgKHR5cGVvZiB2ID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdiA9PT0gJ251bWJlcicpKVxuICAgICAgcmV0dXJuIHRoaXMubm9kZXNJbmRleFt2XTtcblxuICAgIC8vIFJldHVybiBhbiBhcnJheSBvZiB0aGUgcmVsYXRlZCBub2RlOlxuICAgIGlmIChcbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiZcbiAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2KSA9PT0gJ1tvYmplY3QgQXJyYXldJ1xuICAgICkge1xuICAgICAgdmFyIGksXG4gICAgICAgICAgbCxcbiAgICAgICAgICBhID0gW107XG5cbiAgICAgIGZvciAoaSA9IDAsIGwgPSB2Lmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgaWYgKHR5cGVvZiB2W2ldID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdltpXSA9PT0gJ251bWJlcicpXG4gICAgICAgICAgYS5wdXNoKHRoaXMubm9kZXNJbmRleFt2W2ldXSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB0aHJvdyAnbm9kZXM6IFdyb25nIGFyZ3VtZW50cy4nO1xuXG4gICAgICByZXR1cm4gYTtcbiAgICB9XG5cbiAgICB0aHJvdyAnbm9kZXM6IFdyb25nIGFyZ3VtZW50cy4nO1xuICB9KTtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2RzIHJldHVybnMgdGhlIGRlZ3JlZSBvZiBvbmUgb3Igc2V2ZXJhbCBub2RlcywgZGVwZW5kaW5nIG9uIGhvd1xuICAgKiBpdCBpcyBjYWxsZWQuIEl0IGlzIGFsc28gcG9zc2libGUgdG8gZ2V0IGluY29taW5nIG9yIG91dGNvbWluZyBkZWdyZWVzXG4gICAqIGluc3RlYWQgYnkgc3BlY2lmeWluZyAnaW4nIG9yICdvdXQnIGFzIGEgc2Vjb25kIGFyZ3VtZW50LlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd8YXJyYXl9IHYgICAgIE9uZSBpZCwgYW4gYXJyYXkgb2YgaWRzLlxuICAgKiBAcGFyYW0gIHs/c3RyaW5nfSAgICAgIHdoaWNoIFdoaWNoIGRlZ3JlZSBpcyByZXF1aXJlZC4gVmFsdWVzIGFyZSAnaW4nLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvdXQnLCBhbmQgYnkgZGVmYXVsdCB0aGUgbm9ybWFsIGRlZ3JlZS5cbiAgICogQHJldHVybiB7bnVtYmVyfGFycmF5fSAgICAgICBUaGUgcmVsYXRlZCBkZWdyZWUgb3IgYXJyYXkgb2YgZGVncmVlcy5cbiAgICovXG4gIGdyYXBoLmFkZE1ldGhvZCgnZGVncmVlJywgZnVuY3Rpb24odiwgd2hpY2gpIHtcbiAgICAvLyBDaGVjayB3aGljaCBkZWdyZWUgaXMgcmVxdWlyZWQ6XG4gICAgd2hpY2ggPSB7XG4gICAgICAnaW4nOiB0aGlzLmluTmVpZ2hib3JzQ291bnQsXG4gICAgICAnb3V0JzogdGhpcy5vdXROZWlnaGJvcnNDb3VudFxuICAgIH1bd2hpY2ggfHwgJyddIHx8IHRoaXMuYWxsTmVpZ2hib3JzQ291bnQ7XG5cbiAgICAvLyBSZXR1cm4gdGhlIHJlbGF0ZWQgbm9kZTpcbiAgICBpZiAodHlwZW9mIHYgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2ID09PSAnbnVtYmVyJylcbiAgICAgIHJldHVybiB3aGljaFt2XTtcblxuICAgIC8vIFJldHVybiBhbiBhcnJheSBvZiB0aGUgcmVsYXRlZCBub2RlOlxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodikgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgIHZhciBpLFxuICAgICAgICAgIGwsXG4gICAgICAgICAgYSA9IFtdO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsID0gdi5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgIGlmICh0eXBlb2YgdltpXSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZbaV0gPT09ICdudW1iZXInKVxuICAgICAgICAgIGEucHVzaCh3aGljaFt2W2ldXSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB0aHJvdyAnZGVncmVlOiBXcm9uZyBhcmd1bWVudHMuJztcblxuICAgICAgcmV0dXJuIGE7XG4gICAgfVxuXG4gICAgdGhyb3cgJ2RlZ3JlZTogV3JvbmcgYXJndW1lbnRzLic7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZHMgcmV0dXJucyBvbmUgb3Igc2V2ZXJhbCBlZGdlcywgZGVwZW5kaW5nIG9uIGhvdyBpdCBpcyBjYWxsZWQuXG4gICAqXG4gICAqIFRvIGdldCB0aGUgYXJyYXkgb2YgZWRnZXMsIGNhbGwgXCJlZGdlc1wiIHdpdGhvdXQgYXJndW1lbnQuIFRvIGdldCBhXG4gICAqIHNwZWNpZmljIGVkZ2UsIGNhbGwgaXQgd2l0aCB0aGUgaWQgb2YgdGhlIGVkZ2UuIFRoZSBnZXQgbXVsdGlwbGUgZWRnZSxcbiAgICogY2FsbCBpdCB3aXRoIGFuIGFycmF5IG9mIGlkcywgYW5kIGl0IHdpbGwgcmV0dXJuIHRoZSBhcnJheSBvZiBlZGdlcywgaW5cbiAgICogdGhlIHNhbWUgb3JkZXIuXG4gICAqXG4gICAqIEBwYXJhbSAgez8oc3RyaW5nfGFycmF5KX0gdiBFdmVudHVhbGx5IG9uZSBpZCwgYW4gYXJyYXkgb2YgaWRzLlxuICAgKiBAcmV0dXJuIHtvYmplY3R8YXJyYXl9ICAgICAgVGhlIHJlbGF0ZWQgZWRnZSBvciBhcnJheSBvZiBlZGdlcy5cbiAgICovXG4gIGdyYXBoLmFkZE1ldGhvZCgnZWRnZXMnLCBmdW5jdGlvbih2KSB7XG4gICAgLy8gQ2xvbmUgdGhlIGFycmF5IG9mIGVkZ2VzIGFuZCByZXR1cm4gaXQ6XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKVxuICAgICAgcmV0dXJuIHRoaXMuZWRnZXNBcnJheS5zbGljZSgwKTtcblxuICAgIC8vIFJldHVybiB0aGUgcmVsYXRlZCBlZGdlOlxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmXG4gICAgICAgICh0eXBlb2YgdiA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHYgPT09ICdudW1iZXInKSlcbiAgICAgIHJldHVybiB0aGlzLmVkZ2VzSW5kZXhbdl07XG5cbiAgICAvLyBSZXR1cm4gYW4gYXJyYXkgb2YgdGhlIHJlbGF0ZWQgZWRnZTpcbiAgICBpZiAoXG4gICAgICBhcmd1bWVudHMubGVuZ3RoID09PSAxICYmXG4gICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodikgPT09ICdbb2JqZWN0IEFycmF5XSdcbiAgICApIHtcbiAgICAgIHZhciBpLFxuICAgICAgICAgIGwsXG4gICAgICAgICAgYSA9IFtdO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsID0gdi5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgIGlmICh0eXBlb2YgdltpXSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZbaV0gPT09ICdudW1iZXInKVxuICAgICAgICAgIGEucHVzaCh0aGlzLmVkZ2VzSW5kZXhbdltpXV0pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgdGhyb3cgJ2VkZ2VzOiBXcm9uZyBhcmd1bWVudHMuJztcblxuICAgICAgcmV0dXJuIGE7XG4gICAgfVxuXG4gICAgdGhyb3cgJ2VkZ2VzOiBXcm9uZyBhcmd1bWVudHMuJztcbiAgfSk7XG5cblxuICAvKipcbiAgICogRVhQT1JUOlxuICAgKiAqKioqKioqXG4gICAqL1xuICBpZiAodHlwZW9mIHNpZ21hICE9PSAndW5kZWZpbmVkJykge1xuICAgIHNpZ21hLmNsYXNzZXMgPSBzaWdtYS5jbGFzc2VzIHx8IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgc2lnbWEuY2xhc3Nlcy5ncmFwaCA9IGdyYXBoO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cylcbiAgICAgIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGdyYXBoO1xuICAgIGV4cG9ydHMuZ3JhcGggPSBncmFwaDtcbiAgfSBlbHNlXG4gICAgdGhpcy5ncmFwaCA9IGdyYXBoO1xufSkuY2FsbCh0aGlzKTtcblxuOyhmdW5jdGlvbih1bmRlZmluZWQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmICh0eXBlb2Ygc2lnbWEgPT09ICd1bmRlZmluZWQnKVxuICAgIHRocm93ICdzaWdtYSBpcyBub3QgZGVjbGFyZWQnO1xuXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuY2xhc3NlcycpO1xuXG4gIC8qKlxuICAgKiBUaGUgY2FtZXJhIGNvbnN0cnVjdG9yLiBJdCBqdXN0IGluaXRpYWxpemVzIGl0cyBhdHRyaWJ1dGVzIGFuZCBtZXRob2RzLlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgICAgIGlkICAgICAgIFRoZSBpZC5cbiAgICogQHBhcmFtICB7c2lnbWEuY2xhc3Nlcy5ncmFwaH0gIGdyYXBoICAgIFRoZSBncmFwaC5cbiAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSBzZXR0aW5ncyBUaGUgc2V0dGluZ3MgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSAgez9vYmplY3R9ICAgICAgb3B0aW9ucyAgRXZlbnR1YWxseSBzb21lIG92ZXJyaWRpbmcgb3B0aW9ucy5cbiAgICogQHJldHVybiB7Y2FtZXJhfSAgICAgICAgICAgICAgICBSZXR1cm5zIHRoZSBmcmVzaCBuZXcgY2FtZXJhIGluc3RhbmNlLlxuICAgKi9cbiAgc2lnbWEuY2xhc3Nlcy5jYW1lcmEgPSBmdW5jdGlvbihpZCwgZ3JhcGgsIHNldHRpbmdzLCBvcHRpb25zKSB7XG4gICAgc2lnbWEuY2xhc3Nlcy5kaXNwYXRjaGVyLmV4dGVuZCh0aGlzKTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnZ3JhcGgnLCB7XG4gICAgICB2YWx1ZTogZ3JhcGhcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2lkJywge1xuICAgICAgdmFsdWU6IGlkXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdyZWFkUHJlZml4Jywge1xuICAgICAgdmFsdWU6ICdyZWFkX2NhbScgKyBpZCArICc6J1xuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncHJlZml4Jywge1xuICAgICAgdmFsdWU6ICdjYW0nICsgaWQgKyAnOidcbiAgICB9KTtcblxuICAgIHRoaXMueCA9IDA7XG4gICAgdGhpcy55ID0gMDtcbiAgICB0aGlzLnJhdGlvID0gMTtcbiAgICB0aGlzLmFuZ2xlID0gMDtcbiAgICB0aGlzLmlzQW5pbWF0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnNldHRpbmdzID0gKHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0JyAmJiBvcHRpb25zKSA/XG4gICAgICBzZXR0aW5ncy5lbWJlZE9iamVjdChvcHRpb25zKSA6XG4gICAgICBzZXR0aW5ncztcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgY2FtZXJhIHBvc2l0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9IGNvb3JkaW5hdGVzIFRoZSBuZXcgY29vcmRpbmF0ZXMgb2JqZWN0LlxuICAgKiBAcmV0dXJuIHtjYW1lcmF9ICAgICAgICAgICAgIFJldHVybnMgdGhlIGNhbWVyYS5cbiAgICovXG4gIHNpZ21hLmNsYXNzZXMuY2FtZXJhLnByb3RvdHlwZS5nb1RvID0gZnVuY3Rpb24oY29vcmRpbmF0ZXMpIHtcbiAgICBpZiAoIXRoaXMuc2V0dGluZ3MoJ2VuYWJsZUNhbWVyYScpKVxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB2YXIgaSxcbiAgICAgICAgbCxcbiAgICAgICAgYyA9IGNvb3JkaW5hdGVzIHx8IHt9LFxuICAgICAgICBrZXlzID0gWyd4JywgJ3knLCAncmF0aW8nLCAnYW5nbGUnXTtcblxuICAgIGZvciAoaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgIGlmIChjW2tleXNbaV1dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjW2tleXNbaV1dID09PSAnbnVtYmVyJyAmJiAhaXNOYU4oY1trZXlzW2ldXSkpXG4gICAgICAgICAgdGhpc1trZXlzW2ldXSA9IGNba2V5c1tpXV07XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB0aHJvdyAnVmFsdWUgZm9yIFwiJyArIGtleXNbaV0gKyAnXCIgaXMgbm90IGEgbnVtYmVyLic7XG4gICAgICB9XG5cbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoJ2Nvb3JkaW5hdGVzVXBkYXRlZCcpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCB0YWtlcyBhIGdyYXBoIGFuZCBjb21wdXRlcyBmb3IgZWFjaCBub2RlIGFuZCBlZGdlcyBpdHNcbiAgICogY29vcmRpbmF0ZXMgcmVsYXRpdmVseSB0byB0aGUgY2VudGVyIG9mIHRoZSBjYW1lcmEuIEJhc2ljYWxseSwgaXQgd2lsbFxuICAgKiBjb21wdXRlIHRoZSBjb29yZGluYXRlcyB0aGF0IHdpbGwgYmUgdXNlZCBieSB0aGUgZ3JhcGhpYyByZW5kZXJlcnMuXG4gICAqXG4gICAqIFNpbmNlIGl0IHNob3VsZCBiZSBwb3NzaWJsZSB0byB1c2UgZGlmZmVyZW50IGNhbWVyYXMgYW5kIGRpZmZlcmVudFxuICAgKiByZW5kZXJlcnMsIGl0IGlzIHBvc3NpYmxlIHRvIHNwZWNpZnkgYSBwcmVmaXggdG8gcHV0IGJlZm9yZSB0aGUgbmV3XG4gICAqIGNvb3JkaW5hdGVzICh0byBnZXQgc29tZXRoaW5nIGxpa2UgXCJub2RlLmNhbWVyYTFfeFwiKVxuICAgKlxuICAgKiBAcGFyYW0gIHs/c3RyaW5nfSByZWFkICAgIFRoZSBwcmVmaXggb2YgdGhlIGNvb3JkaW5hdGVzIHRvIHJlYWQuXG4gICAqIEBwYXJhbSAgez9zdHJpbmd9IHdyaXRlICAgVGhlIHByZWZpeCBvZiB0aGUgY29vcmRpbmF0ZXMgdG8gd3JpdGUuXG4gICAqIEBwYXJhbSAgez9vYmplY3R9IG9wdGlvbnMgRXZlbnR1YWxseSBhbiBvYmplY3Qgb2Ygb3B0aW9ucy4gVGhvc2UgY2FuIGJlOlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gQSByZXN0cmljdGVkIG5vZGVzIGFycmF5LlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gQSByZXN0cmljdGVkIGVkZ2VzIGFycmF5LlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gQSB3aWR0aC5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAtIEEgaGVpZ2h0LlxuICAgKiBAcmV0dXJuIHtjYW1lcmF9ICAgICAgICBSZXR1cm5zIHRoZSBjYW1lcmEuXG4gICAqL1xuICBzaWdtYS5jbGFzc2VzLmNhbWVyYS5wcm90b3R5cGUuYXBwbHlWaWV3ID0gZnVuY3Rpb24ocmVhZCwgd3JpdGUsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB3cml0ZSA9IHdyaXRlICE9PSB1bmRlZmluZWQgPyB3cml0ZSA6IHRoaXMucHJlZml4O1xuICAgIHJlYWQgPSByZWFkICE9PSB1bmRlZmluZWQgPyByZWFkIDogdGhpcy5yZWFkUHJlZml4O1xuXG4gICAgdmFyIG5vZGVzID0gb3B0aW9ucy5ub2RlcyB8fCB0aGlzLmdyYXBoLm5vZGVzKCksXG4gICAgICAgIGVkZ2VzID0gb3B0aW9ucy5lZGdlcyB8fCB0aGlzLmdyYXBoLmVkZ2VzKCk7XG5cbiAgICB2YXIgaSxcbiAgICAgICAgbCxcbiAgICAgICAgbm9kZSxcbiAgICAgICAgcmVsQ29zID0gTWF0aC5jb3ModGhpcy5hbmdsZSkgLyB0aGlzLnJhdGlvLFxuICAgICAgICByZWxTaW4gPSBNYXRoLnNpbih0aGlzLmFuZ2xlKSAvIHRoaXMucmF0aW8sXG4gICAgICAgIG5vZGVSYXRpbyA9IE1hdGgucG93KHRoaXMucmF0aW8sIHRoaXMuc2V0dGluZ3MoJ25vZGVzUG93UmF0aW8nKSksXG4gICAgICAgIGVkZ2VSYXRpbyA9IE1hdGgucG93KHRoaXMucmF0aW8sIHRoaXMuc2V0dGluZ3MoJ2VkZ2VzUG93UmF0aW8nKSksXG4gICAgICAgIHhPZmZzZXQgPSAob3B0aW9ucy53aWR0aCB8fCAwKSAvIDIgLSB0aGlzLnggKiByZWxDb3MgLSB0aGlzLnkgKiByZWxTaW4sXG4gICAgICAgIHlPZmZzZXQgPSAob3B0aW9ucy5oZWlnaHQgfHwgMCkgLyAyIC0gdGhpcy55ICogcmVsQ29zICsgdGhpcy54ICogcmVsU2luO1xuXG4gICAgZm9yIChpID0gMCwgbCA9IG5vZGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgbm9kZVt3cml0ZSArICd4J10gPVxuICAgICAgICAobm9kZVtyZWFkICsgJ3gnXSB8fCAwKSAqIHJlbENvcyArXG4gICAgICAgIChub2RlW3JlYWQgKyAneSddIHx8IDApICogcmVsU2luICtcbiAgICAgICAgeE9mZnNldDtcbiAgICAgIG5vZGVbd3JpdGUgKyAneSddID1cbiAgICAgICAgKG5vZGVbcmVhZCArICd5J10gfHwgMCkgKiByZWxDb3MgLVxuICAgICAgICAobm9kZVtyZWFkICsgJ3gnXSB8fCAwKSAqIHJlbFNpbiArXG4gICAgICAgIHlPZmZzZXQ7XG4gICAgICBub2RlW3dyaXRlICsgJ3NpemUnXSA9XG4gICAgICAgIChub2RlW3JlYWQgKyAnc2l6ZSddIHx8IDApIC9cbiAgICAgICAgbm9kZVJhdGlvO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDAsIGwgPSBlZGdlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGVkZ2VzW2ldW3dyaXRlICsgJ3NpemUnXSA9XG4gICAgICAgIChlZGdlc1tpXVtyZWFkICsgJ3NpemUnXSB8fCAwKSAvXG4gICAgICAgIGVkZ2VSYXRpbztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBjb252ZXJ0cyB0aGUgY29vcmRpbmF0ZXMgb2YgYSBwb2ludCBmcm9tIHRoZSBmcmFtZSBvZiB0aGVcbiAgICogY2FtZXJhIHRvIHRoZSBmcmFtZSBvZiB0aGUgZ3JhcGguXG4gICAqXG4gICAqIEBwYXJhbSAge251bWJlcn0geCBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBwb2ludCBpbiB0aGUgZnJhbWUgb2YgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICBjYW1lcmEuXG4gICAqIEBwYXJhbSAge251bWJlcn0geSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBwb2ludCBpbiB0aGUgZnJhbWUgb2YgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICBjYW1lcmEuXG4gICAqIEByZXR1cm4ge29iamVjdH0gICBUaGUgcG9pbnQgY29vcmRpbmF0ZXMgaW4gdGhlIGZyYW1lIG9mIHRoZSBncmFwaC5cbiAgICovXG4gIHNpZ21hLmNsYXNzZXMuY2FtZXJhLnByb3RvdHlwZS5ncmFwaFBvc2l0aW9uID0gZnVuY3Rpb24oeCwgeSwgdmVjdG9yKSB7XG4gICAgdmFyIFggPSAwLFxuICAgICAgICBZID0gMCxcbiAgICAgICAgY29zID0gTWF0aC5jb3ModGhpcy5hbmdsZSksXG4gICAgICAgIHNpbiA9IE1hdGguc2luKHRoaXMuYW5nbGUpO1xuXG4gICAgLy8gUmV2ZXJ0IHRoZSBvcmlnaW4gZGlmZmVyZW50aWFsIHZlY3RvcjpcbiAgICBpZiAoIXZlY3Rvcikge1xuICAgICAgWCA9IC0gKHRoaXMueCAqIGNvcyArIHRoaXMueSAqIHNpbikgLyB0aGlzLnJhdGlvO1xuICAgICAgWSA9IC0gKHRoaXMueSAqIGNvcyAtIHRoaXMueCAqIHNpbikgLyB0aGlzLnJhdGlvO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB4OiAoeCAqIGNvcyArIHkgKiBzaW4pIC8gdGhpcy5yYXRpbyArIFgsXG4gICAgICB5OiAoeSAqIGNvcyAtIHggKiBzaW4pIC8gdGhpcy5yYXRpbyArIFlcbiAgICB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGNvbnZlcnRzIHRoZSBjb29yZGluYXRlcyBvZiBhIHBvaW50IGZyb20gdGhlIGZyYW1lIG9mIHRoZVxuICAgKiBncmFwaCB0byB0aGUgZnJhbWUgb2YgdGhlIGNhbWVyYS5cbiAgICpcbiAgICogQHBhcmFtICB7bnVtYmVyfSB4IFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IGluIHRoZSBmcmFtZSBvZiB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgIGdyYXBoLlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgaW4gdGhlIGZyYW1lIG9mIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgZ3JhcGguXG4gICAqIEByZXR1cm4ge29iamVjdH0gICBUaGUgcG9pbnQgY29vcmRpbmF0ZXMgaW4gdGhlIGZyYW1lIG9mIHRoZSBjYW1lcmEuXG4gICAqL1xuICBzaWdtYS5jbGFzc2VzLmNhbWVyYS5wcm90b3R5cGUuY2FtZXJhUG9zaXRpb24gPSBmdW5jdGlvbih4LCB5LCB2ZWN0b3IpIHtcbiAgICB2YXIgWCA9IDAsXG4gICAgICAgIFkgPSAwLFxuICAgICAgICBjb3MgPSBNYXRoLmNvcyh0aGlzLmFuZ2xlKSxcbiAgICAgICAgc2luID0gTWF0aC5zaW4odGhpcy5hbmdsZSk7XG5cbiAgICAvLyBSZXZlcnQgdGhlIG9yaWdpbiBkaWZmZXJlbnRpYWwgdmVjdG9yOlxuICAgIGlmICghdmVjdG9yKSB7XG4gICAgICBYID0gLSAodGhpcy54ICogY29zICsgdGhpcy55ICogc2luKSAvIHRoaXMucmF0aW87XG4gICAgICBZID0gLSAodGhpcy55ICogY29zIC0gdGhpcy54ICogc2luKSAvIHRoaXMucmF0aW87XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHg6ICgoeCAtIFgpICogY29zIC0gKHkgLSBZKSAqIHNpbikgKiB0aGlzLnJhdGlvLFxuICAgICAgeTogKCh5IC0gWSkgKiBjb3MgKyAoeCAtIFgpICogc2luKSAqIHRoaXMucmF0aW9cbiAgICB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggb2YgdGhlIGNhbWVyYS4gVGhpcyBpc1xuICAgKiBlc3BlY2lhbGx5IHVzZWZ1bCB0byBhcHBseSB0aGUgY2FtZXJhIHZpZXcgZGlyZWN0bHkgaW4gc2hhZGVycywgaW4gY2FzZSBvZlxuICAgKiBXZWJHTCByZW5kZXJpbmcuXG4gICAqXG4gICAqIEByZXR1cm4ge2FycmF5fSBUaGUgdHJhbnNmb3JtYXRpb24gbWF0cml4LlxuICAgKi9cbiAgc2lnbWEuY2xhc3Nlcy5jYW1lcmEucHJvdG90eXBlLmdldE1hdHJpeCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzY2FsZSA9IHNpZ21hLnV0aWxzLm1hdHJpY2VzLnNjYWxlKDEgLyB0aGlzLnJhdGlvKSxcbiAgICAgICAgcm90YXRpb24gPSBzaWdtYS51dGlscy5tYXRyaWNlcy5yb3RhdGlvbih0aGlzLmFuZ2xlKSxcbiAgICAgICAgdHJhbnNsYXRpb24gPSBzaWdtYS51dGlscy5tYXRyaWNlcy50cmFuc2xhdGlvbigtdGhpcy54LCAtdGhpcy55KSxcbiAgICAgICAgbWF0cml4ID0gc2lnbWEudXRpbHMubWF0cmljZXMubXVsdGlwbHkoXG4gICAgICAgICAgdHJhbnNsYXRpb24sXG4gICAgICAgICAgc2lnbWEudXRpbHMubWF0cmljZXMubXVsdGlwbHkoXG4gICAgICAgICAgICByb3RhdGlvbixcbiAgICAgICAgICAgIHNjYWxlXG4gICAgICAgICAgKVxuICAgICAgICApO1xuXG4gICAgcmV0dXJuIG1hdHJpeDtcbiAgfTtcblxuICAvKipcbiAgICogVGFraW5nIGEgd2lkdGggYW5kIGEgaGVpZ2h0IGFzIHBhcmFtZXRlcnMsIHRoaXMgbWV0aG9kIHJldHVybnMgdGhlXG4gICAqIGNvb3JkaW5hdGVzIG9mIHRoZSByZWN0YW5nbGUgcmVwcmVzZW50aW5nIHRoZSBjYW1lcmEgb24gc2NyZWVuLCBpbiB0aGVcbiAgICogZ3JhcGgncyByZWZlcmVudGllbC5cbiAgICpcbiAgICogVG8ga2VlcCBkaXNwbGF5aW5nIGxhYmVscyBvZiBub2RlcyBnb2luZyBvdXQgb2YgdGhlIHNjcmVlbiwgdGhlIG1ldGhvZFxuICAgKiBrZWVwcyBhIG1hcmdpbiBhcm91bmQgdGhlIHNjcmVlbiBpbiB0aGUgcmV0dXJuZWQgcmVjdGFuZ2xlLlxuICAgKlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHdpZHRoICBUaGUgd2lkdGggb2YgdGhlIHNjcmVlbi5cbiAgICogQHBhcmFtICB7bnVtYmVyfSBoZWlnaHQgVGhlIGhlaWdodCBvZiB0aGUgc2NyZWVuLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgICBUaGUgcmVjdGFuZ2xlIGFzIHgxLCB5MSwgeDIgYW5kIHkyLCByZXByZXNlbnRpbmdcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgdHdvIG9wcG9zaXRlIHBvaW50cy5cbiAgICovXG4gIHNpZ21hLmNsYXNzZXMuY2FtZXJhLnByb3RvdHlwZS5nZXRSZWN0YW5nbGUgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdmFyIHdpZHRoVmVjdCA9IHRoaXMuY2FtZXJhUG9zaXRpb24od2lkdGgsIDAsIHRydWUpLFxuICAgICAgICBoZWlnaHRWZWN0ID0gdGhpcy5jYW1lcmFQb3NpdGlvbigwLCBoZWlnaHQsIHRydWUpLFxuICAgICAgICBjZW50ZXJWZWN0ID0gdGhpcy5jYW1lcmFQb3NpdGlvbih3aWR0aCAvIDIsIGhlaWdodCAvIDIsIHRydWUpLFxuICAgICAgICBtYXJnaW5YID0gdGhpcy5jYW1lcmFQb3NpdGlvbih3aWR0aCAvIDQsIDAsIHRydWUpLngsXG4gICAgICAgIG1hcmdpblkgPSB0aGlzLmNhbWVyYVBvc2l0aW9uKDAsIGhlaWdodCAvIDQsIHRydWUpLnk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgeDE6IHRoaXMueCAtIGNlbnRlclZlY3QueCAtIG1hcmdpblgsXG4gICAgICB5MTogdGhpcy55IC0gY2VudGVyVmVjdC55IC0gbWFyZ2luWSxcbiAgICAgIHgyOiB0aGlzLnggLSBjZW50ZXJWZWN0LnggKyBtYXJnaW5YICsgd2lkdGhWZWN0LngsXG4gICAgICB5MjogdGhpcy55IC0gY2VudGVyVmVjdC55IC0gbWFyZ2luWSArIHdpZHRoVmVjdC55LFxuICAgICAgaGVpZ2h0OiBNYXRoLnNxcnQoXG4gICAgICAgIE1hdGgucG93KGhlaWdodFZlY3QueCwgMikgK1xuICAgICAgICBNYXRoLnBvdyhoZWlnaHRWZWN0LnkgKyAyICogbWFyZ2luWSwgMilcbiAgICAgIClcbiAgICB9O1xuICB9O1xufSkuY2FsbCh0aGlzKTtcblxuOyhmdW5jdGlvbih1bmRlZmluZWQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qKlxuICAgKiBTaWdtYSBRdWFkdHJlZSBNb2R1bGVcbiAgICogPT09PT09PT09PT09PT09PT09PT09XG4gICAqXG4gICAqIEF1dGhvcjogR3VpbGxhdW1lIFBsaXF1ZSAoWW9tZ3VpdGhlcmVhbClcbiAgICogVmVyc2lvbjogMC4yXG4gICAqL1xuXG5cblxuICAvKipcbiAgICogUXVhZCBHZW9tZXRyaWMgT3BlcmF0aW9uc1xuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqXG4gICAqIEEgdXNlZnVsIGJhdGNoIG9mIGdlb21ldHJpYyBvcGVyYXRpb25zIHVzZWQgYnkgdGhlIHF1YWR0cmVlLlxuICAgKi9cblxuICB2YXIgX2dlb20gPSB7XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIGEgZ3JhcGggbm9kZSB3aXRoIHgsIHkgYW5kIHNpemUgaW50byBhblxuICAgICAqIGF4aXMtYWxpZ25lZCBzcXVhcmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IEEgZ3JhcGggbm9kZSB3aXRoIGF0IGxlYXN0IGEgcG9pbnQgKHgsIHkpIGFuZCBhIHNpemUuXG4gICAgICogQHJldHVybiB7b2JqZWN0fSBBIHNxdWFyZTogdHdvIHBvaW50cyAoeDEsIHkxKSwgKHgyLCB5MikgYW5kIGhlaWdodC5cbiAgICAgKi9cbiAgICBwb2ludFRvU3F1YXJlOiBmdW5jdGlvbihuKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4MTogbi54IC0gbi5zaXplLFxuICAgICAgICB5MTogbi55IC0gbi5zaXplLFxuICAgICAgICB4Mjogbi54ICsgbi5zaXplLFxuICAgICAgICB5Mjogbi55IC0gbi5zaXplLFxuICAgICAgICBoZWlnaHQ6IG4uc2l6ZSAqIDJcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIGEgcmVjdGFuZ2xlIGlzIGF4aXMtYWxpZ25lZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gIEEgcmVjdGFuZ2xlIGRlZmluZWQgYnkgdHdvIHBvaW50c1xuICAgICAqICAgICAgICAgICAgICAgICAgICh4MSwgeTEpIGFuZCAoeDIsIHkyKS5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSByZWN0YW5nbGUgaXMgYXhpcy1hbGlnbmVkLlxuICAgICAqL1xuICAgIGlzQXhpc0FsaWduZWQ6IGZ1bmN0aW9uKHIpIHtcbiAgICAgIHJldHVybiByLngxID09PSByLngyIHx8IHIueTEgPT09IHIueTI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbXB1dGUgdG9wIHBvaW50cyBvZiBhbiBheGlzLWFsaWduZWQgcmVjdGFuZ2xlLiBUaGlzIGlzIHVzZWZ1bCBpblxuICAgICAqIGNhc2VzIHdoZW4gdGhlIHJlY3RhbmdsZSBoYXMgYmVlbiByb3RhdGVkIChsZWZ0LCByaWdodCBvciBib3R0b20gdXApIGFuZFxuICAgICAqIGxhdGVyIG9wZXJhdGlvbnMgbmVlZCB0byBrbm93IHRoZSB0b3AgcG9pbnRzLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSBBbiBheGlzLWFsaWduZWQgcmVjdGFuZ2xlIGRlZmluZWQgYnkgdHdvIHBvaW50c1xuICAgICAqICAgICAgICAgICAgICAgICAgKHgxLCB5MSksICh4MiwgeTIpIGFuZCBoZWlnaHQuXG4gICAgICogQHJldHVybiB7b2JqZWN0fSBBIHJlY3RhbmdsZTogdHdvIHBvaW50cyAoeDEsIHkxKSwgKHgyLCB5MikgYW5kIGhlaWdodC5cbiAgICAgKi9cbiAgICBheGlzQWxpZ25lZFRvcFBvaW50czogZnVuY3Rpb24ocikge1xuXG4gICAgICAvLyBCYXNpY1xuICAgICAgaWYgKHIueTEgPT09IHIueTIgJiYgci54MSA8IHIueDIpXG4gICAgICAgIHJldHVybiByO1xuXG4gICAgICAvLyBSb3RhdGVkIHRvIHJpZ2h0XG4gICAgICBpZiAoci54MSA9PT0gci54MiAmJiByLnkyID4gci55MSlcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4MTogci54MSAtIHIuaGVpZ2h0LCB5MTogci55MSxcbiAgICAgICAgICB4Mjogci54MSwgeTI6IHIueTEsXG4gICAgICAgICAgaGVpZ2h0OiByLmhlaWdodFxuICAgICAgICB9O1xuXG4gICAgICAvLyBSb3RhdGVkIHRvIGxlZnRcbiAgICAgIGlmIChyLngxID09PSByLngyICYmIHIueTIgPCByLnkxKVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHgxOiByLngxLCB5MTogci55MixcbiAgICAgICAgICB4Mjogci54MiArIHIuaGVpZ2h0LCB5Mjogci55MixcbiAgICAgICAgICBoZWlnaHQ6IHIuaGVpZ2h0XG4gICAgICAgIH07XG5cbiAgICAgIC8vIEJvdHRvbSdzIHVwXG4gICAgICByZXR1cm4ge1xuICAgICAgICB4MTogci54MiwgeTE6IHIueTEgLSByLmhlaWdodCxcbiAgICAgICAgeDI6IHIueDEsIHkyOiByLnkxIC0gci5oZWlnaHQsXG4gICAgICAgIGhlaWdodDogci5oZWlnaHRcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBjb29yZGluYXRlcyBvZiBhIHJlY3RhbmdsZSdzIGxvd2VyIGxlZnQgY29ybmVyIGZyb20gaXRzIHRvcCBwb2ludHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IEEgcmVjdGFuZ2xlIGRlZmluZWQgYnkgdHdvIHBvaW50cyAoeDEsIHkxKSBhbmQgKHgyLCB5MikuXG4gICAgICogQHJldHVybiB7b2JqZWN0fSBDb29yZGluYXRlcyBvZiB0aGUgY29ybmVyICh4LCB5KS5cbiAgICAgKi9cbiAgICBsb3dlckxlZnRDb29yOiBmdW5jdGlvbihyKSB7XG4gICAgICB2YXIgd2lkdGggPSAoXG4gICAgICAgIE1hdGguc3FydChcbiAgICAgICAgICBNYXRoLnBvdyhyLngyIC0gci54MSwgMikgK1xuICAgICAgICAgIE1hdGgucG93KHIueTIgLSByLnkxLCAyKVxuICAgICAgICApXG4gICAgICApO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiByLngxIC0gKHIueTIgLSByLnkxKSAqIHIuaGVpZ2h0IC8gd2lkdGgsXG4gICAgICAgIHk6IHIueTEgKyAoci54MiAtIHIueDEpICogci5oZWlnaHQgLyB3aWR0aFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGNvb3JkaW5hdGVzIG9mIGEgcmVjdGFuZ2xlJ3MgbG93ZXIgcmlnaHQgY29ybmVyIGZyb20gaXRzIHRvcCBwb2ludHNcbiAgICAgKiBhbmQgaXRzIGxvd2VyIGxlZnQgY29ybmVyLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSBBIHJlY3RhbmdsZSBkZWZpbmVkIGJ5IHR3byBwb2ludHMgKHgxLCB5MSkgYW5kICh4MiwgeTIpLlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gQSBjb3JuZXIncyBjb29yZGluYXRlcyAoeCwgeSkuXG4gICAgICogQHJldHVybiB7b2JqZWN0fSBDb29yZGluYXRlcyBvZiB0aGUgY29ybmVyICh4LCB5KS5cbiAgICAgKi9cbiAgICBsb3dlclJpZ2h0Q29vcjogZnVuY3Rpb24ociwgbGxjKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBsbGMueCAtIHIueDEgKyByLngyLFxuICAgICAgICB5OiBsbGMueSAtIHIueTEgKyByLnkyXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGNvb3JkaW5hdGVzIG9mIGFsbCB0aGUgY29ybmVycyBvZiBhIHJlY3RhbmdsZSBmcm9tIGl0cyB0b3AgcG9pbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IEEgcmVjdGFuZ2xlIGRlZmluZWQgYnkgdHdvIHBvaW50cyAoeDEsIHkxKSBhbmQgKHgyLCB5MikuXG4gICAgICogQHJldHVybiB7YXJyYXl9ICBBbiBhcnJheSBvZiB0aGUgZm91ciBjb3JuZXJzJyBjb29yZGluYXRlcyAoeCwgeSkuXG4gICAgICovXG4gICAgcmVjdGFuZ2xlQ29ybmVyczogZnVuY3Rpb24ocikge1xuICAgICAgdmFyIGxsYyA9IHRoaXMubG93ZXJMZWZ0Q29vcihyKSxcbiAgICAgICAgICBscmMgPSB0aGlzLmxvd2VyUmlnaHRDb29yKHIsIGxsYyk7XG5cbiAgICAgIHJldHVybiBbXG4gICAgICAgIHt4OiByLngxLCB5OiByLnkxfSxcbiAgICAgICAge3g6IHIueDIsIHk6IHIueTJ9LFxuICAgICAgICB7eDogbGxjLngsIHk6IGxsYy55fSxcbiAgICAgICAge3g6IGxyYy54LCB5OiBscmMueX1cbiAgICAgIF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNwbGl0IGEgc3F1YXJlIGRlZmluZWQgYnkgaXRzIGJvdW5kYXJpZXMgaW50byBmb3VyLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSBCb3VuZGFyaWVzIG9mIHRoZSBzcXVhcmUgKHgsIHksIHdpZHRoLCBoZWlnaHQpLlxuICAgICAqIEByZXR1cm4ge2FycmF5fSAgQW4gYXJyYXkgY29udGFpbmluZyB0aGUgZm91ciBuZXcgc3F1YXJlcywgdGhlbXNlbHZlc1xuICAgICAqICAgICAgICAgICAgICAgICAgZGVmaW5lZCBieSBhbiBhcnJheSBvZiB0aGVpciBmb3VyIGNvcm5lcnMgKHgsIHkpLlxuICAgICAqL1xuICAgIHNwbGl0U3F1YXJlOiBmdW5jdGlvbihiKSB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICBbXG4gICAgICAgICAge3g6IGIueCwgeTogYi55fSxcbiAgICAgICAgICB7eDogYi54ICsgYi53aWR0aCAvIDIsIHk6IGIueX0sXG4gICAgICAgICAge3g6IGIueCwgeTogYi55ICsgYi5oZWlnaHQgLyAyfSxcbiAgICAgICAgICB7eDogYi54ICsgYi53aWR0aCAvIDIsIHk6IGIueSArIGIuaGVpZ2h0IC8gMn1cbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIHt4OiBiLnggKyBiLndpZHRoIC8gMiwgeTogYi55fSxcbiAgICAgICAgICB7eDogYi54ICsgYi53aWR0aCwgeTogYi55fSxcbiAgICAgICAgICB7eDogYi54ICsgYi53aWR0aCAvIDIsIHk6IGIueSArIGIuaGVpZ2h0IC8gMn0sXG4gICAgICAgICAge3g6IGIueCArIGIud2lkdGgsIHk6IGIueSArIGIuaGVpZ2h0IC8gMn1cbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIHt4OiBiLngsIHk6IGIueSArIGIuaGVpZ2h0IC8gMn0sXG4gICAgICAgICAge3g6IGIueCArIGIud2lkdGggLyAyLCB5OiBiLnkgKyBiLmhlaWdodCAvIDJ9LFxuICAgICAgICAgIHt4OiBiLngsIHk6IGIueSArIGIuaGVpZ2h0fSxcbiAgICAgICAgICB7eDogYi54ICsgYi53aWR0aCAvIDIsIHk6IGIueSArIGIuaGVpZ2h0fVxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAge3g6IGIueCArIGIud2lkdGggLyAyLCB5OiBiLnkgKyBiLmhlaWdodCAvIDJ9LFxuICAgICAgICAgIHt4OiBiLnggKyBiLndpZHRoLCB5OiBiLnkgKyBiLmhlaWdodCAvIDJ9LFxuICAgICAgICAgIHt4OiBiLnggKyBiLndpZHRoIC8gMiwgeTogYi55ICsgYi5oZWlnaHR9LFxuICAgICAgICAgIHt4OiBiLnggKyBiLndpZHRoLCB5OiBiLnkgKyBiLmhlaWdodH1cbiAgICAgICAgXVxuICAgICAgXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZSB0aGUgZm91ciBheGlzIGJldHdlZW4gY29ybmVycyBvZiByZWN0YW5nbGUgQSBhbmQgY29ybmVycyBvZlxuICAgICAqIHJlY3RhbmdsZSBCLiBUaGlzIGlzIG5lZWRlZCBsYXRlciB0byBjaGVjayBhbiBldmVudHVhbCBjb2xsaXNpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHthcnJheX0gQW4gYXJyYXkgb2YgcmVjdGFuZ2xlIEEncyBmb3VyIGNvcm5lcnMgKHgsIHkpLlxuICAgICAqIEBwYXJhbSAge2FycmF5fSBBbiBhcnJheSBvZiByZWN0YW5nbGUgQidzIGZvdXIgY29ybmVycyAoeCwgeSkuXG4gICAgICogQHJldHVybiB7YXJyYXl9IEFuIGFycmF5IG9mIGZvdXIgYXhpcyBkZWZpbmVkIGJ5IHRoZWlyIGNvb3JkaW5hdGVzICh4LHkpLlxuICAgICAqL1xuICAgIGF4aXM6IGZ1bmN0aW9uKGMxLCBjMikge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAge3g6IGMxWzFdLnggLSBjMVswXS54LCB5OiBjMVsxXS55IC0gYzFbMF0ueX0sXG4gICAgICAgIHt4OiBjMVsxXS54IC0gYzFbM10ueCwgeTogYzFbMV0ueSAtIGMxWzNdLnl9LFxuICAgICAgICB7eDogYzJbMF0ueCAtIGMyWzJdLngsIHk6IGMyWzBdLnkgLSBjMlsyXS55fSxcbiAgICAgICAge3g6IGMyWzBdLnggLSBjMlsxXS54LCB5OiBjMlswXS55IC0gYzJbMV0ueX1cbiAgICAgIF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByb2plY3QgYSByZWN0YW5nbGUncyBjb3JuZXIgb24gYW4gYXhpcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gQ29vcmRpbmF0ZXMgb2YgYSBjb3JuZXIgKHgsIHkpLlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gQ29vcmRpbmF0ZXMgb2YgYW4gYXhpcyAoeCwgeSkuXG4gICAgICogQHJldHVybiB7b2JqZWN0fSBUaGUgcHJvamVjdGlvbiBkZWZpbmVkIGJ5IGNvb3JkaW5hdGVzICh4LCB5KS5cbiAgICAgKi9cbiAgICBwcm9qZWN0aW9uOiBmdW5jdGlvbihjLCBhKSB7XG4gICAgICB2YXIgbCA9IChcbiAgICAgICAgKGMueCAqIGEueCArIGMueSAqIGEueSkgL1xuICAgICAgICAoTWF0aC5wb3coYS54LCAyKSArIE1hdGgucG93KGEueSwgMikpXG4gICAgICApO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBsICogYS54LFxuICAgICAgICB5OiBsICogYS55XG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayB3aGV0aGVyIHR3byByZWN0YW5nbGVzIGNvbGxpZGUgb24gb25lIHBhcnRpY3VsYXIgYXhpcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gICBBbiBheGlzJyBjb29yZGluYXRlcyAoeCwgeSkuXG4gICAgICogQHBhcmFtICB7YXJyYXl9ICAgIFJlY3RhbmdsZSBBJ3MgY29ybmVycy5cbiAgICAgKiBAcGFyYW0gIHthcnJheX0gICAgUmVjdGFuZ2xlIEIncyBjb3JuZXJzLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59ICBUcnVlIGlmIHRoZSByZWN0YW5nbGVzIGNvbGxpZGUgb24gdGhlIGF4aXMuXG4gICAgICovXG4gICAgYXhpc0NvbGxpc2lvbjogZnVuY3Rpb24oYSwgYzEsIGMyKSB7XG4gICAgICB2YXIgc2MxID0gW10sXG4gICAgICAgICAgc2MyID0gW107XG5cbiAgICAgIGZvciAodmFyIGNpID0gMDsgY2kgPCA0OyBjaSsrKSB7XG4gICAgICAgIHZhciBwMSA9IHRoaXMucHJvamVjdGlvbihjMVtjaV0sIGEpLFxuICAgICAgICAgICAgcDIgPSB0aGlzLnByb2plY3Rpb24oYzJbY2ldLCBhKTtcblxuICAgICAgICBzYzEucHVzaChwMS54ICogYS54ICsgcDEueSAqIGEueSk7XG4gICAgICAgIHNjMi5wdXNoKHAyLnggKiBhLnggKyBwMi55ICogYS55KTtcbiAgICAgIH1cblxuICAgICAgdmFyIG1heGMxID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgc2MxKSxcbiAgICAgICAgICBtYXhjMiA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIHNjMiksXG4gICAgICAgICAgbWluYzEgPSBNYXRoLm1pbi5hcHBseShNYXRoLCBzYzEpLFxuICAgICAgICAgIG1pbmMyID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgc2MyKTtcblxuICAgICAgcmV0dXJuIChtaW5jMiA8PSBtYXhjMSAmJiBtYXhjMiA+PSBtaW5jMSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIHdoZXRoZXIgdHdvIHJlY3RhbmdsZXMgY29sbGlkZSBvbiBlYWNoIG9uZSBvZiB0aGVpciBmb3VyIGF4aXMuIElmXG4gICAgICogYWxsIGF4aXMgY29sbGlkZSwgdGhlbiB0aGUgdHdvIHJlY3RhbmdsZXMgZG8gY29sbGlkZSBvbiB0aGUgcGxhbmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHthcnJheX0gICAgUmVjdGFuZ2xlIEEncyBjb3JuZXJzLlxuICAgICAqIEBwYXJhbSAge2FycmF5fSAgICBSZWN0YW5nbGUgQidzIGNvcm5lcnMuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gIFRydWUgaWYgdGhlIHJlY3RhbmdsZXMgY29sbGlkZS5cbiAgICAgKi9cbiAgICBjb2xsaXNpb246IGZ1bmN0aW9uKGMxLCBjMikge1xuICAgICAgdmFyIGF4aXMgPSB0aGlzLmF4aXMoYzEsIGMyKSxcbiAgICAgICAgICBjb2wgPSB0cnVlO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKylcbiAgICAgICAgY29sID0gY29sICYmIHRoaXMuYXhpc0NvbGxpc2lvbihheGlzW2ldLCBjMSwgYzIpO1xuXG4gICAgICByZXR1cm4gY29sO1xuICAgIH1cbiAgfTtcblxuXG4gIC8qKlxuICAgKiBRdWFkIEZ1bmN0aW9uc1xuICAgKiAtLS0tLS0tLS0tLS1cbiAgICpcbiAgICogVGhlIFF1YWR0cmVlIGZ1bmN0aW9ucyB0aGVtc2VsdmVzLlxuICAgKiBGb3IgZWFjaCBvZiB0aG9zZSBmdW5jdGlvbnMsIHdlIGNvbnNpZGVyIHRoYXQgaW4gYSBzcGxpdHRlZCBxdWFkLCB0aGVcbiAgICogaW5kZXggb2YgZWFjaCBub2RlIGlzIHRoZSBmb2xsb3dpbmc6XG4gICAqIDA6IHRvcCBsZWZ0XG4gICAqIDE6IHRvcCByaWdodFxuICAgKiAyOiBib3R0b20gbGVmdFxuICAgKiAzOiBib3R0b20gcmlnaHRcbiAgICpcbiAgICogTW9yZW92ZXIsIHRoZSBoZXJlYWZ0ZXIgcXVhZCdzIHBoaWxvc29waHkgaXMgdG8gY29uc2lkZXIgdGhhdCBpZiBhbiBlbGVtZW50XG4gICAqIGNvbGxpZGVzIHdpdGggbW9yZSB0aGFuIG9uZSBub2RlcywgdGhpcyBlbGVtZW50IGJlbG9uZ3MgdG8gZWFjaCBvZiB0aGVcbiAgICogbm9kZXMgaXQgY29sbGlkZXMgd2l0aCB3aGVyZSBvdGhlciB3b3VsZCBsZXQgaXQgbGllIG9uIGEgaGlnaGVyIG5vZGUuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGluZGV4IG9mIHRoZSBub2RlIGNvbnRhaW5pbmcgdGhlIHBvaW50IGluIHRoZSBxdWFkXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gIHBvaW50ICAgICAgQSBwb2ludCBkZWZpbmVkIGJ5IGNvb3JkaW5hdGVzICh4LCB5KS5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgcXVhZEJvdW5kcyBCb3VuZGFyaWVzIG9mIHRoZSBxdWFkICh4LCB5LCB3aWR0aCwgaGVpZ3RoKS5cbiAgICogQHJldHVybiB7aW50ZWdlcn0gICAgICAgICAgICBUaGUgaW5kZXggb2YgdGhlIG5vZGUgY29udGFpbmluZyB0aGUgcG9pbnQuXG4gICAqL1xuICBmdW5jdGlvbiBfcXVhZEluZGV4KHBvaW50LCBxdWFkQm91bmRzKSB7XG4gICAgdmFyIHhtcCA9IHF1YWRCb3VuZHMueCArIHF1YWRCb3VuZHMud2lkdGggLyAyLFxuICAgICAgICB5bXAgPSBxdWFkQm91bmRzLnkgKyBxdWFkQm91bmRzLmhlaWdodCAvIDIsXG4gICAgICAgIHRvcCA9IChwb2ludC55IDwgeW1wKSxcbiAgICAgICAgbGVmdCA9IChwb2ludC54IDwgeG1wKTtcblxuICAgIGlmICh0b3ApIHtcbiAgICAgIGlmIChsZWZ0KVxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaWYgKGxlZnQpXG4gICAgICAgIHJldHVybiAyO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gMztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgbGlzdCBvZiBpbmRleGVzIG9mIG5vZGVzIGNvbnRhaW5pbmcgYW4gYXhpcy1hbGlnbmVkIHJlY3RhbmdsZVxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICByZWN0YW5nbGUgICBBIHJlY3RhbmdsZSBkZWZpbmVkIGJ5IHR3byBwb2ludHMgKHgxLCB5MSksXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh4MiwgeTIpIGFuZCBoZWlnaHQuXG4gICAqIEBwYXJhbSAge2FycmF5fSAgIHF1YWRDb3JuZXJzIEFuIGFycmF5IG9mIHRoZSBxdWFkIG5vZGVzJyBjb3JuZXJzLlxuICAgKiBAcmV0dXJuIHthcnJheX0gICAgICAgICAgICAgICBBbiBhcnJheSBvZiBpbmRleGVzIGNvbnRhaW5pbmcgb25lIHRvXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdXIgaW50ZWdlcnMuXG4gICAqL1xuICBmdW5jdGlvbiBfcXVhZEluZGV4ZXMocmVjdGFuZ2xlLCBxdWFkQ29ybmVycykge1xuICAgIHZhciBpbmRleGVzID0gW107XG5cbiAgICAvLyBJdGVyYXRpbmcgdGhyb3VnaCBxdWFkc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKVxuICAgICAgaWYgKChyZWN0YW5nbGUueDIgPj0gcXVhZENvcm5lcnNbaV1bMF0ueCkgJiZcbiAgICAgICAgICAocmVjdGFuZ2xlLngxIDw9IHF1YWRDb3JuZXJzW2ldWzFdLngpICYmXG4gICAgICAgICAgKHJlY3RhbmdsZS55MSArIHJlY3RhbmdsZS5oZWlnaHQgPj0gcXVhZENvcm5lcnNbaV1bMF0ueSkgJiZcbiAgICAgICAgICAocmVjdGFuZ2xlLnkxIDw9IHF1YWRDb3JuZXJzW2ldWzJdLnkpKVxuICAgICAgICBpbmRleGVzLnB1c2goaSk7XG5cbiAgICByZXR1cm4gaW5kZXhlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSBsaXN0IG9mIGluZGV4ZXMgb2Ygbm9kZXMgY29udGFpbmluZyBhIG5vbi1heGlzLWFsaWduZWQgcmVjdGFuZ2xlXG4gICAqXG4gICAqIEBwYXJhbSAge2FycmF5fSAgY29ybmVycyAgICAgIEFuIGFycmF5IGNvbnRhaW5pbmcgZWFjaCBjb3JuZXIgb2YgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY3RhbmdsZSBkZWZpbmVkIGJ5IGl0cyBjb29yZGluYXRlcyAoeCwgeSkuXG4gICAqIEBwYXJhbSAge2FycmF5fSAgcXVhZENvcm5lcnMgIEFuIGFycmF5IG9mIHRoZSBxdWFkIG5vZGVzJyBjb3JuZXJzLlxuICAgKiBAcmV0dXJuIHthcnJheX0gICAgICAgICAgICAgICBBbiBhcnJheSBvZiBpbmRleGVzIGNvbnRhaW5pbmcgb25lIHRvXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdXIgaW50ZWdlcnMuXG4gICAqL1xuICBmdW5jdGlvbiBfcXVhZENvbGxpc2lvbihjb3JuZXJzLCBxdWFkQ29ybmVycykge1xuICAgIHZhciBpbmRleGVzID0gW107XG5cbiAgICAvLyBJdGVyYXRpbmcgdGhyb3VnaCBxdWFkc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKVxuICAgICAgaWYgKF9nZW9tLmNvbGxpc2lvbihjb3JuZXJzLCBxdWFkQ29ybmVyc1tpXSkpXG4gICAgICAgIGluZGV4ZXMucHVzaChpKTtcblxuICAgIHJldHVybiBpbmRleGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIFN1YmRpdmlkZSBhIHF1YWQgYnkgY3JlYXRpbmcgYSBub2RlIGF0IGEgcHJlY2lzZSBpbmRleC4gVGhlIGZ1bmN0aW9uIGRvZXNcbiAgICogbm90IGdlbmVyYXRlIGFsbCBmb3VyIG5vZGVzIG5vdCB0byBwb3RlbnRpYWxseSBjcmVhdGUgdW51c2VkIG5vZGVzLlxuICAgKlxuICAgKiBAcGFyYW0gIHtpbnRlZ2VyfSAgaW5kZXggVGhlIGluZGV4IG9mIHRoZSBub2RlIHRvIGNyZWF0ZS5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgIHF1YWQgIFRoZSBxdWFkIG9iamVjdCB0byBzdWJkaXZpZGUuXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICBBIG5ldyBxdWFkIHJlcHJlc2VudGluZyB0aGUgbm9kZSBjcmVhdGVkLlxuICAgKi9cbiAgZnVuY3Rpb24gX3F1YWRTdWJkaXZpZGUoaW5kZXgsIHF1YWQpIHtcbiAgICB2YXIgbmV4dCA9IHF1YWQubGV2ZWwgKyAxLFxuICAgICAgICBzdWJ3ID0gTWF0aC5yb3VuZChxdWFkLmJvdW5kcy53aWR0aCAvIDIpLFxuICAgICAgICBzdWJoID0gTWF0aC5yb3VuZChxdWFkLmJvdW5kcy5oZWlnaHQgLyAyKSxcbiAgICAgICAgcXggPSBNYXRoLnJvdW5kKHF1YWQuYm91bmRzLngpLFxuICAgICAgICBxeSA9IE1hdGgucm91bmQocXVhZC5ib3VuZHMueSksXG4gICAgICAgIHgsXG4gICAgICAgIHk7XG5cbiAgICBzd2l0Y2ggKGluZGV4KSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHggPSBxeDtcbiAgICAgICAgeSA9IHF5O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgeCA9IHF4ICsgc3VidztcbiAgICAgICAgeSA9IHF5O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgeCA9IHF4O1xuICAgICAgICB5ID0gcXkgKyBzdWJoO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgeCA9IHF4ICsgc3VidztcbiAgICAgICAgeSA9IHF5ICsgc3ViaDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9xdWFkVHJlZShcbiAgICAgIHt4OiB4LCB5OiB5LCB3aWR0aDogc3VidywgaGVpZ2h0OiBzdWJofSxcbiAgICAgIG5leHQsXG4gICAgICBxdWFkLm1heEVsZW1lbnRzLFxuICAgICAgcXVhZC5tYXhMZXZlbFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmVjdXJzaXZlbHkgaW5zZXJ0IGFuIGVsZW1lbnQgaW50byB0aGUgcXVhZHRyZWUuIE9ubHkgcG9pbnRzXG4gICAqIHdpdGggc2l6ZSwgaS5lLiBheGlzLWFsaWduZWQgc3F1YXJlcywgbWF5IGJlIGluc2VydGVkIHdpdGggdGhpc1xuICAgKiBtZXRob2QuXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gIGVsICAgICAgICAgVGhlIGVsZW1lbnQgdG8gaW5zZXJ0IGluIHRoZSBxdWFkdHJlZS5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgc2l6ZWRQb2ludCBBIHNpemVkIHBvaW50IGRlZmluZWQgYnkgdHdvIHRvcCBwb2ludHNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoeDEsIHkxKSwgKHgyLCB5MikgYW5kIGhlaWdodC5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgcXVhZCAgICAgICBUaGUgcXVhZCBpbiB3aGljaCB0byBpbnNlcnQgdGhlIGVsZW1lbnQuXG4gICAqIEByZXR1cm4ge3VuZGVmaW5lZH0gICAgICAgICAgVGhlIGZ1bmN0aW9uIGRvZXMgbm90IHJldHVybiBhbnl0aGluZy5cbiAgICovXG4gIGZ1bmN0aW9uIF9xdWFkSW5zZXJ0KGVsLCBzaXplZFBvaW50LCBxdWFkKSB7XG4gICAgaWYgKHF1YWQubGV2ZWwgPCBxdWFkLm1heExldmVsKSB7XG5cbiAgICAgIC8vIFNlYXJjaGluZyBhcHByb3ByaWF0ZSBxdWFkc1xuICAgICAgdmFyIGluZGV4ZXMgPSBfcXVhZEluZGV4ZXMoc2l6ZWRQb2ludCwgcXVhZC5jb3JuZXJzKTtcblxuICAgICAgLy8gSXRlcmF0aW5nXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGluZGV4ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cbiAgICAgICAgLy8gU3ViZGl2aWRpbmcgaWYgbmVjZXNzYXJ5XG4gICAgICAgIGlmIChxdWFkLm5vZGVzW2luZGV4ZXNbaV1dID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgcXVhZC5ub2Rlc1tpbmRleGVzW2ldXSA9IF9xdWFkU3ViZGl2aWRlKGluZGV4ZXNbaV0sIHF1YWQpO1xuXG4gICAgICAgIC8vIFJlY3Vyc2lvblxuICAgICAgICBfcXVhZEluc2VydChlbCwgc2l6ZWRQb2ludCwgcXVhZC5ub2Rlc1tpbmRleGVzW2ldXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuXG4gICAgICAvLyBQdXNoaW5nIHRoZSBlbGVtZW50IGluIGEgbGVhZiBub2RlXG4gICAgICBxdWFkLmVsZW1lbnRzLnB1c2goZWwpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZWN1cnNpdmVseSByZXRyaWV2ZSBldmVyeSBlbGVtZW50cyBoZWxkIGJ5IHRoZSBub2RlIGNvbnRhaW5pbmcgdGhlXG4gICAqIHNlYXJjaGVkIHBvaW50LlxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICBwb2ludCBUaGUgc2VhcmNoZWQgcG9pbnQgKHgsIHkpLlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICBxdWFkICBUaGUgc2VhcmNoZWQgcXVhZC5cbiAgICogQHJldHVybiB7YXJyYXl9ICAgICAgICAgQW4gYXJyYXkgb2YgZWxlbWVudHMgY29udGFpbmVkIGluIHRoZSByZWxldmFudFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLlxuICAgKi9cbiAgZnVuY3Rpb24gX3F1YWRSZXRyaWV2ZVBvaW50KHBvaW50LCBxdWFkKSB7XG4gICAgaWYgKHF1YWQubGV2ZWwgPCBxdWFkLm1heExldmVsKSB7XG4gICAgICB2YXIgaW5kZXggPSBfcXVhZEluZGV4KHBvaW50LCBxdWFkLmJvdW5kcyk7XG5cbiAgICAgIC8vIElmIG5vZGUgZG9lcyBub3QgZXhpc3Qgd2UgcmV0dXJuIGFuIGVtcHR5IGxpc3RcbiAgICAgIGlmIChxdWFkLm5vZGVzW2luZGV4XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBfcXVhZFJldHJpZXZlUG9pbnQocG9pbnQsIHF1YWQubm9kZXNbaW5kZXhdKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIHF1YWQuZWxlbWVudHM7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlY3Vyc2l2ZWx5IHJldHJpZXZlIGV2ZXJ5IGVsZW1lbnRzIGNvbnRhaW5lZCB3aXRoaW4gYW4gcmVjdGFuZ3VsYXIgYXJlYVxuICAgKiB0aGF0IG1heSBvciBtYXkgbm90IGJlIGF4aXMtYWxpZ25lZC5cbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fGFycmF5fSByZWN0RGF0YSAgICAgICBUaGUgc2VhcmNoZWQgYXJlYSBkZWZpbmVkIGVpdGhlciBieVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuIGFycmF5IG9mIGZvdXIgY29ybmVycyAoeCwgeSkgaW5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgY2FzZSBvZiBhIG5vbi1heGlzLWFsaWduZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWN0YW5nbGUgb3IgYW4gb2JqZWN0IHdpdGggdHdvIHRvcFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cyAoeDEsIHkxKSwgKHgyLCB5MikgYW5kIGhlaWdodC5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICBxdWFkICAgICAgICAgICBUaGUgc2VhcmNoZWQgcXVhZC5cbiAgICogQHBhcmFtICB7ZnVuY3Rpb259ICAgICBjb2xsaXNpb25GdW5jICBUaGUgY29sbGlzaW9uIGZ1bmN0aW9uIHVzZWQgdG8gc2VhcmNoXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIG5vZGUgaW5kZXhlcy5cbiAgICogQHBhcmFtICB7YXJyYXk/fSAgICAgICBlbHMgICAgICAgICAgICBUaGUgcmV0cmlldmVkIGVsZW1lbnRzLlxuICAgKiBAcmV0dXJuIHthcnJheX0gICAgICAgICAgICAgICAgICAgICAgIEFuIGFycmF5IG9mIGVsZW1lbnRzIGNvbnRhaW5lZCBpbiB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmVhLlxuICAgKi9cbiAgZnVuY3Rpb24gX3F1YWRSZXRyaWV2ZUFyZWEocmVjdERhdGEsIHF1YWQsIGNvbGxpc2lvbkZ1bmMsIGVscykge1xuICAgIGVscyA9IGVscyB8fCB7fTtcblxuICAgIGlmIChxdWFkLmxldmVsIDwgcXVhZC5tYXhMZXZlbCkge1xuICAgICAgdmFyIGluZGV4ZXMgPSBjb2xsaXNpb25GdW5jKHJlY3REYXRhLCBxdWFkLmNvcm5lcnMpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGluZGV4ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgICBpZiAocXVhZC5ub2Rlc1tpbmRleGVzW2ldXSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgIF9xdWFkUmV0cmlldmVBcmVhKFxuICAgICAgICAgICAgcmVjdERhdGEsXG4gICAgICAgICAgICBxdWFkLm5vZGVzW2luZGV4ZXNbaV1dLFxuICAgICAgICAgICAgY29sbGlzaW9uRnVuYyxcbiAgICAgICAgICAgIGVsc1xuICAgICAgICAgICk7XG4gICAgfSBlbHNlXG4gICAgICBmb3IgKHZhciBqID0gMCwgbSA9IHF1YWQuZWxlbWVudHMubGVuZ3RoOyBqIDwgbTsgaisrKVxuICAgICAgICBpZiAoZWxzW3F1YWQuZWxlbWVudHNbal0uaWRdID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgZWxzW3F1YWQuZWxlbWVudHNbal0uaWRdID0gcXVhZC5lbGVtZW50c1tqXTtcblxuICAgIHJldHVybiBlbHM7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyB0aGUgcXVhZHRyZWUgb2JqZWN0IGl0c2VsZi5cbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgIGJvdW5kcyAgICAgICBUaGUgYm91bmRhcmllcyBvZiB0aGUgcXVhZCBkZWZpbmVkIGJ5IGFuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luICh4LCB5KSwgd2lkdGggYW5kIGhlaWd0aC5cbiAgICogQHBhcmFtICB7aW50ZWdlcn0gIGxldmVsICAgICAgICBUaGUgbGV2ZWwgb2YgdGhlIHF1YWQgaW4gdGhlIHRyZWUuXG4gICAqIEBwYXJhbSAge2ludGVnZXJ9ICBtYXhFbGVtZW50cyAgVGhlIG1heCBudW1iZXIgb2YgZWxlbWVudCBpbiBhIGxlYWYgbm9kZS5cbiAgICogQHBhcmFtICB7aW50ZWdlcn0gIG1heExldmVsICAgICBUaGUgbWF4IHJlY3Vyc2lvbiBsZXZlbCBvZiB0aGUgdHJlZS5cbiAgICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgICAgICAgICBUaGUgcXVhZHRyZWUgb2JqZWN0LlxuICAgKi9cbiAgZnVuY3Rpb24gX3F1YWRUcmVlKGJvdW5kcywgbGV2ZWwsIG1heEVsZW1lbnRzLCBtYXhMZXZlbCkge1xuICAgIHJldHVybiB7XG4gICAgICBsZXZlbDogbGV2ZWwgfHwgMCxcbiAgICAgIGJvdW5kczogYm91bmRzLFxuICAgICAgY29ybmVyczogX2dlb20uc3BsaXRTcXVhcmUoYm91bmRzKSxcbiAgICAgIG1heEVsZW1lbnRzOiBtYXhFbGVtZW50cyB8fCAyMCxcbiAgICAgIG1heExldmVsOiBtYXhMZXZlbCB8fCA0LFxuICAgICAgZWxlbWVudHM6IFtdLFxuICAgICAgbm9kZXM6IFtdXG4gICAgfTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFNpZ21hIFF1YWQgQ29uc3RydWN0b3JcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKlxuICAgKiBUaGUgcXVhZCBBUEkgYXMgZXhwb3NlZCB0byBzaWdtYS5cbiAgICovXG5cbiAgLyoqXG4gICAqIFRoZSBxdWFkIGNvcmUgdGhhdCB3aWxsIGJlY29tZSB0aGUgc2lnbWEgaW50ZXJmYWNlIHdpdGggdGhlIHF1YWR0cmVlLlxuICAgKlxuICAgKiBwcm9wZXJ0eSB7b2JqZWN0fSBfdHJlZSAgUHJvcGVydHkgaG9sZGluZyB0aGUgcXVhZHRyZWUgb2JqZWN0LlxuICAgKiBwcm9wZXJ0eSB7b2JqZWN0fSBfZ2VvbSAgRXhwb3NpdGlvbiBvZiB0aGUgX2dlb20gbmFtZXNwYWNlIGZvciB0ZXN0aW5nLlxuICAgKiBwcm9wZXJ0eSB7b2JqZWN0fSBfY2FjaGUgQ2FjaGUgZm9yIHRoZSBhcmVhIG1ldGhvZC5cbiAgICovXG4gIHZhciBxdWFkID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fZ2VvbSA9IF9nZW9tO1xuICAgIHRoaXMuX3RyZWUgPSBudWxsO1xuICAgIHRoaXMuX2NhY2hlID0ge1xuICAgICAgcXVlcnk6IGZhbHNlLFxuICAgICAgcmVzdWx0OiBmYWxzZVxuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIEluZGV4IGEgZ3JhcGggYnkgaW5zZXJ0aW5nIGl0cyBub2RlcyBpbnRvIHRoZSBxdWFkdHJlZS5cbiAgICpcbiAgICogQHBhcmFtICB7YXJyYXl9ICBub2RlcyAgIEFuIGFycmF5IG9mIG5vZGVzIHRvIGluZGV4LlxuICAgKiBAcGFyYW0gIHtvYmplY3R9IHBhcmFtcyAgQW4gb2JqZWN0IG9mIHBhcmFtZXRlcnMgd2l0aCBhdCBsZWFzdCB0aGUgcXVhZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgYm91bmRzLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgICAgVGhlIHF1YWR0cmVlIG9iamVjdC5cbiAgICpcbiAgICogUGFyYW1ldGVyczpcbiAgICogLS0tLS0tLS0tLVxuICAgKiBib3VuZHM6ICAgICAge29iamVjdH0gICBib3VuZGFyaWVzIG9mIHRoZSBxdWFkIGRlZmluZWQgYnkgaXRzIG9yaWdpbiAoeCwgeSlcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGggYW5kIGhlaWd0aC5cbiAgICogcHJlZml4OiAgICAgIHtzdHJpbmc/fSAgYSBwcmVmaXggZm9yIG5vZGUgZ2VvbWV0cmljIGF0dHJpYnV0ZXMuXG4gICAqIG1heEVsZW1lbnRzOiB7aW50ZWdlcj99IHRoZSBtYXggbnVtYmVyIG9mIGVsZW1lbnRzIGluIGEgbGVhZiBub2RlLlxuICAgKiBtYXhMZXZlbDogICAge2ludGVnZXI/fSB0aGUgbWF4IHJlY3Vyc2lvbiBsZXZlbCBvZiB0aGUgdHJlZS5cbiAgICovXG4gIHF1YWQucHJvdG90eXBlLmluZGV4ID0gZnVuY3Rpb24obm9kZXMsIHBhcmFtcykge1xuXG4gICAgLy8gRW5mb3JjaW5nIHByZXNlbmNlIG9mIGJvdW5kYXJpZXNcbiAgICBpZiAoIXBhcmFtcy5ib3VuZHMpXG4gICAgICB0aHJvdyAnc2lnbWEuY2xhc3Nlcy5xdWFkLmluZGV4OiBib3VuZHMgaW5mb3JtYXRpb24gbm90IGdpdmVuLic7XG5cbiAgICAvLyBQcmVmaXhcbiAgICB2YXIgcHJlZml4ID0gcGFyYW1zLnByZWZpeCB8fCAnJztcblxuICAgIC8vIEJ1aWxkaW5nIHRoZSB0cmVlXG4gICAgdGhpcy5fdHJlZSA9IF9xdWFkVHJlZShcbiAgICAgIHBhcmFtcy5ib3VuZHMsXG4gICAgICAwLFxuICAgICAgcGFyYW1zLm1heEVsZW1lbnRzLFxuICAgICAgcGFyYW1zLm1heExldmVsXG4gICAgKTtcblxuICAgIC8vIEluc2VydGluZyBncmFwaCBub2RlcyBpbnRvIHRoZSB0cmVlXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBub2Rlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblxuICAgICAgLy8gSW5zZXJ0aW5nIG5vZGVcbiAgICAgIF9xdWFkSW5zZXJ0KFxuICAgICAgICBub2Rlc1tpXSxcbiAgICAgICAgX2dlb20ucG9pbnRUb1NxdWFyZSh7XG4gICAgICAgICAgeDogbm9kZXNbaV1bcHJlZml4ICsgJ3gnXSxcbiAgICAgICAgICB5OiBub2Rlc1tpXVtwcmVmaXggKyAneSddLFxuICAgICAgICAgIHNpemU6IG5vZGVzW2ldW3ByZWZpeCArICdzaXplJ11cbiAgICAgICAgfSksXG4gICAgICAgIHRoaXMuX3RyZWVcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gUmVzZXQgY2FjaGU6XG4gICAgdGhpcy5fY2FjaGUgPSB7XG4gICAgICBxdWVyeTogZmFsc2UsXG4gICAgICByZXN1bHQ6IGZhbHNlXG4gICAgfTtcblxuICAgIC8vIHJlbW92ZT9cbiAgICByZXR1cm4gdGhpcy5fdHJlZTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0cmlldmUgZXZlcnkgZ3JhcGggbm9kZXMgaGVsZCBieSB0aGUgcXVhZHRyZWUgbm9kZSBjb250YWluaW5nIHRoZVxuICAgKiBzZWFyY2hlZCBwb2ludC5cbiAgICpcbiAgICogQHBhcmFtICB7bnVtYmVyfSB4IG9mIHRoZSBwb2ludC5cbiAgICogQHBhcmFtICB7bnVtYmVyfSB5IG9mIHRoZSBwb2ludC5cbiAgICogQHJldHVybiB7YXJyYXl9ICBBbiBhcnJheSBvZiBub2RlcyByZXRyaWV2ZWQuXG4gICAqL1xuICBxdWFkLnByb3RvdHlwZS5wb2ludCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJlZSA/XG4gICAgICBfcXVhZFJldHJpZXZlUG9pbnQoe3g6IHgsIHk6IHl9LCB0aGlzLl90cmVlKSB8fCBbXSA6XG4gICAgICBbXTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0cmlldmUgZXZlcnkgZ3JhcGggbm9kZXMgd2l0aGluIGEgcmVjdGFuZ3VsYXIgYXJlYS4gVGhlIG1ldGhvZHMga2VlcCB0aGVcbiAgICogbGFzdCBhcmVhIHF1ZXJpZWQgaW4gY2FjaGUgZm9yIG9wdGltaXphdGlvbiByZWFzb24gYW5kIHdpbGwgYWN0IGRpZmZlcmVudGx5XG4gICAqIGZvciB0aGUgc2FtZSByZWFzb24gaWYgdGhlIGFyZWEgaXMgYXhpcy1hbGlnbmVkIG9yIG5vdC5cbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSBBIHJlY3RhbmdsZSBkZWZpbmVkIGJ5IHR3byB0b3AgcG9pbnRzICh4MSwgeTEpLCAoeDIsIHkyKVxuICAgKiAgICAgICAgICAgICAgICAgIGFuZCBoZWlnaHQuXG4gICAqIEByZXR1cm4ge2FycmF5fSAgQW4gYXJyYXkgb2Ygbm9kZXMgcmV0cmlldmVkLlxuICAgKi9cbiAgcXVhZC5wcm90b3R5cGUuYXJlYSA9IGZ1bmN0aW9uKHJlY3QpIHtcbiAgICB2YXIgc2VyaWFsaXplZCA9IEpTT04uc3RyaW5naWZ5KHJlY3QpLFxuICAgICAgICBjb2xsaXNpb25GdW5jLFxuICAgICAgICByZWN0RGF0YTtcblxuICAgIC8vIFJldHVybmluZyBjYWNoZT9cbiAgICBpZiAodGhpcy5fY2FjaGUucXVlcnkgPT09IHNlcmlhbGl6ZWQpXG4gICAgICByZXR1cm4gdGhpcy5fY2FjaGUucmVzdWx0O1xuXG4gICAgLy8gQXhpcyBhbGlnbmVkID9cbiAgICBpZiAoX2dlb20uaXNBeGlzQWxpZ25lZChyZWN0KSkge1xuICAgICAgY29sbGlzaW9uRnVuYyA9IF9xdWFkSW5kZXhlcztcbiAgICAgIHJlY3REYXRhID0gX2dlb20uYXhpc0FsaWduZWRUb3BQb2ludHMocmVjdCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY29sbGlzaW9uRnVuYyA9IF9xdWFkQ29sbGlzaW9uO1xuICAgICAgcmVjdERhdGEgPSBfZ2VvbS5yZWN0YW5nbGVDb3JuZXJzKHJlY3QpO1xuICAgIH1cblxuICAgIC8vIFJldHJpZXZpbmcgbm9kZXNcbiAgICB2YXIgbm9kZXMgPSB0aGlzLl90cmVlID9cbiAgICAgIF9xdWFkUmV0cmlldmVBcmVhKFxuICAgICAgICByZWN0RGF0YSxcbiAgICAgICAgdGhpcy5fdHJlZSxcbiAgICAgICAgY29sbGlzaW9uRnVuY1xuICAgICAgKSA6XG4gICAgICBbXTtcblxuICAgIC8vIE9iamVjdCB0byBhcnJheVxuICAgIHZhciBub2Rlc0FycmF5ID0gW107XG4gICAgZm9yICh2YXIgaSBpbiBub2RlcylcbiAgICAgIG5vZGVzQXJyYXkucHVzaChub2Rlc1tpXSk7XG5cbiAgICAvLyBDYWNoaW5nXG4gICAgdGhpcy5fY2FjaGUucXVlcnkgPSBzZXJpYWxpemVkO1xuICAgIHRoaXMuX2NhY2hlLnJlc3VsdCA9IG5vZGVzQXJyYXk7XG5cbiAgICByZXR1cm4gbm9kZXNBcnJheTtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBFWFBPUlQ6XG4gICAqICoqKioqKipcbiAgICovXG4gIGlmICh0eXBlb2YgdGhpcy5zaWdtYSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aGlzLnNpZ21hLmNsYXNzZXMgPSB0aGlzLnNpZ21hLmNsYXNzZXMgfHwge307XG4gICAgdGhpcy5zaWdtYS5jbGFzc2VzLnF1YWQgPSBxdWFkO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cylcbiAgICAgIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHF1YWQ7XG4gICAgZXhwb3J0cy5xdWFkID0gcXVhZDtcbiAgfSBlbHNlXG4gICAgdGhpcy5xdWFkID0gcXVhZDtcbn0pLmNhbGwodGhpcyk7XG5cbjsoZnVuY3Rpb24odW5kZWZpbmVkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvKipcbiAgICogU2lnbWEgUXVhZHRyZWUgTW9kdWxlIGZvciBlZGdlc1xuICAgKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAqXG4gICAqIEF1dGhvcjogU8OpYmFzdGllbiBIZXltYW5uLFxuICAgKiAgIGZyb20gdGhlIHF1YWQgb2YgR3VpbGxhdW1lIFBsaXF1ZSAoWW9tZ3VpdGhlcmVhbClcbiAgICogVmVyc2lvbjogMC4yXG4gICAqL1xuXG5cblxuICAvKipcbiAgICogUXVhZCBHZW9tZXRyaWMgT3BlcmF0aW9uc1xuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqXG4gICAqIEEgdXNlZnVsIGJhdGNoIG9mIGdlb21ldHJpYyBvcGVyYXRpb25zIHVzZWQgYnkgdGhlIHF1YWR0cmVlLlxuICAgKi9cblxuICB2YXIgX2dlb20gPSB7XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIGEgZ3JhcGggbm9kZSB3aXRoIHgsIHkgYW5kIHNpemUgaW50byBhblxuICAgICAqIGF4aXMtYWxpZ25lZCBzcXVhcmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IEEgZ3JhcGggbm9kZSB3aXRoIGF0IGxlYXN0IGEgcG9pbnQgKHgsIHkpIGFuZCBhIHNpemUuXG4gICAgICogQHJldHVybiB7b2JqZWN0fSBBIHNxdWFyZTogdHdvIHBvaW50cyAoeDEsIHkxKSwgKHgyLCB5MikgYW5kIGhlaWdodC5cbiAgICAgKi9cbiAgICBwb2ludFRvU3F1YXJlOiBmdW5jdGlvbihuKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4MTogbi54IC0gbi5zaXplLFxuICAgICAgICB5MTogbi55IC0gbi5zaXplLFxuICAgICAgICB4Mjogbi54ICsgbi5zaXplLFxuICAgICAgICB5Mjogbi55IC0gbi5zaXplLFxuICAgICAgICBoZWlnaHQ6IG4uc2l6ZSAqIDJcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgYSBncmFwaCBlZGdlIHdpdGggeDEsIHkxLCB4MiwgeTIgYW5kIHNpemUgaW50byBhblxuICAgICAqIGF4aXMtYWxpZ25lZCBzcXVhcmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IEEgZ3JhcGggZWRnZSB3aXRoIGF0IGxlYXN0IHR3byBwb2ludHNcbiAgICAgKiAgICAgICAgICAgICAgICAgICh4MSwgeTEpLCAoeDIsIHkyKSBhbmQgYSBzaXplLlxuICAgICAqIEByZXR1cm4ge29iamVjdH0gQSBzcXVhcmU6IHR3byBwb2ludHMgKHgxLCB5MSksICh4MiwgeTIpIGFuZCBoZWlnaHQuXG4gICAgICovXG4gICAgbGluZVRvU3F1YXJlOiBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAoZS55MSA8IGUueTIpIHtcbiAgICAgICAgLy8gKGUueDEsIGUueTEpIG9uIHRvcFxuICAgICAgICBpZiAoZS54MSA8IGUueDIpIHtcbiAgICAgICAgICAvLyAoZS54MSwgZS55MSkgb24gbGVmdFxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4MTogZS54MSAtIGUuc2l6ZSxcbiAgICAgICAgICAgIHkxOiBlLnkxIC0gZS5zaXplLFxuICAgICAgICAgICAgeDI6IGUueDIgKyBlLnNpemUsXG4gICAgICAgICAgICB5MjogZS55MSAtIGUuc2l6ZSxcbiAgICAgICAgICAgIGhlaWdodDogZS55MiAtIGUueTEgKyBlLnNpemUgKiAyXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyAoZS54MSwgZS55MSkgb24gcmlnaHRcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4MTogZS54MiAtIGUuc2l6ZSxcbiAgICAgICAgICB5MTogZS55MSAtIGUuc2l6ZSxcbiAgICAgICAgICB4MjogZS54MSArIGUuc2l6ZSxcbiAgICAgICAgICB5MjogZS55MSAtIGUuc2l6ZSxcbiAgICAgICAgICBoZWlnaHQ6IGUueTIgLSBlLnkxICsgZS5zaXplICogMlxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyAoZS54MiwgZS55Mikgb24gdG9wXG4gICAgICBpZiAoZS54MSA8IGUueDIpIHtcbiAgICAgICAgLy8gKGUueDEsIGUueTEpIG9uIGxlZnRcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4MTogZS54MSAtIGUuc2l6ZSxcbiAgICAgICAgICB5MTogZS55MiAtIGUuc2l6ZSxcbiAgICAgICAgICB4MjogZS54MiArIGUuc2l6ZSxcbiAgICAgICAgICB5MjogZS55MiAtIGUuc2l6ZSxcbiAgICAgICAgICBoZWlnaHQ6IGUueTEgLSBlLnkyICsgZS5zaXplICogMlxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgLy8gKGUueDIsIGUueTIpIG9uIHJpZ2h0XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4MTogZS54MiAtIGUuc2l6ZSxcbiAgICAgICAgeTE6IGUueTIgLSBlLnNpemUsXG4gICAgICAgIHgyOiBlLngxICsgZS5zaXplLFxuICAgICAgICB5MjogZS55MiAtIGUuc2l6ZSxcbiAgICAgICAgaGVpZ2h0OiBlLnkxIC0gZS55MiArIGUuc2l6ZSAqIDJcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgYSBncmFwaCBlZGdlIG9mIHR5cGUgJ2N1cnZlJyB3aXRoIHgxLCB5MSwgeDIsIHkyLFxuICAgICAqIGNvbnRyb2wgcG9pbnQgYW5kIHNpemUgaW50byBhbiBheGlzLWFsaWduZWQgc3F1YXJlLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSBlICBBIGdyYXBoIGVkZ2Ugd2l0aCBhdCBsZWFzdCB0d28gcG9pbnRzXG4gICAgICogICAgICAgICAgICAgICAgICAgICAoeDEsIHkxKSwgKHgyLCB5MikgYW5kIGEgc2l6ZS5cbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IGNwIEEgY29udHJvbCBwb2ludCAoeCx5KS5cbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgIEEgc3F1YXJlOiB0d28gcG9pbnRzICh4MSwgeTEpLCAoeDIsIHkyKSBhbmQgaGVpZ2h0LlxuICAgICAqL1xuICAgIHF1YWRyYXRpY0N1cnZlVG9TcXVhcmU6IGZ1bmN0aW9uKGUsIGNwKSB7XG4gICAgICB2YXIgcHQgPSBzaWdtYS51dGlscy5nZXRQb2ludE9uUXVhZHJhdGljQ3VydmUoXG4gICAgICAgIDAuNSxcbiAgICAgICAgZS54MSxcbiAgICAgICAgZS55MSxcbiAgICAgICAgZS54MixcbiAgICAgICAgZS55MixcbiAgICAgICAgY3AueCxcbiAgICAgICAgY3AueVxuICAgICAgKTtcblxuICAgICAgLy8gQm91bmRpbmcgYm94IG9mIHRoZSB0d28gcG9pbnRzIGFuZCB0aGUgcG9pbnQgYXQgdGhlIG1pZGRsZSBvZiB0aGVcbiAgICAgIC8vIGN1cnZlOlxuICAgICAgdmFyIG1pblggPSBNYXRoLm1pbihlLngxLCBlLngyLCBwdC54KSxcbiAgICAgICAgICBtYXhYID0gTWF0aC5tYXgoZS54MSwgZS54MiwgcHQueCksXG4gICAgICAgICAgbWluWSA9IE1hdGgubWluKGUueTEsIGUueTIsIHB0LnkpLFxuICAgICAgICAgIG1heFkgPSBNYXRoLm1heChlLnkxLCBlLnkyLCBwdC55KTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDE6IG1pblggLSBlLnNpemUsXG4gICAgICAgIHkxOiBtaW5ZIC0gZS5zaXplLFxuICAgICAgICB4MjogbWF4WCArIGUuc2l6ZSxcbiAgICAgICAgeTI6IG1pblkgLSBlLnNpemUsXG4gICAgICAgIGhlaWdodDogbWF4WSAtIG1pblkgKyBlLnNpemUgKiAyXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIGEgZ3JhcGggc2VsZiBsb29wIGludG8gYW4gYXhpcy1hbGlnbmVkIHNxdWFyZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gbiBBIGdyYXBoIG5vZGUgd2l0aCBhIHBvaW50ICh4LCB5KSBhbmQgYSBzaXplLlxuICAgICAqIEByZXR1cm4ge29iamVjdH0gICBBIHNxdWFyZTogdHdvIHBvaW50cyAoeDEsIHkxKSwgKHgyLCB5MikgYW5kIGhlaWdodC5cbiAgICAgKi9cbiAgICBzZWxmTG9vcFRvU3F1YXJlOiBmdW5jdGlvbihuKSB7XG4gICAgICAvLyBGaXR0aW5nIHRvIHRoZSBjdXJ2ZSBpcyB0b28gY29zdGx5LCB3ZSBjb21wdXRlIGEgbGFyZ2VyIGJvdW5kaW5nIGJveFxuICAgICAgLy8gdXNpbmcgdGhlIGNvbnRyb2wgcG9pbnRzOlxuICAgICAgdmFyIGNwID0gc2lnbWEudXRpbHMuZ2V0U2VsZkxvb3BDb250cm9sUG9pbnRzKG4ueCwgbi55LCBuLnNpemUpO1xuXG4gICAgICAvLyBCb3VuZGluZyBib3ggb2YgdGhlIHBvaW50IGFuZCB0aGUgdHdvIGNvbnRyb2wgcG9pbnRzOlxuICAgICAgdmFyIG1pblggPSBNYXRoLm1pbihuLngsIGNwLngxLCBjcC54MiksXG4gICAgICAgICAgbWF4WCA9IE1hdGgubWF4KG4ueCwgY3AueDEsIGNwLngyKSxcbiAgICAgICAgICBtaW5ZID0gTWF0aC5taW4obi55LCBjcC55MSwgY3AueTIpLFxuICAgICAgICAgIG1heFkgPSBNYXRoLm1heChuLnksIGNwLnkxLCBjcC55Mik7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHgxOiBtaW5YIC0gbi5zaXplLFxuICAgICAgICB5MTogbWluWSAtIG4uc2l6ZSxcbiAgICAgICAgeDI6IG1heFggKyBuLnNpemUsXG4gICAgICAgIHkyOiBtaW5ZIC0gbi5zaXplLFxuICAgICAgICBoZWlnaHQ6IG1heFkgLSBtaW5ZICsgbi5zaXplICogMlxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgYSByZWN0YW5nbGUgaXMgYXhpcy1hbGlnbmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSAgQSByZWN0YW5nbGUgZGVmaW5lZCBieSB0d28gcG9pbnRzXG4gICAgICogICAgICAgICAgICAgICAgICAgKHgxLCB5MSkgYW5kICh4MiwgeTIpLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIHJlY3RhbmdsZSBpcyBheGlzLWFsaWduZWQuXG4gICAgICovXG4gICAgaXNBeGlzQWxpZ25lZDogZnVuY3Rpb24ocikge1xuICAgICAgcmV0dXJuIHIueDEgPT09IHIueDIgfHwgci55MSA9PT0gci55MjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZSB0b3AgcG9pbnRzIG9mIGFuIGF4aXMtYWxpZ25lZCByZWN0YW5nbGUuIFRoaXMgaXMgdXNlZnVsIGluXG4gICAgICogY2FzZXMgd2hlbiB0aGUgcmVjdGFuZ2xlIGhhcyBiZWVuIHJvdGF0ZWQgKGxlZnQsIHJpZ2h0IG9yIGJvdHRvbSB1cCkgYW5kXG4gICAgICogbGF0ZXIgb3BlcmF0aW9ucyBuZWVkIHRvIGtub3cgdGhlIHRvcCBwb2ludHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IEFuIGF4aXMtYWxpZ25lZCByZWN0YW5nbGUgZGVmaW5lZCBieSB0d28gcG9pbnRzXG4gICAgICogICAgICAgICAgICAgICAgICAoeDEsIHkxKSwgKHgyLCB5MikgYW5kIGhlaWdodC5cbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IEEgcmVjdGFuZ2xlOiB0d28gcG9pbnRzICh4MSwgeTEpLCAoeDIsIHkyKSBhbmQgaGVpZ2h0LlxuICAgICAqL1xuICAgIGF4aXNBbGlnbmVkVG9wUG9pbnRzOiBmdW5jdGlvbihyKSB7XG5cbiAgICAgIC8vIEJhc2ljXG4gICAgICBpZiAoci55MSA9PT0gci55MiAmJiByLngxIDwgci54MilcbiAgICAgICAgcmV0dXJuIHI7XG5cbiAgICAgIC8vIFJvdGF0ZWQgdG8gcmlnaHRcbiAgICAgIGlmIChyLngxID09PSByLngyICYmIHIueTIgPiByLnkxKVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHgxOiByLngxIC0gci5oZWlnaHQsIHkxOiByLnkxLFxuICAgICAgICAgIHgyOiByLngxLCB5Mjogci55MSxcbiAgICAgICAgICBoZWlnaHQ6IHIuaGVpZ2h0XG4gICAgICAgIH07XG5cbiAgICAgIC8vIFJvdGF0ZWQgdG8gbGVmdFxuICAgICAgaWYgKHIueDEgPT09IHIueDIgJiYgci55MiA8IHIueTEpXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDE6IHIueDEsIHkxOiByLnkyLFxuICAgICAgICAgIHgyOiByLngyICsgci5oZWlnaHQsIHkyOiByLnkyLFxuICAgICAgICAgIGhlaWdodDogci5oZWlnaHRcbiAgICAgICAgfTtcblxuICAgICAgLy8gQm90dG9tJ3MgdXBcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHgxOiByLngyLCB5MTogci55MSAtIHIuaGVpZ2h0LFxuICAgICAgICB4Mjogci54MSwgeTI6IHIueTEgLSByLmhlaWdodCxcbiAgICAgICAgaGVpZ2h0OiByLmhlaWdodFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGNvb3JkaW5hdGVzIG9mIGEgcmVjdGFuZ2xlJ3MgbG93ZXIgbGVmdCBjb3JuZXIgZnJvbSBpdHMgdG9wIHBvaW50cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gQSByZWN0YW5nbGUgZGVmaW5lZCBieSB0d28gcG9pbnRzICh4MSwgeTEpIGFuZCAoeDIsIHkyKS5cbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IENvb3JkaW5hdGVzIG9mIHRoZSBjb3JuZXIgKHgsIHkpLlxuICAgICAqL1xuICAgIGxvd2VyTGVmdENvb3I6IGZ1bmN0aW9uKHIpIHtcbiAgICAgIHZhciB3aWR0aCA9IChcbiAgICAgICAgTWF0aC5zcXJ0KFxuICAgICAgICAgIE1hdGgucG93KHIueDIgLSByLngxLCAyKSArXG4gICAgICAgICAgTWF0aC5wb3coci55MiAtIHIueTEsIDIpXG4gICAgICAgIClcbiAgICAgICk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHIueDEgLSAoci55MiAtIHIueTEpICogci5oZWlnaHQgLyB3aWR0aCxcbiAgICAgICAgeTogci55MSArIChyLngyIC0gci54MSkgKiByLmhlaWdodCAvIHdpZHRoXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgY29vcmRpbmF0ZXMgb2YgYSByZWN0YW5nbGUncyBsb3dlciByaWdodCBjb3JuZXIgZnJvbSBpdHMgdG9wIHBvaW50c1xuICAgICAqIGFuZCBpdHMgbG93ZXIgbGVmdCBjb3JuZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IEEgcmVjdGFuZ2xlIGRlZmluZWQgYnkgdHdvIHBvaW50cyAoeDEsIHkxKSBhbmQgKHgyLCB5MikuXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSBBIGNvcm5lcidzIGNvb3JkaW5hdGVzICh4LCB5KS5cbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IENvb3JkaW5hdGVzIG9mIHRoZSBjb3JuZXIgKHgsIHkpLlxuICAgICAqL1xuICAgIGxvd2VyUmlnaHRDb29yOiBmdW5jdGlvbihyLCBsbGMpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IGxsYy54IC0gci54MSArIHIueDIsXG4gICAgICAgIHk6IGxsYy55IC0gci55MSArIHIueTJcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY29vcmRpbmF0ZXMgb2YgYWxsIHRoZSBjb3JuZXJzIG9mIGEgcmVjdGFuZ2xlIGZyb20gaXRzIHRvcCBwb2ludC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gQSByZWN0YW5nbGUgZGVmaW5lZCBieSB0d28gcG9pbnRzICh4MSwgeTEpIGFuZCAoeDIsIHkyKS5cbiAgICAgKiBAcmV0dXJuIHthcnJheX0gIEFuIGFycmF5IG9mIHRoZSBmb3VyIGNvcm5lcnMnIGNvb3JkaW5hdGVzICh4LCB5KS5cbiAgICAgKi9cbiAgICByZWN0YW5nbGVDb3JuZXJzOiBmdW5jdGlvbihyKSB7XG4gICAgICB2YXIgbGxjID0gdGhpcy5sb3dlckxlZnRDb29yKHIpLFxuICAgICAgICAgIGxyYyA9IHRoaXMubG93ZXJSaWdodENvb3IociwgbGxjKTtcblxuICAgICAgcmV0dXJuIFtcbiAgICAgICAge3g6IHIueDEsIHk6IHIueTF9LFxuICAgICAgICB7eDogci54MiwgeTogci55Mn0sXG4gICAgICAgIHt4OiBsbGMueCwgeTogbGxjLnl9LFxuICAgICAgICB7eDogbHJjLngsIHk6IGxyYy55fVxuICAgICAgXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3BsaXQgYSBzcXVhcmUgZGVmaW5lZCBieSBpdHMgYm91bmRhcmllcyBpbnRvIGZvdXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IEJvdW5kYXJpZXMgb2YgdGhlIHNxdWFyZSAoeCwgeSwgd2lkdGgsIGhlaWdodCkuXG4gICAgICogQHJldHVybiB7YXJyYXl9ICBBbiBhcnJheSBjb250YWluaW5nIHRoZSBmb3VyIG5ldyBzcXVhcmVzLCB0aGVtc2VsdmVzXG4gICAgICogICAgICAgICAgICAgICAgICBkZWZpbmVkIGJ5IGFuIGFycmF5IG9mIHRoZWlyIGZvdXIgY29ybmVycyAoeCwgeSkuXG4gICAgICovXG4gICAgc3BsaXRTcXVhcmU6IGZ1bmN0aW9uKGIpIHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIFtcbiAgICAgICAgICB7eDogYi54LCB5OiBiLnl9LFxuICAgICAgICAgIHt4OiBiLnggKyBiLndpZHRoIC8gMiwgeTogYi55fSxcbiAgICAgICAgICB7eDogYi54LCB5OiBiLnkgKyBiLmhlaWdodCAvIDJ9LFxuICAgICAgICAgIHt4OiBiLnggKyBiLndpZHRoIC8gMiwgeTogYi55ICsgYi5oZWlnaHQgLyAyfVxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAge3g6IGIueCArIGIud2lkdGggLyAyLCB5OiBiLnl9LFxuICAgICAgICAgIHt4OiBiLnggKyBiLndpZHRoLCB5OiBiLnl9LFxuICAgICAgICAgIHt4OiBiLnggKyBiLndpZHRoIC8gMiwgeTogYi55ICsgYi5oZWlnaHQgLyAyfSxcbiAgICAgICAgICB7eDogYi54ICsgYi53aWR0aCwgeTogYi55ICsgYi5oZWlnaHQgLyAyfVxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAge3g6IGIueCwgeTogYi55ICsgYi5oZWlnaHQgLyAyfSxcbiAgICAgICAgICB7eDogYi54ICsgYi53aWR0aCAvIDIsIHk6IGIueSArIGIuaGVpZ2h0IC8gMn0sXG4gICAgICAgICAge3g6IGIueCwgeTogYi55ICsgYi5oZWlnaHR9LFxuICAgICAgICAgIHt4OiBiLnggKyBiLndpZHRoIC8gMiwgeTogYi55ICsgYi5oZWlnaHR9XG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICB7eDogYi54ICsgYi53aWR0aCAvIDIsIHk6IGIueSArIGIuaGVpZ2h0IC8gMn0sXG4gICAgICAgICAge3g6IGIueCArIGIud2lkdGgsIHk6IGIueSArIGIuaGVpZ2h0IC8gMn0sXG4gICAgICAgICAge3g6IGIueCArIGIud2lkdGggLyAyLCB5OiBiLnkgKyBiLmhlaWdodH0sXG4gICAgICAgICAge3g6IGIueCArIGIud2lkdGgsIHk6IGIueSArIGIuaGVpZ2h0fVxuICAgICAgICBdXG4gICAgICBdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlIHRoZSBmb3VyIGF4aXMgYmV0d2VlbiBjb3JuZXJzIG9mIHJlY3RhbmdsZSBBIGFuZCBjb3JuZXJzIG9mXG4gICAgICogcmVjdGFuZ2xlIEIuIFRoaXMgaXMgbmVlZGVkIGxhdGVyIHRvIGNoZWNrIGFuIGV2ZW50dWFsIGNvbGxpc2lvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge2FycmF5fSBBbiBhcnJheSBvZiByZWN0YW5nbGUgQSdzIGZvdXIgY29ybmVycyAoeCwgeSkuXG4gICAgICogQHBhcmFtICB7YXJyYXl9IEFuIGFycmF5IG9mIHJlY3RhbmdsZSBCJ3MgZm91ciBjb3JuZXJzICh4LCB5KS5cbiAgICAgKiBAcmV0dXJuIHthcnJheX0gQW4gYXJyYXkgb2YgZm91ciBheGlzIGRlZmluZWQgYnkgdGhlaXIgY29vcmRpbmF0ZXMgKHgseSkuXG4gICAgICovXG4gICAgYXhpczogZnVuY3Rpb24oYzEsIGMyKSB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICB7eDogYzFbMV0ueCAtIGMxWzBdLngsIHk6IGMxWzFdLnkgLSBjMVswXS55fSxcbiAgICAgICAge3g6IGMxWzFdLnggLSBjMVszXS54LCB5OiBjMVsxXS55IC0gYzFbM10ueX0sXG4gICAgICAgIHt4OiBjMlswXS54IC0gYzJbMl0ueCwgeTogYzJbMF0ueSAtIGMyWzJdLnl9LFxuICAgICAgICB7eDogYzJbMF0ueCAtIGMyWzFdLngsIHk6IGMyWzBdLnkgLSBjMlsxXS55fVxuICAgICAgXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHJvamVjdCBhIHJlY3RhbmdsZSdzIGNvcm5lciBvbiBhbiBheGlzLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSBDb29yZGluYXRlcyBvZiBhIGNvcm5lciAoeCwgeSkuXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSBDb29yZGluYXRlcyBvZiBhbiBheGlzICh4LCB5KS5cbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBwcm9qZWN0aW9uIGRlZmluZWQgYnkgY29vcmRpbmF0ZXMgKHgsIHkpLlxuICAgICAqL1xuICAgIHByb2plY3Rpb246IGZ1bmN0aW9uKGMsIGEpIHtcbiAgICAgIHZhciBsID0gKFxuICAgICAgICAoYy54ICogYS54ICsgYy55ICogYS55KSAvXG4gICAgICAgIChNYXRoLnBvdyhhLngsIDIpICsgTWF0aC5wb3coYS55LCAyKSlcbiAgICAgICk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IGwgKiBhLngsXG4gICAgICAgIHk6IGwgKiBhLnlcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIHdoZXRoZXIgdHdvIHJlY3RhbmdsZXMgY29sbGlkZSBvbiBvbmUgcGFydGljdWxhciBheGlzLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSAgIEFuIGF4aXMnIGNvb3JkaW5hdGVzICh4LCB5KS5cbiAgICAgKiBAcGFyYW0gIHthcnJheX0gICAgUmVjdGFuZ2xlIEEncyBjb3JuZXJzLlxuICAgICAqIEBwYXJhbSAge2FycmF5fSAgICBSZWN0YW5nbGUgQidzIGNvcm5lcnMuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gIFRydWUgaWYgdGhlIHJlY3RhbmdsZXMgY29sbGlkZSBvbiB0aGUgYXhpcy5cbiAgICAgKi9cbiAgICBheGlzQ29sbGlzaW9uOiBmdW5jdGlvbihhLCBjMSwgYzIpIHtcbiAgICAgIHZhciBzYzEgPSBbXSxcbiAgICAgICAgICBzYzIgPSBbXTtcblxuICAgICAgZm9yICh2YXIgY2kgPSAwOyBjaSA8IDQ7IGNpKyspIHtcbiAgICAgICAgdmFyIHAxID0gdGhpcy5wcm9qZWN0aW9uKGMxW2NpXSwgYSksXG4gICAgICAgICAgICBwMiA9IHRoaXMucHJvamVjdGlvbihjMltjaV0sIGEpO1xuXG4gICAgICAgIHNjMS5wdXNoKHAxLnggKiBhLnggKyBwMS55ICogYS55KTtcbiAgICAgICAgc2MyLnB1c2gocDIueCAqIGEueCArIHAyLnkgKiBhLnkpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbWF4YzEgPSBNYXRoLm1heC5hcHBseShNYXRoLCBzYzEpLFxuICAgICAgICAgIG1heGMyID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgc2MyKSxcbiAgICAgICAgICBtaW5jMSA9IE1hdGgubWluLmFwcGx5KE1hdGgsIHNjMSksXG4gICAgICAgICAgbWluYzIgPSBNYXRoLm1pbi5hcHBseShNYXRoLCBzYzIpO1xuXG4gICAgICByZXR1cm4gKG1pbmMyIDw9IG1heGMxICYmIG1heGMyID49IG1pbmMxKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgd2hldGhlciB0d28gcmVjdGFuZ2xlcyBjb2xsaWRlIG9uIGVhY2ggb25lIG9mIHRoZWlyIGZvdXIgYXhpcy4gSWZcbiAgICAgKiBhbGwgYXhpcyBjb2xsaWRlLCB0aGVuIHRoZSB0d28gcmVjdGFuZ2xlcyBkbyBjb2xsaWRlIG9uIHRoZSBwbGFuZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge2FycmF5fSAgICBSZWN0YW5nbGUgQSdzIGNvcm5lcnMuXG4gICAgICogQHBhcmFtICB7YXJyYXl9ICAgIFJlY3RhbmdsZSBCJ3MgY29ybmVycy5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSAgVHJ1ZSBpZiB0aGUgcmVjdGFuZ2xlcyBjb2xsaWRlLlxuICAgICAqL1xuICAgIGNvbGxpc2lvbjogZnVuY3Rpb24oYzEsIGMyKSB7XG4gICAgICB2YXIgYXhpcyA9IHRoaXMuYXhpcyhjMSwgYzIpLFxuICAgICAgICAgIGNvbCA9IHRydWU7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKVxuICAgICAgICBjb2wgPSBjb2wgJiYgdGhpcy5heGlzQ29sbGlzaW9uKGF4aXNbaV0sIGMxLCBjMik7XG5cbiAgICAgIHJldHVybiBjb2w7XG4gICAgfVxuICB9O1xuXG5cbiAgLyoqXG4gICAqIFF1YWQgRnVuY3Rpb25zXG4gICAqIC0tLS0tLS0tLS0tLVxuICAgKlxuICAgKiBUaGUgUXVhZHRyZWUgZnVuY3Rpb25zIHRoZW1zZWx2ZXMuXG4gICAqIEZvciBlYWNoIG9mIHRob3NlIGZ1bmN0aW9ucywgd2UgY29uc2lkZXIgdGhhdCBpbiBhIHNwbGl0dGVkIHF1YWQsIHRoZVxuICAgKiBpbmRleCBvZiBlYWNoIG5vZGUgaXMgdGhlIGZvbGxvd2luZzpcbiAgICogMDogdG9wIGxlZnRcbiAgICogMTogdG9wIHJpZ2h0XG4gICAqIDI6IGJvdHRvbSBsZWZ0XG4gICAqIDM6IGJvdHRvbSByaWdodFxuICAgKlxuICAgKiBNb3Jlb3ZlciwgdGhlIGhlcmVhZnRlciBxdWFkJ3MgcGhpbG9zb3BoeSBpcyB0byBjb25zaWRlciB0aGF0IGlmIGFuIGVsZW1lbnRcbiAgICogY29sbGlkZXMgd2l0aCBtb3JlIHRoYW4gb25lIG5vZGVzLCB0aGlzIGVsZW1lbnQgYmVsb25ncyB0byBlYWNoIG9mIHRoZVxuICAgKiBub2RlcyBpdCBjb2xsaWRlcyB3aXRoIHdoZXJlIG90aGVyIHdvdWxkIGxldCBpdCBsaWUgb24gYSBoaWdoZXIgbm9kZS5cbiAgICovXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaW5kZXggb2YgdGhlIG5vZGUgY29udGFpbmluZyB0aGUgcG9pbnQgaW4gdGhlIHF1YWRcbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgcG9pbnQgICAgICBBIHBvaW50IGRlZmluZWQgYnkgY29vcmRpbmF0ZXMgKHgsIHkpLlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICBxdWFkQm91bmRzIEJvdW5kYXJpZXMgb2YgdGhlIHF1YWQgKHgsIHksIHdpZHRoLCBoZWlndGgpLlxuICAgKiBAcmV0dXJuIHtpbnRlZ2VyfSAgICAgICAgICAgIFRoZSBpbmRleCBvZiB0aGUgbm9kZSBjb250YWluaW5nIHRoZSBwb2ludC5cbiAgICovXG4gIGZ1bmN0aW9uIF9xdWFkSW5kZXgocG9pbnQsIHF1YWRCb3VuZHMpIHtcbiAgICB2YXIgeG1wID0gcXVhZEJvdW5kcy54ICsgcXVhZEJvdW5kcy53aWR0aCAvIDIsXG4gICAgICAgIHltcCA9IHF1YWRCb3VuZHMueSArIHF1YWRCb3VuZHMuaGVpZ2h0IC8gMixcbiAgICAgICAgdG9wID0gKHBvaW50LnkgPCB5bXApLFxuICAgICAgICBsZWZ0ID0gKHBvaW50LnggPCB4bXApO1xuXG4gICAgaWYgKHRvcCkge1xuICAgICAgaWYgKGxlZnQpXG4gICAgICAgIHJldHVybiAwO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpZiAobGVmdClcbiAgICAgICAgcmV0dXJuIDI7XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiAzO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSBsaXN0IG9mIGluZGV4ZXMgb2Ygbm9kZXMgY29udGFpbmluZyBhbiBheGlzLWFsaWduZWQgcmVjdGFuZ2xlXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gIHJlY3RhbmdsZSAgIEEgcmVjdGFuZ2xlIGRlZmluZWQgYnkgdHdvIHBvaW50cyAoeDEsIHkxKSxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHgyLCB5MikgYW5kIGhlaWdodC5cbiAgICogQHBhcmFtICB7YXJyYXl9ICAgcXVhZENvcm5lcnMgQW4gYXJyYXkgb2YgdGhlIHF1YWQgbm9kZXMnIGNvcm5lcnMuXG4gICAqIEByZXR1cm4ge2FycmF5fSAgICAgICAgICAgICAgIEFuIGFycmF5IG9mIGluZGV4ZXMgY29udGFpbmluZyBvbmUgdG9cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91ciBpbnRlZ2Vycy5cbiAgICovXG4gIGZ1bmN0aW9uIF9xdWFkSW5kZXhlcyhyZWN0YW5nbGUsIHF1YWRDb3JuZXJzKSB7XG4gICAgdmFyIGluZGV4ZXMgPSBbXTtcblxuICAgIC8vIEl0ZXJhdGluZyB0aHJvdWdoIHF1YWRzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspXG4gICAgICBpZiAoKHJlY3RhbmdsZS54MiA+PSBxdWFkQ29ybmVyc1tpXVswXS54KSAmJlxuICAgICAgICAgIChyZWN0YW5nbGUueDEgPD0gcXVhZENvcm5lcnNbaV1bMV0ueCkgJiZcbiAgICAgICAgICAocmVjdGFuZ2xlLnkxICsgcmVjdGFuZ2xlLmhlaWdodCA+PSBxdWFkQ29ybmVyc1tpXVswXS55KSAmJlxuICAgICAgICAgIChyZWN0YW5nbGUueTEgPD0gcXVhZENvcm5lcnNbaV1bMl0ueSkpXG4gICAgICAgIGluZGV4ZXMucHVzaChpKTtcblxuICAgIHJldHVybiBpbmRleGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIGxpc3Qgb2YgaW5kZXhlcyBvZiBub2RlcyBjb250YWluaW5nIGEgbm9uLWF4aXMtYWxpZ25lZCByZWN0YW5nbGVcbiAgICpcbiAgICogQHBhcmFtICB7YXJyYXl9ICBjb3JuZXJzICAgICAgQW4gYXJyYXkgY29udGFpbmluZyBlYWNoIGNvcm5lciBvZiB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjdGFuZ2xlIGRlZmluZWQgYnkgaXRzIGNvb3JkaW5hdGVzICh4LCB5KS5cbiAgICogQHBhcmFtICB7YXJyYXl9ICBxdWFkQ29ybmVycyAgQW4gYXJyYXkgb2YgdGhlIHF1YWQgbm9kZXMnIGNvcm5lcnMuXG4gICAqIEByZXR1cm4ge2FycmF5fSAgICAgICAgICAgICAgIEFuIGFycmF5IG9mIGluZGV4ZXMgY29udGFpbmluZyBvbmUgdG9cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91ciBpbnRlZ2Vycy5cbiAgICovXG4gIGZ1bmN0aW9uIF9xdWFkQ29sbGlzaW9uKGNvcm5lcnMsIHF1YWRDb3JuZXJzKSB7XG4gICAgdmFyIGluZGV4ZXMgPSBbXTtcblxuICAgIC8vIEl0ZXJhdGluZyB0aHJvdWdoIHF1YWRzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspXG4gICAgICBpZiAoX2dlb20uY29sbGlzaW9uKGNvcm5lcnMsIHF1YWRDb3JuZXJzW2ldKSlcbiAgICAgICAgaW5kZXhlcy5wdXNoKGkpO1xuXG4gICAgcmV0dXJuIGluZGV4ZXM7XG4gIH1cblxuICAvKipcbiAgICogU3ViZGl2aWRlIGEgcXVhZCBieSBjcmVhdGluZyBhIG5vZGUgYXQgYSBwcmVjaXNlIGluZGV4LiBUaGUgZnVuY3Rpb24gZG9lc1xuICAgKiBub3QgZ2VuZXJhdGUgYWxsIGZvdXIgbm9kZXMgbm90IHRvIHBvdGVudGlhbGx5IGNyZWF0ZSB1bnVzZWQgbm9kZXMuXG4gICAqXG4gICAqIEBwYXJhbSAge2ludGVnZXJ9ICBpbmRleCBUaGUgaW5kZXggb2YgdGhlIG5vZGUgdG8gY3JlYXRlLlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgcXVhZCAgVGhlIHF1YWQgb2JqZWN0IHRvIHN1YmRpdmlkZS5cbiAgICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgIEEgbmV3IHF1YWQgcmVwcmVzZW50aW5nIHRoZSBub2RlIGNyZWF0ZWQuXG4gICAqL1xuICBmdW5jdGlvbiBfcXVhZFN1YmRpdmlkZShpbmRleCwgcXVhZCkge1xuICAgIHZhciBuZXh0ID0gcXVhZC5sZXZlbCArIDEsXG4gICAgICAgIHN1YncgPSBNYXRoLnJvdW5kKHF1YWQuYm91bmRzLndpZHRoIC8gMiksXG4gICAgICAgIHN1YmggPSBNYXRoLnJvdW5kKHF1YWQuYm91bmRzLmhlaWdodCAvIDIpLFxuICAgICAgICBxeCA9IE1hdGgucm91bmQocXVhZC5ib3VuZHMueCksXG4gICAgICAgIHF5ID0gTWF0aC5yb3VuZChxdWFkLmJvdW5kcy55KSxcbiAgICAgICAgeCxcbiAgICAgICAgeTtcblxuICAgIHN3aXRjaCAoaW5kZXgpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgeCA9IHF4O1xuICAgICAgICB5ID0gcXk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxOlxuICAgICAgICB4ID0gcXggKyBzdWJ3O1xuICAgICAgICB5ID0gcXk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICB4ID0gcXg7XG4gICAgICAgIHkgPSBxeSArIHN1Ymg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICB4ID0gcXggKyBzdWJ3O1xuICAgICAgICB5ID0gcXkgKyBzdWJoO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gX3F1YWRUcmVlKFxuICAgICAge3g6IHgsIHk6IHksIHdpZHRoOiBzdWJ3LCBoZWlnaHQ6IHN1Ymh9LFxuICAgICAgbmV4dCxcbiAgICAgIHF1YWQubWF4RWxlbWVudHMsXG4gICAgICBxdWFkLm1heExldmVsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWN1cnNpdmVseSBpbnNlcnQgYW4gZWxlbWVudCBpbnRvIHRoZSBxdWFkdHJlZS4gT25seSBwb2ludHNcbiAgICogd2l0aCBzaXplLCBpLmUuIGF4aXMtYWxpZ25lZCBzcXVhcmVzLCBtYXkgYmUgaW5zZXJ0ZWQgd2l0aCB0aGlzXG4gICAqIG1ldGhvZC5cbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgZWwgICAgICAgICBUaGUgZWxlbWVudCB0byBpbnNlcnQgaW4gdGhlIHF1YWR0cmVlLlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICBzaXplZFBvaW50IEEgc2l6ZWQgcG9pbnQgZGVmaW5lZCBieSB0d28gdG9wIHBvaW50c1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh4MSwgeTEpLCAoeDIsIHkyKSBhbmQgaGVpZ2h0LlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICBxdWFkICAgICAgIFRoZSBxdWFkIGluIHdoaWNoIHRvIGluc2VydCB0aGUgZWxlbWVudC5cbiAgICogQHJldHVybiB7dW5kZWZpbmVkfSAgICAgICAgICBUaGUgZnVuY3Rpb24gZG9lcyBub3QgcmV0dXJuIGFueXRoaW5nLlxuICAgKi9cbiAgZnVuY3Rpb24gX3F1YWRJbnNlcnQoZWwsIHNpemVkUG9pbnQsIHF1YWQpIHtcbiAgICBpZiAocXVhZC5sZXZlbCA8IHF1YWQubWF4TGV2ZWwpIHtcblxuICAgICAgLy8gU2VhcmNoaW5nIGFwcHJvcHJpYXRlIHF1YWRzXG4gICAgICB2YXIgaW5kZXhlcyA9IF9xdWFkSW5kZXhlcyhzaXplZFBvaW50LCBxdWFkLmNvcm5lcnMpO1xuXG4gICAgICAvLyBJdGVyYXRpbmdcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gaW5kZXhlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblxuICAgICAgICAvLyBTdWJkaXZpZGluZyBpZiBuZWNlc3NhcnlcbiAgICAgICAgaWYgKHF1YWQubm9kZXNbaW5kZXhlc1tpXV0gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICBxdWFkLm5vZGVzW2luZGV4ZXNbaV1dID0gX3F1YWRTdWJkaXZpZGUoaW5kZXhlc1tpXSwgcXVhZCk7XG5cbiAgICAgICAgLy8gUmVjdXJzaW9uXG4gICAgICAgIF9xdWFkSW5zZXJ0KGVsLCBzaXplZFBvaW50LCBxdWFkLm5vZGVzW2luZGV4ZXNbaV1dKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG5cbiAgICAgIC8vIFB1c2hpbmcgdGhlIGVsZW1lbnQgaW4gYSBsZWFmIG5vZGVcbiAgICAgIHF1YWQuZWxlbWVudHMucHVzaChlbCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlY3Vyc2l2ZWx5IHJldHJpZXZlIGV2ZXJ5IGVsZW1lbnRzIGhlbGQgYnkgdGhlIG5vZGUgY29udGFpbmluZyB0aGVcbiAgICogc2VhcmNoZWQgcG9pbnQuXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gIHBvaW50IFRoZSBzZWFyY2hlZCBwb2ludCAoeCwgeSkuXG4gICAqIEBwYXJhbSAge29iamVjdH0gIHF1YWQgIFRoZSBzZWFyY2hlZCBxdWFkLlxuICAgKiBAcmV0dXJuIHthcnJheX0gICAgICAgICBBbiBhcnJheSBvZiBlbGVtZW50cyBjb250YWluZWQgaW4gdGhlIHJlbGV2YW50XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuXG4gICAqL1xuICBmdW5jdGlvbiBfcXVhZFJldHJpZXZlUG9pbnQocG9pbnQsIHF1YWQpIHtcbiAgICBpZiAocXVhZC5sZXZlbCA8IHF1YWQubWF4TGV2ZWwpIHtcbiAgICAgIHZhciBpbmRleCA9IF9xdWFkSW5kZXgocG9pbnQsIHF1YWQuYm91bmRzKTtcblxuICAgICAgLy8gSWYgbm9kZSBkb2VzIG5vdCBleGlzdCB3ZSByZXR1cm4gYW4gZW1wdHkgbGlzdFxuICAgICAgaWYgKHF1YWQubm9kZXNbaW5kZXhdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIF9xdWFkUmV0cmlldmVQb2ludChwb2ludCwgcXVhZC5ub2Rlc1tpbmRleF0pO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gcXVhZC5lbGVtZW50cztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVjdXJzaXZlbHkgcmV0cmlldmUgZXZlcnkgZWxlbWVudHMgY29udGFpbmVkIHdpdGhpbiBhbiByZWN0YW5ndWxhciBhcmVhXG4gICAqIHRoYXQgbWF5IG9yIG1heSBub3QgYmUgYXhpcy1hbGlnbmVkLlxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R8YXJyYXl9IHJlY3REYXRhICAgICAgIFRoZSBzZWFyY2hlZCBhcmVhIGRlZmluZWQgZWl0aGVyIGJ5XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW4gYXJyYXkgb2YgZm91ciBjb3JuZXJzICh4LCB5KSBpblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBjYXNlIG9mIGEgbm9uLWF4aXMtYWxpZ25lZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY3RhbmdsZSBvciBhbiBvYmplY3Qgd2l0aCB0d28gdG9wXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzICh4MSwgeTEpLCAoeDIsIHkyKSBhbmQgaGVpZ2h0LlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgIHF1YWQgICAgICAgICAgIFRoZSBzZWFyY2hlZCBxdWFkLlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gICAgIGNvbGxpc2lvbkZ1bmMgIFRoZSBjb2xsaXNpb24gZnVuY3Rpb24gdXNlZCB0byBzZWFyY2hcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3Igbm9kZSBpbmRleGVzLlxuICAgKiBAcGFyYW0gIHthcnJheT99ICAgICAgIGVscyAgICAgICAgICAgIFRoZSByZXRyaWV2ZWQgZWxlbWVudHMuXG4gICAqIEByZXR1cm4ge2FycmF5fSAgICAgICAgICAgICAgICAgICAgICAgQW4gYXJyYXkgb2YgZWxlbWVudHMgY29udGFpbmVkIGluIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZWEuXG4gICAqL1xuICBmdW5jdGlvbiBfcXVhZFJldHJpZXZlQXJlYShyZWN0RGF0YSwgcXVhZCwgY29sbGlzaW9uRnVuYywgZWxzKSB7XG4gICAgZWxzID0gZWxzIHx8IHt9O1xuXG4gICAgaWYgKHF1YWQubGV2ZWwgPCBxdWFkLm1heExldmVsKSB7XG4gICAgICB2YXIgaW5kZXhlcyA9IGNvbGxpc2lvbkZ1bmMocmVjdERhdGEsIHF1YWQuY29ybmVycyk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gaW5kZXhlcy5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgIGlmIChxdWFkLm5vZGVzW2luZGV4ZXNbaV1dICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgX3F1YWRSZXRyaWV2ZUFyZWEoXG4gICAgICAgICAgICByZWN0RGF0YSxcbiAgICAgICAgICAgIHF1YWQubm9kZXNbaW5kZXhlc1tpXV0sXG4gICAgICAgICAgICBjb2xsaXNpb25GdW5jLFxuICAgICAgICAgICAgZWxzXG4gICAgICAgICAgKTtcbiAgICB9IGVsc2VcbiAgICAgIGZvciAodmFyIGogPSAwLCBtID0gcXVhZC5lbGVtZW50cy5sZW5ndGg7IGogPCBtOyBqKyspXG4gICAgICAgIGlmIChlbHNbcXVhZC5lbGVtZW50c1tqXS5pZF0gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICBlbHNbcXVhZC5lbGVtZW50c1tqXS5pZF0gPSBxdWFkLmVsZW1lbnRzW2pdO1xuXG4gICAgcmV0dXJuIGVscztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIHRoZSBxdWFkdHJlZSBvYmplY3QgaXRzZWxmLlxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgYm91bmRzICAgICAgIFRoZSBib3VuZGFyaWVzIG9mIHRoZSBxdWFkIGRlZmluZWQgYnkgYW5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW4gKHgsIHkpLCB3aWR0aCBhbmQgaGVpZ3RoLlxuICAgKiBAcGFyYW0gIHtpbnRlZ2VyfSAgbGV2ZWwgICAgICAgIFRoZSBsZXZlbCBvZiB0aGUgcXVhZCBpbiB0aGUgdHJlZS5cbiAgICogQHBhcmFtICB7aW50ZWdlcn0gIG1heEVsZW1lbnRzICBUaGUgbWF4IG51bWJlciBvZiBlbGVtZW50IGluIGEgbGVhZiBub2RlLlxuICAgKiBAcGFyYW0gIHtpbnRlZ2VyfSAgbWF4TGV2ZWwgICAgIFRoZSBtYXggcmVjdXJzaW9uIGxldmVsIG9mIHRoZSB0cmVlLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgICAgICAgICAgIFRoZSBxdWFkdHJlZSBvYmplY3QuXG4gICAqL1xuICBmdW5jdGlvbiBfcXVhZFRyZWUoYm91bmRzLCBsZXZlbCwgbWF4RWxlbWVudHMsIG1heExldmVsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxldmVsOiBsZXZlbCB8fCAwLFxuICAgICAgYm91bmRzOiBib3VuZHMsXG4gICAgICBjb3JuZXJzOiBfZ2VvbS5zcGxpdFNxdWFyZShib3VuZHMpLFxuICAgICAgbWF4RWxlbWVudHM6IG1heEVsZW1lbnRzIHx8IDQwLFxuICAgICAgbWF4TGV2ZWw6IG1heExldmVsIHx8IDgsXG4gICAgICBlbGVtZW50czogW10sXG4gICAgICBub2RlczogW11cbiAgICB9O1xuICB9XG5cblxuICAvKipcbiAgICogU2lnbWEgUXVhZCBDb25zdHJ1Y3RvclxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqXG4gICAqIFRoZSBlZGdlcXVhZCBBUEkgYXMgZXhwb3NlZCB0byBzaWdtYS5cbiAgICovXG5cbiAgLyoqXG4gICAqIFRoZSBlZGdlcXVhZCBjb3JlIHRoYXQgd2lsbCBiZWNvbWUgdGhlIHNpZ21hIGludGVyZmFjZSB3aXRoIHRoZSBxdWFkdHJlZS5cbiAgICpcbiAgICogcHJvcGVydHkge29iamVjdH0gX3RyZWUgICAgIFByb3BlcnR5IGhvbGRpbmcgdGhlIHF1YWR0cmVlIG9iamVjdC5cbiAgICogcHJvcGVydHkge29iamVjdH0gX2dlb20gICAgIEV4cG9zaXRpb24gb2YgdGhlIF9nZW9tIG5hbWVzcGFjZSBmb3IgdGVzdGluZy5cbiAgICogcHJvcGVydHkge29iamVjdH0gX2NhY2hlICAgIENhY2hlIGZvciB0aGUgYXJlYSBtZXRob2QuXG4gICAqIHByb3BlcnR5IHtib29sZWFufSBfZW5hYmxlZCBDYW4gaW5kZXggYW5kIHJldHJlaXZlIGVsZW1lbnRzLlxuICAgKi9cbiAgdmFyIGVkZ2VxdWFkID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fZ2VvbSA9IF9nZW9tO1xuICAgIHRoaXMuX3RyZWUgPSBudWxsO1xuICAgIHRoaXMuX2NhY2hlID0ge1xuICAgICAgcXVlcnk6IGZhbHNlLFxuICAgICAgcmVzdWx0OiBmYWxzZVxuICAgIH07XG4gICAgdGhpcy5fZW5hYmxlZCA9IHRydWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIEluZGV4IGEgZ3JhcGggYnkgaW5zZXJ0aW5nIGl0cyBlZGdlcyBpbnRvIHRoZSBxdWFkdHJlZS5cbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSBncmFwaCAgIEEgZ3JhcGggaW5zdGFuY2UuXG4gICAqIEBwYXJhbSAge29iamVjdH0gcGFyYW1zICBBbiBvYmplY3Qgb2YgcGFyYW1ldGVycyB3aXRoIGF0IGxlYXN0IHRoZSBxdWFkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBib3VuZHMuXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICBUaGUgcXVhZHRyZWUgb2JqZWN0LlxuICAgKlxuICAgKiBQYXJhbWV0ZXJzOlxuICAgKiAtLS0tLS0tLS0tXG4gICAqIGJvdW5kczogICAgICB7b2JqZWN0fSAgIGJvdW5kYXJpZXMgb2YgdGhlIHF1YWQgZGVmaW5lZCBieSBpdHMgb3JpZ2luICh4LCB5KVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCBhbmQgaGVpZ3RoLlxuICAgKiBwcmVmaXg6ICAgICAge3N0cmluZz99ICBhIHByZWZpeCBmb3IgZWRnZSBnZW9tZXRyaWMgYXR0cmlidXRlcy5cbiAgICogbWF4RWxlbWVudHM6IHtpbnRlZ2VyP30gdGhlIG1heCBudW1iZXIgb2YgZWxlbWVudHMgaW4gYSBsZWFmIG5vZGUuXG4gICAqIG1heExldmVsOiAgICB7aW50ZWdlcj99IHRoZSBtYXggcmVjdXJzaW9uIGxldmVsIG9mIHRoZSB0cmVlLlxuICAgKi9cbiAgZWRnZXF1YWQucHJvdG90eXBlLmluZGV4ID0gZnVuY3Rpb24oZ3JhcGgsIHBhcmFtcykge1xuICAgIGlmICghdGhpcy5fZW5hYmxlZClcbiAgICAgIHJldHVybiB0aGlzLl90cmVlO1xuXG4gICAgLy8gRW5mb3JjaW5nIHByZXNlbmNlIG9mIGJvdW5kYXJpZXNcbiAgICBpZiAoIXBhcmFtcy5ib3VuZHMpXG4gICAgICB0aHJvdyAnc2lnbWEuY2xhc3Nlcy5lZGdlcXVhZC5pbmRleDogYm91bmRzIGluZm9ybWF0aW9uIG5vdCBnaXZlbi4nO1xuXG4gICAgLy8gUHJlZml4XG4gICAgdmFyIHByZWZpeCA9IHBhcmFtcy5wcmVmaXggfHwgJycsXG4gICAgICAgIGNwLFxuICAgICAgICBzb3VyY2UsXG4gICAgICAgIHRhcmdldCxcbiAgICAgICAgbixcbiAgICAgICAgZTtcblxuICAgIC8vIEJ1aWxkaW5nIHRoZSB0cmVlXG4gICAgdGhpcy5fdHJlZSA9IF9xdWFkVHJlZShcbiAgICAgIHBhcmFtcy5ib3VuZHMsXG4gICAgICAwLFxuICAgICAgcGFyYW1zLm1heEVsZW1lbnRzLFxuICAgICAgcGFyYW1zLm1heExldmVsXG4gICAgKTtcblxuICAgIHZhciBlZGdlcyA9IGdyYXBoLmVkZ2VzKCk7XG5cbiAgICAvLyBJbnNlcnRpbmcgZ3JhcGggZWRnZXMgaW50byB0aGUgdHJlZVxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gZWRnZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBzb3VyY2UgPSBncmFwaC5ub2RlcyhlZGdlc1tpXS5zb3VyY2UpO1xuICAgICAgdGFyZ2V0ID0gZ3JhcGgubm9kZXMoZWRnZXNbaV0udGFyZ2V0KTtcbiAgICAgIGUgPSB7XG4gICAgICAgIHgxOiBzb3VyY2VbcHJlZml4ICsgJ3gnXSxcbiAgICAgICAgeTE6IHNvdXJjZVtwcmVmaXggKyAneSddLFxuICAgICAgICB4MjogdGFyZ2V0W3ByZWZpeCArICd4J10sXG4gICAgICAgIHkyOiB0YXJnZXRbcHJlZml4ICsgJ3knXSxcbiAgICAgICAgc2l6ZTogZWRnZXNbaV1bcHJlZml4ICsgJ3NpemUnXSB8fCAwXG4gICAgICB9O1xuXG4gICAgICAvLyBJbnNlcnRpbmcgZWRnZVxuICAgICAgaWYgKGVkZ2VzW2ldLnR5cGUgPT09ICdjdXJ2ZScgfHwgZWRnZXNbaV0udHlwZSA9PT0gJ2N1cnZlZEFycm93Jykge1xuICAgICAgICBpZiAoc291cmNlLmlkID09PSB0YXJnZXQuaWQpIHtcbiAgICAgICAgICBuID0ge1xuICAgICAgICAgICAgeDogc291cmNlW3ByZWZpeCArICd4J10sXG4gICAgICAgICAgICB5OiBzb3VyY2VbcHJlZml4ICsgJ3knXSxcbiAgICAgICAgICAgIHNpemU6IHNvdXJjZVtwcmVmaXggKyAnc2l6ZSddIHx8IDBcbiAgICAgICAgICB9O1xuICAgICAgICAgIF9xdWFkSW5zZXJ0KFxuICAgICAgICAgICAgZWRnZXNbaV0sXG4gICAgICAgICAgICBfZ2VvbS5zZWxmTG9vcFRvU3F1YXJlKG4pLFxuICAgICAgICAgICAgdGhpcy5fdHJlZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgY3AgPSBzaWdtYS51dGlscy5nZXRRdWFkcmF0aWNDb250cm9sUG9pbnQoZS54MSwgZS55MSwgZS54MiwgZS55Mik7XG4gICAgICAgICAgX3F1YWRJbnNlcnQoXG4gICAgICAgICAgICBlZGdlc1tpXSxcbiAgICAgICAgICAgIF9nZW9tLnF1YWRyYXRpY0N1cnZlVG9TcXVhcmUoZSwgY3ApLFxuICAgICAgICAgICAgdGhpcy5fdHJlZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBfcXVhZEluc2VydChcbiAgICAgICAgICBlZGdlc1tpXSxcbiAgICAgICAgICBfZ2VvbS5saW5lVG9TcXVhcmUoZSksXG4gICAgICAgICAgdGhpcy5fdHJlZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmVzZXQgY2FjaGU6XG4gICAgdGhpcy5fY2FjaGUgPSB7XG4gICAgICBxdWVyeTogZmFsc2UsXG4gICAgICByZXN1bHQ6IGZhbHNlXG4gICAgfTtcblxuICAgIC8vIHJlbW92ZT9cbiAgICByZXR1cm4gdGhpcy5fdHJlZTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0cmlldmUgZXZlcnkgZ3JhcGggZWRnZXMgaGVsZCBieSB0aGUgcXVhZHRyZWUgbm9kZSBjb250YWluaW5nIHRoZVxuICAgKiBzZWFyY2hlZCBwb2ludC5cbiAgICpcbiAgICogQHBhcmFtICB7bnVtYmVyfSB4IG9mIHRoZSBwb2ludC5cbiAgICogQHBhcmFtICB7bnVtYmVyfSB5IG9mIHRoZSBwb2ludC5cbiAgICogQHJldHVybiB7YXJyYXl9ICBBbiBhcnJheSBvZiBlZGdlcyByZXRyaWV2ZWQuXG4gICAqL1xuICBlZGdlcXVhZC5wcm90b3R5cGUucG9pbnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgaWYgKCF0aGlzLl9lbmFibGVkKVxuICAgICAgcmV0dXJuIFtdO1xuXG4gICAgcmV0dXJuIHRoaXMuX3RyZWUgP1xuICAgICAgX3F1YWRSZXRyaWV2ZVBvaW50KHt4OiB4LCB5OiB5fSwgdGhpcy5fdHJlZSkgfHwgW10gOlxuICAgICAgW107XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIGV2ZXJ5IGdyYXBoIGVkZ2VzIHdpdGhpbiBhIHJlY3Rhbmd1bGFyIGFyZWEuIFRoZSBtZXRob2RzIGtlZXAgdGhlXG4gICAqIGxhc3QgYXJlYSBxdWVyaWVkIGluIGNhY2hlIGZvciBvcHRpbWl6YXRpb24gcmVhc29uIGFuZCB3aWxsIGFjdCBkaWZmZXJlbnRseVxuICAgKiBmb3IgdGhlIHNhbWUgcmVhc29uIGlmIHRoZSBhcmVhIGlzIGF4aXMtYWxpZ25lZCBvciBub3QuXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gQSByZWN0YW5nbGUgZGVmaW5lZCBieSB0d28gdG9wIHBvaW50cyAoeDEsIHkxKSwgKHgyLCB5MilcbiAgICogICAgICAgICAgICAgICAgICBhbmQgaGVpZ2h0LlxuICAgKiBAcmV0dXJuIHthcnJheX0gIEFuIGFycmF5IG9mIGVkZ2VzIHJldHJpZXZlZC5cbiAgICovXG4gIGVkZ2VxdWFkLnByb3RvdHlwZS5hcmVhID0gZnVuY3Rpb24ocmVjdCkge1xuICAgIGlmICghdGhpcy5fZW5hYmxlZClcbiAgICAgIHJldHVybiBbXTtcblxuICAgIHZhciBzZXJpYWxpemVkID0gSlNPTi5zdHJpbmdpZnkocmVjdCksXG4gICAgICAgIGNvbGxpc2lvbkZ1bmMsXG4gICAgICAgIHJlY3REYXRhO1xuXG4gICAgLy8gUmV0dXJuaW5nIGNhY2hlP1xuICAgIGlmICh0aGlzLl9jYWNoZS5xdWVyeSA9PT0gc2VyaWFsaXplZClcbiAgICAgIHJldHVybiB0aGlzLl9jYWNoZS5yZXN1bHQ7XG5cbiAgICAvLyBBeGlzIGFsaWduZWQgP1xuICAgIGlmIChfZ2VvbS5pc0F4aXNBbGlnbmVkKHJlY3QpKSB7XG4gICAgICBjb2xsaXNpb25GdW5jID0gX3F1YWRJbmRleGVzO1xuICAgICAgcmVjdERhdGEgPSBfZ2VvbS5heGlzQWxpZ25lZFRvcFBvaW50cyhyZWN0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjb2xsaXNpb25GdW5jID0gX3F1YWRDb2xsaXNpb247XG4gICAgICByZWN0RGF0YSA9IF9nZW9tLnJlY3RhbmdsZUNvcm5lcnMocmVjdCk7XG4gICAgfVxuXG4gICAgLy8gUmV0cmlldmluZyBlZGdlc1xuICAgIHZhciBlZGdlcyA9IHRoaXMuX3RyZWUgP1xuICAgICAgX3F1YWRSZXRyaWV2ZUFyZWEoXG4gICAgICAgIHJlY3REYXRhLFxuICAgICAgICB0aGlzLl90cmVlLFxuICAgICAgICBjb2xsaXNpb25GdW5jXG4gICAgICApIDpcbiAgICAgIFtdO1xuXG4gICAgLy8gT2JqZWN0IHRvIGFycmF5XG4gICAgdmFyIGVkZ2VzQXJyYXkgPSBbXTtcbiAgICBmb3IgKHZhciBpIGluIGVkZ2VzKVxuICAgICAgZWRnZXNBcnJheS5wdXNoKGVkZ2VzW2ldKTtcblxuICAgIC8vIENhY2hpbmdcbiAgICB0aGlzLl9jYWNoZS5xdWVyeSA9IHNlcmlhbGl6ZWQ7XG4gICAgdGhpcy5fY2FjaGUucmVzdWx0ID0gZWRnZXNBcnJheTtcblxuICAgIHJldHVybiBlZGdlc0FycmF5O1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEVYUE9SVDpcbiAgICogKioqKioqKlxuICAgKi9cbiAgaWYgKHR5cGVvZiB0aGlzLnNpZ21hICE9PSAndW5kZWZpbmVkJykge1xuICAgIHRoaXMuc2lnbWEuY2xhc3NlcyA9IHRoaXMuc2lnbWEuY2xhc3NlcyB8fCB7fTtcbiAgICB0aGlzLnNpZ21hLmNsYXNzZXMuZWRnZXF1YWQgPSBlZGdlcXVhZDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpXG4gICAgICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBlZGdlcXVhZDtcbiAgICBleHBvcnRzLmVkZ2VxdWFkID0gZWRnZXF1YWQ7XG4gIH0gZWxzZVxuICAgIHRoaXMuZWRnZXF1YWQgPSBlZGdlcXVhZDtcbn0pLmNhbGwodGhpcyk7XG5cbjsoZnVuY3Rpb24odW5kZWZpbmVkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBpZiAodHlwZW9mIHNpZ21hID09PSAndW5kZWZpbmVkJylcbiAgICB0aHJvdyAnc2lnbWEgaXMgbm90IGRlY2xhcmVkJztcblxuICAvLyBJbml0aWFsaXplIHBhY2thZ2VzOlxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLmNhcHRvcnMnKTtcblxuICAvKipcbiAgICogVGhlIHVzZXIgaW5wdXRzIGRlZmF1bHQgY2FwdG9yLiBJdCBkZWFscyB3aXRoIG1vdXNlIGV2ZW50cywga2V5Ym9hcmRzXG4gICAqIGV2ZW50cyBhbmQgdG91Y2ggZXZlbnRzLlxuICAgKlxuICAgKiBAcGFyYW0gIHtET01FbGVtZW50fSAgIHRhcmdldCAgIFRoZSBET00gZWxlbWVudCB3aGVyZSB0aGUgbGlzdGVuZXJzIHdpbGwgYmVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3VuZC5cbiAgICogQHBhcmFtICB7Y2FtZXJhfSAgICAgICBjYW1lcmEgICBUaGUgY2FtZXJhIHJlbGF0ZWQgdG8gdGhlIHRhcmdldC5cbiAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSBzZXR0aW5ncyBUaGUgc2V0dGluZ3MgZnVuY3Rpb24uXG4gICAqIEByZXR1cm4ge3NpZ21hLmNhcHRvcn0gICAgICAgICAgVGhlIGZyZXNoIG5ldyBjYXB0b3IgaW5zdGFuY2UuXG4gICAqL1xuICBzaWdtYS5jYXB0b3JzLm1vdXNlID0gZnVuY3Rpb24odGFyZ2V0LCBjYW1lcmEsIHNldHRpbmdzKSB7XG4gICAgdmFyIF9zZWxmID0gdGhpcyxcbiAgICAgICAgX3RhcmdldCA9IHRhcmdldCxcbiAgICAgICAgX2NhbWVyYSA9IGNhbWVyYSxcbiAgICAgICAgX3NldHRpbmdzID0gc2V0dGluZ3MsXG5cbiAgICAgICAgLy8gQ0FNRVJBIE1BTkFHRU1FTlQ6XG4gICAgICAgIC8vICoqKioqKioqKioqKioqKioqKlxuICAgICAgICAvLyBUaGUgY2FtZXJhIHBvc2l0aW9uIHdoZW4gdGhlIHVzZXIgc3RhcnRzIGRyYWdnaW5nOlxuICAgICAgICBfc3RhcnRDYW1lcmFYLFxuICAgICAgICBfc3RhcnRDYW1lcmFZLFxuICAgICAgICBfc3RhcnRDYW1lcmFBbmdsZSxcblxuICAgICAgICAvLyBUaGUgbGF0ZXN0IHN0YWdlIHBvc2l0aW9uOlxuICAgICAgICBfbGFzdENhbWVyYVgsXG4gICAgICAgIF9sYXN0Q2FtZXJhWSxcbiAgICAgICAgX2xhc3RDYW1lcmFBbmdsZSxcbiAgICAgICAgX2xhc3RDYW1lcmFSYXRpbyxcblxuICAgICAgICAvLyBNT1VTRSBNQU5BR0VNRU5UOlxuICAgICAgICAvLyAqKioqKioqKioqKioqKioqKlxuICAgICAgICAvLyBUaGUgbW91c2UgcG9zaXRpb24gd2hlbiB0aGUgdXNlciBzdGFydHMgZHJhZ2dpbmc6XG4gICAgICAgIF9zdGFydE1vdXNlWCxcbiAgICAgICAgX3N0YXJ0TW91c2VZLFxuXG4gICAgICAgIF9pc01vdXNlRG93bixcbiAgICAgICAgX2lzTW92aW5nLFxuICAgICAgICBfaGFzRHJhZ2dlZCxcbiAgICAgICAgX2Rvd25TdGFydFRpbWUsXG4gICAgICAgIF9tb3ZpbmdUaW1lb3V0SWQ7XG5cbiAgICBzaWdtYS5jbGFzc2VzLmRpc3BhdGNoZXIuZXh0ZW5kKHRoaXMpO1xuXG4gICAgc2lnbWEudXRpbHMuZG91YmxlQ2xpY2soX3RhcmdldCwgJ2NsaWNrJywgX2RvdWJsZUNsaWNrSGFuZGxlcik7XG4gICAgX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCdET01Nb3VzZVNjcm9sbCcsIF93aGVlbEhhbmRsZXIsIGZhbHNlKTtcbiAgICBfdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNld2hlZWwnLCBfd2hlZWxIYW5kbGVyLCBmYWxzZSk7XG4gICAgX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBfbW92ZUhhbmRsZXIsIGZhbHNlKTtcbiAgICBfdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIF9kb3duSGFuZGxlciwgZmFsc2UpO1xuICAgIF90YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBfY2xpY2tIYW5kbGVyLCBmYWxzZSk7XG4gICAgX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsIF9vdXRIYW5kbGVyLCBmYWxzZSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIF91cEhhbmRsZXIsIGZhbHNlKTtcblxuXG5cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHVuYmluZHMgZXZlcnkgaGFuZGxlcnMgdGhhdCBtYWtlcyB0aGUgY2FwdG9yIHdvcmsuXG4gICAgICovXG4gICAgdGhpcy5raWxsID0gZnVuY3Rpb24oKSB7XG4gICAgICBzaWdtYS51dGlscy51bmJpbmREb3VibGVDbGljayhfdGFyZ2V0LCAnY2xpY2snKTtcbiAgICAgIF90YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignRE9NTW91c2VTY3JvbGwnLCBfd2hlZWxIYW5kbGVyKTtcbiAgICAgIF90YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V3aGVlbCcsIF93aGVlbEhhbmRsZXIpO1xuICAgICAgX3RhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBfbW92ZUhhbmRsZXIpO1xuICAgICAgX3RhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBfZG93bkhhbmRsZXIpO1xuICAgICAgX3RhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIF9jbGlja0hhbmRsZXIpO1xuICAgICAgX3RhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsIF9vdXRIYW5kbGVyKTtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBfdXBIYW5kbGVyKTtcbiAgICB9O1xuXG5cblxuXG4gICAgLy8gTU9VU0UgRVZFTlRTOlxuICAgIC8vICoqKioqKioqKioqKipcblxuICAgIC8qKlxuICAgICAqIFRoZSBoYW5kbGVyIGxpc3RlbmluZyB0byB0aGUgJ21vdmUnIG1vdXNlIGV2ZW50LiBJdCB3aWxsIGVmZmVjdGl2ZWx5XG4gICAgICogZHJhZyB0aGUgZ3JhcGguXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2V2ZW50fSBlIEEgbW91c2UgZXZlbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gX21vdmVIYW5kbGVyKGUpIHtcbiAgICAgIHZhciB4LFxuICAgICAgICAgIHksXG4gICAgICAgICAgcG9zO1xuXG4gICAgICAvLyBEaXNwYXRjaCBldmVudDpcbiAgICAgIGlmIChfc2V0dGluZ3MoJ21vdXNlRW5hYmxlZCcpKSB7XG4gICAgICAgIF9zZWxmLmRpc3BhdGNoRXZlbnQoJ21vdXNlbW92ZScsXG4gICAgICAgICAgc2lnbWEudXRpbHMubW91c2VDb29yZHMoZSkpO1xuXG4gICAgICAgIGlmIChfaXNNb3VzZURvd24pIHtcbiAgICAgICAgICBfaXNNb3ZpbmcgPSB0cnVlO1xuICAgICAgICAgIF9oYXNEcmFnZ2VkID0gdHJ1ZTtcblxuICAgICAgICAgIGlmIChfbW92aW5nVGltZW91dElkKVxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KF9tb3ZpbmdUaW1lb3V0SWQpO1xuXG4gICAgICAgICAgX21vdmluZ1RpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBfaXNNb3ZpbmcgPSBmYWxzZTtcbiAgICAgICAgICB9LCBfc2V0dGluZ3MoJ2RyYWdUaW1lb3V0JykpO1xuXG4gICAgICAgICAgc2lnbWEubWlzYy5hbmltYXRpb24ua2lsbEFsbChfY2FtZXJhKTtcblxuICAgICAgICAgIF9jYW1lcmEuaXNNb3ZpbmcgPSB0cnVlO1xuICAgICAgICAgIHBvcyA9IF9jYW1lcmEuY2FtZXJhUG9zaXRpb24oXG4gICAgICAgICAgICBzaWdtYS51dGlscy5nZXRYKGUpIC0gX3N0YXJ0TW91c2VYLFxuICAgICAgICAgICAgc2lnbWEudXRpbHMuZ2V0WShlKSAtIF9zdGFydE1vdXNlWSxcbiAgICAgICAgICAgIHRydWVcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgeCA9IF9zdGFydENhbWVyYVggLSBwb3MueDtcbiAgICAgICAgICB5ID0gX3N0YXJ0Q2FtZXJhWSAtIHBvcy55O1xuXG4gICAgICAgICAgaWYgKHggIT09IF9jYW1lcmEueCB8fCB5ICE9PSBfY2FtZXJhLnkpIHtcbiAgICAgICAgICAgIF9sYXN0Q2FtZXJhWCA9IF9jYW1lcmEueDtcbiAgICAgICAgICAgIF9sYXN0Q2FtZXJhWSA9IF9jYW1lcmEueTtcblxuICAgICAgICAgICAgX2NhbWVyYS5nb1RvKHtcbiAgICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgICAgeTogeVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGUucHJldmVudERlZmF1bHQpXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZS5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuXG4gICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaGFuZGxlciBsaXN0ZW5pbmcgdG8gdGhlICd1cCcgbW91c2UgZXZlbnQuIEl0IHdpbGwgc3RvcCBkcmFnZ2luZyB0aGVcbiAgICAgKiBncmFwaC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZXZlbnR9IGUgQSBtb3VzZSBldmVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfdXBIYW5kbGVyKGUpIHtcbiAgICAgIGlmIChfc2V0dGluZ3MoJ21vdXNlRW5hYmxlZCcpICYmIF9pc01vdXNlRG93bikge1xuICAgICAgICBfaXNNb3VzZURvd24gPSBmYWxzZTtcbiAgICAgICAgaWYgKF9tb3ZpbmdUaW1lb3V0SWQpXG4gICAgICAgICAgY2xlYXJUaW1lb3V0KF9tb3ZpbmdUaW1lb3V0SWQpO1xuXG4gICAgICAgIF9jYW1lcmEuaXNNb3ZpbmcgPSBmYWxzZTtcblxuICAgICAgICB2YXIgeCA9IHNpZ21hLnV0aWxzLmdldFgoZSksXG4gICAgICAgICAgICB5ID0gc2lnbWEudXRpbHMuZ2V0WShlKTtcblxuICAgICAgICBpZiAoX2lzTW92aW5nKSB7XG4gICAgICAgICAgc2lnbWEubWlzYy5hbmltYXRpb24ua2lsbEFsbChfY2FtZXJhKTtcbiAgICAgICAgICBzaWdtYS5taXNjLmFuaW1hdGlvbi5jYW1lcmEoXG4gICAgICAgICAgICBfY2FtZXJhLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB4OiBfY2FtZXJhLnggK1xuICAgICAgICAgICAgICAgIF9zZXR0aW5ncygnbW91c2VJbmVydGlhUmF0aW8nKSAqIChfY2FtZXJhLnggLSBfbGFzdENhbWVyYVgpLFxuICAgICAgICAgICAgICB5OiBfY2FtZXJhLnkgK1xuICAgICAgICAgICAgICAgIF9zZXR0aW5ncygnbW91c2VJbmVydGlhUmF0aW8nKSAqIChfY2FtZXJhLnkgLSBfbGFzdENhbWVyYVkpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBlYXNpbmc6ICdxdWFkcmF0aWNPdXQnLFxuICAgICAgICAgICAgICBkdXJhdGlvbjogX3NldHRpbmdzKCdtb3VzZUluZXJ0aWFEdXJhdGlvbicpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICBfc3RhcnRNb3VzZVggIT09IHggfHxcbiAgICAgICAgICBfc3RhcnRNb3VzZVkgIT09IHlcbiAgICAgICAgKVxuICAgICAgICAgIF9jYW1lcmEuZ29Ubyh7XG4gICAgICAgICAgICB4OiBfY2FtZXJhLngsXG4gICAgICAgICAgICB5OiBfY2FtZXJhLnlcbiAgICAgICAgICB9KTtcblxuICAgICAgICBfc2VsZi5kaXNwYXRjaEV2ZW50KCdtb3VzZXVwJyxcbiAgICAgICAgICBzaWdtYS51dGlscy5tb3VzZUNvb3JkcyhlKSk7XG5cbiAgICAgICAgLy8gVXBkYXRlIF9pc01vdmluZyBmbGFnOlxuICAgICAgICBfaXNNb3ZpbmcgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaGFuZGxlciBsaXN0ZW5pbmcgdG8gdGhlICdkb3duJyBtb3VzZSBldmVudC4gSXQgd2lsbCBzdGFydCBvYnNlcnZpbmdcbiAgICAgKiB0aGUgbW91c2UgcG9zaXRpb24gZm9yIGRyYWdnaW5nIHRoZSBncmFwaC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZXZlbnR9IGUgQSBtb3VzZSBldmVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfZG93bkhhbmRsZXIoZSkge1xuICAgICAgaWYgKF9zZXR0aW5ncygnbW91c2VFbmFibGVkJykpIHtcbiAgICAgICAgX3N0YXJ0Q2FtZXJhWCA9IF9jYW1lcmEueDtcbiAgICAgICAgX3N0YXJ0Q2FtZXJhWSA9IF9jYW1lcmEueTtcblxuICAgICAgICBfbGFzdENhbWVyYVggPSBfY2FtZXJhLng7XG4gICAgICAgIF9sYXN0Q2FtZXJhWSA9IF9jYW1lcmEueTtcblxuICAgICAgICBfc3RhcnRNb3VzZVggPSBzaWdtYS51dGlscy5nZXRYKGUpO1xuICAgICAgICBfc3RhcnRNb3VzZVkgPSBzaWdtYS51dGlscy5nZXRZKGUpO1xuXG4gICAgICAgIF9oYXNEcmFnZ2VkID0gZmFsc2U7XG4gICAgICAgIF9kb3duU3RhcnRUaW1lID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcblxuICAgICAgICBzd2l0Y2ggKGUud2hpY2gpIHtcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAvLyBNaWRkbGUgbW91c2UgYnV0dG9uIHByZXNzZWRcbiAgICAgICAgICAgIC8vIERvIG5vdGhpbmcuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAvLyBSaWdodCBtb3VzZSBidXR0b24gcHJlc3NlZFxuICAgICAgICAgICAgX3NlbGYuZGlzcGF0Y2hFdmVudCgncmlnaHRjbGljaycsXG4gICAgICAgICAgICAgIHNpZ21hLnV0aWxzLm1vdXNlQ29vcmRzKGUsIF9zdGFydE1vdXNlWCwgX3N0YXJ0TW91c2VZKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAvLyBjYXNlIDE6XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIC8vIExlZnQgbW91c2UgYnV0dG9uIHByZXNzZWRcbiAgICAgICAgICAgIF9pc01vdXNlRG93biA9IHRydWU7XG5cbiAgICAgICAgICAgIF9zZWxmLmRpc3BhdGNoRXZlbnQoJ21vdXNlZG93bicsXG4gICAgICAgICAgICAgIHNpZ21hLnV0aWxzLm1vdXNlQ29vcmRzKGUsIF9zdGFydE1vdXNlWCwgX3N0YXJ0TW91c2VZKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaGFuZGxlciBsaXN0ZW5pbmcgdG8gdGhlICdvdXQnIG1vdXNlIGV2ZW50LiBJdCB3aWxsIGp1c3QgcmVkaXNwYXRjaFxuICAgICAqIHRoZSBldmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZXZlbnR9IGUgQSBtb3VzZSBldmVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfb3V0SGFuZGxlcihlKSB7XG4gICAgICBpZiAoX3NldHRpbmdzKCdtb3VzZUVuYWJsZWQnKSlcbiAgICAgICAgX3NlbGYuZGlzcGF0Y2hFdmVudCgnbW91c2VvdXQnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaGFuZGxlciBsaXN0ZW5pbmcgdG8gdGhlICdjbGljaycgbW91c2UgZXZlbnQuIEl0IHdpbGwgcmVkaXNwYXRjaCB0aGVcbiAgICAgKiBjbGljayBldmVudCwgYnV0IHdpdGggbm9ybWFsaXplZCBYIGFuZCBZIGNvb3JkaW5hdGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtldmVudH0gZSBBIG1vdXNlIGV2ZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9jbGlja0hhbmRsZXIoZSkge1xuICAgICAgaWYgKF9zZXR0aW5ncygnbW91c2VFbmFibGVkJykpIHtcbiAgICAgICAgdmFyIGV2ZW50ID0gc2lnbWEudXRpbHMubW91c2VDb29yZHMoZSk7XG4gICAgICAgIGV2ZW50LmlzRHJhZ2dpbmcgPVxuICAgICAgICAgICgoKG5ldyBEYXRlKCkpLmdldFRpbWUoKSAtIF9kb3duU3RhcnRUaW1lKSA+IDEwMCkgJiYgX2hhc0RyYWdnZWQ7XG4gICAgICAgIF9zZWxmLmRpc3BhdGNoRXZlbnQoJ2NsaWNrJywgZXZlbnQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdClcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZWxzZVxuICAgICAgICBlLnJldHVyblZhbHVlID0gZmFsc2U7XG5cbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGhhbmRsZXIgbGlzdGVuaW5nIHRvIHRoZSBkb3VibGUgY2xpY2sgY3VzdG9tIGV2ZW50LiBJdCB3aWxsXG4gICAgICogYmFzaWNhbGx5IHpvb20gaW50byB0aGUgZ3JhcGguXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2V2ZW50fSBlIEEgbW91c2UgZXZlbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gX2RvdWJsZUNsaWNrSGFuZGxlcihlKSB7XG4gICAgICB2YXIgcG9zLFxuICAgICAgICAgIHJhdGlvLFxuICAgICAgICAgIGFuaW1hdGlvbjtcblxuICAgICAgaWYgKF9zZXR0aW5ncygnbW91c2VFbmFibGVkJykpIHtcbiAgICAgICAgcmF0aW8gPSAxIC8gX3NldHRpbmdzKCdkb3VibGVDbGlja1pvb21pbmdSYXRpbycpO1xuXG4gICAgICAgIF9zZWxmLmRpc3BhdGNoRXZlbnQoJ2RvdWJsZWNsaWNrJyxcbiAgICAgICAgICAgIHNpZ21hLnV0aWxzLm1vdXNlQ29vcmRzKGUsIF9zdGFydE1vdXNlWCwgX3N0YXJ0TW91c2VZKSk7XG5cbiAgICAgICAgaWYgKF9zZXR0aW5ncygnZG91YmxlQ2xpY2tFbmFibGVkJykpIHtcbiAgICAgICAgICBwb3MgPSBfY2FtZXJhLmNhbWVyYVBvc2l0aW9uKFxuICAgICAgICAgICAgc2lnbWEudXRpbHMuZ2V0WChlKSAtIHNpZ21hLnV0aWxzLmdldENlbnRlcihlKS54LFxuICAgICAgICAgICAgc2lnbWEudXRpbHMuZ2V0WShlKSAtIHNpZ21hLnV0aWxzLmdldENlbnRlcihlKS55LFxuICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICk7XG5cbiAgICAgICAgICBhbmltYXRpb24gPSB7XG4gICAgICAgICAgICBkdXJhdGlvbjogX3NldHRpbmdzKCdkb3VibGVDbGlja1pvb21EdXJhdGlvbicpXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHNpZ21hLnV0aWxzLnpvb21UbyhfY2FtZXJhLCBwb3MueCwgcG9zLnksIHJhdGlvLCBhbmltYXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGUucHJldmVudERlZmF1bHQpXG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgZS5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuXG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaGFuZGxlciBsaXN0ZW5pbmcgdG8gdGhlICd3aGVlbCcgbW91c2UgZXZlbnQuIEl0IHdpbGwgYmFzaWNhbGx5IHpvb21cbiAgICAgKiBpbiBvciBub3QgaW50byB0aGUgZ3JhcGguXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2V2ZW50fSBlIEEgbW91c2UgZXZlbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gX3doZWVsSGFuZGxlcihlKSB7XG4gICAgICB2YXIgcG9zLFxuICAgICAgICAgIHJhdGlvLFxuICAgICAgICAgIGFuaW1hdGlvbixcbiAgICAgICAgICB3aGVlbERlbHRhID0gc2lnbWEudXRpbHMuZ2V0RGVsdGEoZSk7XG5cbiAgICAgIGlmIChfc2V0dGluZ3MoJ21vdXNlRW5hYmxlZCcpICYmIF9zZXR0aW5ncygnbW91c2VXaGVlbEVuYWJsZWQnKSAmJiB3aGVlbERlbHRhICE9PSAwKSB7XG4gICAgICAgIHJhdGlvID0gd2hlZWxEZWx0YSA+IDAgP1xuICAgICAgICAgIDEgLyBfc2V0dGluZ3MoJ3pvb21pbmdSYXRpbycpIDpcbiAgICAgICAgICBfc2V0dGluZ3MoJ3pvb21pbmdSYXRpbycpO1xuXG4gICAgICAgIHBvcyA9IF9jYW1lcmEuY2FtZXJhUG9zaXRpb24oXG4gICAgICAgICAgc2lnbWEudXRpbHMuZ2V0WChlKSAtIHNpZ21hLnV0aWxzLmdldENlbnRlcihlKS54LFxuICAgICAgICAgIHNpZ21hLnV0aWxzLmdldFkoZSkgLSBzaWdtYS51dGlscy5nZXRDZW50ZXIoZSkueSxcbiAgICAgICAgICB0cnVlXG4gICAgICAgICk7XG5cbiAgICAgICAgYW5pbWF0aW9uID0ge1xuICAgICAgICAgIGR1cmF0aW9uOiBfc2V0dGluZ3MoJ21vdXNlWm9vbUR1cmF0aW9uJylcbiAgICAgICAgfTtcblxuICAgICAgICBzaWdtYS51dGlscy56b29tVG8oX2NhbWVyYSwgcG9zLngsIHBvcy55LCByYXRpbywgYW5pbWF0aW9uKTtcblxuICAgICAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdClcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBlLnJldHVyblZhbHVlID0gZmFsc2U7XG5cbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn0pLmNhbGwodGhpcyk7XG5cbjsoZnVuY3Rpb24odW5kZWZpbmVkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBpZiAodHlwZW9mIHNpZ21hID09PSAndW5kZWZpbmVkJylcbiAgICB0aHJvdyAnc2lnbWEgaXMgbm90IGRlY2xhcmVkJztcblxuICAvLyBJbml0aWFsaXplIHBhY2thZ2VzOlxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLmNhcHRvcnMnKTtcblxuICAvKipcbiAgICogVGhlIHVzZXIgaW5wdXRzIGRlZmF1bHQgY2FwdG9yLiBJdCBkZWFscyB3aXRoIG1vdXNlIGV2ZW50cywga2V5Ym9hcmRzXG4gICAqIGV2ZW50cyBhbmQgdG91Y2ggZXZlbnRzLlxuICAgKlxuICAgKiBAcGFyYW0gIHtET01FbGVtZW50fSAgIHRhcmdldCAgIFRoZSBET00gZWxlbWVudCB3aGVyZSB0aGUgbGlzdGVuZXJzIHdpbGwgYmVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3VuZC5cbiAgICogQHBhcmFtICB7Y2FtZXJhfSAgICAgICBjYW1lcmEgICBUaGUgY2FtZXJhIHJlbGF0ZWQgdG8gdGhlIHRhcmdldC5cbiAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSBzZXR0aW5ncyBUaGUgc2V0dGluZ3MgZnVuY3Rpb24uXG4gICAqIEByZXR1cm4ge3NpZ21hLmNhcHRvcn0gICAgICAgICAgVGhlIGZyZXNoIG5ldyBjYXB0b3IgaW5zdGFuY2UuXG4gICAqL1xuICBzaWdtYS5jYXB0b3JzLnRvdWNoID0gZnVuY3Rpb24odGFyZ2V0LCBjYW1lcmEsIHNldHRpbmdzKSB7XG4gICAgdmFyIF9zZWxmID0gdGhpcyxcbiAgICAgICAgX3RhcmdldCA9IHRhcmdldCxcbiAgICAgICAgX2NhbWVyYSA9IGNhbWVyYSxcbiAgICAgICAgX3NldHRpbmdzID0gc2V0dGluZ3MsXG5cbiAgICAgICAgLy8gQ0FNRVJBIE1BTkFHRU1FTlQ6XG4gICAgICAgIC8vICoqKioqKioqKioqKioqKioqKlxuICAgICAgICAvLyBUaGUgY2FtZXJhIHBvc2l0aW9uIHdoZW4gdGhlIHVzZXIgc3RhcnRzIGRyYWdnaW5nOlxuICAgICAgICBfc3RhcnRDYW1lcmFYLFxuICAgICAgICBfc3RhcnRDYW1lcmFZLFxuICAgICAgICBfc3RhcnRDYW1lcmFBbmdsZSxcbiAgICAgICAgX3N0YXJ0Q2FtZXJhUmF0aW8sXG5cbiAgICAgICAgLy8gVGhlIGxhdGVzdCBzdGFnZSBwb3NpdGlvbjpcbiAgICAgICAgX2xhc3RDYW1lcmFYLFxuICAgICAgICBfbGFzdENhbWVyYVksXG4gICAgICAgIF9sYXN0Q2FtZXJhQW5nbGUsXG4gICAgICAgIF9sYXN0Q2FtZXJhUmF0aW8sXG5cbiAgICAgICAgLy8gVE9VQ0ggTUFOQUdFTUVOVDpcbiAgICAgICAgLy8gKioqKioqKioqKioqKioqKipcbiAgICAgICAgLy8gVG91Y2hlcyB0aGF0IGFyZSBkb3duOlxuICAgICAgICBfZG93blRvdWNoZXMgPSBbXSxcblxuICAgICAgICBfc3RhcnRUb3VjaFgwLFxuICAgICAgICBfc3RhcnRUb3VjaFkwLFxuICAgICAgICBfc3RhcnRUb3VjaFgxLFxuICAgICAgICBfc3RhcnRUb3VjaFkxLFxuICAgICAgICBfc3RhcnRUb3VjaEFuZ2xlLFxuICAgICAgICBfc3RhcnRUb3VjaERpc3RhbmNlLFxuXG4gICAgICAgIF90b3VjaE1vZGUsXG5cbiAgICAgICAgX2lzTW92aW5nLFxuICAgICAgICBfZG91YmxlVGFwLFxuICAgICAgICBfbW92aW5nVGltZW91dElkO1xuXG4gICAgc2lnbWEuY2xhc3Nlcy5kaXNwYXRjaGVyLmV4dGVuZCh0aGlzKTtcblxuICAgIHNpZ21hLnV0aWxzLmRvdWJsZUNsaWNrKF90YXJnZXQsICd0b3VjaHN0YXJ0JywgX2RvdWJsZVRhcEhhbmRsZXIpO1xuICAgIF90YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIF9oYW5kbGVTdGFydCwgZmFsc2UpO1xuICAgIF90YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBfaGFuZGxlTGVhdmUsIGZhbHNlKTtcbiAgICBfdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgX2hhbmRsZUxlYXZlLCBmYWxzZSk7XG4gICAgX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGxlYXZlJywgX2hhbmRsZUxlYXZlLCBmYWxzZSk7XG4gICAgX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBfaGFuZGxlTW92ZSwgZmFsc2UpO1xuXG4gICAgZnVuY3Rpb24gcG9zaXRpb24oZSkge1xuICAgICAgdmFyIG9mZnNldCA9IHNpZ21hLnV0aWxzLmdldE9mZnNldChfdGFyZ2V0KTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogZS5wYWdlWCAtIG9mZnNldC5sZWZ0LFxuICAgICAgICB5OiBlLnBhZ2VZIC0gb2Zmc2V0LnRvcFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCB1bmJpbmRzIGV2ZXJ5IGhhbmRsZXJzIHRoYXQgbWFrZXMgdGhlIGNhcHRvciB3b3JrLlxuICAgICAqL1xuICAgIHRoaXMua2lsbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgc2lnbWEudXRpbHMudW5iaW5kRG91YmxlQ2xpY2soX3RhcmdldCwgJ3RvdWNoc3RhcnQnKTtcbiAgICAgIF90YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIF9oYW5kbGVTdGFydCk7XG4gICAgICBfdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgX2hhbmRsZUxlYXZlKTtcbiAgICAgIF90YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hjYW5jZWwnLCBfaGFuZGxlTGVhdmUpO1xuICAgICAgX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGxlYXZlJywgX2hhbmRsZUxlYXZlKTtcbiAgICAgIF90YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgX2hhbmRsZU1vdmUpO1xuICAgIH07XG5cbiAgICAvLyBUT1VDSCBFVkVOVFM6XG4gICAgLy8gKioqKioqKioqKioqKlxuICAgIC8qKlxuICAgICAqIFRoZSBoYW5kbGVyIGxpc3RlbmluZyB0byB0aGUgJ3RvdWNoc3RhcnQnIGV2ZW50LiBJdCB3aWxsIHNldCB0aGUgdG91Y2hcbiAgICAgKiBtb2RlIChcIl90b3VjaE1vZGVcIikgYW5kIHN0YXJ0IG9ic2VydmluZyB0aGUgdXNlciB0b3VjaCBtb3Zlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZXZlbnR9IGUgQSB0b3VjaCBldmVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfaGFuZGxlU3RhcnQoZSkge1xuICAgICAgaWYgKF9zZXR0aW5ncygndG91Y2hFbmFibGVkJykpIHtcbiAgICAgICAgdmFyIHgwLFxuICAgICAgICAgICAgeDEsXG4gICAgICAgICAgICB5MCxcbiAgICAgICAgICAgIHkxLFxuICAgICAgICAgICAgcG9zMCxcbiAgICAgICAgICAgIHBvczE7XG5cbiAgICAgICAgX2Rvd25Ub3VjaGVzID0gZS50b3VjaGVzO1xuXG4gICAgICAgIHN3aXRjaCAoX2Rvd25Ub3VjaGVzLmxlbmd0aCkge1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIF9jYW1lcmEuaXNNb3ZpbmcgPSB0cnVlO1xuICAgICAgICAgICAgX3RvdWNoTW9kZSA9IDE7XG5cbiAgICAgICAgICAgIF9zdGFydENhbWVyYVggPSBfY2FtZXJhLng7XG4gICAgICAgICAgICBfc3RhcnRDYW1lcmFZID0gX2NhbWVyYS55O1xuXG4gICAgICAgICAgICBfbGFzdENhbWVyYVggPSBfY2FtZXJhLng7XG4gICAgICAgICAgICBfbGFzdENhbWVyYVkgPSBfY2FtZXJhLnk7XG5cbiAgICAgICAgICAgIHBvczAgPSBwb3NpdGlvbihfZG93blRvdWNoZXNbMF0pO1xuICAgICAgICAgICAgX3N0YXJ0VG91Y2hYMCA9IHBvczAueDtcbiAgICAgICAgICAgIF9zdGFydFRvdWNoWTAgPSBwb3MwLnk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIF9jYW1lcmEuaXNNb3ZpbmcgPSB0cnVlO1xuICAgICAgICAgICAgX3RvdWNoTW9kZSA9IDI7XG5cbiAgICAgICAgICAgIHBvczAgPSBwb3NpdGlvbihfZG93blRvdWNoZXNbMF0pO1xuICAgICAgICAgICAgcG9zMSA9IHBvc2l0aW9uKF9kb3duVG91Y2hlc1sxXSk7XG4gICAgICAgICAgICB4MCA9IHBvczAueDtcbiAgICAgICAgICAgIHkwID0gcG9zMC55O1xuICAgICAgICAgICAgeDEgPSBwb3MxLng7XG4gICAgICAgICAgICB5MSA9IHBvczEueTtcblxuICAgICAgICAgICAgX2xhc3RDYW1lcmFYID0gX2NhbWVyYS54O1xuICAgICAgICAgICAgX2xhc3RDYW1lcmFZID0gX2NhbWVyYS55O1xuXG4gICAgICAgICAgICBfc3RhcnRDYW1lcmFBbmdsZSA9IF9jYW1lcmEuYW5nbGU7XG4gICAgICAgICAgICBfc3RhcnRDYW1lcmFSYXRpbyA9IF9jYW1lcmEucmF0aW87XG5cbiAgICAgICAgICAgIF9zdGFydENhbWVyYVggPSBfY2FtZXJhLng7XG4gICAgICAgICAgICBfc3RhcnRDYW1lcmFZID0gX2NhbWVyYS55O1xuXG4gICAgICAgICAgICBfc3RhcnRUb3VjaFgwID0geDA7XG4gICAgICAgICAgICBfc3RhcnRUb3VjaFkwID0geTA7XG4gICAgICAgICAgICBfc3RhcnRUb3VjaFgxID0geDE7XG4gICAgICAgICAgICBfc3RhcnRUb3VjaFkxID0geTE7XG5cbiAgICAgICAgICAgIF9zdGFydFRvdWNoQW5nbGUgPSBNYXRoLmF0YW4yKFxuICAgICAgICAgICAgICBfc3RhcnRUb3VjaFkxIC0gX3N0YXJ0VG91Y2hZMCxcbiAgICAgICAgICAgICAgX3N0YXJ0VG91Y2hYMSAtIF9zdGFydFRvdWNoWDBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBfc3RhcnRUb3VjaERpc3RhbmNlID0gTWF0aC5zcXJ0KFxuICAgICAgICAgICAgICAoX3N0YXJ0VG91Y2hZMSAtIF9zdGFydFRvdWNoWTApICpcbiAgICAgICAgICAgICAgICAoX3N0YXJ0VG91Y2hZMSAtIF9zdGFydFRvdWNoWTApICtcbiAgICAgICAgICAgICAgKF9zdGFydFRvdWNoWDEgLSBfc3RhcnRUb3VjaFgwKSAqXG4gICAgICAgICAgICAgICAgKF9zdGFydFRvdWNoWDEgLSBfc3RhcnRUb3VjaFgwKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGhhbmRsZXIgbGlzdGVuaW5nIHRvIHRoZSAndG91Y2hlbmQnLCAndG91Y2hjYW5jZWwnIGFuZCAndG91Y2hsZWF2ZSdcbiAgICAgKiBldmVudC4gSXQgd2lsbCB1cGRhdGUgdGhlIHRvdWNoIG1vZGUgaWYgdGhlcmUgYXJlIHN0aWxsIGF0IGxlYXN0IG9uZVxuICAgICAqIGZpbmdlciwgYW5kIHN0b3AgZHJhZ2dpbmcgZWxzZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZXZlbnR9IGUgQSB0b3VjaCBldmVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfaGFuZGxlTGVhdmUoZSkge1xuICAgICAgaWYgKF9zZXR0aW5ncygndG91Y2hFbmFibGVkJykpIHtcbiAgICAgICAgX2Rvd25Ub3VjaGVzID0gZS50b3VjaGVzO1xuICAgICAgICB2YXIgaW5lcnRpYVJhdGlvID0gX3NldHRpbmdzKCd0b3VjaEluZXJ0aWFSYXRpbycpO1xuXG4gICAgICAgIGlmIChfbW92aW5nVGltZW91dElkKSB7XG4gICAgICAgICAgX2lzTW92aW5nID0gZmFsc2U7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KF9tb3ZpbmdUaW1lb3V0SWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoIChfdG91Y2hNb2RlKSB7XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgaWYgKGUudG91Y2hlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgX2hhbmRsZVN0YXJ0KGUpO1xuXG4gICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgX2NhbWVyYS5pc01vdmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgX3NlbGYuZGlzcGF0Y2hFdmVudCgnc3RvcERyYWcnKTtcblxuICAgICAgICAgICAgaWYgKF9pc01vdmluZykge1xuICAgICAgICAgICAgICBfZG91YmxlVGFwID0gZmFsc2U7XG4gICAgICAgICAgICAgIHNpZ21hLm1pc2MuYW5pbWF0aW9uLmNhbWVyYShcbiAgICAgICAgICAgICAgICBfY2FtZXJhLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHg6IF9jYW1lcmEueCArXG4gICAgICAgICAgICAgICAgICAgIGluZXJ0aWFSYXRpbyAqIChfY2FtZXJhLnggLSBfbGFzdENhbWVyYVgpLFxuICAgICAgICAgICAgICAgICAgeTogX2NhbWVyYS55ICtcbiAgICAgICAgICAgICAgICAgICAgaW5lcnRpYVJhdGlvICogKF9jYW1lcmEueSAtIF9sYXN0Q2FtZXJhWSlcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGVhc2luZzogJ3F1YWRyYXRpY091dCcsXG4gICAgICAgICAgICAgICAgICBkdXJhdGlvbjogX3NldHRpbmdzKCd0b3VjaEluZXJ0aWFEdXJhdGlvbicpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfaXNNb3ZpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIF90b3VjaE1vZGUgPSAwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaGFuZGxlciBsaXN0ZW5pbmcgdG8gdGhlICd0b3VjaG1vdmUnIGV2ZW50LiBJdCB3aWxsIGVmZmVjdGl2ZWx5IGRyYWdcbiAgICAgKiB0aGUgZ3JhcGgsIGFuZCBldmVudHVhbGx5IHpvb21zIGFuZCB0dXJuIGl0IGlmIHRoZSB1c2VyIGlzIHVzaW5nIHR3b1xuICAgICAqIGZpbmdlcnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2V2ZW50fSBlIEEgdG91Y2ggZXZlbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gX2hhbmRsZU1vdmUoZSkge1xuICAgICAgaWYgKCFfZG91YmxlVGFwICYmIF9zZXR0aW5ncygndG91Y2hFbmFibGVkJykpIHtcbiAgICAgICAgdmFyIHgwLFxuICAgICAgICAgICAgeDEsXG4gICAgICAgICAgICB5MCxcbiAgICAgICAgICAgIHkxLFxuICAgICAgICAgICAgY29zLFxuICAgICAgICAgICAgc2luLFxuICAgICAgICAgICAgZW5kLFxuICAgICAgICAgICAgcG9zMCxcbiAgICAgICAgICAgIHBvczEsXG4gICAgICAgICAgICBkaWZmLFxuICAgICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgICBkQW5nbGUsXG4gICAgICAgICAgICBkUmF0aW8sXG4gICAgICAgICAgICBuZXdTdGFnZVgsXG4gICAgICAgICAgICBuZXdTdGFnZVksXG4gICAgICAgICAgICBuZXdTdGFnZVJhdGlvLFxuICAgICAgICAgICAgbmV3U3RhZ2VBbmdsZTtcblxuICAgICAgICBfZG93blRvdWNoZXMgPSBlLnRvdWNoZXM7XG4gICAgICAgIF9pc01vdmluZyA9IHRydWU7XG5cbiAgICAgICAgaWYgKF9tb3ZpbmdUaW1lb3V0SWQpXG4gICAgICAgICAgY2xlYXJUaW1lb3V0KF9tb3ZpbmdUaW1lb3V0SWQpO1xuXG4gICAgICAgIF9tb3ZpbmdUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIF9pc01vdmluZyA9IGZhbHNlO1xuICAgICAgICB9LCBfc2V0dGluZ3MoJ2RyYWdUaW1lb3V0JykpO1xuXG4gICAgICAgIHN3aXRjaCAoX3RvdWNoTW9kZSkge1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHBvczAgPSBwb3NpdGlvbihfZG93blRvdWNoZXNbMF0pO1xuICAgICAgICAgICAgeDAgPSBwb3MwLng7XG4gICAgICAgICAgICB5MCA9IHBvczAueTtcblxuICAgICAgICAgICAgZGlmZiA9IF9jYW1lcmEuY2FtZXJhUG9zaXRpb24oXG4gICAgICAgICAgICAgIHgwIC0gX3N0YXJ0VG91Y2hYMCxcbiAgICAgICAgICAgICAgeTAgLSBfc3RhcnRUb3VjaFkwLFxuICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBuZXdTdGFnZVggPSBfc3RhcnRDYW1lcmFYIC0gZGlmZi54O1xuICAgICAgICAgICAgbmV3U3RhZ2VZID0gX3N0YXJ0Q2FtZXJhWSAtIGRpZmYueTtcblxuICAgICAgICAgICAgaWYgKG5ld1N0YWdlWCAhPT0gX2NhbWVyYS54IHx8IG5ld1N0YWdlWSAhPT0gX2NhbWVyYS55KSB7XG4gICAgICAgICAgICAgIF9sYXN0Q2FtZXJhWCA9IF9jYW1lcmEueDtcbiAgICAgICAgICAgICAgX2xhc3RDYW1lcmFZID0gX2NhbWVyYS55O1xuXG4gICAgICAgICAgICAgIF9jYW1lcmEuZ29Ubyh7XG4gICAgICAgICAgICAgICAgeDogbmV3U3RhZ2VYLFxuICAgICAgICAgICAgICAgIHk6IG5ld1N0YWdlWVxuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBfc2VsZi5kaXNwYXRjaEV2ZW50KCdtb3VzZW1vdmUnLFxuICAgICAgICAgICAgICAgIHNpZ21hLnV0aWxzLm1vdXNlQ29vcmRzKGUsIHBvczAueCwgcG9zMC55KSk7XG5cbiAgICAgICAgICAgICAgX3NlbGYuZGlzcGF0Y2hFdmVudCgnZHJhZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgcG9zMCA9IHBvc2l0aW9uKF9kb3duVG91Y2hlc1swXSk7XG4gICAgICAgICAgICBwb3MxID0gcG9zaXRpb24oX2Rvd25Ub3VjaGVzWzFdKTtcbiAgICAgICAgICAgIHgwID0gcG9zMC54O1xuICAgICAgICAgICAgeTAgPSBwb3MwLnk7XG4gICAgICAgICAgICB4MSA9IHBvczEueDtcbiAgICAgICAgICAgIHkxID0gcG9zMS55O1xuXG4gICAgICAgICAgICBzdGFydCA9IF9jYW1lcmEuY2FtZXJhUG9zaXRpb24oXG4gICAgICAgICAgICAgIChfc3RhcnRUb3VjaFgwICsgX3N0YXJ0VG91Y2hYMSkgLyAyIC1cbiAgICAgICAgICAgICAgICBzaWdtYS51dGlscy5nZXRDZW50ZXIoZSkueCxcbiAgICAgICAgICAgICAgKF9zdGFydFRvdWNoWTAgKyBfc3RhcnRUb3VjaFkxKSAvIDIgLVxuICAgICAgICAgICAgICAgIHNpZ21hLnV0aWxzLmdldENlbnRlcihlKS55LFxuICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZW5kID0gX2NhbWVyYS5jYW1lcmFQb3NpdGlvbihcbiAgICAgICAgICAgICAgKHgwICsgeDEpIC8gMiAtIHNpZ21hLnV0aWxzLmdldENlbnRlcihlKS54LFxuICAgICAgICAgICAgICAoeTAgKyB5MSkgLyAyIC0gc2lnbWEudXRpbHMuZ2V0Q2VudGVyKGUpLnksXG4gICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGRBbmdsZSA9IE1hdGguYXRhbjIoeTEgLSB5MCwgeDEgLSB4MCkgLSBfc3RhcnRUb3VjaEFuZ2xlO1xuICAgICAgICAgICAgZFJhdGlvID0gTWF0aC5zcXJ0KFxuICAgICAgICAgICAgICAoeTEgLSB5MCkgKiAoeTEgLSB5MCkgKyAoeDEgLSB4MCkgKiAoeDEgLSB4MClcbiAgICAgICAgICAgICkgLyBfc3RhcnRUb3VjaERpc3RhbmNlO1xuXG4gICAgICAgICAgICAvLyBUcmFuc2xhdGlvbjpcbiAgICAgICAgICAgIHgwID0gc3RhcnQueDtcbiAgICAgICAgICAgIHkwID0gc3RhcnQueTtcblxuICAgICAgICAgICAgLy8gSG9tb3RoZXRpYyB0cmFuc2Zvcm1hdGlvbjpcbiAgICAgICAgICAgIG5ld1N0YWdlUmF0aW8gPSBfc3RhcnRDYW1lcmFSYXRpbyAvIGRSYXRpbztcbiAgICAgICAgICAgIHgwID0geDAgKiBkUmF0aW87XG4gICAgICAgICAgICB5MCA9IHkwICogZFJhdGlvO1xuXG4gICAgICAgICAgICAvLyBSb3RhdGlvbjpcbiAgICAgICAgICAgIG5ld1N0YWdlQW5nbGUgPSBfc3RhcnRDYW1lcmFBbmdsZSAtIGRBbmdsZTtcbiAgICAgICAgICAgIGNvcyA9IE1hdGguY29zKC1kQW5nbGUpO1xuICAgICAgICAgICAgc2luID0gTWF0aC5zaW4oLWRBbmdsZSk7XG4gICAgICAgICAgICB4MSA9IHgwICogY29zICsgeTAgKiBzaW47XG4gICAgICAgICAgICB5MSA9IHkwICogY29zIC0geDAgKiBzaW47XG4gICAgICAgICAgICB4MCA9IHgxO1xuICAgICAgICAgICAgeTAgPSB5MTtcblxuICAgICAgICAgICAgLy8gRmluYWxpemU6XG4gICAgICAgICAgICBuZXdTdGFnZVggPSB4MCAtIGVuZC54ICsgX3N0YXJ0Q2FtZXJhWDtcbiAgICAgICAgICAgIG5ld1N0YWdlWSA9IHkwIC0gZW5kLnkgKyBfc3RhcnRDYW1lcmFZO1xuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIG5ld1N0YWdlUmF0aW8gIT09IF9jYW1lcmEucmF0aW8gfHxcbiAgICAgICAgICAgICAgbmV3U3RhZ2VBbmdsZSAhPT0gX2NhbWVyYS5hbmdsZSB8fFxuICAgICAgICAgICAgICBuZXdTdGFnZVggIT09IF9jYW1lcmEueCB8fFxuICAgICAgICAgICAgICBuZXdTdGFnZVkgIT09IF9jYW1lcmEueVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIF9sYXN0Q2FtZXJhWCA9IF9jYW1lcmEueDtcbiAgICAgICAgICAgICAgX2xhc3RDYW1lcmFZID0gX2NhbWVyYS55O1xuICAgICAgICAgICAgICBfbGFzdENhbWVyYUFuZ2xlID0gX2NhbWVyYS5hbmdsZTtcbiAgICAgICAgICAgICAgX2xhc3RDYW1lcmFSYXRpbyA9IF9jYW1lcmEucmF0aW87XG5cbiAgICAgICAgICAgICAgX2NhbWVyYS5nb1RvKHtcbiAgICAgICAgICAgICAgICB4OiBuZXdTdGFnZVgsXG4gICAgICAgICAgICAgICAgeTogbmV3U3RhZ2VZLFxuICAgICAgICAgICAgICAgIGFuZ2xlOiBuZXdTdGFnZUFuZ2xlLFxuICAgICAgICAgICAgICAgIHJhdGlvOiBuZXdTdGFnZVJhdGlvXG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIF9zZWxmLmRpc3BhdGNoRXZlbnQoJ2RyYWcnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaGFuZGxlciBsaXN0ZW5pbmcgdG8gdGhlIGRvdWJsZSB0YXAgY3VzdG9tIGV2ZW50LiBJdCB3aWxsXG4gICAgICogYmFzaWNhbGx5IHpvb20gaW50byB0aGUgZ3JhcGguXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2V2ZW50fSBlIEEgdG91Y2ggZXZlbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gX2RvdWJsZVRhcEhhbmRsZXIoZSkge1xuICAgICAgdmFyIHBvcyxcbiAgICAgICAgICByYXRpbyxcbiAgICAgICAgICBhbmltYXRpb247XG5cbiAgICAgIGlmIChlLnRvdWNoZXMgJiYgZS50b3VjaGVzLmxlbmd0aCA9PT0gMSAmJiBfc2V0dGluZ3MoJ3RvdWNoRW5hYmxlZCcpKSB7XG4gICAgICAgIF9kb3VibGVUYXAgPSB0cnVlO1xuXG4gICAgICAgIHJhdGlvID0gMSAvIF9zZXR0aW5ncygnZG91YmxlQ2xpY2tab29taW5nUmF0aW8nKTtcblxuICAgICAgICBwb3MgPSBwb3NpdGlvbihlLnRvdWNoZXNbMF0pO1xuICAgICAgICBfc2VsZi5kaXNwYXRjaEV2ZW50KCdkb3VibGVjbGljaycsXG4gICAgICAgICAgc2lnbWEudXRpbHMubW91c2VDb29yZHMoZSwgcG9zLngsIHBvcy55KSk7XG5cbiAgICAgICAgaWYgKF9zZXR0aW5ncygnZG91YmxlQ2xpY2tFbmFibGVkJykpIHtcbiAgICAgICAgICBwb3MgPSBfY2FtZXJhLmNhbWVyYVBvc2l0aW9uKFxuICAgICAgICAgICAgcG9zLnggLSBzaWdtYS51dGlscy5nZXRDZW50ZXIoZSkueCxcbiAgICAgICAgICAgIHBvcy55IC0gc2lnbWEudXRpbHMuZ2V0Q2VudGVyKGUpLnksXG4gICAgICAgICAgICB0cnVlXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGFuaW1hdGlvbiA9IHtcbiAgICAgICAgICAgIGR1cmF0aW9uOiBfc2V0dGluZ3MoJ2RvdWJsZUNsaWNrWm9vbUR1cmF0aW9uJyksXG4gICAgICAgICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgX2RvdWJsZVRhcCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBzaWdtYS51dGlscy56b29tVG8oX2NhbWVyYSwgcG9zLngsIHBvcy55LCByYXRpbywgYW5pbWF0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlLnByZXZlbnREZWZhdWx0KVxuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGUucmV0dXJuVmFsdWUgPSBmYWxzZTtcblxuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9O1xufSkuY2FsbCh0aGlzKTtcblxuOyhmdW5jdGlvbih1bmRlZmluZWQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmICh0eXBlb2Ygc2lnbWEgPT09ICd1bmRlZmluZWQnKVxuICAgIHRocm93ICdzaWdtYSBpcyBub3QgZGVjbGFyZWQnO1xuXG4gIGlmICh0eXBlb2YgY29ucmFkID09PSAndW5kZWZpbmVkJylcbiAgICB0aHJvdyAnY29ucmFkIGlzIG5vdCBkZWNsYXJlZCc7XG5cbiAgLy8gSW5pdGlhbGl6ZSBwYWNrYWdlczpcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5yZW5kZXJlcnMnKTtcblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBpcyB0aGUgY29uc3RydWN0b3Igb2YgdGhlIGNhbnZhcyBzaWdtYSdzIHJlbmRlcmVyLlxuICAgKlxuICAgKiBAcGFyYW0gIHtzaWdtYS5jbGFzc2VzLmdyYXBofSAgICAgICAgICAgIGdyYXBoICAgIFRoZSBncmFwaCB0byByZW5kZXIuXG4gICAqIEBwYXJhbSAge3NpZ21hLmNsYXNzZXMuY2FtZXJhfSAgICAgICAgICAgY2FtZXJhICAgVGhlIGNhbWVyYS5cbiAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSAgICAgICAgICAgc2V0dGluZ3MgVGhlIHNpZ21hIGluc3RhbmNlIHNldHRpbmdzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICBvYmplY3QgICBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAqIEByZXR1cm4ge3NpZ21hLnJlbmRlcmVycy5jYW52YXN9ICAgICAgICAgIFRoZSByZW5kZXJlciBpbnN0YW5jZS5cbiAgICovXG4gIHNpZ21hLnJlbmRlcmVycy5jYW52YXMgPSBmdW5jdGlvbihncmFwaCwgY2FtZXJhLCBzZXR0aW5ncywgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpXG4gICAgICB0aHJvdyAnc2lnbWEucmVuZGVyZXJzLmNhbnZhczogV3JvbmcgYXJndW1lbnRzLic7XG5cbiAgICBpZiAoIShvcHRpb25zLmNvbnRhaW5lciBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSlcbiAgICAgIHRocm93ICdDb250YWluZXIgbm90IGZvdW5kLic7XG5cbiAgICB2YXIgayxcbiAgICAgICAgaSxcbiAgICAgICAgbCxcbiAgICAgICAgYSxcbiAgICAgICAgZm4sXG4gICAgICAgIHNlbGYgPSB0aGlzO1xuXG4gICAgc2lnbWEuY2xhc3Nlcy5kaXNwYXRjaGVyLmV4dGVuZCh0aGlzKTtcblxuICAgIC8vIEluaXRpYWxpemUgbWFpbiBhdHRyaWJ1dGVzOlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnY29ucmFkSWQnLCB7XG4gICAgICB2YWx1ZTogc2lnbWEudXRpbHMuaWQoKVxuICAgIH0pO1xuICAgIHRoaXMuZ3JhcGggPSBncmFwaDtcbiAgICB0aGlzLmNhbWVyYSA9IGNhbWVyYTtcbiAgICB0aGlzLmNvbnRleHRzID0ge307XG4gICAgdGhpcy5kb21FbGVtZW50cyA9IHt9O1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5jb250YWluZXIgPSB0aGlzLm9wdGlvbnMuY29udGFpbmVyO1xuICAgIHRoaXMuc2V0dGluZ3MgPSAoXG4gICAgICAgIHR5cGVvZiBvcHRpb25zLnNldHRpbmdzID09PSAnb2JqZWN0JyAmJlxuICAgICAgICBvcHRpb25zLnNldHRpbmdzXG4gICAgICApID9cbiAgICAgICAgc2V0dGluZ3MuZW1iZWRPYmplY3RzKG9wdGlvbnMuc2V0dGluZ3MpIDpcbiAgICAgICAgc2V0dGluZ3M7XG5cbiAgICAvLyBOb2RlIGluZGV4ZXM6XG4gICAgdGhpcy5ub2Rlc09uU2NyZWVuID0gW107XG4gICAgdGhpcy5lZGdlc09uU2NyZWVuID0gW107XG5cbiAgICAvLyBDb25yYWQgcmVsYXRlZCBhdHRyaWJ1dGVzOlxuICAgIHRoaXMuam9icyA9IHt9O1xuXG4gICAgLy8gRmluZCB0aGUgcHJlZml4OlxuICAgIHRoaXMub3B0aW9ucy5wcmVmaXggPSAncmVuZGVyZXInICsgdGhpcy5jb25yYWRJZCArICc6JztcblxuICAgIC8vIEluaXRpYWxpemUgdGhlIERPTSBlbGVtZW50czpcbiAgICBpZiAoXG4gICAgICAhdGhpcy5zZXR0aW5ncygnYmF0Y2hFZGdlc0RyYXdpbmcnKVxuICAgICkge1xuICAgICAgdGhpcy5pbml0RE9NKCdjYW52YXMnLCAnc2NlbmUnKTtcbiAgICAgIHRoaXMuY29udGV4dHMuZWRnZXMgPSB0aGlzLmNvbnRleHRzLnNjZW5lO1xuICAgICAgdGhpcy5jb250ZXh0cy5ub2RlcyA9IHRoaXMuY29udGV4dHMuc2NlbmU7XG4gICAgICB0aGlzLmNvbnRleHRzLmxhYmVscyA9IHRoaXMuY29udGV4dHMuc2NlbmU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaW5pdERPTSgnY2FudmFzJywgJ2VkZ2VzJyk7XG4gICAgICB0aGlzLmluaXRET00oJ2NhbnZhcycsICdzY2VuZScpO1xuICAgICAgdGhpcy5jb250ZXh0cy5ub2RlcyA9IHRoaXMuY29udGV4dHMuc2NlbmU7XG4gICAgICB0aGlzLmNvbnRleHRzLmxhYmVscyA9IHRoaXMuY29udGV4dHMuc2NlbmU7XG4gICAgfVxuXG4gICAgdGhpcy5pbml0RE9NKCdjYW52YXMnLCAnbW91c2UnKTtcbiAgICB0aGlzLmNvbnRleHRzLmhvdmVyID0gdGhpcy5jb250ZXh0cy5tb3VzZTtcblxuICAgIC8vIEluaXRpYWxpemUgY2FwdG9yczpcbiAgICB0aGlzLmNhcHRvcnMgPSBbXTtcbiAgICBhID0gdGhpcy5vcHRpb25zLmNhcHRvcnMgfHwgW3NpZ21hLmNhcHRvcnMubW91c2UsIHNpZ21hLmNhcHRvcnMudG91Y2hdO1xuICAgIGZvciAoaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgZm4gPSB0eXBlb2YgYVtpXSA9PT0gJ2Z1bmN0aW9uJyA/IGFbaV0gOiBzaWdtYS5jYXB0b3JzW2FbaV1dO1xuICAgICAgdGhpcy5jYXB0b3JzLnB1c2goXG4gICAgICAgIG5ldyBmbihcbiAgICAgICAgICB0aGlzLmRvbUVsZW1lbnRzLm1vdXNlLFxuICAgICAgICAgIHRoaXMuY2FtZXJhLFxuICAgICAgICAgIHRoaXMuc2V0dGluZ3NcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBEZWFsIHdpdGggc2lnbWEgZXZlbnRzOlxuICAgIHNpZ21hLm1pc2MuYmluZEV2ZW50cy5jYWxsKHRoaXMsIHRoaXMub3B0aW9ucy5wcmVmaXgpO1xuICAgIHNpZ21hLm1pc2MuZHJhd0hvdmVycy5jYWxsKHRoaXMsIHRoaXMub3B0aW9ucy5wcmVmaXgpO1xuXG4gICAgdGhpcy5yZXNpemUoZmFsc2UpO1xuICB9O1xuXG5cblxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCByZW5kZXJzIHRoZSBncmFwaCBvbiB0aGUgY2FudmFzZXMuXG4gICAqXG4gICAqIEBwYXJhbSAgez9vYmplY3R9ICAgICAgICAgICAgICAgIG9wdGlvbnMgRXZlbnR1YWxseSBhbiBvYmplY3Qgb2Ygb3B0aW9ucy5cbiAgICogQHJldHVybiB7c2lnbWEucmVuZGVyZXJzLmNhbnZhc30gICAgICAgICBSZXR1cm5zIHRoZSBpbnN0YW5jZSBpdHNlbGYuXG4gICAqL1xuICBzaWdtYS5yZW5kZXJlcnMuY2FudmFzLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICB2YXIgYSxcbiAgICAgICAgaSxcbiAgICAgICAgayxcbiAgICAgICAgbCxcbiAgICAgICAgbyxcbiAgICAgICAgaWQsXG4gICAgICAgIGVuZCxcbiAgICAgICAgam9iLFxuICAgICAgICBzdGFydCxcbiAgICAgICAgZWRnZXMsXG4gICAgICAgIHJlbmRlcmVycyxcbiAgICAgICAgcmVuZGVyZXJUeXBlLFxuICAgICAgICBiYXRjaFNpemUsXG4gICAgICAgIHRlbXBHQ08sXG4gICAgICAgIGluZGV4ID0ge30sXG4gICAgICAgIGdyYXBoID0gdGhpcy5ncmFwaCxcbiAgICAgICAgbm9kZXMgPSB0aGlzLmdyYXBoLm5vZGVzLFxuICAgICAgICBwcmVmaXggPSB0aGlzLm9wdGlvbnMucHJlZml4IHx8ICcnLFxuICAgICAgICBkcmF3RWRnZXMgPSB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdkcmF3RWRnZXMnKSxcbiAgICAgICAgZHJhd05vZGVzID0gdGhpcy5zZXR0aW5ncyhvcHRpb25zLCAnZHJhd05vZGVzJyksXG4gICAgICAgIGRyYXdMYWJlbHMgPSB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdkcmF3TGFiZWxzJyksXG4gICAgICAgIGRyYXdFZGdlTGFiZWxzID0gdGhpcy5zZXR0aW5ncyhvcHRpb25zLCAnZHJhd0VkZ2VMYWJlbHMnKSxcbiAgICAgICAgZW1iZWRTZXR0aW5ncyA9IHRoaXMuc2V0dGluZ3MuZW1iZWRPYmplY3RzKG9wdGlvbnMsIHtcbiAgICAgICAgICBwcmVmaXg6IHRoaXMub3B0aW9ucy5wcmVmaXhcbiAgICAgICAgfSk7XG5cbiAgICAvLyBDYWxsIHRoZSByZXNpemUgZnVuY3Rpb246XG4gICAgdGhpcy5yZXNpemUoZmFsc2UpO1xuXG4gICAgLy8gQ2hlY2sgdGhlICdoaWRlRWRnZXNPbk1vdmUnIHNldHRpbmc6XG4gICAgaWYgKHRoaXMuc2V0dGluZ3Mob3B0aW9ucywgJ2hpZGVFZGdlc09uTW92ZScpKVxuICAgICAgaWYgKHRoaXMuY2FtZXJhLmlzQW5pbWF0ZWQgfHwgdGhpcy5jYW1lcmEuaXNNb3ZpbmcpXG4gICAgICAgIGRyYXdFZGdlcyA9IGZhbHNlO1xuXG4gICAgLy8gQXBwbHkgdGhlIGNhbWVyYSdzIHZpZXc6XG4gICAgdGhpcy5jYW1lcmEuYXBwbHlWaWV3KFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAgdGhpcy5vcHRpb25zLnByZWZpeCxcbiAgICAgIHtcbiAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHRcbiAgICAgIH1cbiAgICApO1xuXG4gICAgLy8gQ2xlYXIgY2FudmFzZXM6XG4gICAgdGhpcy5jbGVhcigpO1xuXG4gICAgLy8gS2lsbCBydW5uaW5nIGpvYnM6XG4gICAgZm9yIChrIGluIHRoaXMuam9icylcbiAgICAgIGlmIChjb25yYWQuaGFzSm9iKGspKVxuICAgICAgICBjb25yYWQua2lsbEpvYihrKTtcblxuICAgIC8vIEZpbmQgd2hpY2ggbm9kZXMgYXJlIG9uIHNjcmVlbjpcbiAgICB0aGlzLmVkZ2VzT25TY3JlZW4gPSBbXTtcbiAgICB0aGlzLm5vZGVzT25TY3JlZW4gPSB0aGlzLmNhbWVyYS5xdWFkdHJlZS5hcmVhKFxuICAgICAgdGhpcy5jYW1lcmEuZ2V0UmVjdGFuZ2xlKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KVxuICAgICk7XG5cbiAgICBmb3IgKGEgPSB0aGlzLm5vZGVzT25TY3JlZW4sIGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICBpbmRleFthW2ldLmlkXSA9IGFbaV07XG5cbiAgICAvLyBEcmF3IGVkZ2VzOlxuICAgIC8vIC0gSWYgc2V0dGluZ3MoJ2JhdGNoRWRnZXNEcmF3aW5nJykgaXMgdHJ1ZSwgdGhlIGVkZ2VzIGFyZSBkaXNwbGF5ZWQgcGVyXG4gICAgLy8gICBiYXRjaGVzLiBJZiBub3QsIHRoZXkgYXJlIGRyYXduIGluIG9uZSBmcmFtZS5cbiAgICBpZiAoZHJhd0VkZ2VzKSB7XG4gICAgICAvLyBGaXJzdCwgbGV0J3MgaWRlbnRpZnkgd2hpY2ggZWRnZXMgdG8gZHJhdy4gVG8gZG8gdGhpcywgd2UganVzdCBrZWVwXG4gICAgICAvLyBldmVyeSBlZGdlcyB0aGF0IGhhdmUgYXQgbGVhc3Qgb25lIGV4dHJlbWl0eSBkaXNwbGF5ZWQgYWNjb3JkaW5nIHRvXG4gICAgICAvLyB0aGUgcXVhZHRyZWUgYW5kIHRoZSBcImhpZGRlblwiIGF0dHJpYnV0ZS4gV2UgYWxzbyBkbyBub3Qga2VlcCBoaWRkZW5cbiAgICAgIC8vIGVkZ2VzLlxuICAgICAgZm9yIChhID0gZ3JhcGguZWRnZXMoKSwgaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBvID0gYVtpXTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIChpbmRleFtvLnNvdXJjZV0gfHwgaW5kZXhbby50YXJnZXRdKSAmJlxuICAgICAgICAgICghby5oaWRkZW4gJiYgIW5vZGVzKG8uc291cmNlKS5oaWRkZW4gJiYgIW5vZGVzKG8udGFyZ2V0KS5oaWRkZW4pXG4gICAgICAgIClcbiAgICAgICAgICB0aGlzLmVkZ2VzT25TY3JlZW4ucHVzaChvKTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhlIFwiYmF0Y2hFZGdlc0RyYXdpbmdcIiBzZXR0aW5ncyBpcyB0cnVlLCBlZGdlcyBhcmUgYmF0Y2hlZDpcbiAgICAgIGlmICh0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdiYXRjaEVkZ2VzRHJhd2luZycpKSB7XG4gICAgICAgIGlkID0gJ2VkZ2VzXycgKyB0aGlzLmNvbnJhZElkO1xuICAgICAgICBiYXRjaFNpemUgPSBlbWJlZFNldHRpbmdzKCdjYW52YXNFZGdlc0JhdGNoU2l6ZScpO1xuXG4gICAgICAgIGVkZ2VzID0gdGhpcy5lZGdlc09uU2NyZWVuO1xuICAgICAgICBsID0gZWRnZXMubGVuZ3RoO1xuXG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgZW5kID0gTWF0aC5taW4oZWRnZXMubGVuZ3RoLCBzdGFydCArIGJhdGNoU2l6ZSk7XG5cbiAgICAgICAgam9iID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGVtcEdDTyA9IHRoaXMuY29udGV4dHMuZWRnZXMuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uO1xuICAgICAgICAgIHRoaXMuY29udGV4dHMuZWRnZXMuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2Rlc3RpbmF0aW9uLW92ZXInO1xuXG4gICAgICAgICAgcmVuZGVyZXJzID0gc2lnbWEuY2FudmFzLmVkZ2VzO1xuICAgICAgICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgICAgICAgIG8gPSBlZGdlc1tpXTtcbiAgICAgICAgICAgIChyZW5kZXJlcnNbXG4gICAgICAgICAgICAgIG8udHlwZSB8fCB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdkZWZhdWx0RWRnZVR5cGUnKVxuICAgICAgICAgICAgXSB8fCByZW5kZXJlcnMuZGVmKShcbiAgICAgICAgICAgICAgbyxcbiAgICAgICAgICAgICAgZ3JhcGgubm9kZXMoby5zb3VyY2UpLFxuICAgICAgICAgICAgICBncmFwaC5ub2RlcyhvLnRhcmdldCksXG4gICAgICAgICAgICAgIHRoaXMuY29udGV4dHMuZWRnZXMsXG4gICAgICAgICAgICAgIGVtYmVkU2V0dGluZ3NcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRHJhdyBlZGdlIGxhYmVsczpcbiAgICAgICAgICBpZiAoZHJhd0VkZ2VMYWJlbHMpIHtcbiAgICAgICAgICAgIHJlbmRlcmVycyA9IHNpZ21hLmNhbnZhcy5lZGdlcy5sYWJlbHM7XG4gICAgICAgICAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgICAgICAgIG8gPSBlZGdlc1tpXTtcbiAgICAgICAgICAgICAgaWYgKCFvLmhpZGRlbilcbiAgICAgICAgICAgICAgICAocmVuZGVyZXJzW1xuICAgICAgICAgICAgICAgICAgby50eXBlIHx8IHRoaXMuc2V0dGluZ3Mob3B0aW9ucywgJ2RlZmF1bHRFZGdlVHlwZScpXG4gICAgICAgICAgICAgICAgXSB8fCByZW5kZXJlcnMuZGVmKShcbiAgICAgICAgICAgICAgICAgIG8sXG4gICAgICAgICAgICAgICAgICBncmFwaC5ub2RlcyhvLnNvdXJjZSksXG4gICAgICAgICAgICAgICAgICBncmFwaC5ub2RlcyhvLnRhcmdldCksXG4gICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHRzLmxhYmVscyxcbiAgICAgICAgICAgICAgICAgIGVtYmVkU2V0dGluZ3NcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFJlc3RvcmUgb3JpZ2luYWwgZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uOlxuICAgICAgICAgIHRoaXMuY29udGV4dHMuZWRnZXMuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gdGVtcEdDTztcblxuICAgICAgICAgIC8vIENhdGNoIGpvYidzIGVuZDpcbiAgICAgICAgICBpZiAoZW5kID09PSBlZGdlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmpvYnNbaWRdO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHN0YXJ0ID0gZW5kICsgMTtcbiAgICAgICAgICBlbmQgPSBNYXRoLm1pbihlZGdlcy5sZW5ndGgsIHN0YXJ0ICsgYmF0Y2hTaXplKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmpvYnNbaWRdID0gam9iO1xuICAgICAgICBjb25yYWQuYWRkSm9iKGlkLCBqb2IuYmluZCh0aGlzKSk7XG5cbiAgICAgIC8vIElmIG5vdCwgdGhleSBhcmUgZHJhd24gaW4gb25lIGZyYW1lOlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVuZGVyZXJzID0gc2lnbWEuY2FudmFzLmVkZ2VzO1xuICAgICAgICBmb3IgKGEgPSB0aGlzLmVkZ2VzT25TY3JlZW4sIGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBvID0gYVtpXTtcbiAgICAgICAgICAocmVuZGVyZXJzW1xuICAgICAgICAgICAgby50eXBlIHx8IHRoaXMuc2V0dGluZ3Mob3B0aW9ucywgJ2RlZmF1bHRFZGdlVHlwZScpXG4gICAgICAgICAgXSB8fCByZW5kZXJlcnMuZGVmKShcbiAgICAgICAgICAgIG8sXG4gICAgICAgICAgICBncmFwaC5ub2RlcyhvLnNvdXJjZSksXG4gICAgICAgICAgICBncmFwaC5ub2RlcyhvLnRhcmdldCksXG4gICAgICAgICAgICB0aGlzLmNvbnRleHRzLmVkZ2VzLFxuICAgICAgICAgICAgZW1iZWRTZXR0aW5nc1xuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEcmF3IGVkZ2UgbGFiZWxzOlxuICAgICAgICAvLyAtIE5vIGJhdGNoaW5nXG4gICAgICAgIGlmIChkcmF3RWRnZUxhYmVscykge1xuICAgICAgICAgIHJlbmRlcmVycyA9IHNpZ21hLmNhbnZhcy5lZGdlcy5sYWJlbHM7XG4gICAgICAgICAgZm9yIChhID0gdGhpcy5lZGdlc09uU2NyZWVuLCBpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgICAgICAgaWYgKCFhW2ldLmhpZGRlbilcbiAgICAgICAgICAgICAgKHJlbmRlcmVyc1tcbiAgICAgICAgICAgICAgICBhW2ldLnR5cGUgfHwgdGhpcy5zZXR0aW5ncyhvcHRpb25zLCAnZGVmYXVsdEVkZ2VUeXBlJylcbiAgICAgICAgICAgICAgXSB8fCByZW5kZXJlcnMuZGVmKShcbiAgICAgICAgICAgICAgICBhW2ldLFxuICAgICAgICAgICAgICAgIGdyYXBoLm5vZGVzKGFbaV0uc291cmNlKSxcbiAgICAgICAgICAgICAgICBncmFwaC5ub2RlcyhhW2ldLnRhcmdldCksXG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0cy5sYWJlbHMsXG4gICAgICAgICAgICAgICAgZW1iZWRTZXR0aW5nc1xuICAgICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRHJhdyBub2RlczpcbiAgICAvLyAtIE5vIGJhdGNoaW5nXG4gICAgaWYgKGRyYXdOb2Rlcykge1xuICAgICAgcmVuZGVyZXJzID0gc2lnbWEuY2FudmFzLm5vZGVzO1xuICAgICAgZm9yIChhID0gdGhpcy5ub2Rlc09uU2NyZWVuLCBpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgICBpZiAoIWFbaV0uaGlkZGVuKVxuICAgICAgICAgIChyZW5kZXJlcnNbXG4gICAgICAgICAgICBhW2ldLnR5cGUgfHwgdGhpcy5zZXR0aW5ncyhvcHRpb25zLCAnZGVmYXVsdE5vZGVUeXBlJylcbiAgICAgICAgICBdIHx8IHJlbmRlcmVycy5kZWYpKFxuICAgICAgICAgICAgYVtpXSxcbiAgICAgICAgICAgIHRoaXMuY29udGV4dHMubm9kZXMsXG4gICAgICAgICAgICBlbWJlZFNldHRpbmdzXG4gICAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBEcmF3IGxhYmVsczpcbiAgICAvLyAtIE5vIGJhdGNoaW5nXG4gICAgaWYgKGRyYXdMYWJlbHMpIHtcbiAgICAgIHJlbmRlcmVycyA9IHNpZ21hLmNhbnZhcy5sYWJlbHM7XG4gICAgICBmb3IgKGEgPSB0aGlzLm5vZGVzT25TY3JlZW4sIGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgIGlmICghYVtpXS5oaWRkZW4pXG4gICAgICAgICAgKHJlbmRlcmVyc1tcbiAgICAgICAgICAgIGFbaV0udHlwZSB8fCB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdkZWZhdWx0Tm9kZVR5cGUnKVxuICAgICAgICAgIF0gfHwgcmVuZGVyZXJzLmRlZikoXG4gICAgICAgICAgICBhW2ldLFxuICAgICAgICAgICAgdGhpcy5jb250ZXh0cy5sYWJlbHMsXG4gICAgICAgICAgICBlbWJlZFNldHRpbmdzXG4gICAgICAgICAgKTtcbiAgICB9XG5cbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoJ3JlbmRlcicpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGNyZWF0ZXMgYSBET00gZWxlbWVudCBvZiB0aGUgc3BlY2lmaWVkIHR5cGUsIHN3aXRjaGVzIGl0c1xuICAgKiBwb3NpdGlvbiB0byBcImFic29sdXRlXCIsIHJlZmVyZW5jZXMgaXQgdG8gdGhlIGRvbUVsZW1lbnRzIGF0dHJpYnV0ZSwgYW5kXG4gICAqIGZpbmFsbHkgYXBwZW5kcyBpdCB0byB0aGUgY29udGFpbmVyLlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHRhZyBUaGUgbGFiZWwgdGFnLlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IGlkICBUaGUgaWQgb2YgdGhlIGVsZW1lbnQgKHRvIHN0b3JlIGl0IGluIFwiZG9tRWxlbWVudHNcIikuXG4gICAqL1xuICBzaWdtYS5yZW5kZXJlcnMuY2FudmFzLnByb3RvdHlwZS5pbml0RE9NID0gZnVuY3Rpb24odGFnLCBpZCkge1xuICAgIHZhciBkb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG5cbiAgICBkb20uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIGRvbS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ3NpZ21hLScgKyBpZCk7XG5cbiAgICB0aGlzLmRvbUVsZW1lbnRzW2lkXSA9IGRvbTtcbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZChkb20pO1xuXG4gICAgaWYgKHRhZy50b0xvd2VyQ2FzZSgpID09PSAnY2FudmFzJylcbiAgICAgIHRoaXMuY29udGV4dHNbaWRdID0gZG9tLmdldENvbnRleHQoJzJkJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHJlc2l6ZXMgZWFjaCBET00gZWxlbWVudHMgaW4gdGhlIGNvbnRhaW5lciBhbmQgc3RvcmVzIHRoZSBuZXdcbiAgICogZGltZW5zaW9ucy4gVGhlbiwgaXQgcmVuZGVycyB0aGUgZ3JhcGguXG4gICAqXG4gICAqIEBwYXJhbSAgez9udW1iZXJ9ICAgICAgICAgICAgICAgIHdpZHRoICBUaGUgbmV3IHdpZHRoIG9mIHRoZSBjb250YWluZXIuXG4gICAqIEBwYXJhbSAgez9udW1iZXJ9ICAgICAgICAgICAgICAgIGhlaWdodCBUaGUgbmV3IGhlaWdodCBvZiB0aGUgY29udGFpbmVyLlxuICAgKiBAcmV0dXJuIHtzaWdtYS5yZW5kZXJlcnMuY2FudmFzfSAgICAgICAgUmV0dXJucyB0aGUgaW5zdGFuY2UgaXRzZWxmLlxuICAgKi9cbiAgc2lnbWEucmVuZGVyZXJzLmNhbnZhcy5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24odywgaCkge1xuICAgIHZhciBrLFxuICAgICAgICBvbGRXaWR0aCA9IHRoaXMud2lkdGgsXG4gICAgICAgIG9sZEhlaWdodCA9IHRoaXMuaGVpZ2h0LFxuICAgICAgICBwaXhlbFJhdGlvID0gc2lnbWEudXRpbHMuZ2V0UGl4ZWxSYXRpbygpO1xuXG4gICAgaWYgKHcgIT09IHVuZGVmaW5lZCAmJiBoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMud2lkdGggPSB3O1xuICAgICAgdGhpcy5oZWlnaHQgPSBoO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndpZHRoID0gdGhpcy5jb250YWluZXIub2Zmc2V0V2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IHRoaXMuY29udGFpbmVyLm9mZnNldEhlaWdodDtcblxuICAgICAgdyA9IHRoaXMud2lkdGg7XG4gICAgICBoID0gdGhpcy5oZWlnaHQ7XG4gICAgfVxuXG4gICAgaWYgKG9sZFdpZHRoICE9PSB0aGlzLndpZHRoIHx8IG9sZEhlaWdodCAhPT0gdGhpcy5oZWlnaHQpIHtcbiAgICAgIGZvciAoayBpbiB0aGlzLmRvbUVsZW1lbnRzKSB7XG4gICAgICAgIHRoaXMuZG9tRWxlbWVudHNba10uc3R5bGUud2lkdGggPSB3ICsgJ3B4JztcbiAgICAgICAgdGhpcy5kb21FbGVtZW50c1trXS5zdHlsZS5oZWlnaHQgPSBoICsgJ3B4JztcblxuICAgICAgICBpZiAodGhpcy5kb21FbGVtZW50c1trXS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdjYW52YXMnKSB7XG4gICAgICAgICAgdGhpcy5kb21FbGVtZW50c1trXS5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgKHcgKiBwaXhlbFJhdGlvKSArICdweCcpO1xuICAgICAgICAgIHRoaXMuZG9tRWxlbWVudHNba10uc2V0QXR0cmlidXRlKCdoZWlnaHQnLCAoaCAqIHBpeGVsUmF0aW8pICsgJ3B4Jyk7XG5cbiAgICAgICAgICBpZiAocGl4ZWxSYXRpbyAhPT0gMSlcbiAgICAgICAgICAgIHRoaXMuY29udGV4dHNba10uc2NhbGUocGl4ZWxSYXRpbywgcGl4ZWxSYXRpbyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgY2xlYXJzIGVhY2ggY2FudmFzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzaWdtYS5yZW5kZXJlcnMuY2FudmFzfSBSZXR1cm5zIHRoZSBpbnN0YW5jZSBpdHNlbGYuXG4gICAqL1xuICBzaWdtYS5yZW5kZXJlcnMuY2FudmFzLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIGsgaW4gdGhpcy5jb250ZXh0cykge1xuICAgICAgdGhpcy5jb250ZXh0c1trXS5jbGVhclJlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBraWxscyBjb250ZXh0cyBhbmQgb3RoZXIgYXR0cmlidXRlcy5cbiAgICovXG4gIHNpZ21hLnJlbmRlcmVycy5jYW52YXMucHJvdG90eXBlLmtpbGwgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgayxcbiAgICAgICAgY2FwdG9yO1xuXG4gICAgLy8gS2lsbCBjYXB0b3JzOlxuICAgIHdoaWxlICgoY2FwdG9yID0gdGhpcy5jYXB0b3JzLnBvcCgpKSlcbiAgICAgIGNhcHRvci5raWxsKCk7XG4gICAgZGVsZXRlIHRoaXMuY2FwdG9ycztcblxuICAgIC8vIEtpbGwgY29udGV4dHM6XG4gICAgZm9yIChrIGluIHRoaXMuZG9tRWxlbWVudHMpIHtcbiAgICAgIHRoaXMuZG9tRWxlbWVudHNba10ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmRvbUVsZW1lbnRzW2tdKTtcbiAgICAgIGRlbGV0ZSB0aGlzLmRvbUVsZW1lbnRzW2tdO1xuICAgICAgZGVsZXRlIHRoaXMuY29udGV4dHNba107XG4gICAgfVxuICAgIGRlbGV0ZSB0aGlzLmRvbUVsZW1lbnRzO1xuICAgIGRlbGV0ZSB0aGlzLmNvbnRleHRzO1xuICB9O1xuXG5cblxuXG4gIC8qKlxuICAgKiBUaGUgbGFiZWxzLCBub2RlcyBhbmQgZWRnZXMgcmVuZGVyZXJzIGFyZSBzdG9yZWQgaW4gdGhlIHRocmVlIGZvbGxvd2luZ1xuICAgKiBvYmplY3RzLiBXaGVuIGFuIGVsZW1lbnQgaXMgZHJhd24sIGl0cyB0eXBlIHdpbGwgYmUgY2hlY2tlZCBhbmQgaWYgYVxuICAgKiByZW5kZXJlciB3aXRoIHRoZSBzYW1lIG5hbWUgZXhpc3RzLCBpdCB3aWxsIGJlIHVzZWQuIElmIG5vdCBmb3VuZCwgdGhlXG4gICAqIGRlZmF1bHQgcmVuZGVyZXIgd2lsbCBiZSB1c2VkIGluc3RlYWQuXG4gICAqXG4gICAqIFRoZXkgYXJlIHN0b3JlZCBpbiBkaWZmZXJlbnQgZmlsZXMsIGluIHRoZSBcIi4vY2FudmFzXCIgZm9sZGVyLlxuICAgKi9cbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5jYW52YXMubm9kZXMnKTtcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5jYW52YXMuZWRnZXMnKTtcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5jYW52YXMubGFiZWxzJyk7XG59KS5jYWxsKHRoaXMpO1xuXG47KGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgaWYgKHR5cGVvZiBzaWdtYSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgdGhyb3cgJ3NpZ21hIGlzIG5vdCBkZWNsYXJlZCc7XG5cbiAgLy8gSW5pdGlhbGl6ZSBwYWNrYWdlczpcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5yZW5kZXJlcnMnKTtcblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBpcyB0aGUgY29uc3RydWN0b3Igb2YgdGhlIGNhbnZhcyBzaWdtYSdzIHJlbmRlcmVyLlxuICAgKlxuICAgKiBAcGFyYW0gIHtzaWdtYS5jbGFzc2VzLmdyYXBofSAgICAgICAgICAgIGdyYXBoICAgIFRoZSBncmFwaCB0byByZW5kZXIuXG4gICAqIEBwYXJhbSAge3NpZ21hLmNsYXNzZXMuY2FtZXJhfSAgICAgICAgICAgY2FtZXJhICAgVGhlIGNhbWVyYS5cbiAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSAgICAgICAgICAgc2V0dGluZ3MgVGhlIHNpZ21hIGluc3RhbmNlIHNldHRpbmdzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICBvYmplY3QgICBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAqIEByZXR1cm4ge3NpZ21hLnJlbmRlcmVycy5jYW52YXN9ICAgICAgICAgIFRoZSByZW5kZXJlciBpbnN0YW5jZS5cbiAgICovXG4gIHNpZ21hLnJlbmRlcmVycy53ZWJnbCA9IGZ1bmN0aW9uKGdyYXBoLCBjYW1lcmEsIHNldHRpbmdzLCBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0JylcbiAgICAgIHRocm93ICdzaWdtYS5yZW5kZXJlcnMud2ViZ2w6IFdyb25nIGFyZ3VtZW50cy4nO1xuXG4gICAgaWYgKCEob3B0aW9ucy5jb250YWluZXIgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpXG4gICAgICB0aHJvdyAnQ29udGFpbmVyIG5vdCBmb3VuZC4nO1xuXG4gICAgdmFyIGssXG4gICAgICAgIGksXG4gICAgICAgIGwsXG4gICAgICAgIGEsXG4gICAgICAgIGZuLFxuICAgICAgICBfc2VsZiA9IHRoaXM7XG5cbiAgICBzaWdtYS5jbGFzc2VzLmRpc3BhdGNoZXIuZXh0ZW5kKHRoaXMpO1xuXG4gICAgLy8gQ29ucmFkIHJlbGF0ZWQgYXR0cmlidXRlczpcbiAgICB0aGlzLmpvYnMgPSB7fTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnY29ucmFkSWQnLCB7XG4gICAgICB2YWx1ZTogc2lnbWEudXRpbHMuaWQoKVxuICAgIH0pO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSBtYWluIGF0dHJpYnV0ZXM6XG4gICAgdGhpcy5ncmFwaCA9IGdyYXBoO1xuICAgIHRoaXMuY2FtZXJhID0gY2FtZXJhO1xuICAgIHRoaXMuY29udGV4dHMgPSB7fTtcbiAgICB0aGlzLmRvbUVsZW1lbnRzID0ge307XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmNvbnRhaW5lciA9IHRoaXMub3B0aW9ucy5jb250YWluZXI7XG4gICAgdGhpcy5zZXR0aW5ncyA9IChcbiAgICAgICAgdHlwZW9mIG9wdGlvbnMuc2V0dGluZ3MgPT09ICdvYmplY3QnICYmXG4gICAgICAgIG9wdGlvbnMuc2V0dGluZ3NcbiAgICAgICkgP1xuICAgICAgICBzZXR0aW5ncy5lbWJlZE9iamVjdHMob3B0aW9ucy5zZXR0aW5ncykgOlxuICAgICAgICBzZXR0aW5ncztcblxuICAgIC8vIEZpbmQgdGhlIHByZWZpeDpcbiAgICB0aGlzLm9wdGlvbnMucHJlZml4ID0gdGhpcy5jYW1lcmEucmVhZFByZWZpeDtcblxuICAgIC8vIEluaXRpYWxpemUgcHJvZ3JhbXMgaGFzaFxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbm9kZVByb2dyYW1zJywge1xuICAgICAgdmFsdWU6IHt9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdlZGdlUHJvZ3JhbXMnLCB7XG4gICAgICB2YWx1ZToge31cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ25vZGVGbG9hdEFycmF5cycsIHtcbiAgICAgIHZhbHVlOiB7fVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnZWRnZUZsb2F0QXJyYXlzJywge1xuICAgICAgdmFsdWU6IHt9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdlZGdlSW5kaWNlc0FycmF5cycsIHtcbiAgICAgIHZhbHVlOiB7fVxuICAgIH0pO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgRE9NIGVsZW1lbnRzOlxuICAgIGlmICh0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdiYXRjaEVkZ2VzRHJhd2luZycpKSB7XG4gICAgICB0aGlzLmluaXRET00oJ2NhbnZhcycsICdlZGdlcycsIHRydWUpO1xuICAgICAgdGhpcy5pbml0RE9NKCdjYW52YXMnLCAnbm9kZXMnLCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5pbml0RE9NKCdjYW52YXMnLCAnc2NlbmUnLCB0cnVlKTtcbiAgICAgIHRoaXMuY29udGV4dHMubm9kZXMgPSB0aGlzLmNvbnRleHRzLnNjZW5lO1xuICAgICAgdGhpcy5jb250ZXh0cy5lZGdlcyA9IHRoaXMuY29udGV4dHMuc2NlbmU7XG4gICAgfVxuXG4gICAgdGhpcy5pbml0RE9NKCdjYW52YXMnLCAnbGFiZWxzJyk7XG4gICAgdGhpcy5pbml0RE9NKCdjYW52YXMnLCAnbW91c2UnKTtcbiAgICB0aGlzLmNvbnRleHRzLmhvdmVyID0gdGhpcy5jb250ZXh0cy5tb3VzZTtcblxuICAgIC8vIEluaXRpYWxpemUgY2FwdG9yczpcbiAgICB0aGlzLmNhcHRvcnMgPSBbXTtcbiAgICBhID0gdGhpcy5vcHRpb25zLmNhcHRvcnMgfHwgW3NpZ21hLmNhcHRvcnMubW91c2UsIHNpZ21hLmNhcHRvcnMudG91Y2hdO1xuICAgIGZvciAoaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgZm4gPSB0eXBlb2YgYVtpXSA9PT0gJ2Z1bmN0aW9uJyA/IGFbaV0gOiBzaWdtYS5jYXB0b3JzW2FbaV1dO1xuICAgICAgdGhpcy5jYXB0b3JzLnB1c2goXG4gICAgICAgIG5ldyBmbihcbiAgICAgICAgICB0aGlzLmRvbUVsZW1lbnRzLm1vdXNlLFxuICAgICAgICAgIHRoaXMuY2FtZXJhLFxuICAgICAgICAgIHRoaXMuc2V0dGluZ3NcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBEZWFsIHdpdGggc2lnbWEgZXZlbnRzOlxuICAgIHNpZ21hLm1pc2MuYmluZEV2ZW50cy5jYWxsKHRoaXMsIHRoaXMuY2FtZXJhLnByZWZpeCk7XG4gICAgc2lnbWEubWlzYy5kcmF3SG92ZXJzLmNhbGwodGhpcywgdGhpcy5jYW1lcmEucHJlZml4KTtcblxuICAgIHRoaXMucmVzaXplKCk7XG4gIH07XG5cblxuXG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHdpbGwgZ2VuZXJhdGUgdGhlIG5vZGVzIGFuZCBlZGdlcyBmbG9hdCBhcnJheXMuIFRoaXMgc3RlcCBpc1xuICAgKiBzZXBhcmF0ZWQgZnJvbSB0aGUgXCJyZW5kZXJcIiBtZXRob2QsIGJlY2F1c2UgdG8ga2VlcCBXZWJHTCBlZmZpY2llbnQsIHNpbmNlXG4gICAqIGFsbCB0aGUgY2FtZXJhIGFuZCBtaWRkbGV3YXJlcyBhcmUgbW9kZWxpc2VkIGFzIG1hdHJpY2VzIGFuZCB0aGV5IGRvIG5vdFxuICAgKiByZXF1aXJlIHRoZSBmbG9hdCBhcnJheXMgdG8gYmUgcmVnZW5lcmF0ZWQuXG4gICAqXG4gICAqIEJhc2ljYWxseSwgd2hlbiB0aGUgdXNlciBtb3ZlcyB0aGUgY2FtZXJhIG9yIGFwcGxpZXMgc29tZSBzcGVjaWZpYyBsaW5lYXJcbiAgICogdHJhbnNmb3JtYXRpb25zLCB0aGlzIHByb2Nlc3Mgc3RlcCB3aWxsIGJlIHNraXBwZWQsIGFuZCB0aGUgXCJyZW5kZXJcIlxuICAgKiBtZXRob2Qgd2lsbCBlZmZpY2llbnRseSByZWZyZXNoIHRoZSByZW5kZXJpbmcuXG4gICAqXG4gICAqIEFuZCB3aGVuIHRoZSB1c2VyIG1vZGlmaWVzIHRoZSBncmFwaCBjb2xvcnMgb3IgcG9zaXRpb25zIChhcHBseWluZyBhIG5ld1xuICAgKiBsYXlvdXQgb3IgZmlsdGVyaW5nIHRoZSBjb2xvcnMsIGZvciBpbnN0YW5jZSksIHRoaXMgXCJwcm9jZXNzXCIgc3RlcCB3aWxsIGJlXG4gICAqIHJlcXVpcmVkIHRvIHJlZ2VuZXJhdGUgdGhlIGZsb2F0IGFycmF5cy5cbiAgICpcbiAgICogQHJldHVybiB7c2lnbWEucmVuZGVyZXJzLndlYmdsfSBSZXR1cm5zIHRoZSBpbnN0YW5jZSBpdHNlbGYuXG4gICAqL1xuICBzaWdtYS5yZW5kZXJlcnMud2ViZ2wucHJvdG90eXBlLnByb2Nlc3MgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYSxcbiAgICAgICAgaSxcbiAgICAgICAgbCxcbiAgICAgICAgayxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgcmVuZGVyZXIsXG4gICAgICAgIGdyYXBoID0gdGhpcy5ncmFwaCxcbiAgICAgICAgb3B0aW9ucyA9IHNpZ21hLnV0aWxzLmV4dGVuZChvcHRpb25zLCB0aGlzLm9wdGlvbnMpLFxuICAgICAgICBkZWZhdWx0RWRnZVR5cGUgPSB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdkZWZhdWx0RWRnZVR5cGUnKSxcbiAgICAgICAgZGVmYXVsdE5vZGVUeXBlID0gdGhpcy5zZXR0aW5ncyhvcHRpb25zLCAnZGVmYXVsdE5vZGVUeXBlJyk7XG5cbiAgICAvLyBFbXB0eSBmbG9hdCBhcnJheXM6XG4gICAgZm9yIChrIGluIHRoaXMubm9kZUZsb2F0QXJyYXlzKVxuICAgICAgZGVsZXRlIHRoaXMubm9kZUZsb2F0QXJyYXlzW2tdO1xuXG4gICAgZm9yIChrIGluIHRoaXMuZWRnZUZsb2F0QXJyYXlzKVxuICAgICAgZGVsZXRlIHRoaXMuZWRnZUZsb2F0QXJyYXlzW2tdO1xuXG4gICAgZm9yIChrIGluIHRoaXMuZWRnZUluZGljZXNBcnJheXMpXG4gICAgICBkZWxldGUgdGhpcy5lZGdlSW5kaWNlc0FycmF5c1trXTtcblxuICAgIC8vIFNvcnQgZWRnZXMgYW5kIG5vZGVzIHBlciB0eXBlczpcbiAgICBmb3IgKGEgPSBncmFwaC5lZGdlcygpLCBpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB0eXBlID0gYVtpXS50eXBlIHx8IGRlZmF1bHRFZGdlVHlwZTtcbiAgICAgIGsgPSAodHlwZSAmJiBzaWdtYS53ZWJnbC5lZGdlc1t0eXBlXSkgPyB0eXBlIDogJ2RlZic7XG5cbiAgICAgIGlmICghdGhpcy5lZGdlRmxvYXRBcnJheXNba10pXG4gICAgICAgIHRoaXMuZWRnZUZsb2F0QXJyYXlzW2tdID0ge1xuICAgICAgICAgIGVkZ2VzOiBbXVxuICAgICAgICB9O1xuXG4gICAgICB0aGlzLmVkZ2VGbG9hdEFycmF5c1trXS5lZGdlcy5wdXNoKGFbaV0pO1xuICAgIH1cblxuICAgIGZvciAoYSA9IGdyYXBoLm5vZGVzKCksIGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHR5cGUgPSBhW2ldLnR5cGUgfHwgZGVmYXVsdE5vZGVUeXBlO1xuICAgICAgayA9ICh0eXBlICYmIHNpZ21hLndlYmdsLm5vZGVzW3R5cGVdKSA/IHR5cGUgOiAnZGVmJztcblxuICAgICAgaWYgKCF0aGlzLm5vZGVGbG9hdEFycmF5c1trXSlcbiAgICAgICAgdGhpcy5ub2RlRmxvYXRBcnJheXNba10gPSB7XG4gICAgICAgICAgbm9kZXM6IFtdXG4gICAgICAgIH07XG5cbiAgICAgIHRoaXMubm9kZUZsb2F0QXJyYXlzW2tdLm5vZGVzLnB1c2goYVtpXSk7XG4gICAgfVxuXG4gICAgLy8gUHVzaCBlZGdlczpcbiAgICBmb3IgKGsgaW4gdGhpcy5lZGdlRmxvYXRBcnJheXMpIHtcbiAgICAgIHJlbmRlcmVyID0gc2lnbWEud2ViZ2wuZWRnZXNba107XG4gICAgICBhID0gdGhpcy5lZGdlRmxvYXRBcnJheXNba10uZWRnZXM7XG5cbiAgICAgIC8vIENyZWF0aW5nIHRoZSBuZWNlc3NhcnkgYXJyYXlzXG4gICAgICB0aGlzLmVkZ2VGbG9hdEFycmF5c1trXS5hcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoXG4gICAgICAgIGEubGVuZ3RoICogcmVuZGVyZXIuUE9JTlRTICogcmVuZGVyZXIuQVRUUklCVVRFU1xuICAgICAgKTtcblxuICAgICAgZm9yIChpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cbiAgICAgICAgLy8gSnVzdCBjaGVjayB0aGF0IHRoZSBlZGdlIGFuZCBib3RoIGl0cyBleHRyZW1pdGllcyBhcmUgdmlzaWJsZTpcbiAgICAgICAgaWYgKFxuICAgICAgICAgICFhW2ldLmhpZGRlbiAmJlxuICAgICAgICAgICFncmFwaC5ub2RlcyhhW2ldLnNvdXJjZSkuaGlkZGVuICYmXG4gICAgICAgICAgIWdyYXBoLm5vZGVzKGFbaV0udGFyZ2V0KS5oaWRkZW5cbiAgICAgICAgKVxuICAgICAgICAgIHJlbmRlcmVyLmFkZEVkZ2UoXG4gICAgICAgICAgICBhW2ldLFxuICAgICAgICAgICAgZ3JhcGgubm9kZXMoYVtpXS5zb3VyY2UpLFxuICAgICAgICAgICAgZ3JhcGgubm9kZXMoYVtpXS50YXJnZXQpLFxuICAgICAgICAgICAgdGhpcy5lZGdlRmxvYXRBcnJheXNba10uYXJyYXksXG4gICAgICAgICAgICBpICogcmVuZGVyZXIuUE9JTlRTICogcmVuZGVyZXIuQVRUUklCVVRFUyxcbiAgICAgICAgICAgIG9wdGlvbnMucHJlZml4LFxuICAgICAgICAgICAgdGhpcy5zZXR0aW5nc1xuICAgICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgcmVuZGVyZXIuY29tcHV0ZUluZGljZXMgPT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRoaXMuZWRnZUluZGljZXNBcnJheXNba10gPSByZW5kZXJlci5jb21wdXRlSW5kaWNlcyhcbiAgICAgICAgICB0aGlzLmVkZ2VGbG9hdEFycmF5c1trXS5hcnJheVxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8vIFB1c2ggbm9kZXM6XG4gICAgZm9yIChrIGluIHRoaXMubm9kZUZsb2F0QXJyYXlzKSB7XG4gICAgICByZW5kZXJlciA9IHNpZ21hLndlYmdsLm5vZGVzW2tdO1xuICAgICAgYSA9IHRoaXMubm9kZUZsb2F0QXJyYXlzW2tdLm5vZGVzO1xuXG4gICAgICAvLyBDcmVhdGluZyB0aGUgbmVjZXNzYXJ5IGFycmF5c1xuICAgICAgdGhpcy5ub2RlRmxvYXRBcnJheXNba10uYXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KFxuICAgICAgICBhLmxlbmd0aCAqIHJlbmRlcmVyLlBPSU5UUyAqIHJlbmRlcmVyLkFUVFJJQlVURVNcbiAgICAgICk7XG5cbiAgICAgIGZvciAoaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoIXRoaXMubm9kZUZsb2F0QXJyYXlzW2tdLmFycmF5KVxuICAgICAgICAgIHRoaXMubm9kZUZsb2F0QXJyYXlzW2tdLmFycmF5ID0gbmV3IEZsb2F0MzJBcnJheShcbiAgICAgICAgICAgIGEubGVuZ3RoICogcmVuZGVyZXIuUE9JTlRTICogcmVuZGVyZXIuQVRUUklCVVRFU1xuICAgICAgICAgICk7XG5cbiAgICAgICAgLy8gSnVzdCBjaGVjayB0aGF0IHRoZSBlZGdlIGFuZCBib3RoIGl0cyBleHRyZW1pdGllcyBhcmUgdmlzaWJsZTpcbiAgICAgICAgaWYgKFxuICAgICAgICAgICFhW2ldLmhpZGRlblxuICAgICAgICApXG4gICAgICAgICAgcmVuZGVyZXIuYWRkTm9kZShcbiAgICAgICAgICAgIGFbaV0sXG4gICAgICAgICAgICB0aGlzLm5vZGVGbG9hdEFycmF5c1trXS5hcnJheSxcbiAgICAgICAgICAgIGkgKiByZW5kZXJlci5QT0lOVFMgKiByZW5kZXJlci5BVFRSSUJVVEVTLFxuICAgICAgICAgICAgb3B0aW9ucy5wcmVmaXgsXG4gICAgICAgICAgICB0aGlzLnNldHRpbmdzXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuXG5cblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgcmVuZGVycyB0aGUgZ3JhcGguIEl0IGJhc2ljYWxseSBjYWxscyBlYWNoIHByb2dyYW0gKGFuZFxuICAgKiBnZW5lcmF0ZSB0aGVtIGlmIHRoZXkgZG8gbm90IGV4aXN0IHlldCkgdG8gcmVuZGVyIG5vZGVzIGFuZCBlZGdlcywgYmF0Y2hlZFxuICAgKiBwZXIgcmVuZGVyZXIuXG4gICAqXG4gICAqIEFzIGluIHRoZSBjYW52YXMgcmVuZGVyZXIsIGl0IGlzIHBvc3NpYmxlIHRvIGRpc3BsYXkgZWRnZXMsIG5vZGVzIGFuZCAvIG9yXG4gICAqIGxhYmVscyBpbiBiYXRjaGVzLCB0byBtYWtlIHRoZSB3aG9sZSB0aGluZyB3YXkgbW9yZSBzY2FsYWJsZS5cbiAgICpcbiAgICogQHBhcmFtICB7P29iamVjdH0gICAgICAgICAgICAgICBwYXJhbXMgRXZlbnR1YWxseSBhbiBvYmplY3Qgb2Ygb3B0aW9ucy5cbiAgICogQHJldHVybiB7c2lnbWEucmVuZGVyZXJzLndlYmdsfSAgICAgICAgUmV0dXJucyB0aGUgaW5zdGFuY2UgaXRzZWxmLlxuICAgKi9cbiAgc2lnbWEucmVuZGVyZXJzLndlYmdsLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICB2YXIgYSxcbiAgICAgICAgaSxcbiAgICAgICAgbCxcbiAgICAgICAgayxcbiAgICAgICAgbyxcbiAgICAgICAgcHJvZ3JhbSxcbiAgICAgICAgcmVuZGVyZXIsXG4gICAgICAgIHNlbGYgPSB0aGlzLFxuICAgICAgICBncmFwaCA9IHRoaXMuZ3JhcGgsXG4gICAgICAgIG5vZGVzR2wgPSB0aGlzLmNvbnRleHRzLm5vZGVzLFxuICAgICAgICBlZGdlc0dsID0gdGhpcy5jb250ZXh0cy5lZGdlcyxcbiAgICAgICAgbWF0cml4ID0gdGhpcy5jYW1lcmEuZ2V0TWF0cml4KCksXG4gICAgICAgIG9wdGlvbnMgPSBzaWdtYS51dGlscy5leHRlbmQocGFyYW1zLCB0aGlzLm9wdGlvbnMpLFxuICAgICAgICBkcmF3TGFiZWxzID0gdGhpcy5zZXR0aW5ncyhvcHRpb25zLCAnZHJhd0xhYmVscycpLFxuICAgICAgICBkcmF3RWRnZXMgPSB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdkcmF3RWRnZXMnKSxcbiAgICAgICAgZHJhd05vZGVzID0gdGhpcy5zZXR0aW5ncyhvcHRpb25zLCAnZHJhd05vZGVzJyk7XG5cbiAgICAvLyBDYWxsIHRoZSByZXNpemUgZnVuY3Rpb246XG4gICAgdGhpcy5yZXNpemUoZmFsc2UpO1xuXG4gICAgLy8gQ2hlY2sgdGhlICdoaWRlRWRnZXNPbk1vdmUnIHNldHRpbmc6XG4gICAgaWYgKHRoaXMuc2V0dGluZ3Mob3B0aW9ucywgJ2hpZGVFZGdlc09uTW92ZScpKVxuICAgICAgaWYgKHRoaXMuY2FtZXJhLmlzQW5pbWF0ZWQgfHwgdGhpcy5jYW1lcmEuaXNNb3ZpbmcpXG4gICAgICAgIGRyYXdFZGdlcyA9IGZhbHNlO1xuXG4gICAgLy8gQ2xlYXIgY2FudmFzZXM6XG4gICAgdGhpcy5jbGVhcigpO1xuXG4gICAgLy8gVHJhbnNsYXRlIG1hdHJpeCB0byBbd2lkdGgvMiwgaGVpZ2h0LzJdOlxuICAgIG1hdHJpeCA9IHNpZ21hLnV0aWxzLm1hdHJpY2VzLm11bHRpcGx5KFxuICAgICAgbWF0cml4LFxuICAgICAgc2lnbWEudXRpbHMubWF0cmljZXMudHJhbnNsYXRpb24odGhpcy53aWR0aCAvIDIsIHRoaXMuaGVpZ2h0IC8gMilcbiAgICApO1xuXG4gICAgLy8gS2lsbCBydW5uaW5nIGpvYnM6XG4gICAgZm9yIChrIGluIHRoaXMuam9icylcbiAgICAgIGlmIChjb25yYWQuaGFzSm9iKGspKVxuICAgICAgICBjb25yYWQua2lsbEpvYihrKTtcblxuICAgIGlmIChkcmF3RWRnZXMpIHtcbiAgICAgIGlmICh0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdiYXRjaEVkZ2VzRHJhd2luZycpKVxuICAgICAgICAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGEsXG4gICAgICAgICAgICAgIGssXG4gICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICBqb2IsXG4gICAgICAgICAgICAgIGFycixcbiAgICAgICAgICAgICAgZW5kLFxuICAgICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgICAgaW5kaWNlcyxcbiAgICAgICAgICAgICAgcmVuZGVyZXIsXG4gICAgICAgICAgICAgIGJhdGNoU2l6ZSxcbiAgICAgICAgICAgICAgY3VycmVudFByb2dyYW07XG5cbiAgICAgICAgICBpZCA9ICdlZGdlc18nICsgdGhpcy5jb25yYWRJZDtcbiAgICAgICAgICBiYXRjaFNpemUgPSB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICd3ZWJnbEVkZ2VzQmF0Y2hTaXplJyk7XG4gICAgICAgICAgYSA9IE9iamVjdC5rZXlzKHRoaXMuZWRnZUZsb2F0QXJyYXlzKTtcblxuICAgICAgICAgIGlmICghYS5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgcmVuZGVyZXIgPSBzaWdtYS53ZWJnbC5lZGdlc1thW2ldXTtcbiAgICAgICAgICBhcnIgPSB0aGlzLmVkZ2VGbG9hdEFycmF5c1thW2ldXS5hcnJheTtcbiAgICAgICAgICBpbmRpY2VzID0gdGhpcy5lZGdlSW5kaWNlc0FycmF5c1thW2ldXTtcbiAgICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgICAgZW5kID0gTWF0aC5taW4oXG4gICAgICAgICAgICBzdGFydCArIGJhdGNoU2l6ZSAqIHJlbmRlcmVyLlBPSU5UUyxcbiAgICAgICAgICAgIGFyci5sZW5ndGggLyByZW5kZXJlci5BVFRSSUJVVEVTXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGpvYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgcHJvZ3JhbTpcbiAgICAgICAgICAgIGlmICghdGhpcy5lZGdlUHJvZ3JhbXNbYVtpXV0pXG4gICAgICAgICAgICAgIHRoaXMuZWRnZVByb2dyYW1zW2FbaV1dID0gcmVuZGVyZXIuaW5pdFByb2dyYW0oZWRnZXNHbCk7XG5cbiAgICAgICAgICAgIGlmIChzdGFydCA8IGVuZCkge1xuICAgICAgICAgICAgICBlZGdlc0dsLnVzZVByb2dyYW0odGhpcy5lZGdlUHJvZ3JhbXNbYVtpXV0pO1xuICAgICAgICAgICAgICByZW5kZXJlci5yZW5kZXIoXG4gICAgICAgICAgICAgICAgZWRnZXNHbCxcbiAgICAgICAgICAgICAgICB0aGlzLmVkZ2VQcm9ncmFtc1thW2ldXSxcbiAgICAgICAgICAgICAgICBhcnIsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgc2V0dGluZ3M6IHRoaXMuc2V0dGluZ3MsXG4gICAgICAgICAgICAgICAgICBtYXRyaXg6IG1hdHJpeCxcbiAgICAgICAgICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcbiAgICAgICAgICAgICAgICAgIHJhdGlvOiB0aGlzLmNhbWVyYS5yYXRpbyxcbiAgICAgICAgICAgICAgICAgIHNjYWxpbmdSYXRpbzogdGhpcy5zZXR0aW5ncyhcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgJ3dlYmdsT3ZlcnNhbXBsaW5nUmF0aW8nXG4gICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICAgICAgY291bnQ6IGVuZCAtIHN0YXJ0LFxuICAgICAgICAgICAgICAgICAgaW5kaWNlc0RhdGE6IGluZGljZXNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENhdGNoIGpvYidzIGVuZDpcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgZW5kID49IGFyci5sZW5ndGggLyByZW5kZXJlci5BVFRSSUJVVEVTICYmXG4gICAgICAgICAgICAgIGkgPT09IGEubGVuZ3RoIC0gMVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmpvYnNbaWRdO1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChlbmQgPj0gYXJyLmxlbmd0aCAvIHJlbmRlcmVyLkFUVFJJQlVURVMpIHtcbiAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICBhcnIgPSB0aGlzLmVkZ2VGbG9hdEFycmF5c1thW2ldXS5hcnJheTtcbiAgICAgICAgICAgICAgcmVuZGVyZXIgPSBzaWdtYS53ZWJnbC5lZGdlc1thW2ldXTtcbiAgICAgICAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICAgICAgICBlbmQgPSBNYXRoLm1pbihcbiAgICAgICAgICAgICAgICBzdGFydCArIGJhdGNoU2l6ZSAqIHJlbmRlcmVyLlBPSU5UUyxcbiAgICAgICAgICAgICAgICBhcnIubGVuZ3RoIC8gcmVuZGVyZXIuQVRUUklCVVRFU1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3RhcnQgPSBlbmQ7XG4gICAgICAgICAgICAgIGVuZCA9IE1hdGgubWluKFxuICAgICAgICAgICAgICAgIHN0YXJ0ICsgYmF0Y2hTaXplICogcmVuZGVyZXIuUE9JTlRTLFxuICAgICAgICAgICAgICAgIGFyci5sZW5ndGggLyByZW5kZXJlci5BVFRSSUJVVEVTXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICB0aGlzLmpvYnNbaWRdID0gam9iO1xuICAgICAgICAgIGNvbnJhZC5hZGRKb2IoaWQsIGpvYi5iaW5kKHRoaXMpKTtcbiAgICAgICAgfSkuY2FsbCh0aGlzKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBmb3IgKGsgaW4gdGhpcy5lZGdlRmxvYXRBcnJheXMpIHtcbiAgICAgICAgICByZW5kZXJlciA9IHNpZ21hLndlYmdsLmVkZ2VzW2tdO1xuXG4gICAgICAgICAgLy8gQ2hlY2sgcHJvZ3JhbTpcbiAgICAgICAgICBpZiAoIXRoaXMuZWRnZVByb2dyYW1zW2tdKVxuICAgICAgICAgICAgdGhpcy5lZGdlUHJvZ3JhbXNba10gPSByZW5kZXJlci5pbml0UHJvZ3JhbShlZGdlc0dsKTtcblxuICAgICAgICAgIC8vIFJlbmRlclxuICAgICAgICAgIGlmICh0aGlzLmVkZ2VGbG9hdEFycmF5c1trXSkge1xuICAgICAgICAgICAgZWRnZXNHbC51c2VQcm9ncmFtKHRoaXMuZWRnZVByb2dyYW1zW2tdKTtcbiAgICAgICAgICAgIHJlbmRlcmVyLnJlbmRlcihcbiAgICAgICAgICAgICAgZWRnZXNHbCxcbiAgICAgICAgICAgICAgdGhpcy5lZGdlUHJvZ3JhbXNba10sXG4gICAgICAgICAgICAgIHRoaXMuZWRnZUZsb2F0QXJyYXlzW2tdLmFycmF5LFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3M6IHRoaXMuc2V0dGluZ3MsXG4gICAgICAgICAgICAgICAgbWF0cml4OiBtYXRyaXgsXG4gICAgICAgICAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcbiAgICAgICAgICAgICAgICByYXRpbzogdGhpcy5jYW1lcmEucmF0aW8sXG4gICAgICAgICAgICAgICAgc2NhbGluZ1JhdGlvOiB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICd3ZWJnbE92ZXJzYW1wbGluZ1JhdGlvJyksXG4gICAgICAgICAgICAgICAgaW5kaWNlc0RhdGE6IHRoaXMuZWRnZUluZGljZXNBcnJheXNba11cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZHJhd05vZGVzKSB7XG4gICAgICAvLyBFbmFibGUgYmxlbmRpbmc6XG4gICAgICBub2Rlc0dsLmJsZW5kRnVuYyhub2Rlc0dsLlNSQ19BTFBIQSwgbm9kZXNHbC5PTkVfTUlOVVNfU1JDX0FMUEhBKTtcbiAgICAgIG5vZGVzR2wuZW5hYmxlKG5vZGVzR2wuQkxFTkQpO1xuXG4gICAgICBmb3IgKGsgaW4gdGhpcy5ub2RlRmxvYXRBcnJheXMpIHtcbiAgICAgICAgcmVuZGVyZXIgPSBzaWdtYS53ZWJnbC5ub2Rlc1trXTtcblxuICAgICAgICAvLyBDaGVjayBwcm9ncmFtOlxuICAgICAgICBpZiAoIXRoaXMubm9kZVByb2dyYW1zW2tdKVxuICAgICAgICAgIHRoaXMubm9kZVByb2dyYW1zW2tdID0gcmVuZGVyZXIuaW5pdFByb2dyYW0obm9kZXNHbCk7XG5cbiAgICAgICAgLy8gUmVuZGVyXG4gICAgICAgIGlmICh0aGlzLm5vZGVGbG9hdEFycmF5c1trXSkge1xuICAgICAgICAgIG5vZGVzR2wudXNlUHJvZ3JhbSh0aGlzLm5vZGVQcm9ncmFtc1trXSk7XG4gICAgICAgICAgcmVuZGVyZXIucmVuZGVyKFxuICAgICAgICAgICAgbm9kZXNHbCxcbiAgICAgICAgICAgIHRoaXMubm9kZVByb2dyYW1zW2tdLFxuICAgICAgICAgICAgdGhpcy5ub2RlRmxvYXRBcnJheXNba10uYXJyYXksXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHNldHRpbmdzOiB0aGlzLnNldHRpbmdzLFxuICAgICAgICAgICAgICBtYXRyaXg6IG1hdHJpeCxcbiAgICAgICAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXG4gICAgICAgICAgICAgIHJhdGlvOiB0aGlzLmNhbWVyYS5yYXRpbyxcbiAgICAgICAgICAgICAgc2NhbGluZ1JhdGlvOiB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICd3ZWJnbE92ZXJzYW1wbGluZ1JhdGlvJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRyYXdMYWJlbHMpIHtcbiAgICAgIGEgPSB0aGlzLmNhbWVyYS5xdWFkdHJlZS5hcmVhKFxuICAgICAgICB0aGlzLmNhbWVyYS5nZXRSZWN0YW5nbGUodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpXG4gICAgICApO1xuXG4gICAgICAvLyBBcHBseSBjYW1lcmEgdmlldyB0byB0aGVzZSBub2RlczpcbiAgICAgIHRoaXMuY2FtZXJhLmFwcGx5VmlldyhcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIHtcbiAgICAgICAgICBub2RlczogYSxcbiAgICAgICAgICBlZGdlczogW10sXG4gICAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodFxuICAgICAgICB9XG4gICAgICApO1xuXG4gICAgICBvID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiBzZWxmLnNldHRpbmdzKHtcbiAgICAgICAgICBwcmVmaXg6IHNlbGYuY2FtZXJhLnByZWZpeFxuICAgICAgICB9LCBrZXkpO1xuICAgICAgfTtcblxuICAgICAgZm9yIChpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgICBpZiAoIWFbaV0uaGlkZGVuKVxuICAgICAgICAgIChcbiAgICAgICAgICAgIHNpZ21hLmNhbnZhcy5sYWJlbHNbXG4gICAgICAgICAgICAgIGFbaV0udHlwZSB8fFxuICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdkZWZhdWx0Tm9kZVR5cGUnKVxuICAgICAgICAgICAgXSB8fCBzaWdtYS5jYW52YXMubGFiZWxzLmRlZlxuICAgICAgICAgICkoYVtpXSwgdGhpcy5jb250ZXh0cy5sYWJlbHMsIG8pO1xuICAgIH1cblxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudCgncmVuZGVyJyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuXG5cblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgY3JlYXRlcyBhIERPTSBlbGVtZW50IG9mIHRoZSBzcGVjaWZpZWQgdHlwZSwgc3dpdGNoZXMgaXRzXG4gICAqIHBvc2l0aW9uIHRvIFwiYWJzb2x1dGVcIiwgcmVmZXJlbmNlcyBpdCB0byB0aGUgZG9tRWxlbWVudHMgYXR0cmlidXRlLCBhbmRcbiAgICogZmluYWxseSBhcHBlbmRzIGl0IHRvIHRoZSBjb250YWluZXIuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICB0YWcgICBUaGUgbGFiZWwgdGFnLlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgaWQgICAgVGhlIGlkIG9mIHRoZSBlbGVtZW50ICh0byBzdG9yZSBpdCBpblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJkb21FbGVtZW50c1wiKS5cbiAgICogQHBhcmFtICB7P2Jvb2xlYW59IHdlYmdsIFdpbGwgaW5pdCB0aGUgV2ViR0wgY29udGV4dCBpZiB0cnVlLlxuICAgKi9cbiAgc2lnbWEucmVuZGVyZXJzLndlYmdsLnByb3RvdHlwZS5pbml0RE9NID0gZnVuY3Rpb24odGFnLCBpZCwgd2ViZ2wpIHtcbiAgICB2YXIgZ2wsXG4gICAgICAgIGRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKSxcbiAgICAgICAgc2VsZiA9IHRoaXM7XG5cbiAgICBkb20uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIGRvbS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ3NpZ21hLScgKyBpZCk7XG5cbiAgICB0aGlzLmRvbUVsZW1lbnRzW2lkXSA9IGRvbTtcbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZChkb20pO1xuXG4gICAgaWYgKHRhZy50b0xvd2VyQ2FzZSgpID09PSAnY2FudmFzJykge1xuICAgICAgdGhpcy5jb250ZXh0c1tpZF0gPSBkb20uZ2V0Q29udGV4dCh3ZWJnbCA/ICdleHBlcmltZW50YWwtd2ViZ2wnIDogJzJkJywge1xuICAgICAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IHRydWVcbiAgICAgIH0pO1xuXG4gICAgICAvLyBBZGRpbmcgd2ViZ2wgY29udGV4dCBsb3NzIGxpc3RlbmVyc1xuICAgICAgaWYgKHdlYmdsKSB7XG4gICAgICAgIGRvbS5hZGRFdmVudExpc3RlbmVyKCd3ZWJnbGNvbnRleHRsb3N0JywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSwgZmFsc2UpO1xuXG4gICAgICAgIGRvbS5hZGRFdmVudExpc3RlbmVyKCd3ZWJnbGNvbnRleHRyZXN0b3JlZCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICBzZWxmLnJlbmRlcigpO1xuICAgICAgICB9LCBmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCByZXNpemVzIGVhY2ggRE9NIGVsZW1lbnRzIGluIHRoZSBjb250YWluZXIgYW5kIHN0b3JlcyB0aGUgbmV3XG4gICAqIGRpbWVuc2lvbnMuIFRoZW4sIGl0IHJlbmRlcnMgdGhlIGdyYXBoLlxuICAgKlxuICAgKiBAcGFyYW0gIHs/bnVtYmVyfSAgICAgICAgICAgICAgIHdpZHRoICBUaGUgbmV3IHdpZHRoIG9mIHRoZSBjb250YWluZXIuXG4gICAqIEBwYXJhbSAgez9udW1iZXJ9ICAgICAgICAgICAgICAgaGVpZ2h0IFRoZSBuZXcgaGVpZ2h0IG9mIHRoZSBjb250YWluZXIuXG4gICAqIEByZXR1cm4ge3NpZ21hLnJlbmRlcmVycy53ZWJnbH0gICAgICAgIFJldHVybnMgdGhlIGluc3RhbmNlIGl0c2VsZi5cbiAgICovXG4gIHNpZ21hLnJlbmRlcmVycy53ZWJnbC5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24odywgaCkge1xuICAgIHZhciBrLFxuICAgICAgICBvbGRXaWR0aCA9IHRoaXMud2lkdGgsXG4gICAgICAgIG9sZEhlaWdodCA9IHRoaXMuaGVpZ2h0LFxuICAgICAgICBwaXhlbFJhdGlvID0gc2lnbWEudXRpbHMuZ2V0UGl4ZWxSYXRpbygpO1xuXG4gICAgaWYgKHcgIT09IHVuZGVmaW5lZCAmJiBoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMud2lkdGggPSB3O1xuICAgICAgdGhpcy5oZWlnaHQgPSBoO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndpZHRoID0gdGhpcy5jb250YWluZXIub2Zmc2V0V2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IHRoaXMuY29udGFpbmVyLm9mZnNldEhlaWdodDtcblxuICAgICAgdyA9IHRoaXMud2lkdGg7XG4gICAgICBoID0gdGhpcy5oZWlnaHQ7XG4gICAgfVxuXG4gICAgaWYgKG9sZFdpZHRoICE9PSB0aGlzLndpZHRoIHx8IG9sZEhlaWdodCAhPT0gdGhpcy5oZWlnaHQpIHtcbiAgICAgIGZvciAoayBpbiB0aGlzLmRvbUVsZW1lbnRzKSB7XG4gICAgICAgIHRoaXMuZG9tRWxlbWVudHNba10uc3R5bGUud2lkdGggPSB3ICsgJ3B4JztcbiAgICAgICAgdGhpcy5kb21FbGVtZW50c1trXS5zdHlsZS5oZWlnaHQgPSBoICsgJ3B4JztcblxuICAgICAgICBpZiAodGhpcy5kb21FbGVtZW50c1trXS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdjYW52YXMnKSB7XG4gICAgICAgICAgLy8gSWYgc2ltcGxlIDJEIGNhbnZhczpcbiAgICAgICAgICBpZiAodGhpcy5jb250ZXh0c1trXSAmJiB0aGlzLmNvbnRleHRzW2tdLnNjYWxlKSB7XG4gICAgICAgICAgICB0aGlzLmRvbUVsZW1lbnRzW2tdLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAodyAqIHBpeGVsUmF0aW8pICsgJ3B4Jyk7XG4gICAgICAgICAgICB0aGlzLmRvbUVsZW1lbnRzW2tdLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgKGggKiBwaXhlbFJhdGlvKSArICdweCcpO1xuXG4gICAgICAgICAgICBpZiAocGl4ZWxSYXRpbyAhPT0gMSlcbiAgICAgICAgICAgICAgdGhpcy5jb250ZXh0c1trXS5zY2FsZShwaXhlbFJhdGlvLCBwaXhlbFJhdGlvKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kb21FbGVtZW50c1trXS5zZXRBdHRyaWJ1dGUoXG4gICAgICAgICAgICAgICd3aWR0aCcsXG4gICAgICAgICAgICAgICh3ICogdGhpcy5zZXR0aW5ncygnd2ViZ2xPdmVyc2FtcGxpbmdSYXRpbycpKSArICdweCdcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLmRvbUVsZW1lbnRzW2tdLnNldEF0dHJpYnV0ZShcbiAgICAgICAgICAgICAgJ2hlaWdodCcsXG4gICAgICAgICAgICAgIChoICogdGhpcy5zZXR0aW5ncygnd2ViZ2xPdmVyc2FtcGxpbmdSYXRpbycpKSArICdweCdcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2NhbGU6XG4gICAgZm9yIChrIGluIHRoaXMuY29udGV4dHMpXG4gICAgICBpZiAodGhpcy5jb250ZXh0c1trXSAmJiB0aGlzLmNvbnRleHRzW2tdLnZpZXdwb3J0KVxuICAgICAgICB0aGlzLmNvbnRleHRzW2tdLnZpZXdwb3J0KFxuICAgICAgICAgIDAsXG4gICAgICAgICAgMCxcbiAgICAgICAgICB0aGlzLndpZHRoICogdGhpcy5zZXR0aW5ncygnd2ViZ2xPdmVyc2FtcGxpbmdSYXRpbycpLFxuICAgICAgICAgIHRoaXMuaGVpZ2h0ICogdGhpcy5zZXR0aW5ncygnd2ViZ2xPdmVyc2FtcGxpbmdSYXRpbycpXG4gICAgICAgICk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgY2xlYXJzIGVhY2ggY2FudmFzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzaWdtYS5yZW5kZXJlcnMud2ViZ2x9IFJldHVybnMgdGhlIGluc3RhbmNlIGl0c2VsZi5cbiAgICovXG4gIHNpZ21hLnJlbmRlcmVycy53ZWJnbC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNvbnRleHRzLmxhYmVscy5jbGVhclJlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgIHRoaXMuY29udGV4dHMubm9kZXMuY2xlYXIodGhpcy5jb250ZXh0cy5ub2Rlcy5DT0xPUl9CVUZGRVJfQklUKTtcbiAgICB0aGlzLmNvbnRleHRzLmVkZ2VzLmNsZWFyKHRoaXMuY29udGV4dHMuZWRnZXMuQ09MT1JfQlVGRkVSX0JJVCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2Qga2lsbHMgY29udGV4dHMgYW5kIG90aGVyIGF0dHJpYnV0ZXMuXG4gICAqL1xuICBzaWdtYS5yZW5kZXJlcnMud2ViZ2wucHJvdG90eXBlLmtpbGwgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgayxcbiAgICAgICAgY2FwdG9yO1xuXG4gICAgLy8gS2lsbCBjYXB0b3JzOlxuICAgIHdoaWxlICgoY2FwdG9yID0gdGhpcy5jYXB0b3JzLnBvcCgpKSlcbiAgICAgIGNhcHRvci5raWxsKCk7XG4gICAgZGVsZXRlIHRoaXMuY2FwdG9ycztcblxuICAgIC8vIEtpbGwgY29udGV4dHM6XG4gICAgZm9yIChrIGluIHRoaXMuZG9tRWxlbWVudHMpIHtcbiAgICAgIHRoaXMuZG9tRWxlbWVudHNba10ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmRvbUVsZW1lbnRzW2tdKTtcbiAgICAgIGRlbGV0ZSB0aGlzLmRvbUVsZW1lbnRzW2tdO1xuICAgICAgZGVsZXRlIHRoaXMuY29udGV4dHNba107XG4gICAgfVxuICAgIGRlbGV0ZSB0aGlzLmRvbUVsZW1lbnRzO1xuICAgIGRlbGV0ZSB0aGlzLmNvbnRleHRzO1xuICB9O1xuXG5cblxuXG4gIC8qKlxuICAgKiBUaGUgb2JqZWN0IFwic2lnbWEud2ViZ2wubm9kZXNcIiBjb250YWlucyB0aGUgZGlmZmVyZW50IFdlYkdMIG5vZGVcbiAgICogcmVuZGVyZXJzLiBUaGUgZGVmYXVsdCBvbmUgZHJhdyBub2RlcyBhcyBkaXNjcy4gSGVyZSBhcmUgdGhlIGF0dHJpYnV0ZXNcbiAgICogYW55IG5vZGUgcmVuZGVyZXIgbXVzdCBoYXZlOlxuICAgKlxuICAgKiB7bnVtYmVyfSAgIFBPSU5UUyAgICAgIFRoZSBudW1iZXIgb2YgcG9pbnRzIHJlcXVpcmVkIHRvIGRyYXcgYSBub2RlLlxuICAgKiB7bnVtYmVyfSAgIEFUVFJJQlVURVMgIFRoZSBudW1iZXIgb2YgYXR0cmlidXRlcyBuZWVkZWQgdG8gZHJhdyBvbmUgcG9pbnQuXG4gICAqIHtmdW5jdGlvbn0gYWRkTm9kZSAgICAgQSBmdW5jdGlvbiB0aGF0IGFkZHMgYSBub2RlIHRvIHRoZSBkYXRhIHN0YWNrIHRoYXRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICB3aWxsIGJlIGdpdmVuIHRvIHRoZSBidWZmZXIuIEhlcmUgaXMgdGhlIGFyZ3VtZW50czpcbiAgICogICAgICAgICAgICAgICAgICAgICAgICA+IHtvYmplY3R9ICAgICAgIG5vZGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICA+IHtudW1iZXJ9ICAgICAgIGluZGV4ICAgVGhlIG5vZGUgaW5kZXggaW4gdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzIGFycmF5LlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgID4ge0Zsb2F0MzJBcnJheX0gZGF0YSAgICBUaGUgc3RhY2suXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgPiB7b2JqZWN0fSAgICAgICBvcHRpb25zIFNvbWUgb3B0aW9ucy5cbiAgICoge2Z1bmN0aW9ufSByZW5kZXIgICAgICBUaGUgZnVuY3Rpb24gdGhhdCB3aWxsIGVmZmVjdGl2ZWx5IHJlbmRlciB0aGUgbm9kZXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICBpbnRvIHRoZSBidWZmZXIuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgPiB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgID4ge1dlYkdMUHJvZ3JhbX0gICAgICAgICAgcHJvZ3JhbVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgID4ge0Zsb2F0MzJBcnJheX0gZGF0YSAgICBUaGUgc3RhY2sgdG8gZ2l2ZSB0byB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgID4ge29iamVjdH0gICAgICAgcGFyYW1zICBBbiBvYmplY3QgY29udGFpbmluZyBzb21lXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMsIGxpa2Ugd2lkdGgsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodCwgdGhlIGNhbWVyYSByYXRpby5cbiAgICoge2Z1bmN0aW9ufSBpbml0UHJvZ3JhbSBUaGUgZnVuY3Rpb24gdGhhdCB3aWxsIGluaXRpYXRlIHRoZSBwcm9ncmFtLCB3aXRoXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgdGhlIHJlbGV2YW50IHNoYWRlcnMgYW5kIHBhcmFtZXRlcnMuIEl0IG11c3QgcmV0dXJuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgdGhlIG5ld2x5IGNyZWF0ZWQgcHJvZ3JhbS5cbiAgICpcbiAgICogQ2hlY2sgc2lnbWEud2ViZ2wubm9kZXMuZGVmIG9yIHNpZ21hLndlYmdsLm5vZGVzLmZhc3QgdG8gc2VlIGhvdyBpdFxuICAgKiB3b3JrcyBtb3JlIHByZWNpc2VseS5cbiAgICovXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEud2ViZ2wubm9kZXMnKTtcblxuXG5cblxuICAvKipcbiAgICogVGhlIG9iamVjdCBcInNpZ21hLndlYmdsLmVkZ2VzXCIgY29udGFpbnMgdGhlIGRpZmZlcmVudCBXZWJHTCBlZGdlXG4gICAqIHJlbmRlcmVycy4gVGhlIGRlZmF1bHQgb25lIGRyYXcgZWRnZXMgYXMgZGlyZWN0IGxpbmVzLiBIZXJlIGFyZSB0aGVcbiAgICogYXR0cmlidXRlcyBhbnkgZWRnZSByZW5kZXJlciBtdXN0IGhhdmU6XG4gICAqXG4gICAqIHtudW1iZXJ9ICAgUE9JTlRTICAgICAgVGhlIG51bWJlciBvZiBwb2ludHMgcmVxdWlyZWQgdG8gZHJhdyBhbiBlZGdlLlxuICAgKiB7bnVtYmVyfSAgIEFUVFJJQlVURVMgIFRoZSBudW1iZXIgb2YgYXR0cmlidXRlcyBuZWVkZWQgdG8gZHJhdyBvbmUgcG9pbnQuXG4gICAqIHtmdW5jdGlvbn0gYWRkRWRnZSAgICAgQSBmdW5jdGlvbiB0aGF0IGFkZHMgYW4gZWRnZSB0byB0aGUgZGF0YSBzdGFjayB0aGF0XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgd2lsbCBiZSBnaXZlbiB0byB0aGUgYnVmZmVyLiBIZXJlIGlzIHRoZSBhcmd1bWVudHM6XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgPiB7b2JqZWN0fSAgICAgICBlZGdlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgPiB7b2JqZWN0fSAgICAgICBzb3VyY2VcbiAgICogICAgICAgICAgICAgICAgICAgICAgICA+IHtvYmplY3R9ICAgICAgIHRhcmdldFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgID4ge0Zsb2F0MzJBcnJheX0gZGF0YSAgICBUaGUgc3RhY2suXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgPiB7b2JqZWN0fSAgICAgICBvcHRpb25zIFNvbWUgb3B0aW9ucy5cbiAgICoge2Z1bmN0aW9ufSByZW5kZXIgICAgICBUaGUgZnVuY3Rpb24gdGhhdCB3aWxsIGVmZmVjdGl2ZWx5IHJlbmRlciB0aGUgZWRnZXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICBpbnRvIHRoZSBidWZmZXIuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgPiB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgID4ge1dlYkdMUHJvZ3JhbX0gICAgICAgICAgcHJvZ3JhbVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgID4ge0Zsb2F0MzJBcnJheX0gZGF0YSAgICBUaGUgc3RhY2sgdG8gZ2l2ZSB0byB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgID4ge29iamVjdH0gICAgICAgcGFyYW1zICBBbiBvYmplY3QgY29udGFpbmluZyBzb21lXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMsIGxpa2Ugd2lkdGgsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodCwgdGhlIGNhbWVyYSByYXRpby5cbiAgICoge2Z1bmN0aW9ufSBpbml0UHJvZ3JhbSBUaGUgZnVuY3Rpb24gdGhhdCB3aWxsIGluaXRpYXRlIHRoZSBwcm9ncmFtLCB3aXRoXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgdGhlIHJlbGV2YW50IHNoYWRlcnMgYW5kIHBhcmFtZXRlcnMuIEl0IG11c3QgcmV0dXJuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgdGhlIG5ld2x5IGNyZWF0ZWQgcHJvZ3JhbS5cbiAgICpcbiAgICogQ2hlY2sgc2lnbWEud2ViZ2wuZWRnZXMuZGVmIG9yIHNpZ21hLndlYmdsLmVkZ2VzLmZhc3QgdG8gc2VlIGhvdyBpdFxuICAgKiB3b3JrcyBtb3JlIHByZWNpc2VseS5cbiAgICovXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEud2ViZ2wuZWRnZXMnKTtcblxuXG5cblxuICAvKipcbiAgICogVGhlIG9iamVjdCBcInNpZ21hLmNhbnZhcy5sYWJlbHNcIiBjb250YWlucyB0aGUgZGlmZmVyZW50XG4gICAqIGxhYmVsIHJlbmRlcmVycyBmb3IgdGhlIFdlYkdMIHJlbmRlcmVyLiBTaW5jZSBkaXNwbGF5aW5nIHRleHRzIGluIFdlYkdMIGlzXG4gICAqIGRlZmluaXRlbHkgcGFpbmZ1bCBhbmQgc2luY2UgdGhlcmUgYSB3YXkgbGVzcyBsYWJlbHMgdG8gZGlzcGxheSB0aGFuIG5vZGVzXG4gICAqIG9yIGVkZ2VzLCB0aGUgZGVmYXVsdCByZW5kZXJlciBzaW1wbHkgcmVuZGVycyB0aGVtIGluIGEgY2FudmFzLlxuICAgKlxuICAgKiBBIGxhYmVscyByZW5kZXJlciBpcyBhIHNpbXBsZSBmdW5jdGlvbiwgdGFraW5nIGFzIGFyZ3VtZW50cyB0aGUgcmVsYXRlZFxuICAgKiBub2RlLCB0aGUgcmVuZGVyZXIgYW5kIGEgc2V0dGluZ3MgZnVuY3Rpb24uXG4gICAqL1xuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLmNhbnZhcy5sYWJlbHMnKTtcbn0pLmNhbGwodGhpcyk7XG5cbjsoZnVuY3Rpb24odW5kZWZpbmVkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBpZiAodHlwZW9mIHNpZ21hID09PSAndW5kZWZpbmVkJylcbiAgICB0aHJvdyAnc2lnbWEgaXMgbm90IGRlY2xhcmVkJztcblxuICBpZiAodHlwZW9mIGNvbnJhZCA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgdGhyb3cgJ2NvbnJhZCBpcyBub3QgZGVjbGFyZWQnO1xuXG4gIC8vIEluaXRpYWxpemUgcGFja2FnZXM6XG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEucmVuZGVyZXJzJyk7XG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gaXMgdGhlIGNvbnN0cnVjdG9yIG9mIHRoZSBzdmcgc2lnbWEncyByZW5kZXJlci5cbiAgICpcbiAgICogQHBhcmFtICB7c2lnbWEuY2xhc3Nlcy5ncmFwaH0gICAgICAgICAgICBncmFwaCAgICBUaGUgZ3JhcGggdG8gcmVuZGVyLlxuICAgKiBAcGFyYW0gIHtzaWdtYS5jbGFzc2VzLmNhbWVyYX0gICAgICAgICAgIGNhbWVyYSAgIFRoZSBjYW1lcmEuXG4gICAqIEBwYXJhbSAge2NvbmZpZ3VyYWJsZX0gICAgICAgICAgIHNldHRpbmdzIFRoZSBzaWdtYSBpbnN0YW5jZSBzZXR0aW5nc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbi5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgb2JqZWN0ICAgVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgKiBAcmV0dXJuIHtzaWdtYS5yZW5kZXJlcnMuc3ZnfSAgICAgICAgICAgICBUaGUgcmVuZGVyZXIgaW5zdGFuY2UuXG4gICAqL1xuICBzaWdtYS5yZW5kZXJlcnMuc3ZnID0gZnVuY3Rpb24oZ3JhcGgsIGNhbWVyYSwgc2V0dGluZ3MsIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKVxuICAgICAgdGhyb3cgJ3NpZ21hLnJlbmRlcmVycy5zdmc6IFdyb25nIGFyZ3VtZW50cy4nO1xuXG4gICAgaWYgKCEob3B0aW9ucy5jb250YWluZXIgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpXG4gICAgICB0aHJvdyAnQ29udGFpbmVyIG5vdCBmb3VuZC4nO1xuXG4gICAgdmFyIGksXG4gICAgICAgIGwsXG4gICAgICAgIGEsXG4gICAgICAgIGZuLFxuICAgICAgICBzZWxmID0gdGhpcztcblxuICAgIHNpZ21hLmNsYXNzZXMuZGlzcGF0Y2hlci5leHRlbmQodGhpcyk7XG5cbiAgICAvLyBJbml0aWFsaXplIG1haW4gYXR0cmlidXRlczpcbiAgICB0aGlzLmdyYXBoID0gZ3JhcGg7XG4gICAgdGhpcy5jYW1lcmEgPSBjYW1lcmE7XG4gICAgdGhpcy5kb21FbGVtZW50cyA9IHtcbiAgICAgIGdyYXBoOiBudWxsLFxuICAgICAgZ3JvdXBzOiB7fSxcbiAgICAgIG5vZGVzOiB7fSxcbiAgICAgIGVkZ2VzOiB7fSxcbiAgICAgIGxhYmVsczoge30sXG4gICAgICBob3ZlcnM6IHt9XG4gICAgfTtcbiAgICB0aGlzLm1lYXN1cmVtZW50Q2FudmFzID0gbnVsbDtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuY29udGFpbmVyID0gdGhpcy5vcHRpb25zLmNvbnRhaW5lcjtcbiAgICB0aGlzLnNldHRpbmdzID0gKFxuICAgICAgICB0eXBlb2Ygb3B0aW9ucy5zZXR0aW5ncyA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgb3B0aW9ucy5zZXR0aW5nc1xuICAgICAgKSA/XG4gICAgICAgIHNldHRpbmdzLmVtYmVkT2JqZWN0cyhvcHRpb25zLnNldHRpbmdzKSA6XG4gICAgICAgIHNldHRpbmdzO1xuXG4gICAgLy8gSXMgdGhlIHJlbmRlcmVyIG1lYW50IHRvIGJlIGZyZWVzdHlsZT9cbiAgICB0aGlzLnNldHRpbmdzKCdmcmVlU3R5bGUnLCAhIXRoaXMub3B0aW9ucy5mcmVlU3R5bGUpO1xuXG4gICAgLy8gU1ZHIHhtbG5zXG4gICAgdGhpcy5zZXR0aW5ncygneG1sbnMnLCAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnKTtcblxuICAgIC8vIEluZGV4ZXM6XG4gICAgdGhpcy5ub2Rlc09uU2NyZWVuID0gW107XG4gICAgdGhpcy5lZGdlc09uU2NyZWVuID0gW107XG5cbiAgICAvLyBGaW5kIHRoZSBwcmVmaXg6XG4gICAgdGhpcy5vcHRpb25zLnByZWZpeCA9ICdyZW5kZXJlcicgKyBzaWdtYS51dGlscy5pZCgpICsgJzonO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgRE9NIGVsZW1lbnRzXG4gICAgdGhpcy5pbml0RE9NKCdzdmcnKTtcblxuICAgIC8vIEluaXRpYWxpemUgY2FwdG9yczpcbiAgICB0aGlzLmNhcHRvcnMgPSBbXTtcbiAgICBhID0gdGhpcy5vcHRpb25zLmNhcHRvcnMgfHwgW3NpZ21hLmNhcHRvcnMubW91c2UsIHNpZ21hLmNhcHRvcnMudG91Y2hdO1xuICAgIGZvciAoaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgZm4gPSB0eXBlb2YgYVtpXSA9PT0gJ2Z1bmN0aW9uJyA/IGFbaV0gOiBzaWdtYS5jYXB0b3JzW2FbaV1dO1xuICAgICAgdGhpcy5jYXB0b3JzLnB1c2goXG4gICAgICAgIG5ldyBmbihcbiAgICAgICAgICB0aGlzLmRvbUVsZW1lbnRzLmdyYXBoLFxuICAgICAgICAgIHRoaXMuY2FtZXJhLFxuICAgICAgICAgIHRoaXMuc2V0dGluZ3NcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBCaW5kIHJlc2l6ZTpcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLnJlc2l6ZSgpO1xuICAgIH0pO1xuXG4gICAgLy8gRGVhbCB3aXRoIHNpZ21hIGV2ZW50czpcbiAgICAvLyBUT0RPOiBrZWVwIGFuIG9wdGlvbiB0byBvdmVycmlkZSB0aGUgRE9NIGV2ZW50cz9cbiAgICBzaWdtYS5taXNjLmJpbmRET01FdmVudHMuY2FsbCh0aGlzLCB0aGlzLmRvbUVsZW1lbnRzLmdyYXBoKTtcbiAgICB0aGlzLmJpbmRIb3ZlcnModGhpcy5vcHRpb25zLnByZWZpeCk7XG5cbiAgICAvLyBSZXNpemVcbiAgICB0aGlzLnJlc2l6ZShmYWxzZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHJlbmRlcnMgdGhlIGdyYXBoIG9uIHRoZSBzdmcgc2NlbmUuXG4gICAqXG4gICAqIEBwYXJhbSAgez9vYmplY3R9ICAgICAgICAgICAgICAgIG9wdGlvbnMgRXZlbnR1YWxseSBhbiBvYmplY3Qgb2Ygb3B0aW9ucy5cbiAgICogQHJldHVybiB7c2lnbWEucmVuZGVyZXJzLnN2Z30gICAgICAgICAgICBSZXR1cm5zIHRoZSBpbnN0YW5jZSBpdHNlbGYuXG4gICAqL1xuICBzaWdtYS5yZW5kZXJlcnMuc3ZnLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICB2YXIgYSxcbiAgICAgICAgaSxcbiAgICAgICAgayxcbiAgICAgICAgZSxcbiAgICAgICAgbCxcbiAgICAgICAgbyxcbiAgICAgICAgc291cmNlLFxuICAgICAgICB0YXJnZXQsXG4gICAgICAgIHN0YXJ0LFxuICAgICAgICBlZGdlcyxcbiAgICAgICAgcmVuZGVyZXJzLFxuICAgICAgICBzdWJyZW5kZXJlcnMsXG4gICAgICAgIGluZGV4ID0ge30sXG4gICAgICAgIGdyYXBoID0gdGhpcy5ncmFwaCxcbiAgICAgICAgbm9kZXMgPSB0aGlzLmdyYXBoLm5vZGVzLFxuICAgICAgICBwcmVmaXggPSB0aGlzLm9wdGlvbnMucHJlZml4IHx8ICcnLFxuICAgICAgICBkcmF3RWRnZXMgPSB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdkcmF3RWRnZXMnKSxcbiAgICAgICAgZHJhd05vZGVzID0gdGhpcy5zZXR0aW5ncyhvcHRpb25zLCAnZHJhd05vZGVzJyksXG4gICAgICAgIGRyYXdMYWJlbHMgPSB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdkcmF3TGFiZWxzJyksXG4gICAgICAgIGVtYmVkU2V0dGluZ3MgPSB0aGlzLnNldHRpbmdzLmVtYmVkT2JqZWN0cyhvcHRpb25zLCB7XG4gICAgICAgICAgcHJlZml4OiB0aGlzLm9wdGlvbnMucHJlZml4LFxuICAgICAgICAgIGZvcmNlTGFiZWxzOiB0aGlzLm9wdGlvbnMuZm9yY2VMYWJlbHNcbiAgICAgICAgfSk7XG5cbiAgICAvLyBDaGVjayB0aGUgJ2hpZGVFZGdlc09uTW92ZScgc2V0dGluZzpcbiAgICBpZiAodGhpcy5zZXR0aW5ncyhvcHRpb25zLCAnaGlkZUVkZ2VzT25Nb3ZlJykpXG4gICAgICBpZiAodGhpcy5jYW1lcmEuaXNBbmltYXRlZCB8fCB0aGlzLmNhbWVyYS5pc01vdmluZylcbiAgICAgICAgZHJhd0VkZ2VzID0gZmFsc2U7XG5cbiAgICAvLyBBcHBseSB0aGUgY2FtZXJhJ3MgdmlldzpcbiAgICB0aGlzLmNhbWVyYS5hcHBseVZpZXcoXG4gICAgICB1bmRlZmluZWQsXG4gICAgICB0aGlzLm9wdGlvbnMucHJlZml4LFxuICAgICAge1xuICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodFxuICAgICAgfVxuICAgICk7XG5cbiAgICAvLyBIaWRpbmcgZXZlcnl0aGluZ1xuICAgIC8vIFRPRE86IGZpbmQgYSBtb3JlIHNlbnNpYmxlIHdheSB0byBwZXJmb3JtIHRoaXMgb3BlcmF0aW9uXG4gICAgdGhpcy5oaWRlRE9NRWxlbWVudHModGhpcy5kb21FbGVtZW50cy5ub2Rlcyk7XG4gICAgdGhpcy5oaWRlRE9NRWxlbWVudHModGhpcy5kb21FbGVtZW50cy5lZGdlcyk7XG4gICAgdGhpcy5oaWRlRE9NRWxlbWVudHModGhpcy5kb21FbGVtZW50cy5sYWJlbHMpO1xuXG4gICAgLy8gRmluZCB3aGljaCBub2RlcyBhcmUgb24gc2NyZWVuXG4gICAgdGhpcy5lZGdlc09uU2NyZWVuID0gW107XG4gICAgdGhpcy5ub2Rlc09uU2NyZWVuID0gdGhpcy5jYW1lcmEucXVhZHRyZWUuYXJlYShcbiAgICAgIHRoaXMuY2FtZXJhLmdldFJlY3RhbmdsZSh0aGlzLndpZHRoLCB0aGlzLmhlaWdodClcbiAgICApO1xuXG4gICAgLy8gTm9kZSBpbmRleFxuICAgIGZvciAoYSA9IHRoaXMubm9kZXNPblNjcmVlbiwgaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgIGluZGV4W2FbaV0uaWRdID0gYVtpXTtcblxuICAgIC8vIEZpbmQgd2hpY2ggZWRnZXMgYXJlIG9uIHNjcmVlblxuICAgIGZvciAoYSA9IGdyYXBoLmVkZ2VzKCksIGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIG8gPSBhW2ldO1xuICAgICAgaWYgKFxuICAgICAgICAoaW5kZXhbby5zb3VyY2VdIHx8IGluZGV4W28udGFyZ2V0XSkgJiZcbiAgICAgICAgKCFvLmhpZGRlbiAmJiAhbm9kZXMoby5zb3VyY2UpLmhpZGRlbiAmJiAhbm9kZXMoby50YXJnZXQpLmhpZGRlbilcbiAgICAgIClcbiAgICAgICAgdGhpcy5lZGdlc09uU2NyZWVuLnB1c2gobyk7XG4gICAgfVxuXG4gICAgLy8gRGlzcGxheSBub2Rlc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tXG4gICAgcmVuZGVyZXJzID0gc2lnbWEuc3ZnLm5vZGVzO1xuICAgIHN1YnJlbmRlcmVycyA9IHNpZ21hLnN2Zy5sYWJlbHM7XG5cbiAgICAvLy0tIEZpcnN0IHdlIGNyZWF0ZSB0aGUgbm9kZXMgd2hpY2ggYXJlIG5vdCBhbHJlYWR5IGNyZWF0ZWRcbiAgICBpZiAoZHJhd05vZGVzKVxuICAgICAgZm9yIChhID0gdGhpcy5ub2Rlc09uU2NyZWVuLCBpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmICghYVtpXS5oaWRkZW4gJiYgIXRoaXMuZG9tRWxlbWVudHMubm9kZXNbYVtpXS5pZF0pIHtcblxuICAgICAgICAgIC8vIE5vZGVcbiAgICAgICAgICBlID0gKHJlbmRlcmVyc1thW2ldLnR5cGVdIHx8IHJlbmRlcmVycy5kZWYpLmNyZWF0ZShcbiAgICAgICAgICAgIGFbaV0sXG4gICAgICAgICAgICBlbWJlZFNldHRpbmdzXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIHRoaXMuZG9tRWxlbWVudHMubm9kZXNbYVtpXS5pZF0gPSBlO1xuICAgICAgICAgIHRoaXMuZG9tRWxlbWVudHMuZ3JvdXBzLm5vZGVzLmFwcGVuZENoaWxkKGUpO1xuXG4gICAgICAgICAgLy8gTGFiZWxcbiAgICAgICAgICBlID0gKHN1YnJlbmRlcmVyc1thW2ldLnR5cGVdIHx8IHN1YnJlbmRlcmVycy5kZWYpLmNyZWF0ZShcbiAgICAgICAgICAgIGFbaV0sXG4gICAgICAgICAgICBlbWJlZFNldHRpbmdzXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIHRoaXMuZG9tRWxlbWVudHMubGFiZWxzW2FbaV0uaWRdID0gZTtcbiAgICAgICAgICB0aGlzLmRvbUVsZW1lbnRzLmdyb3Vwcy5sYWJlbHMuYXBwZW5kQ2hpbGQoZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIC8vLS0gU2Vjb25kIHdlIHVwZGF0ZSB0aGUgbm9kZXNcbiAgICBpZiAoZHJhd05vZGVzKVxuICAgICAgZm9yIChhID0gdGhpcy5ub2Rlc09uU2NyZWVuLCBpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cbiAgICAgICAgaWYgKGFbaV0uaGlkZGVuKVxuICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgIC8vIE5vZGVcbiAgICAgICAgKHJlbmRlcmVyc1thW2ldLnR5cGVdIHx8IHJlbmRlcmVycy5kZWYpLnVwZGF0ZShcbiAgICAgICAgICBhW2ldLFxuICAgICAgICAgIHRoaXMuZG9tRWxlbWVudHMubm9kZXNbYVtpXS5pZF0sXG4gICAgICAgICAgZW1iZWRTZXR0aW5nc1xuICAgICAgICApO1xuXG4gICAgICAgIC8vIExhYmVsXG4gICAgICAgIChzdWJyZW5kZXJlcnNbYVtpXS50eXBlXSB8fCBzdWJyZW5kZXJlcnMuZGVmKS51cGRhdGUoXG4gICAgICAgICAgYVtpXSxcbiAgICAgICAgICB0aGlzLmRvbUVsZW1lbnRzLmxhYmVsc1thW2ldLmlkXSxcbiAgICAgICAgICBlbWJlZFNldHRpbmdzXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAvLyBEaXNwbGF5IGVkZ2VzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS1cbiAgICByZW5kZXJlcnMgPSBzaWdtYS5zdmcuZWRnZXM7XG5cbiAgICAvLy0tIEZpcnN0IHdlIGNyZWF0ZSB0aGUgZWRnZXMgd2hpY2ggYXJlIG5vdCBhbHJlYWR5IGNyZWF0ZWRcbiAgICBpZiAoZHJhd0VkZ2VzKVxuICAgICAgZm9yIChhID0gdGhpcy5lZGdlc09uU2NyZWVuLCBpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmICghdGhpcy5kb21FbGVtZW50cy5lZGdlc1thW2ldLmlkXSkge1xuICAgICAgICAgIHNvdXJjZSA9IG5vZGVzKGFbaV0uc291cmNlKTtcbiAgICAgICAgICB0YXJnZXQgPSBub2RlcyhhW2ldLnRhcmdldCk7XG5cbiAgICAgICAgICBlID0gKHJlbmRlcmVyc1thW2ldLnR5cGVdIHx8IHJlbmRlcmVycy5kZWYpLmNyZWF0ZShcbiAgICAgICAgICAgIGFbaV0sXG4gICAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICBlbWJlZFNldHRpbmdzXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIHRoaXMuZG9tRWxlbWVudHMuZWRnZXNbYVtpXS5pZF0gPSBlO1xuICAgICAgICAgIHRoaXMuZG9tRWxlbWVudHMuZ3JvdXBzLmVkZ2VzLmFwcGVuZENoaWxkKGUpO1xuICAgICAgICB9XG4gICAgICAgfVxuXG4gICAgLy8tLSBTZWNvbmQgd2UgdXBkYXRlIHRoZSBlZGdlc1xuICAgIGlmIChkcmF3RWRnZXMpXG4gICAgICBmb3IgKGEgPSB0aGlzLmVkZ2VzT25TY3JlZW4sIGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgc291cmNlID0gbm9kZXMoYVtpXS5zb3VyY2UpO1xuICAgICAgICB0YXJnZXQgPSBub2RlcyhhW2ldLnRhcmdldCk7XG5cbiAgICAgICAgKHJlbmRlcmVyc1thW2ldLnR5cGVdIHx8IHJlbmRlcmVycy5kZWYpLnVwZGF0ZShcbiAgICAgICAgICBhW2ldLFxuICAgICAgICAgIHRoaXMuZG9tRWxlbWVudHMuZWRnZXNbYVtpXS5pZF0sXG4gICAgICAgICAgc291cmNlLFxuICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICBlbWJlZFNldHRpbmdzXG4gICAgICAgICk7XG4gICAgICAgfVxuXG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KCdyZW5kZXInKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBjcmVhdGVzIGEgRE9NIGVsZW1lbnQgb2YgdGhlIHNwZWNpZmllZCB0eXBlLCBzd2l0Y2hlcyBpdHNcbiAgICogcG9zaXRpb24gdG8gXCJhYnNvbHV0ZVwiLCByZWZlcmVuY2VzIGl0IHRvIHRoZSBkb21FbGVtZW50cyBhdHRyaWJ1dGUsIGFuZFxuICAgKiBmaW5hbGx5IGFwcGVuZHMgaXQgdG8gdGhlIGNvbnRhaW5lci5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSB0YWcgVGhlIGxhYmVsIHRhZy5cbiAgICogQHBhcmFtICB7c3RyaW5nfSBpZCAgVGhlIGlkIG9mIHRoZSBlbGVtZW50ICh0byBzdG9yZSBpdCBpbiBcImRvbUVsZW1lbnRzXCIpLlxuICAgKi9cbiAgc2lnbWEucmVuZGVyZXJzLnN2Zy5wcm90b3R5cGUuaW5pdERPTSA9IGZ1bmN0aW9uKHRhZykge1xuICAgIHZhciBkb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlModGhpcy5zZXR0aW5ncygneG1sbnMnKSwgdGFnKSxcbiAgICAgICAgYyA9IHRoaXMuc2V0dGluZ3MoJ2NsYXNzUHJlZml4JyksXG4gICAgICAgIGcsXG4gICAgICAgIGwsXG4gICAgICAgIGk7XG5cbiAgICBkb20uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIGRvbS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgYyArICctc3ZnJyk7XG5cbiAgICAvLyBTZXR0aW5nIFNWRyBuYW1lc3BhY2VcbiAgICBkb20uc2V0QXR0cmlidXRlKCd4bWxucycsIHRoaXMuc2V0dGluZ3MoJ3htbG5zJykpO1xuICAgIGRvbS5zZXRBdHRyaWJ1dGUoJ3htbG5zOnhsaW5rJywgJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnKTtcbiAgICBkb20uc2V0QXR0cmlidXRlKCd2ZXJzaW9uJywgJzEuMScpO1xuXG4gICAgLy8gQ3JlYXRpbmcgdGhlIG1lYXN1cmVtZW50IGNhbnZhc1xuICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICBjYW52YXMuc2V0QXR0cmlidXRlKCdjbGFzcycsIGMgKyAnLW1lYXN1cmVtZW50LWNhbnZhcycpO1xuXG4gICAgLy8gQXBwZW5kaW5nIGVsZW1lbnRzXG4gICAgdGhpcy5kb21FbGVtZW50cy5ncmFwaCA9IHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKGRvbSk7XG5cbiAgICAvLyBDcmVhdGluZyBncm91cHNcbiAgICB2YXIgZ3JvdXBzID0gWydlZGdlcycsICdub2RlcycsICdsYWJlbHMnLCAnaG92ZXJzJ107XG4gICAgZm9yIChpID0gMCwgbCA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlModGhpcy5zZXR0aW5ncygneG1sbnMnKSwgJ2cnKTtcblxuICAgICAgZy5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnaWQnLCBjICsgJy1ncm91cC0nICsgZ3JvdXBzW2ldKTtcbiAgICAgIGcuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2NsYXNzJywgYyArICctZ3JvdXAnKTtcblxuICAgICAgdGhpcy5kb21FbGVtZW50cy5ncm91cHNbZ3JvdXBzW2ldXSA9XG4gICAgICAgIHRoaXMuZG9tRWxlbWVudHMuZ3JhcGguYXBwZW5kQ2hpbGQoZyk7XG4gICAgfVxuXG4gICAgLy8gQXBwZW5kaW5nIG1lYXN1cmVtZW50IGNhbnZhc1xuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKGNhbnZhcyk7XG4gICAgdGhpcy5tZWFzdXJlbWVudENhbnZhcyA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBoaWRlcyBhIGJhdGNoIG9mIFNWRyBET00gZWxlbWVudHMuXG4gICAqXG4gICAqIEBwYXJhbSAge2FycmF5fSAgICAgICAgICAgICAgICAgIGVsZW1lbnRzICBBbiBhcnJheSBvZiBlbGVtZW50cyB0byBoaWRlLlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICByZW5kZXJlciAgVGhlIHJlbmRlcmVyIHRvIHVzZS5cbiAgICogQHJldHVybiB7c2lnbWEucmVuZGVyZXJzLnN2Z30gICAgICAgICAgICAgIFJldHVybnMgdGhlIGluc3RhbmNlIGl0c2VsZi5cbiAgICovXG4gIHNpZ21hLnJlbmRlcmVycy5zdmcucHJvdG90eXBlLmhpZGVET01FbGVtZW50cyA9IGZ1bmN0aW9uKGVsZW1lbnRzKSB7XG4gICAgdmFyIG8sXG4gICAgICAgIGk7XG5cbiAgICBmb3IgKGkgaW4gZWxlbWVudHMpIHtcbiAgICAgIG8gPSBlbGVtZW50c1tpXTtcbiAgICAgIHNpZ21hLnN2Zy51dGlscy5oaWRlKG8pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBiaW5kcyB0aGUgaG92ZXIgZXZlbnRzIHRvIHRoZSByZW5kZXJlci5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSBwcmVmaXggVGhlIHJlbmRlcmVyIHByZWZpeC5cbiAgICovXG4gIC8vIFRPRE86IGFkZCBvcHRpb24gYWJvdXQgd2hldGhlciB0byBkaXNwbGF5IGhvdmVycyBvciBub3RcbiAgc2lnbWEucmVuZGVyZXJzLnN2Zy5wcm90b3R5cGUuYmluZEhvdmVycyA9IGZ1bmN0aW9uKHByZWZpeCkge1xuICAgIHZhciByZW5kZXJlcnMgPSBzaWdtYS5zdmcuaG92ZXJzLFxuICAgICAgICBzZWxmID0gdGhpcyxcbiAgICAgICAgaG92ZXJlZE5vZGU7XG5cbiAgICBmdW5jdGlvbiBvdmVyTm9kZShlKSB7XG4gICAgICB2YXIgbm9kZSA9IGUuZGF0YS5ub2RlLFxuICAgICAgICAgIGVtYmVkU2V0dGluZ3MgPSBzZWxmLnNldHRpbmdzLmVtYmVkT2JqZWN0cyh7XG4gICAgICAgICAgICBwcmVmaXg6IHByZWZpeFxuICAgICAgICAgIH0pO1xuXG4gICAgICBpZiAoIWVtYmVkU2V0dGluZ3MoJ2VuYWJsZUhvdmVyaW5nJykpXG4gICAgICAgIHJldHVybjtcblxuICAgICAgdmFyIGhvdmVyID0gKHJlbmRlcmVyc1tub2RlLnR5cGVdIHx8IHJlbmRlcmVycy5kZWYpLmNyZWF0ZShcbiAgICAgICAgbm9kZSxcbiAgICAgICAgc2VsZi5kb21FbGVtZW50cy5ub2Rlc1tub2RlLmlkXSxcbiAgICAgICAgc2VsZi5tZWFzdXJlbWVudENhbnZhcyxcbiAgICAgICAgZW1iZWRTZXR0aW5nc1xuICAgICAgKTtcblxuICAgICAgc2VsZi5kb21FbGVtZW50cy5ob3ZlcnNbbm9kZS5pZF0gPSBob3ZlcjtcblxuICAgICAgLy8gSW5zZXJ0aW5nIHRoZSBob3ZlciBpbiB0aGUgZG9tXG4gICAgICBzZWxmLmRvbUVsZW1lbnRzLmdyb3Vwcy5ob3ZlcnMuYXBwZW5kQ2hpbGQoaG92ZXIpO1xuICAgICAgaG92ZXJlZE5vZGUgPSBub2RlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG91dE5vZGUoZSkge1xuICAgICAgdmFyIG5vZGUgPSBlLmRhdGEubm9kZSxcbiAgICAgICAgICBlbWJlZFNldHRpbmdzID0gc2VsZi5zZXR0aW5ncy5lbWJlZE9iamVjdHMoe1xuICAgICAgICAgICAgcHJlZml4OiBwcmVmaXhcbiAgICAgICAgICB9KTtcblxuICAgICAgaWYgKCFlbWJlZFNldHRpbmdzKCdlbmFibGVIb3ZlcmluZycpKVxuICAgICAgICByZXR1cm47XG5cbiAgICAgIC8vIERlbGV0aW5nIGVsZW1lbnRcbiAgICAgIHNlbGYuZG9tRWxlbWVudHMuZ3JvdXBzLmhvdmVycy5yZW1vdmVDaGlsZChcbiAgICAgICAgc2VsZi5kb21FbGVtZW50cy5ob3ZlcnNbbm9kZS5pZF1cbiAgICAgICk7XG4gICAgICBob3ZlcmVkTm9kZSA9IG51bGw7XG4gICAgICBkZWxldGUgc2VsZi5kb21FbGVtZW50cy5ob3ZlcnNbbm9kZS5pZF07XG5cbiAgICAgIC8vIFJlaW5zdGF0ZVxuICAgICAgc2VsZi5kb21FbGVtZW50cy5ncm91cHMubm9kZXMuYXBwZW5kQ2hpbGQoXG4gICAgICAgIHNlbGYuZG9tRWxlbWVudHMubm9kZXNbbm9kZS5pZF1cbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gT1BUSU1JWkU6IHBlcmZvcm0gYSByZWFsIHVwZGF0ZSByYXRoZXIgdGhhbiBhIGRlbGV0aW9uXG4gICAgZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgICAgaWYgKCFob3ZlcmVkTm9kZSlcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICB2YXIgZW1iZWRTZXR0aW5ncyA9IHNlbGYuc2V0dGluZ3MuZW1iZWRPYmplY3RzKHtcbiAgICAgICAgICAgIHByZWZpeDogcHJlZml4XG4gICAgICAgICAgfSk7XG5cbiAgICAgIC8vIERlbGV0aW5nIGVsZW1lbnQgYmVmb3JlIHVwZGF0ZVxuICAgICAgc2VsZi5kb21FbGVtZW50cy5ncm91cHMuaG92ZXJzLnJlbW92ZUNoaWxkKFxuICAgICAgICBzZWxmLmRvbUVsZW1lbnRzLmhvdmVyc1tob3ZlcmVkTm9kZS5pZF1cbiAgICAgICk7XG4gICAgICBkZWxldGUgc2VsZi5kb21FbGVtZW50cy5ob3ZlcnNbaG92ZXJlZE5vZGUuaWRdO1xuXG4gICAgICB2YXIgaG92ZXIgPSAocmVuZGVyZXJzW2hvdmVyZWROb2RlLnR5cGVdIHx8IHJlbmRlcmVycy5kZWYpLmNyZWF0ZShcbiAgICAgICAgaG92ZXJlZE5vZGUsXG4gICAgICAgIHNlbGYuZG9tRWxlbWVudHMubm9kZXNbaG92ZXJlZE5vZGUuaWRdLFxuICAgICAgICBzZWxmLm1lYXN1cmVtZW50Q2FudmFzLFxuICAgICAgICBlbWJlZFNldHRpbmdzXG4gICAgICApO1xuXG4gICAgICBzZWxmLmRvbUVsZW1lbnRzLmhvdmVyc1tob3ZlcmVkTm9kZS5pZF0gPSBob3ZlcjtcblxuICAgICAgLy8gSW5zZXJ0aW5nIHRoZSBob3ZlciBpbiB0aGUgZG9tXG4gICAgICBzZWxmLmRvbUVsZW1lbnRzLmdyb3Vwcy5ob3ZlcnMuYXBwZW5kQ2hpbGQoaG92ZXIpO1xuICAgIH1cblxuICAgIC8vIEJpbmRpbmcgZXZlbnRzXG4gICAgdGhpcy5iaW5kKCdvdmVyTm9kZScsIG92ZXJOb2RlKTtcbiAgICB0aGlzLmJpbmQoJ291dE5vZGUnLCBvdXROb2RlKTtcblxuICAgIC8vIFVwZGF0ZSBvbiByZW5kZXJcbiAgICB0aGlzLmJpbmQoJ3JlbmRlcicsIHVwZGF0ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHJlc2l6ZXMgZWFjaCBET00gZWxlbWVudHMgaW4gdGhlIGNvbnRhaW5lciBhbmQgc3RvcmVzIHRoZSBuZXdcbiAgICogZGltZW5zaW9ucy4gVGhlbiwgaXQgcmVuZGVycyB0aGUgZ3JhcGguXG4gICAqXG4gICAqIEBwYXJhbSAgez9udW1iZXJ9ICAgICAgICAgICAgICAgIHdpZHRoICBUaGUgbmV3IHdpZHRoIG9mIHRoZSBjb250YWluZXIuXG4gICAqIEBwYXJhbSAgez9udW1iZXJ9ICAgICAgICAgICAgICAgIGhlaWdodCBUaGUgbmV3IGhlaWdodCBvZiB0aGUgY29udGFpbmVyLlxuICAgKiBAcmV0dXJuIHtzaWdtYS5yZW5kZXJlcnMuc3ZnfSAgICAgICAgICAgUmV0dXJucyB0aGUgaW5zdGFuY2UgaXRzZWxmLlxuICAgKi9cbiAgc2lnbWEucmVuZGVyZXJzLnN2Zy5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24odywgaCkge1xuICAgIHZhciBvbGRXaWR0aCA9IHRoaXMud2lkdGgsXG4gICAgICAgIG9sZEhlaWdodCA9IHRoaXMuaGVpZ2h0LFxuICAgICAgICBwaXhlbFJhdGlvID0gMTtcblxuICAgIGlmICh3ICE9PSB1bmRlZmluZWQgJiYgaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLndpZHRoID0gdztcbiAgICAgIHRoaXMuaGVpZ2h0ID0gaDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53aWR0aCA9IHRoaXMuY29udGFpbmVyLm9mZnNldFdpZHRoO1xuICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLmNvbnRhaW5lci5vZmZzZXRIZWlnaHQ7XG5cbiAgICAgIHcgPSB0aGlzLndpZHRoO1xuICAgICAgaCA9IHRoaXMuaGVpZ2h0O1xuICAgIH1cblxuICAgIGlmIChvbGRXaWR0aCAhPT0gdGhpcy53aWR0aCB8fCBvbGRIZWlnaHQgIT09IHRoaXMuaGVpZ2h0KSB7XG4gICAgICB0aGlzLmRvbUVsZW1lbnRzLmdyYXBoLnN0eWxlLndpZHRoID0gdyArICdweCc7XG4gICAgICB0aGlzLmRvbUVsZW1lbnRzLmdyYXBoLnN0eWxlLmhlaWdodCA9IGggKyAncHgnO1xuXG4gICAgICBpZiAodGhpcy5kb21FbGVtZW50cy5ncmFwaC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdzdmcnKSB7XG4gICAgICAgIHRoaXMuZG9tRWxlbWVudHMuZ3JhcGguc2V0QXR0cmlidXRlKCd3aWR0aCcsICh3ICogcGl4ZWxSYXRpbykpO1xuICAgICAgICB0aGlzLmRvbUVsZW1lbnRzLmdyYXBoLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgKGggKiBwaXhlbFJhdGlvKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cblxuICAvKipcbiAgICogVGhlIGxhYmVscywgbm9kZXMgYW5kIGVkZ2VzIHJlbmRlcmVycyBhcmUgc3RvcmVkIGluIHRoZSB0aHJlZSBmb2xsb3dpbmdcbiAgICogb2JqZWN0cy4gV2hlbiBhbiBlbGVtZW50IGlzIGRyYXduLCBpdHMgdHlwZSB3aWxsIGJlIGNoZWNrZWQgYW5kIGlmIGFcbiAgICogcmVuZGVyZXIgd2l0aCB0aGUgc2FtZSBuYW1lIGV4aXN0cywgaXQgd2lsbCBiZSB1c2VkLiBJZiBub3QgZm91bmQsIHRoZVxuICAgKiBkZWZhdWx0IHJlbmRlcmVyIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLlxuICAgKlxuICAgKiBUaGV5IGFyZSBzdG9yZWQgaW4gZGlmZmVyZW50IGZpbGVzLCBpbiB0aGUgXCIuL3N2Z1wiIGZvbGRlci5cbiAgICovXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuc3ZnLm5vZGVzJyk7XG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuc3ZnLmVkZ2VzJyk7XG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuc3ZnLmxhYmVscycpO1xufSkuY2FsbCh0aGlzKTtcblxuOyhmdW5jdGlvbihnbG9iYWwpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmICh0eXBlb2Ygc2lnbWEgPT09ICd1bmRlZmluZWQnKVxuICAgIHRocm93ICdzaWdtYSBpcyBub3QgZGVjbGFyZWQnO1xuXG4gIC8vIEluaXRpYWxpemUgcGFja2FnZXM6XG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEucmVuZGVyZXJzJyk7XG5cbiAgLy8gQ2hlY2sgaWYgV2ViR0wgaXMgZW5hYmxlZDpcbiAgdmFyIGNhbnZhcyxcbiAgICAgIHdlYmdsID0gISFnbG9iYWwuV2ViR0xSZW5kZXJpbmdDb250ZXh0O1xuICBpZiAod2ViZ2wpIHtcbiAgICBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICB0cnkge1xuICAgICAgd2ViZ2wgPSAhIShcbiAgICAgICAgY2FudmFzLmdldENvbnRleHQoJ3dlYmdsJykgfHxcbiAgICAgICAgY2FudmFzLmdldENvbnRleHQoJ2V4cGVyaW1lbnRhbC13ZWJnbCcpXG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHdlYmdsID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLy8gQ29weSB0aGUgZ29vZCByZW5kZXJlcjpcbiAgc2lnbWEucmVuZGVyZXJzLmRlZiA9IHdlYmdsID9cbiAgICBzaWdtYS5yZW5kZXJlcnMud2ViZ2wgOlxuICAgIHNpZ21hLnJlbmRlcmVycy5jYW52YXM7XG59KSh0aGlzKTtcblxuOyhmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEud2ViZ2wubm9kZXMnKTtcblxuICAvKipcbiAgICogVGhpcyBub2RlIHJlbmRlcmVyIHdpbGwgZGlzcGxheSBub2RlcyBhcyBkaXNjcywgc2hhcGVkIGluIHRyaWFuZ2xlcyB3aXRoXG4gICAqIHRoZSBnbC5UUklBTkdMRVMgZGlzcGxheSBtb2RlLiBTbywgdG8gYmUgbW9yZSBwcmVjaXNlLCB0byBkcmF3IG9uZSBub2RlLFxuICAgKiBpdCB3aWxsIHN0b3JlIHRocmVlIHRpbWVzIHRoZSBjZW50ZXIgb2Ygbm9kZSwgd2l0aCB0aGUgY29sb3IgYW5kIHRoZSBzaXplLFxuICAgKiBhbmQgYW4gYW5nbGUgaW5kaWNhdGluZyB3aGljaCBcImNvcm5lclwiIG9mIHRoZSB0cmlhbmdsZSB0byBkcmF3LlxuICAgKlxuICAgKiBUaGUgZnJhZ21lbnQgc2hhZGVyIGRvZXMgbm90IGRlYWwgd2l0aCBhbnRpLWFsaWFzaW5nLCBzbyBtYWtlIHN1cmUgdGhhdFxuICAgKiB5b3UgZGVhbCB3aXRoIGl0IHNvbWV3aGVyZSBlbHNlIGluIHRoZSBjb2RlIChieSBkZWZhdWx0LCB0aGUgV2ViR0xcbiAgICogcmVuZGVyZXIgd2lsbCBvdmVyc2FtcGxlIHRoZSByZW5kZXJpbmcgdGhyb3VnaCB0aGUgd2ViZ2xPdmVyc2FtcGxpbmdSYXRpb1xuICAgKiB2YWx1ZSkuXG4gICAqL1xuICBzaWdtYS53ZWJnbC5ub2Rlcy5kZWYgPSB7XG4gICAgUE9JTlRTOiAzLFxuICAgIEFUVFJJQlVURVM6IDUsXG4gICAgYWRkTm9kZTogZnVuY3Rpb24obm9kZSwgZGF0YSwgaSwgcHJlZml4LCBzZXR0aW5ncykge1xuICAgICAgdmFyIGNvbG9yID0gc2lnbWEudXRpbHMuZmxvYXRDb2xvcihcbiAgICAgICAgbm9kZS5jb2xvciB8fCBzZXR0aW5ncygnZGVmYXVsdE5vZGVDb2xvcicpXG4gICAgICApO1xuXG4gICAgICBkYXRhW2krK10gPSBub2RlW3ByZWZpeCArICd4J107XG4gICAgICBkYXRhW2krK10gPSBub2RlW3ByZWZpeCArICd5J107XG4gICAgICBkYXRhW2krK10gPSBub2RlW3ByZWZpeCArICdzaXplJ107XG4gICAgICBkYXRhW2krK10gPSBjb2xvcjtcbiAgICAgIGRhdGFbaSsrXSA9IDA7XG5cbiAgICAgIGRhdGFbaSsrXSA9IG5vZGVbcHJlZml4ICsgJ3gnXTtcbiAgICAgIGRhdGFbaSsrXSA9IG5vZGVbcHJlZml4ICsgJ3knXTtcbiAgICAgIGRhdGFbaSsrXSA9IG5vZGVbcHJlZml4ICsgJ3NpemUnXTtcbiAgICAgIGRhdGFbaSsrXSA9IGNvbG9yO1xuICAgICAgZGF0YVtpKytdID0gMiAqIE1hdGguUEkgLyAzO1xuXG4gICAgICBkYXRhW2krK10gPSBub2RlW3ByZWZpeCArICd4J107XG4gICAgICBkYXRhW2krK10gPSBub2RlW3ByZWZpeCArICd5J107XG4gICAgICBkYXRhW2krK10gPSBub2RlW3ByZWZpeCArICdzaXplJ107XG4gICAgICBkYXRhW2krK10gPSBjb2xvcjtcbiAgICAgIGRhdGFbaSsrXSA9IDQgKiBNYXRoLlBJIC8gMztcbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24oZ2wsIHByb2dyYW0sIGRhdGEsIHBhcmFtcykge1xuICAgICAgdmFyIGJ1ZmZlcjtcblxuICAgICAgLy8gRGVmaW5lIGF0dHJpYnV0ZXM6XG4gICAgICB2YXIgcG9zaXRpb25Mb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV9wb3NpdGlvbicpLFxuICAgICAgICAgIHNpemVMb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV9zaXplJyksXG4gICAgICAgICAgY29sb3JMb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV9jb2xvcicpLFxuICAgICAgICAgIGFuZ2xlTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FfYW5nbGUnKSxcbiAgICAgICAgICByZXNvbHV0aW9uTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X3Jlc29sdXRpb24nKSxcbiAgICAgICAgICBtYXRyaXhMb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfbWF0cml4JyksXG4gICAgICAgICAgcmF0aW9Mb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfcmF0aW8nKSxcbiAgICAgICAgICBzY2FsZUxvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9zY2FsZScpO1xuXG4gICAgICBidWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIpO1xuICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIGRhdGEsIGdsLkRZTkFNSUNfRFJBVyk7XG5cbiAgICAgIGdsLnVuaWZvcm0yZihyZXNvbHV0aW9uTG9jYXRpb24sIHBhcmFtcy53aWR0aCwgcGFyYW1zLmhlaWdodCk7XG4gICAgICBnbC51bmlmb3JtMWYoXG4gICAgICAgIHJhdGlvTG9jYXRpb24sXG4gICAgICAgIDEgLyBNYXRoLnBvdyhwYXJhbXMucmF0aW8sIHBhcmFtcy5zZXR0aW5ncygnbm9kZXNQb3dSYXRpbycpKVxuICAgICAgKTtcbiAgICAgIGdsLnVuaWZvcm0xZihzY2FsZUxvY2F0aW9uLCBwYXJhbXMuc2NhbGluZ1JhdGlvKTtcbiAgICAgIGdsLnVuaWZvcm1NYXRyaXgzZnYobWF0cml4TG9jYXRpb24sIGZhbHNlLCBwYXJhbXMubWF0cml4KTtcblxuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkocG9zaXRpb25Mb2NhdGlvbik7XG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShzaXplTG9jYXRpb24pO1xuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoY29sb3JMb2NhdGlvbik7XG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShhbmdsZUxvY2F0aW9uKTtcblxuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihcbiAgICAgICAgcG9zaXRpb25Mb2NhdGlvbixcbiAgICAgICAgMixcbiAgICAgICAgZ2wuRkxPQVQsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICB0aGlzLkFUVFJJQlVURVMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXG4gICAgICAgIDBcbiAgICAgICk7XG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKFxuICAgICAgICBzaXplTG9jYXRpb24sXG4gICAgICAgIDEsXG4gICAgICAgIGdsLkZMT0FULFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgdGhpcy5BVFRSSUJVVEVTICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxuICAgICAgICA4XG4gICAgICApO1xuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihcbiAgICAgICAgY29sb3JMb2NhdGlvbixcbiAgICAgICAgMSxcbiAgICAgICAgZ2wuRkxPQVQsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICB0aGlzLkFUVFJJQlVURVMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXG4gICAgICAgIDEyXG4gICAgICApO1xuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihcbiAgICAgICAgYW5nbGVMb2NhdGlvbixcbiAgICAgICAgMSxcbiAgICAgICAgZ2wuRkxPQVQsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICB0aGlzLkFUVFJJQlVURVMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXG4gICAgICAgIDE2XG4gICAgICApO1xuXG4gICAgICBnbC5kcmF3QXJyYXlzKFxuICAgICAgICBnbC5UUklBTkdMRVMsXG4gICAgICAgIHBhcmFtcy5zdGFydCB8fCAwLFxuICAgICAgICBwYXJhbXMuY291bnQgfHwgKGRhdGEubGVuZ3RoIC8gdGhpcy5BVFRSSUJVVEVTKVxuICAgICAgKTtcbiAgICB9LFxuICAgIGluaXRQcm9ncmFtOiBmdW5jdGlvbihnbCkge1xuICAgICAgdmFyIHZlcnRleFNoYWRlcixcbiAgICAgICAgICBmcmFnbWVudFNoYWRlcixcbiAgICAgICAgICBwcm9ncmFtO1xuXG4gICAgICB2ZXJ0ZXhTaGFkZXIgPSBzaWdtYS51dGlscy5sb2FkU2hhZGVyKFxuICAgICAgICBnbCxcbiAgICAgICAgW1xuICAgICAgICAgICdhdHRyaWJ1dGUgdmVjMiBhX3Bvc2l0aW9uOycsXG4gICAgICAgICAgJ2F0dHJpYnV0ZSBmbG9hdCBhX3NpemU7JyxcbiAgICAgICAgICAnYXR0cmlidXRlIGZsb2F0IGFfY29sb3I7JyxcbiAgICAgICAgICAnYXR0cmlidXRlIGZsb2F0IGFfYW5nbGU7JyxcblxuICAgICAgICAgICd1bmlmb3JtIHZlYzIgdV9yZXNvbHV0aW9uOycsXG4gICAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdV9yYXRpbzsnLFxuICAgICAgICAgICd1bmlmb3JtIGZsb2F0IHVfc2NhbGU7JyxcbiAgICAgICAgICAndW5pZm9ybSBtYXQzIHVfbWF0cml4OycsXG5cbiAgICAgICAgICAndmFyeWluZyB2ZWM0IGNvbG9yOycsXG4gICAgICAgICAgJ3ZhcnlpbmcgdmVjMiBjZW50ZXI7JyxcbiAgICAgICAgICAndmFyeWluZyBmbG9hdCByYWRpdXM7JyxcblxuICAgICAgICAgICd2b2lkIG1haW4oKSB7JyxcbiAgICAgICAgICAgIC8vIE11bHRpcGx5IHRoZSBwb2ludCBzaXplIHR3aWNlOlxuICAgICAgICAgICAgJ3JhZGl1cyA9IGFfc2l6ZSAqIHVfcmF0aW87JyxcblxuICAgICAgICAgICAgLy8gU2NhbGUgZnJvbSBbWy0xIDFdIFstMSAxXV0gdG8gdGhlIGNvbnRhaW5lcjpcbiAgICAgICAgICAgICd2ZWMyIHBvc2l0aW9uID0gKHVfbWF0cml4ICogdmVjMyhhX3Bvc2l0aW9uLCAxKSkueHk7JyxcbiAgICAgICAgICAgIC8vICdjZW50ZXIgPSAocG9zaXRpb24gLyB1X3Jlc29sdXRpb24gKiAyLjAgLSAxLjApICogdmVjMigxLCAtMSk7JyxcbiAgICAgICAgICAgICdjZW50ZXIgPSBwb3NpdGlvbiAqIHVfc2NhbGU7JyxcbiAgICAgICAgICAgICdjZW50ZXIgPSB2ZWMyKGNlbnRlci54LCB1X3NjYWxlICogdV9yZXNvbHV0aW9uLnkgLSBjZW50ZXIueSk7JyxcblxuICAgICAgICAgICAgJ3Bvc2l0aW9uID0gcG9zaXRpb24gKycsXG4gICAgICAgICAgICAgICcyLjAgKiByYWRpdXMgKiB2ZWMyKGNvcyhhX2FuZ2xlKSwgc2luKGFfYW5nbGUpKTsnLFxuICAgICAgICAgICAgJ3Bvc2l0aW9uID0gKHBvc2l0aW9uIC8gdV9yZXNvbHV0aW9uICogMi4wIC0gMS4wKSAqIHZlYzIoMSwgLTEpOycsXG5cbiAgICAgICAgICAgICdyYWRpdXMgPSByYWRpdXMgKiB1X3NjYWxlOycsXG5cbiAgICAgICAgICAgICdnbF9Qb3NpdGlvbiA9IHZlYzQocG9zaXRpb24sIDAsIDEpOycsXG5cbiAgICAgICAgICAgIC8vIEV4dHJhY3QgdGhlIGNvbG9yOlxuICAgICAgICAgICAgJ2Zsb2F0IGMgPSBhX2NvbG9yOycsXG4gICAgICAgICAgICAnY29sb3IuYiA9IG1vZChjLCAyNTYuMCk7IGMgPSBmbG9vcihjIC8gMjU2LjApOycsXG4gICAgICAgICAgICAnY29sb3IuZyA9IG1vZChjLCAyNTYuMCk7IGMgPSBmbG9vcihjIC8gMjU2LjApOycsXG4gICAgICAgICAgICAnY29sb3IuciA9IG1vZChjLCAyNTYuMCk7IGMgPSBmbG9vcihjIC8gMjU2LjApOyBjb2xvciAvPSAyNTUuMDsnLFxuICAgICAgICAgICAgJ2NvbG9yLmEgPSAxLjA7JyxcbiAgICAgICAgICAnfSdcbiAgICAgICAgXS5qb2luKCdcXG4nKSxcbiAgICAgICAgZ2wuVkVSVEVYX1NIQURFUlxuICAgICAgKTtcblxuICAgICAgZnJhZ21lbnRTaGFkZXIgPSBzaWdtYS51dGlscy5sb2FkU2hhZGVyKFxuICAgICAgICBnbCxcbiAgICAgICAgW1xuICAgICAgICAgICdwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsnLFxuXG4gICAgICAgICAgJ3ZhcnlpbmcgdmVjNCBjb2xvcjsnLFxuICAgICAgICAgICd2YXJ5aW5nIHZlYzIgY2VudGVyOycsXG4gICAgICAgICAgJ3ZhcnlpbmcgZmxvYXQgcmFkaXVzOycsXG5cbiAgICAgICAgICAndm9pZCBtYWluKHZvaWQpIHsnLFxuICAgICAgICAgICAgJ3ZlYzQgY29sb3IwID0gdmVjNCgwLjAsIDAuMCwgMC4wLCAwLjApOycsXG5cbiAgICAgICAgICAgICd2ZWMyIG0gPSBnbF9GcmFnQ29vcmQueHkgLSBjZW50ZXI7JyxcbiAgICAgICAgICAgICdmbG9hdCBkaWZmID0gcmFkaXVzIC0gc3FydChtLnggKiBtLnggKyBtLnkgKiBtLnkpOycsXG5cbiAgICAgICAgICAgIC8vIEhlcmUgaXMgaG93IHdlIGRyYXcgYSBkaXNjIGluc3RlYWQgb2YgYSBzcXVhcmU6XG4gICAgICAgICAgICAnaWYgKGRpZmYgPiAwLjApJyxcbiAgICAgICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yOycsXG4gICAgICAgICAgICAnZWxzZScsXG4gICAgICAgICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjA7JyxcbiAgICAgICAgICAnfSdcbiAgICAgICAgXS5qb2luKCdcXG4nKSxcbiAgICAgICAgZ2wuRlJBR01FTlRfU0hBREVSXG4gICAgICApO1xuXG4gICAgICBwcm9ncmFtID0gc2lnbWEudXRpbHMubG9hZFByb2dyYW0oZ2wsIFt2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyXSk7XG5cbiAgICAgIHJldHVybiBwcm9ncmFtO1xuICAgIH1cbiAgfTtcbn0pKCk7XG5cbjsoZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLndlYmdsLm5vZGVzJyk7XG5cbiAgLyoqXG4gICAqIFRoaXMgbm9kZSByZW5kZXJlciB3aWxsIGRpc3BsYXkgbm9kZXMgaW4gdGhlIGZhc3Rlc3Qgd2F5OiBOb2RlcyBhcmUgYmFzaWNcbiAgICogc3F1YXJlcywgZHJhd24gdGhyb3VnaCB0aGUgZ2wuUE9JTlRTIGRyYXdpbmcgbWV0aG9kLiBUaGUgc2l6ZSBvZiB0aGUgbm9kZXNcbiAgICogYXJlIHJlcHJlc2VudGVkIHdpdGggdGhlIFwiZ2xfUG9pbnRTaXplXCIgdmFsdWUgaW4gdGhlIHZlcnRleCBzaGFkZXIuXG4gICAqXG4gICAqIEl0IGlzIHRoZSBmYXN0ZXN0IG5vZGUgcmVuZGVyZXIgaGVyZSBzaW5jZSB0aGUgYnVmZmVyIGp1c3QgdGFrZXMgb25lIGxpbmVcbiAgICogdG8gZHJhdyBlYWNoIG5vZGUgKHdpdGggYXR0cmlidXRlcyBcInhcIiwgXCJ5XCIsIFwic2l6ZVwiIGFuZCBcImNvbG9yXCIpLlxuICAgKlxuICAgKiBOZXZlcnRoZWxlc3MsIHRoaXMgbWV0aG9kIGhhcyBzb21lIHByb2JsZW1zLCBlc3BlY2lhbGx5IGR1ZSB0byBzb21lIGlzc3Vlc1xuICAgKiB3aXRoIHRoZSBnbC5QT0lOVFM6XG4gICAqICAtIEZpcnN0LCBpZiB0aGUgY2VudGVyIG9mIGEgbm9kZSBpcyBvdXRzaWRlIHRoZSBzY2VuZSwgdGhlIHBvaW50IHdpbGwgbm90XG4gICAqICAgIGJlIGRyYXduLCBldmVuIGlmIGl0IHNob3VsZCBiZSBwYXJ0bHkgb24gc2NyZWVuLlxuICAgKiAgLSBJIHRyaWVkIGFwcGx5aW5nIGEgZnJhZ21lbnQgc2hhZGVyIHNpbWlsYXIgdG8gdGhlIG9uZSBpbiB0aGUgZGVmYXVsdFxuICAgKiAgICBub2RlIHJlbmRlcmVyIHRvIGRpc3BsYXkgdGhlbSBhcyBkaXNjcywgYnV0IGl0IGRpZCBub3Qgd29yayBmaW5lIG9uXG4gICAqICAgIHNvbWUgY29tcHV0ZXJzIHNldHRpbmdzLCBmaWxsaW5nIHRoZSBkaXNjcyB3aXRoIHdlaXJkIGdyYWRpZW50cyBub3RcbiAgICogICAgZGVwZW5kaW5nIG9uIHRoZSBhY3R1YWwgY29sb3IuXG4gICAqL1xuICBzaWdtYS53ZWJnbC5ub2Rlcy5mYXN0ID0ge1xuICAgIFBPSU5UUzogMSxcbiAgICBBVFRSSUJVVEVTOiA0LFxuICAgIGFkZE5vZGU6IGZ1bmN0aW9uKG5vZGUsIGRhdGEsIGksIHByZWZpeCwgc2V0dGluZ3MpIHtcbiAgICAgIGRhdGFbaSsrXSA9IG5vZGVbcHJlZml4ICsgJ3gnXTtcbiAgICAgIGRhdGFbaSsrXSA9IG5vZGVbcHJlZml4ICsgJ3knXTtcbiAgICAgIGRhdGFbaSsrXSA9IG5vZGVbcHJlZml4ICsgJ3NpemUnXTtcbiAgICAgIGRhdGFbaSsrXSA9IHNpZ21hLnV0aWxzLmZsb2F0Q29sb3IoXG4gICAgICAgIG5vZGUuY29sb3IgfHwgc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKVxuICAgICAgKTtcbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24oZ2wsIHByb2dyYW0sIGRhdGEsIHBhcmFtcykge1xuICAgICAgdmFyIGJ1ZmZlcjtcblxuICAgICAgLy8gRGVmaW5lIGF0dHJpYnV0ZXM6XG4gICAgICB2YXIgcG9zaXRpb25Mb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV9wb3NpdGlvbicpLFxuICAgICAgICAgIHNpemVMb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV9zaXplJyksXG4gICAgICAgICAgY29sb3JMb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV9jb2xvcicpLFxuICAgICAgICAgIHJlc29sdXRpb25Mb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfcmVzb2x1dGlvbicpLFxuICAgICAgICAgIG1hdHJpeExvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9tYXRyaXgnKSxcbiAgICAgICAgICByYXRpb0xvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9yYXRpbycpLFxuICAgICAgICAgIHNjYWxlTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X3NjYWxlJyk7XG5cbiAgICAgIGJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7XG4gICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgZGF0YSwgZ2wuRFlOQU1JQ19EUkFXKTtcblxuICAgICAgZ2wudW5pZm9ybTJmKHJlc29sdXRpb25Mb2NhdGlvbiwgcGFyYW1zLndpZHRoLCBwYXJhbXMuaGVpZ2h0KTtcbiAgICAgIGdsLnVuaWZvcm0xZihcbiAgICAgICAgcmF0aW9Mb2NhdGlvbixcbiAgICAgICAgMSAvIE1hdGgucG93KHBhcmFtcy5yYXRpbywgcGFyYW1zLnNldHRpbmdzKCdub2Rlc1Bvd1JhdGlvJykpXG4gICAgICApO1xuICAgICAgZ2wudW5pZm9ybTFmKHNjYWxlTG9jYXRpb24sIHBhcmFtcy5zY2FsaW5nUmF0aW8pO1xuICAgICAgZ2wudW5pZm9ybU1hdHJpeDNmdihtYXRyaXhMb2NhdGlvbiwgZmFsc2UsIHBhcmFtcy5tYXRyaXgpO1xuXG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShwb3NpdGlvbkxvY2F0aW9uKTtcbiAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHNpemVMb2NhdGlvbik7XG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShjb2xvckxvY2F0aW9uKTtcblxuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihcbiAgICAgICAgcG9zaXRpb25Mb2NhdGlvbixcbiAgICAgICAgMixcbiAgICAgICAgZ2wuRkxPQVQsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICB0aGlzLkFUVFJJQlVURVMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXG4gICAgICAgIDBcbiAgICAgICk7XG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKFxuICAgICAgICBzaXplTG9jYXRpb24sXG4gICAgICAgIDEsXG4gICAgICAgIGdsLkZMT0FULFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgdGhpcy5BVFRSSUJVVEVTICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxuICAgICAgICA4XG4gICAgICApO1xuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihcbiAgICAgICAgY29sb3JMb2NhdGlvbixcbiAgICAgICAgMSxcbiAgICAgICAgZ2wuRkxPQVQsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICB0aGlzLkFUVFJJQlVURVMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXG4gICAgICAgIDEyXG4gICAgICApO1xuXG4gICAgICBnbC5kcmF3QXJyYXlzKFxuICAgICAgICBnbC5QT0lOVFMsXG4gICAgICAgIHBhcmFtcy5zdGFydCB8fCAwLFxuICAgICAgICBwYXJhbXMuY291bnQgfHwgKGRhdGEubGVuZ3RoIC8gdGhpcy5BVFRSSUJVVEVTKVxuICAgICAgKTtcbiAgICB9LFxuICAgIGluaXRQcm9ncmFtOiBmdW5jdGlvbihnbCkge1xuICAgICAgdmFyIHZlcnRleFNoYWRlcixcbiAgICAgICAgICBmcmFnbWVudFNoYWRlcixcbiAgICAgICAgICBwcm9ncmFtO1xuXG4gICAgICB2ZXJ0ZXhTaGFkZXIgPSBzaWdtYS51dGlscy5sb2FkU2hhZGVyKFxuICAgICAgICBnbCxcbiAgICAgICAgW1xuICAgICAgICAgICdhdHRyaWJ1dGUgdmVjMiBhX3Bvc2l0aW9uOycsXG4gICAgICAgICAgJ2F0dHJpYnV0ZSBmbG9hdCBhX3NpemU7JyxcbiAgICAgICAgICAnYXR0cmlidXRlIGZsb2F0IGFfY29sb3I7JyxcblxuICAgICAgICAgICd1bmlmb3JtIHZlYzIgdV9yZXNvbHV0aW9uOycsXG4gICAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdV9yYXRpbzsnLFxuICAgICAgICAgICd1bmlmb3JtIGZsb2F0IHVfc2NhbGU7JyxcbiAgICAgICAgICAndW5pZm9ybSBtYXQzIHVfbWF0cml4OycsXG5cbiAgICAgICAgICAndmFyeWluZyB2ZWM0IGNvbG9yOycsXG5cbiAgICAgICAgICAndm9pZCBtYWluKCkgeycsXG4gICAgICAgICAgICAvLyBTY2FsZSBmcm9tIFtbLTEgMV0gWy0xIDFdXSB0byB0aGUgY29udGFpbmVyOlxuICAgICAgICAgICAgJ2dsX1Bvc2l0aW9uID0gdmVjNCgnLFxuICAgICAgICAgICAgICAnKCh1X21hdHJpeCAqIHZlYzMoYV9wb3NpdGlvbiwgMSkpLnh5IC8nLFxuICAgICAgICAgICAgICAgICd1X3Jlc29sdXRpb24gKiAyLjAgLSAxLjApICogdmVjMigxLCAtMSksJyxcbiAgICAgICAgICAgICAgJzAsJyxcbiAgICAgICAgICAgICAgJzEnLFxuICAgICAgICAgICAgJyk7JyxcblxuICAgICAgICAgICAgLy8gTXVsdGlwbHkgdGhlIHBvaW50IHNpemUgdHdpY2U6XG4gICAgICAgICAgICAvLyAgLSB4IFNDQUxJTkdfUkFUSU8gdG8gY29ycmVjdCB0aGUgY2FudmFzIHNjYWxpbmdcbiAgICAgICAgICAgIC8vICAtIHggMiB0byBjb3JyZWN0IHRoZSBmb3JtdWxhZVxuICAgICAgICAgICAgJ2dsX1BvaW50U2l6ZSA9IGFfc2l6ZSAqIHVfcmF0aW8gKiB1X3NjYWxlICogMi4wOycsXG5cbiAgICAgICAgICAgIC8vIEV4dHJhY3QgdGhlIGNvbG9yOlxuICAgICAgICAgICAgJ2Zsb2F0IGMgPSBhX2NvbG9yOycsXG4gICAgICAgICAgICAnY29sb3IuYiA9IG1vZChjLCAyNTYuMCk7IGMgPSBmbG9vcihjIC8gMjU2LjApOycsXG4gICAgICAgICAgICAnY29sb3IuZyA9IG1vZChjLCAyNTYuMCk7IGMgPSBmbG9vcihjIC8gMjU2LjApOycsXG4gICAgICAgICAgICAnY29sb3IuciA9IG1vZChjLCAyNTYuMCk7IGMgPSBmbG9vcihjIC8gMjU2LjApOyBjb2xvciAvPSAyNTUuMDsnLFxuICAgICAgICAgICAgJ2NvbG9yLmEgPSAxLjA7JyxcbiAgICAgICAgICAnfSdcbiAgICAgICAgXS5qb2luKCdcXG4nKSxcbiAgICAgICAgZ2wuVkVSVEVYX1NIQURFUlxuICAgICAgKTtcblxuICAgICAgZnJhZ21lbnRTaGFkZXIgPSBzaWdtYS51dGlscy5sb2FkU2hhZGVyKFxuICAgICAgICBnbCxcbiAgICAgICAgW1xuICAgICAgICAgICdwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsnLFxuXG4gICAgICAgICAgJ3ZhcnlpbmcgdmVjNCBjb2xvcjsnLFxuXG4gICAgICAgICAgJ3ZvaWQgbWFpbih2b2lkKSB7JyxcbiAgICAgICAgICAgICdmbG9hdCBib3JkZXIgPSAwLjAxOycsXG4gICAgICAgICAgICAnZmxvYXQgcmFkaXVzID0gMC41OycsXG5cbiAgICAgICAgICAgICd2ZWM0IGNvbG9yMCA9IHZlYzQoMC4wLCAwLjAsIDAuMCwgMC4wKTsnLFxuICAgICAgICAgICAgJ3ZlYzIgbSA9IGdsX1BvaW50Q29vcmQgLSB2ZWMyKDAuNSwgMC41KTsnLFxuICAgICAgICAgICAgJ2Zsb2F0IGRpc3QgPSByYWRpdXMgLSBzcXJ0KG0ueCAqIG0ueCArIG0ueSAqIG0ueSk7JyxcblxuICAgICAgICAgICAgJ2Zsb2F0IHQgPSAwLjA7JyxcbiAgICAgICAgICAgICdpZiAoZGlzdCA+IGJvcmRlciknLFxuICAgICAgICAgICAgICAndCA9IDEuMDsnLFxuICAgICAgICAgICAgJ2Vsc2UgaWYgKGRpc3QgPiAwLjApJyxcbiAgICAgICAgICAgICAgJ3QgPSBkaXN0IC8gYm9yZGVyOycsXG5cbiAgICAgICAgICAgICdnbF9GcmFnQ29sb3IgPSBtaXgoY29sb3IwLCBjb2xvciwgdCk7JyxcbiAgICAgICAgICAnfSdcbiAgICAgICAgXS5qb2luKCdcXG4nKSxcbiAgICAgICAgZ2wuRlJBR01FTlRfU0hBREVSXG4gICAgICApO1xuXG4gICAgICBwcm9ncmFtID0gc2lnbWEudXRpbHMubG9hZFByb2dyYW0oZ2wsIFt2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyXSk7XG5cbiAgICAgIHJldHVybiBwcm9ncmFtO1xuICAgIH1cbiAgfTtcbn0pKCk7XG5cbjsoZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLndlYmdsLmVkZ2VzJyk7XG5cbiAgLyoqXG4gICAqIFRoaXMgZWRnZSByZW5kZXJlciB3aWxsIGRpc3BsYXkgZWRnZXMgYXMgbGluZXMgZ29pbmcgZnJvbSB0aGUgc291cmNlIG5vZGVcbiAgICogdG8gdGhlIHRhcmdldCBub2RlLiBUbyBkZWFsIHdpdGggZWRnZSB0aGlja25lc3NlcywgdGhlIGxpbmVzIGFyZSBtYWRlIG9mXG4gICAqIHR3byB0cmlhbmdsZXMgZm9ybWluZyByZWN0YW5nbGVzLCB3aXRoIHRoZSBnbC5UUklBTkdMRVMgZHJhd2luZyBtb2RlLlxuICAgKlxuICAgKiBJdCBpcyBleHBlbnNpdmUsIHNpbmNlIGRyYXdpbmcgYSBzaW5nbGUgZWRnZSByZXF1aXJlcyA2IHBvaW50cywgZWFjaFxuICAgKiBoYXZpbmcgNyBhdHRyaWJ1dGVzIChzb3VyY2UgcG9zaXRpb24sIHRhcmdldCBwb3NpdGlvbiwgdGhpY2tuZXNzLCBjb2xvclxuICAgKiBhbmQgYSBmbGFnIGluZGljYXRpbmcgd2hpY2ggdmVydGljZSBvZiB0aGUgcmVjdGFuZ2xlIGl0IGlzKS5cbiAgICovXG4gIHNpZ21hLndlYmdsLmVkZ2VzLmRlZiA9IHtcbiAgICBQT0lOVFM6IDYsXG4gICAgQVRUUklCVVRFUzogNyxcbiAgICBhZGRFZGdlOiBmdW5jdGlvbihlZGdlLCBzb3VyY2UsIHRhcmdldCwgZGF0YSwgaSwgcHJlZml4LCBzZXR0aW5ncykge1xuICAgICAgdmFyIHcgPSAoZWRnZVtwcmVmaXggKyAnc2l6ZSddIHx8IDEpIC8gMixcbiAgICAgICAgICB4MSA9IHNvdXJjZVtwcmVmaXggKyAneCddLFxuICAgICAgICAgIHkxID0gc291cmNlW3ByZWZpeCArICd5J10sXG4gICAgICAgICAgeDIgPSB0YXJnZXRbcHJlZml4ICsgJ3gnXSxcbiAgICAgICAgICB5MiA9IHRhcmdldFtwcmVmaXggKyAneSddLFxuICAgICAgICAgIGNvbG9yID0gZWRnZS5jb2xvcjtcblxuICAgICAgaWYgKCFjb2xvcilcbiAgICAgICAgc3dpdGNoIChzZXR0aW5ncygnZWRnZUNvbG9yJykpIHtcbiAgICAgICAgICBjYXNlICdzb3VyY2UnOlxuICAgICAgICAgICAgY29sb3IgPSBzb3VyY2UuY29sb3IgfHwgc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3RhcmdldCc6XG4gICAgICAgICAgICBjb2xvciA9IHRhcmdldC5jb2xvciB8fCBzZXR0aW5ncygnZGVmYXVsdE5vZGVDb2xvcicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNvbG9yID0gc2V0dGluZ3MoJ2RlZmF1bHRFZGdlQ29sb3InKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIC8vIE5vcm1hbGl6ZSBjb2xvcjpcbiAgICAgIGNvbG9yID0gc2lnbWEudXRpbHMuZmxvYXRDb2xvcihjb2xvcik7XG5cbiAgICAgIGRhdGFbaSsrXSA9IHgxO1xuICAgICAgZGF0YVtpKytdID0geTE7XG4gICAgICBkYXRhW2krK10gPSB4MjtcbiAgICAgIGRhdGFbaSsrXSA9IHkyO1xuICAgICAgZGF0YVtpKytdID0gdztcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcbiAgICAgIGRhdGFbaSsrXSA9IGNvbG9yO1xuXG4gICAgICBkYXRhW2krK10gPSB4MjtcbiAgICAgIGRhdGFbaSsrXSA9IHkyO1xuICAgICAgZGF0YVtpKytdID0geDE7XG4gICAgICBkYXRhW2krK10gPSB5MTtcbiAgICAgIGRhdGFbaSsrXSA9IHc7XG4gICAgICBkYXRhW2krK10gPSAxLjA7XG4gICAgICBkYXRhW2krK10gPSBjb2xvcjtcblxuICAgICAgZGF0YVtpKytdID0geDI7XG4gICAgICBkYXRhW2krK10gPSB5MjtcbiAgICAgIGRhdGFbaSsrXSA9IHgxO1xuICAgICAgZGF0YVtpKytdID0geTE7XG4gICAgICBkYXRhW2krK10gPSB3O1xuICAgICAgZGF0YVtpKytdID0gMC4wO1xuICAgICAgZGF0YVtpKytdID0gY29sb3I7XG5cbiAgICAgIGRhdGFbaSsrXSA9IHgyO1xuICAgICAgZGF0YVtpKytdID0geTI7XG4gICAgICBkYXRhW2krK10gPSB4MTtcbiAgICAgIGRhdGFbaSsrXSA9IHkxO1xuICAgICAgZGF0YVtpKytdID0gdztcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcbiAgICAgIGRhdGFbaSsrXSA9IGNvbG9yO1xuXG4gICAgICBkYXRhW2krK10gPSB4MTtcbiAgICAgIGRhdGFbaSsrXSA9IHkxO1xuICAgICAgZGF0YVtpKytdID0geDI7XG4gICAgICBkYXRhW2krK10gPSB5MjtcbiAgICAgIGRhdGFbaSsrXSA9IHc7XG4gICAgICBkYXRhW2krK10gPSAxLjA7XG4gICAgICBkYXRhW2krK10gPSBjb2xvcjtcblxuICAgICAgZGF0YVtpKytdID0geDE7XG4gICAgICBkYXRhW2krK10gPSB5MTtcbiAgICAgIGRhdGFbaSsrXSA9IHgyO1xuICAgICAgZGF0YVtpKytdID0geTI7XG4gICAgICBkYXRhW2krK10gPSB3O1xuICAgICAgZGF0YVtpKytdID0gMC4wO1xuICAgICAgZGF0YVtpKytdID0gY29sb3I7XG4gICAgfSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uKGdsLCBwcm9ncmFtLCBkYXRhLCBwYXJhbXMpIHtcbiAgICAgIHZhciBidWZmZXI7XG5cbiAgICAgIC8vIERlZmluZSBhdHRyaWJ1dGVzOlxuICAgICAgdmFyIGNvbG9yTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FfY29sb3InKSxcbiAgICAgICAgICBwb3NpdGlvbkxvY2F0aW9uMSA9XG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV9wb3NpdGlvbjEnKSxcbiAgICAgICAgICBwb3NpdGlvbkxvY2F0aW9uMiA9XG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV9wb3NpdGlvbjInKSxcbiAgICAgICAgICB0aGlja25lc3NMb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV90aGlja25lc3MnKSxcbiAgICAgICAgICBtaW51c0xvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhX21pbnVzJyksXG4gICAgICAgICAgcmVzb2x1dGlvbkxvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9yZXNvbHV0aW9uJyksXG4gICAgICAgICAgbWF0cml4TG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X21hdHJpeCcpLFxuICAgICAgICAgIG1hdHJpeEhhbGZQaUxvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9tYXRyaXhIYWxmUGknKSxcbiAgICAgICAgICBtYXRyaXhIYWxmUGlNaW51c0xvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9tYXRyaXhIYWxmUGlNaW51cycpLFxuICAgICAgICAgIHJhdGlvTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X3JhdGlvJyksXG4gICAgICAgICAgc2NhbGVMb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3Vfc2NhbGUnKTtcblxuICAgICAgYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKTtcbiAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBkYXRhLCBnbC5TVEFUSUNfRFJBVyk7XG5cbiAgICAgIGdsLnVuaWZvcm0yZihyZXNvbHV0aW9uTG9jYXRpb24sIHBhcmFtcy53aWR0aCwgcGFyYW1zLmhlaWdodCk7XG4gICAgICBnbC51bmlmb3JtMWYoXG4gICAgICAgIHJhdGlvTG9jYXRpb24sXG4gICAgICAgIHBhcmFtcy5yYXRpbyAvIE1hdGgucG93KHBhcmFtcy5yYXRpbywgcGFyYW1zLnNldHRpbmdzKCdlZGdlc1Bvd1JhdGlvJykpXG4gICAgICApO1xuICAgICAgZ2wudW5pZm9ybTFmKHNjYWxlTG9jYXRpb24sIHBhcmFtcy5zY2FsaW5nUmF0aW8pO1xuICAgICAgZ2wudW5pZm9ybU1hdHJpeDNmdihtYXRyaXhMb2NhdGlvbiwgZmFsc2UsIHBhcmFtcy5tYXRyaXgpO1xuICAgICAgZ2wudW5pZm9ybU1hdHJpeDJmdihcbiAgICAgICAgbWF0cml4SGFsZlBpTG9jYXRpb24sXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBzaWdtYS51dGlscy5tYXRyaWNlcy5yb3RhdGlvbihNYXRoLlBJIC8gMiwgdHJ1ZSlcbiAgICAgICk7XG4gICAgICBnbC51bmlmb3JtTWF0cml4MmZ2KFxuICAgICAgICBtYXRyaXhIYWxmUGlNaW51c0xvY2F0aW9uLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgc2lnbWEudXRpbHMubWF0cmljZXMucm90YXRpb24oLU1hdGguUEkgLyAyLCB0cnVlKVxuICAgICAgKTtcblxuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoY29sb3JMb2NhdGlvbik7XG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShwb3NpdGlvbkxvY2F0aW9uMSk7XG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShwb3NpdGlvbkxvY2F0aW9uMik7XG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh0aGlja25lc3NMb2NhdGlvbik7XG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShtaW51c0xvY2F0aW9uKTtcblxuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihwb3NpdGlvbkxvY2F0aW9uMSxcbiAgICAgICAgMixcbiAgICAgICAgZ2wuRkxPQVQsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICB0aGlzLkFUVFJJQlVURVMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXG4gICAgICAgIDBcbiAgICAgICk7XG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHBvc2l0aW9uTG9jYXRpb24yLFxuICAgICAgICAyLFxuICAgICAgICBnbC5GTE9BVCxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHRoaXMuQVRUUklCVVRFUyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcbiAgICAgICAgOFxuICAgICAgKTtcbiAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodGhpY2tuZXNzTG9jYXRpb24sXG4gICAgICAgIDEsXG4gICAgICAgIGdsLkZMT0FULFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgdGhpcy5BVFRSSUJVVEVTICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxuICAgICAgICAxNlxuICAgICAgKTtcbiAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIobWludXNMb2NhdGlvbixcbiAgICAgICAgMSxcbiAgICAgICAgZ2wuRkxPQVQsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICB0aGlzLkFUVFJJQlVURVMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXG4gICAgICAgIDIwXG4gICAgICApO1xuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihjb2xvckxvY2F0aW9uLFxuICAgICAgICAxLFxuICAgICAgICBnbC5GTE9BVCxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHRoaXMuQVRUUklCVVRFUyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcbiAgICAgICAgMjRcbiAgICAgICk7XG5cbiAgICAgIGdsLmRyYXdBcnJheXMoXG4gICAgICAgIGdsLlRSSUFOR0xFUyxcbiAgICAgICAgcGFyYW1zLnN0YXJ0IHx8IDAsXG4gICAgICAgIHBhcmFtcy5jb3VudCB8fCAoZGF0YS5sZW5ndGggLyB0aGlzLkFUVFJJQlVURVMpXG4gICAgICApO1xuICAgIH0sXG4gICAgaW5pdFByb2dyYW06IGZ1bmN0aW9uKGdsKSB7XG4gICAgICB2YXIgdmVydGV4U2hhZGVyLFxuICAgICAgICAgIGZyYWdtZW50U2hhZGVyLFxuICAgICAgICAgIHByb2dyYW07XG5cbiAgICAgIHZlcnRleFNoYWRlciA9IHNpZ21hLnV0aWxzLmxvYWRTaGFkZXIoXG4gICAgICAgIGdsLFxuICAgICAgICBbXG4gICAgICAgICAgJ2F0dHJpYnV0ZSB2ZWMyIGFfcG9zaXRpb24xOycsXG4gICAgICAgICAgJ2F0dHJpYnV0ZSB2ZWMyIGFfcG9zaXRpb24yOycsXG4gICAgICAgICAgJ2F0dHJpYnV0ZSBmbG9hdCBhX3RoaWNrbmVzczsnLFxuICAgICAgICAgICdhdHRyaWJ1dGUgZmxvYXQgYV9taW51czsnLFxuICAgICAgICAgICdhdHRyaWJ1dGUgZmxvYXQgYV9jb2xvcjsnLFxuXG4gICAgICAgICAgJ3VuaWZvcm0gdmVjMiB1X3Jlc29sdXRpb247JyxcbiAgICAgICAgICAndW5pZm9ybSBmbG9hdCB1X3JhdGlvOycsXG4gICAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdV9zY2FsZTsnLFxuICAgICAgICAgICd1bmlmb3JtIG1hdDMgdV9tYXRyaXg7JyxcbiAgICAgICAgICAndW5pZm9ybSBtYXQyIHVfbWF0cml4SGFsZlBpOycsXG4gICAgICAgICAgJ3VuaWZvcm0gbWF0MiB1X21hdHJpeEhhbGZQaU1pbnVzOycsXG5cbiAgICAgICAgICAndmFyeWluZyB2ZWM0IGNvbG9yOycsXG5cbiAgICAgICAgICAndm9pZCBtYWluKCkgeycsXG4gICAgICAgICAgICAvLyBGaW5kIHRoZSBnb29kIHBvaW50OlxuICAgICAgICAgICAgJ3ZlYzIgcG9zaXRpb24gPSBhX3RoaWNrbmVzcyAqIHVfcmF0aW8gKicsXG4gICAgICAgICAgICAgICdub3JtYWxpemUoYV9wb3NpdGlvbjIgLSBhX3Bvc2l0aW9uMSk7JyxcblxuICAgICAgICAgICAgJ21hdDIgbWF0cml4ID0gYV9taW51cyAqIHVfbWF0cml4SGFsZlBpTWludXMgKycsXG4gICAgICAgICAgICAgICcoMS4wIC0gYV9taW51cykgKiB1X21hdHJpeEhhbGZQaTsnLFxuXG4gICAgICAgICAgICAncG9zaXRpb24gPSBtYXRyaXggKiBwb3NpdGlvbiArIGFfcG9zaXRpb24xOycsXG5cbiAgICAgICAgICAgIC8vIFNjYWxlIGZyb20gW1stMSAxXSBbLTEgMV1dIHRvIHRoZSBjb250YWluZXI6XG4gICAgICAgICAgICAnZ2xfUG9zaXRpb24gPSB2ZWM0KCcsXG4gICAgICAgICAgICAgICcoKHVfbWF0cml4ICogdmVjMyhwb3NpdGlvbiwgMSkpLnh5IC8nLFxuICAgICAgICAgICAgICAgICd1X3Jlc29sdXRpb24gKiAyLjAgLSAxLjApICogdmVjMigxLCAtMSksJyxcbiAgICAgICAgICAgICAgJzAsJyxcbiAgICAgICAgICAgICAgJzEnLFxuICAgICAgICAgICAgJyk7JyxcblxuICAgICAgICAgICAgLy8gRXh0cmFjdCB0aGUgY29sb3I6XG4gICAgICAgICAgICAnZmxvYXQgYyA9IGFfY29sb3I7JyxcbiAgICAgICAgICAgICdjb2xvci5iID0gbW9kKGMsIDI1Ni4wKTsgYyA9IGZsb29yKGMgLyAyNTYuMCk7JyxcbiAgICAgICAgICAgICdjb2xvci5nID0gbW9kKGMsIDI1Ni4wKTsgYyA9IGZsb29yKGMgLyAyNTYuMCk7JyxcbiAgICAgICAgICAgICdjb2xvci5yID0gbW9kKGMsIDI1Ni4wKTsgYyA9IGZsb29yKGMgLyAyNTYuMCk7IGNvbG9yIC89IDI1NS4wOycsXG4gICAgICAgICAgICAnY29sb3IuYSA9IDEuMDsnLFxuICAgICAgICAgICd9J1xuICAgICAgICBdLmpvaW4oJ1xcbicpLFxuICAgICAgICBnbC5WRVJURVhfU0hBREVSXG4gICAgICApO1xuXG4gICAgICBmcmFnbWVudFNoYWRlciA9IHNpZ21hLnV0aWxzLmxvYWRTaGFkZXIoXG4gICAgICAgIGdsLFxuICAgICAgICBbXG4gICAgICAgICAgJ3ByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OycsXG5cbiAgICAgICAgICAndmFyeWluZyB2ZWM0IGNvbG9yOycsXG5cbiAgICAgICAgICAndm9pZCBtYWluKHZvaWQpIHsnLFxuICAgICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yOycsXG4gICAgICAgICAgJ30nXG4gICAgICAgIF0uam9pbignXFxuJyksXG4gICAgICAgIGdsLkZSQUdNRU5UX1NIQURFUlxuICAgICAgKTtcblxuICAgICAgcHJvZ3JhbSA9IHNpZ21hLnV0aWxzLmxvYWRQcm9ncmFtKGdsLCBbdmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlcl0pO1xuXG4gICAgICByZXR1cm4gcHJvZ3JhbTtcbiAgICB9XG4gIH07XG59KSgpO1xuXG47KGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS53ZWJnbC5lZGdlcycpO1xuXG4gIC8qKlxuICAgKiBUaGlzIGVkZ2UgcmVuZGVyZXIgd2lsbCBkaXNwbGF5IGVkZ2VzIGFzIGxpbmVzIHdpdGggdGhlIGdsLkxJTkVTIGRpc3BsYXlcbiAgICogbW9kZS4gU2luY2UgdGhpcyBtb2RlIGRvZXMgbm90IHN1cHBvcnQgd2VsbCB0aGlja25lc3MsIGVkZ2VzIGFyZSBhbGwgZHJhd25cbiAgICogd2l0aCB0aGUgc2FtZSB0aGlja25lc3MgKDNweCksIGluZGVwZW5kYW50bHkgb2YgdGhlIGVkZ2UgYXR0cmlidXRlcyBvciB0aGVcbiAgICogem9vbWluZyByYXRpby5cbiAgICovXG4gIHNpZ21hLndlYmdsLmVkZ2VzLmZhc3QgPSB7XG4gICAgUE9JTlRTOiAyLFxuICAgIEFUVFJJQlVURVM6IDMsXG4gICAgYWRkRWRnZTogZnVuY3Rpb24oZWRnZSwgc291cmNlLCB0YXJnZXQsIGRhdGEsIGksIHByZWZpeCwgc2V0dGluZ3MpIHtcbiAgICAgIHZhciB3ID0gKGVkZ2VbcHJlZml4ICsgJ3NpemUnXSB8fCAxKSAvIDIsXG4gICAgICAgICAgeDEgPSBzb3VyY2VbcHJlZml4ICsgJ3gnXSxcbiAgICAgICAgICB5MSA9IHNvdXJjZVtwcmVmaXggKyAneSddLFxuICAgICAgICAgIHgyID0gdGFyZ2V0W3ByZWZpeCArICd4J10sXG4gICAgICAgICAgeTIgPSB0YXJnZXRbcHJlZml4ICsgJ3knXSxcbiAgICAgICAgICBjb2xvciA9IGVkZ2UuY29sb3I7XG5cbiAgICAgIGlmICghY29sb3IpXG4gICAgICAgIHN3aXRjaCAoc2V0dGluZ3MoJ2VkZ2VDb2xvcicpKSB7XG4gICAgICAgICAgY2FzZSAnc291cmNlJzpcbiAgICAgICAgICAgIGNvbG9yID0gc291cmNlLmNvbG9yIHx8IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICd0YXJnZXQnOlxuICAgICAgICAgICAgY29sb3IgPSB0YXJnZXQuY29sb3IgfHwgc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjb2xvciA9IHNldHRpbmdzKCdkZWZhdWx0RWRnZUNvbG9yJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAvLyBOb3JtYWxpemUgY29sb3I6XG4gICAgICBjb2xvciA9IHNpZ21hLnV0aWxzLmZsb2F0Q29sb3IoY29sb3IpO1xuXG4gICAgICBkYXRhW2krK10gPSB4MTtcbiAgICAgIGRhdGFbaSsrXSA9IHkxO1xuICAgICAgZGF0YVtpKytdID0gY29sb3I7XG5cbiAgICAgIGRhdGFbaSsrXSA9IHgyO1xuICAgICAgZGF0YVtpKytdID0geTI7XG4gICAgICBkYXRhW2krK10gPSBjb2xvcjtcbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24oZ2wsIHByb2dyYW0sIGRhdGEsIHBhcmFtcykge1xuICAgICAgdmFyIGJ1ZmZlcjtcblxuICAgICAgLy8gRGVmaW5lIGF0dHJpYnV0ZXM6XG4gICAgICB2YXIgY29sb3JMb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV9jb2xvcicpLFxuICAgICAgICAgIHBvc2l0aW9uTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FfcG9zaXRpb24nKSxcbiAgICAgICAgICByZXNvbHV0aW9uTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X3Jlc29sdXRpb24nKSxcbiAgICAgICAgICBtYXRyaXhMb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfbWF0cml4Jyk7XG5cbiAgICAgIGJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7XG4gICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgZGF0YSwgZ2wuRFlOQU1JQ19EUkFXKTtcblxuICAgICAgZ2wudW5pZm9ybTJmKHJlc29sdXRpb25Mb2NhdGlvbiwgcGFyYW1zLndpZHRoLCBwYXJhbXMuaGVpZ2h0KTtcbiAgICAgIGdsLnVuaWZvcm1NYXRyaXgzZnYobWF0cml4TG9jYXRpb24sIGZhbHNlLCBwYXJhbXMubWF0cml4KTtcblxuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkocG9zaXRpb25Mb2NhdGlvbik7XG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShjb2xvckxvY2F0aW9uKTtcblxuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihwb3NpdGlvbkxvY2F0aW9uLFxuICAgICAgICAyLFxuICAgICAgICBnbC5GTE9BVCxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHRoaXMuQVRUUklCVVRFUyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcbiAgICAgICAgMFxuICAgICAgKTtcbiAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoY29sb3JMb2NhdGlvbixcbiAgICAgICAgMSxcbiAgICAgICAgZ2wuRkxPQVQsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICB0aGlzLkFUVFJJQlVURVMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXG4gICAgICAgIDhcbiAgICAgICk7XG5cbiAgICAgIGdsLmxpbmVXaWR0aCgzKTtcbiAgICAgIGdsLmRyYXdBcnJheXMoXG4gICAgICAgIGdsLkxJTkVTLFxuICAgICAgICBwYXJhbXMuc3RhcnQgfHwgMCxcbiAgICAgICAgcGFyYW1zLmNvdW50IHx8IChkYXRhLmxlbmd0aCAvIHRoaXMuQVRUUklCVVRFUylcbiAgICAgICk7XG4gICAgfSxcbiAgICBpbml0UHJvZ3JhbTogZnVuY3Rpb24oZ2wpIHtcbiAgICAgIHZhciB2ZXJ0ZXhTaGFkZXIsXG4gICAgICAgICAgZnJhZ21lbnRTaGFkZXIsXG4gICAgICAgICAgcHJvZ3JhbTtcblxuICAgICAgdmVydGV4U2hhZGVyID0gc2lnbWEudXRpbHMubG9hZFNoYWRlcihcbiAgICAgICAgZ2wsXG4gICAgICAgIFtcbiAgICAgICAgICAnYXR0cmlidXRlIHZlYzIgYV9wb3NpdGlvbjsnLFxuICAgICAgICAgICdhdHRyaWJ1dGUgZmxvYXQgYV9jb2xvcjsnLFxuXG4gICAgICAgICAgJ3VuaWZvcm0gdmVjMiB1X3Jlc29sdXRpb247JyxcbiAgICAgICAgICAndW5pZm9ybSBtYXQzIHVfbWF0cml4OycsXG5cbiAgICAgICAgICAndmFyeWluZyB2ZWM0IGNvbG9yOycsXG5cbiAgICAgICAgICAndm9pZCBtYWluKCkgeycsXG4gICAgICAgICAgICAvLyBTY2FsZSBmcm9tIFtbLTEgMV0gWy0xIDFdXSB0byB0aGUgY29udGFpbmVyOlxuICAgICAgICAgICAgJ2dsX1Bvc2l0aW9uID0gdmVjNCgnLFxuICAgICAgICAgICAgICAnKCh1X21hdHJpeCAqIHZlYzMoYV9wb3NpdGlvbiwgMSkpLnh5IC8nLFxuICAgICAgICAgICAgICAgICd1X3Jlc29sdXRpb24gKiAyLjAgLSAxLjApICogdmVjMigxLCAtMSksJyxcbiAgICAgICAgICAgICAgJzAsJyxcbiAgICAgICAgICAgICAgJzEnLFxuICAgICAgICAgICAgJyk7JyxcblxuICAgICAgICAgICAgLy8gRXh0cmFjdCB0aGUgY29sb3I6XG4gICAgICAgICAgICAnZmxvYXQgYyA9IGFfY29sb3I7JyxcbiAgICAgICAgICAgICdjb2xvci5iID0gbW9kKGMsIDI1Ni4wKTsgYyA9IGZsb29yKGMgLyAyNTYuMCk7JyxcbiAgICAgICAgICAgICdjb2xvci5nID0gbW9kKGMsIDI1Ni4wKTsgYyA9IGZsb29yKGMgLyAyNTYuMCk7JyxcbiAgICAgICAgICAgICdjb2xvci5yID0gbW9kKGMsIDI1Ni4wKTsgYyA9IGZsb29yKGMgLyAyNTYuMCk7IGNvbG9yIC89IDI1NS4wOycsXG4gICAgICAgICAgICAnY29sb3IuYSA9IDEuMDsnLFxuICAgICAgICAgICd9J1xuICAgICAgICBdLmpvaW4oJ1xcbicpLFxuICAgICAgICBnbC5WRVJURVhfU0hBREVSXG4gICAgICApO1xuXG4gICAgICBmcmFnbWVudFNoYWRlciA9IHNpZ21hLnV0aWxzLmxvYWRTaGFkZXIoXG4gICAgICAgIGdsLFxuICAgICAgICBbXG4gICAgICAgICAgJ3ByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OycsXG5cbiAgICAgICAgICAndmFyeWluZyB2ZWM0IGNvbG9yOycsXG5cbiAgICAgICAgICAndm9pZCBtYWluKHZvaWQpIHsnLFxuICAgICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yOycsXG4gICAgICAgICAgJ30nXG4gICAgICAgIF0uam9pbignXFxuJyksXG4gICAgICAgIGdsLkZSQUdNRU5UX1NIQURFUlxuICAgICAgKTtcblxuICAgICAgcHJvZ3JhbSA9IHNpZ21hLnV0aWxzLmxvYWRQcm9ncmFtKGdsLCBbdmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlcl0pO1xuXG4gICAgICByZXR1cm4gcHJvZ3JhbTtcbiAgICB9XG4gIH07XG59KSgpO1xuXG47KGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS53ZWJnbC5lZGdlcycpO1xuXG4gIC8qKlxuICAgKiBUaGlzIGVkZ2UgcmVuZGVyZXIgd2lsbCBkaXNwbGF5IGVkZ2VzIGFzIGFycm93cyBnb2luZyBmcm9tIHRoZSBzb3VyY2Ugbm9kZVxuICAgKiB0byB0aGUgdGFyZ2V0IG5vZGUuIFRvIGRlYWwgd2l0aCBlZGdlIHRoaWNrbmVzc2VzLCB0aGUgbGluZXMgYXJlIG1hZGUgb2ZcbiAgICogdGhyZWUgdHJpYW5nbGVzOiB0d28gZm9ybWluZyByZWN0YW5nbGVzLCB3aXRoIHRoZSBnbC5UUklBTkdMRVMgZHJhd2luZ1xuICAgKiBtb2RlLlxuICAgKlxuICAgKiBJdCBpcyBleHBlbnNpdmUsIHNpbmNlIGRyYXdpbmcgYSBzaW5nbGUgZWRnZSByZXF1aXJlcyA5IHBvaW50cywgZWFjaFxuICAgKiBoYXZpbmcgYSBsb3Qgb2YgYXR0cmlidXRlcy5cbiAgICovXG4gIHNpZ21hLndlYmdsLmVkZ2VzLmFycm93ID0ge1xuICAgIFBPSU5UUzogOSxcbiAgICBBVFRSSUJVVEVTOiAxMSxcbiAgICBhZGRFZGdlOiBmdW5jdGlvbihlZGdlLCBzb3VyY2UsIHRhcmdldCwgZGF0YSwgaSwgcHJlZml4LCBzZXR0aW5ncykge1xuICAgICAgdmFyIHcgPSAoZWRnZVtwcmVmaXggKyAnc2l6ZSddIHx8IDEpIC8gMixcbiAgICAgICAgICB4MSA9IHNvdXJjZVtwcmVmaXggKyAneCddLFxuICAgICAgICAgIHkxID0gc291cmNlW3ByZWZpeCArICd5J10sXG4gICAgICAgICAgeDIgPSB0YXJnZXRbcHJlZml4ICsgJ3gnXSxcbiAgICAgICAgICB5MiA9IHRhcmdldFtwcmVmaXggKyAneSddLFxuICAgICAgICAgIHRhcmdldFNpemUgPSB0YXJnZXRbcHJlZml4ICsgJ3NpemUnXSxcbiAgICAgICAgICBjb2xvciA9IGVkZ2UuY29sb3I7XG5cbiAgICAgIGlmICghY29sb3IpXG4gICAgICAgIHN3aXRjaCAoc2V0dGluZ3MoJ2VkZ2VDb2xvcicpKSB7XG4gICAgICAgICAgY2FzZSAnc291cmNlJzpcbiAgICAgICAgICAgIGNvbG9yID0gc291cmNlLmNvbG9yIHx8IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICd0YXJnZXQnOlxuICAgICAgICAgICAgY29sb3IgPSB0YXJnZXQuY29sb3IgfHwgc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjb2xvciA9IHNldHRpbmdzKCdkZWZhdWx0RWRnZUNvbG9yJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAvLyBOb3JtYWxpemUgY29sb3I6XG4gICAgICBjb2xvciA9IHNpZ21hLnV0aWxzLmZsb2F0Q29sb3IoY29sb3IpO1xuXG4gICAgICBkYXRhW2krK10gPSB4MTtcbiAgICAgIGRhdGFbaSsrXSA9IHkxO1xuICAgICAgZGF0YVtpKytdID0geDI7XG4gICAgICBkYXRhW2krK10gPSB5MjtcbiAgICAgIGRhdGFbaSsrXSA9IHc7XG4gICAgICBkYXRhW2krK10gPSB0YXJnZXRTaXplO1xuICAgICAgZGF0YVtpKytdID0gMC4wO1xuICAgICAgZGF0YVtpKytdID0gMC4wO1xuICAgICAgZGF0YVtpKytdID0gMC4wO1xuICAgICAgZGF0YVtpKytdID0gMC4wO1xuICAgICAgZGF0YVtpKytdID0gY29sb3I7XG5cbiAgICAgIGRhdGFbaSsrXSA9IHgyO1xuICAgICAgZGF0YVtpKytdID0geTI7XG4gICAgICBkYXRhW2krK10gPSB4MTtcbiAgICAgIGRhdGFbaSsrXSA9IHkxO1xuICAgICAgZGF0YVtpKytdID0gdztcbiAgICAgIGRhdGFbaSsrXSA9IHRhcmdldFNpemU7XG4gICAgICBkYXRhW2krK10gPSAxLjA7XG4gICAgICBkYXRhW2krK10gPSAxLjA7XG4gICAgICBkYXRhW2krK10gPSAwLjA7XG4gICAgICBkYXRhW2krK10gPSAwLjA7XG4gICAgICBkYXRhW2krK10gPSBjb2xvcjtcblxuICAgICAgZGF0YVtpKytdID0geDI7XG4gICAgICBkYXRhW2krK10gPSB5MjtcbiAgICAgIGRhdGFbaSsrXSA9IHgxO1xuICAgICAgZGF0YVtpKytdID0geTE7XG4gICAgICBkYXRhW2krK10gPSB3O1xuICAgICAgZGF0YVtpKytdID0gdGFyZ2V0U2l6ZTtcbiAgICAgIGRhdGFbaSsrXSA9IDEuMDtcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcbiAgICAgIGRhdGFbaSsrXSA9IGNvbG9yO1xuXG4gICAgICBkYXRhW2krK10gPSB4MjtcbiAgICAgIGRhdGFbaSsrXSA9IHkyO1xuICAgICAgZGF0YVtpKytdID0geDE7XG4gICAgICBkYXRhW2krK10gPSB5MTtcbiAgICAgIGRhdGFbaSsrXSA9IHc7XG4gICAgICBkYXRhW2krK10gPSB0YXJnZXRTaXplO1xuICAgICAgZGF0YVtpKytdID0gMS4wO1xuICAgICAgZGF0YVtpKytdID0gMC4wO1xuICAgICAgZGF0YVtpKytdID0gMC4wO1xuICAgICAgZGF0YVtpKytdID0gMC4wO1xuICAgICAgZGF0YVtpKytdID0gY29sb3I7XG5cbiAgICAgIGRhdGFbaSsrXSA9IHgxO1xuICAgICAgZGF0YVtpKytdID0geTE7XG4gICAgICBkYXRhW2krK10gPSB4MjtcbiAgICAgIGRhdGFbaSsrXSA9IHkyO1xuICAgICAgZGF0YVtpKytdID0gdztcbiAgICAgIGRhdGFbaSsrXSA9IHRhcmdldFNpemU7XG4gICAgICBkYXRhW2krK10gPSAwLjA7XG4gICAgICBkYXRhW2krK10gPSAxLjA7XG4gICAgICBkYXRhW2krK10gPSAwLjA7XG4gICAgICBkYXRhW2krK10gPSAwLjA7XG4gICAgICBkYXRhW2krK10gPSBjb2xvcjtcblxuICAgICAgZGF0YVtpKytdID0geDE7XG4gICAgICBkYXRhW2krK10gPSB5MTtcbiAgICAgIGRhdGFbaSsrXSA9IHgyO1xuICAgICAgZGF0YVtpKytdID0geTI7XG4gICAgICBkYXRhW2krK10gPSB3O1xuICAgICAgZGF0YVtpKytdID0gdGFyZ2V0U2l6ZTtcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcbiAgICAgIGRhdGFbaSsrXSA9IGNvbG9yO1xuXG4gICAgICAvLyBBcnJvdyBoZWFkOlxuICAgICAgZGF0YVtpKytdID0geDI7XG4gICAgICBkYXRhW2krK10gPSB5MjtcbiAgICAgIGRhdGFbaSsrXSA9IHgxO1xuICAgICAgZGF0YVtpKytdID0geTE7XG4gICAgICBkYXRhW2krK10gPSB3O1xuICAgICAgZGF0YVtpKytdID0gdGFyZ2V0U2l6ZTtcbiAgICAgIGRhdGFbaSsrXSA9IDEuMDtcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcbiAgICAgIGRhdGFbaSsrXSA9IDEuMDtcbiAgICAgIGRhdGFbaSsrXSA9IC0xLjA7XG4gICAgICBkYXRhW2krK10gPSBjb2xvcjtcblxuICAgICAgZGF0YVtpKytdID0geDI7XG4gICAgICBkYXRhW2krK10gPSB5MjtcbiAgICAgIGRhdGFbaSsrXSA9IHgxO1xuICAgICAgZGF0YVtpKytdID0geTE7XG4gICAgICBkYXRhW2krK10gPSB3O1xuICAgICAgZGF0YVtpKytdID0gdGFyZ2V0U2l6ZTtcbiAgICAgIGRhdGFbaSsrXSA9IDEuMDtcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcbiAgICAgIGRhdGFbaSsrXSA9IDEuMDtcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcbiAgICAgIGRhdGFbaSsrXSA9IGNvbG9yO1xuXG4gICAgICBkYXRhW2krK10gPSB4MjtcbiAgICAgIGRhdGFbaSsrXSA9IHkyO1xuICAgICAgZGF0YVtpKytdID0geDE7XG4gICAgICBkYXRhW2krK10gPSB5MTtcbiAgICAgIGRhdGFbaSsrXSA9IHc7XG4gICAgICBkYXRhW2krK10gPSB0YXJnZXRTaXplO1xuICAgICAgZGF0YVtpKytdID0gMS4wO1xuICAgICAgZGF0YVtpKytdID0gMC4wO1xuICAgICAgZGF0YVtpKytdID0gMS4wO1xuICAgICAgZGF0YVtpKytdID0gMS4wO1xuICAgICAgZGF0YVtpKytdID0gY29sb3I7XG4gICAgfSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uKGdsLCBwcm9ncmFtLCBkYXRhLCBwYXJhbXMpIHtcbiAgICAgIHZhciBidWZmZXI7XG5cbiAgICAgIC8vIERlZmluZSBhdHRyaWJ1dGVzOlxuICAgICAgdmFyIHBvc2l0aW9uTG9jYXRpb24xID1cbiAgICAgICAgICAgIGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhX3BvczEnKSxcbiAgICAgICAgICBwb3NpdGlvbkxvY2F0aW9uMiA9XG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV9wb3MyJyksXG4gICAgICAgICAgdGhpY2tuZXNzTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FfdGhpY2tuZXNzJyksXG4gICAgICAgICAgdGFyZ2V0U2l6ZUxvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhX3RTaXplJyksXG4gICAgICAgICAgZGVsYXlMb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV9kZWxheScpLFxuICAgICAgICAgIG1pbnVzTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FfbWludXMnKSxcbiAgICAgICAgICBoZWFkTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FfaGVhZCcpLFxuICAgICAgICAgIGhlYWRQb3NpdGlvbkxvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhX2hlYWRQb3NpdGlvbicpLFxuICAgICAgICAgIGNvbG9yTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FfY29sb3InKSxcbiAgICAgICAgICByZXNvbHV0aW9uTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X3Jlc29sdXRpb24nKSxcbiAgICAgICAgICBtYXRyaXhMb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfbWF0cml4JyksXG4gICAgICAgICAgbWF0cml4SGFsZlBpTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X21hdHJpeEhhbGZQaScpLFxuICAgICAgICAgIG1hdHJpeEhhbGZQaU1pbnVzTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X21hdHJpeEhhbGZQaU1pbnVzJyksXG4gICAgICAgICAgcmF0aW9Mb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfcmF0aW8nKSxcbiAgICAgICAgICBub2RlUmF0aW9Mb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3Vfbm9kZVJhdGlvJyksXG4gICAgICAgICAgYXJyb3dIZWFkTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X2Fycm93SGVhZCcpLFxuICAgICAgICAgIHNjYWxlTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X3NjYWxlJyk7XG5cbiAgICAgIGJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7XG4gICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgZGF0YSwgZ2wuU1RBVElDX0RSQVcpO1xuXG4gICAgICBnbC51bmlmb3JtMmYocmVzb2x1dGlvbkxvY2F0aW9uLCBwYXJhbXMud2lkdGgsIHBhcmFtcy5oZWlnaHQpO1xuICAgICAgZ2wudW5pZm9ybTFmKFxuICAgICAgICByYXRpb0xvY2F0aW9uLFxuICAgICAgICBwYXJhbXMucmF0aW8gLyBNYXRoLnBvdyhwYXJhbXMucmF0aW8sIHBhcmFtcy5zZXR0aW5ncygnZWRnZXNQb3dSYXRpbycpKVxuICAgICAgKTtcbiAgICAgIGdsLnVuaWZvcm0xZihcbiAgICAgICAgbm9kZVJhdGlvTG9jYXRpb24sXG4gICAgICAgIE1hdGgucG93KHBhcmFtcy5yYXRpbywgcGFyYW1zLnNldHRpbmdzKCdub2Rlc1Bvd1JhdGlvJykpIC9cbiAgICAgICAgcGFyYW1zLnJhdGlvXG4gICAgICApO1xuICAgICAgZ2wudW5pZm9ybTFmKGFycm93SGVhZExvY2F0aW9uLCA1LjApO1xuICAgICAgZ2wudW5pZm9ybTFmKHNjYWxlTG9jYXRpb24sIHBhcmFtcy5zY2FsaW5nUmF0aW8pO1xuICAgICAgZ2wudW5pZm9ybU1hdHJpeDNmdihtYXRyaXhMb2NhdGlvbiwgZmFsc2UsIHBhcmFtcy5tYXRyaXgpO1xuICAgICAgZ2wudW5pZm9ybU1hdHJpeDJmdihcbiAgICAgICAgbWF0cml4SGFsZlBpTG9jYXRpb24sXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBzaWdtYS51dGlscy5tYXRyaWNlcy5yb3RhdGlvbihNYXRoLlBJIC8gMiwgdHJ1ZSlcbiAgICAgICk7XG4gICAgICBnbC51bmlmb3JtTWF0cml4MmZ2KFxuICAgICAgICBtYXRyaXhIYWxmUGlNaW51c0xvY2F0aW9uLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgc2lnbWEudXRpbHMubWF0cmljZXMucm90YXRpb24oLU1hdGguUEkgLyAyLCB0cnVlKVxuICAgICAgKTtcblxuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkocG9zaXRpb25Mb2NhdGlvbjEpO1xuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkocG9zaXRpb25Mb2NhdGlvbjIpO1xuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodGhpY2tuZXNzTG9jYXRpb24pO1xuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodGFyZ2V0U2l6ZUxvY2F0aW9uKTtcbiAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGRlbGF5TG9jYXRpb24pO1xuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkobWludXNMb2NhdGlvbik7XG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShoZWFkTG9jYXRpb24pO1xuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoaGVhZFBvc2l0aW9uTG9jYXRpb24pO1xuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoY29sb3JMb2NhdGlvbik7XG5cbiAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIocG9zaXRpb25Mb2NhdGlvbjEsXG4gICAgICAgIDIsXG4gICAgICAgIGdsLkZMT0FULFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgdGhpcy5BVFRSSUJVVEVTICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxuICAgICAgICAwXG4gICAgICApO1xuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihwb3NpdGlvbkxvY2F0aW9uMixcbiAgICAgICAgMixcbiAgICAgICAgZ2wuRkxPQVQsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICB0aGlzLkFUVFJJQlVURVMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXG4gICAgICAgIDhcbiAgICAgICk7XG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaWNrbmVzc0xvY2F0aW9uLFxuICAgICAgICAxLFxuICAgICAgICBnbC5GTE9BVCxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHRoaXMuQVRUUklCVVRFUyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcbiAgICAgICAgMTZcbiAgICAgICk7XG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRhcmdldFNpemVMb2NhdGlvbixcbiAgICAgICAgMSxcbiAgICAgICAgZ2wuRkxPQVQsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICB0aGlzLkFUVFJJQlVURVMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXG4gICAgICAgIDIwXG4gICAgICApO1xuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihkZWxheUxvY2F0aW9uLFxuICAgICAgICAxLFxuICAgICAgICBnbC5GTE9BVCxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHRoaXMuQVRUUklCVVRFUyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcbiAgICAgICAgMjRcbiAgICAgICk7XG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKG1pbnVzTG9jYXRpb24sXG4gICAgICAgIDEsXG4gICAgICAgIGdsLkZMT0FULFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgdGhpcy5BVFRSSUJVVEVTICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxuICAgICAgICAyOFxuICAgICAgKTtcbiAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoaGVhZExvY2F0aW9uLFxuICAgICAgICAxLFxuICAgICAgICBnbC5GTE9BVCxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHRoaXMuQVRUUklCVVRFUyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcbiAgICAgICAgMzJcbiAgICAgICk7XG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGhlYWRQb3NpdGlvbkxvY2F0aW9uLFxuICAgICAgICAxLFxuICAgICAgICBnbC5GTE9BVCxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHRoaXMuQVRUUklCVVRFUyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcbiAgICAgICAgMzZcbiAgICAgICk7XG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGNvbG9yTG9jYXRpb24sXG4gICAgICAgIDEsXG4gICAgICAgIGdsLkZMT0FULFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgdGhpcy5BVFRSSUJVVEVTICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxuICAgICAgICA0MFxuICAgICAgKTtcblxuICAgICAgZ2wuZHJhd0FycmF5cyhcbiAgICAgICAgZ2wuVFJJQU5HTEVTLFxuICAgICAgICBwYXJhbXMuc3RhcnQgfHwgMCxcbiAgICAgICAgcGFyYW1zLmNvdW50IHx8IChkYXRhLmxlbmd0aCAvIHRoaXMuQVRUUklCVVRFUylcbiAgICAgICk7XG4gICAgfSxcbiAgICBpbml0UHJvZ3JhbTogZnVuY3Rpb24oZ2wpIHtcbiAgICAgIHZhciB2ZXJ0ZXhTaGFkZXIsXG4gICAgICAgICAgZnJhZ21lbnRTaGFkZXIsXG4gICAgICAgICAgcHJvZ3JhbTtcblxuICAgICAgdmVydGV4U2hhZGVyID0gc2lnbWEudXRpbHMubG9hZFNoYWRlcihcbiAgICAgICAgZ2wsXG4gICAgICAgIFtcbiAgICAgICAgICAnYXR0cmlidXRlIHZlYzIgYV9wb3MxOycsXG4gICAgICAgICAgJ2F0dHJpYnV0ZSB2ZWMyIGFfcG9zMjsnLFxuICAgICAgICAgICdhdHRyaWJ1dGUgZmxvYXQgYV90aGlja25lc3M7JyxcbiAgICAgICAgICAnYXR0cmlidXRlIGZsb2F0IGFfdFNpemU7JyxcbiAgICAgICAgICAnYXR0cmlidXRlIGZsb2F0IGFfZGVsYXk7JyxcbiAgICAgICAgICAnYXR0cmlidXRlIGZsb2F0IGFfbWludXM7JyxcbiAgICAgICAgICAnYXR0cmlidXRlIGZsb2F0IGFfaGVhZDsnLFxuICAgICAgICAgICdhdHRyaWJ1dGUgZmxvYXQgYV9oZWFkUG9zaXRpb247JyxcbiAgICAgICAgICAnYXR0cmlidXRlIGZsb2F0IGFfY29sb3I7JyxcblxuICAgICAgICAgICd1bmlmb3JtIHZlYzIgdV9yZXNvbHV0aW9uOycsXG4gICAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdV9yYXRpbzsnLFxuICAgICAgICAgICd1bmlmb3JtIGZsb2F0IHVfbm9kZVJhdGlvOycsXG4gICAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdV9hcnJvd0hlYWQ7JyxcbiAgICAgICAgICAndW5pZm9ybSBmbG9hdCB1X3NjYWxlOycsXG4gICAgICAgICAgJ3VuaWZvcm0gbWF0MyB1X21hdHJpeDsnLFxuICAgICAgICAgICd1bmlmb3JtIG1hdDIgdV9tYXRyaXhIYWxmUGk7JyxcbiAgICAgICAgICAndW5pZm9ybSBtYXQyIHVfbWF0cml4SGFsZlBpTWludXM7JyxcblxuICAgICAgICAgICd2YXJ5aW5nIHZlYzQgY29sb3I7JyxcblxuICAgICAgICAgICd2b2lkIG1haW4oKSB7JyxcbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIGdvb2QgcG9pbnQ6XG4gICAgICAgICAgICAndmVjMiBwb3MgPSBub3JtYWxpemUoYV9wb3MyIC0gYV9wb3MxKTsnLFxuXG4gICAgICAgICAgICAnbWF0MiBtYXRyaXggPSAoMS4wIC0gYV9oZWFkKSAqJyxcbiAgICAgICAgICAgICAgJygnLFxuICAgICAgICAgICAgICAgICdhX21pbnVzICogdV9tYXRyaXhIYWxmUGlNaW51cyArJyxcbiAgICAgICAgICAgICAgICAnKDEuMCAtIGFfbWludXMpICogdV9tYXRyaXhIYWxmUGknLFxuICAgICAgICAgICAgICAnKSArIGFfaGVhZCAqICgnLFxuICAgICAgICAgICAgICAgICdhX2hlYWRQb3NpdGlvbiAqIHVfbWF0cml4SGFsZlBpTWludXMgKiAwLjYgKycsXG4gICAgICAgICAgICAgICAgJyhhX2hlYWRQb3NpdGlvbiAqIGFfaGVhZFBvc2l0aW9uIC0gMS4wKSAqIG1hdDIoMS4wKScsXG4gICAgICAgICAgICAgICcpOycsXG5cbiAgICAgICAgICAgICdwb3MgPSBhX3BvczEgKyAoJyxcbiAgICAgICAgICAgICAgLy8gRGVhbCB3aXRoIGJvZHk6XG4gICAgICAgICAgICAgICcoMS4wIC0gYV9oZWFkKSAqIGFfdGhpY2tuZXNzICogdV9yYXRpbyAqIG1hdHJpeCAqIHBvcyArJyxcbiAgICAgICAgICAgICAgLy8gRGVhbCB3aXRoIGhlYWQ6XG4gICAgICAgICAgICAgICdhX2hlYWQgKiB1X2Fycm93SGVhZCAqIGFfdGhpY2tuZXNzICogdV9yYXRpbyAqIG1hdHJpeCAqIHBvcyArJyxcbiAgICAgICAgICAgICAgLy8gRGVhbCB3aXRoIGRlbGF5OlxuICAgICAgICAgICAgICAnYV9kZWxheSAqIHBvcyAqICgnLFxuICAgICAgICAgICAgICAgICdhX3RTaXplIC8gdV9ub2RlUmF0aW8gKycsXG4gICAgICAgICAgICAgICAgJ3VfYXJyb3dIZWFkICogYV90aGlja25lc3MgKiB1X3JhdGlvJyxcbiAgICAgICAgICAgICAgJyknLFxuICAgICAgICAgICAgJyk7JyxcblxuICAgICAgICAgICAgLy8gU2NhbGUgZnJvbSBbWy0xIDFdIFstMSAxXV0gdG8gdGhlIGNvbnRhaW5lcjpcbiAgICAgICAgICAgICdnbF9Qb3NpdGlvbiA9IHZlYzQoJyxcbiAgICAgICAgICAgICAgJygodV9tYXRyaXggKiB2ZWMzKHBvcywgMSkpLnh5IC8nLFxuICAgICAgICAgICAgICAgICd1X3Jlc29sdXRpb24gKiAyLjAgLSAxLjApICogdmVjMigxLCAtMSksJyxcbiAgICAgICAgICAgICAgJzAsJyxcbiAgICAgICAgICAgICAgJzEnLFxuICAgICAgICAgICAgJyk7JyxcblxuICAgICAgICAgICAgLy8gRXh0cmFjdCB0aGUgY29sb3I6XG4gICAgICAgICAgICAnZmxvYXQgYyA9IGFfY29sb3I7JyxcbiAgICAgICAgICAgICdjb2xvci5iID0gbW9kKGMsIDI1Ni4wKTsgYyA9IGZsb29yKGMgLyAyNTYuMCk7JyxcbiAgICAgICAgICAgICdjb2xvci5nID0gbW9kKGMsIDI1Ni4wKTsgYyA9IGZsb29yKGMgLyAyNTYuMCk7JyxcbiAgICAgICAgICAgICdjb2xvci5yID0gbW9kKGMsIDI1Ni4wKTsgYyA9IGZsb29yKGMgLyAyNTYuMCk7IGNvbG9yIC89IDI1NS4wOycsXG4gICAgICAgICAgICAnY29sb3IuYSA9IDEuMDsnLFxuICAgICAgICAgICd9J1xuICAgICAgICBdLmpvaW4oJ1xcbicpLFxuICAgICAgICBnbC5WRVJURVhfU0hBREVSXG4gICAgICApO1xuXG4gICAgICBmcmFnbWVudFNoYWRlciA9IHNpZ21hLnV0aWxzLmxvYWRTaGFkZXIoXG4gICAgICAgIGdsLFxuICAgICAgICBbXG4gICAgICAgICAgJ3ByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OycsXG5cbiAgICAgICAgICAndmFyeWluZyB2ZWM0IGNvbG9yOycsXG5cbiAgICAgICAgICAndm9pZCBtYWluKHZvaWQpIHsnLFxuICAgICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yOycsXG4gICAgICAgICAgJ30nXG4gICAgICAgIF0uam9pbignXFxuJyksXG4gICAgICAgIGdsLkZSQUdNRU5UX1NIQURFUlxuICAgICAgKTtcblxuICAgICAgcHJvZ3JhbSA9IHNpZ21hLnV0aWxzLmxvYWRQcm9ncmFtKGdsLCBbdmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlcl0pO1xuXG4gICAgICByZXR1cm4gcHJvZ3JhbTtcbiAgICB9XG4gIH07XG59KSgpO1xuXG47KGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgaWYgKHR5cGVvZiBzaWdtYSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgdGhyb3cgJ3NpZ21hIGlzIG5vdCBkZWNsYXJlZCc7XG5cbiAgLy8gSW5pdGlhbGl6ZSBwYWNrYWdlczpcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5jYW52YXMubGFiZWxzJyk7XG5cbiAgLyoqXG4gICAqIFRoaXMgbGFiZWwgcmVuZGVyZXIgd2lsbCBqdXN0IGRpc3BsYXkgdGhlIGxhYmVsIG9uIHRoZSByaWdodCBvZiB0aGUgbm9kZS5cbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBub2RlICAgICBUaGUgbm9kZSBvYmplY3QuXG4gICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCAgVGhlIGNhbnZhcyBjb250ZXh0LlxuICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9ICAgICAgICAgICAgIHNldHRpbmdzIFRoZSBzZXR0aW5ncyBmdW5jdGlvbi5cbiAgICovXG4gIHNpZ21hLmNhbnZhcy5sYWJlbHMuZGVmID0gZnVuY3Rpb24obm9kZSwgY29udGV4dCwgc2V0dGluZ3MpIHtcbiAgICB2YXIgZm9udFNpemUsXG4gICAgICAgIHByZWZpeCA9IHNldHRpbmdzKCdwcmVmaXgnKSB8fCAnJyxcbiAgICAgICAgc2l6ZSA9IG5vZGVbcHJlZml4ICsgJ3NpemUnXTtcblxuICAgIGlmIChzaXplIDwgc2V0dGluZ3MoJ2xhYmVsVGhyZXNob2xkJykpXG4gICAgICByZXR1cm47XG5cbiAgICBpZiAoIW5vZGUubGFiZWwgfHwgdHlwZW9mIG5vZGUubGFiZWwgIT09ICdzdHJpbmcnKVxuICAgICAgcmV0dXJuO1xuXG4gICAgZm9udFNpemUgPSAoc2V0dGluZ3MoJ2xhYmVsU2l6ZScpID09PSAnZml4ZWQnKSA/XG4gICAgICBzZXR0aW5ncygnZGVmYXVsdExhYmVsU2l6ZScpIDpcbiAgICAgIHNldHRpbmdzKCdsYWJlbFNpemVSYXRpbycpICogc2l6ZTtcblxuICAgIGNvbnRleHQuZm9udCA9IChzZXR0aW5ncygnZm9udFN0eWxlJykgPyBzZXR0aW5ncygnZm9udFN0eWxlJykgKyAnICcgOiAnJykgK1xuICAgICAgZm9udFNpemUgKyAncHggJyArIHNldHRpbmdzKCdmb250Jyk7XG4gICAgY29udGV4dC5maWxsU3R5bGUgPSAoc2V0dGluZ3MoJ2xhYmVsQ29sb3InKSA9PT0gJ25vZGUnKSA/XG4gICAgICAobm9kZS5jb2xvciB8fCBzZXR0aW5ncygnZGVmYXVsdE5vZGVDb2xvcicpKSA6XG4gICAgICBzZXR0aW5ncygnZGVmYXVsdExhYmVsQ29sb3InKTtcblxuICAgIGNvbnRleHQuZmlsbFRleHQoXG4gICAgICBub2RlLmxhYmVsLFxuICAgICAgTWF0aC5yb3VuZChub2RlW3ByZWZpeCArICd4J10gKyBzaXplICsgMyksXG4gICAgICBNYXRoLnJvdW5kKG5vZGVbcHJlZml4ICsgJ3knXSArIGZvbnRTaXplIC8gMylcbiAgICApO1xuICB9O1xufSkuY2FsbCh0aGlzKTtcblxuOyhmdW5jdGlvbih1bmRlZmluZWQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmICh0eXBlb2Ygc2lnbWEgPT09ICd1bmRlZmluZWQnKVxuICAgIHRocm93ICdzaWdtYSBpcyBub3QgZGVjbGFyZWQnO1xuXG4gIC8vIEluaXRpYWxpemUgcGFja2FnZXM6XG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuY2FudmFzLmhvdmVycycpO1xuXG4gIC8qKlxuICAgKiBUaGlzIGhvdmVyIHJlbmRlcmVyIHdpbGwgYmFzaWNhbGx5IGRpc3BsYXkgdGhlIGxhYmVsIHdpdGggYSBiYWNrZ3JvdW5kLlxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIG5vZGUgICAgIFRoZSBub2RlIG9iamVjdC5cbiAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0ICBUaGUgY2FudmFzIGNvbnRleHQuXG4gICAqIEBwYXJhbSAge2NvbmZpZ3VyYWJsZX0gICAgICAgICAgICAgc2V0dGluZ3MgVGhlIHNldHRpbmdzIGZ1bmN0aW9uLlxuICAgKi9cbiAgc2lnbWEuY2FudmFzLmhvdmVycy5kZWYgPSBmdW5jdGlvbihub2RlLCBjb250ZXh0LCBzZXR0aW5ncykge1xuICAgIHZhciB4LFxuICAgICAgICB5LFxuICAgICAgICB3LFxuICAgICAgICBoLFxuICAgICAgICBlLFxuICAgICAgICBmb250U3R5bGUgPSBzZXR0aW5ncygnaG92ZXJGb250U3R5bGUnKSB8fCBzZXR0aW5ncygnZm9udFN0eWxlJyksXG4gICAgICAgIHByZWZpeCA9IHNldHRpbmdzKCdwcmVmaXgnKSB8fCAnJyxcbiAgICAgICAgc2l6ZSA9IG5vZGVbcHJlZml4ICsgJ3NpemUnXSxcbiAgICAgICAgZm9udFNpemUgPSAoc2V0dGluZ3MoJ2xhYmVsU2l6ZScpID09PSAnZml4ZWQnKSA/XG4gICAgICAgICAgc2V0dGluZ3MoJ2RlZmF1bHRMYWJlbFNpemUnKSA6XG4gICAgICAgICAgc2V0dGluZ3MoJ2xhYmVsU2l6ZVJhdGlvJykgKiBzaXplO1xuXG4gICAgLy8gTGFiZWwgYmFja2dyb3VuZDpcbiAgICBjb250ZXh0LmZvbnQgPSAoZm9udFN0eWxlID8gZm9udFN0eWxlICsgJyAnIDogJycpICtcbiAgICAgIGZvbnRTaXplICsgJ3B4ICcgKyAoc2V0dGluZ3MoJ2hvdmVyRm9udCcpIHx8IHNldHRpbmdzKCdmb250JykpO1xuXG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9IHNldHRpbmdzKCdsYWJlbEhvdmVyQkdDb2xvcicpID09PSAnbm9kZScgP1xuICAgICAgKG5vZGUuY29sb3IgfHwgc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKSkgOlxuICAgICAgc2V0dGluZ3MoJ2RlZmF1bHRIb3ZlckxhYmVsQkdDb2xvcicpO1xuXG4gICAgaWYgKG5vZGUubGFiZWwgJiYgc2V0dGluZ3MoJ2xhYmVsSG92ZXJTaGFkb3cnKSkge1xuICAgICAgY29udGV4dC5zaGFkb3dPZmZzZXRYID0gMDtcbiAgICAgIGNvbnRleHQuc2hhZG93T2Zmc2V0WSA9IDA7XG4gICAgICBjb250ZXh0LnNoYWRvd0JsdXIgPSA4O1xuICAgICAgY29udGV4dC5zaGFkb3dDb2xvciA9IHNldHRpbmdzKCdsYWJlbEhvdmVyU2hhZG93Q29sb3InKTtcbiAgICB9XG5cbiAgICBpZiAobm9kZS5sYWJlbCAmJiB0eXBlb2Ygbm9kZS5sYWJlbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHggPSBNYXRoLnJvdW5kKG5vZGVbcHJlZml4ICsgJ3gnXSAtIGZvbnRTaXplIC8gMiAtIDIpO1xuICAgICAgeSA9IE1hdGgucm91bmQobm9kZVtwcmVmaXggKyAneSddIC0gZm9udFNpemUgLyAyIC0gMik7XG4gICAgICB3ID0gTWF0aC5yb3VuZChcbiAgICAgICAgY29udGV4dC5tZWFzdXJlVGV4dChub2RlLmxhYmVsKS53aWR0aCArIGZvbnRTaXplIC8gMiArIHNpemUgKyA3XG4gICAgICApO1xuICAgICAgaCA9IE1hdGgucm91bmQoZm9udFNpemUgKyA0KTtcbiAgICAgIGUgPSBNYXRoLnJvdW5kKGZvbnRTaXplIC8gMiArIDIpO1xuXG4gICAgICBjb250ZXh0Lm1vdmVUbyh4LCB5ICsgZSk7XG4gICAgICBjb250ZXh0LmFyY1RvKHgsIHksIHggKyBlLCB5LCBlKTtcbiAgICAgIGNvbnRleHQubGluZVRvKHggKyB3LCB5KTtcbiAgICAgIGNvbnRleHQubGluZVRvKHggKyB3LCB5ICsgaCk7XG4gICAgICBjb250ZXh0LmxpbmVUbyh4ICsgZSwgeSArIGgpO1xuICAgICAgY29udGV4dC5hcmNUbyh4LCB5ICsgaCwgeCwgeSArIGggLSBlLCBlKTtcbiAgICAgIGNvbnRleHQubGluZVRvKHgsIHkgKyBlKTtcblxuICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgIGNvbnRleHQuZmlsbCgpO1xuXG4gICAgICBjb250ZXh0LnNoYWRvd09mZnNldFggPSAwO1xuICAgICAgY29udGV4dC5zaGFkb3dPZmZzZXRZID0gMDtcbiAgICAgIGNvbnRleHQuc2hhZG93Qmx1ciA9IDA7XG4gICAgfVxuXG4gICAgLy8gTm9kZSBib3JkZXI6XG4gICAgaWYgKHNldHRpbmdzKCdib3JkZXJTaXplJykgPiAwKSB7XG4gICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBzZXR0aW5ncygnbm9kZUJvcmRlckNvbG9yJykgPT09ICdub2RlJyA/XG4gICAgICAgIChub2RlLmNvbG9yIHx8IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJykpIDpcbiAgICAgICAgc2V0dGluZ3MoJ2RlZmF1bHROb2RlQm9yZGVyQ29sb3InKTtcbiAgICAgIGNvbnRleHQuYXJjKFxuICAgICAgICBub2RlW3ByZWZpeCArICd4J10sXG4gICAgICAgIG5vZGVbcHJlZml4ICsgJ3knXSxcbiAgICAgICAgc2l6ZSArIHNldHRpbmdzKCdib3JkZXJTaXplJyksXG4gICAgICAgIDAsXG4gICAgICAgIE1hdGguUEkgKiAyLFxuICAgICAgICB0cnVlXG4gICAgICApO1xuICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgIH1cblxuICAgIC8vIE5vZGU6XG4gICAgdmFyIG5vZGVSZW5kZXJlciA9IHNpZ21hLmNhbnZhcy5ub2Rlc1tub2RlLnR5cGVdIHx8IHNpZ21hLmNhbnZhcy5ub2Rlcy5kZWY7XG4gICAgbm9kZVJlbmRlcmVyKG5vZGUsIGNvbnRleHQsIHNldHRpbmdzKTtcblxuICAgIC8vIERpc3BsYXkgdGhlIGxhYmVsOlxuICAgIGlmIChub2RlLmxhYmVsICYmIHR5cGVvZiBub2RlLmxhYmVsID09PSAnc3RyaW5nJykge1xuICAgICAgY29udGV4dC5maWxsU3R5bGUgPSAoc2V0dGluZ3MoJ2xhYmVsSG92ZXJDb2xvcicpID09PSAnbm9kZScpID9cbiAgICAgICAgKG5vZGUuY29sb3IgfHwgc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKSkgOlxuICAgICAgICBzZXR0aW5ncygnZGVmYXVsdExhYmVsSG92ZXJDb2xvcicpO1xuXG4gICAgICBjb250ZXh0LmZpbGxUZXh0KFxuICAgICAgICBub2RlLmxhYmVsLFxuICAgICAgICBNYXRoLnJvdW5kKG5vZGVbcHJlZml4ICsgJ3gnXSArIHNpemUgKyAzKSxcbiAgICAgICAgTWF0aC5yb3VuZChub2RlW3ByZWZpeCArICd5J10gKyBmb250U2l6ZSAvIDMpXG4gICAgICApO1xuICAgIH1cbiAgfTtcbn0pLmNhbGwodGhpcyk7XG5cbjsoZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLmNhbnZhcy5ub2RlcycpO1xuXG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCBub2RlIHJlbmRlcmVyLiBJdCByZW5kZXJzIHRoZSBub2RlIGFzIGEgc2ltcGxlIGRpc2MuXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgbm9kZSAgICAgVGhlIG5vZGUgb2JqZWN0LlxuICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgIFRoZSBjYW52YXMgY29udGV4dC5cbiAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSAgICAgICAgICAgICBzZXR0aW5ncyBUaGUgc2V0dGluZ3MgZnVuY3Rpb24uXG4gICAqL1xuICBzaWdtYS5jYW52YXMubm9kZXMuZGVmID0gZnVuY3Rpb24obm9kZSwgY29udGV4dCwgc2V0dGluZ3MpIHtcbiAgICB2YXIgcHJlZml4ID0gc2V0dGluZ3MoJ3ByZWZpeCcpIHx8ICcnO1xuXG4gICAgY29udGV4dC5maWxsU3R5bGUgPSBub2RlLmNvbG9yIHx8IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJyk7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICBjb250ZXh0LmFyYyhcbiAgICAgIG5vZGVbcHJlZml4ICsgJ3gnXSxcbiAgICAgIG5vZGVbcHJlZml4ICsgJ3knXSxcbiAgICAgIG5vZGVbcHJlZml4ICsgJ3NpemUnXSxcbiAgICAgIDAsXG4gICAgICBNYXRoLlBJICogMixcbiAgICAgIHRydWVcbiAgICApO1xuXG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICBjb250ZXh0LmZpbGwoKTtcbiAgfTtcbn0pKCk7XG5cbjsoZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLmNhbnZhcy5lZGdlcycpO1xuXG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCBlZGdlIHJlbmRlcmVyLiBJdCByZW5kZXJzIHRoZSBlZGdlIGFzIGEgc2ltcGxlIGxpbmUuXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgZWRnZSAgICAgICAgIFRoZSBlZGdlIG9iamVjdC5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBzb3VyY2Ugbm9kZSAgVGhlIGVkZ2Ugc291cmNlIG5vZGUuXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgdGFyZ2V0IG5vZGUgIFRoZSBlZGdlIHRhcmdldCBub2RlLlxuICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgICAgICBUaGUgY2FudmFzIGNvbnRleHQuXG4gICAqIEBwYXJhbSAge2NvbmZpZ3VyYWJsZX0gICAgICAgICAgICAgc2V0dGluZ3MgICAgIFRoZSBzZXR0aW5ncyBmdW5jdGlvbi5cbiAgICovXG4gIHNpZ21hLmNhbnZhcy5lZGdlcy5kZWYgPSBmdW5jdGlvbihlZGdlLCBzb3VyY2UsIHRhcmdldCwgY29udGV4dCwgc2V0dGluZ3MpIHtcbiAgICB2YXIgY29sb3IgPSBlZGdlLmNvbG9yLFxuICAgICAgICBwcmVmaXggPSBzZXR0aW5ncygncHJlZml4JykgfHwgJycsXG4gICAgICAgIHNpemUgPSBlZGdlW3ByZWZpeCArICdzaXplJ10gfHwgMSxcbiAgICAgICAgZWRnZUNvbG9yID0gc2V0dGluZ3MoJ2VkZ2VDb2xvcicpLFxuICAgICAgICBkZWZhdWx0Tm9kZUNvbG9yID0gc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKSxcbiAgICAgICAgZGVmYXVsdEVkZ2VDb2xvciA9IHNldHRpbmdzKCdkZWZhdWx0RWRnZUNvbG9yJyk7XG5cbiAgICBpZiAoIWNvbG9yKVxuICAgICAgc3dpdGNoIChlZGdlQ29sb3IpIHtcbiAgICAgICAgY2FzZSAnc291cmNlJzpcbiAgICAgICAgICBjb2xvciA9IHNvdXJjZS5jb2xvciB8fCBkZWZhdWx0Tm9kZUNvbG9yO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd0YXJnZXQnOlxuICAgICAgICAgIGNvbG9yID0gdGFyZ2V0LmNvbG9yIHx8IGRlZmF1bHROb2RlQ29sb3I7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY29sb3IgPSBkZWZhdWx0RWRnZUNvbG9yO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY29udGV4dC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuICAgIGNvbnRleHQubGluZVdpZHRoID0gc2l6ZTtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIGNvbnRleHQubW92ZVRvKFxuICAgICAgc291cmNlW3ByZWZpeCArICd4J10sXG4gICAgICBzb3VyY2VbcHJlZml4ICsgJ3knXVxuICAgICk7XG4gICAgY29udGV4dC5saW5lVG8oXG4gICAgICB0YXJnZXRbcHJlZml4ICsgJ3gnXSxcbiAgICAgIHRhcmdldFtwcmVmaXggKyAneSddXG4gICAgKTtcbiAgICBjb250ZXh0LnN0cm9rZSgpO1xuICB9O1xufSkoKTtcblxuOyhmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuY2FudmFzLmVkZ2VzJyk7XG5cbiAgLyoqXG4gICAqIFRoaXMgZWRnZSByZW5kZXJlciB3aWxsIGRpc3BsYXkgZWRnZXMgYXMgYXJyb3dzIGdvaW5nIGZyb20gdGhlIHNvdXJjZSBub2RlXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgZWRnZSAgICAgICAgIFRoZSBlZGdlIG9iamVjdC5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBzb3VyY2Ugbm9kZSAgVGhlIGVkZ2Ugc291cmNlIG5vZGUuXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgdGFyZ2V0IG5vZGUgIFRoZSBlZGdlIHRhcmdldCBub2RlLlxuICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgICAgICBUaGUgY2FudmFzIGNvbnRleHQuXG4gICAqIEBwYXJhbSAge2NvbmZpZ3VyYWJsZX0gICAgICAgICAgICAgc2V0dGluZ3MgICAgIFRoZSBzZXR0aW5ncyBmdW5jdGlvbi5cbiAgICovXG4gIHNpZ21hLmNhbnZhcy5lZGdlcy5hcnJvdyA9IGZ1bmN0aW9uKGVkZ2UsIHNvdXJjZSwgdGFyZ2V0LCBjb250ZXh0LCBzZXR0aW5ncykge1xuICAgIHZhciBjb2xvciA9IGVkZ2UuY29sb3IsXG4gICAgICAgIHByZWZpeCA9IHNldHRpbmdzKCdwcmVmaXgnKSB8fCAnJyxcbiAgICAgICAgZWRnZUNvbG9yID0gc2V0dGluZ3MoJ2VkZ2VDb2xvcicpLFxuICAgICAgICBkZWZhdWx0Tm9kZUNvbG9yID0gc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKSxcbiAgICAgICAgZGVmYXVsdEVkZ2VDb2xvciA9IHNldHRpbmdzKCdkZWZhdWx0RWRnZUNvbG9yJyksXG4gICAgICAgIHNpemUgPSBlZGdlW3ByZWZpeCArICdzaXplJ10gfHwgMSxcbiAgICAgICAgdFNpemUgPSB0YXJnZXRbcHJlZml4ICsgJ3NpemUnXSxcbiAgICAgICAgc1ggPSBzb3VyY2VbcHJlZml4ICsgJ3gnXSxcbiAgICAgICAgc1kgPSBzb3VyY2VbcHJlZml4ICsgJ3knXSxcbiAgICAgICAgdFggPSB0YXJnZXRbcHJlZml4ICsgJ3gnXSxcbiAgICAgICAgdFkgPSB0YXJnZXRbcHJlZml4ICsgJ3knXSxcbiAgICAgICAgYVNpemUgPSBNYXRoLm1heChzaXplICogMi41LCBzZXR0aW5ncygnbWluQXJyb3dTaXplJykpLFxuICAgICAgICBkID0gTWF0aC5zcXJ0KE1hdGgucG93KHRYIC0gc1gsIDIpICsgTWF0aC5wb3codFkgLSBzWSwgMikpLFxuICAgICAgICBhWCA9IHNYICsgKHRYIC0gc1gpICogKGQgLSBhU2l6ZSAtIHRTaXplKSAvIGQsXG4gICAgICAgIGFZID0gc1kgKyAodFkgLSBzWSkgKiAoZCAtIGFTaXplIC0gdFNpemUpIC8gZCxcbiAgICAgICAgdlggPSAodFggLSBzWCkgKiBhU2l6ZSAvIGQsXG4gICAgICAgIHZZID0gKHRZIC0gc1kpICogYVNpemUgLyBkO1xuXG4gICAgaWYgKCFjb2xvcilcbiAgICAgIHN3aXRjaCAoZWRnZUNvbG9yKSB7XG4gICAgICAgIGNhc2UgJ3NvdXJjZSc6XG4gICAgICAgICAgY29sb3IgPSBzb3VyY2UuY29sb3IgfHwgZGVmYXVsdE5vZGVDb2xvcjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndGFyZ2V0JzpcbiAgICAgICAgICBjb2xvciA9IHRhcmdldC5jb2xvciB8fCBkZWZhdWx0Tm9kZUNvbG9yO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGNvbG9yID0gZGVmYXVsdEVkZ2VDb2xvcjtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHNpemU7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICBjb250ZXh0Lm1vdmVUbyhzWCwgc1kpO1xuICAgIGNvbnRleHQubGluZVRvKFxuICAgICAgYVgsXG4gICAgICBhWVxuICAgICk7XG4gICAgY29udGV4dC5zdHJva2UoKTtcblxuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gY29sb3I7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICBjb250ZXh0Lm1vdmVUbyhhWCArIHZYLCBhWSArIHZZKTtcbiAgICBjb250ZXh0LmxpbmVUbyhhWCArIHZZICogMC42LCBhWSAtIHZYICogMC42KTtcbiAgICBjb250ZXh0LmxpbmVUbyhhWCAtIHZZICogMC42LCBhWSArIHZYICogMC42KTtcbiAgICBjb250ZXh0LmxpbmVUbyhhWCArIHZYLCBhWSArIHZZKTtcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIGNvbnRleHQuZmlsbCgpO1xuICB9O1xufSkoKTtcblxuOyhmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuY2FudmFzLmVkZ2Vob3ZlcnMnKTtcblxuICAvKipcbiAgICogVGhpcyBob3ZlciByZW5kZXJlciB3aWxsIGRpc3BsYXkgdGhlIGVkZ2Ugd2l0aCBhIGRpZmZlcmVudCBjb2xvciBvciBzaXplLlxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIGVkZ2UgICAgICAgICBUaGUgZWRnZSBvYmplY3QuXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgc291cmNlIG5vZGUgIFRoZSBlZGdlIHNvdXJjZSBub2RlLlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIHRhcmdldCBub2RlICBUaGUgZWRnZSB0YXJnZXQgbm9kZS5cbiAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0ICAgICAgVGhlIGNhbnZhcyBjb250ZXh0LlxuICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9ICAgICAgICAgICAgIHNldHRpbmdzICAgICBUaGUgc2V0dGluZ3MgZnVuY3Rpb24uXG4gICAqL1xuICBzaWdtYS5jYW52YXMuZWRnZWhvdmVycy5kZWYgPVxuICAgIGZ1bmN0aW9uKGVkZ2UsIHNvdXJjZSwgdGFyZ2V0LCBjb250ZXh0LCBzZXR0aW5ncykge1xuICAgICAgdmFyIGNvbG9yID0gZWRnZS5jb2xvcixcbiAgICAgICAgcHJlZml4ID0gc2V0dGluZ3MoJ3ByZWZpeCcpIHx8ICcnLFxuICAgICAgICBzaXplID0gZWRnZVtwcmVmaXggKyAnc2l6ZSddIHx8IDEsXG4gICAgICAgIGVkZ2VDb2xvciA9IHNldHRpbmdzKCdlZGdlQ29sb3InKSxcbiAgICAgICAgZGVmYXVsdE5vZGVDb2xvciA9IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJyksXG4gICAgICAgIGRlZmF1bHRFZGdlQ29sb3IgPSBzZXR0aW5ncygnZGVmYXVsdEVkZ2VDb2xvcicpO1xuXG4gICAgaWYgKCFjb2xvcilcbiAgICAgIHN3aXRjaCAoZWRnZUNvbG9yKSB7XG4gICAgICAgIGNhc2UgJ3NvdXJjZSc6XG4gICAgICAgICAgY29sb3IgPSBzb3VyY2UuY29sb3IgfHwgZGVmYXVsdE5vZGVDb2xvcjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndGFyZ2V0JzpcbiAgICAgICAgICBjb2xvciA9IHRhcmdldC5jb2xvciB8fCBkZWZhdWx0Tm9kZUNvbG9yO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGNvbG9yID0gZGVmYXVsdEVkZ2VDb2xvcjtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGlmIChzZXR0aW5ncygnZWRnZUhvdmVyQ29sb3InKSA9PT0gJ2VkZ2UnKSB7XG4gICAgICBjb2xvciA9IGVkZ2UuaG92ZXJfY29sb3IgfHwgY29sb3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbG9yID0gZWRnZS5ob3Zlcl9jb2xvciB8fCBzZXR0aW5ncygnZGVmYXVsdEVkZ2VIb3ZlckNvbG9yJykgfHwgY29sb3I7XG4gICAgfVxuICAgIHNpemUgKj0gc2V0dGluZ3MoJ2VkZ2VIb3ZlclNpemVSYXRpbycpO1xuXG4gICAgY29udGV4dC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuICAgIGNvbnRleHQubGluZVdpZHRoID0gc2l6ZTtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIGNvbnRleHQubW92ZVRvKFxuICAgICAgc291cmNlW3ByZWZpeCArICd4J10sXG4gICAgICBzb3VyY2VbcHJlZml4ICsgJ3knXVxuICAgICk7XG4gICAgY29udGV4dC5saW5lVG8oXG4gICAgICB0YXJnZXRbcHJlZml4ICsgJ3gnXSxcbiAgICAgIHRhcmdldFtwcmVmaXggKyAneSddXG4gICAgKTtcbiAgICBjb250ZXh0LnN0cm9rZSgpO1xuICB9O1xufSkoKTtcblxuOyhmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuY2FudmFzLmVkZ2Vob3ZlcnMnKTtcblxuICAvKipcbiAgICogVGhpcyBob3ZlciByZW5kZXJlciB3aWxsIGRpc3BsYXkgdGhlIGVkZ2Ugd2l0aCBhIGRpZmZlcmVudCBjb2xvciBvciBzaXplLlxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIGVkZ2UgICAgICAgICBUaGUgZWRnZSBvYmplY3QuXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgc291cmNlIG5vZGUgIFRoZSBlZGdlIHNvdXJjZSBub2RlLlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIHRhcmdldCBub2RlICBUaGUgZWRnZSB0YXJnZXQgbm9kZS5cbiAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0ICAgICAgVGhlIGNhbnZhcyBjb250ZXh0LlxuICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9ICAgICAgICAgICAgIHNldHRpbmdzICAgICBUaGUgc2V0dGluZ3MgZnVuY3Rpb24uXG4gICAqL1xuICBzaWdtYS5jYW52YXMuZWRnZWhvdmVycy5jdXJ2ZSA9XG4gICAgZnVuY3Rpb24oZWRnZSwgc291cmNlLCB0YXJnZXQsIGNvbnRleHQsIHNldHRpbmdzKSB7XG4gICAgdmFyIGNvbG9yID0gZWRnZS5jb2xvcixcbiAgICAgICAgcHJlZml4ID0gc2V0dGluZ3MoJ3ByZWZpeCcpIHx8ICcnLFxuICAgICAgICBzaXplID0gc2V0dGluZ3MoJ2VkZ2VIb3ZlclNpemVSYXRpbycpICogKGVkZ2VbcHJlZml4ICsgJ3NpemUnXSB8fCAxKSxcbiAgICAgICAgZWRnZUNvbG9yID0gc2V0dGluZ3MoJ2VkZ2VDb2xvcicpLFxuICAgICAgICBkZWZhdWx0Tm9kZUNvbG9yID0gc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKSxcbiAgICAgICAgZGVmYXVsdEVkZ2VDb2xvciA9IHNldHRpbmdzKCdkZWZhdWx0RWRnZUNvbG9yJyksXG4gICAgICAgIGNwID0ge30sXG4gICAgICAgIHNTaXplID0gc291cmNlW3ByZWZpeCArICdzaXplJ10sXG4gICAgICAgIHNYID0gc291cmNlW3ByZWZpeCArICd4J10sXG4gICAgICAgIHNZID0gc291cmNlW3ByZWZpeCArICd5J10sXG4gICAgICAgIHRYID0gdGFyZ2V0W3ByZWZpeCArICd4J10sXG4gICAgICAgIHRZID0gdGFyZ2V0W3ByZWZpeCArICd5J107XG5cbiAgICBjcCA9IChzb3VyY2UuaWQgPT09IHRhcmdldC5pZCkgP1xuICAgICAgc2lnbWEudXRpbHMuZ2V0U2VsZkxvb3BDb250cm9sUG9pbnRzKHNYLCBzWSwgc1NpemUpIDpcbiAgICAgIHNpZ21hLnV0aWxzLmdldFF1YWRyYXRpY0NvbnRyb2xQb2ludChzWCwgc1ksIHRYLCB0WSk7XG5cbiAgICBpZiAoIWNvbG9yKVxuICAgICAgc3dpdGNoIChlZGdlQ29sb3IpIHtcbiAgICAgICAgY2FzZSAnc291cmNlJzpcbiAgICAgICAgICBjb2xvciA9IHNvdXJjZS5jb2xvciB8fCBkZWZhdWx0Tm9kZUNvbG9yO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd0YXJnZXQnOlxuICAgICAgICAgIGNvbG9yID0gdGFyZ2V0LmNvbG9yIHx8IGRlZmF1bHROb2RlQ29sb3I7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY29sb3IgPSBkZWZhdWx0RWRnZUNvbG9yO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgaWYgKHNldHRpbmdzKCdlZGdlSG92ZXJDb2xvcicpID09PSAnZWRnZScpIHtcbiAgICAgIGNvbG9yID0gZWRnZS5ob3Zlcl9jb2xvciB8fCBjb2xvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgY29sb3IgPSBlZGdlLmhvdmVyX2NvbG9yIHx8IHNldHRpbmdzKCdkZWZhdWx0RWRnZUhvdmVyQ29sb3InKSB8fCBjb2xvcjtcbiAgICB9XG5cbiAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gICAgY29udGV4dC5saW5lV2lkdGggPSBzaXplO1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgY29udGV4dC5tb3ZlVG8oc1gsIHNZKTtcbiAgICBpZiAoc291cmNlLmlkID09PSB0YXJnZXQuaWQpIHtcbiAgICAgIGNvbnRleHQuYmV6aWVyQ3VydmVUbyhjcC54MSwgY3AueTEsIGNwLngyLCBjcC55MiwgdFgsIHRZKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKGNwLngsIGNwLnksIHRYLCB0WSk7XG4gICAgfVxuICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gIH07XG59KSgpO1xuXG47KGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5jYW52YXMuZWRnZWhvdmVycycpO1xuXG4gIC8qKlxuICAgKiBUaGlzIGhvdmVyIHJlbmRlcmVyIHdpbGwgZGlzcGxheSB0aGUgZWRnZSB3aXRoIGEgZGlmZmVyZW50IGNvbG9yIG9yIHNpemUuXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgZWRnZSAgICAgICAgIFRoZSBlZGdlIG9iamVjdC5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBzb3VyY2Ugbm9kZSAgVGhlIGVkZ2Ugc291cmNlIG5vZGUuXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgdGFyZ2V0IG5vZGUgIFRoZSBlZGdlIHRhcmdldCBub2RlLlxuICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgICAgICBUaGUgY2FudmFzIGNvbnRleHQuXG4gICAqIEBwYXJhbSAge2NvbmZpZ3VyYWJsZX0gICAgICAgICAgICAgc2V0dGluZ3MgICAgIFRoZSBzZXR0aW5ncyBmdW5jdGlvbi5cbiAgICovXG4gIHNpZ21hLmNhbnZhcy5lZGdlaG92ZXJzLmFycm93ID1cbiAgICBmdW5jdGlvbihlZGdlLCBzb3VyY2UsIHRhcmdldCwgY29udGV4dCwgc2V0dGluZ3MpIHtcbiAgICB2YXIgY29sb3IgPSBlZGdlLmNvbG9yLFxuICAgICAgICBwcmVmaXggPSBzZXR0aW5ncygncHJlZml4JykgfHwgJycsXG4gICAgICAgIGVkZ2VDb2xvciA9IHNldHRpbmdzKCdlZGdlQ29sb3InKSxcbiAgICAgICAgZGVmYXVsdE5vZGVDb2xvciA9IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJyksXG4gICAgICAgIGRlZmF1bHRFZGdlQ29sb3IgPSBzZXR0aW5ncygnZGVmYXVsdEVkZ2VDb2xvcicpLFxuICAgICAgICBzaXplID0gZWRnZVtwcmVmaXggKyAnc2l6ZSddIHx8IDEsXG4gICAgICAgIHRTaXplID0gdGFyZ2V0W3ByZWZpeCArICdzaXplJ10sXG4gICAgICAgIHNYID0gc291cmNlW3ByZWZpeCArICd4J10sXG4gICAgICAgIHNZID0gc291cmNlW3ByZWZpeCArICd5J10sXG4gICAgICAgIHRYID0gdGFyZ2V0W3ByZWZpeCArICd4J10sXG4gICAgICAgIHRZID0gdGFyZ2V0W3ByZWZpeCArICd5J107XG5cbiAgICBzaXplID0gKGVkZ2UuaG92ZXIpID9cbiAgICAgIHNldHRpbmdzKCdlZGdlSG92ZXJTaXplUmF0aW8nKSAqIHNpemUgOiBzaXplO1xuICAgIHZhciBhU2l6ZSA9IHNpemUgKiAyLjUsXG4gICAgICAgIGQgPSBNYXRoLnNxcnQoTWF0aC5wb3codFggLSBzWCwgMikgKyBNYXRoLnBvdyh0WSAtIHNZLCAyKSksXG4gICAgICAgIGFYID0gc1ggKyAodFggLSBzWCkgKiAoZCAtIGFTaXplIC0gdFNpemUpIC8gZCxcbiAgICAgICAgYVkgPSBzWSArICh0WSAtIHNZKSAqIChkIC0gYVNpemUgLSB0U2l6ZSkgLyBkLFxuICAgICAgICB2WCA9ICh0WCAtIHNYKSAqIGFTaXplIC8gZCxcbiAgICAgICAgdlkgPSAodFkgLSBzWSkgKiBhU2l6ZSAvIGQ7XG5cbiAgICBpZiAoIWNvbG9yKVxuICAgICAgc3dpdGNoIChlZGdlQ29sb3IpIHtcbiAgICAgICAgY2FzZSAnc291cmNlJzpcbiAgICAgICAgICBjb2xvciA9IHNvdXJjZS5jb2xvciB8fCBkZWZhdWx0Tm9kZUNvbG9yO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd0YXJnZXQnOlxuICAgICAgICAgIGNvbG9yID0gdGFyZ2V0LmNvbG9yIHx8IGRlZmF1bHROb2RlQ29sb3I7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY29sb3IgPSBkZWZhdWx0RWRnZUNvbG9yO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgaWYgKHNldHRpbmdzKCdlZGdlSG92ZXJDb2xvcicpID09PSAnZWRnZScpIHtcbiAgICAgIGNvbG9yID0gZWRnZS5ob3Zlcl9jb2xvciB8fCBjb2xvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgY29sb3IgPSBlZGdlLmhvdmVyX2NvbG9yIHx8IHNldHRpbmdzKCdkZWZhdWx0RWRnZUhvdmVyQ29sb3InKSB8fCBjb2xvcjtcbiAgICB9XG5cbiAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gICAgY29udGV4dC5saW5lV2lkdGggPSBzaXplO1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgY29udGV4dC5tb3ZlVG8oc1gsIHNZKTtcbiAgICBjb250ZXh0LmxpbmVUbyhcbiAgICAgIGFYLFxuICAgICAgYVlcbiAgICApO1xuICAgIGNvbnRleHQuc3Ryb2tlKCk7XG5cbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgY29udGV4dC5tb3ZlVG8oYVggKyB2WCwgYVkgKyB2WSk7XG4gICAgY29udGV4dC5saW5lVG8oYVggKyB2WSAqIDAuNiwgYVkgLSB2WCAqIDAuNik7XG4gICAgY29udGV4dC5saW5lVG8oYVggLSB2WSAqIDAuNiwgYVkgKyB2WCAqIDAuNik7XG4gICAgY29udGV4dC5saW5lVG8oYVggKyB2WCwgYVkgKyB2WSk7XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICBjb250ZXh0LmZpbGwoKTtcbiAgfTtcbn0pKCk7XG5cbjsoZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLmNhbnZhcy5lZGdlaG92ZXJzJyk7XG5cbiAgLyoqXG4gICAqIFRoaXMgaG92ZXIgcmVuZGVyZXIgd2lsbCBkaXNwbGF5IHRoZSBlZGdlIHdpdGggYSBkaWZmZXJlbnQgY29sb3Igb3Igc2l6ZS5cbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBlZGdlICAgICAgICAgVGhlIGVkZ2Ugb2JqZWN0LlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIHNvdXJjZSBub2RlICBUaGUgZWRnZSBzb3VyY2Ugbm9kZS5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICB0YXJnZXQgbm9kZSAgVGhlIGVkZ2UgdGFyZ2V0IG5vZGUuXG4gICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCAgICAgIFRoZSBjYW52YXMgY29udGV4dC5cbiAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSAgICAgICAgICAgICBzZXR0aW5ncyAgICAgVGhlIHNldHRpbmdzIGZ1bmN0aW9uLlxuICAgKi9cbiAgc2lnbWEuY2FudmFzLmVkZ2Vob3ZlcnMuY3VydmVkQXJyb3cgPVxuICAgIGZ1bmN0aW9uKGVkZ2UsIHNvdXJjZSwgdGFyZ2V0LCBjb250ZXh0LCBzZXR0aW5ncykge1xuICAgIHZhciBjb2xvciA9IGVkZ2UuY29sb3IsXG4gICAgICAgIHByZWZpeCA9IHNldHRpbmdzKCdwcmVmaXgnKSB8fCAnJyxcbiAgICAgICAgZWRnZUNvbG9yID0gc2V0dGluZ3MoJ2VkZ2VDb2xvcicpLFxuICAgICAgICBkZWZhdWx0Tm9kZUNvbG9yID0gc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKSxcbiAgICAgICAgZGVmYXVsdEVkZ2VDb2xvciA9IHNldHRpbmdzKCdkZWZhdWx0RWRnZUNvbG9yJyksXG4gICAgICAgIGNwID0ge30sXG4gICAgICAgIHNpemUgPSBzZXR0aW5ncygnZWRnZUhvdmVyU2l6ZVJhdGlvJykgKiAoZWRnZVtwcmVmaXggKyAnc2l6ZSddIHx8IDEpLFxuICAgICAgICB0U2l6ZSA9IHRhcmdldFtwcmVmaXggKyAnc2l6ZSddLFxuICAgICAgICBzWCA9IHNvdXJjZVtwcmVmaXggKyAneCddLFxuICAgICAgICBzWSA9IHNvdXJjZVtwcmVmaXggKyAneSddLFxuICAgICAgICB0WCA9IHRhcmdldFtwcmVmaXggKyAneCddLFxuICAgICAgICB0WSA9IHRhcmdldFtwcmVmaXggKyAneSddLFxuICAgICAgICBkLFxuICAgICAgICBhU2l6ZSxcbiAgICAgICAgYVgsXG4gICAgICAgIGFZLFxuICAgICAgICB2WCxcbiAgICAgICAgdlk7XG5cbiAgICBjcCA9IChzb3VyY2UuaWQgPT09IHRhcmdldC5pZCkgP1xuICAgICAgc2lnbWEudXRpbHMuZ2V0U2VsZkxvb3BDb250cm9sUG9pbnRzKHNYLCBzWSwgdFNpemUpIDpcbiAgICAgIHNpZ21hLnV0aWxzLmdldFF1YWRyYXRpY0NvbnRyb2xQb2ludChzWCwgc1ksIHRYLCB0WSk7XG5cbiAgICBpZiAoc291cmNlLmlkID09PSB0YXJnZXQuaWQpIHtcbiAgICAgIGQgPSBNYXRoLnNxcnQoTWF0aC5wb3codFggLSBjcC54MSwgMikgKyBNYXRoLnBvdyh0WSAtIGNwLnkxLCAyKSk7XG4gICAgICBhU2l6ZSA9IHNpemUgKiAyLjU7XG4gICAgICBhWCA9IGNwLngxICsgKHRYIC0gY3AueDEpICogKGQgLSBhU2l6ZSAtIHRTaXplKSAvIGQ7XG4gICAgICBhWSA9IGNwLnkxICsgKHRZIC0gY3AueTEpICogKGQgLSBhU2l6ZSAtIHRTaXplKSAvIGQ7XG4gICAgICB2WCA9ICh0WCAtIGNwLngxKSAqIGFTaXplIC8gZDtcbiAgICAgIHZZID0gKHRZIC0gY3AueTEpICogYVNpemUgLyBkO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGQgPSBNYXRoLnNxcnQoTWF0aC5wb3codFggLSBjcC54LCAyKSArIE1hdGgucG93KHRZIC0gY3AueSwgMikpO1xuICAgICAgYVNpemUgPSBzaXplICogMi41O1xuICAgICAgYVggPSBjcC54ICsgKHRYIC0gY3AueCkgKiAoZCAtIGFTaXplIC0gdFNpemUpIC8gZDtcbiAgICAgIGFZID0gY3AueSArICh0WSAtIGNwLnkpICogKGQgLSBhU2l6ZSAtIHRTaXplKSAvIGQ7XG4gICAgICB2WCA9ICh0WCAtIGNwLngpICogYVNpemUgLyBkO1xuICAgICAgdlkgPSAodFkgLSBjcC55KSAqIGFTaXplIC8gZDtcbiAgICB9XG5cbiAgICBpZiAoIWNvbG9yKVxuICAgICAgc3dpdGNoIChlZGdlQ29sb3IpIHtcbiAgICAgICAgY2FzZSAnc291cmNlJzpcbiAgICAgICAgICBjb2xvciA9IHNvdXJjZS5jb2xvciB8fCBkZWZhdWx0Tm9kZUNvbG9yO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd0YXJnZXQnOlxuICAgICAgICAgIGNvbG9yID0gdGFyZ2V0LmNvbG9yIHx8IGRlZmF1bHROb2RlQ29sb3I7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY29sb3IgPSBkZWZhdWx0RWRnZUNvbG9yO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgaWYgKHNldHRpbmdzKCdlZGdlSG92ZXJDb2xvcicpID09PSAnZWRnZScpIHtcbiAgICAgIGNvbG9yID0gZWRnZS5ob3Zlcl9jb2xvciB8fCBjb2xvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgY29sb3IgPSBlZGdlLmhvdmVyX2NvbG9yIHx8IHNldHRpbmdzKCdkZWZhdWx0RWRnZUhvdmVyQ29sb3InKSB8fCBjb2xvcjtcbiAgICB9XG5cbiAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gICAgY29udGV4dC5saW5lV2lkdGggPSBzaXplO1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgY29udGV4dC5tb3ZlVG8oc1gsIHNZKTtcbiAgICBpZiAoc291cmNlLmlkID09PSB0YXJnZXQuaWQpIHtcbiAgICAgIGNvbnRleHQuYmV6aWVyQ3VydmVUbyhjcC54MiwgY3AueTIsIGNwLngxLCBjcC55MSwgYVgsIGFZKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKGNwLngsIGNwLnksIGFYLCBhWSk7XG4gICAgfVxuICAgIGNvbnRleHQuc3Ryb2tlKCk7XG5cbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgY29udGV4dC5tb3ZlVG8oYVggKyB2WCwgYVkgKyB2WSk7XG4gICAgY29udGV4dC5saW5lVG8oYVggKyB2WSAqIDAuNiwgYVkgLSB2WCAqIDAuNik7XG4gICAgY29udGV4dC5saW5lVG8oYVggLSB2WSAqIDAuNiwgYVkgKyB2WCAqIDAuNik7XG4gICAgY29udGV4dC5saW5lVG8oYVggKyB2WCwgYVkgKyB2WSk7XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICBjb250ZXh0LmZpbGwoKTtcbiAgfTtcbn0pKCk7XG5cbjsoZnVuY3Rpb24odW5kZWZpbmVkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBpZiAodHlwZW9mIHNpZ21hID09PSAndW5kZWZpbmVkJylcbiAgICB0aHJvdyAnc2lnbWEgaXMgbm90IGRlY2xhcmVkJztcblxuICAvLyBJbml0aWFsaXplIHBhY2thZ2VzOlxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLmNhbnZhcy5leHRyZW1pdGllcycpO1xuXG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCByZW5kZXJlciBmb3IgaG92ZXJlZCBlZGdlIGV4dHJlbWl0aWVzLiBJdCByZW5kZXJzIHRoZSBlZGdlXG4gICAqIGV4dHJlbWl0aWVzIGFzIGhvdmVyZWQuXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgZWRnZSAgICAgICAgIFRoZSBlZGdlIG9iamVjdC5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBzb3VyY2Ugbm9kZSAgVGhlIGVkZ2Ugc291cmNlIG5vZGUuXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgdGFyZ2V0IG5vZGUgIFRoZSBlZGdlIHRhcmdldCBub2RlLlxuICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgICAgICBUaGUgY2FudmFzIGNvbnRleHQuXG4gICAqIEBwYXJhbSAge2NvbmZpZ3VyYWJsZX0gICAgICAgICAgICAgc2V0dGluZ3MgICAgIFRoZSBzZXR0aW5ncyBmdW5jdGlvbi5cbiAgICovXG4gIHNpZ21hLmNhbnZhcy5leHRyZW1pdGllcy5kZWYgPVxuICAgIGZ1bmN0aW9uKGVkZ2UsIHNvdXJjZSwgdGFyZ2V0LCBjb250ZXh0LCBzZXR0aW5ncykge1xuICAgIC8vIFNvdXJjZSBOb2RlOlxuICAgIChcbiAgICAgIHNpZ21hLmNhbnZhcy5ob3ZlcnNbc291cmNlLnR5cGVdIHx8XG4gICAgICBzaWdtYS5jYW52YXMuaG92ZXJzLmRlZlxuICAgICkgKFxuICAgICAgc291cmNlLCBjb250ZXh0LCBzZXR0aW5nc1xuICAgICk7XG5cbiAgICAvLyBUYXJnZXQgTm9kZTpcbiAgICAoXG4gICAgICBzaWdtYS5jYW52YXMuaG92ZXJzW3RhcmdldC50eXBlXSB8fFxuICAgICAgc2lnbWEuY2FudmFzLmhvdmVycy5kZWZcbiAgICApIChcbiAgICAgIHRhcmdldCwgY29udGV4dCwgc2V0dGluZ3NcbiAgICApO1xuICB9O1xufSkuY2FsbCh0aGlzKTtcblxuOyhmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuc3ZnLnV0aWxzJyk7XG5cbiAgLyoqXG4gICAqIFNvbWUgdXNlZnVsIGZ1bmN0aW9ucyB1c2VkIGJ5IHNpZ21hJ3MgU1ZHIHJlbmRlcmVyLlxuICAgKi9cbiAgc2lnbWEuc3ZnLnV0aWxzID0ge1xuXG4gICAgLyoqXG4gICAgICogU1ZHIEVsZW1lbnQgc2hvdy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge0RPTUVsZW1lbnR9ICAgICAgICAgICAgICAgZWxlbWVudCAgIFRoZSBET00gZWxlbWVudCB0byBzaG93LlxuICAgICAqL1xuICAgIHNob3c6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgIGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICcnO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNWRyBFbGVtZW50IGhpZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtET01FbGVtZW50fSAgICAgICAgICAgICAgIGVsZW1lbnQgICBUaGUgRE9NIGVsZW1lbnQgdG8gaGlkZS5cbiAgICAgKi9cbiAgICBoaWRlOiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH07XG59KSgpO1xuXG47KGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5zdmcubm9kZXMnKTtcblxuICAvKipcbiAgICogVGhlIGRlZmF1bHQgbm9kZSByZW5kZXJlci4gSXQgcmVuZGVycyB0aGUgbm9kZSBhcyBhIHNpbXBsZSBkaXNjLlxuICAgKi9cbiAgc2lnbWEuc3ZnLm5vZGVzLmRlZiA9IHtcblxuICAgIC8qKlxuICAgICAqIFNWRyBFbGVtZW50IGNyZWF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBub2RlICAgICBUaGUgbm9kZSBvYmplY3QuXG4gICAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSAgICAgICAgICAgICBzZXR0aW5ncyBUaGUgc2V0dGluZ3MgZnVuY3Rpb24uXG4gICAgICovXG4gICAgY3JlYXRlOiBmdW5jdGlvbihub2RlLCBzZXR0aW5ncykge1xuICAgICAgdmFyIHByZWZpeCA9IHNldHRpbmdzKCdwcmVmaXgnKSB8fCAnJyxcbiAgICAgICAgICBjaXJjbGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoc2V0dGluZ3MoJ3htbG5zJyksICdjaXJjbGUnKTtcblxuICAgICAgLy8gRGVmaW5pbmcgdGhlIG5vZGUncyBjaXJjbGVcbiAgICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZGF0YS1ub2RlLWlkJywgbm9kZS5pZCk7XG4gICAgICBjaXJjbGUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2NsYXNzJywgc2V0dGluZ3MoJ2NsYXNzUHJlZml4JykgKyAnLW5vZGUnKTtcbiAgICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGVOUyhcbiAgICAgICAgbnVsbCwgJ2ZpbGwnLCBub2RlLmNvbG9yIHx8IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJykpO1xuXG4gICAgICAvLyBSZXR1cm5pbmcgdGhlIERPTSBFbGVtZW50XG4gICAgICByZXR1cm4gY2lyY2xlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTVkcgRWxlbWVudCB1cGRhdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIG5vZGUgICAgIFRoZSBub2RlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gIHtET01FbGVtZW50fSAgICAgICAgICAgICAgIGNpcmNsZSAgIFRoZSBub2RlIERPTSBlbGVtZW50LlxuICAgICAqIEBwYXJhbSAge2NvbmZpZ3VyYWJsZX0gICAgICAgICAgICAgc2V0dGluZ3MgVGhlIHNldHRpbmdzIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIHVwZGF0ZTogZnVuY3Rpb24obm9kZSwgY2lyY2xlLCBzZXR0aW5ncykge1xuICAgICAgdmFyIHByZWZpeCA9IHNldHRpbmdzKCdwcmVmaXgnKSB8fCAnJztcblxuICAgICAgLy8gQXBwbHlpbmcgY2hhbmdlc1xuICAgICAgLy8gVE9ETzogb3B0aW1pemUgLSBjaGVjayBpZiBuZWNlc3NhcnlcbiAgICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnY3gnLCBub2RlW3ByZWZpeCArICd4J10pO1xuICAgICAgY2lyY2xlLnNldEF0dHJpYnV0ZU5TKG51bGwsICdjeScsIG5vZGVbcHJlZml4ICsgJ3knXSk7XG4gICAgICBjaXJjbGUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3InLCBub2RlW3ByZWZpeCArICdzaXplJ10pO1xuXG4gICAgICAvLyBVcGRhdGluZyBvbmx5IGlmIG5vdCBmcmVlc3R5bGVcbiAgICAgIGlmICghc2V0dGluZ3MoJ2ZyZWVTdHlsZScpKVxuICAgICAgICBjaXJjbGUuc2V0QXR0cmlidXRlTlMoXG4gICAgICAgICAgbnVsbCwgJ2ZpbGwnLCBub2RlLmNvbG9yIHx8IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJykpO1xuXG4gICAgICAvLyBTaG93aW5nXG4gICAgICBjaXJjbGUuc3R5bGUuZGlzcGxheSA9ICcnO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH07XG59KSgpO1xuXG47KGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5zdmcuZWRnZXMnKTtcblxuICAvKipcbiAgICogVGhlIGRlZmF1bHQgZWRnZSByZW5kZXJlci4gSXQgcmVuZGVycyB0aGUgbm9kZSBhcyBhIHNpbXBsZSBsaW5lLlxuICAgKi9cbiAgc2lnbWEuc3ZnLmVkZ2VzLmRlZiA9IHtcblxuICAgIC8qKlxuICAgICAqIFNWRyBFbGVtZW50IGNyZWF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBlZGdlICAgICAgIFRoZSBlZGdlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIHNvdXJjZSAgICAgVGhlIHNvdXJjZSBub2RlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIHRhcmdldCAgICAgVGhlIHRhcmdldCBub2RlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9ICAgICAgICAgICAgIHNldHRpbmdzICAgVGhlIHNldHRpbmdzIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGNyZWF0ZTogZnVuY3Rpb24oZWRnZSwgc291cmNlLCB0YXJnZXQsIHNldHRpbmdzKSB7XG4gICAgICB2YXIgY29sb3IgPSBlZGdlLmNvbG9yLFxuICAgICAgICAgIHByZWZpeCA9IHNldHRpbmdzKCdwcmVmaXgnKSB8fCAnJyxcbiAgICAgICAgICBlZGdlQ29sb3IgPSBzZXR0aW5ncygnZWRnZUNvbG9yJyksXG4gICAgICAgICAgZGVmYXVsdE5vZGVDb2xvciA9IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJyksXG4gICAgICAgICAgZGVmYXVsdEVkZ2VDb2xvciA9IHNldHRpbmdzKCdkZWZhdWx0RWRnZUNvbG9yJyk7XG5cbiAgICAgIGlmICghY29sb3IpXG4gICAgICAgIHN3aXRjaCAoZWRnZUNvbG9yKSB7XG4gICAgICAgICAgY2FzZSAnc291cmNlJzpcbiAgICAgICAgICAgIGNvbG9yID0gc291cmNlLmNvbG9yIHx8IGRlZmF1bHROb2RlQ29sb3I7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICd0YXJnZXQnOlxuICAgICAgICAgICAgY29sb3IgPSB0YXJnZXQuY29sb3IgfHwgZGVmYXVsdE5vZGVDb2xvcjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjb2xvciA9IGRlZmF1bHRFZGdlQ29sb3I7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICB2YXIgbGluZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhzZXR0aW5ncygneG1sbnMnKSwgJ2xpbmUnKTtcblxuICAgICAgLy8gQXR0cmlidXRlc1xuICAgICAgbGluZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZGF0YS1lZGdlLWlkJywgZWRnZS5pZCk7XG4gICAgICBsaW5lLnNldEF0dHJpYnV0ZU5TKG51bGwsICdjbGFzcycsIHNldHRpbmdzKCdjbGFzc1ByZWZpeCcpICsgJy1lZGdlJyk7XG4gICAgICBsaW5lLnNldEF0dHJpYnV0ZU5TKG51bGwsICdzdHJva2UnLCBjb2xvcik7XG5cbiAgICAgIHJldHVybiBsaW5lO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTVkcgRWxlbWVudCB1cGRhdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIGVkZ2UgICAgICAgVGhlIGVkZ2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSAge0RPTUVsZW1lbnR9ICAgICAgICAgICAgICAgbGluZSAgICAgICBUaGUgbGluZSBET00gRWxlbWVudC5cbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIHNvdXJjZSAgICAgVGhlIHNvdXJjZSBub2RlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIHRhcmdldCAgICAgVGhlIHRhcmdldCBub2RlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9ICAgICAgICAgICAgIHNldHRpbmdzICAgVGhlIHNldHRpbmdzIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIHVwZGF0ZTogZnVuY3Rpb24oZWRnZSwgbGluZSwgc291cmNlLCB0YXJnZXQsIHNldHRpbmdzKSB7XG4gICAgICB2YXIgcHJlZml4ID0gc2V0dGluZ3MoJ3ByZWZpeCcpIHx8ICcnO1xuXG4gICAgICBsaW5lLnNldEF0dHJpYnV0ZU5TKG51bGwsICdzdHJva2Utd2lkdGgnLCBlZGdlW3ByZWZpeCArICdzaXplJ10gfHwgMSk7XG4gICAgICBsaW5lLnNldEF0dHJpYnV0ZU5TKG51bGwsICd4MScsIHNvdXJjZVtwcmVmaXggKyAneCddKTtcbiAgICAgIGxpbmUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3kxJywgc291cmNlW3ByZWZpeCArICd5J10pO1xuICAgICAgbGluZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAneDInLCB0YXJnZXRbcHJlZml4ICsgJ3gnXSk7XG4gICAgICBsaW5lLnNldEF0dHJpYnV0ZU5TKG51bGwsICd5MicsIHRhcmdldFtwcmVmaXggKyAneSddKTtcblxuICAgICAgLy8gU2hvd2luZ1xuICAgICAgbGluZS5zdHlsZS5kaXNwbGF5ID0gJyc7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTtcbn0pKCk7XG5cbjsoZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLnN2Zy5lZGdlcycpO1xuXG4gIC8qKlxuICAgKiBUaGUgY3VydmUgZWRnZSByZW5kZXJlci4gSXQgcmVuZGVycyB0aGUgbm9kZSBhcyBhIGJlemllciBjdXJ2ZS5cbiAgICovXG4gIHNpZ21hLnN2Zy5lZGdlcy5jdXJ2ZSA9IHtcblxuICAgIC8qKlxuICAgICAqIFNWRyBFbGVtZW50IGNyZWF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBlZGdlICAgICAgIFRoZSBlZGdlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIHNvdXJjZSAgICAgVGhlIHNvdXJjZSBub2RlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIHRhcmdldCAgICAgVGhlIHRhcmdldCBub2RlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9ICAgICAgICAgICAgIHNldHRpbmdzICAgVGhlIHNldHRpbmdzIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGNyZWF0ZTogZnVuY3Rpb24oZWRnZSwgc291cmNlLCB0YXJnZXQsIHNldHRpbmdzKSB7XG4gICAgICB2YXIgY29sb3IgPSBlZGdlLmNvbG9yLFxuICAgICAgICAgIHByZWZpeCA9IHNldHRpbmdzKCdwcmVmaXgnKSB8fCAnJyxcbiAgICAgICAgICBlZGdlQ29sb3IgPSBzZXR0aW5ncygnZWRnZUNvbG9yJyksXG4gICAgICAgICAgZGVmYXVsdE5vZGVDb2xvciA9IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJyksXG4gICAgICAgICAgZGVmYXVsdEVkZ2VDb2xvciA9IHNldHRpbmdzKCdkZWZhdWx0RWRnZUNvbG9yJyk7XG5cbiAgICAgIGlmICghY29sb3IpXG4gICAgICAgIHN3aXRjaCAoZWRnZUNvbG9yKSB7XG4gICAgICAgICAgY2FzZSAnc291cmNlJzpcbiAgICAgICAgICAgIGNvbG9yID0gc291cmNlLmNvbG9yIHx8IGRlZmF1bHROb2RlQ29sb3I7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICd0YXJnZXQnOlxuICAgICAgICAgICAgY29sb3IgPSB0YXJnZXQuY29sb3IgfHwgZGVmYXVsdE5vZGVDb2xvcjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjb2xvciA9IGRlZmF1bHRFZGdlQ29sb3I7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICB2YXIgcGF0aCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhzZXR0aW5ncygneG1sbnMnKSwgJ3BhdGgnKTtcblxuICAgICAgLy8gQXR0cmlidXRlc1xuICAgICAgcGF0aC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZGF0YS1lZGdlLWlkJywgZWRnZS5pZCk7XG4gICAgICBwYXRoLnNldEF0dHJpYnV0ZU5TKG51bGwsICdjbGFzcycsIHNldHRpbmdzKCdjbGFzc1ByZWZpeCcpICsgJy1lZGdlJyk7XG4gICAgICBwYXRoLnNldEF0dHJpYnV0ZU5TKG51bGwsICdzdHJva2UnLCBjb2xvcik7XG5cbiAgICAgIHJldHVybiBwYXRoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTVkcgRWxlbWVudCB1cGRhdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIGVkZ2UgICAgICAgVGhlIGVkZ2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSAge0RPTUVsZW1lbnR9ICAgICAgICAgICAgICAgbGluZSAgICAgICBUaGUgbGluZSBET00gRWxlbWVudC5cbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIHNvdXJjZSAgICAgVGhlIHNvdXJjZSBub2RlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIHRhcmdldCAgICAgVGhlIHRhcmdldCBub2RlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9ICAgICAgICAgICAgIHNldHRpbmdzICAgVGhlIHNldHRpbmdzIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIHVwZGF0ZTogZnVuY3Rpb24oZWRnZSwgcGF0aCwgc291cmNlLCB0YXJnZXQsIHNldHRpbmdzKSB7XG4gICAgICB2YXIgcHJlZml4ID0gc2V0dGluZ3MoJ3ByZWZpeCcpIHx8ICcnO1xuXG4gICAgICBwYXRoLnNldEF0dHJpYnV0ZU5TKG51bGwsICdzdHJva2Utd2lkdGgnLCBlZGdlW3ByZWZpeCArICdzaXplJ10gfHwgMSk7XG5cbiAgICAgIC8vIENvbnRyb2wgcG9pbnRcbiAgICAgIHZhciBjeCA9IChzb3VyY2VbcHJlZml4ICsgJ3gnXSArIHRhcmdldFtwcmVmaXggKyAneCddKSAvIDIgK1xuICAgICAgICAodGFyZ2V0W3ByZWZpeCArICd5J10gLSBzb3VyY2VbcHJlZml4ICsgJ3knXSkgLyA0LFxuICAgICAgICAgIGN5ID0gKHNvdXJjZVtwcmVmaXggKyAneSddICsgdGFyZ2V0W3ByZWZpeCArICd5J10pIC8gMiArXG4gICAgICAgIChzb3VyY2VbcHJlZml4ICsgJ3gnXSAtIHRhcmdldFtwcmVmaXggKyAneCddKSAvIDQ7XG5cbiAgICAgIC8vIFBhdGhcbiAgICAgIHZhciBwID0gJ00nICsgc291cmNlW3ByZWZpeCArICd4J10gKyAnLCcgKyBzb3VyY2VbcHJlZml4ICsgJ3knXSArICcgJyArXG4gICAgICAgICAgICAgICdRJyArIGN4ICsgJywnICsgY3kgKyAnICcgK1xuICAgICAgICAgICAgICB0YXJnZXRbcHJlZml4ICsgJ3gnXSArICcsJyArIHRhcmdldFtwcmVmaXggKyAneSddO1xuXG4gICAgICAvLyBVcGRhdGluZyBhdHRyaWJ1dGVzXG4gICAgICBwYXRoLnNldEF0dHJpYnV0ZU5TKG51bGwsICdkJywgcCk7XG4gICAgICBwYXRoLnNldEF0dHJpYnV0ZU5TKG51bGwsICdmaWxsJywgJ25vbmUnKTtcblxuICAgICAgLy8gU2hvd2luZ1xuICAgICAgcGF0aC5zdHlsZS5kaXNwbGF5ID0gJyc7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTtcbn0pKCk7XG5cbjsoZnVuY3Rpb24odW5kZWZpbmVkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBpZiAodHlwZW9mIHNpZ21hID09PSAndW5kZWZpbmVkJylcbiAgICB0aHJvdyAnc2lnbWEgaXMgbm90IGRlY2xhcmVkJztcblxuICAvLyBJbml0aWFsaXplIHBhY2thZ2VzOlxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLnN2Zy5sYWJlbHMnKTtcblxuICAvKipcbiAgICogVGhlIGRlZmF1bHQgbGFiZWwgcmVuZGVyZXIuIEl0IHJlbmRlcnMgdGhlIGxhYmVsIGFzIGEgc2ltcGxlIHRleHQuXG4gICAqL1xuICBzaWdtYS5zdmcubGFiZWxzLmRlZiA9IHtcblxuICAgIC8qKlxuICAgICAqIFNWRyBFbGVtZW50IGNyZWF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBub2RlICAgICAgIFRoZSBub2RlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9ICAgICAgICAgICAgIHNldHRpbmdzICAgVGhlIHNldHRpbmdzIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGNyZWF0ZTogZnVuY3Rpb24obm9kZSwgc2V0dGluZ3MpIHtcbiAgICAgIHZhciBwcmVmaXggPSBzZXR0aW5ncygncHJlZml4JykgfHwgJycsXG4gICAgICAgICAgc2l6ZSA9IG5vZGVbcHJlZml4ICsgJ3NpemUnXSxcbiAgICAgICAgICB0ZXh0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHNldHRpbmdzKCd4bWxucycpLCAndGV4dCcpO1xuXG4gICAgICB2YXIgZm9udFNpemUgPSAoc2V0dGluZ3MoJ2xhYmVsU2l6ZScpID09PSAnZml4ZWQnKSA/XG4gICAgICAgIHNldHRpbmdzKCdkZWZhdWx0TGFiZWxTaXplJykgOlxuICAgICAgICBzZXR0aW5ncygnbGFiZWxTaXplUmF0aW8nKSAqIHNpemU7XG5cbiAgICAgIHZhciBmb250Q29sb3IgPSAoc2V0dGluZ3MoJ2xhYmVsQ29sb3InKSA9PT0gJ25vZGUnKSA/XG4gICAgICAgIChub2RlLmNvbG9yIHx8IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJykpIDpcbiAgICAgICAgc2V0dGluZ3MoJ2RlZmF1bHRMYWJlbENvbG9yJyk7XG5cbiAgICAgIHRleHQuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2RhdGEtbGFiZWwtdGFyZ2V0Jywgbm9kZS5pZCk7XG4gICAgICB0ZXh0LnNldEF0dHJpYnV0ZU5TKG51bGwsICdjbGFzcycsIHNldHRpbmdzKCdjbGFzc1ByZWZpeCcpICsgJy1sYWJlbCcpO1xuICAgICAgdGV4dC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZm9udC1zaXplJywgZm9udFNpemUpO1xuICAgICAgdGV4dC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZm9udC1mYW1pbHknLCBzZXR0aW5ncygnZm9udCcpKTtcbiAgICAgIHRleHQuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2ZpbGwnLCBmb250Q29sb3IpO1xuXG4gICAgICB0ZXh0LmlubmVySFRNTCA9IG5vZGUubGFiZWw7XG4gICAgICB0ZXh0LnRleHRDb250ZW50ID0gbm9kZS5sYWJlbDtcblxuICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNWRyBFbGVtZW50IHVwZGF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgbm9kZSAgICAgVGhlIG5vZGUgb2JqZWN0LlxuICAgICAqIEBwYXJhbSAge0RPTUVsZW1lbnR9ICAgICAgICAgICAgICAgdGV4dCAgICAgVGhlIGxhYmVsIERPTSBlbGVtZW50LlxuICAgICAqIEBwYXJhbSAge2NvbmZpZ3VyYWJsZX0gICAgICAgICAgICAgc2V0dGluZ3MgVGhlIHNldHRpbmdzIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIHVwZGF0ZTogZnVuY3Rpb24obm9kZSwgdGV4dCwgc2V0dGluZ3MpIHtcbiAgICAgIHZhciBwcmVmaXggPSBzZXR0aW5ncygncHJlZml4JykgfHwgJycsXG4gICAgICAgICAgc2l6ZSA9IG5vZGVbcHJlZml4ICsgJ3NpemUnXTtcblxuICAgICAgdmFyIGZvbnRTaXplID0gKHNldHRpbmdzKCdsYWJlbFNpemUnKSA9PT0gJ2ZpeGVkJykgP1xuICAgICAgICBzZXR0aW5ncygnZGVmYXVsdExhYmVsU2l6ZScpIDpcbiAgICAgICAgc2V0dGluZ3MoJ2xhYmVsU2l6ZVJhdGlvJykgKiBzaXplO1xuXG4gICAgICAvLyBDYXNlIHdoZW4gd2UgZG9uJ3Qgd2FudCB0byBkaXNwbGF5IHRoZSBsYWJlbFxuICAgICAgaWYgKCFzZXR0aW5ncygnZm9yY2VMYWJlbHMnKSAmJiBzaXplIDwgc2V0dGluZ3MoJ2xhYmVsVGhyZXNob2xkJykpXG4gICAgICAgIHJldHVybjtcblxuICAgICAgaWYgKHR5cGVvZiBub2RlLmxhYmVsICE9PSAnc3RyaW5nJylcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICAvLyBVcGRhdGluZ1xuICAgICAgdGV4dC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAneCcsXG4gICAgICAgIE1hdGgucm91bmQobm9kZVtwcmVmaXggKyAneCddICsgc2l6ZSArIDMpKTtcbiAgICAgIHRleHQuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3knLFxuICAgICAgICBNYXRoLnJvdW5kKG5vZGVbcHJlZml4ICsgJ3knXSArIGZvbnRTaXplIC8gMykpO1xuXG4gICAgICAvLyBTaG93aW5nXG4gICAgICB0ZXh0LnN0eWxlLmRpc3BsYXkgPSAnJztcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9O1xufSkuY2FsbCh0aGlzKTtcblxuOyhmdW5jdGlvbih1bmRlZmluZWQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmICh0eXBlb2Ygc2lnbWEgPT09ICd1bmRlZmluZWQnKVxuICAgIHRocm93ICdzaWdtYSBpcyBub3QgZGVjbGFyZWQnO1xuXG4gIC8vIEluaXRpYWxpemUgcGFja2FnZXM6XG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuc3ZnLmhvdmVycycpO1xuXG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCBob3ZlciByZW5kZXJlci5cbiAgICovXG4gIHNpZ21hLnN2Zy5ob3ZlcnMuZGVmID0ge1xuXG4gICAgLyoqXG4gICAgICogU1ZHIEVsZW1lbnQgY3JlYXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICBub2RlICAgICAgICAgICAgICAgVGhlIG5vZGUgb2JqZWN0LlxuICAgICAqIEBwYXJhbSAge0NhbnZhc0VsZW1lbnR9ICAgIG1lYXN1cmVtZW50Q2FudmFzICBBIGZha2UgY2FudmFzIGhhbmRsZWQgYnlcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgc3ZnIHRvIHBlcmZvcm0gc29tZSBtZWFzdXJlbWVudHMgYW5kXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFzc2VkIGJ5IHRoZSByZW5kZXJlci5cbiAgICAgKiBAcGFyYW0gIHtET01FbGVtZW50fSAgICAgICBub2RlQ2lyY2xlICAgICAgICAgVGhlIG5vZGUgRE9NIEVsZW1lbnQuXG4gICAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSAgICAgc2V0dGluZ3MgICAgICAgICAgIFRoZSBzZXR0aW5ncyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBjcmVhdGU6IGZ1bmN0aW9uKG5vZGUsIG5vZGVDaXJjbGUsIG1lYXN1cmVtZW50Q2FudmFzLCBzZXR0aW5ncykge1xuXG4gICAgICAvLyBEZWZpbmluZyB2aXN1YWwgcHJvcGVydGllc1xuICAgICAgdmFyIHgsXG4gICAgICAgICAgeSxcbiAgICAgICAgICB3LFxuICAgICAgICAgIGgsXG4gICAgICAgICAgZSxcbiAgICAgICAgICBkLFxuICAgICAgICAgIGZvbnRTdHlsZSA9IHNldHRpbmdzKCdob3ZlckZvbnRTdHlsZScpIHx8IHNldHRpbmdzKCdmb250U3R5bGUnKSxcbiAgICAgICAgICBwcmVmaXggPSBzZXR0aW5ncygncHJlZml4JykgfHwgJycsXG4gICAgICAgICAgc2l6ZSA9IG5vZGVbcHJlZml4ICsgJ3NpemUnXSxcbiAgICAgICAgICBmb250U2l6ZSA9IChzZXR0aW5ncygnbGFiZWxTaXplJykgPT09ICdmaXhlZCcpID9cbiAgICAgICAgICAgIHNldHRpbmdzKCdkZWZhdWx0TGFiZWxTaXplJykgOlxuICAgICAgICAgICAgc2V0dGluZ3MoJ2xhYmVsU2l6ZVJhdGlvJykgKiBzaXplLFxuICAgICAgICAgIGZvbnRDb2xvciA9IChzZXR0aW5ncygnbGFiZWxIb3ZlckNvbG9yJykgPT09ICdub2RlJykgP1xuICAgICAgICAgICAgICAgICAgICAgICAgKG5vZGUuY29sb3IgfHwgc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MoJ2RlZmF1bHRMYWJlbEhvdmVyQ29sb3InKTtcblxuICAgICAgLy8gQ3JlYXRpbmcgZWxlbWVudHNcbiAgICAgIHZhciBncm91cCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhzZXR0aW5ncygneG1sbnMnKSwgJ2cnKSxcbiAgICAgICAgICByZWN0YW5nbGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoc2V0dGluZ3MoJ3htbG5zJyksICdyZWN0JyksXG4gICAgICAgICAgY2lyY2xlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHNldHRpbmdzKCd4bWxucycpLCAnY2lyY2xlJyksXG4gICAgICAgICAgdGV4dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhzZXR0aW5ncygneG1sbnMnKSwgJ3RleHQnKTtcblxuICAgICAgLy8gRGVmaW5pbmcgcHJvcGVydGllc1xuICAgICAgZ3JvdXAuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2NsYXNzJywgc2V0dGluZ3MoJ2NsYXNzUHJlZml4JykgKyAnLWhvdmVyJyk7XG4gICAgICBncm91cC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZGF0YS1ub2RlLWlkJywgbm9kZS5pZCk7XG5cbiAgICAgIGlmICh0eXBlb2Ygbm9kZS5sYWJlbCA9PT0gJ3N0cmluZycpIHtcblxuICAgICAgICAvLyBUZXh0XG4gICAgICAgIHRleHQuaW5uZXJIVE1MID0gbm9kZS5sYWJlbDtcbiAgICAgICAgdGV4dC50ZXh0Q29udGVudCA9IG5vZGUubGFiZWw7XG4gICAgICAgIHRleHQuc2V0QXR0cmlidXRlTlMoXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgJ2NsYXNzJyxcbiAgICAgICAgICAgIHNldHRpbmdzKCdjbGFzc1ByZWZpeCcpICsgJy1ob3Zlci1sYWJlbCcpO1xuICAgICAgICB0ZXh0LnNldEF0dHJpYnV0ZU5TKG51bGwsICdmb250LXNpemUnLCBmb250U2l6ZSk7XG4gICAgICAgIHRleHQuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2ZvbnQtZmFtaWx5Jywgc2V0dGluZ3MoJ2ZvbnQnKSk7XG4gICAgICAgIHRleHQuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2ZpbGwnLCBmb250Q29sb3IpO1xuICAgICAgICB0ZXh0LnNldEF0dHJpYnV0ZU5TKG51bGwsICd4JyxcbiAgICAgICAgICBNYXRoLnJvdW5kKG5vZGVbcHJlZml4ICsgJ3gnXSArIHNpemUgKyAzKSk7XG4gICAgICAgIHRleHQuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3knLFxuICAgICAgICAgIE1hdGgucm91bmQobm9kZVtwcmVmaXggKyAneSddICsgZm9udFNpemUgLyAzKSk7XG5cbiAgICAgICAgLy8gTWVhc3VyZXNcbiAgICAgICAgLy8gT1BUSU1JWkU6IEZpbmQgYSBiZXR0ZXIgd2F5IHRoYW4gYSBtZWFzdXJlbWVudCBjYW52YXNcbiAgICAgICAgeCA9IE1hdGgucm91bmQobm9kZVtwcmVmaXggKyAneCddIC0gZm9udFNpemUgLyAyIC0gMik7XG4gICAgICAgIHkgPSBNYXRoLnJvdW5kKG5vZGVbcHJlZml4ICsgJ3knXSAtIGZvbnRTaXplIC8gMiAtIDIpO1xuICAgICAgICB3ID0gTWF0aC5yb3VuZChcbiAgICAgICAgICBtZWFzdXJlbWVudENhbnZhcy5tZWFzdXJlVGV4dChub2RlLmxhYmVsKS53aWR0aCArXG4gICAgICAgICAgICBmb250U2l6ZSAvIDIgKyBzaXplICsgOVxuICAgICAgICApO1xuICAgICAgICBoID0gTWF0aC5yb3VuZChmb250U2l6ZSArIDQpO1xuICAgICAgICBlID0gTWF0aC5yb3VuZChmb250U2l6ZSAvIDIgKyAyKTtcblxuICAgICAgICAvLyBDaXJjbGVcbiAgICAgICAgY2lyY2xlLnNldEF0dHJpYnV0ZU5TKFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICdjbGFzcycsXG4gICAgICAgICAgICBzZXR0aW5ncygnY2xhc3NQcmVmaXgnKSArICctaG92ZXItYXJlYScpO1xuICAgICAgICBjaXJjbGUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2ZpbGwnLCAnI2ZmZicpO1xuICAgICAgICBjaXJjbGUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2N4Jywgbm9kZVtwcmVmaXggKyAneCddKTtcbiAgICAgICAgY2lyY2xlLnNldEF0dHJpYnV0ZU5TKG51bGwsICdjeScsIG5vZGVbcHJlZml4ICsgJ3knXSk7XG4gICAgICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAncicsIGUpO1xuXG4gICAgICAgIC8vIFJlY3RhbmdsZVxuICAgICAgICByZWN0YW5nbGUuc2V0QXR0cmlidXRlTlMoXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgJ2NsYXNzJyxcbiAgICAgICAgICAgIHNldHRpbmdzKCdjbGFzc1ByZWZpeCcpICsgJy1ob3Zlci1hcmVhJyk7XG4gICAgICAgIHJlY3RhbmdsZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZmlsbCcsICcjZmZmJyk7XG4gICAgICAgIHJlY3RhbmdsZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAneCcsIG5vZGVbcHJlZml4ICsgJ3gnXSArIGUgLyA0KTtcbiAgICAgICAgcmVjdGFuZ2xlLnNldEF0dHJpYnV0ZU5TKG51bGwsICd5Jywgbm9kZVtwcmVmaXggKyAneSddIC0gZSk7XG4gICAgICAgIHJlY3RhbmdsZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnd2lkdGgnLCB3KTtcbiAgICAgICAgcmVjdGFuZ2xlLnNldEF0dHJpYnV0ZU5TKG51bGwsICdoZWlnaHQnLCBoKTtcbiAgICAgIH1cblxuICAgICAgLy8gQXBwZW5kaW5nIGNoaWxkc1xuICAgICAgZ3JvdXAuYXBwZW5kQ2hpbGQoY2lyY2xlKTtcbiAgICAgIGdyb3VwLmFwcGVuZENoaWxkKHJlY3RhbmdsZSk7XG4gICAgICBncm91cC5hcHBlbmRDaGlsZCh0ZXh0KTtcbiAgICAgIGdyb3VwLmFwcGVuZENoaWxkKG5vZGVDaXJjbGUpO1xuXG4gICAgICByZXR1cm4gZ3JvdXA7XG4gICAgfVxuICB9O1xufSkuY2FsbCh0aGlzKTtcblxuOyhmdW5jdGlvbih1bmRlZmluZWQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmICh0eXBlb2Ygc2lnbWEgPT09ICd1bmRlZmluZWQnKVxuICAgIHRocm93ICdzaWdtYSBpcyBub3QgZGVjbGFyZWQnO1xuXG4gIC8vIEluaXRpYWxpemUgcGFja2FnZXM6XG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEubWlkZGxld2FyZXMnKTtcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS51dGlscycpO1xuXG4gIC8qKlxuICAgKiBUaGlzIG1pZGRsZXdhcmUgd2lsbCByZXNjYWxlIHRoZSBncmFwaCBzdWNoIHRoYXQgaXQgdGFrZXMgYW4gb3B0aW1hbCBzcGFjZVxuICAgKiBvbiB0aGUgcmVuZGVyZXIuXG4gICAqXG4gICAqIEFzIGVhY2ggbWlkZGxld2FyZSwgdGhpcyBmdW5jdGlvbiBpcyBleGVjdXRlZCBpbiB0aGUgc2NvcGUgb2YgdGhlIHNpZ21hXG4gICAqIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IHJlYWRQcmVmaXggIFRoZSByZWFkIHByZWZpeC5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSB3cml0ZVByZWZpeCBUaGUgd3JpdGUgcHJlZml4LlxuICAgKiBAcGFyYW0ge29iamVjdH0gIG9wdGlvbnMgICAgIFRoZSBwYXJhbWV0ZXJzLlxuICAgKi9cbiAgc2lnbWEubWlkZGxld2FyZXMucmVzY2FsZSA9IGZ1bmN0aW9uKHJlYWRQcmVmaXgsIHdyaXRlUHJlZml4LCBvcHRpb25zKSB7XG4gICAgdmFyIGksXG4gICAgICAgIGwsXG4gICAgICAgIGEsXG4gICAgICAgIGIsXG4gICAgICAgIGMsXG4gICAgICAgIGQsXG4gICAgICAgIHNjYWxlLFxuICAgICAgICBtYXJnaW4sXG4gICAgICAgIG4gPSB0aGlzLmdyYXBoLm5vZGVzKCksXG4gICAgICAgIGUgPSB0aGlzLmdyYXBoLmVkZ2VzKCksXG4gICAgICAgIHNldHRpbmdzID0gdGhpcy5zZXR0aW5ncy5lbWJlZE9iamVjdHMob3B0aW9ucyB8fCB7fSksXG4gICAgICAgIGJvdW5kcyA9IHNldHRpbmdzKCdib3VuZHMnKSB8fCBzaWdtYS51dGlscy5nZXRCb3VuZGFyaWVzKFxuICAgICAgICAgIHRoaXMuZ3JhcGgsXG4gICAgICAgICAgcmVhZFByZWZpeCxcbiAgICAgICAgICB0cnVlXG4gICAgICAgICksXG4gICAgICAgIG1pblggPSBib3VuZHMubWluWCxcbiAgICAgICAgbWluWSA9IGJvdW5kcy5taW5ZLFxuICAgICAgICBtYXhYID0gYm91bmRzLm1heFgsXG4gICAgICAgIG1heFkgPSBib3VuZHMubWF4WSxcbiAgICAgICAgc2l6ZU1heCA9IGJvdW5kcy5zaXplTWF4LFxuICAgICAgICB3ZWlnaHRNYXggPSBib3VuZHMud2VpZ2h0TWF4LFxuICAgICAgICB3ID0gc2V0dGluZ3MoJ3dpZHRoJykgfHwgMSxcbiAgICAgICAgaCA9IHNldHRpbmdzKCdoZWlnaHQnKSB8fCAxLFxuICAgICAgICByZXNjYWxlU2V0dGluZ3MgPSBzZXR0aW5ncygnYXV0b1Jlc2NhbGUnKSxcbiAgICAgICAgdmFsaWRTZXR0aW5ncyA9IHtcbiAgICAgICAgICBub2RlUG9zaXRpb246IDEsXG4gICAgICAgICAgbm9kZVNpemU6IDEsXG4gICAgICAgICAgZWRnZVNpemU6IDFcbiAgICAgICAgfTtcblxuICAgIC8qKlxuICAgICAqIFdoYXQgZWxlbWVudHMgc2hvdWxkIHdlIHJlc2NhbGU/XG4gICAgICovXG4gICAgaWYgKCEocmVzY2FsZVNldHRpbmdzIGluc3RhbmNlb2YgQXJyYXkpKVxuICAgICAgcmVzY2FsZVNldHRpbmdzID0gWydub2RlUG9zaXRpb24nLCAnbm9kZVNpemUnLCAnZWRnZVNpemUnXTtcblxuICAgIGZvciAoaSA9IDAsIGwgPSByZXNjYWxlU2V0dGluZ3MubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgaWYgKCF2YWxpZFNldHRpbmdzW3Jlc2NhbGVTZXR0aW5nc1tpXV0pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnVGhlIHJlc2NhbGUgc2V0dGluZyBcIicgKyByZXNjYWxlU2V0dGluZ3NbaV0gKyAnXCIgaXMgbm90IHJlY29nbml6ZWQuJ1xuICAgICAgICApO1xuXG4gICAgdmFyIG5wID0gfnJlc2NhbGVTZXR0aW5ncy5pbmRleE9mKCdub2RlUG9zaXRpb24nKSxcbiAgICAgICAgbnMgPSB+cmVzY2FsZVNldHRpbmdzLmluZGV4T2YoJ25vZGVTaXplJyksXG4gICAgICAgIGVzID0gfnJlc2NhbGVTZXR0aW5ncy5pbmRleE9mKCdlZGdlU2l6ZScpO1xuXG4gICAgLyoqXG4gICAgICogRmlyc3QsIHdlIGNvbXB1dGUgdGhlIHNjYWxpbmcgcmF0aW8sIHdpdGhvdXQgY29uc2lkZXJpbmcgdGhlIHNpemVzXG4gICAgICogb2YgdGhlIG5vZGVzIDogRWFjaCBub2RlIHdpbGwgaGF2ZSBpdHMgY2VudGVyIGluIHRoZSBjYW52YXMsIGJ1dCBtaWdodFxuICAgICAqIGJlIHBhcnRpYWxseSBvdXQgb2YgaXQuXG4gICAgICovXG4gICAgc2NhbGUgPSBzZXR0aW5ncygnc2NhbGluZ01vZGUnKSA9PT0gJ291dHNpZGUnID9cbiAgICAgIE1hdGgubWF4KFxuICAgICAgICB3IC8gTWF0aC5tYXgobWF4WCAtIG1pblgsIDEpLFxuICAgICAgICBoIC8gTWF0aC5tYXgobWF4WSAtIG1pblksIDEpXG4gICAgICApIDpcbiAgICAgIE1hdGgubWluKFxuICAgICAgICB3IC8gTWF0aC5tYXgobWF4WCAtIG1pblgsIDEpLFxuICAgICAgICBoIC8gTWF0aC5tYXgobWF4WSAtIG1pblksIDEpXG4gICAgICApO1xuXG4gICAgLyoqXG4gICAgICogVGhlbiwgd2UgY29ycmVjdCB0aGF0IHNjYWxpbmcgcmF0aW8gY29uc2lkZXJpbmcgYSBtYXJnaW4sIHdoaWNoIGlzXG4gICAgICogYmFzaWNhbGx5IHRoZSBzaXplIG9mIHRoZSBiaWdnZXN0IG5vZGUuXG4gICAgICogVGhpcyBoYXMgdG8gYmUgZG9uZSBhcyBhIGNvcnJlY3Rpb24gc2luY2UgdG8gY29tcGFyZSB0aGUgc2l6ZSBvZiB0aGVcbiAgICAgKiBiaWdnZXN0IG5vZGUgdG8gdGhlIFggYW5kIFkgdmFsdWVzLCB3ZSBoYXZlIHRvIGZpcnN0IGdldCBhblxuICAgICAqIGFwcHJveGltYXRpb24gb2YgdGhlIHNjYWxpbmcgcmF0aW8uXG4gICAgICoqL1xuICAgIG1hcmdpbiA9XG4gICAgICAoXG4gICAgICAgIHNldHRpbmdzKCdyZXNjYWxlSWdub3JlU2l6ZScpID9cbiAgICAgICAgICAwIDpcbiAgICAgICAgICAoc2V0dGluZ3MoJ21heE5vZGVTaXplJykgfHwgc2l6ZU1heCkgLyBzY2FsZVxuICAgICAgKSArXG4gICAgICAoc2V0dGluZ3MoJ3NpZGVNYXJnaW4nKSB8fCAwKTtcbiAgICBtYXhYICs9IG1hcmdpbjtcbiAgICBtaW5YIC09IG1hcmdpbjtcbiAgICBtYXhZICs9IG1hcmdpbjtcbiAgICBtaW5ZIC09IG1hcmdpbjtcblxuICAgIC8vIEZpeCB0aGUgc2NhbGluZyB3aXRoIHRoZSBuZXcgZXh0cmVtYTpcbiAgICBzY2FsZSA9IHNldHRpbmdzKCdzY2FsaW5nTW9kZScpID09PSAnb3V0c2lkZScgP1xuICAgICAgTWF0aC5tYXgoXG4gICAgICAgIHcgLyBNYXRoLm1heChtYXhYIC0gbWluWCwgMSksXG4gICAgICAgIGggLyBNYXRoLm1heChtYXhZIC0gbWluWSwgMSlcbiAgICAgICkgOlxuICAgICAgTWF0aC5taW4oXG4gICAgICAgIHcgLyBNYXRoLm1heChtYXhYIC0gbWluWCwgMSksXG4gICAgICAgIGggLyBNYXRoLm1heChtYXhZIC0gbWluWSwgMSlcbiAgICAgICk7XG5cbiAgICAvLyBTaXplIGhvbW90aGV0aWMgcGFyYW1ldGVyczpcbiAgICBpZiAoIXNldHRpbmdzKCdtYXhOb2RlU2l6ZScpICYmICFzZXR0aW5ncygnbWluTm9kZVNpemUnKSkge1xuICAgICAgYSA9IDE7XG4gICAgICBiID0gMDtcbiAgICB9IGVsc2UgaWYgKHNldHRpbmdzKCdtYXhOb2RlU2l6ZScpID09PSBzZXR0aW5ncygnbWluTm9kZVNpemUnKSkge1xuICAgICAgYSA9IDA7XG4gICAgICBiID0gK3NldHRpbmdzKCdtYXhOb2RlU2l6ZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhID0gKHNldHRpbmdzKCdtYXhOb2RlU2l6ZScpIC0gc2V0dGluZ3MoJ21pbk5vZGVTaXplJykpIC8gc2l6ZU1heDtcbiAgICAgIGIgPSArc2V0dGluZ3MoJ21pbk5vZGVTaXplJyk7XG4gICAgfVxuXG4gICAgaWYgKCFzZXR0aW5ncygnbWF4RWRnZVNpemUnKSAmJiAhc2V0dGluZ3MoJ21pbkVkZ2VTaXplJykpIHtcbiAgICAgIGMgPSAxO1xuICAgICAgZCA9IDA7XG4gICAgfSBlbHNlIGlmIChzZXR0aW5ncygnbWF4RWRnZVNpemUnKSA9PT0gc2V0dGluZ3MoJ21pbkVkZ2VTaXplJykpIHtcbiAgICAgIGMgPSAwO1xuICAgICAgZCA9ICtzZXR0aW5ncygnbWluRWRnZVNpemUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYyA9IChzZXR0aW5ncygnbWF4RWRnZVNpemUnKSAtIHNldHRpbmdzKCdtaW5FZGdlU2l6ZScpKSAvIHdlaWdodE1heDtcbiAgICAgIGQgPSArc2V0dGluZ3MoJ21pbkVkZ2VTaXplJyk7XG4gICAgfVxuXG4gICAgLy8gUmVzY2FsZSB0aGUgbm9kZXMgYW5kIGVkZ2VzOlxuICAgIGZvciAoaSA9IDAsIGwgPSBlLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgIGVbaV1bd3JpdGVQcmVmaXggKyAnc2l6ZSddID1cbiAgICAgICAgZVtpXVtyZWFkUHJlZml4ICsgJ3NpemUnXSAqIChlcyA/IGMgOiAxKSArIChlcyA/IGQgOiAwKTtcblxuICAgIGZvciAoaSA9IDAsIGwgPSBuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgbltpXVt3cml0ZVByZWZpeCArICdzaXplJ10gPVxuICAgICAgICBuW2ldW3JlYWRQcmVmaXggKyAnc2l6ZSddICogKG5zID8gYSA6IDEpICsgKG5zID8gYiA6IDApO1xuICAgICAgbltpXVt3cml0ZVByZWZpeCArICd4J10gPVxuICAgICAgICAobltpXVtyZWFkUHJlZml4ICsgJ3gnXSAtIChtYXhYICsgbWluWCkgLyAyKSAqIChucCA/IHNjYWxlIDogMSk7XG4gICAgICBuW2ldW3dyaXRlUHJlZml4ICsgJ3knXSA9XG4gICAgICAgIChuW2ldW3JlYWRQcmVmaXggKyAneSddIC0gKG1heFkgKyBtaW5ZKSAvIDIpICogKG5wID8gc2NhbGUgOiAxKTtcbiAgICB9XG4gIH07XG5cbiAgc2lnbWEudXRpbHMuZ2V0Qm91bmRhcmllcyA9IGZ1bmN0aW9uKGdyYXBoLCBwcmVmaXgsIGRvRWRnZXMpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgbCxcbiAgICAgICAgZSA9IGdyYXBoLmVkZ2VzKCksXG4gICAgICAgIG4gPSBncmFwaC5ub2RlcygpLFxuICAgICAgICB3ZWlnaHRNYXggPSAtSW5maW5pdHksXG4gICAgICAgIHNpemVNYXggPSAtSW5maW5pdHksXG4gICAgICAgIG1pblggPSBJbmZpbml0eSxcbiAgICAgICAgbWluWSA9IEluZmluaXR5LFxuICAgICAgICBtYXhYID0gLUluZmluaXR5LFxuICAgICAgICBtYXhZID0gLUluZmluaXR5O1xuXG4gICAgaWYgKGRvRWRnZXMpXG4gICAgICBmb3IgKGkgPSAwLCBsID0gZS5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgIHdlaWdodE1heCA9IE1hdGgubWF4KGVbaV1bcHJlZml4ICsgJ3NpemUnXSwgd2VpZ2h0TWF4KTtcblxuICAgIGZvciAoaSA9IDAsIGwgPSBuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgc2l6ZU1heCA9IE1hdGgubWF4KG5baV1bcHJlZml4ICsgJ3NpemUnXSwgc2l6ZU1heCk7XG4gICAgICBtYXhYID0gTWF0aC5tYXgobltpXVtwcmVmaXggKyAneCddLCBtYXhYKTtcbiAgICAgIG1pblggPSBNYXRoLm1pbihuW2ldW3ByZWZpeCArICd4J10sIG1pblgpO1xuICAgICAgbWF4WSA9IE1hdGgubWF4KG5baV1bcHJlZml4ICsgJ3knXSwgbWF4WSk7XG4gICAgICBtaW5ZID0gTWF0aC5taW4obltpXVtwcmVmaXggKyAneSddLCBtaW5ZKTtcbiAgICB9XG5cbiAgICB3ZWlnaHRNYXggPSB3ZWlnaHRNYXggfHwgMTtcbiAgICBzaXplTWF4ID0gc2l6ZU1heCB8fCAxO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHdlaWdodE1heDogd2VpZ2h0TWF4LFxuICAgICAgc2l6ZU1heDogc2l6ZU1heCxcbiAgICAgIG1pblg6IG1pblgsXG4gICAgICBtaW5ZOiBtaW5ZLFxuICAgICAgbWF4WDogbWF4WCxcbiAgICAgIG1heFk6IG1heFlcbiAgICB9O1xuICB9O1xufSkuY2FsbCh0aGlzKTtcblxuOyhmdW5jdGlvbih1bmRlZmluZWQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmICh0eXBlb2Ygc2lnbWEgPT09ICd1bmRlZmluZWQnKVxuICAgIHRocm93ICdzaWdtYSBpcyBub3QgZGVjbGFyZWQnO1xuXG4gIC8vIEluaXRpYWxpemUgcGFja2FnZXM6XG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEubWlkZGxld2FyZXMnKTtcblxuICAvKipcbiAgICogVGhpcyBtaWRkbGV3YXJlIHdpbGwganVzdCBjb3B5IHRoZSBncmFwaGljIHByb3BlcnRpZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gcmVhZFByZWZpeCAgVGhlIHJlYWQgcHJlZml4LlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IHdyaXRlUHJlZml4IFRoZSB3cml0ZSBwcmVmaXguXG4gICAqL1xuICBzaWdtYS5taWRkbGV3YXJlcy5jb3B5ID0gZnVuY3Rpb24ocmVhZFByZWZpeCwgd3JpdGVQcmVmaXgpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgbCxcbiAgICAgICAgYTtcblxuICAgIGlmICh3cml0ZVByZWZpeCArICcnID09PSByZWFkUHJlZml4ICsgJycpXG4gICAgICByZXR1cm47XG5cbiAgICBhID0gdGhpcy5ncmFwaC5ub2RlcygpO1xuICAgIGZvciAoaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgYVtpXVt3cml0ZVByZWZpeCArICd4J10gPSBhW2ldW3JlYWRQcmVmaXggKyAneCddO1xuICAgICAgYVtpXVt3cml0ZVByZWZpeCArICd5J10gPSBhW2ldW3JlYWRQcmVmaXggKyAneSddO1xuICAgICAgYVtpXVt3cml0ZVByZWZpeCArICdzaXplJ10gPSBhW2ldW3JlYWRQcmVmaXggKyAnc2l6ZSddO1xuICAgIH1cblxuICAgIGEgPSB0aGlzLmdyYXBoLmVkZ2VzKCk7XG4gICAgZm9yIChpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgYVtpXVt3cml0ZVByZWZpeCArICdzaXplJ10gPSBhW2ldW3JlYWRQcmVmaXggKyAnc2l6ZSddO1xuICB9O1xufSkuY2FsbCh0aGlzKTtcblxuOyhmdW5jdGlvbih1bmRlZmluZWQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmICh0eXBlb2Ygc2lnbWEgPT09ICd1bmRlZmluZWQnKVxuICAgIHRocm93ICdzaWdtYSBpcyBub3QgZGVjbGFyZWQnO1xuXG4gIC8vIEluaXRpYWxpemUgcGFja2FnZXM6XG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEubWlzYy5hbmltYXRpb24ucnVubmluZycpO1xuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSB1bmlxdWUgSUQgZm9yIHRoZSBhbmltYXRpb24uXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ30gUmV0dXJucyB0aGUgbmV3IElELlxuICAgKi9cbiAgdmFyIF9nZXRJRCA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgaWQgPSAwO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAnJyArICgrK2lkKTtcbiAgICB9O1xuICB9KSgpO1xuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGFuaW1hdGVzIGEgY2FtZXJhLiBJdCBoYXMgdG8gYmUgY2FsbGVkIHdpdGggdGhlIGNhbWVyYSB0b1xuICAgKiBhbmltYXRlLCB0aGUgdmFsdWVzIG9mIHRoZSBjb29yZGluYXRlcyB0byByZWFjaCBhbmQgZXZlbnR1YWxseSBzb21lXG4gICAqIG9wdGlvbnMuIEl0IHJldHVybnMgYSBudW1iZXIgaWQsIHRoYXQgeW91IGNhbiB1c2UgdG8ga2lsbCB0aGUgYW5pbWF0aW9uLFxuICAgKiB3aXRoIHRoZSBtZXRob2Qgc2lnbWEubWlzYy5hbmltYXRpb24ua2lsbChpZCkuXG4gICAqXG4gICAqIFRoZSBhdmFpbGFibGUgb3B0aW9ucyBhcmU6XG4gICAqXG4gICAqICAgez9udW1iZXJ9ICAgICAgICAgICAgZHVyYXRpb24gICBUaGUgZHVyYXRpb24gb2YgdGhlIGFuaW1hdGlvbi5cbiAgICogICB7P2Z1bmN0aW9ufSAgICAgICAgICBvbk5ld0ZyYW1lIEEgY2FsbGJhY2sgdG8gZXhlY3V0ZSB3aGVuIHRoZSBhbmltYXRpb25cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudGVyIGEgbmV3IGZyYW1lLlxuICAgKiAgIHs/ZnVuY3Rpb259ICAgICAgICAgIG9uQ29tcGxldGUgQSBjYWxsYmFjayB0byBleGVjdXRlIHdoZW4gdGhlIGFuaW1hdGlvblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXMgY29tcGxldGVkIG9yIGtpbGxlZC5cbiAgICogICB7PyhzdHJpbmd8ZnVuY3Rpb24pfSBlYXNpbmcgICAgIFRoZSBuYW1lIG9mIGEgZnVuY3Rpb24gZnJvbSB0aGUgcGFja2FnZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lnbWEudXRpbHMuZWFzaW5ncywgb3IgYSBjdXN0b20gZWFzaW5nXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbi5cbiAgICpcbiAgICogQHBhcmFtICB7Y2FtZXJhfSAgY2FtZXJhICBUaGUgY2FtZXJhIHRvIGFuaW1hdGUuXG4gICAqIEBwYXJhbSAge29iamVjdH0gIHRhcmdldCAgVGhlIGNvb3JkaW5hdGVzIHRvIHJlYWNoLlxuICAgKiBAcGFyYW0gIHs/b2JqZWN0fSBvcHRpb25zIEV2ZW50dWFsbHkgYW4gb2JqZWN0IHRvIHNwZWNpZnkgc29tZSBvcHRpb25zIHRvXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIGZ1bmN0aW9uLiBUaGUgYXZhaWxhYmxlIG9wdGlvbnMgYXJlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlc2VudGVkIGluIHRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgZnVuY3Rpb24uXG4gICAqIEByZXR1cm4ge251bWJlcn0gICAgICAgICAgVGhlIGFuaW1hdGlvbiBpZCwgdG8gbWFrZSBpdCBlYXN5IHRvIGtpbGxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdWdoIHRoZSBtZXRob2QgXCJzaWdtYS5taXNjLmFuaW1hdGlvbi5raWxsXCIuXG4gICAqL1xuICBzaWdtYS5taXNjLmFuaW1hdGlvbi5jYW1lcmEgPSBmdW5jdGlvbihjYW1lcmEsIHZhbCwgb3B0aW9ucykge1xuICAgIGlmIChcbiAgICAgICEoY2FtZXJhIGluc3RhbmNlb2Ygc2lnbWEuY2xhc3Nlcy5jYW1lcmEpIHx8XG4gICAgICB0eXBlb2YgdmFsICE9PSAnb2JqZWN0JyB8fFxuICAgICAgIXZhbFxuICAgIClcbiAgICAgIHRocm93ICdhbmltYXRpb24uY2FtZXJhOiBXcm9uZyBhcmd1bWVudHMuJztcblxuICAgIGlmIChcbiAgICAgIHR5cGVvZiB2YWwueCAhPT0gJ251bWJlcicgJiZcbiAgICAgIHR5cGVvZiB2YWwueSAhPT0gJ251bWJlcicgJiZcbiAgICAgIHR5cGVvZiB2YWwucmF0aW8gIT09ICdudW1iZXInICYmXG4gICAgICB0eXBlb2YgdmFsLmFuZ2xlICE9PSAnbnVtYmVyJ1xuICAgIClcbiAgICAgIHRocm93ICdUaGVyZSBtdXN0IGJlIGF0IGxlYXN0IG9uZSB2YWxpZCBjb29yZGluYXRlIGluIHRoZSBnaXZlbiB2YWwuJztcblxuICAgIHZhciBmbixcbiAgICAgICAgaWQsXG4gICAgICAgIGFuaW0sXG4gICAgICAgIGVhc2luZyxcbiAgICAgICAgZHVyYXRpb24sXG4gICAgICAgIGluaXRpYWxWYWwsXG4gICAgICAgIG8gPSBvcHRpb25zIHx8IHt9LFxuICAgICAgICBzdGFydCA9IHNpZ21hLnV0aWxzLmRhdGVOb3coKTtcblxuICAgIC8vIFN0b3JlIGluaXRpYWwgdmFsdWVzOlxuICAgIGluaXRpYWxWYWwgPSB7XG4gICAgICB4OiBjYW1lcmEueCxcbiAgICAgIHk6IGNhbWVyYS55LFxuICAgICAgcmF0aW86IGNhbWVyYS5yYXRpbyxcbiAgICAgIGFuZ2xlOiBjYW1lcmEuYW5nbGVcbiAgICB9O1xuXG4gICAgZHVyYXRpb24gPSBvLmR1cmF0aW9uO1xuICAgIGVhc2luZyA9IHR5cGVvZiBvLmVhc2luZyAhPT0gJ2Z1bmN0aW9uJyA/XG4gICAgICBzaWdtYS51dGlscy5lYXNpbmdzW28uZWFzaW5nIHx8ICdxdWFkcmF0aWNJbk91dCddIDpcbiAgICAgIG8uZWFzaW5nO1xuXG4gICAgZm4gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjb2VmLFxuICAgICAgICAgIHQgPSBvLmR1cmF0aW9uID8gKHNpZ21hLnV0aWxzLmRhdGVOb3coKSAtIHN0YXJ0KSAvIG8uZHVyYXRpb24gOiAxO1xuXG4gICAgICAvLyBJZiB0aGUgYW5pbWF0aW9uIGlzIG92ZXI6XG4gICAgICBpZiAodCA+PSAxKSB7XG4gICAgICAgIGNhbWVyYS5pc0FuaW1hdGVkID0gZmFsc2U7XG4gICAgICAgIGNhbWVyYS5nb1RvKHtcbiAgICAgICAgICB4OiB2YWwueCAhPT0gdW5kZWZpbmVkID8gdmFsLnggOiBpbml0aWFsVmFsLngsXG4gICAgICAgICAgeTogdmFsLnkgIT09IHVuZGVmaW5lZCA/IHZhbC55IDogaW5pdGlhbFZhbC55LFxuICAgICAgICAgIHJhdGlvOiB2YWwucmF0aW8gIT09IHVuZGVmaW5lZCA/IHZhbC5yYXRpbyA6IGluaXRpYWxWYWwucmF0aW8sXG4gICAgICAgICAgYW5nbGU6IHZhbC5hbmdsZSAhPT0gdW5kZWZpbmVkID8gdmFsLmFuZ2xlIDogaW5pdGlhbFZhbC5hbmdsZVxuICAgICAgICB9KTtcblxuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShpZCk7XG4gICAgICAgIGRlbGV0ZSBzaWdtYS5taXNjLmFuaW1hdGlvbi5ydW5uaW5nW2lkXTtcblxuICAgICAgICAvLyBDaGVjayBjYWxsYmFja3M6XG4gICAgICAgIGlmICh0eXBlb2Ygby5vbkNvbXBsZXRlID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgIG8ub25Db21wbGV0ZSgpO1xuXG4gICAgICAvLyBFbHNlLCBsZXQncyBrZWVwIGdvaW5nOlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29lZiA9IGVhc2luZyh0KTtcbiAgICAgICAgY2FtZXJhLmlzQW5pbWF0ZWQgPSB0cnVlO1xuICAgICAgICBjYW1lcmEuZ29Ubyh7XG4gICAgICAgICAgeDogdmFsLnggIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICBpbml0aWFsVmFsLnggKyAodmFsLnggLSBpbml0aWFsVmFsLngpICogY29lZiA6XG4gICAgICAgICAgICBpbml0aWFsVmFsLngsXG4gICAgICAgICAgeTogdmFsLnkgIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICBpbml0aWFsVmFsLnkgKyAodmFsLnkgLSBpbml0aWFsVmFsLnkpICogY29lZiA6XG4gICAgICAgICAgICBpbml0aWFsVmFsLnksXG4gICAgICAgICAgcmF0aW86IHZhbC5yYXRpbyAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgIGluaXRpYWxWYWwucmF0aW8gKyAodmFsLnJhdGlvIC0gaW5pdGlhbFZhbC5yYXRpbykgKiBjb2VmIDpcbiAgICAgICAgICAgIGluaXRpYWxWYWwucmF0aW8sXG4gICAgICAgICAgYW5nbGU6IHZhbC5hbmdsZSAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgIGluaXRpYWxWYWwuYW5nbGUgKyAodmFsLmFuZ2xlIC0gaW5pdGlhbFZhbC5hbmdsZSkgKiBjb2VmIDpcbiAgICAgICAgICAgIGluaXRpYWxWYWwuYW5nbGVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQ2hlY2sgY2FsbGJhY2tzOlxuICAgICAgICBpZiAodHlwZW9mIG8ub25OZXdGcmFtZSA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICBvLm9uTmV3RnJhbWUoKTtcblxuICAgICAgICBhbmltLmZyYW1lSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZm4pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZCA9IF9nZXRJRCgpO1xuICAgIGFuaW0gPSB7XG4gICAgICBmcmFtZUlkOiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZm4pLFxuICAgICAgdGFyZ2V0OiBjYW1lcmEsXG4gICAgICB0eXBlOiAnY2FtZXJhJyxcbiAgICAgIG9wdGlvbnM6IG8sXG4gICAgICBmbjogZm5cbiAgICB9O1xuICAgIHNpZ21hLm1pc2MuYW5pbWF0aW9uLnJ1bm5pbmdbaWRdID0gYW5pbTtcblxuICAgIHJldHVybiBpZDtcbiAgfTtcblxuICAvKipcbiAgICogS2lsbHMgYSBydW5uaW5nIGFuaW1hdGlvbi4gSXQgdHJpZ2dlcnMgdGhlIGV2ZW50dWFsIG9uQ29tcGxldGUgY2FsbGJhY2suXG4gICAqXG4gICAqIEBwYXJhbSAge251bWJlcn0gaWQgIFRoZSBpZCBvZiB0aGUgYW5pbWF0aW9uIHRvIGtpbGwuXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgIFJldHVybnMgdGhlIHNpZ21hLm1pc2MuYW5pbWF0aW9uIHBhY2thZ2UuXG4gICAqL1xuICBzaWdtYS5taXNjLmFuaW1hdGlvbi5raWxsID0gZnVuY3Rpb24oaWQpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMSB8fCB0eXBlb2YgaWQgIT09ICdudW1iZXInKVxuICAgICAgdGhyb3cgJ2FuaW1hdGlvbi5raWxsOiBXcm9uZyBhcmd1bWVudHMuJztcblxuICAgIHZhciBvID0gc2lnbWEubWlzYy5hbmltYXRpb24ucnVubmluZ1tpZF07XG5cbiAgICBpZiAobykge1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoaWQpO1xuICAgICAgZGVsZXRlIHNpZ21hLm1pc2MuYW5pbWF0aW9uLnJ1bm5pbmdbby5mcmFtZUlkXTtcblxuICAgICAgaWYgKG8udHlwZSA9PT0gJ2NhbWVyYScpXG4gICAgICAgIG8udGFyZ2V0LmlzQW5pbWF0ZWQgPSBmYWxzZTtcblxuICAgICAgLy8gQ2hlY2sgY2FsbGJhY2tzOlxuICAgICAgaWYgKHR5cGVvZiAoby5vcHRpb25zIHx8IHt9KS5vbkNvbXBsZXRlID09PSAnZnVuY3Rpb24nKVxuICAgICAgICBvLm9wdGlvbnMub25Db21wbGV0ZSgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBLaWxscyBldmVyeSBydW5uaW5nIGFuaW1hdGlvbnMsIG9yIG9ubHkgdGhlIG9uZSB3aXRoIHRoZSBzcGVjaWZpZWQgdHlwZSxcbiAgICogaWYgYSBzdHJpbmcgcGFyYW1ldGVyIGlzIGdpdmVuLlxuICAgKlxuICAgKiBAcGFyYW0gIHs/KHN0cmluZ3xvYmplY3QpfSBmaWx0ZXIgQSBzdHJpbmcgdG8gZmlsdGVyIHRoZSBhbmltYXRpb25zIHRvIGtpbGxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uIHRoZWlyIHR5cGUgKGV4YW1wbGU6IFwiY2FtZXJhXCIpLCBvciBhblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0IHRvIGZpbHRlciBvbiB0aGVpciB0YXJnZXQuXG4gICAqIEByZXR1cm4ge251bWJlcn0gICAgICAgICAgICAgICAgICBSZXR1cm5zIHRoZSBudW1iZXIgb2YgYW5pbWF0aW9ucyBraWxsZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQgd2F5LlxuICAgKi9cbiAgc2lnbWEubWlzYy5hbmltYXRpb24ua2lsbEFsbCA9IGZ1bmN0aW9uKGZpbHRlcikge1xuICAgIHZhciBvLFxuICAgICAgICBpZCxcbiAgICAgICAgY291bnQgPSAwLFxuICAgICAgICB0eXBlID0gdHlwZW9mIGZpbHRlciA9PT0gJ3N0cmluZycgPyBmaWx0ZXIgOiBudWxsLFxuICAgICAgICB0YXJnZXQgPSB0eXBlb2YgZmlsdGVyID09PSAnb2JqZWN0JyA/IGZpbHRlciA6IG51bGwsXG4gICAgICAgIHJ1bm5pbmcgPSBzaWdtYS5taXNjLmFuaW1hdGlvbi5ydW5uaW5nO1xuXG4gICAgZm9yIChpZCBpbiBydW5uaW5nKVxuICAgICAgaWYgKFxuICAgICAgICAoIXR5cGUgfHwgcnVubmluZ1tpZF0udHlwZSA9PT0gdHlwZSkgJiZcbiAgICAgICAgKCF0YXJnZXQgfHwgcnVubmluZ1tpZF0udGFyZ2V0ID09PSB0YXJnZXQpXG4gICAgICApIHtcbiAgICAgICAgbyA9IHNpZ21hLm1pc2MuYW5pbWF0aW9uLnJ1bm5pbmdbaWRdO1xuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShvLmZyYW1lSWQpO1xuICAgICAgICBkZWxldGUgc2lnbWEubWlzYy5hbmltYXRpb24ucnVubmluZ1tpZF07XG5cbiAgICAgICAgaWYgKG8udHlwZSA9PT0gJ2NhbWVyYScpXG4gICAgICAgICAgby50YXJnZXQuaXNBbmltYXRlZCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIEluY3JlbWVudCBjb3VudGVyOlxuICAgICAgICBjb3VudCsrO1xuXG4gICAgICAgIC8vIENoZWNrIGNhbGxiYWNrczpcbiAgICAgICAgaWYgKHR5cGVvZiAoby5vcHRpb25zIHx8IHt9KS5vbkNvbXBsZXRlID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgIG8ub3B0aW9ucy5vbkNvbXBsZXRlKCk7XG4gICAgICB9XG5cbiAgICByZXR1cm4gY291bnQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgXCJ0cnVlXCIgaWYgYW55IGFuaW1hdGlvbiB0aGF0IGlzIGN1cnJlbnRseSBzdGlsbCBydW5uaW5nIG1hdGNoZXNcbiAgICogdGhlIGZpbHRlciBnaXZlbiB0byB0aGUgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ3xvYmplY3R9IGZpbHRlciBBIHN0cmluZyB0byBmaWx0ZXIgdGhlIGFuaW1hdGlvbnMgdG8ga2lsbFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb24gdGhlaXIgdHlwZSAoZXhhbXBsZTogXCJjYW1lcmFcIiksIG9yIGFuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3QgdG8gZmlsdGVyIG9uIHRoZWlyIHRhcmdldC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gICAgICAgICAgICAgIFJldHVybnMgdHJ1ZSBpZiBhbnkgcnVubmluZyBhbmltYXRpb25cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXMuXG4gICAqL1xuICBzaWdtYS5taXNjLmFuaW1hdGlvbi5oYXMgPSBmdW5jdGlvbihmaWx0ZXIpIHtcbiAgICB2YXIgaWQsXG4gICAgICAgIHR5cGUgPSB0eXBlb2YgZmlsdGVyID09PSAnc3RyaW5nJyA/IGZpbHRlciA6IG51bGwsXG4gICAgICAgIHRhcmdldCA9IHR5cGVvZiBmaWx0ZXIgPT09ICdvYmplY3QnID8gZmlsdGVyIDogbnVsbCxcbiAgICAgICAgcnVubmluZyA9IHNpZ21hLm1pc2MuYW5pbWF0aW9uLnJ1bm5pbmc7XG5cbiAgICBmb3IgKGlkIGluIHJ1bm5pbmcpXG4gICAgICBpZiAoXG4gICAgICAgICghdHlwZSB8fCBydW5uaW5nW2lkXS50eXBlID09PSB0eXBlKSAmJlxuICAgICAgICAoIXRhcmdldCB8fCBydW5uaW5nW2lkXS50YXJnZXQgPT09IHRhcmdldClcbiAgICAgIClcbiAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG59KS5jYWxsKHRoaXMpO1xuXG47KGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgaWYgKHR5cGVvZiBzaWdtYSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgdGhyb3cgJ3NpZ21hIGlzIG5vdCBkZWNsYXJlZCc7XG5cbiAgLy8gSW5pdGlhbGl6ZSBwYWNrYWdlczpcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5taXNjJyk7XG5cbiAgLyoqXG4gICAqIFRoaXMgaGVscGVyIHdpbGwgYmluZCBhbnkgbm8tRE9NIHJlbmRlcmVyIChmb3IgaW5zdGFuY2UgY2FudmFzIG9yIFdlYkdMKVxuICAgKiB0byBpdHMgY2FwdG9ycywgdG8gcHJvcGVybHkgZGlzcGF0Y2ggdGhlIGdvb2QgZXZlbnRzIHRvIHRoZSBzaWdtYSBpbnN0YW5jZVxuICAgKiB0byBtYW5hZ2UgY2xpY2tpbmcsIGhvdmVyaW5nIGV0Yy4uLlxuICAgKlxuICAgKiBJdCBoYXMgdG8gYmUgY2FsbGVkIGluIHRoZSBzY29wZSBvZiB0aGUgcmVsYXRlZCByZW5kZXJlci5cbiAgICovXG4gIHNpZ21hLm1pc2MuYmluZEV2ZW50cyA9IGZ1bmN0aW9uKHByZWZpeCkge1xuICAgIHZhciBpLFxuICAgICAgICBsLFxuICAgICAgICBtWCxcbiAgICAgICAgbVksXG4gICAgICAgIGNhcHRvcixcbiAgICAgICAgc2VsZiA9IHRoaXM7XG5cbiAgICBmdW5jdGlvbiBnZXROb2RlcyhlKSB7XG4gICAgICBpZiAoZSkge1xuICAgICAgICBtWCA9ICd4JyBpbiBlLmRhdGEgPyBlLmRhdGEueCA6IG1YO1xuICAgICAgICBtWSA9ICd5JyBpbiBlLmRhdGEgPyBlLmRhdGEueSA6IG1ZO1xuICAgICAgfVxuXG4gICAgICB2YXIgaSxcbiAgICAgICAgICBqLFxuICAgICAgICAgIGwsXG4gICAgICAgICAgbixcbiAgICAgICAgICB4LFxuICAgICAgICAgIHksXG4gICAgICAgICAgcyxcbiAgICAgICAgICBpbnNlcnRlZCxcbiAgICAgICAgICBzZWxlY3RlZCA9IFtdLFxuICAgICAgICAgIG1vZGlmaWVkWCA9IG1YICsgc2VsZi53aWR0aCAvIDIsXG4gICAgICAgICAgbW9kaWZpZWRZID0gbVkgKyBzZWxmLmhlaWdodCAvIDIsXG4gICAgICAgICAgcG9pbnQgPSBzZWxmLmNhbWVyYS5jYW1lcmFQb3NpdGlvbihcbiAgICAgICAgICAgIG1YLFxuICAgICAgICAgICAgbVlcbiAgICAgICAgICApLFxuICAgICAgICAgIG5vZGVzID0gc2VsZi5jYW1lcmEucXVhZHRyZWUucG9pbnQoXG4gICAgICAgICAgICBwb2ludC54LFxuICAgICAgICAgICAgcG9pbnQueVxuICAgICAgICAgICk7XG5cbiAgICAgIGlmIChub2Rlcy5sZW5ndGgpXG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBub2Rlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBuID0gbm9kZXNbaV07XG4gICAgICAgICAgeCA9IG5bcHJlZml4ICsgJ3gnXTtcbiAgICAgICAgICB5ID0gbltwcmVmaXggKyAneSddO1xuICAgICAgICAgIHMgPSBuW3ByZWZpeCArICdzaXplJ107XG5cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhbi5oaWRkZW4gJiZcbiAgICAgICAgICAgIG1vZGlmaWVkWCA+IHggLSBzICYmXG4gICAgICAgICAgICBtb2RpZmllZFggPCB4ICsgcyAmJlxuICAgICAgICAgICAgbW9kaWZpZWRZID4geSAtIHMgJiZcbiAgICAgICAgICAgIG1vZGlmaWVkWSA8IHkgKyBzICYmXG4gICAgICAgICAgICBNYXRoLnNxcnQoXG4gICAgICAgICAgICAgIE1hdGgucG93KG1vZGlmaWVkWCAtIHgsIDIpICtcbiAgICAgICAgICAgICAgTWF0aC5wb3cobW9kaWZpZWRZIC0geSwgMilcbiAgICAgICAgICAgICkgPCBzXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICAvLyBJbnNlcnQgdGhlIG5vZGU6XG4gICAgICAgICAgICBpbnNlcnRlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgc2VsZWN0ZWQubGVuZ3RoOyBqKyspXG4gICAgICAgICAgICAgIGlmIChuLnNpemUgPiBzZWxlY3RlZFtqXS5zaXplKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWQuc3BsaWNlKGosIDAsIG4pO1xuICAgICAgICAgICAgICAgIGluc2VydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWluc2VydGVkKVxuICAgICAgICAgICAgICBzZWxlY3RlZC5wdXNoKG4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZWN0ZWQ7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBnZXRFZGdlcyhlKSB7XG4gICAgICBpZiAoIXNlbGYuc2V0dGluZ3MoJ2VuYWJsZUVkZ2VIb3ZlcmluZycpKSB7XG4gICAgICAgIC8vIE5vIGV2ZW50IGlmIHRoZSBzZXR0aW5nIGlzIG9mZjpcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuXG4gICAgICB2YXIgaXNDYW52YXMgPSAoXG4gICAgICAgIHNpZ21hLnJlbmRlcmVycy5jYW52YXMgJiYgc2VsZiBpbnN0YW5jZW9mIHNpZ21hLnJlbmRlcmVycy5jYW52YXMpO1xuXG4gICAgICBpZiAoIWlzQ2FudmFzKSB7XG4gICAgICAgIC8vIEEgcXVpY2sgaGFyZGNvZGVkIHJ1bGUgdG8gcHJldmVudCBwZW9wbGUgZnJvbSB1c2luZyB0aGlzIGZlYXR1cmVcbiAgICAgICAgLy8gd2l0aCB0aGUgV2ViR0wgcmVuZGVyZXIgKHdoaWNoIGlzIG5vdCBnb29kIGVub3VnaCBhdCB0aGUgbW9tZW50KTpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdUaGUgZWRnZSBldmVudHMgZmVhdHVyZSBpcyBub3QgY29tcGF0aWJsZSB3aXRoIHRoZSBXZWJHTCByZW5kZXJlcidcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGUpIHtcbiAgICAgICAgbVggPSAneCcgaW4gZS5kYXRhID8gZS5kYXRhLnggOiBtWDtcbiAgICAgICAgbVkgPSAneScgaW4gZS5kYXRhID8gZS5kYXRhLnkgOiBtWTtcbiAgICAgIH1cblxuICAgICAgdmFyIGksXG4gICAgICAgICAgaixcbiAgICAgICAgICBsLFxuICAgICAgICAgIGEsXG4gICAgICAgICAgZWRnZSxcbiAgICAgICAgICBzLFxuICAgICAgICAgIG1heEVwc2lsb24gPSBzZWxmLnNldHRpbmdzKCdlZGdlSG92ZXJQcmVjaXNpb24nKSxcbiAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgIGNwLFxuICAgICAgICAgIG5vZGVJbmRleCA9IHt9LFxuICAgICAgICAgIGluc2VydGVkLFxuICAgICAgICAgIHNlbGVjdGVkID0gW10sXG4gICAgICAgICAgbW9kaWZpZWRYID0gbVggKyBzZWxmLndpZHRoIC8gMixcbiAgICAgICAgICBtb2RpZmllZFkgPSBtWSArIHNlbGYuaGVpZ2h0IC8gMixcbiAgICAgICAgICBwb2ludCA9IHNlbGYuY2FtZXJhLmNhbWVyYVBvc2l0aW9uKFxuICAgICAgICAgICAgbVgsXG4gICAgICAgICAgICBtWVxuICAgICAgICAgICksXG4gICAgICAgICAgZWRnZXMgPSBbXTtcblxuICAgICAgaWYgKGlzQ2FudmFzKSB7XG4gICAgICAgIHZhciBub2Rlc09uU2NyZWVuID0gc2VsZi5jYW1lcmEucXVhZHRyZWUuYXJlYShcbiAgICAgICAgICBzZWxmLmNhbWVyYS5nZXRSZWN0YW5nbGUoc2VsZi53aWR0aCwgc2VsZi5oZWlnaHQpXG4gICAgICAgICk7XG4gICAgICAgIGZvciAoYSA9IG5vZGVzT25TY3JlZW4sIGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgICAgbm9kZUluZGV4W2FbaV0uaWRdID0gYVtpXTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGYuY2FtZXJhLmVkZ2VxdWFkdHJlZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVkZ2VzID0gc2VsZi5jYW1lcmEuZWRnZXF1YWR0cmVlLnBvaW50KFxuICAgICAgICAgIHBvaW50LngsXG4gICAgICAgICAgcG9pbnQueVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpbnNlcnRFZGdlKHNlbGVjdGVkLCBlZGdlKSB7XG4gICAgICAgIGluc2VydGVkID0gZmFsc2U7XG5cbiAgICAgICAgZm9yIChqID0gMDsgaiA8IHNlbGVjdGVkLmxlbmd0aDsgaisrKVxuICAgICAgICAgIGlmIChlZGdlLnNpemUgPiBzZWxlY3RlZFtqXS5zaXplKSB7XG4gICAgICAgICAgICBzZWxlY3RlZC5zcGxpY2UoaiwgMCwgZWRnZSk7XG4gICAgICAgICAgICBpbnNlcnRlZCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpbnNlcnRlZClcbiAgICAgICAgICBzZWxlY3RlZC5wdXNoKGVkZ2UpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWRnZXMubGVuZ3RoKVxuICAgICAgICBmb3IgKGkgPSAwLCBsID0gZWRnZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgZWRnZSA9IGVkZ2VzW2ldO1xuICAgICAgICAgIHNvdXJjZSA9IHNlbGYuZ3JhcGgubm9kZXMoZWRnZS5zb3VyY2UpO1xuICAgICAgICAgIHRhcmdldCA9IHNlbGYuZ3JhcGgubm9kZXMoZWRnZS50YXJnZXQpO1xuICAgICAgICAgIC8vIChIQUNLKSB3ZSBjYW4ndCBnZXQgZWRnZVtwcmVmaXggKyAnc2l6ZSddIG9uIFdlYkdMIHJlbmRlcmVyOlxuICAgICAgICAgIHMgPSBlZGdlW3ByZWZpeCArICdzaXplJ10gfHxcbiAgICAgICAgICAgICAgZWRnZVsncmVhZF8nICsgcHJlZml4ICsgJ3NpemUnXTtcblxuICAgICAgICAgIC8vIEZpcnN0LCBsZXQncyBpZGVudGlmeSB3aGljaCBlZGdlcyBhcmUgZHJhd24uIFRvIGRvIHRoaXMsIHdlIGtlZXBcbiAgICAgICAgICAvLyBldmVyeSBlZGdlcyB0aGF0IGhhdmUgYXQgbGVhc3Qgb25lIGV4dHJlbWl0eSBkaXNwbGF5ZWQgYWNjb3JkaW5nIHRvXG4gICAgICAgICAgLy8gdGhlIHF1YWR0cmVlIGFuZCB0aGUgXCJoaWRkZW5cIiBhdHRyaWJ1dGUuIFdlIGFsc28gZG8gbm90IGtlZXAgaGlkZGVuXG4gICAgICAgICAgLy8gZWRnZXMuXG4gICAgICAgICAgLy8gVGhlbiwgbGV0J3MgY2hlY2sgaWYgdGhlIG1vdXNlIGlzIG9uIHRoZSBlZGdlICh3ZSBzdXBwb3NlIHRoYXQgaXRcbiAgICAgICAgICAvLyBpcyBhIGxpbmUgc2VnbWVudCkuXG5cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhZWRnZS5oaWRkZW4gJiZcbiAgICAgICAgICAgICFzb3VyY2UuaGlkZGVuICYmICF0YXJnZXQuaGlkZGVuICYmXG4gICAgICAgICAgICAoIWlzQ2FudmFzIHx8XG4gICAgICAgICAgICAgIChub2RlSW5kZXhbZWRnZS5zb3VyY2VdIHx8IG5vZGVJbmRleFtlZGdlLnRhcmdldF0pKSAmJlxuICAgICAgICAgICAgc2lnbWEudXRpbHMuZ2V0RGlzdGFuY2UoXG4gICAgICAgICAgICAgIHNvdXJjZVtwcmVmaXggKyAneCddLFxuICAgICAgICAgICAgICBzb3VyY2VbcHJlZml4ICsgJ3knXSxcbiAgICAgICAgICAgICAgbW9kaWZpZWRYLFxuICAgICAgICAgICAgICBtb2RpZmllZFkpID4gc291cmNlW3ByZWZpeCArICdzaXplJ10gJiZcbiAgICAgICAgICAgIHNpZ21hLnV0aWxzLmdldERpc3RhbmNlKFxuICAgICAgICAgICAgICB0YXJnZXRbcHJlZml4ICsgJ3gnXSxcbiAgICAgICAgICAgICAgdGFyZ2V0W3ByZWZpeCArICd5J10sXG4gICAgICAgICAgICAgIG1vZGlmaWVkWCxcbiAgICAgICAgICAgICAgbW9kaWZpZWRZKSA+IHRhcmdldFtwcmVmaXggKyAnc2l6ZSddXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBpZiAoZWRnZS50eXBlID09ICdjdXJ2ZScgfHwgZWRnZS50eXBlID09ICdjdXJ2ZWRBcnJvdycpIHtcbiAgICAgICAgICAgICAgaWYgKHNvdXJjZS5pZCA9PT0gdGFyZ2V0LmlkKSB7XG4gICAgICAgICAgICAgICAgY3AgPSBzaWdtYS51dGlscy5nZXRTZWxmTG9vcENvbnRyb2xQb2ludHMoXG4gICAgICAgICAgICAgICAgICBzb3VyY2VbcHJlZml4ICsgJ3gnXSxcbiAgICAgICAgICAgICAgICAgIHNvdXJjZVtwcmVmaXggKyAneSddLFxuICAgICAgICAgICAgICAgICAgc291cmNlW3ByZWZpeCArICdzaXplJ11cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgIHNpZ21hLnV0aWxzLmlzUG9pbnRPbkJlemllckN1cnZlKFxuICAgICAgICAgICAgICAgICAgbW9kaWZpZWRYLFxuICAgICAgICAgICAgICAgICAgbW9kaWZpZWRZLFxuICAgICAgICAgICAgICAgICAgc291cmNlW3ByZWZpeCArICd4J10sXG4gICAgICAgICAgICAgICAgICBzb3VyY2VbcHJlZml4ICsgJ3knXSxcbiAgICAgICAgICAgICAgICAgIHRhcmdldFtwcmVmaXggKyAneCddLFxuICAgICAgICAgICAgICAgICAgdGFyZ2V0W3ByZWZpeCArICd5J10sXG4gICAgICAgICAgICAgICAgICBjcC54MSxcbiAgICAgICAgICAgICAgICAgIGNwLnkxLFxuICAgICAgICAgICAgICAgICAgY3AueDIsXG4gICAgICAgICAgICAgICAgICBjcC55MixcbiAgICAgICAgICAgICAgICAgIE1hdGgubWF4KHMsIG1heEVwc2lsb24pXG4gICAgICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgICAgICAgaW5zZXJ0RWRnZShzZWxlY3RlZCwgZWRnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNwID0gc2lnbWEudXRpbHMuZ2V0UXVhZHJhdGljQ29udHJvbFBvaW50KFxuICAgICAgICAgICAgICAgICAgc291cmNlW3ByZWZpeCArICd4J10sXG4gICAgICAgICAgICAgICAgICBzb3VyY2VbcHJlZml4ICsgJ3knXSxcbiAgICAgICAgICAgICAgICAgIHRhcmdldFtwcmVmaXggKyAneCddLFxuICAgICAgICAgICAgICAgICAgdGFyZ2V0W3ByZWZpeCArICd5J10pO1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgIHNpZ21hLnV0aWxzLmlzUG9pbnRPblF1YWRyYXRpY0N1cnZlKFxuICAgICAgICAgICAgICAgICAgbW9kaWZpZWRYLFxuICAgICAgICAgICAgICAgICAgbW9kaWZpZWRZLFxuICAgICAgICAgICAgICAgICAgc291cmNlW3ByZWZpeCArICd4J10sXG4gICAgICAgICAgICAgICAgICBzb3VyY2VbcHJlZml4ICsgJ3knXSxcbiAgICAgICAgICAgICAgICAgIHRhcmdldFtwcmVmaXggKyAneCddLFxuICAgICAgICAgICAgICAgICAgdGFyZ2V0W3ByZWZpeCArICd5J10sXG4gICAgICAgICAgICAgICAgICBjcC54LFxuICAgICAgICAgICAgICAgICAgY3AueSxcbiAgICAgICAgICAgICAgICAgIE1hdGgubWF4KHMsIG1heEVwc2lsb24pXG4gICAgICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgICAgICAgaW5zZXJ0RWRnZShzZWxlY3RlZCwgZWRnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgIHNpZ21hLnV0aWxzLmlzUG9pbnRPblNlZ21lbnQoXG4gICAgICAgICAgICAgICAgbW9kaWZpZWRYLFxuICAgICAgICAgICAgICAgIG1vZGlmaWVkWSxcbiAgICAgICAgICAgICAgICBzb3VyY2VbcHJlZml4ICsgJ3gnXSxcbiAgICAgICAgICAgICAgICBzb3VyY2VbcHJlZml4ICsgJ3knXSxcbiAgICAgICAgICAgICAgICB0YXJnZXRbcHJlZml4ICsgJ3gnXSxcbiAgICAgICAgICAgICAgICB0YXJnZXRbcHJlZml4ICsgJ3knXSxcbiAgICAgICAgICAgICAgICBNYXRoLm1heChzLCBtYXhFcHNpbG9uKVxuICAgICAgICAgICAgICApKSB7XG4gICAgICAgICAgICAgIGluc2VydEVkZ2Uoc2VsZWN0ZWQsIGVkZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZWN0ZWQ7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBiaW5kQ2FwdG9yKGNhcHRvcikge1xuICAgICAgdmFyIG5vZGVzLFxuICAgICAgICAgIGVkZ2VzLFxuICAgICAgICAgIG92ZXJOb2RlcyA9IHt9LFxuICAgICAgICAgIG92ZXJFZGdlcyA9IHt9O1xuXG4gICAgICBmdW5jdGlvbiBvbkNsaWNrKGUpIHtcbiAgICAgICAgaWYgKCFzZWxmLnNldHRpbmdzKCdldmVudHNFbmFibGVkJykpXG4gICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnY2xpY2snLCBlLmRhdGEpO1xuXG4gICAgICAgIG5vZGVzID0gZ2V0Tm9kZXMoZSk7XG4gICAgICAgIGVkZ2VzID0gZ2V0RWRnZXMoZSk7XG5cbiAgICAgICAgaWYgKG5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnY2xpY2tOb2RlJywge1xuICAgICAgICAgICAgbm9kZTogbm9kZXNbMF0sXG4gICAgICAgICAgICBjYXB0b3I6IGUuZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnY2xpY2tOb2RlcycsIHtcbiAgICAgICAgICAgIG5vZGU6IG5vZGVzLFxuICAgICAgICAgICAgY2FwdG9yOiBlLmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChlZGdlcy5sZW5ndGgpIHtcbiAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ2NsaWNrRWRnZScsIHtcbiAgICAgICAgICAgIGVkZ2U6IGVkZ2VzWzBdLFxuICAgICAgICAgICAgY2FwdG9yOiBlLmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ2NsaWNrRWRnZXMnLCB7XG4gICAgICAgICAgICBlZGdlOiBlZGdlcyxcbiAgICAgICAgICAgIGNhcHRvcjogZS5kYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnY2xpY2tTdGFnZScsIHtjYXB0b3I6IGUuZGF0YX0pO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBvbkRvdWJsZUNsaWNrKGUpIHtcbiAgICAgICAgaWYgKCFzZWxmLnNldHRpbmdzKCdldmVudHNFbmFibGVkJykpXG4gICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnZG91YmxlQ2xpY2snLCBlLmRhdGEpO1xuXG4gICAgICAgIG5vZGVzID0gZ2V0Tm9kZXMoZSk7XG4gICAgICAgIGVkZ2VzID0gZ2V0RWRnZXMoZSk7XG5cbiAgICAgICAgaWYgKG5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnZG91YmxlQ2xpY2tOb2RlJywge1xuICAgICAgICAgICAgbm9kZTogbm9kZXNbMF0sXG4gICAgICAgICAgICBjYXB0b3I6IGUuZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnZG91YmxlQ2xpY2tOb2RlcycsIHtcbiAgICAgICAgICAgIG5vZGU6IG5vZGVzLFxuICAgICAgICAgICAgY2FwdG9yOiBlLmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChlZGdlcy5sZW5ndGgpIHtcbiAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ2RvdWJsZUNsaWNrRWRnZScsIHtcbiAgICAgICAgICAgIGVkZ2U6IGVkZ2VzWzBdLFxuICAgICAgICAgICAgY2FwdG9yOiBlLmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ2RvdWJsZUNsaWNrRWRnZXMnLCB7XG4gICAgICAgICAgICBlZGdlOiBlZGdlcyxcbiAgICAgICAgICAgIGNhcHRvcjogZS5kYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnZG91YmxlQ2xpY2tTdGFnZScsIHtjYXB0b3I6IGUuZGF0YX0pO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBvblJpZ2h0Q2xpY2soZSkge1xuICAgICAgICBpZiAoIXNlbGYuc2V0dGluZ3MoJ2V2ZW50c0VuYWJsZWQnKSlcbiAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdyaWdodENsaWNrJywgZS5kYXRhKTtcblxuICAgICAgICBub2RlcyA9IGdldE5vZGVzKGUpO1xuICAgICAgICBlZGdlcyA9IGdldEVkZ2VzKGUpO1xuXG4gICAgICAgIGlmIChub2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ3JpZ2h0Q2xpY2tOb2RlJywge1xuICAgICAgICAgICAgbm9kZTogbm9kZXNbMF0sXG4gICAgICAgICAgICBjYXB0b3I6IGUuZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgncmlnaHRDbGlja05vZGVzJywge1xuICAgICAgICAgICAgbm9kZTogbm9kZXMsXG4gICAgICAgICAgICBjYXB0b3I6IGUuZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGVkZ2VzLmxlbmd0aCkge1xuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgncmlnaHRDbGlja0VkZ2UnLCB7XG4gICAgICAgICAgICBlZGdlOiBlZGdlc1swXSxcbiAgICAgICAgICAgIGNhcHRvcjogZS5kYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdyaWdodENsaWNrRWRnZXMnLCB7XG4gICAgICAgICAgICBlZGdlOiBlZGdlcyxcbiAgICAgICAgICAgIGNhcHRvcjogZS5kYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgncmlnaHRDbGlja1N0YWdlJywge2NhcHRvcjogZS5kYXRhfSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG9uT3V0KGUpIHtcbiAgICAgICAgaWYgKCFzZWxmLnNldHRpbmdzKCdldmVudHNFbmFibGVkJykpXG4gICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIHZhciBrLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGwsXG4gICAgICAgICAgICBsZSxcbiAgICAgICAgICAgIG91dE5vZGVzID0gW10sXG4gICAgICAgICAgICBvdXRFZGdlcyA9IFtdO1xuXG4gICAgICAgIGZvciAoayBpbiBvdmVyTm9kZXMpXG4gICAgICAgICAgb3V0Tm9kZXMucHVzaChvdmVyTm9kZXNba10pO1xuXG4gICAgICAgIG92ZXJOb2RlcyA9IHt9O1xuICAgICAgICAvLyBEaXNwYXRjaCBib3RoIHNpbmdsZSBhbmQgbXVsdGkgZXZlbnRzOlxuICAgICAgICBmb3IgKGkgPSAwLCBsID0gb3V0Tm9kZXMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnb3V0Tm9kZScsIHtcbiAgICAgICAgICAgIG5vZGU6IG91dE5vZGVzW2ldLFxuICAgICAgICAgICAgY2FwdG9yOiBlLmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgaWYgKG91dE5vZGVzLmxlbmd0aClcbiAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ291dE5vZGVzJywge1xuICAgICAgICAgICAgbm9kZXM6IG91dE5vZGVzLFxuICAgICAgICAgICAgY2FwdG9yOiBlLmRhdGFcbiAgICAgICAgICB9KTtcblxuICAgICAgICBvdmVyRWRnZXMgPSB7fTtcbiAgICAgICAgLy8gRGlzcGF0Y2ggYm90aCBzaW5nbGUgYW5kIG11bHRpIGV2ZW50czpcbiAgICAgICAgZm9yIChpID0gMCwgbGUgPSBvdXRFZGdlcy5sZW5ndGg7IGkgPCBsZTsgaSsrKVxuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnb3V0RWRnZScsIHtcbiAgICAgICAgICAgIGVkZ2U6IG91dEVkZ2VzW2ldLFxuICAgICAgICAgICAgY2FwdG9yOiBlLmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgaWYgKG91dEVkZ2VzLmxlbmd0aClcbiAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ291dEVkZ2VzJywge1xuICAgICAgICAgICAgZWRnZXM6IG91dEVkZ2VzLFxuICAgICAgICAgICAgY2FwdG9yOiBlLmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gb25Nb3ZlKGUpIHtcbiAgICAgICAgaWYgKCFzZWxmLnNldHRpbmdzKCdldmVudHNFbmFibGVkJykpXG4gICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIG5vZGVzID0gZ2V0Tm9kZXMoZSk7XG4gICAgICAgIGVkZ2VzID0gZ2V0RWRnZXMoZSk7XG5cbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBrLFxuICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgIGVkZ2UsXG4gICAgICAgICAgICBuZXdPdXROb2RlcyA9IFtdLFxuICAgICAgICAgICAgbmV3T3Zlck5vZGVzID0gW10sXG4gICAgICAgICAgICBjdXJyZW50T3Zlck5vZGVzID0ge30sXG4gICAgICAgICAgICBsID0gbm9kZXMubGVuZ3RoLFxuICAgICAgICAgICAgbmV3T3V0RWRnZXMgPSBbXSxcbiAgICAgICAgICAgIG5ld092ZXJFZGdlcyA9IFtdLFxuICAgICAgICAgICAgY3VycmVudE92ZXJFZGdlcyA9IHt9LFxuICAgICAgICAgICAgbGUgPSBlZGdlcy5sZW5ndGg7XG5cbiAgICAgICAgLy8gQ2hlY2sgbmV3bHkgb3ZlcnJlZCBub2RlczpcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICBjdXJyZW50T3Zlck5vZGVzW25vZGUuaWRdID0gbm9kZTtcbiAgICAgICAgICBpZiAoIW92ZXJOb2Rlc1tub2RlLmlkXSkge1xuICAgICAgICAgICAgbmV3T3Zlck5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgICAgICBvdmVyTm9kZXNbbm9kZS5pZF0gPSBub2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIG5vIG1vcmUgb3ZlcnJlZCBub2RlczpcbiAgICAgICAgZm9yIChrIGluIG92ZXJOb2RlcylcbiAgICAgICAgICBpZiAoIWN1cnJlbnRPdmVyTm9kZXNba10pIHtcbiAgICAgICAgICAgIG5ld091dE5vZGVzLnB1c2gob3Zlck5vZGVzW2tdKTtcbiAgICAgICAgICAgIGRlbGV0ZSBvdmVyTm9kZXNba107XG4gICAgICAgICAgfVxuXG4gICAgICAgIC8vIERpc3BhdGNoIGJvdGggc2luZ2xlIGFuZCBtdWx0aSBldmVudHM6XG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBuZXdPdmVyTm9kZXMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnb3Zlck5vZGUnLCB7XG4gICAgICAgICAgICBub2RlOiBuZXdPdmVyTm9kZXNbaV0sXG4gICAgICAgICAgICBjYXB0b3I6IGUuZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICBmb3IgKGkgPSAwLCBsID0gbmV3T3V0Tm9kZXMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnb3V0Tm9kZScsIHtcbiAgICAgICAgICAgIG5vZGU6IG5ld091dE5vZGVzW2ldLFxuICAgICAgICAgICAgY2FwdG9yOiBlLmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgaWYgKG5ld092ZXJOb2Rlcy5sZW5ndGgpXG4gICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdvdmVyTm9kZXMnLCB7XG4gICAgICAgICAgICBub2RlczogbmV3T3Zlck5vZGVzLFxuICAgICAgICAgICAgY2FwdG9yOiBlLmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgaWYgKG5ld091dE5vZGVzLmxlbmd0aClcbiAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ291dE5vZGVzJywge1xuICAgICAgICAgICAgbm9kZXM6IG5ld091dE5vZGVzLFxuICAgICAgICAgICAgY2FwdG9yOiBlLmRhdGFcbiAgICAgICAgICB9KTtcblxuICAgICAgICAvLyBDaGVjayBuZXdseSBvdmVycmVkIGVkZ2VzOlxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGU7IGkrKykge1xuICAgICAgICAgIGVkZ2UgPSBlZGdlc1tpXTtcbiAgICAgICAgICBjdXJyZW50T3ZlckVkZ2VzW2VkZ2UuaWRdID0gZWRnZTtcbiAgICAgICAgICBpZiAoIW92ZXJFZGdlc1tlZGdlLmlkXSkge1xuICAgICAgICAgICAgbmV3T3ZlckVkZ2VzLnB1c2goZWRnZSk7XG4gICAgICAgICAgICBvdmVyRWRnZXNbZWRnZS5pZF0gPSBlZGdlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIG5vIG1vcmUgb3ZlcnJlZCBlZGdlczpcbiAgICAgICAgZm9yIChrIGluIG92ZXJFZGdlcylcbiAgICAgICAgICBpZiAoIWN1cnJlbnRPdmVyRWRnZXNba10pIHtcbiAgICAgICAgICAgIG5ld091dEVkZ2VzLnB1c2gob3ZlckVkZ2VzW2tdKTtcbiAgICAgICAgICAgIGRlbGV0ZSBvdmVyRWRnZXNba107XG4gICAgICAgICAgfVxuXG4gICAgICAgIC8vIERpc3BhdGNoIGJvdGggc2luZ2xlIGFuZCBtdWx0aSBldmVudHM6XG4gICAgICAgIGZvciAoaSA9IDAsIGxlID0gbmV3T3ZlckVkZ2VzLmxlbmd0aDsgaSA8IGxlOyBpKyspXG4gICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdvdmVyRWRnZScsIHtcbiAgICAgICAgICAgIGVkZ2U6IG5ld092ZXJFZGdlc1tpXSxcbiAgICAgICAgICAgIGNhcHRvcjogZS5kYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgIGZvciAoaSA9IDAsIGxlID0gbmV3T3V0RWRnZXMubGVuZ3RoOyBpIDwgbGU7IGkrKylcbiAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ291dEVkZ2UnLCB7XG4gICAgICAgICAgICBlZGdlOiBuZXdPdXRFZGdlc1tpXSxcbiAgICAgICAgICAgIGNhcHRvcjogZS5kYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgIGlmIChuZXdPdmVyRWRnZXMubGVuZ3RoKVxuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnb3ZlckVkZ2VzJywge1xuICAgICAgICAgICAgZWRnZXM6IG5ld092ZXJFZGdlcyxcbiAgICAgICAgICAgIGNhcHRvcjogZS5kYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgIGlmIChuZXdPdXRFZGdlcy5sZW5ndGgpXG4gICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdvdXRFZGdlcycsIHtcbiAgICAgICAgICAgIGVkZ2VzOiBuZXdPdXRFZGdlcyxcbiAgICAgICAgICAgIGNhcHRvcjogZS5kYXRhXG4gICAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEJpbmQgZXZlbnRzOlxuICAgICAgY2FwdG9yLmJpbmQoJ2NsaWNrJywgb25DbGljayk7XG4gICAgICBjYXB0b3IuYmluZCgnbW91c2Vkb3duJywgb25Nb3ZlKTtcbiAgICAgIGNhcHRvci5iaW5kKCdtb3VzZXVwJywgb25Nb3ZlKTtcbiAgICAgIGNhcHRvci5iaW5kKCdtb3VzZW1vdmUnLCBvbk1vdmUpO1xuICAgICAgY2FwdG9yLmJpbmQoJ21vdXNlb3V0Jywgb25PdXQpO1xuICAgICAgY2FwdG9yLmJpbmQoJ2RvdWJsZWNsaWNrJywgb25Eb3VibGVDbGljayk7XG4gICAgICBjYXB0b3IuYmluZCgncmlnaHRjbGljaycsIG9uUmlnaHRDbGljayk7XG4gICAgICBzZWxmLmJpbmQoJ3JlbmRlcicsIG9uTW92ZSk7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMCwgbCA9IHRoaXMuY2FwdG9ycy5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICBiaW5kQ2FwdG9yKHRoaXMuY2FwdG9yc1tpXSk7XG4gIH07XG59KS5jYWxsKHRoaXMpO1xuXG47KGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgaWYgKHR5cGVvZiBzaWdtYSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgdGhyb3cgJ3NpZ21hIGlzIG5vdCBkZWNsYXJlZCc7XG5cbiAgLy8gSW5pdGlhbGl6ZSBwYWNrYWdlczpcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5taXNjJyk7XG5cbiAgLyoqXG4gICAqIFRoaXMgaGVscGVyIHdpbGwgYmluZCBhbnkgRE9NIHJlbmRlcmVyIChmb3IgaW5zdGFuY2Ugc3ZnKVxuICAgKiB0byBpdHMgY2FwdG9ycywgdG8gcHJvcGVybHkgZGlzcGF0Y2ggdGhlIGdvb2QgZXZlbnRzIHRvIHRoZSBzaWdtYSBpbnN0YW5jZVxuICAgKiB0byBtYW5hZ2UgY2xpY2tpbmcsIGhvdmVyaW5nIGV0Yy4uLlxuICAgKlxuICAgKiBJdCBoYXMgdG8gYmUgY2FsbGVkIGluIHRoZSBzY29wZSBvZiB0aGUgcmVsYXRlZCByZW5kZXJlci5cbiAgICovXG4gIHNpZ21hLm1pc2MuYmluZERPTUV2ZW50cyA9IGZ1bmN0aW9uKGNvbnRhaW5lcikge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgZ3JhcGggPSB0aGlzLmdyYXBoO1xuXG4gICAgLy8gRE9NRWxlbWVudCBhYnN0cmFjdGlvblxuICAgIGZ1bmN0aW9uIEVsZW1lbnQoZG9tRWxlbWVudCkge1xuXG4gICAgICAvLyBIZWxwZXJzXG4gICAgICB0aGlzLmF0dHIgPSBmdW5jdGlvbihhdHRyTmFtZSkge1xuICAgICAgICByZXR1cm4gZG9tRWxlbWVudC5nZXRBdHRyaWJ1dGVOUyhudWxsLCBhdHRyTmFtZSk7XG4gICAgICB9O1xuXG4gICAgICAvLyBQcm9wZXJ0aWVzXG4gICAgICB0aGlzLnRhZyA9IGRvbUVsZW1lbnQudGFnTmFtZTtcbiAgICAgIHRoaXMuY2xhc3MgPSB0aGlzLmF0dHIoJ2NsYXNzJyk7XG4gICAgICB0aGlzLmlkID0gdGhpcy5hdHRyKCdpZCcpO1xuXG4gICAgICAvLyBNZXRob2RzXG4gICAgICB0aGlzLmlzTm9kZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gISF+dGhpcy5jbGFzcy5pbmRleE9mKHNlbGYuc2V0dGluZ3MoJ2NsYXNzUHJlZml4JykgKyAnLW5vZGUnKTtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuaXNFZGdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAhIX50aGlzLmNsYXNzLmluZGV4T2Yoc2VsZi5zZXR0aW5ncygnY2xhc3NQcmVmaXgnKSArICctZWRnZScpO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5pc0hvdmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAhIX50aGlzLmNsYXNzLmluZGV4T2Yoc2VsZi5zZXR0aW5ncygnY2xhc3NQcmVmaXgnKSArICctaG92ZXInKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gQ2xpY2tcbiAgICBmdW5jdGlvbiBjbGljayhlKSB7XG4gICAgICBpZiAoIXNlbGYuc2V0dGluZ3MoJ2V2ZW50c0VuYWJsZWQnKSlcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICAvLyBHZW5lcmljIGV2ZW50XG4gICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ2NsaWNrJywgZSk7XG5cbiAgICAgIC8vIEFyZSB3ZSBvbiBhIG5vZGU/XG4gICAgICB2YXIgZWxlbWVudCA9IG5ldyBFbGVtZW50KGUudGFyZ2V0KTtcblxuICAgICAgaWYgKGVsZW1lbnQuaXNOb2RlKCkpXG4gICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnY2xpY2tOb2RlJywge1xuICAgICAgICAgIG5vZGU6IGdyYXBoLm5vZGVzKGVsZW1lbnQuYXR0cignZGF0YS1ub2RlLWlkJykpXG4gICAgICAgIH0pO1xuICAgICAgZWxzZVxuICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ2NsaWNrU3RhZ2UnKTtcblxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9XG5cbiAgICAvLyBEb3VibGUgY2xpY2tcbiAgICBmdW5jdGlvbiBkb3VibGVDbGljayhlKSB7XG4gICAgICBpZiAoIXNlbGYuc2V0dGluZ3MoJ2V2ZW50c0VuYWJsZWQnKSlcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICAvLyBHZW5lcmljIGV2ZW50XG4gICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ2RvdWJsZUNsaWNrJywgZSk7XG5cbiAgICAgIC8vIEFyZSB3ZSBvbiBhIG5vZGU/XG4gICAgICB2YXIgZWxlbWVudCA9IG5ldyBFbGVtZW50KGUudGFyZ2V0KTtcblxuICAgICAgaWYgKGVsZW1lbnQuaXNOb2RlKCkpXG4gICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnZG91YmxlQ2xpY2tOb2RlJywge1xuICAgICAgICAgIG5vZGU6IGdyYXBoLm5vZGVzKGVsZW1lbnQuYXR0cignZGF0YS1ub2RlLWlkJykpXG4gICAgICAgIH0pO1xuICAgICAgZWxzZVxuICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ2RvdWJsZUNsaWNrU3RhZ2UnKTtcblxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9XG5cbiAgICAvLyBPbiBvdmVyXG4gICAgZnVuY3Rpb24gb25PdmVyKGUpIHtcbiAgICAgIHZhciB0YXJnZXQgPSBlLnRvRWxlbWVudCB8fCBlLnRhcmdldDtcblxuICAgICAgaWYgKCFzZWxmLnNldHRpbmdzKCdldmVudHNFbmFibGVkJykgfHwgIXRhcmdldClcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICB2YXIgZWwgPSBuZXcgRWxlbWVudCh0YXJnZXQpO1xuXG4gICAgICBpZiAoZWwuaXNOb2RlKCkpIHtcbiAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdvdmVyTm9kZScsIHtcbiAgICAgICAgICBub2RlOiBncmFwaC5ub2RlcyhlbC5hdHRyKCdkYXRhLW5vZGUtaWQnKSlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChlbC5pc0VkZ2UoKSkge1xuICAgICAgICB2YXIgZWRnZSA9IGdyYXBoLmVkZ2VzKGVsLmF0dHIoJ2RhdGEtZWRnZS1pZCcpKTtcbiAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdvdmVyRWRnZScsIHtcbiAgICAgICAgICBlZGdlOiBlZGdlLFxuICAgICAgICAgIHNvdXJjZTogZ3JhcGgubm9kZXMoZWRnZS5zb3VyY2UpLFxuICAgICAgICAgIHRhcmdldDogZ3JhcGgubm9kZXMoZWRnZS50YXJnZXQpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE9uIG91dFxuICAgIGZ1bmN0aW9uIG9uT3V0KGUpIHtcbiAgICAgIHZhciB0YXJnZXQgPSBlLmZyb21FbGVtZW50IHx8IGUub3JpZ2luYWxUYXJnZXQ7XG5cbiAgICAgIGlmICghc2VsZi5zZXR0aW5ncygnZXZlbnRzRW5hYmxlZCcpKVxuICAgICAgICByZXR1cm47XG5cbiAgICAgIHZhciBlbCA9IG5ldyBFbGVtZW50KHRhcmdldCk7XG5cbiAgICAgIGlmIChlbC5pc05vZGUoKSkge1xuICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ291dE5vZGUnLCB7XG4gICAgICAgICAgbm9kZTogZ3JhcGgubm9kZXMoZWwuYXR0cignZGF0YS1ub2RlLWlkJykpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZWwuaXNFZGdlKCkpIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBncmFwaC5lZGdlcyhlbC5hdHRyKCdkYXRhLWVkZ2UtaWQnKSk7XG4gICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnb3V0RWRnZScsIHtcbiAgICAgICAgICBlZGdlOiBlZGdlLFxuICAgICAgICAgIHNvdXJjZTogZ3JhcGgubm9kZXMoZWRnZS5zb3VyY2UpLFxuICAgICAgICAgIHRhcmdldDogZ3JhcGgubm9kZXMoZWRnZS50YXJnZXQpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlZ2lzdGVyaW5nIEV2ZW50czpcblxuICAgIC8vIENsaWNrXG4gICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgY2xpY2ssIGZhbHNlKTtcbiAgICBzaWdtYS51dGlscy5kb3VibGVDbGljayhjb250YWluZXIsICdjbGljaycsIGRvdWJsZUNsaWNrKTtcblxuICAgIC8vIFRvdWNoIGNvdW50ZXJwYXJ0c1xuICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgY2xpY2ssIGZhbHNlKTtcbiAgICBzaWdtYS51dGlscy5kb3VibGVDbGljayhjb250YWluZXIsICd0b3VjaHN0YXJ0JywgZG91YmxlQ2xpY2spO1xuXG4gICAgLy8gTW91c2VvdmVyXG4gICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3ZlcicsIG9uT3ZlciwgdHJ1ZSk7XG5cbiAgICAvLyBNb3VzZW91dFxuICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsIG9uT3V0LCB0cnVlKTtcbiAgfTtcbn0pLmNhbGwodGhpcyk7XG5cbjsoZnVuY3Rpb24odW5kZWZpbmVkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBpZiAodHlwZW9mIHNpZ21hID09PSAndW5kZWZpbmVkJylcbiAgICB0aHJvdyAnc2lnbWEgaXMgbm90IGRlY2xhcmVkJztcblxuICAvLyBJbml0aWFsaXplIHBhY2thZ2VzOlxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLm1pc2MnKTtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgbGlzdGVucyB0byBcIm92ZXJOb2RlXCIsIFwib3V0Tm9kZVwiLCBcIm92ZXJFZGdlXCIgYW5kIFwib3V0RWRnZVwiXG4gICAqIGV2ZW50cyBmcm9tIGEgcmVuZGVyZXIgYW5kIHJlbmRlcnMgdGhlIG5vZGVzIGRpZmZlcmVudGx5IG9uIHRoZSB0b3AgbGF5ZXIuXG4gICAqIFRoZSBnb2FsIGlzIHRvIG1ha2UgYW55IG5vZGUgbGFiZWwgcmVhZGFibGUgd2l0aCB0aGUgbW91c2UsIGFuZCB0b1xuICAgKiBoaWdobGlnaHQgaG92ZXJlZCBub2RlcyBhbmQgZWRnZXMuXG4gICAqXG4gICAqIEl0IGhhcyB0byBiZSBjYWxsZWQgaW4gdGhlIHNjb3BlIG9mIHRoZSByZWxhdGVkIHJlbmRlcmVyLlxuICAgKi9cbiAgc2lnbWEubWlzYy5kcmF3SG92ZXJzID0gZnVuY3Rpb24ocHJlZml4KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBob3ZlcmVkTm9kZXMgPSB7fSxcbiAgICAgICAgaG92ZXJlZEVkZ2VzID0ge307XG5cbiAgICB0aGlzLmJpbmQoJ292ZXJOb2RlJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIHZhciBub2RlID0gZXZlbnQuZGF0YS5ub2RlO1xuICAgICAgaWYgKCFub2RlLmhpZGRlbikge1xuICAgICAgICBob3ZlcmVkTm9kZXNbbm9kZS5pZF0gPSBub2RlO1xuICAgICAgICBkcmF3KCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLmJpbmQoJ291dE5vZGUnLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgZGVsZXRlIGhvdmVyZWROb2Rlc1tldmVudC5kYXRhLm5vZGUuaWRdO1xuICAgICAgZHJhdygpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5iaW5kKCdvdmVyRWRnZScsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICB2YXIgZWRnZSA9IGV2ZW50LmRhdGEuZWRnZTtcbiAgICAgIGlmICghZWRnZS5oaWRkZW4pIHtcbiAgICAgICAgaG92ZXJlZEVkZ2VzW2VkZ2UuaWRdID0gZWRnZTtcbiAgICAgICAgZHJhdygpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5iaW5kKCdvdXRFZGdlJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIGRlbGV0ZSBob3ZlcmVkRWRnZXNbZXZlbnQuZGF0YS5lZGdlLmlkXTtcbiAgICAgIGRyYXcoKTtcbiAgICB9KTtcblxuICAgIHRoaXMuYmluZCgncmVuZGVyJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIGRyYXcoKTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGRyYXcoKSB7XG5cbiAgICAgIHZhciBrLFxuICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgaG92ZXJlZE5vZGUsXG4gICAgICAgICAgaG92ZXJlZEVkZ2UsXG4gICAgICAgICAgYyA9IHNlbGYuY29udGV4dHMuaG92ZXIuY2FudmFzLFxuICAgICAgICAgIGRlZmF1bHROb2RlVHlwZSA9IHNlbGYuc2V0dGluZ3MoJ2RlZmF1bHROb2RlVHlwZScpLFxuICAgICAgICAgIGRlZmF1bHRFZGdlVHlwZSA9IHNlbGYuc2V0dGluZ3MoJ2RlZmF1bHRFZGdlVHlwZScpLFxuICAgICAgICAgIG5vZGVSZW5kZXJlcnMgPSBzaWdtYS5jYW52YXMuaG92ZXJzLFxuICAgICAgICAgIGVkZ2VSZW5kZXJlcnMgPSBzaWdtYS5jYW52YXMuZWRnZWhvdmVycyxcbiAgICAgICAgICBleHRyZW1pdGllc1JlbmRlcmVycyA9IHNpZ21hLmNhbnZhcy5leHRyZW1pdGllcyxcbiAgICAgICAgICBlbWJlZFNldHRpbmdzID0gc2VsZi5zZXR0aW5ncy5lbWJlZE9iamVjdHMoe1xuICAgICAgICAgICAgcHJlZml4OiBwcmVmaXhcbiAgICAgICAgICB9KTtcblxuICAgICAgLy8gQ2xlYXIgc2VsZi5jb250ZXh0cy5ob3ZlcjpcbiAgICAgIHNlbGYuY29udGV4dHMuaG92ZXIuY2xlYXJSZWN0KDAsIDAsIGMud2lkdGgsIGMuaGVpZ2h0KTtcblxuICAgICAgLy8gTm9kZSByZW5kZXI6IHNpbmdsZSBob3ZlclxuICAgICAgaWYgKFxuICAgICAgICBlbWJlZFNldHRpbmdzKCdlbmFibGVIb3ZlcmluZycpICYmXG4gICAgICAgIGVtYmVkU2V0dGluZ3MoJ3NpbmdsZUhvdmVyJykgJiZcbiAgICAgICAgT2JqZWN0LmtleXMoaG92ZXJlZE5vZGVzKS5sZW5ndGhcbiAgICAgICkge1xuICAgICAgICBob3ZlcmVkTm9kZSA9IGhvdmVyZWROb2Rlc1tPYmplY3Qua2V5cyhob3ZlcmVkTm9kZXMpWzBdXTtcbiAgICAgICAgKFxuICAgICAgICAgIG5vZGVSZW5kZXJlcnNbaG92ZXJlZE5vZGUudHlwZV0gfHxcbiAgICAgICAgICBub2RlUmVuZGVyZXJzW2RlZmF1bHROb2RlVHlwZV0gfHxcbiAgICAgICAgICBub2RlUmVuZGVyZXJzLmRlZlxuICAgICAgICApKFxuICAgICAgICAgIGhvdmVyZWROb2RlLFxuICAgICAgICAgIHNlbGYuY29udGV4dHMuaG92ZXIsXG4gICAgICAgICAgZW1iZWRTZXR0aW5nc1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICAvLyBOb2RlIHJlbmRlcjogbXVsdGlwbGUgaG92ZXJcbiAgICAgIGlmIChcbiAgICAgICAgZW1iZWRTZXR0aW5ncygnZW5hYmxlSG92ZXJpbmcnKSAmJlxuICAgICAgICAhZW1iZWRTZXR0aW5ncygnc2luZ2xlSG92ZXInKVxuICAgICAgKVxuICAgICAgICBmb3IgKGsgaW4gaG92ZXJlZE5vZGVzKVxuICAgICAgICAgIChcbiAgICAgICAgICAgIG5vZGVSZW5kZXJlcnNbaG92ZXJlZE5vZGVzW2tdLnR5cGVdIHx8XG4gICAgICAgICAgICBub2RlUmVuZGVyZXJzW2RlZmF1bHROb2RlVHlwZV0gfHxcbiAgICAgICAgICAgIG5vZGVSZW5kZXJlcnMuZGVmXG4gICAgICAgICAgKShcbiAgICAgICAgICAgIGhvdmVyZWROb2Rlc1trXSxcbiAgICAgICAgICAgIHNlbGYuY29udGV4dHMuaG92ZXIsXG4gICAgICAgICAgICBlbWJlZFNldHRpbmdzXG4gICAgICAgICAgKTtcblxuICAgICAgLy8gRWRnZSByZW5kZXI6IHNpbmdsZSBob3ZlclxuICAgICAgaWYgKFxuICAgICAgICBlbWJlZFNldHRpbmdzKCdlbmFibGVFZGdlSG92ZXJpbmcnKSAmJlxuICAgICAgICBlbWJlZFNldHRpbmdzKCdzaW5nbGVIb3ZlcicpICYmXG4gICAgICAgIE9iamVjdC5rZXlzKGhvdmVyZWRFZGdlcykubGVuZ3RoXG4gICAgICApIHtcbiAgICAgICAgaG92ZXJlZEVkZ2UgPSBob3ZlcmVkRWRnZXNbT2JqZWN0LmtleXMoaG92ZXJlZEVkZ2VzKVswXV07XG4gICAgICAgIHNvdXJjZSA9IHNlbGYuZ3JhcGgubm9kZXMoaG92ZXJlZEVkZ2Uuc291cmNlKTtcbiAgICAgICAgdGFyZ2V0ID0gc2VsZi5ncmFwaC5ub2Rlcyhob3ZlcmVkRWRnZS50YXJnZXQpO1xuXG4gICAgICAgIGlmICghIGhvdmVyZWRFZGdlLmhpZGRlbikge1xuICAgICAgICAgIChcbiAgICAgICAgICAgIGVkZ2VSZW5kZXJlcnNbaG92ZXJlZEVkZ2UudHlwZV0gfHxcbiAgICAgICAgICAgIGVkZ2VSZW5kZXJlcnNbZGVmYXVsdEVkZ2VUeXBlXSB8fFxuICAgICAgICAgICAgZWRnZVJlbmRlcmVycy5kZWZcbiAgICAgICAgICApIChcbiAgICAgICAgICAgIGhvdmVyZWRFZGdlLFxuICAgICAgICAgICAgc291cmNlLFxuICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgc2VsZi5jb250ZXh0cy5ob3ZlcixcbiAgICAgICAgICAgIGVtYmVkU2V0dGluZ3NcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgaWYgKGVtYmVkU2V0dGluZ3MoJ2VkZ2VIb3ZlckV4dHJlbWl0aWVzJykpIHtcbiAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgZXh0cmVtaXRpZXNSZW5kZXJlcnNbaG92ZXJlZEVkZ2UudHlwZV0gfHxcbiAgICAgICAgICAgICAgZXh0cmVtaXRpZXNSZW5kZXJlcnMuZGVmXG4gICAgICAgICAgICApKFxuICAgICAgICAgICAgICBob3ZlcmVkRWRnZSxcbiAgICAgICAgICAgICAgc291cmNlLFxuICAgICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICAgIHNlbGYuY29udGV4dHMuaG92ZXIsXG4gICAgICAgICAgICAgIGVtYmVkU2V0dGluZ3NcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQXZvaWQgZWRnZXMgcmVuZGVyZWQgb3ZlciBub2RlczpcbiAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgc2lnbWEuY2FudmFzLm5vZGVzW3NvdXJjZS50eXBlXSB8fFxuICAgICAgICAgICAgICBzaWdtYS5jYW52YXMubm9kZXMuZGVmXG4gICAgICAgICAgICApIChcbiAgICAgICAgICAgICAgc291cmNlLFxuICAgICAgICAgICAgICBzZWxmLmNvbnRleHRzLmhvdmVyLFxuICAgICAgICAgICAgICBlbWJlZFNldHRpbmdzXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgKFxuICAgICAgICAgICAgICBzaWdtYS5jYW52YXMubm9kZXNbdGFyZ2V0LnR5cGVdIHx8XG4gICAgICAgICAgICAgIHNpZ21hLmNhbnZhcy5ub2Rlcy5kZWZcbiAgICAgICAgICAgICkgKFxuICAgICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICAgIHNlbGYuY29udGV4dHMuaG92ZXIsXG4gICAgICAgICAgICAgIGVtYmVkU2V0dGluZ3NcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEVkZ2UgcmVuZGVyOiBtdWx0aXBsZSBob3ZlclxuICAgICAgaWYgKFxuICAgICAgICBlbWJlZFNldHRpbmdzKCdlbmFibGVFZGdlSG92ZXJpbmcnKSAmJlxuICAgICAgICAhZW1iZWRTZXR0aW5ncygnc2luZ2xlSG92ZXInKVxuICAgICAgKSB7XG4gICAgICAgIGZvciAoayBpbiBob3ZlcmVkRWRnZXMpIHtcbiAgICAgICAgICBob3ZlcmVkRWRnZSA9IGhvdmVyZWRFZGdlc1trXTtcbiAgICAgICAgICBzb3VyY2UgPSBzZWxmLmdyYXBoLm5vZGVzKGhvdmVyZWRFZGdlLnNvdXJjZSk7XG4gICAgICAgICAgdGFyZ2V0ID0gc2VsZi5ncmFwaC5ub2Rlcyhob3ZlcmVkRWRnZS50YXJnZXQpO1xuXG4gICAgICAgICAgaWYgKCFob3ZlcmVkRWRnZS5oaWRkZW4pIHtcbiAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgZWRnZVJlbmRlcmVyc1tob3ZlcmVkRWRnZS50eXBlXSB8fFxuICAgICAgICAgICAgICBlZGdlUmVuZGVyZXJzW2RlZmF1bHRFZGdlVHlwZV0gfHxcbiAgICAgICAgICAgICAgZWRnZVJlbmRlcmVycy5kZWZcbiAgICAgICAgICAgICkgKFxuICAgICAgICAgICAgICBob3ZlcmVkRWRnZSxcbiAgICAgICAgICAgICAgc291cmNlLFxuICAgICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICAgIHNlbGYuY29udGV4dHMuaG92ZXIsXG4gICAgICAgICAgICAgIGVtYmVkU2V0dGluZ3NcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGlmIChlbWJlZFNldHRpbmdzKCdlZGdlSG92ZXJFeHRyZW1pdGllcycpKSB7XG4gICAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICBleHRyZW1pdGllc1JlbmRlcmVyc1tob3ZlcmVkRWRnZS50eXBlXSB8fFxuICAgICAgICAgICAgICAgIGV4dHJlbWl0aWVzUmVuZGVyZXJzLmRlZlxuICAgICAgICAgICAgICApKFxuICAgICAgICAgICAgICAgIGhvdmVyZWRFZGdlLFxuICAgICAgICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICAgICAgc2VsZi5jb250ZXh0cy5ob3ZlcixcbiAgICAgICAgICAgICAgICBlbWJlZFNldHRpbmdzXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBBdm9pZCBlZGdlcyByZW5kZXJlZCBvdmVyIG5vZGVzOlxuICAgICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgc2lnbWEuY2FudmFzLm5vZGVzW3NvdXJjZS50eXBlXSB8fFxuICAgICAgICAgICAgICAgIHNpZ21hLmNhbnZhcy5ub2Rlcy5kZWZcbiAgICAgICAgICAgICAgKSAoXG4gICAgICAgICAgICAgICAgc291cmNlLFxuICAgICAgICAgICAgICAgIHNlbGYuY29udGV4dHMuaG92ZXIsXG4gICAgICAgICAgICAgICAgZW1iZWRTZXR0aW5nc1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgc2lnbWEuY2FudmFzLm5vZGVzW3RhcmdldC50eXBlXSB8fFxuICAgICAgICAgICAgICAgIHNpZ21hLmNhbnZhcy5ub2Rlcy5kZWZcbiAgICAgICAgICAgICAgKSAoXG4gICAgICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgICAgIHNlbGYuY29udGV4dHMuaG92ZXIsXG4gICAgICAgICAgICAgICAgZW1iZWRTZXR0aW5nc1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbn0pLmNhbGwodGhpcyk7XG4iLCIhZnVuY3Rpb24oZSl7aWYoXCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGUpbW9kdWxlLmV4cG9ydHM9ZSgpO2Vsc2UgaWYoXCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kKWRlZmluZShbXSxlKTtlbHNle3ZhciB0O3Q9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz93aW5kb3c6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbD9nbG9iYWw6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGY/c2VsZjp0aGlzLHQuVFFHcmFtVUk9ZSgpfX0oZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24oKXtmdW5jdGlvbiBlKHQsbixvKXtmdW5jdGlvbiBpKGwsYSl7aWYoIW5bbF0pe2lmKCF0W2xdKXt2YXIgcz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFhJiZzKXJldHVybiBzKGwsITApO2lmKHIpcmV0dXJuIHIobCwhMCk7dmFyIHU9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitsK1wiJ1wiKTt0aHJvdyB1LmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsdX12YXIgZD1uW2xdPXtleHBvcnRzOnt9fTt0W2xdWzBdLmNhbGwoZC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbbF1bMV1bZV07cmV0dXJuIGkobj9uOmUpfSxkLGQuZXhwb3J0cyxlLHQsbixvKX1yZXR1cm4gbltsXS5leHBvcnRzfWZvcih2YXIgcj1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGw9MDtsPG8ubGVuZ3RoO2wrKylpKG9bbF0pO3JldHVybiBpfXJldHVybiBlfSgpKHsxOltmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbyhlKXtmdW5jdGlvbiB0KCl7ci5yb290SHRtbC5pbm5lckhUTUw9XCJcIixyLnJvb3RIdG1sLnN0eWxlLmJvcmRlclRvcD0wIT09ci5idXR0b25zLmxlbmd0aD9cIjFweCBzb2xpZCAjY2NjY2NjXCI6bnVsbCxyLnJvb3RIdG1sLnN0eWxlLmJvcmRlckJvdHRvbT0wIT09ci5idXR0b25zLmxlbmd0aD9cIjFweCBzb2xpZCAjY2NjY2NjXCI6bnVsbCxyLmJ1dHRvbnMuZm9yRWFjaChmdW5jdGlvbihlKXt2YXIgdD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiQlVUVE9OXCIpO3QudGl0bGU9ZS5sYWJlbCx0LmNsYXNzTmFtZT1cInRxLXVpLXRvb2xiYXJfX2J1dHRvbiB0cS11aS1jb2xvcmVkLWJ1dHRvblwiLHQuaW5uZXJIVE1MPSc8c3BhbiBzdHlsZT1cImNvbG9yOiAnK2UuYm9yZGVyQ29sb3IrJ1wiPicrbihlLmxhYmVsKStcIjwvc3Bhbj5cIix0LnN0eWxlLmJhY2tncm91bmRDb2xvcj1lLmJhY2tncm91bmRDb2xvcnx8XCJ3aGl0ZVwiLHQuc3R5bGUuYm9yZGVyQ29sb3I9ZS5ib3JkZXJDb2xvcnx8XCJibGFja1wiLHQub25jbGljaz1mdW5jdGlvbih0KXtlLmNhbGxiYWNrKGUsdCl9LHIucm9vdEh0bWwuYXBwZW5kQ2hpbGQodCl9KX1mdW5jdGlvbiBuKGUpe2lmKGUpe3ZhciB0PWUubWF0Y2goL1thLXonXFwtXSsvZ2kpO3JldHVybiB0LmZpbHRlcihmdW5jdGlvbihlKXtyZXR1cm5cImFuZFwiIT09ZS50b0xvd2VyQ2FzZSgpJiZcIiZcIiE9PWV9KS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGVbMF19KS5qb2luKFwiXCIpfX1mdW5jdGlvbiBvKCl7dmFyIGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIkRJVlwiKTtyZXR1cm4gZS5jbGFzc05hbWU9XCJ0cS11aS1jb2xvcmVkLWJ1dHRvbnMtbGlzdFwiLGUuaW5uZXJIVE1MPVwiXCIsZX12YXIgcj10aGlzO2V8fChlPXt9KSxyLnJvb3RIdG1sPW8oKSxyLmlkPWUuaWR8fFwiY29sb3JlZEJ1dHRvbnMtXCIraSsrLHIucm9vdEh0bWwuaWQ9ci5pZCxyLmJ1dHRvbnM9ZS5idXR0b25zfHxbXSx0KCksci5yZW1vdmVBbGw9ZnVuY3Rpb24oKXtyLmJ1dHRvbnM9W10sdCgpfSxyLmFkZEJ1dHRvbj1mdW5jdGlvbihlKXtyLmJ1dHRvbnMubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLmlkfSkuaW5kZXhPZihlLmlkKT09PS0xJiYoci5idXR0b25zLnB1c2goZSksdCgpKX0sci5yZW1vdmVCdXR0b249ZnVuY3Rpb24oZSl7ci5idXR0b25zLnNwbGljZShyLmJ1dHRvbnMuaW5kZXhPZihlKSwxKSx0KCl9fU9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLG4uQ29sb3JlZEJ1dHRvbnNMaXN0PW87dmFyIGk9MDtuW1wiZGVmYXVsdFwiXT1vfSx7fV0sMjpbZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIG8oZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntcImRlZmF1bHRcIjplfX1mdW5jdGlvbiBpKGUpe2Z1bmN0aW9uIHQoKXtpZihlLmJvZHkgaW5zdGFuY2VvZiBPYmplY3Qpe3ZhciB0PWkucm9vdEh0bWwucXVlcnlTZWxlY3RvcihcIi50cS11aS1ib2R5X2NvbnRhaW5lclwiKTt0LmFwcGVuZENoaWxkKGUuYm9keS5yb290SHRtbCl9dmFyIGE9aS5yb290SHRtbC5xdWVyeVNlbGVjdG9yKFwiLnRxLXVpLWZseWluZy1wYW5lbF9oZWFkZXJcIik7YS5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsbyk7dmFyIHM9aS5yb290SHRtbC5xdWVyeVNlbGVjdG9yKFwiLnRxLXVpLXdpbmRvd3MtY29sbGFwc2UtYnV0dG9uXCIpO2lmKHMub25jbGljaz1pLmhpZGUsZS5yZXNpemFibGUpe3ZhciB1PWkucm9vdEh0bWwucXVlcnlTZWxlY3RvcihcIi50cS11aS1mbHlpbmctcGFuZWxfX2JvcmRlci50cS11aS10b3AtYm9yZGVyXCIpO3UuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLGZ1bmN0aW9uKGUpe28oZSxcIm5cIil9KTt2YXIgZD1pLnJvb3RIdG1sLnF1ZXJ5U2VsZWN0b3IoXCIudHEtdWktZmx5aW5nLXBhbmVsX19ib3JkZXIudHEtdWktcmlnaHQtYm9yZGVyXCIpO2QuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLGZ1bmN0aW9uKGUpe28oZSxcImVcIil9KTt2YXIgYz1pLnJvb3RIdG1sLnF1ZXJ5U2VsZWN0b3IoXCIudHEtdWktZmx5aW5nLXBhbmVsX19ib3JkZXIudHEtdWktYm90dG9tLWJvcmRlclwiKTtjLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIixmdW5jdGlvbihlKXtvKGUsXCJzXCIpfSk7dmFyIGY9aS5yb290SHRtbC5xdWVyeVNlbGVjdG9yKFwiLnRxLXVpLWZseWluZy1wYW5lbF9fYm9yZGVyLnRxLXVpLWxlZnQtYm9yZGVyXCIpO2YuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLGZ1bmN0aW9uKGUpe28oZSxcIndcIil9KTt2YXIgcD1pLnJvb3RIdG1sLnF1ZXJ5U2VsZWN0b3IoXCIudHEtdWktZmx5aW5nLXBhbmVsX19ib3JkZXIudHEtdWktdG9wLXJpZ2h0LWJvcmRlclwiKTtwLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIixmdW5jdGlvbihlKXtvKGUsXCJuZVwiKX0pO3ZhciBiPWkucm9vdEh0bWwucXVlcnlTZWxlY3RvcihcIi50cS11aS1mbHlpbmctcGFuZWxfX2JvcmRlci50cS11aS10b3AtbGVmdC1ib3JkZXJcIik7Yi5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsZnVuY3Rpb24oZSl7byhlLFwibndcIil9KTt2YXIgbT1pLnJvb3RIdG1sLnF1ZXJ5U2VsZWN0b3IoXCIudHEtdWktZmx5aW5nLXBhbmVsX19ib3JkZXIudHEtdWktYm90dG9tLXJpZ2h0LWJvcmRlclwiKTttLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIixmdW5jdGlvbihlKXtvKGUsXCJzZVwiKX0pO3ZhciB5PWkucm9vdEh0bWwucXVlcnlTZWxlY3RvcihcIi50cS11aS1mbHlpbmctcGFuZWxfX2JvcmRlci50cS11aS1ib3R0b20tbGVmdC1ib3JkZXJcIik7eS5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsZnVuY3Rpb24oZSl7byhlLFwic3dcIil9KX1pLl90cmlnZ2VyQnV0dG9uPXIoZS50cmlnZ2VyQnV0dG9uKSxuKCksaS5fdHJpZ2dlckJ1dHRvbiYmKGkuX3RyaWdnZXJCdXR0b24ub25jbGljaz1mdW5jdGlvbigpe2w/aS5zaG93KCk6aS5oaWRlKCl9KX1mdW5jdGlvbiBuKCl7bD8oaS5fdHJpZ2dlckJ1dHRvbiYmKGkuX3RyaWdnZXJCdXR0b24uY2xhc3NOYW1lPWkuX3RyaWdnZXJCdXR0b24uY2xhc3NOYW1lLnJlcGxhY2UoLyB0cS11aS1zZWxlY3RlZC9naSxcIlwiKSksaS5yb290SHRtbC5jbGFzc05hbWU9aS5yb290SHRtbC5jbGFzc05hbWUrXCIgdHEtdWktY29sbGFwc2VkXCIpOihpLl90cmlnZ2VyQnV0dG9uJiYoaS5fdHJpZ2dlckJ1dHRvbi5jbGFzc05hbWU9aS5fdHJpZ2dlckJ1dHRvbi5jbGFzc05hbWUrXCIgdHEtdWktc2VsZWN0ZWRcIiksaS5yb290SHRtbC5jbGFzc05hbWU9aS5yb290SHRtbC5jbGFzc05hbWUucmVwbGFjZSgvIHRxLXVpLWNvbGxhcHNlZC9naSxcIlwiKSl9ZnVuY3Rpb24gbyhlLHQpe2Z1bmN0aW9uIG4oZSl7aS5fbW91c2VNb3ZlPSEwO3ZhciBuPTA7ZS5wYWdlWD9uPWUucGFnZVg6ZS5jbGllbnRYJiYobj1lLmNsaWVudFgpO3ZhciBvPW4tbDtsPW4sdHx8KGkucm9vdEh0bWwuc3R5bGUubGVmdD1pLnJvb3RIdG1sLm9mZnNldExlZnQrbytcInB4XCIpO3ZhciBzPTA7ZS5wYWdlWT9zPWUucGFnZVk6ZS5jbGllbnRZJiYocz1lLmNsaWVudFkpO3ZhciB1PXMtYTthPXMsdHx8KGkucm9vdEh0bWwuc3R5bGUudG9wPWkucm9vdEh0bWwub2Zmc2V0VG9wK3UrXCJweFwiKSx0PyhyKG8sdSx0KSxpLnRyaWdnZXIoXCJzaXplLWNoYW5nZWRcIix7d2lkdGg6aS5yb290SHRtbC5vZmZzZXRXaWR0aCxoZWlnaHQ6aS5yb290SHRtbC5vZmZzZXRIZWlnaHR9KSx0LmluZGV4T2YoXCJuXCIpPT09LTEmJnQuaW5kZXhPZihcIndcIik9PT0tMXx8aS50cmlnZ2VyKFwicG9zaXRpb24tY2hhbmdlZFwiLHt4Omkucm9vdEh0bWwub2Zmc2V0TGVmdCx5Omkucm9vdEh0bWwub2Zmc2V0VG9wfSkpOmkudHJpZ2dlcihcInBvc2l0aW9uLWNoYW5nZWRcIix7eDppLnJvb3RIdG1sLm9mZnNldExlZnQseTppLnJvb3RIdG1sLm9mZnNldFRvcH0pfWZ1bmN0aW9uIG8oZSl7aS5fbW91c2VNb3ZlJiYobihlLCEwKSxpLl9tb3VzZU1vdmU9ITEpLGRvY3VtZW50LmJvZHkub25tb3VzZW1vdmU9ZG9jdW1lbnQuYm9keS5vbm1vdXNldXA9bnVsbCxkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIixuKSxkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsbyl9ZnVuY3Rpb24gcihlLHQsbil7c3dpdGNoKG4pe2Nhc2VcIm5cIjppLnJvb3RIdG1sLnN0eWxlLmhlaWdodD1pLnJvb3RIdG1sLm9mZnNldEhlaWdodC10K1wicHhcIixpLnJvb3RIdG1sLnN0eWxlLnRvcD1pLnJvb3RIdG1sLm9mZnNldFRvcCt0K1wicHhcIjticmVhaztjYXNlXCJlXCI6aS5yb290SHRtbC5zdHlsZS53aWR0aD1pLnJvb3RIdG1sLm9mZnNldFdpZHRoK2UrXCJweFwiO2JyZWFrO2Nhc2VcInNcIjppLnJvb3RIdG1sLnN0eWxlLmhlaWdodD1pLnJvb3RIdG1sLm9mZnNldEhlaWdodCt0K1wicHhcIjticmVhaztjYXNlXCJ3XCI6aS5yb290SHRtbC5zdHlsZS53aWR0aD1pLnJvb3RIdG1sLm9mZnNldFdpZHRoLWUrXCJweFwiLGkucm9vdEh0bWwuc3R5bGUubGVmdD1pLnJvb3RIdG1sLm9mZnNldExlZnQrZStcInB4XCI7YnJlYWs7Y2FzZVwibmVcIjppLnJvb3RIdG1sLnN0eWxlLndpZHRoPWkucm9vdEh0bWwub2Zmc2V0V2lkdGgrZStcInB4XCIsaS5yb290SHRtbC5zdHlsZS5oZWlnaHQ9aS5yb290SHRtbC5vZmZzZXRIZWlnaHQtdCtcInB4XCIsaS5yb290SHRtbC5zdHlsZS50b3A9aS5yb290SHRtbC5vZmZzZXRUb3ArdCtcInB4XCI7YnJlYWs7Y2FzZVwibndcIjppLnJvb3RIdG1sLnN0eWxlLmhlaWdodD1pLnJvb3RIdG1sLm9mZnNldEhlaWdodC10K1wicHhcIixpLnJvb3RIdG1sLnN0eWxlLnRvcD1pLnJvb3RIdG1sLm9mZnNldFRvcCt0K1wicHhcIixpLnJvb3RIdG1sLnN0eWxlLndpZHRoPWkucm9vdEh0bWwub2Zmc2V0V2lkdGgtZStcInB4XCIsaS5yb290SHRtbC5zdHlsZS5sZWZ0PWkucm9vdEh0bWwub2Zmc2V0TGVmdCtlK1wicHhcIjticmVhaztjYXNlXCJzZVwiOmkucm9vdEh0bWwuc3R5bGUud2lkdGg9aS5yb290SHRtbC5vZmZzZXRXaWR0aCtlK1wicHhcIixpLnJvb3RIdG1sLnN0eWxlLmhlaWdodD1pLnJvb3RIdG1sLm9mZnNldEhlaWdodCt0K1wicHhcIjticmVhaztjYXNlXCJzd1wiOmkucm9vdEh0bWwuc3R5bGUuaGVpZ2h0PWkucm9vdEh0bWwub2Zmc2V0SGVpZ2h0K3QrXCJweFwiLGkucm9vdEh0bWwuc3R5bGUud2lkdGg9aS5yb290SHRtbC5vZmZzZXRXaWR0aC1lK1wicHhcIixpLnJvb3RIdG1sLnN0eWxlLmxlZnQ9aS5yb290SHRtbC5vZmZzZXRMZWZ0K2UrXCJweFwifX12YXIgbD0wLGE9MDtlLnBhZ2VYP2w9ZS5wYWdlWDplLmNsaWVudFgmJihsPWUuY2xpZW50WCksZS5wYWdlWT9hPWUucGFnZVk6ZS5jbGllbnRZJiYoYT1lLmNsaWVudFkpLHdpbmRvdy5nZXRTZWxlY3Rpb24oKS5yZW1vdmVBbGxSYW5nZXMoKSxkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIixuKSxkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsbyl9c1tcImRlZmF1bHRcIl0uYXBwbHkodGhpcyk7dmFyIGk9dGhpcztlfHwoZT17fSk7dmFyIGw9IWUuYWN0aXZlO2kubWFya3VwPSdcXG4gICAgICAgIDxkaXYgY2xhc3M9XCJ0cS11aS1mbHlpbmctcGFuZWxcIlxcbiAgICAgICAgICAgIHN0eWxlPVwiXFxuICAgICAgICAgICAgICAgIHdpZHRoOiAnKyhlLnNpemU/ZS5zaXplLndpZHRoOlwiXCIpK1wiO1xcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IFwiKyhlLnNpemU/ZS5zaXplLmhlaWdodDpcIlwiKStcIjtcXG4gICAgICAgICAgICAgICAgbGVmdDogXCIrKGUucG9zaXRpb24/ZS5wb3NpdGlvbi54OlwiXCIpK1wiO1xcbiAgICAgICAgICAgICAgICB0b3A6IFwiKyhlLnBvc2l0aW9uP2UucG9zaXRpb24ueTpcIlwiKSsnO1xcbiAgICAgICAgICAgIFwiXFxuICAgICAgICA+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRxLXVpLWZseWluZy1wYW5lbF9oZWFkZXJcIj5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRxLXVpLWZseWluZy1wYW5lbF9oZWFkZXJfX2hlYWRlclwiPlxcbiAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVwidHEtdWktd2luZG93LWhlYWRlci1sYWJlbFwiPicrKGUuaGVhZGVyP2UuaGVhZGVyOlwiXCIpKyc8L2xhYmVsPlxcbiAgICAgICAgICAgICAgICAgICAgPGltZyBjbGFzcz1cInRxLXVpLXdpbmRvd3MtY29sbGFwc2UtYnV0dG9uXCIvPlxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwidHEtdWktYm9keVwiPlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidHEtdWktYm9keV9jb250YWluZXIgJysoZS5yZW1vdmVCYWNrZ3JvdW5kP1widHEtdWktYm9keV9lbXB0eS1jb250YWluZXJcIjpcInRxLXVpLWJvZHlfZGVmYXVsdC1jb250YWluZXJcIikrJ1wiPlxcbiAgICAgICAgICAgICAgICAgICAgJysoZS5ib2R5JiZcInN0cmluZ1wiPT10eXBlb2YgZS5ib2R5P2UuYm9keTpcIlwiKStcIlxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICBcIisoZS5yZXNpemFibGU/J1xcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidHEtdWktZmx5aW5nLXBhbmVsX19ib3JkZXIgdHEtdWktdG9wLWJvcmRlclwiPjwvZGl2PlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidHEtdWktZmx5aW5nLXBhbmVsX19ib3JkZXIgdHEtdWktcmlnaHQtYm9yZGVyXCI+PC9kaXY+XFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0cS11aS1mbHlpbmctcGFuZWxfX2JvcmRlciB0cS11aS1ib3R0b20tYm9yZGVyXCI+PC9kaXY+XFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0cS11aS1mbHlpbmctcGFuZWxfX2JvcmRlciB0cS11aS1sZWZ0LWJvcmRlclwiPjwvZGl2PlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidHEtdWktZmx5aW5nLXBhbmVsX19ib3JkZXIgdHEtdWktdG9wLWxlZnQtYm9yZGVyXCI+PC9kaXY+XFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0cS11aS1mbHlpbmctcGFuZWxfX2JvcmRlciB0cS11aS10b3AtcmlnaHQtYm9yZGVyXCI+PC9kaXY+XFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0cS11aS1mbHlpbmctcGFuZWxfX2JvcmRlciB0cS11aS1ib3R0b20tbGVmdC1ib3JkZXJcIj48L2Rpdj5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRxLXVpLWZseWluZy1wYW5lbF9fYm9yZGVyIHRxLXVpLWJvdHRvbS1yaWdodC1ib3JkZXJcIj48L2Rpdj5cXG4gICAgICAgICAgICAnOlwiXCIpK1wiXFxuICAgICAgICA8L2Rpdj5cIjt2YXIgYT1yKGUuYmFzZUVsZW1lbnQpO2EuaW5uZXJIVE1MPWkubWFya3VwLGkucm9vdEh0bWw9YS5xdWVyeVNlbGVjdG9yKFwiLnRxLXVpLWZseWluZy1wYW5lbFwiKSxpLmlkPWUuaWR8fFwiZmx5aW5nUGFuZWwtXCIrdSsrLGkucm9vdEh0bWwuaWQ9aS5pZCxpLnNob3c9ZnVuY3Rpb24oZSl7ZSYmZS5zdG9wUHJvcGFnYXRpb24oKSxsJiYobD0hMSxuKCkpfSxpLmhpZGU9ZnVuY3Rpb24oZSl7ZSYmZS5zdG9wUHJvcGFnYXRpb24oKSxsfHwobD0hMCxuKCkpfSx0KCl9ZnVuY3Rpb24gcihlKXt2YXIgdD12b2lkIDA7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIGU/dD1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChlKTpcIm9iamVjdFwiPT09KFwidW5kZWZpbmVkXCI9PXR5cGVvZiBlP1widW5kZWZpbmVkXCI6bChlKSkmJih0PWUpLHR9T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIGw9XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKGUpe3JldHVybiB0eXBlb2YgZX06ZnVuY3Rpb24oZSl7cmV0dXJuIGUmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmZS5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmZSE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgZX07bi5GbHlpbmdQYW5lbD1pO3ZhciBhPWUoXCIuL3N1YnNjcmlwdGlvbkFQSS9zdWJzY3JpYmVhYmxlXCIpLHM9byhhKSx1PTA7bltcImRlZmF1bHRcIl09aX0se1wiLi9zdWJzY3JpcHRpb25BUEkvc3Vic2NyaWJlYWJsZVwiOjh9XSwzOltmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbyhlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e1wiZGVmYXVsdFwiOmV9fWZ1bmN0aW9uIGkoZSl7ZnVuY3Rpb24gdChlKXtmdW5jdGlvbiB0KGUpe3ZhciB0PWUubGFiZWwsbj1lLmxhYmVsK1wiIChcIitlLmlkK1wiKVwiLG89ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIkxJXCIpO3JldHVybiBvLmNsYXNzTmFtZT1cInRxLXVpLXByb3BlcnR5LWJ1dHRvblwiLG8udGl0bGU9bixvLmlubmVyVGV4dD10LG8ub25jbGljaz1mdW5jdGlvbigpe2kudHJpZ2dlcihcInNlbGVjdGVkLWVsZW1lbnQtY2hhbmdlZFwiLGUuaWQpfSxvfXZhciBuPWkucm9vdEh0bWwucXVlcnlTZWxlY3RvcihcIiNyZWxhdGVkRWxlbWVudHNcIik7bi5pbm5lckhUTUw9XCJcIjt2YXIgbz1lLmluY29taW5nc3x8W107aWYoby5sZW5ndGgpe3ZhciByPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJMQUJFTFwiKTtyLmNsYXNzTmFtZT1cInRxLWxhYmVsXCIsci5pbm5lclRleHQ9XCJJbmNvbWluZyBub2RlczpcIixuLmFwcGVuZENoaWxkKHIpO3ZhciBsPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJVTFwiKTtsLmNsYXNzTmFtZT1cInRxLXVpLWluZm8tcGFuZWxfcmVsYXRlZC1lbGVtZW50c19saXN0XCIsbi5hcHBlbmRDaGlsZChsKSxvLmZvckVhY2goZnVuY3Rpb24oZSl7bC5hcHBlbmRDaGlsZCh0KGUpKX0pfXZhciBhPWUub3V0Z29pbmdzfHxbXTtpZihhLmxlbmd0aCl7dmFyIHM9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIkxBQkVMXCIpO3MuY2xhc3NOYW1lPVwidHEtbGFiZWxcIixzLmlubmVyVGV4dD1cIk91dGdvaW5nIG5vZGVzOlwiLG4uYXBwZW5kQ2hpbGQocyk7dmFyIHU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIlVMXCIpO3UuY2xhc3NOYW1lPVwidHEtdWktaW5mby1wYW5lbF9yZWxhdGVkLWVsZW1lbnRzX2xpc3RcIixuLmFwcGVuZENoaWxkKHUpLGEuZm9yRWFjaChmdW5jdGlvbihlKXt1LmFwcGVuZENoaWxkKHQoZSkpfSl9fWZ1bmN0aW9uIG4oZSl7dmFyIHQ9XCJcIjtyZXR1cm4gT2JqZWN0LmtleXMoZSkuZm9yRWFjaChmdW5jdGlvbihuKXt0Kz0nPGxhYmVsIGZvcj1cIicrbisnXCIgY2xhc3M9XCJ0cS1sYWJlbFwiPicrbisnPC9sYWJlbD5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgaWQ9XCInK24rJ1wiIHR5cGU9XCJ0ZXh0XCIgY2xhc3M9XCJ0cS11aS1wcm9wZXJ0eVwiIHZhbHVlPVwiJytlW25dKydcIiBkaXNhYmxlZD48L2lucHV0Pid9KSx0fWZ1bmN0aW9uIG8oKXt2YXIgZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiRElWXCIpO3JldHVybiBlLmNsYXNzTmFtZT1cInRxLXVpLWluZm8tcGFuZWxcIixlLmlubmVySFRNTD1pLm1hcmt1cCxlfWxbXCJkZWZhdWx0XCJdLmFwcGx5KHRoaXMpLGV8fChlPXt9KTt2YXIgaT10aGlzLHI9ZS5wbGFjZWhvbGRlcnx8XCJTZWxlY3QgYSBkaWFncmFtIGVsZW1lbnRcIixzPSc8ZGl2IGNsYXNzPVwidHEtdWktaW5mby1wYW5lbF9lbXB0eS1zdHVmZlwiPicrcitcIjwvZGl2PlwiO2kucm9vdEh0bWw9bygpLGkucm9vdEh0bWwuaW5uZXJIVE1MPXMsaS5pZD1lLmlkfHxcImluZm9QYW5lbC1cIithKyssaS5yb290SHRtbC5pZD1pLmlkLGkuc2V0U2VsZWN0ZWRFbGVtZW50PWZ1bmN0aW9uKG8pe2lmKG8pe2lmKGkucm9vdEh0bWwuaW5uZXJIVE1MPVwiXCIrKGUubGF1bmNoRXh0ZXJuYWwmJlwibm9kZVwiPT09by5kaWFncmFtVHlwZT8nPGRpdiBjbGFzcz1cInRxLXVpLWdyb3VwXCI+XFxuICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gaWQ9XCJ0cUxhdW5jaEV4dGVybmFsQnRuXCIgY2xhc3M9XCJ0cS1idXR0b25cIiB0aXRsZT1cIlZpZXcgbW9yZSBpbiBuZXcgdGFiLlwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIE1vcmUgJm5ic3A7XFxuICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZ2x5cGhpY29uIGdseXBoaWNvbi1uZXctd2luZG93XCI+PC9zcGFuPjwvYnV0dG9uPlxcbiAgICAgICAgICAgICAgICAgICAgIDwvZGl2Pic6XCJcIikrKG8uaWQ/J1xcbiAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVwidHEtbGFiZWxcIj5JRDwvbGFiZWw+XFxuICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdmFsdWU9XCInK28uaWQrJ1wiIHR5cGU9XCJ0ZXh0XCIgY2xhc3M9XCJ0cS11aS1wcm9wZXJ0eVwiIGRpc2FibGVkPjwvaW5wdXQ+XFxuICAgICAgICAgICAgICAgICc6XCJcIikrKG8ubGFiZWw/J1xcbiAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVwidHEtbGFiZWxcIj5MYWJlbDwvbGFiZWw+XFxuICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdmFsdWU9XCInK28ubGFiZWwrJ1wiIHR5cGU9XCJ0ZXh0XCIgY2xhc3M9XCJ0cS11aS1wcm9wZXJ0eVwiIGRpc2FibGVkPjwvaW5wdXQ+XFxuICAgICAgICAgICAgICAgICc6XCJcIikrKG8udHlwZXM/J1xcbiAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVwidHEtbGFiZWxcIj5UeXBlczwvbGFiZWw+XFxuICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdmFsdWU9XCInK28udHlwZXMrJ1wiIHR5cGU9XCJ0ZXh0XCIgY2xhc3M9XCJ0cS11aS1wcm9wZXJ0eVwiIGRpc2FibGVkPjwvaW5wdXQ+XFxuICAgICAgICAgICAgICAgICc6XCJcIikrKG8uc291cmNlPydcXG4gICAgICAgICAgICAgICAgICAgIDxsYWJlbCBmb3I9XCJsaW5rRnJvbVwiIGNsYXNzPVwidHEtbGFiZWxcIj5Tb3VyY2U8L2xhYmVsPlxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBpZD1cImxpbmtGcm9tXCIgdHlwZT1cInRleHRcIiBjbGFzcz1cInRxLXVpLXByb3BlcnR5LWJ1dHRvblwiPjwvZGl2PlxcbiAgICAgICAgICAgICAgICAnOlwiXCIpKyhvLnRhcmdldD8nXFxuICAgICAgICAgICAgICAgICAgICA8bGFiZWwgZm9yPVwibGlua1RvXCIgY2xhc3M9XCJ0cS1sYWJlbFwiPlRhcmdldDwvbGFiZWw+XFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGlkPVwibGlua1RvXCIgdHlwZT1cInRleHRcIiBjbGFzcz1cInRxLXVpLXByb3BlcnR5LWJ1dHRvblwiPjwvZGl2PlxcbiAgICAgICAgICAgICAgICAnOlwiXCIpKyhvLnRoaWNrbmVzcz8nXFxuICAgICAgICAgICAgICAgICAgICA8bGFiZWwgZm9yPVwidGhpY2tuZXNzXCIgY2xhc3M9XCJ0cS1sYWJlbFwiPlRoaWNrbmVzczwvbGFiZWw+XFxuICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdmFsdWU9XCInK28udGhpY2tuZXNzKydcIiB0eXBlPVwidGV4dFwiIGNsYXNzPVwidHEtdWktcHJvcGVydHlcIiBkaXNhYmxlZD48L2lucHV0PlxcbiAgICAgICAgICAgICAgICAnOlwiXCIpKyhvLmRhdGE/bihvLmRhdGEpOlwiXCIpKyhvLnJlbGF0aW9ucz8nXFxuICAgICAgICAgICAgICAgICAgICA8bGFiZWwgZm9yPVwicmVsYXRlZEVsZW1lbnRzXCIgY2xhc3M9XCJ0cS1sYWJlbFwiPlJlbGF0ZWQgZWxlbWVudHM8L2xhYmVsPlxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiAgIGlkPVwicmVsYXRlZEVsZW1lbnRzXCIgY2xhc3M9XCJ0cS11aS1pbmZvLXBhbmVsX3JlbGF0ZWQtZWxlbWVudHNcIj48L2Rpdj5cXG4gICAgICAgICAgICAgICAgJzpcIlwiKSxlLmxhdW5jaEV4dGVybmFsJiZcIm5vZGVcIj09PW8uZGlhZ3JhbVR5cGUpe3ZhciByPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwidHFMYXVuY2hFeHRlcm5hbEJ0blwiKTtyLm9uY2xpY2s9ZnVuY3Rpb24oKXtlLmxhdW5jaEV4dGVybmFsKG8pfX1pZihvLnJlbGF0aW9ucyYmdChvLnJlbGF0aW9ucyksby5zb3VyY2Upe3ZhciBsPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibGlua0Zyb21cIik7bC5pbm5lclRleHQ9by5zb3VyY2UubGFiZWwsbC50aXRsZT1vLnNvdXJjZS5sYWJlbCtcIihJRDogXCIrby5zb3VyY2UuaWQrXCIpXCIsbC5vbmNsaWNrPWZ1bmN0aW9uKCl7aS50cmlnZ2VyKFwic2VsZWN0ZWQtZWxlbWVudC1jaGFuZ2VkXCIsby5zb3VyY2UuaWQpfX1pZihvLnRhcmdldCl7dmFyIGE9ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJsaW5rVG9cIik7YS5pbm5lclRleHQ9by50YXJnZXQubGFiZWwsYS50aXRsZT1vLnRhcmdldC5sYWJlbCtcIihJRDogXCIrby50YXJnZXQuaWQrXCIpXCIsYS5vbmNsaWNrPWZ1bmN0aW9uKCl7aS50cmlnZ2VyKFwic2VsZWN0ZWQtZWxlbWVudC1jaGFuZ2VkXCIsby50YXJnZXQuaWQpfX19ZWxzZSBpLnJvb3RIdG1sLmlubmVySFRNTD1zfSxlLnNlbGVjdGVkRWxlbWVudCYmaS5zZXRTZWxlY3RlZEVsZW1lbnQoZS5zZWxlY3RlZEVsZW1lbnQpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLG4uSW5mb1BhbmVsPWk7dmFyIHI9ZShcIi4vc3Vic2NyaXB0aW9uQVBJL3N1YnNjcmliZWFibGVcIiksbD1vKHIpLGE9MDtuW1wiZGVmYXVsdFwiXT1pfSx7XCIuL3N1YnNjcmlwdGlvbkFQSS9zdWJzY3JpYmVhYmxlXCI6OH1dLDQ6W2Z1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBvKGUpe2Z1bmN0aW9uIHQoKXt2YXIgZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiRElWXCIpO3JldHVybiBlLmlubmVySFRNTD1uLm1hcmt1cCxlLnF1ZXJ5U2VsZWN0b3IoXCIudHEtdWktbGVnZW5kLXBhbmVsX2JvZHlfbGVnZW5kc1wiKX12YXIgbj10aGlzO2V8fChlPXt9KTt2YXIgbz1lLmxlZ2VuZHN8fFtdO24ubWFya3VwPSdcXG4gICAgICAgIDxkaXYgY2xhc3M9XCJ0cS11aS1sZWdlbmQtcGFuZWxfYm9keV9sZWdlbmRzXCI+XFxuICAgICAgICAnK28ubWFwKGZ1bmN0aW9uKGUpe3JldHVybidcXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRxLXVpLWxlZ2VuZC1wYW5lbF9ib2R5X2xlZ2VuZHNfbGVnZW5kXCIgdGl0bGU9XCInK2UuZGVzY3JpcHRpb24rJ1wiPlxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRxLXVpLWxlZ2VuZC1wYW5lbF9ib2R5X2xlZ2VuZHNfbGVnZW5kX2ltZ1wiPjxpbWcgc3JjPVwiJytlLmltYWdlKydcIj48L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cInRxLWxhYmVsXCI+JytlLmxhYmVsK1wiPC9sYWJlbD5cXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgXCJ9KS5qb2luKFwiXCIpK1wiXFxuICAgICAgICA8L2Rpdj5cXG4gICAgXCIsbi5yb290SHRtbD10KCksbi5pZD1lLmlkfHxcImxlZ2VuZHMtXCIraSsrLG4ucm9vdEh0bWwuaWQ9bi5pZH1PYmplY3QuZGVmaW5lUHJvcGVydHkobixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxuLkxlZ2VuZHM9bzt2YXIgaT0wO25bXCJkZWZhdWx0XCJdPW99LHt9XSw1OltmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbyhlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e1wiZGVmYXVsdFwiOmV9fXZhciBpPWUoXCIuL2NvbG9yZWRCdXR0b25zTGlzdFwiKSxyPW8oaSksbD1lKFwiLi9mbHlpbmdQYW5lbFwiKSxhPW8obCkscz1lKFwiLi9pbmZvUGFuZWxcIiksdT1vKHMpLGQ9ZShcIi4vbGVnZW5kc1wiKSxjPW8oZCksZj1lKFwiLi9wcm9ncmVzc1NjcmVlblwiKSxwPW8oZiksYj1lKFwiLi9zZWFyY2hQYW5lbFwiKSxtPW8oYikseT1lKFwiLi9zd2l0Y2hlclwiKSx2PW8oeSksZz1lKFwiLi90YWJQYW5lbFwiKSxoPW8oZyksSD1lKFwiLi90b29sYmFyXCIpLHE9byhIKTt0LmV4cG9ydHM9e0NvbG9yZWRCdXR0b25zTGlzdDpyW1wiZGVmYXVsdFwiXSxGbHlpbmdQYW5lbDphW1wiZGVmYXVsdFwiXSxJbmZvUGFuZWw6dVtcImRlZmF1bHRcIl0sTGVnZW5kczpjW1wiZGVmYXVsdFwiXSxQcm9ncmVzc1NjcmVlbjpwW1wiZGVmYXVsdFwiXSxTZWFyY2hQYW5lbDptW1wiZGVmYXVsdFwiXSxTd2l0Y2hlcjp2W1wiZGVmYXVsdFwiXSxUYWJQYW5lbDpoW1wiZGVmYXVsdFwiXSxUb29sYmFyOnFbXCJkZWZhdWx0XCJdfX0se1wiLi9jb2xvcmVkQnV0dG9uc0xpc3RcIjoxLFwiLi9mbHlpbmdQYW5lbFwiOjIsXCIuL2luZm9QYW5lbFwiOjMsXCIuL2xlZ2VuZHNcIjo0LFwiLi9wcm9ncmVzc1NjcmVlblwiOjYsXCIuL3NlYXJjaFBhbmVsXCI6NyxcIi4vc3dpdGNoZXJcIjo5LFwiLi90YWJQYW5lbFwiOjEwLFwiLi90b29sYmFyXCI6MTF9XSw2OltmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbyhlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e1wiZGVmYXVsdFwiOmV9fWZ1bmN0aW9uIGkoZSl7ZnVuY3Rpb24gdCgpe3ZhciBlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJESVZcIik7cmV0dXJuIGUuY2xhc3NOYW1lPVwidHEtdWktcHJvZ3Jlc3Mtc2NyZWVuXCIsZS5pbm5lckhUTUw9by5tYXJrdXAsZX1mdW5jdGlvbiBuKGUpe3ZhciB0PXZvaWQgMDtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgZT90PWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGUpOlwib2JqZWN0XCI9PT0oXCJ1bmRlZmluZWRcIj09dHlwZW9mIGU/XCJ1bmRlZmluZWRcIjpyKGUpKSYmKHQ9ZSksdH1hW1wiZGVmYXVsdFwiXS5hcHBseSh0aGlzKTt2YXIgbz10aGlzO2V8fChlPXt9KSxvLm1hcmt1cD1cIlwiLG8uc3RhdGU9XCJjb21wbGV0ZWRcIixvLnJvb3RIdG1sPXQoKSxvLmlkPWUuaWR8fFwidGFiUGFuZWwtXCIrcysrLG8ucm9vdEh0bWwuaWQ9by5pZDt2YXIgaT1uKGUuYmFzZUVsZW1lbnQpO2kuYXBwZW5kQ2hpbGQoby5yb290SHRtbCksby5zZXRTdGF0ZT1mdW5jdGlvbihlLHQpe2UmJihvLnN0YXRlPWUsXCJhY3RpdmVcIj09PWU/KG8ucm9vdEh0bWwuaW5uZXJIVE1MPVwiPGgxPlwiKyh0fHx1KSsnPC9oMT48ZGl2IGNsYXNzPVwidHEtdWktcHJvZ3Jlc3Mtc2NyZWVuX19wcm9ncmVzc1wiPjwvZGl2Picsby5yb290SHRtbC5zdHlsZS5kaXNwbGF5PW51bGwpOlwiY29tcGxldGVkXCI9PT1lPyhvLnJvb3RIdG1sLmlubmVySFRNTD1cIlwiLG8ucm9vdEh0bWwuc3R5bGUuZGlzcGxheT1cIm5vbmVcIik6XCJlcnJvclwiPT09ZSYmKG8ucm9vdEh0bWwuaW5uZXJIVE1MPVwiPGgxPlwiKyh0fHxkKStcIjwvaDE+XCIsby5yb290SHRtbC5zdHlsZS5kaXNwbGF5PW51bGwpLG8udHJpZ2dlcihcImRpYWdyYW0tc3RhdGUtY2hhbmdlZFwiLGUpKX0sby5zZXRTdGF0ZShlLnN0YXRlLGUudGV4dCl9T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHI9XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKGUpe3JldHVybiB0eXBlb2YgZX06ZnVuY3Rpb24oZSl7cmV0dXJuIGUmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmZS5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmZSE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgZX07bi5Qcm9ncmVzc1NjcmVlbj1pO3ZhciBsPWUoXCIuL3N1YnNjcmlwdGlvbkFQSS9zdWJzY3JpYmVhYmxlXCIpLGE9byhsKSxzPTAsdT1cIkxvYWRpbmdcIixkPVwiRXJyb3IgaGFzIG9jY3VycmVkIVwiO25bXCJkZWZhdWx0XCJdPWl9LHtcIi4vc3Vic2NyaXB0aW9uQVBJL3N1YnNjcmliZWFibGVcIjo4fV0sNzpbZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIG8oZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntcImRlZmF1bHRcIjplfX1mdW5jdGlvbiBpKGUpe2xbXCJkZWZhdWx0XCJdLmFwcGx5KHRoaXMpLGV8fChlPXt9KTt2YXIgdD1lLnNlYXJjaEJ1dHRvbklkfHxcInRxTGdTZWFyY2hCdXR0b25cIixuPWUuc2VhcmNoSWR8fFwic2VhcmNoXCI7c1tcImRlZmF1bHRcIl0uYXBwbHkodGhpcyxbe2lkOmUuaWQsYmFzZUVsZW1lbnQ6ZS5iYXNlRWxlbWVudCxhY3RpdmU6ZS5hY3RpdmUsaGVhZGVyOmUuaGVhZGVyfHxcIlNlYXJjaCBwYW5lbFwiLHRyaWdnZXJCdXR0b246ZS50cmlnZ2VyQnV0dG9uLGJvZHk6XCJcXG4gICAgICAgICAgICA8c3BhbiBpZD0gXCIrdCsnIGNsYXNzPVwidHEtdWktc2VhcmNoLWljb24gZ2x5cGhpY29uIGdseXBoaWNvbi1zZWFyY2hcIiBhcmlhLWhpZGRlbj1cInRydWVcIj48L3NwYW4+XFxuICAgICAgICAgICAgPGlucHV0IGlkPVwiJytuKydcIiBwbGFjZUhvbGRlcj1cIlNlYXJjaC4uLlwiIGNsYXNzPVwidHEtdWktc2VhcmNoLWlucHV0XCI+PC9pbnB1dD5cXG4gICAgICAgICcscmVtb3ZlQmFja2dyb3VuZDohMCxzaXplOnt3aWR0aDpcIjI2MHB4XCIsaGVpZ2h0OlwiNzBweFwifX1dKX1PYmplY3QuZGVmaW5lUHJvcGVydHkobixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxuLlNlYXJjaFBhbmVsPWk7dmFyIHI9ZShcIi4vc3Vic2NyaXB0aW9uQVBJL3N1YnNjcmliZWFibGVcIiksbD1vKHIpLGE9ZShcIi4vZmx5aW5nUGFuZWxcIikscz1vKGEpO25bXCJkZWZhdWx0XCJdPWl9LHtcIi4vZmx5aW5nUGFuZWxcIjoyLFwiLi9zdWJzY3JpcHRpb25BUEkvc3Vic2NyaWJlYWJsZVwiOjh9XSw4OltmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbygpe3ZhciBlPXRoaXM7ZS5fc3Vic2NyaWJ0aW9ucz17fSxlLm9uPWZ1bmN0aW9uKHQsbil7ZS5fc3Vic2NyaWJ0aW9uc1t0XXx8KGUuX3N1YnNjcmlidGlvbnNbdF09W10pLGUuX3N1YnNjcmlidGlvbnNbdF0ucHVzaChuKX0sZS51bnN1YnNjcmliZT1mdW5jdGlvbih0KXtPYmplY3Qua2V5cyhlLl9zdWJzY3JpYnRpb25zKS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIGUuX3N1YnNjcmlidGlvbnNbdF19KS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3ZhciBuPWUuaW5kZXhPZih0KTtuIT09LTEmJmUuc3BsaWNlKG4sMSl9KX0sZS50cmlnZ2VyPWZ1bmN0aW9uKHQsbil7dmFyIG89dGhpcztuIGluc3RhbmNlb2YgQXJyYXl8fChuPVtuXSksZS5fc3Vic2NyaWJ0aW9ucyYmZS5fc3Vic2NyaWJ0aW9uc1t0XSYmZS5fc3Vic2NyaWJ0aW9uc1t0XS5mb3JFYWNoKGZ1bmN0aW9uKGUpe2UuYXBwbHkobyxuKX0pfX1PYmplY3QuZGVmaW5lUHJvcGVydHkobixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxuLlN1YnNjcmliYWJsZT1vLG5bXCJkZWZhdWx0XCJdPW99LHt9XSw5OltmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbyhlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e1wiZGVmYXVsdFwiOmV9fWZ1bmN0aW9uIGkoZSl7ZnVuY3Rpb24gdCgpe3ZhciB0PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJESVZcIik7cmV0dXJuIHQuY2xhc3NOYW1lPVwidHEtdWktc3dpdGNoLWJ1dHRvbnNcIisoZS52ZXJ0aWNhbE9yaWVudGF0aW9uP1wiLXZlcnRpY2FsXCI6XCJcIiksdC5pbm5lckhUTUw9bi5tYXJrdXAsdH1sW1wiZGVmYXVsdFwiXS5hcHBseSh0aGlzKSxlfHwoZT17fSk7dmFyIG49dGhpcyxvPWUuc3RhdGVzfHxbXTtuLm1hcmt1cD1vLm1hcChmdW5jdGlvbih0LG4pe3JldHVybic8YnV0dG9uIGlkPVwiJyt0LmlkKydcIiAnKygwIT09bj9cIlwiOlwiZGlzYWJsZWRcIikrJyB0aXRsZT1cIicrKHQubGFiZWx8fHQuaWQpKydcIj5cXG4gICAgICAgICAgICAnKyhlLnZlcnRpY2FsT3JpZW50YXRpb24mJnQuaWNvbj8nPHNwYW4gY2xhc3M9XCInK3QuaWNvbisnXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9zcGFuPic6dC5sYWJlbHx8dC5pZCkrXCJcXG4gICAgICAgIDwvYnV0dG9uPlwifSkuam9pbihcIlwiKSxuLnJvb3RIdG1sPXQoKSxuLmlkPWUuaWR8fFwic3dpdGNoZXItXCIrYSsrLG4ucm9vdEh0bWwuaWQ9bi5pZDt2YXIgaT1udWxsO28uZm9yRWFjaChmdW5jdGlvbihlLHQpe3ZhciBvPW4ucm9vdEh0bWwucXVlcnlTZWxlY3RvcihcIiNcIitlLmlkKTswPT09dCYmKGk9byksby5vbmNsaWNrPWZ1bmN0aW9uKCl7by5kaXNhYmxlZD0hMCxpLmRpc2FibGVkPSExLGk9byxuLnRyaWdnZXIoXCJzdGF0ZS1jaGFuZ2VkXCIsZS5pZCl9fSksbi5zZXRTdGF0ZT1mdW5jdGlvbihlKXt2YXIgdD1uLnJvb3RIdG1sLnF1ZXJ5U2VsZWN0b3IoXCIjXCIrZSk7dCYmZSE9PWkuaWQmJih0LmRpc2FibGVkPSEwLGkuZGlzYWJsZWQ9ITEsaT10KX19T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksbi5Td2l0Y2hlcj1pO3ZhciByPWUoXCIuL3N1YnNjcmlwdGlvbkFQSS9zdWJzY3JpYmVhYmxlXCIpLGw9byhyKSxhPTA7bltcImRlZmF1bHRcIl09aX0se1wiLi9zdWJzY3JpcHRpb25BUEkvc3Vic2NyaWJlYWJsZVwiOjh9XSwxMDpbZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIG8oZSl7ZnVuY3Rpb24gdCgpe3ZhciBlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJESVZcIik7cmV0dXJuIGUuY2xhc3NOYW1lPVwidHEtdWktdGFiLXBhbmVsXCIsZS5pbm5lckhUTUw9bi5tYXJrdXAsZX12YXIgbj10aGlzO2V8fChlPXt9KTt2YXIgbz1lLnRhYnN8fFtdO24ubWFya3VwPSdcXG4gICAgICAgIDxkaXYgY2xhc3M9XCJ0cS11aS10YWItc3dpdGNoZXIgdHEtdWktc3dpdGNoLWJ1dHRvbnNcIj4nK28ubWFwKGZ1bmN0aW9uKGUsdCl7cmV0dXJuJ1xcbiAgICAgICAgICAgIDxidXR0b24gaWQ9XCInK2UuaWQrJ1wiICcrKDAhPT10P1wiXCI6XCJkaXNhYmxlZFwiKStcIj5cXG4gICAgICAgICAgICAgICAgXCIrKGUubGFiZWx8fGUuaWQpK1wiXFxuICAgICAgICAgICAgPC9idXR0b24+ICBcXG4gICAgICAgIFwifSkuam9pbihcIlwiKStcIjwvZGl2PlwiK28ubWFwKGZ1bmN0aW9uKGUsdCl7cmV0dXJuJ1xcbiAgICAgICAgICAgIDxkaXYgaWQ9XCInK2UuaWQrJ1BhbmVsXCIgY2xhc3M9XCJ0cS11aS10YWItcGFuZWxfcGFnZVwiIHN0eWxlPVwiZGlzcGxheTogJysoMD09PXQ/XCJcIjpcIm5vbmVcIikrJ1wiPlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidHEtdWktdGFiLXBhbmVsX3BhZ2VfYm9keVwiPlxcbiAgICAgICAgICAgICAgICAgICAgJysoXCJzdHJpbmdcIj09dHlwZW9mIGUuYm9keT9lLmJvZHk6XCJcIikrXCJcXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICBcIn0pLmpvaW4oXCJcIiksbi5yb290SHRtbD10KCksbi5pZD1lLmlkfHxcInRhYlBhbmVsLVwiK2krKyxuLnJvb3RIdG1sLmlkPW4uaWQsby5tYXAoZnVuY3Rpb24oZSl7aWYoZS5ib2R5IGluc3RhbmNlb2YgT2JqZWN0JiZlLmJvZHkucm9vdEh0bWwpe3ZhciB0PW4ucm9vdEh0bWwucXVlcnlTZWxlY3RvcihcIiNcIitlLmlkK1wiUGFuZWwgLnRxLXVpLXRhYi1wYW5lbF9wYWdlX2JvZHlcIik7dC5hcHBlbmRDaGlsZChlLmJvZHkucm9vdEh0bWwpfX0pO3ZhciByPW51bGw7by5mb3JFYWNoKGZ1bmN0aW9uKGUsdCl7dmFyIG89bi5yb290SHRtbC5xdWVyeVNlbGVjdG9yKFwiI1wiK2UuaWQpLGk9bi5yb290SHRtbC5xdWVyeVNlbGVjdG9yKFwiI1wiK2UuaWQrXCJQYW5lbFwiKTswPT09dCYmKHI9e3RhYkJ0bjpvLHRhYlBhbmVsOml9KSxvLm9uY2xpY2s9ZnVuY3Rpb24oKXtvLmRpc2FibGVkPSEwLGkuc3R5bGUuZGlzcGxheT1cIlwiLHIudGFiQnRuLmRpc2FibGVkPSExLHIudGFiUGFuZWwuc3R5bGUuZGlzcGxheT1cIm5vbmVcIixyPXt0YWJCdG46byx0YWJQYW5lbDppfX19KX1PYmplY3QuZGVmaW5lUHJvcGVydHkobixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxuLlRhYlBhbmVsPW87dmFyIGk9MDtuW1wiZGVmYXVsdFwiXT1vfSx7fV0sMTE6W2Z1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBvKGUpe2Z1bmN0aW9uIHQoZSl7dmFyIHQ9dm9pZCAwO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlKXt2YXIgbj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiRElWXCIpO24uaW5uZXJIVE1MPWUsdD1uLmZpcnN0Q2hpbGR9ZWxzZSBpZihlLmlkJiZlLmljb24pe3ZhciBvPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJESVZcIik7aWYoby5pbm5lckhUTUw9JzxidXR0b24gaWQ9XCInK2UuaWQrJ1wiIHRpdGxlPVwiJysoZS5sYWJlbHx8ZS5pZCkrJ1wiIGNsYXNzPVwidHEtdWktdG9vbGJhcl9fYnV0dG9uXCI+XFxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiJytlLmljb24rJ1wiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjwvc3Bhbj5cXG4gICAgICAgICAgICA8L2J1dHRvbj4nLHQ9by5maXJzdENoaWxkLGUuaWNvbjIpe3ZhciBpPSEwO3Qub25jbGljaz1mdW5jdGlvbihuKXt0LmlubmVySFRNTD0nPHNwYW4gY2xhc3M9XCInKyhpP2UuaWNvbjI6ZS5pY29uKSsnXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9zcGFuPicsZS5jYWxsYmFjayhuKSxpPSFpfX1lbHNlIHQub25jbGljaz1lLmNhbGxiYWNrfWVsc2UgZS5yb290SHRtbCYmKHQ9ZS5yb290SHRtbCk7cmV0dXJuIHR9ZnVuY3Rpb24gbigpe3ZhciB0PXZvaWQgMDtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgZS5iYXNlRWxlbWVudD90PWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGUuYmFzZUVsZW1lbnQpOlwib2JqZWN0XCI9PT1pKGUuYmFzZUVsZW1lbnQpJiYodD1lLmJhc2VFbGVtZW50KSx0Pyh0LmlubmVySFRNTD1vLm1hcmt1cCx0KTpudWxsfXZhciBvPXRoaXM7aWYoZXx8KGU9e30pLG8ubWFya3VwPSdcXG4gICAgICAgIDxkaXYgaWQ9XCJ0b29sYmFyUm9vdEVsZW1lbnRcIiBjbGFzcz1cInRxLXVpLXRvb2xiYXJcIj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAnLG8ucm9vdEh0bWw9bigpLG8uaWQ9ZS5pZHx8XCJ0b29sYmFyLVwiK3IrKyxvLnJvb3RIdG1sLmlkPW8uaWQsIW8ucm9vdEh0bWwpdGhyb3cgbmV3IEVycm9yKFwiVGhlIHJvb3QgZWxlbWVudCBpcyBub3Qgc3BlY2lmaWVkIVwiKTtvLmNvbnRhaW5lcj1vLnJvb3RIdG1sLnF1ZXJ5U2VsZWN0b3IoXCIjdG9vbGJhclJvb3RFbGVtZW50XCIpLG8ucHVzaFRvb2w9ZnVuY3Rpb24oZSl7dmFyIG49dChlKTtuJiYoXCJzdHJpbmdcIiE9dHlwZW9mIG4/bC5wdXNoKGUpOmwucHVzaCh7aWQ6XCJjdXN0b21odG1sXCIrcisrLG1hcmt1cDplLHJvb3RIdG1sOm59KSxvLmNvbnRhaW5lci5hcHBlbmRDaGlsZChuKSl9LG8uaW5zZXJ0VG9vbD1mdW5jdGlvbihlLG4pe3ZhciBpPU1hdGgubWluKE1hdGgubWF4KG4sMCksbC5sZW5ndGgtMSkscj1vLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFwiI1wiK2xbaV0uaWQpO2lmKHIpe3ZhciBhPXQoZSk7YSYmKGwuc3BsaWNlKGksMCxlKSxvLmNvbnRhaW5lci5pbnNlcnRCZWZvcmUoYSxyKSl9ZWxzZSBvLnB1c2hUb29sKGUpfSxvLnJlbW92ZVRvb2w9ZnVuY3Rpb24oZSl7dmFyIHQ9XCJzdHJpbmdcIj09dHlwZW9mIGU/ZTplLmlkO2wuc3BsaWNlKGwuaW5kZXhPZihlKSwxKTt2YXIgbj1vLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFwiI1wiK3QpO28uY29udGFpbmVyLnJlbW92ZUNoaWxkKG4pfTt2YXIgbD1bXTtlLnRvb2xzLmZvckVhY2goZnVuY3Rpb24oZSl7by5wdXNoVG9vbChlKX0pfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBpPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbihlKXtyZXR1cm4gdHlwZW9mIGV9OmZ1bmN0aW9uKGUpe3JldHVybiBlJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJmUuY29uc3RydWN0b3I9PT1TeW1ib2wmJmUhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIGV9O24uVG9vbGJhcj1vO3ZhciByPTA7bltcImRlZmF1bHRcIl09b30se31dfSx7fSxbNV0pKDUpfSk7IiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbmZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcclxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcclxufVxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3NyYy9hZGFwdG9yXCIpKTtcclxuX19leHBvcnQocmVxdWlyZShcIi4vc3JjL2QzYWRhcHRvclwiKSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3NyYy9kZXNjZW50XCIpKTtcclxuX19leHBvcnQocmVxdWlyZShcIi4vc3JjL2dlb21cIikpO1xyXG5fX2V4cG9ydChyZXF1aXJlKFwiLi9zcmMvZ3JpZHJvdXRlclwiKSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3NyYy9oYW5kbGVkaXNjb25uZWN0ZWRcIikpO1xyXG5fX2V4cG9ydChyZXF1aXJlKFwiLi9zcmMvbGF5b3V0XCIpKTtcclxuX19leHBvcnQocmVxdWlyZShcIi4vc3JjL2xheW91dDNkXCIpKTtcclxuX19leHBvcnQocmVxdWlyZShcIi4vc3JjL2xpbmtsZW5ndGhzXCIpKTtcclxuX19leHBvcnQocmVxdWlyZShcIi4vc3JjL3Bvd2VyZ3JhcGhcIikpO1xyXG5fX2V4cG9ydChyZXF1aXJlKFwiLi9zcmMvcHF1ZXVlXCIpKTtcclxuX19leHBvcnQocmVxdWlyZShcIi4vc3JjL3JidHJlZVwiKSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3NyYy9yZWN0YW5nbGVcIikpO1xyXG5fX2V4cG9ydChyZXF1aXJlKFwiLi9zcmMvc2hvcnRlc3RwYXRoc1wiKSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3NyYy92cHNjXCIpKTtcclxuX19leHBvcnQocmVxdWlyZShcIi4vc3JjL2JhdGNoXCIpKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBsYXlvdXRfMSA9IHJlcXVpcmUoXCIuL2xheW91dFwiKTtcclxudmFyIExheW91dEFkYXB0b3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKExheW91dEFkYXB0b3IsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBMYXlvdXRBZGFwdG9yKG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgIHZhciBzZWxmID0gX3RoaXM7XHJcbiAgICAgICAgdmFyIG8gPSBvcHRpb25zO1xyXG4gICAgICAgIGlmIChvLnRyaWdnZXIpIHtcclxuICAgICAgICAgICAgX3RoaXMudHJpZ2dlciA9IG8udHJpZ2dlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG8ua2ljaykge1xyXG4gICAgICAgICAgICBfdGhpcy5raWNrID0gby5raWNrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoby5kcmFnKSB7XHJcbiAgICAgICAgICAgIF90aGlzLmRyYWcgPSBvLmRyYWc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvLm9uKSB7XHJcbiAgICAgICAgICAgIF90aGlzLm9uID0gby5vbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgX3RoaXMuZHJhZ3N0YXJ0ID0gX3RoaXMuZHJhZ1N0YXJ0ID0gbGF5b3V0XzEuTGF5b3V0LmRyYWdTdGFydDtcclxuICAgICAgICBfdGhpcy5kcmFnZW5kID0gX3RoaXMuZHJhZ0VuZCA9IGxheW91dF8xLkxheW91dC5kcmFnRW5kO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIExheW91dEFkYXB0b3IucHJvdG90eXBlLnRyaWdnZXIgPSBmdW5jdGlvbiAoZSkgeyB9O1xyXG4gICAgO1xyXG4gICAgTGF5b3V0QWRhcHRvci5wcm90b3R5cGUua2ljayA9IGZ1bmN0aW9uICgpIHsgfTtcclxuICAgIDtcclxuICAgIExheW91dEFkYXB0b3IucHJvdG90eXBlLmRyYWcgPSBmdW5jdGlvbiAoKSB7IH07XHJcbiAgICA7XHJcbiAgICBMYXlvdXRBZGFwdG9yLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldmVudFR5cGUsIGxpc3RlbmVyKSB7IHJldHVybiB0aGlzOyB9O1xyXG4gICAgO1xyXG4gICAgcmV0dXJuIExheW91dEFkYXB0b3I7XHJcbn0obGF5b3V0XzEuTGF5b3V0KSk7XHJcbmV4cG9ydHMuTGF5b3V0QWRhcHRvciA9IExheW91dEFkYXB0b3I7XHJcbmZ1bmN0aW9uIGFkYXB0b3Iob3B0aW9ucykge1xyXG4gICAgcmV0dXJuIG5ldyBMYXlvdXRBZGFwdG9yKG9wdGlvbnMpO1xyXG59XHJcbmV4cG9ydHMuYWRhcHRvciA9IGFkYXB0b3I7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkYXB0b3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIGxheW91dF8xID0gcmVxdWlyZShcIi4vbGF5b3V0XCIpO1xyXG52YXIgZ3JpZHJvdXRlcl8xID0gcmVxdWlyZShcIi4vZ3JpZHJvdXRlclwiKTtcclxuZnVuY3Rpb24gZ3JpZGlmeShwZ0xheW91dCwgbnVkZ2VHYXAsIG1hcmdpbiwgZ3JvdXBNYXJnaW4pIHtcclxuICAgIHBnTGF5b3V0LmNvbGEuc3RhcnQoMCwgMCwgMCwgMTAsIGZhbHNlKTtcclxuICAgIHZhciBncmlkcm91dGVyID0gcm91dGUocGdMYXlvdXQuY29sYS5ub2RlcygpLCBwZ0xheW91dC5jb2xhLmdyb3VwcygpLCBtYXJnaW4sIGdyb3VwTWFyZ2luKTtcclxuICAgIHJldHVybiBncmlkcm91dGVyLnJvdXRlRWRnZXMocGdMYXlvdXQucG93ZXJHcmFwaC5wb3dlckVkZ2VzLCBudWRnZUdhcCwgZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGUuc291cmNlLnJvdXRlck5vZGUuaWQ7IH0sIGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLnRhcmdldC5yb3V0ZXJOb2RlLmlkOyB9KTtcclxufVxyXG5leHBvcnRzLmdyaWRpZnkgPSBncmlkaWZ5O1xyXG5mdW5jdGlvbiByb3V0ZShub2RlcywgZ3JvdXBzLCBtYXJnaW4sIGdyb3VwTWFyZ2luKSB7XHJcbiAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgZC5yb3V0ZXJOb2RlID0ge1xyXG4gICAgICAgICAgICBuYW1lOiBkLm5hbWUsXHJcbiAgICAgICAgICAgIGJvdW5kczogZC5ib3VuZHMuaW5mbGF0ZSgtbWFyZ2luKVxyXG4gICAgICAgIH07XHJcbiAgICB9KTtcclxuICAgIGdyb3Vwcy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgZC5yb3V0ZXJOb2RlID0ge1xyXG4gICAgICAgICAgICBib3VuZHM6IGQuYm91bmRzLmluZmxhdGUoLWdyb3VwTWFyZ2luKSxcclxuICAgICAgICAgICAgY2hpbGRyZW46ICh0eXBlb2YgZC5ncm91cHMgIT09ICd1bmRlZmluZWQnID8gZC5ncm91cHMubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiBub2Rlcy5sZW5ndGggKyBjLmlkOyB9KSA6IFtdKVxyXG4gICAgICAgICAgICAgICAgLmNvbmNhdCh0eXBlb2YgZC5sZWF2ZXMgIT09ICd1bmRlZmluZWQnID8gZC5sZWF2ZXMubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLmluZGV4OyB9KSA6IFtdKVxyXG4gICAgICAgIH07XHJcbiAgICB9KTtcclxuICAgIHZhciBncmlkUm91dGVyTm9kZXMgPSBub2Rlcy5jb25jYXQoZ3JvdXBzKS5tYXAoZnVuY3Rpb24gKGQsIGkpIHtcclxuICAgICAgICBkLnJvdXRlck5vZGUuaWQgPSBpO1xyXG4gICAgICAgIHJldHVybiBkLnJvdXRlck5vZGU7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBuZXcgZ3JpZHJvdXRlcl8xLkdyaWRSb3V0ZXIoZ3JpZFJvdXRlck5vZGVzLCB7XHJcbiAgICAgICAgZ2V0Q2hpbGRyZW46IGZ1bmN0aW9uICh2KSB7IHJldHVybiB2LmNoaWxkcmVuOyB9LFxyXG4gICAgICAgIGdldEJvdW5kczogZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHYuYm91bmRzOyB9XHJcbiAgICB9LCBtYXJnaW4gLSBncm91cE1hcmdpbik7XHJcbn1cclxuZnVuY3Rpb24gcG93ZXJHcmFwaEdyaWRMYXlvdXQoZ3JhcGgsIHNpemUsIGdyb3VwcGFkZGluZykge1xyXG4gICAgdmFyIHBvd2VyR3JhcGg7XHJcbiAgICBncmFwaC5ub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uICh2LCBpKSB7IHJldHVybiB2LmluZGV4ID0gaTsgfSk7XHJcbiAgICBuZXcgbGF5b3V0XzEuTGF5b3V0KClcclxuICAgICAgICAuYXZvaWRPdmVybGFwcyhmYWxzZSlcclxuICAgICAgICAubm9kZXMoZ3JhcGgubm9kZXMpXHJcbiAgICAgICAgLmxpbmtzKGdyYXBoLmxpbmtzKVxyXG4gICAgICAgIC5wb3dlckdyYXBoR3JvdXBzKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgcG93ZXJHcmFwaCA9IGQ7XHJcbiAgICAgICAgcG93ZXJHcmFwaC5ncm91cHMuZm9yRWFjaChmdW5jdGlvbiAodikgeyByZXR1cm4gdi5wYWRkaW5nID0gZ3JvdXBwYWRkaW5nOyB9KTtcclxuICAgIH0pO1xyXG4gICAgdmFyIG4gPSBncmFwaC5ub2Rlcy5sZW5ndGg7XHJcbiAgICB2YXIgZWRnZXMgPSBbXTtcclxuICAgIHZhciB2cyA9IGdyYXBoLm5vZGVzLnNsaWNlKDApO1xyXG4gICAgdnMuZm9yRWFjaChmdW5jdGlvbiAodiwgaSkgeyByZXR1cm4gdi5pbmRleCA9IGk7IH0pO1xyXG4gICAgcG93ZXJHcmFwaC5ncm91cHMuZm9yRWFjaChmdW5jdGlvbiAoZykge1xyXG4gICAgICAgIHZhciBzb3VyY2VJbmQgPSBnLmluZGV4ID0gZy5pZCArIG47XHJcbiAgICAgICAgdnMucHVzaChnKTtcclxuICAgICAgICBpZiAodHlwZW9mIGcubGVhdmVzICE9PSAndW5kZWZpbmVkJylcclxuICAgICAgICAgICAgZy5sZWF2ZXMuZm9yRWFjaChmdW5jdGlvbiAodikgeyByZXR1cm4gZWRnZXMucHVzaCh7IHNvdXJjZTogc291cmNlSW5kLCB0YXJnZXQ6IHYuaW5kZXggfSk7IH0pO1xyXG4gICAgICAgIGlmICh0eXBlb2YgZy5ncm91cHMgIT09ICd1bmRlZmluZWQnKVxyXG4gICAgICAgICAgICBnLmdyb3Vwcy5mb3JFYWNoKGZ1bmN0aW9uIChnZykgeyByZXR1cm4gZWRnZXMucHVzaCh7IHNvdXJjZTogc291cmNlSW5kLCB0YXJnZXQ6IGdnLmlkICsgbiB9KTsgfSk7XHJcbiAgICB9KTtcclxuICAgIHBvd2VyR3JhcGgucG93ZXJFZGdlcy5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgZWRnZXMucHVzaCh7IHNvdXJjZTogZS5zb3VyY2UuaW5kZXgsIHRhcmdldDogZS50YXJnZXQuaW5kZXggfSk7XHJcbiAgICB9KTtcclxuICAgIG5ldyBsYXlvdXRfMS5MYXlvdXQoKVxyXG4gICAgICAgIC5zaXplKHNpemUpXHJcbiAgICAgICAgLm5vZGVzKHZzKVxyXG4gICAgICAgIC5saW5rcyhlZGdlcylcclxuICAgICAgICAuYXZvaWRPdmVybGFwcyhmYWxzZSlcclxuICAgICAgICAubGlua0Rpc3RhbmNlKDMwKVxyXG4gICAgICAgIC5zeW1tZXRyaWNEaWZmTGlua0xlbmd0aHMoNSlcclxuICAgICAgICAuY29udmVyZ2VuY2VUaHJlc2hvbGQoMWUtNClcclxuICAgICAgICAuc3RhcnQoMTAwLCAwLCAwLCAwLCBmYWxzZSk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGNvbGE6IG5ldyBsYXlvdXRfMS5MYXlvdXQoKVxyXG4gICAgICAgICAgICAuY29udmVyZ2VuY2VUaHJlc2hvbGQoMWUtMylcclxuICAgICAgICAgICAgLnNpemUoc2l6ZSlcclxuICAgICAgICAgICAgLmF2b2lkT3ZlcmxhcHModHJ1ZSlcclxuICAgICAgICAgICAgLm5vZGVzKGdyYXBoLm5vZGVzKVxyXG4gICAgICAgICAgICAubGlua3MoZ3JhcGgubGlua3MpXHJcbiAgICAgICAgICAgIC5ncm91cENvbXBhY3RuZXNzKDFlLTQpXHJcbiAgICAgICAgICAgIC5saW5rRGlzdGFuY2UoMzApXHJcbiAgICAgICAgICAgIC5zeW1tZXRyaWNEaWZmTGlua0xlbmd0aHMoNSlcclxuICAgICAgICAgICAgLnBvd2VyR3JhcGhHcm91cHMoZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgcG93ZXJHcmFwaCA9IGQ7XHJcbiAgICAgICAgICAgIHBvd2VyR3JhcGguZ3JvdXBzLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgICAgIHYucGFkZGluZyA9IGdyb3VwcGFkZGluZztcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSkuc3RhcnQoNTAsIDAsIDEwMCwgMCwgZmFsc2UpLFxyXG4gICAgICAgIHBvd2VyR3JhcGg6IHBvd2VyR3JhcGhcclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5wb3dlckdyYXBoR3JpZExheW91dCA9IHBvd2VyR3JhcGhHcmlkTGF5b3V0O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXRjaC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgZDN2MyA9IHJlcXVpcmUoXCIuL2QzdjNhZGFwdG9yXCIpO1xyXG52YXIgZDN2NCA9IHJlcXVpcmUoXCIuL2QzdjRhZGFwdG9yXCIpO1xyXG47XHJcbmZ1bmN0aW9uIGQzYWRhcHRvcihkM0NvbnRleHQpIHtcclxuICAgIGlmICghZDNDb250ZXh0IHx8IGlzRDNWMyhkM0NvbnRleHQpKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBkM3YzLkQzU3R5bGVMYXlvdXRBZGFwdG9yKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IGQzdjQuRDNTdHlsZUxheW91dEFkYXB0b3IoZDNDb250ZXh0KTtcclxufVxyXG5leHBvcnRzLmQzYWRhcHRvciA9IGQzYWRhcHRvcjtcclxuZnVuY3Rpb24gaXNEM1YzKGQzQ29udGV4dCkge1xyXG4gICAgdmFyIHYzZXhwID0gL14zXFwuLztcclxuICAgIHJldHVybiBkM0NvbnRleHQudmVyc2lvbiAmJiBkM0NvbnRleHQudmVyc2lvbi5tYXRjaCh2M2V4cCkgIT09IG51bGw7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZDNhZGFwdG9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgbGF5b3V0XzEgPSByZXF1aXJlKFwiLi9sYXlvdXRcIik7XHJcbnZhciBEM1N0eWxlTGF5b3V0QWRhcHRvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoRDNTdHlsZUxheW91dEFkYXB0b3IsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBEM1N0eWxlTGF5b3V0QWRhcHRvcigpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLmV2ZW50ID0gZDMuZGlzcGF0Y2gobGF5b3V0XzEuRXZlbnRUeXBlW2xheW91dF8xLkV2ZW50VHlwZS5zdGFydF0sIGxheW91dF8xLkV2ZW50VHlwZVtsYXlvdXRfMS5FdmVudFR5cGUudGlja10sIGxheW91dF8xLkV2ZW50VHlwZVtsYXlvdXRfMS5FdmVudFR5cGUuZW5kXSk7XHJcbiAgICAgICAgdmFyIGQzbGF5b3V0ID0gX3RoaXM7XHJcbiAgICAgICAgdmFyIGRyYWc7XHJcbiAgICAgICAgX3RoaXMuZHJhZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKCFkcmFnKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZHJhZyA9IGQzLmJlaGF2aW9yLmRyYWcoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5vcmlnaW4obGF5b3V0XzEuTGF5b3V0LmRyYWdPcmlnaW4pXHJcbiAgICAgICAgICAgICAgICAgICAgLm9uKFwiZHJhZ3N0YXJ0LmQzYWRhcHRvclwiLCBsYXlvdXRfMS5MYXlvdXQuZHJhZ1N0YXJ0KVxyXG4gICAgICAgICAgICAgICAgICAgIC5vbihcImRyYWcuZDNhZGFwdG9yXCIsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0XzEuTGF5b3V0LmRyYWcoZCwgZDMuZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGQzbGF5b3V0LnJlc3VtZSgpO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAub24oXCJkcmFnZW5kLmQzYWRhcHRvclwiLCBsYXlvdXRfMS5MYXlvdXQuZHJhZ0VuZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRyYWc7XHJcbiAgICAgICAgICAgIHRoaXNcclxuICAgICAgICAgICAgICAgIC5jYWxsKGRyYWcpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgRDNTdHlsZUxheW91dEFkYXB0b3IucHJvdG90eXBlLnRyaWdnZXIgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIHZhciBkM2V2ZW50ID0geyB0eXBlOiBsYXlvdXRfMS5FdmVudFR5cGVbZS50eXBlXSwgYWxwaGE6IGUuYWxwaGEsIHN0cmVzczogZS5zdHJlc3MgfTtcclxuICAgICAgICB0aGlzLmV2ZW50W2QzZXZlbnQudHlwZV0oZDNldmVudCk7XHJcbiAgICB9O1xyXG4gICAgRDNTdHlsZUxheW91dEFkYXB0b3IucHJvdG90eXBlLmtpY2sgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBkMy50aW1lcihmdW5jdGlvbiAoKSB7IHJldHVybiBfc3VwZXIucHJvdG90eXBlLnRpY2suY2FsbChfdGhpcyk7IH0pO1xyXG4gICAgfTtcclxuICAgIEQzU3R5bGVMYXlvdXRBZGFwdG9yLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldmVudFR5cGUsIGxpc3RlbmVyKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBldmVudFR5cGUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnQub24oZXZlbnRUeXBlLCBsaXN0ZW5lcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50Lm9uKGxheW91dF8xLkV2ZW50VHlwZVtldmVudFR5cGVdLCBsaXN0ZW5lcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBEM1N0eWxlTGF5b3V0QWRhcHRvcjtcclxufShsYXlvdXRfMS5MYXlvdXQpKTtcclxuZXhwb3J0cy5EM1N0eWxlTGF5b3V0QWRhcHRvciA9IEQzU3R5bGVMYXlvdXRBZGFwdG9yO1xyXG5mdW5jdGlvbiBkM2FkYXB0b3IoKSB7XHJcbiAgICByZXR1cm4gbmV3IEQzU3R5bGVMYXlvdXRBZGFwdG9yKCk7XHJcbn1cclxuZXhwb3J0cy5kM2FkYXB0b3IgPSBkM2FkYXB0b3I7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWQzdjNhZGFwdG9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgbGF5b3V0XzEgPSByZXF1aXJlKFwiLi9sYXlvdXRcIik7XHJcbnZhciBEM1N0eWxlTGF5b3V0QWRhcHRvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoRDNTdHlsZUxheW91dEFkYXB0b3IsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBEM1N0eWxlTGF5b3V0QWRhcHRvcihkM0NvbnRleHQpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLmQzQ29udGV4dCA9IGQzQ29udGV4dDtcclxuICAgICAgICBfdGhpcy5ldmVudCA9IGQzQ29udGV4dC5kaXNwYXRjaChsYXlvdXRfMS5FdmVudFR5cGVbbGF5b3V0XzEuRXZlbnRUeXBlLnN0YXJ0XSwgbGF5b3V0XzEuRXZlbnRUeXBlW2xheW91dF8xLkV2ZW50VHlwZS50aWNrXSwgbGF5b3V0XzEuRXZlbnRUeXBlW2xheW91dF8xLkV2ZW50VHlwZS5lbmRdKTtcclxuICAgICAgICB2YXIgZDNsYXlvdXQgPSBfdGhpcztcclxuICAgICAgICB2YXIgZHJhZztcclxuICAgICAgICBfdGhpcy5kcmFnID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoIWRyYWcpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkcmFnID0gZDNDb250ZXh0LmRyYWcoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zdWJqZWN0KGxheW91dF8xLkxheW91dC5kcmFnT3JpZ2luKVxyXG4gICAgICAgICAgICAgICAgICAgIC5vbihcInN0YXJ0LmQzYWRhcHRvclwiLCBsYXlvdXRfMS5MYXlvdXQuZHJhZ1N0YXJ0KVxyXG4gICAgICAgICAgICAgICAgICAgIC5vbihcImRyYWcuZDNhZGFwdG9yXCIsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0XzEuTGF5b3V0LmRyYWcoZCwgZDNDb250ZXh0LmV2ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICBkM2xheW91dC5yZXN1bWUoKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLm9uKFwiZW5kLmQzYWRhcHRvclwiLCBsYXlvdXRfMS5MYXlvdXQuZHJhZ0VuZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRyYWc7XHJcbiAgICAgICAgICAgIGFyZ3VtZW50c1swXS5jYWxsKGRyYWcpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgRDNTdHlsZUxheW91dEFkYXB0b3IucHJvdG90eXBlLnRyaWdnZXIgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIHZhciBkM2V2ZW50ID0geyB0eXBlOiBsYXlvdXRfMS5FdmVudFR5cGVbZS50eXBlXSwgYWxwaGE6IGUuYWxwaGEsIHN0cmVzczogZS5zdHJlc3MgfTtcclxuICAgICAgICB0aGlzLmV2ZW50LmNhbGwoZDNldmVudC50eXBlLCBkM2V2ZW50KTtcclxuICAgIH07XHJcbiAgICBEM1N0eWxlTGF5b3V0QWRhcHRvci5wcm90b3R5cGUua2ljayA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciB0ID0gdGhpcy5kM0NvbnRleHQudGltZXIoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS50aWNrLmNhbGwoX3RoaXMpICYmIHQuc3RvcCgpOyB9KTtcclxuICAgIH07XHJcbiAgICBEM1N0eWxlTGF5b3V0QWRhcHRvci5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXZlbnRUeXBlLCBsaXN0ZW5lcikge1xyXG4gICAgICAgIGlmICh0eXBlb2YgZXZlbnRUeXBlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50Lm9uKGV2ZW50VHlwZSwgbGlzdGVuZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5ldmVudC5vbihsYXlvdXRfMS5FdmVudFR5cGVbZXZlbnRUeXBlXSwgbGlzdGVuZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICByZXR1cm4gRDNTdHlsZUxheW91dEFkYXB0b3I7XHJcbn0obGF5b3V0XzEuTGF5b3V0KSk7XHJcbmV4cG9ydHMuRDNTdHlsZUxheW91dEFkYXB0b3IgPSBEM1N0eWxlTGF5b3V0QWRhcHRvcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZDN2NGFkYXB0b3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIExvY2tzID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIExvY2tzKCkge1xyXG4gICAgICAgIHRoaXMubG9ja3MgPSB7fTtcclxuICAgIH1cclxuICAgIExvY2tzLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoaWQsIHgpIHtcclxuICAgICAgICB0aGlzLmxvY2tzW2lkXSA9IHg7XHJcbiAgICB9O1xyXG4gICAgTG9ja3MucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMubG9ja3MgPSB7fTtcclxuICAgIH07XHJcbiAgICBMb2Nrcy5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmb3IgKHZhciBsIGluIHRoaXMubG9ja3MpXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcbiAgICBMb2Nrcy5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiAoZikge1xyXG4gICAgICAgIGZvciAodmFyIGwgaW4gdGhpcy5sb2Nrcykge1xyXG4gICAgICAgICAgICBmKE51bWJlcihsKSwgdGhpcy5sb2Nrc1tsXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBMb2NrcztcclxufSgpKTtcclxuZXhwb3J0cy5Mb2NrcyA9IExvY2tzO1xyXG52YXIgRGVzY2VudCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBEZXNjZW50KHgsIEQsIEcpIHtcclxuICAgICAgICBpZiAoRyA9PT0gdm9pZCAwKSB7IEcgPSBudWxsOyB9XHJcbiAgICAgICAgdGhpcy5EID0gRDtcclxuICAgICAgICB0aGlzLkcgPSBHO1xyXG4gICAgICAgIHRoaXMudGhyZXNob2xkID0gMC4wMDAxO1xyXG4gICAgICAgIHRoaXMubnVtR3JpZFNuYXBOb2RlcyA9IDA7XHJcbiAgICAgICAgdGhpcy5zbmFwR3JpZFNpemUgPSAxMDA7XHJcbiAgICAgICAgdGhpcy5zbmFwU3RyZW5ndGggPSAxMDAwO1xyXG4gICAgICAgIHRoaXMuc2NhbGVTbmFwQnlNYXhIID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5yYW5kb20gPSBuZXcgUHNldWRvUmFuZG9tKCk7XHJcbiAgICAgICAgdGhpcy5wcm9qZWN0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLnggPSB4O1xyXG4gICAgICAgIHRoaXMuayA9IHgubGVuZ3RoO1xyXG4gICAgICAgIHZhciBuID0gdGhpcy5uID0geFswXS5sZW5ndGg7XHJcbiAgICAgICAgdGhpcy5IID0gbmV3IEFycmF5KHRoaXMuayk7XHJcbiAgICAgICAgdGhpcy5nID0gbmV3IEFycmF5KHRoaXMuayk7XHJcbiAgICAgICAgdGhpcy5IZCA9IG5ldyBBcnJheSh0aGlzLmspO1xyXG4gICAgICAgIHRoaXMuYSA9IG5ldyBBcnJheSh0aGlzLmspO1xyXG4gICAgICAgIHRoaXMuYiA9IG5ldyBBcnJheSh0aGlzLmspO1xyXG4gICAgICAgIHRoaXMuYyA9IG5ldyBBcnJheSh0aGlzLmspO1xyXG4gICAgICAgIHRoaXMuZCA9IG5ldyBBcnJheSh0aGlzLmspO1xyXG4gICAgICAgIHRoaXMuZSA9IG5ldyBBcnJheSh0aGlzLmspO1xyXG4gICAgICAgIHRoaXMuaWEgPSBuZXcgQXJyYXkodGhpcy5rKTtcclxuICAgICAgICB0aGlzLmliID0gbmV3IEFycmF5KHRoaXMuayk7XHJcbiAgICAgICAgdGhpcy54dG1wID0gbmV3IEFycmF5KHRoaXMuayk7XHJcbiAgICAgICAgdGhpcy5sb2NrcyA9IG5ldyBMb2NrcygpO1xyXG4gICAgICAgIHRoaXMubWluRCA9IE51bWJlci5NQVhfVkFMVUU7XHJcbiAgICAgICAgdmFyIGkgPSBuLCBqO1xyXG4gICAgICAgIHdoaWxlIChpLS0pIHtcclxuICAgICAgICAgICAgaiA9IG47XHJcbiAgICAgICAgICAgIHdoaWxlICgtLWogPiBpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZCA9IERbaV1bal07XHJcbiAgICAgICAgICAgICAgICBpZiAoZCA+IDAgJiYgZCA8IHRoaXMubWluRCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWluRCA9IGQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMubWluRCA9PT0gTnVtYmVyLk1BWF9WQUxVRSlcclxuICAgICAgICAgICAgdGhpcy5taW5EID0gMTtcclxuICAgICAgICBpID0gdGhpcy5rO1xyXG4gICAgICAgIHdoaWxlIChpLS0pIHtcclxuICAgICAgICAgICAgdGhpcy5nW2ldID0gbmV3IEFycmF5KG4pO1xyXG4gICAgICAgICAgICB0aGlzLkhbaV0gPSBuZXcgQXJyYXkobik7XHJcbiAgICAgICAgICAgIGogPSBuO1xyXG4gICAgICAgICAgICB3aGlsZSAoai0tKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLkhbaV1bal0gPSBuZXcgQXJyYXkobik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5IZFtpXSA9IG5ldyBBcnJheShuKTtcclxuICAgICAgICAgICAgdGhpcy5hW2ldID0gbmV3IEFycmF5KG4pO1xyXG4gICAgICAgICAgICB0aGlzLmJbaV0gPSBuZXcgQXJyYXkobik7XHJcbiAgICAgICAgICAgIHRoaXMuY1tpXSA9IG5ldyBBcnJheShuKTtcclxuICAgICAgICAgICAgdGhpcy5kW2ldID0gbmV3IEFycmF5KG4pO1xyXG4gICAgICAgICAgICB0aGlzLmVbaV0gPSBuZXcgQXJyYXkobik7XHJcbiAgICAgICAgICAgIHRoaXMuaWFbaV0gPSBuZXcgQXJyYXkobik7XHJcbiAgICAgICAgICAgIHRoaXMuaWJbaV0gPSBuZXcgQXJyYXkobik7XHJcbiAgICAgICAgICAgIHRoaXMueHRtcFtpXSA9IG5ldyBBcnJheShuKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBEZXNjZW50LmNyZWF0ZVNxdWFyZU1hdHJpeCA9IGZ1bmN0aW9uIChuLCBmKSB7XHJcbiAgICAgICAgdmFyIE0gPSBuZXcgQXJyYXkobik7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHtcclxuICAgICAgICAgICAgTVtpXSA9IG5ldyBBcnJheShuKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBuOyArK2opIHtcclxuICAgICAgICAgICAgICAgIE1baV1bal0gPSBmKGksIGopO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBNO1xyXG4gICAgfTtcclxuICAgIERlc2NlbnQucHJvdG90eXBlLm9mZnNldERpciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciB1ID0gbmV3IEFycmF5KHRoaXMuayk7XHJcbiAgICAgICAgdmFyIGwgPSAwO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5rOyArK2kpIHtcclxuICAgICAgICAgICAgdmFyIHggPSB1W2ldID0gdGhpcy5yYW5kb20uZ2V0TmV4dEJldHdlZW4oMC4wMSwgMSkgLSAwLjU7XHJcbiAgICAgICAgICAgIGwgKz0geCAqIHg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGwgPSBNYXRoLnNxcnQobCk7XHJcbiAgICAgICAgcmV0dXJuIHUubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4ICo9IF90aGlzLm1pbkQgLyBsOyB9KTtcclxuICAgIH07XHJcbiAgICBEZXNjZW50LnByb3RvdHlwZS5jb21wdXRlRGVyaXZhdGl2ZXMgPSBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIG4gPSB0aGlzLm47XHJcbiAgICAgICAgaWYgKG4gPCAxKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIGQgPSBuZXcgQXJyYXkodGhpcy5rKTtcclxuICAgICAgICB2YXIgZDIgPSBuZXcgQXJyYXkodGhpcy5rKTtcclxuICAgICAgICB2YXIgSHV1ID0gbmV3IEFycmF5KHRoaXMuayk7XHJcbiAgICAgICAgdmFyIG1heEggPSAwO1xyXG4gICAgICAgIGZvciAodmFyIHUgPSAwOyB1IDwgbjsgKyt1KSB7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLms7ICsraSlcclxuICAgICAgICAgICAgICAgIEh1dVtpXSA9IHRoaXMuZ1tpXVt1XSA9IDA7XHJcbiAgICAgICAgICAgIGZvciAodmFyIHYgPSAwOyB2IDwgbjsgKyt2KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodSA9PT0gdilcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIHZhciBtYXhEaXNwbGFjZXMgPSBuO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKG1heERpc3BsYWNlcy0tKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNkMiA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuazsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkeCA9IGRbaV0gPSB4W2ldW3VdIC0geFtpXVt2XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2QyICs9IGQyW2ldID0gZHggKiBkeDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNkMiA+IDFlLTkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZCA9IHRoaXMub2Zmc2V0RGlyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuazsgKytpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB4W2ldW3ZdICs9IHJkW2ldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGwgPSBNYXRoLnNxcnQoc2QyKTtcclxuICAgICAgICAgICAgICAgIHZhciBEID0gdGhpcy5EW3VdW3ZdO1xyXG4gICAgICAgICAgICAgICAgdmFyIHdlaWdodCA9IHRoaXMuRyAhPSBudWxsID8gdGhpcy5HW3VdW3ZdIDogMTtcclxuICAgICAgICAgICAgICAgIGlmICh3ZWlnaHQgPiAxICYmIGwgPiBEIHx8ICFpc0Zpbml0ZShEKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLms7ICsraSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5IW2ldW3VdW3ZdID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh3ZWlnaHQgPiAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2VpZ2h0ID0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBEMiA9IEQgKiBEO1xyXG4gICAgICAgICAgICAgICAgdmFyIGdzID0gMiAqIHdlaWdodCAqIChsIC0gRCkgLyAoRDIgKiBsKTtcclxuICAgICAgICAgICAgICAgIHZhciBsMyA9IGwgKiBsICogbDtcclxuICAgICAgICAgICAgICAgIHZhciBocyA9IDIgKiAtd2VpZ2h0IC8gKEQyICogbDMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0Zpbml0ZShncykpXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZ3MpO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuazsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nW2ldW3VdICs9IGRbaV0gKiBncztcclxuICAgICAgICAgICAgICAgICAgICBIdXVbaV0gLT0gdGhpcy5IW2ldW3VdW3ZdID0gaHMgKiAobDMgKyBEICogKGQyW2ldIC0gc2QyKSArIGwgKiBzZDIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLms7ICsraSlcclxuICAgICAgICAgICAgICAgIG1heEggPSBNYXRoLm1heChtYXhILCB0aGlzLkhbaV1bdV1bdV0gPSBIdXVbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgciA9IHRoaXMuc25hcEdyaWRTaXplIC8gMjtcclxuICAgICAgICB2YXIgZyA9IHRoaXMuc25hcEdyaWRTaXplO1xyXG4gICAgICAgIHZhciB3ID0gdGhpcy5zbmFwU3RyZW5ndGg7XHJcbiAgICAgICAgdmFyIGsgPSB3IC8gKHIgKiByKTtcclxuICAgICAgICB2YXIgbnVtTm9kZXMgPSB0aGlzLm51bUdyaWRTbmFwTm9kZXM7XHJcbiAgICAgICAgZm9yICh2YXIgdSA9IDA7IHUgPCBudW1Ob2RlczsgKyt1KSB7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLms7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHhpdSA9IHRoaXMueFtpXVt1XTtcclxuICAgICAgICAgICAgICAgIHZhciBtID0geGl1IC8gZztcclxuICAgICAgICAgICAgICAgIHZhciBmID0gbSAlIDE7XHJcbiAgICAgICAgICAgICAgICB2YXIgcSA9IG0gLSBmO1xyXG4gICAgICAgICAgICAgICAgdmFyIGEgPSBNYXRoLmFicyhmKTtcclxuICAgICAgICAgICAgICAgIHZhciBkeCA9IChhIDw9IDAuNSkgPyB4aXUgLSBxICogZyA6XHJcbiAgICAgICAgICAgICAgICAgICAgKHhpdSA+IDApID8geGl1IC0gKHEgKyAxKSAqIGcgOiB4aXUgLSAocSAtIDEpICogZztcclxuICAgICAgICAgICAgICAgIGlmICgtciA8IGR4ICYmIGR4IDw9IHIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zY2FsZVNuYXBCeU1heEgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nW2ldW3VdICs9IG1heEggKiBrICogZHg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuSFtpXVt1XVt1XSArPSBtYXhIICogaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ1tpXVt1XSArPSBrICogZHg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuSFtpXVt1XVt1XSArPSBrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaXMubG9ja3MuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9ja3MuYXBwbHkoZnVuY3Rpb24gKHUsIHApIHtcclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBfdGhpcy5rOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5IW2ldW3VdW3VdICs9IG1heEg7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZ1tpXVt1XSAtPSBtYXhIICogKHBbaV0gLSB4W2ldW3VdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIERlc2NlbnQuZG90UHJvZCA9IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgdmFyIHggPSAwLCBpID0gYS5sZW5ndGg7XHJcbiAgICAgICAgd2hpbGUgKGktLSlcclxuICAgICAgICAgICAgeCArPSBhW2ldICogYltpXTtcclxuICAgICAgICByZXR1cm4geDtcclxuICAgIH07XHJcbiAgICBEZXNjZW50LnJpZ2h0TXVsdGlwbHkgPSBmdW5jdGlvbiAobSwgdiwgcikge1xyXG4gICAgICAgIHZhciBpID0gbS5sZW5ndGg7XHJcbiAgICAgICAgd2hpbGUgKGktLSlcclxuICAgICAgICAgICAgcltpXSA9IERlc2NlbnQuZG90UHJvZChtW2ldLCB2KTtcclxuICAgIH07XHJcbiAgICBEZXNjZW50LnByb3RvdHlwZS5jb21wdXRlU3RlcFNpemUgPSBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgIHZhciBudW1lcmF0b3IgPSAwLCBkZW5vbWluYXRvciA9IDA7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLms7ICsraSkge1xyXG4gICAgICAgICAgICBudW1lcmF0b3IgKz0gRGVzY2VudC5kb3RQcm9kKHRoaXMuZ1tpXSwgZFtpXSk7XHJcbiAgICAgICAgICAgIERlc2NlbnQucmlnaHRNdWx0aXBseSh0aGlzLkhbaV0sIGRbaV0sIHRoaXMuSGRbaV0pO1xyXG4gICAgICAgICAgICBkZW5vbWluYXRvciArPSBEZXNjZW50LmRvdFByb2QoZFtpXSwgdGhpcy5IZFtpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkZW5vbWluYXRvciA9PT0gMCB8fCAhaXNGaW5pdGUoZGVub21pbmF0b3IpKVxyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICByZXR1cm4gMSAqIG51bWVyYXRvciAvIGRlbm9taW5hdG9yO1xyXG4gICAgfTtcclxuICAgIERlc2NlbnQucHJvdG90eXBlLnJlZHVjZVN0cmVzcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmNvbXB1dGVEZXJpdmF0aXZlcyh0aGlzLngpO1xyXG4gICAgICAgIHZhciBhbHBoYSA9IHRoaXMuY29tcHV0ZVN0ZXBTaXplKHRoaXMuZyk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLms7ICsraSkge1xyXG4gICAgICAgICAgICB0aGlzLnRha2VEZXNjZW50U3RlcCh0aGlzLnhbaV0sIHRoaXMuZ1tpXSwgYWxwaGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5jb21wdXRlU3RyZXNzKCk7XHJcbiAgICB9O1xyXG4gICAgRGVzY2VudC5jb3B5ID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICB2YXIgbSA9IGEubGVuZ3RoLCBuID0gYlswXS5sZW5ndGg7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtOyArK2kpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBuOyArK2opIHtcclxuICAgICAgICAgICAgICAgIGJbaV1bal0gPSBhW2ldW2pdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIERlc2NlbnQucHJvdG90eXBlLnN0ZXBBbmRQcm9qZWN0ID0gZnVuY3Rpb24gKHgwLCByLCBkLCBzdGVwU2l6ZSkge1xyXG4gICAgICAgIERlc2NlbnQuY29weSh4MCwgcik7XHJcbiAgICAgICAgdGhpcy50YWtlRGVzY2VudFN0ZXAoclswXSwgZFswXSwgc3RlcFNpemUpO1xyXG4gICAgICAgIGlmICh0aGlzLnByb2plY3QpXHJcbiAgICAgICAgICAgIHRoaXMucHJvamVjdFswXSh4MFswXSwgeDBbMV0sIHJbMF0pO1xyXG4gICAgICAgIHRoaXMudGFrZURlc2NlbnRTdGVwKHJbMV0sIGRbMV0sIHN0ZXBTaXplKTtcclxuICAgICAgICBpZiAodGhpcy5wcm9qZWN0KVxyXG4gICAgICAgICAgICB0aGlzLnByb2plY3RbMV0oclswXSwgeDBbMV0sIHJbMV0pO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAyOyBpIDwgdGhpcy5rOyBpKyspXHJcbiAgICAgICAgICAgIHRoaXMudGFrZURlc2NlbnRTdGVwKHJbaV0sIGRbaV0sIHN0ZXBTaXplKTtcclxuICAgIH07XHJcbiAgICBEZXNjZW50Lm1BcHBseSA9IGZ1bmN0aW9uIChtLCBuLCBmKSB7XHJcbiAgICAgICAgdmFyIGkgPSBtO1xyXG4gICAgICAgIHdoaWxlIChpLS0gPiAwKSB7XHJcbiAgICAgICAgICAgIHZhciBqID0gbjtcclxuICAgICAgICAgICAgd2hpbGUgKGotLSA+IDApXHJcbiAgICAgICAgICAgICAgICBmKGksIGopO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBEZXNjZW50LnByb3RvdHlwZS5tYXRyaXhBcHBseSA9IGZ1bmN0aW9uIChmKSB7XHJcbiAgICAgICAgRGVzY2VudC5tQXBwbHkodGhpcy5rLCB0aGlzLm4sIGYpO1xyXG4gICAgfTtcclxuICAgIERlc2NlbnQucHJvdG90eXBlLmNvbXB1dGVOZXh0UG9zaXRpb24gPSBmdW5jdGlvbiAoeDAsIHIpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuY29tcHV0ZURlcml2YXRpdmVzKHgwKTtcclxuICAgICAgICB2YXIgYWxwaGEgPSB0aGlzLmNvbXB1dGVTdGVwU2l6ZSh0aGlzLmcpO1xyXG4gICAgICAgIHRoaXMuc3RlcEFuZFByb2plY3QoeDAsIHIsIHRoaXMuZywgYWxwaGEpO1xyXG4gICAgICAgIGlmICh0aGlzLnByb2plY3QpIHtcclxuICAgICAgICAgICAgdGhpcy5tYXRyaXhBcHBseShmdW5jdGlvbiAoaSwgaikgeyByZXR1cm4gX3RoaXMuZVtpXVtqXSA9IHgwW2ldW2pdIC0gcltpXVtqXTsgfSk7XHJcbiAgICAgICAgICAgIHZhciBiZXRhID0gdGhpcy5jb21wdXRlU3RlcFNpemUodGhpcy5lKTtcclxuICAgICAgICAgICAgYmV0YSA9IE1hdGgubWF4KDAuMiwgTWF0aC5taW4oYmV0YSwgMSkpO1xyXG4gICAgICAgICAgICB0aGlzLnN0ZXBBbmRQcm9qZWN0KHgwLCByLCB0aGlzLmUsIGJldGEpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBEZXNjZW50LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoaXRlcmF0aW9ucykge1xyXG4gICAgICAgIHZhciBzdHJlc3MgPSBOdW1iZXIuTUFYX1ZBTFVFLCBjb252ZXJnZWQgPSBmYWxzZTtcclxuICAgICAgICB3aGlsZSAoIWNvbnZlcmdlZCAmJiBpdGVyYXRpb25zLS0gPiAwKSB7XHJcbiAgICAgICAgICAgIHZhciBzID0gdGhpcy5ydW5nZUt1dHRhKCk7XHJcbiAgICAgICAgICAgIGNvbnZlcmdlZCA9IE1hdGguYWJzKHN0cmVzcyAvIHMgLSAxKSA8IHRoaXMudGhyZXNob2xkO1xyXG4gICAgICAgICAgICBzdHJlc3MgPSBzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc3RyZXNzO1xyXG4gICAgfTtcclxuICAgIERlc2NlbnQucHJvdG90eXBlLnJ1bmdlS3V0dGEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLmNvbXB1dGVOZXh0UG9zaXRpb24odGhpcy54LCB0aGlzLmEpO1xyXG4gICAgICAgIERlc2NlbnQubWlkKHRoaXMueCwgdGhpcy5hLCB0aGlzLmlhKTtcclxuICAgICAgICB0aGlzLmNvbXB1dGVOZXh0UG9zaXRpb24odGhpcy5pYSwgdGhpcy5iKTtcclxuICAgICAgICBEZXNjZW50Lm1pZCh0aGlzLngsIHRoaXMuYiwgdGhpcy5pYik7XHJcbiAgICAgICAgdGhpcy5jb21wdXRlTmV4dFBvc2l0aW9uKHRoaXMuaWIsIHRoaXMuYyk7XHJcbiAgICAgICAgdGhpcy5jb21wdXRlTmV4dFBvc2l0aW9uKHRoaXMuYywgdGhpcy5kKTtcclxuICAgICAgICB2YXIgZGlzcCA9IDA7XHJcbiAgICAgICAgdGhpcy5tYXRyaXhBcHBseShmdW5jdGlvbiAoaSwgaikge1xyXG4gICAgICAgICAgICB2YXIgeCA9IChfdGhpcy5hW2ldW2pdICsgMi4wICogX3RoaXMuYltpXVtqXSArIDIuMCAqIF90aGlzLmNbaV1bal0gKyBfdGhpcy5kW2ldW2pdKSAvIDYuMCwgZCA9IF90aGlzLnhbaV1bal0gLSB4O1xyXG4gICAgICAgICAgICBkaXNwICs9IGQgKiBkO1xyXG4gICAgICAgICAgICBfdGhpcy54W2ldW2pdID0geDtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gZGlzcDtcclxuICAgIH07XHJcbiAgICBEZXNjZW50Lm1pZCA9IGZ1bmN0aW9uIChhLCBiLCBtKSB7XHJcbiAgICAgICAgRGVzY2VudC5tQXBwbHkoYS5sZW5ndGgsIGFbMF0ubGVuZ3RoLCBmdW5jdGlvbiAoaSwgaikge1xyXG4gICAgICAgICAgICByZXR1cm4gbVtpXVtqXSA9IGFbaV1bal0gKyAoYltpXVtqXSAtIGFbaV1bal0pIC8gMi4wO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIERlc2NlbnQucHJvdG90eXBlLnRha2VEZXNjZW50U3RlcCA9IGZ1bmN0aW9uICh4LCBkLCBzdGVwU2l6ZSkge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5uOyArK2kpIHtcclxuICAgICAgICAgICAgeFtpXSA9IHhbaV0gLSBzdGVwU2l6ZSAqIGRbaV07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIERlc2NlbnQucHJvdG90eXBlLmNvbXB1dGVTdHJlc3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHN0cmVzcyA9IDA7XHJcbiAgICAgICAgZm9yICh2YXIgdSA9IDAsIG5NaW51czEgPSB0aGlzLm4gLSAxOyB1IDwgbk1pbnVzMTsgKyt1KSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIHYgPSB1ICsgMSwgbiA9IHRoaXMubjsgdiA8IG47ICsrdikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGwgPSAwO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLms7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkeCA9IHRoaXMueFtpXVt1XSAtIHRoaXMueFtpXVt2XTtcclxuICAgICAgICAgICAgICAgICAgICBsICs9IGR4ICogZHg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsID0gTWF0aC5zcXJ0KGwpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGQgPSB0aGlzLkRbdV1bdl07XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzRmluaXRlKGQpKVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJsID0gZCAtIGw7XHJcbiAgICAgICAgICAgICAgICB2YXIgZDIgPSBkICogZDtcclxuICAgICAgICAgICAgICAgIHN0cmVzcyArPSBybCAqIHJsIC8gZDI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN0cmVzcztcclxuICAgIH07XHJcbiAgICBEZXNjZW50Lnplcm9EaXN0YW5jZSA9IDFlLTEwO1xyXG4gICAgcmV0dXJuIERlc2NlbnQ7XHJcbn0oKSk7XHJcbmV4cG9ydHMuRGVzY2VudCA9IERlc2NlbnQ7XHJcbnZhciBQc2V1ZG9SYW5kb20gPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUHNldWRvUmFuZG9tKHNlZWQpIHtcclxuICAgICAgICBpZiAoc2VlZCA9PT0gdm9pZCAwKSB7IHNlZWQgPSAxOyB9XHJcbiAgICAgICAgdGhpcy5zZWVkID0gc2VlZDtcclxuICAgICAgICB0aGlzLmEgPSAyMTQwMTM7XHJcbiAgICAgICAgdGhpcy5jID0gMjUzMTAxMTtcclxuICAgICAgICB0aGlzLm0gPSAyMTQ3NDgzNjQ4O1xyXG4gICAgICAgIHRoaXMucmFuZ2UgPSAzMjc2NztcclxuICAgIH1cclxuICAgIFBzZXVkb1JhbmRvbS5wcm90b3R5cGUuZ2V0TmV4dCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnNlZWQgPSAodGhpcy5zZWVkICogdGhpcy5hICsgdGhpcy5jKSAlIHRoaXMubTtcclxuICAgICAgICByZXR1cm4gKHRoaXMuc2VlZCA+PiAxNikgLyB0aGlzLnJhbmdlO1xyXG4gICAgfTtcclxuICAgIFBzZXVkb1JhbmRvbS5wcm90b3R5cGUuZ2V0TmV4dEJldHdlZW4gPSBmdW5jdGlvbiAobWluLCBtYXgpIHtcclxuICAgICAgICByZXR1cm4gbWluICsgdGhpcy5nZXROZXh0KCkgKiAobWF4IC0gbWluKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gUHNldWRvUmFuZG9tO1xyXG59KCkpO1xyXG5leHBvcnRzLlBzZXVkb1JhbmRvbSA9IFBzZXVkb1JhbmRvbTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVzY2VudC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHJlY3RhbmdsZV8xID0gcmVxdWlyZShcIi4vcmVjdGFuZ2xlXCIpO1xyXG52YXIgUG9pbnQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUG9pbnQoKSB7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUG9pbnQ7XHJcbn0oKSk7XHJcbmV4cG9ydHMuUG9pbnQgPSBQb2ludDtcclxudmFyIExpbmVTZWdtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIExpbmVTZWdtZW50KHgxLCB5MSwgeDIsIHkyKSB7XHJcbiAgICAgICAgdGhpcy54MSA9IHgxO1xyXG4gICAgICAgIHRoaXMueTEgPSB5MTtcclxuICAgICAgICB0aGlzLngyID0geDI7XHJcbiAgICAgICAgdGhpcy55MiA9IHkyO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIExpbmVTZWdtZW50O1xyXG59KCkpO1xyXG5leHBvcnRzLkxpbmVTZWdtZW50ID0gTGluZVNlZ21lbnQ7XHJcbnZhciBQb2x5UG9pbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFBvbHlQb2ludCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFBvbHlQb2ludCgpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUG9seVBvaW50O1xyXG59KFBvaW50KSk7XHJcbmV4cG9ydHMuUG9seVBvaW50ID0gUG9seVBvaW50O1xyXG5mdW5jdGlvbiBpc0xlZnQoUDAsIFAxLCBQMikge1xyXG4gICAgcmV0dXJuIChQMS54IC0gUDAueCkgKiAoUDIueSAtIFAwLnkpIC0gKFAyLnggLSBQMC54KSAqIChQMS55IC0gUDAueSk7XHJcbn1cclxuZXhwb3J0cy5pc0xlZnQgPSBpc0xlZnQ7XHJcbmZ1bmN0aW9uIGFib3ZlKHAsIHZpLCB2aikge1xyXG4gICAgcmV0dXJuIGlzTGVmdChwLCB2aSwgdmopID4gMDtcclxufVxyXG5mdW5jdGlvbiBiZWxvdyhwLCB2aSwgdmopIHtcclxuICAgIHJldHVybiBpc0xlZnQocCwgdmksIHZqKSA8IDA7XHJcbn1cclxuZnVuY3Rpb24gQ29udmV4SHVsbChTKSB7XHJcbiAgICB2YXIgUCA9IFMuc2xpY2UoMCkuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS54ICE9PSBiLnggPyBiLnggLSBhLnggOiBiLnkgLSBhLnk7IH0pO1xyXG4gICAgdmFyIG4gPSBTLmxlbmd0aCwgaTtcclxuICAgIHZhciBtaW5taW4gPSAwO1xyXG4gICAgdmFyIHhtaW4gPSBQWzBdLng7XHJcbiAgICBmb3IgKGkgPSAxOyBpIDwgbjsgKytpKSB7XHJcbiAgICAgICAgaWYgKFBbaV0ueCAhPT0geG1pbilcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgICB2YXIgbWlubWF4ID0gaSAtIDE7XHJcbiAgICB2YXIgSCA9IFtdO1xyXG4gICAgSC5wdXNoKFBbbWlubWluXSk7XHJcbiAgICBpZiAobWlubWF4ID09PSBuIC0gMSkge1xyXG4gICAgICAgIGlmIChQW21pbm1heF0ueSAhPT0gUFttaW5taW5dLnkpXHJcbiAgICAgICAgICAgIEgucHVzaChQW21pbm1heF0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdmFyIG1heG1pbiwgbWF4bWF4ID0gbiAtIDE7XHJcbiAgICAgICAgdmFyIHhtYXggPSBQW24gLSAxXS54O1xyXG4gICAgICAgIGZvciAoaSA9IG4gLSAyOyBpID49IDA7IGktLSlcclxuICAgICAgICAgICAgaWYgKFBbaV0ueCAhPT0geG1heClcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIG1heG1pbiA9IGkgKyAxO1xyXG4gICAgICAgIGkgPSBtaW5tYXg7XHJcbiAgICAgICAgd2hpbGUgKCsraSA8PSBtYXhtaW4pIHtcclxuICAgICAgICAgICAgaWYgKGlzTGVmdChQW21pbm1pbl0sIFBbbWF4bWluXSwgUFtpXSkgPj0gMCAmJiBpIDwgbWF4bWluKVxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIHdoaWxlIChILmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc0xlZnQoSFtILmxlbmd0aCAtIDJdLCBIW0gubGVuZ3RoIC0gMV0sIFBbaV0pID4gMClcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBILmxlbmd0aCAtPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpICE9IG1pbm1pbilcclxuICAgICAgICAgICAgICAgIEgucHVzaChQW2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1heG1heCAhPSBtYXhtaW4pXHJcbiAgICAgICAgICAgIEgucHVzaChQW21heG1heF0pO1xyXG4gICAgICAgIHZhciBib3QgPSBILmxlbmd0aDtcclxuICAgICAgICBpID0gbWF4bWluO1xyXG4gICAgICAgIHdoaWxlICgtLWkgPj0gbWlubWF4KSB7XHJcbiAgICAgICAgICAgIGlmIChpc0xlZnQoUFttYXhtYXhdLCBQW21pbm1heF0sIFBbaV0pID49IDAgJiYgaSA+IG1pbm1heClcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB3aGlsZSAoSC5sZW5ndGggPiBib3QpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc0xlZnQoSFtILmxlbmd0aCAtIDJdLCBIW0gubGVuZ3RoIC0gMV0sIFBbaV0pID4gMClcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBILmxlbmd0aCAtPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpICE9IG1pbm1pbilcclxuICAgICAgICAgICAgICAgIEgucHVzaChQW2ldKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gSDtcclxufVxyXG5leHBvcnRzLkNvbnZleEh1bGwgPSBDb252ZXhIdWxsO1xyXG5mdW5jdGlvbiBjbG9ja3dpc2VSYWRpYWxTd2VlcChwLCBQLCBmKSB7XHJcbiAgICBQLnNsaWNlKDApLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIE1hdGguYXRhbjIoYS55IC0gcC55LCBhLnggLSBwLngpIC0gTWF0aC5hdGFuMihiLnkgLSBwLnksIGIueCAtIHAueCk7IH0pLmZvckVhY2goZik7XHJcbn1cclxuZXhwb3J0cy5jbG9ja3dpc2VSYWRpYWxTd2VlcCA9IGNsb2Nrd2lzZVJhZGlhbFN3ZWVwO1xyXG5mdW5jdGlvbiBuZXh0UG9seVBvaW50KHAsIHBzKSB7XHJcbiAgICBpZiAocC5wb2x5SW5kZXggPT09IHBzLmxlbmd0aCAtIDEpXHJcbiAgICAgICAgcmV0dXJuIHBzWzBdO1xyXG4gICAgcmV0dXJuIHBzW3AucG9seUluZGV4ICsgMV07XHJcbn1cclxuZnVuY3Rpb24gcHJldlBvbHlQb2ludChwLCBwcykge1xyXG4gICAgaWYgKHAucG9seUluZGV4ID09PSAwKVxyXG4gICAgICAgIHJldHVybiBwc1twcy5sZW5ndGggLSAxXTtcclxuICAgIHJldHVybiBwc1twLnBvbHlJbmRleCAtIDFdO1xyXG59XHJcbmZ1bmN0aW9uIHRhbmdlbnRfUG9pbnRQb2x5QyhQLCBWKSB7XHJcbiAgICB2YXIgVmNsb3NlZCA9IFYuc2xpY2UoMCk7XHJcbiAgICBWY2xvc2VkLnB1c2goVlswXSk7XHJcbiAgICByZXR1cm4geyBydGFuOiBSdGFuZ2VudF9Qb2ludFBvbHlDKFAsIFZjbG9zZWQpLCBsdGFuOiBMdGFuZ2VudF9Qb2ludFBvbHlDKFAsIFZjbG9zZWQpIH07XHJcbn1cclxuZnVuY3Rpb24gUnRhbmdlbnRfUG9pbnRQb2x5QyhQLCBWKSB7XHJcbiAgICB2YXIgbiA9IFYubGVuZ3RoIC0gMTtcclxuICAgIHZhciBhLCBiLCBjO1xyXG4gICAgdmFyIHVwQSwgZG5DO1xyXG4gICAgaWYgKGJlbG93KFAsIFZbMV0sIFZbMF0pICYmICFhYm92ZShQLCBWW24gLSAxXSwgVlswXSkpXHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICBmb3IgKGEgPSAwLCBiID0gbjs7KSB7XHJcbiAgICAgICAgaWYgKGIgLSBhID09PSAxKVxyXG4gICAgICAgICAgICBpZiAoYWJvdmUoUCwgVlthXSwgVltiXSkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGI7XHJcbiAgICAgICAgYyA9IE1hdGguZmxvb3IoKGEgKyBiKSAvIDIpO1xyXG4gICAgICAgIGRuQyA9IGJlbG93KFAsIFZbYyArIDFdLCBWW2NdKTtcclxuICAgICAgICBpZiAoZG5DICYmICFhYm92ZShQLCBWW2MgLSAxXSwgVltjXSkpXHJcbiAgICAgICAgICAgIHJldHVybiBjO1xyXG4gICAgICAgIHVwQSA9IGFib3ZlKFAsIFZbYSArIDFdLCBWW2FdKTtcclxuICAgICAgICBpZiAodXBBKSB7XHJcbiAgICAgICAgICAgIGlmIChkbkMpXHJcbiAgICAgICAgICAgICAgICBiID0gYztcclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYWJvdmUoUCwgVlthXSwgVltjXSkpXHJcbiAgICAgICAgICAgICAgICAgICAgYiA9IGM7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgYSA9IGM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICghZG5DKVxyXG4gICAgICAgICAgICAgICAgYSA9IGM7XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKGJlbG93KFAsIFZbYV0sIFZbY10pKVxyXG4gICAgICAgICAgICAgICAgICAgIGIgPSBjO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIGEgPSBjO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIEx0YW5nZW50X1BvaW50UG9seUMoUCwgVikge1xyXG4gICAgdmFyIG4gPSBWLmxlbmd0aCAtIDE7XHJcbiAgICB2YXIgYSwgYiwgYztcclxuICAgIHZhciBkbkEsIGRuQztcclxuICAgIGlmIChhYm92ZShQLCBWW24gLSAxXSwgVlswXSkgJiYgIWJlbG93KFAsIFZbMV0sIFZbMF0pKVxyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgZm9yIChhID0gMCwgYiA9IG47Oykge1xyXG4gICAgICAgIGlmIChiIC0gYSA9PT0gMSlcclxuICAgICAgICAgICAgaWYgKGJlbG93KFAsIFZbYV0sIFZbYl0pKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGE7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHJldHVybiBiO1xyXG4gICAgICAgIGMgPSBNYXRoLmZsb29yKChhICsgYikgLyAyKTtcclxuICAgICAgICBkbkMgPSBiZWxvdyhQLCBWW2MgKyAxXSwgVltjXSk7XHJcbiAgICAgICAgaWYgKGFib3ZlKFAsIFZbYyAtIDFdLCBWW2NdKSAmJiAhZG5DKVxyXG4gICAgICAgICAgICByZXR1cm4gYztcclxuICAgICAgICBkbkEgPSBiZWxvdyhQLCBWW2EgKyAxXSwgVlthXSk7XHJcbiAgICAgICAgaWYgKGRuQSkge1xyXG4gICAgICAgICAgICBpZiAoIWRuQylcclxuICAgICAgICAgICAgICAgIGIgPSBjO1xyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChiZWxvdyhQLCBWW2FdLCBWW2NdKSlcclxuICAgICAgICAgICAgICAgICAgICBiID0gYztcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBhID0gYztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKGRuQylcclxuICAgICAgICAgICAgICAgIGEgPSBjO1xyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChhYm92ZShQLCBWW2FdLCBWW2NdKSlcclxuICAgICAgICAgICAgICAgICAgICBiID0gYztcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBhID0gYztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB0YW5nZW50X1BvbHlQb2x5QyhWLCBXLCB0MSwgdDIsIGNtcDEsIGNtcDIpIHtcclxuICAgIHZhciBpeDEsIGl4MjtcclxuICAgIGl4MSA9IHQxKFdbMF0sIFYpO1xyXG4gICAgaXgyID0gdDIoVltpeDFdLCBXKTtcclxuICAgIHZhciBkb25lID0gZmFsc2U7XHJcbiAgICB3aGlsZSAoIWRvbmUpIHtcclxuICAgICAgICBkb25lID0gdHJ1ZTtcclxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgICAgICBpZiAoaXgxID09PSBWLmxlbmd0aCAtIDEpXHJcbiAgICAgICAgICAgICAgICBpeDEgPSAwO1xyXG4gICAgICAgICAgICBpZiAoY21wMShXW2l4Ml0sIFZbaXgxXSwgVltpeDEgKyAxXSkpXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgKytpeDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgIGlmIChpeDIgPT09IDApXHJcbiAgICAgICAgICAgICAgICBpeDIgPSBXLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgICAgIGlmIChjbXAyKFZbaXgxXSwgV1tpeDJdLCBXW2l4MiAtIDFdKSlcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAtLWl4MjtcclxuICAgICAgICAgICAgZG9uZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB7IHQxOiBpeDEsIHQyOiBpeDIgfTtcclxufVxyXG5leHBvcnRzLnRhbmdlbnRfUG9seVBvbHlDID0gdGFuZ2VudF9Qb2x5UG9seUM7XHJcbmZ1bmN0aW9uIExSdGFuZ2VudF9Qb2x5UG9seUMoViwgVykge1xyXG4gICAgdmFyIHJsID0gUkx0YW5nZW50X1BvbHlQb2x5QyhXLCBWKTtcclxuICAgIHJldHVybiB7IHQxOiBybC50MiwgdDI6IHJsLnQxIH07XHJcbn1cclxuZXhwb3J0cy5MUnRhbmdlbnRfUG9seVBvbHlDID0gTFJ0YW5nZW50X1BvbHlQb2x5QztcclxuZnVuY3Rpb24gUkx0YW5nZW50X1BvbHlQb2x5QyhWLCBXKSB7XHJcbiAgICByZXR1cm4gdGFuZ2VudF9Qb2x5UG9seUMoViwgVywgUnRhbmdlbnRfUG9pbnRQb2x5QywgTHRhbmdlbnRfUG9pbnRQb2x5QywgYWJvdmUsIGJlbG93KTtcclxufVxyXG5leHBvcnRzLlJMdGFuZ2VudF9Qb2x5UG9seUMgPSBSTHRhbmdlbnRfUG9seVBvbHlDO1xyXG5mdW5jdGlvbiBMTHRhbmdlbnRfUG9seVBvbHlDKFYsIFcpIHtcclxuICAgIHJldHVybiB0YW5nZW50X1BvbHlQb2x5QyhWLCBXLCBMdGFuZ2VudF9Qb2ludFBvbHlDLCBMdGFuZ2VudF9Qb2ludFBvbHlDLCBiZWxvdywgYmVsb3cpO1xyXG59XHJcbmV4cG9ydHMuTEx0YW5nZW50X1BvbHlQb2x5QyA9IExMdGFuZ2VudF9Qb2x5UG9seUM7XHJcbmZ1bmN0aW9uIFJSdGFuZ2VudF9Qb2x5UG9seUMoViwgVykge1xyXG4gICAgcmV0dXJuIHRhbmdlbnRfUG9seVBvbHlDKFYsIFcsIFJ0YW5nZW50X1BvaW50UG9seUMsIFJ0YW5nZW50X1BvaW50UG9seUMsIGFib3ZlLCBhYm92ZSk7XHJcbn1cclxuZXhwb3J0cy5SUnRhbmdlbnRfUG9seVBvbHlDID0gUlJ0YW5nZW50X1BvbHlQb2x5QztcclxudmFyIEJpVGFuZ2VudCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBCaVRhbmdlbnQodDEsIHQyKSB7XHJcbiAgICAgICAgdGhpcy50MSA9IHQxO1xyXG4gICAgICAgIHRoaXMudDIgPSB0MjtcclxuICAgIH1cclxuICAgIHJldHVybiBCaVRhbmdlbnQ7XHJcbn0oKSk7XHJcbmV4cG9ydHMuQmlUYW5nZW50ID0gQmlUYW5nZW50O1xyXG52YXIgQmlUYW5nZW50cyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBCaVRhbmdlbnRzKCkge1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIEJpVGFuZ2VudHM7XHJcbn0oKSk7XHJcbmV4cG9ydHMuQmlUYW5nZW50cyA9IEJpVGFuZ2VudHM7XHJcbnZhciBUVkdQb2ludCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoVFZHUG9pbnQsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBUVkdQb2ludCgpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gVFZHUG9pbnQ7XHJcbn0oUG9pbnQpKTtcclxuZXhwb3J0cy5UVkdQb2ludCA9IFRWR1BvaW50O1xyXG52YXIgVmlzaWJpbGl0eVZlcnRleCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBWaXNpYmlsaXR5VmVydGV4KGlkLCBwb2x5aWQsIHBvbHl2ZXJ0aWQsIHApIHtcclxuICAgICAgICB0aGlzLmlkID0gaWQ7XHJcbiAgICAgICAgdGhpcy5wb2x5aWQgPSBwb2x5aWQ7XHJcbiAgICAgICAgdGhpcy5wb2x5dmVydGlkID0gcG9seXZlcnRpZDtcclxuICAgICAgICB0aGlzLnAgPSBwO1xyXG4gICAgICAgIHAudnYgPSB0aGlzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFZpc2liaWxpdHlWZXJ0ZXg7XHJcbn0oKSk7XHJcbmV4cG9ydHMuVmlzaWJpbGl0eVZlcnRleCA9IFZpc2liaWxpdHlWZXJ0ZXg7XHJcbnZhciBWaXNpYmlsaXR5RWRnZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBWaXNpYmlsaXR5RWRnZShzb3VyY2UsIHRhcmdldCkge1xyXG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xyXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgfVxyXG4gICAgVmlzaWJpbGl0eUVkZ2UucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZHggPSB0aGlzLnNvdXJjZS5wLnggLSB0aGlzLnRhcmdldC5wLng7XHJcbiAgICAgICAgdmFyIGR5ID0gdGhpcy5zb3VyY2UucC55IC0gdGhpcy50YXJnZXQucC55O1xyXG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBWaXNpYmlsaXR5RWRnZTtcclxufSgpKTtcclxuZXhwb3J0cy5WaXNpYmlsaXR5RWRnZSA9IFZpc2liaWxpdHlFZGdlO1xyXG52YXIgVGFuZ2VudFZpc2liaWxpdHlHcmFwaCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBUYW5nZW50VmlzaWJpbGl0eUdyYXBoKFAsIGcwKSB7XHJcbiAgICAgICAgdGhpcy5QID0gUDtcclxuICAgICAgICB0aGlzLlYgPSBbXTtcclxuICAgICAgICB0aGlzLkUgPSBbXTtcclxuICAgICAgICBpZiAoIWcwKSB7XHJcbiAgICAgICAgICAgIHZhciBuID0gUC5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcCA9IFBbaV07XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHAubGVuZ3RoOyArK2opIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGogPSBwW2pdLCB2diA9IG5ldyBWaXNpYmlsaXR5VmVydGV4KHRoaXMuVi5sZW5ndGgsIGksIGosIHBqKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLlYucHVzaCh2dik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGogPiAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLkUucHVzaChuZXcgVmlzaWJpbGl0eUVkZ2UocFtqIC0gMV0udnYsIHZ2KSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocC5sZW5ndGggPiAxKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuRS5wdXNoKG5ldyBWaXNpYmlsaXR5RWRnZShwWzBdLnZ2LCBwW3AubGVuZ3RoIC0gMV0udnYpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG4gLSAxOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBQaSA9IFBbaV07XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gaSArIDE7IGogPCBuOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgUGogPSBQW2pdLCB0ID0gdGFuZ2VudHMoUGksIFBqKTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBxIGluIHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSB0W3FdLCBzb3VyY2UgPSBQaVtjLnQxXSwgdGFyZ2V0ID0gUGpbYy50Ml07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkRWRnZUlmVmlzaWJsZShzb3VyY2UsIHRhcmdldCwgaSwgaik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLlYgPSBnMC5WLnNsaWNlKDApO1xyXG4gICAgICAgICAgICB0aGlzLkUgPSBnMC5FLnNsaWNlKDApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIFRhbmdlbnRWaXNpYmlsaXR5R3JhcGgucHJvdG90eXBlLmFkZEVkZ2VJZlZpc2libGUgPSBmdW5jdGlvbiAodSwgdiwgaTEsIGkyKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmludGVyc2VjdHNQb2x5cyhuZXcgTGluZVNlZ21lbnQodS54LCB1LnksIHYueCwgdi55KSwgaTEsIGkyKSkge1xyXG4gICAgICAgICAgICB0aGlzLkUucHVzaChuZXcgVmlzaWJpbGl0eUVkZ2UodS52diwgdi52dikpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBUYW5nZW50VmlzaWJpbGl0eUdyYXBoLnByb3RvdHlwZS5hZGRQb2ludCA9IGZ1bmN0aW9uIChwLCBpMSkge1xyXG4gICAgICAgIHZhciBuID0gdGhpcy5QLmxlbmd0aDtcclxuICAgICAgICB0aGlzLlYucHVzaChuZXcgVmlzaWJpbGl0eVZlcnRleCh0aGlzLlYubGVuZ3RoLCBuLCAwLCBwKSk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHtcclxuICAgICAgICAgICAgaWYgKGkgPT09IGkxKVxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIHZhciBwb2x5ID0gdGhpcy5QW2ldLCB0ID0gdGFuZ2VudF9Qb2ludFBvbHlDKHAsIHBvbHkpO1xyXG4gICAgICAgICAgICB0aGlzLmFkZEVkZ2VJZlZpc2libGUocCwgcG9seVt0Lmx0YW5dLCBpMSwgaSk7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkRWRnZUlmVmlzaWJsZShwLCBwb2x5W3QucnRhbl0sIGkxLCBpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHAudnY7XHJcbiAgICB9O1xyXG4gICAgVGFuZ2VudFZpc2liaWxpdHlHcmFwaC5wcm90b3R5cGUuaW50ZXJzZWN0c1BvbHlzID0gZnVuY3Rpb24gKGwsIGkxLCBpMikge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gdGhpcy5QLmxlbmd0aDsgaSA8IG47ICsraSkge1xyXG4gICAgICAgICAgICBpZiAoaSAhPSBpMSAmJiBpICE9IGkyICYmIGludGVyc2VjdHMobCwgdGhpcy5QW2ldKS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFRhbmdlbnRWaXNpYmlsaXR5R3JhcGg7XHJcbn0oKSk7XHJcbmV4cG9ydHMuVGFuZ2VudFZpc2liaWxpdHlHcmFwaCA9IFRhbmdlbnRWaXNpYmlsaXR5R3JhcGg7XHJcbmZ1bmN0aW9uIGludGVyc2VjdHMobCwgUCkge1xyXG4gICAgdmFyIGludHMgPSBbXTtcclxuICAgIGZvciAodmFyIGkgPSAxLCBuID0gUC5sZW5ndGg7IGkgPCBuOyArK2kpIHtcclxuICAgICAgICB2YXIgaW50ID0gcmVjdGFuZ2xlXzEuUmVjdGFuZ2xlLmxpbmVJbnRlcnNlY3Rpb24obC54MSwgbC55MSwgbC54MiwgbC55MiwgUFtpIC0gMV0ueCwgUFtpIC0gMV0ueSwgUFtpXS54LCBQW2ldLnkpO1xyXG4gICAgICAgIGlmIChpbnQpXHJcbiAgICAgICAgICAgIGludHMucHVzaChpbnQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGludHM7XHJcbn1cclxuZnVuY3Rpb24gdGFuZ2VudHMoViwgVykge1xyXG4gICAgdmFyIG0gPSBWLmxlbmd0aCAtIDEsIG4gPSBXLmxlbmd0aCAtIDE7XHJcbiAgICB2YXIgYnQgPSBuZXcgQmlUYW5nZW50cygpO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtOyArK2kpIHtcclxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG47ICsraikge1xyXG4gICAgICAgICAgICB2YXIgdjEgPSBWW2kgPT0gMCA/IG0gLSAxIDogaSAtIDFdO1xyXG4gICAgICAgICAgICB2YXIgdjIgPSBWW2ldO1xyXG4gICAgICAgICAgICB2YXIgdjMgPSBWW2kgKyAxXTtcclxuICAgICAgICAgICAgdmFyIHcxID0gV1tqID09IDAgPyBuIC0gMSA6IGogLSAxXTtcclxuICAgICAgICAgICAgdmFyIHcyID0gV1tqXTtcclxuICAgICAgICAgICAgdmFyIHczID0gV1tqICsgMV07XHJcbiAgICAgICAgICAgIHZhciB2MXYydzIgPSBpc0xlZnQodjEsIHYyLCB3Mik7XHJcbiAgICAgICAgICAgIHZhciB2MncxdzIgPSBpc0xlZnQodjIsIHcxLCB3Mik7XHJcbiAgICAgICAgICAgIHZhciB2MncydzMgPSBpc0xlZnQodjIsIHcyLCB3Myk7XHJcbiAgICAgICAgICAgIHZhciB3MXcydjIgPSBpc0xlZnQodzEsIHcyLCB2Mik7XHJcbiAgICAgICAgICAgIHZhciB3MnYxdjIgPSBpc0xlZnQodzIsIHYxLCB2Mik7XHJcbiAgICAgICAgICAgIHZhciB3MnYydjMgPSBpc0xlZnQodzIsIHYyLCB2Myk7XHJcbiAgICAgICAgICAgIGlmICh2MXYydzIgPj0gMCAmJiB2MncxdzIgPj0gMCAmJiB2MncydzMgPCAwXHJcbiAgICAgICAgICAgICAgICAmJiB3MXcydjIgPj0gMCAmJiB3MnYxdjIgPj0gMCAmJiB3MnYydjMgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBidC5sbCA9IG5ldyBCaVRhbmdlbnQoaSwgaik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodjF2MncyIDw9IDAgJiYgdjJ3MXcyIDw9IDAgJiYgdjJ3MnczID4gMFxyXG4gICAgICAgICAgICAgICAgJiYgdzF3MnYyIDw9IDAgJiYgdzJ2MXYyIDw9IDAgJiYgdzJ2MnYzID4gMCkge1xyXG4gICAgICAgICAgICAgICAgYnQucnIgPSBuZXcgQmlUYW5nZW50KGksIGopO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHYxdjJ3MiA8PSAwICYmIHYydzF3MiA+IDAgJiYgdjJ3MnczIDw9IDBcclxuICAgICAgICAgICAgICAgICYmIHcxdzJ2MiA+PSAwICYmIHcydjF2MiA8IDAgJiYgdzJ2MnYzID49IDApIHtcclxuICAgICAgICAgICAgICAgIGJ0LnJsID0gbmV3IEJpVGFuZ2VudChpLCBqKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh2MXYydzIgPj0gMCAmJiB2MncxdzIgPCAwICYmIHYydzJ3MyA+PSAwXHJcbiAgICAgICAgICAgICAgICAmJiB3MXcydjIgPD0gMCAmJiB3MnYxdjIgPiAwICYmIHcydjJ2MyA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBidC5sciA9IG5ldyBCaVRhbmdlbnQoaSwgaik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYnQ7XHJcbn1cclxuZXhwb3J0cy50YW5nZW50cyA9IHRhbmdlbnRzO1xyXG5mdW5jdGlvbiBpc1BvaW50SW5zaWRlUG9seShwLCBwb2x5KSB7XHJcbiAgICBmb3IgKHZhciBpID0gMSwgbiA9IHBvbHkubGVuZ3RoOyBpIDwgbjsgKytpKVxyXG4gICAgICAgIGlmIChiZWxvdyhwb2x5W2kgLSAxXSwgcG9seVtpXSwgcCkpXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbmZ1bmN0aW9uIGlzQW55UEluUShwLCBxKSB7XHJcbiAgICByZXR1cm4gIXAuZXZlcnkoZnVuY3Rpb24gKHYpIHsgcmV0dXJuICFpc1BvaW50SW5zaWRlUG9seSh2LCBxKTsgfSk7XHJcbn1cclxuZnVuY3Rpb24gcG9seXNPdmVybGFwKHAsIHEpIHtcclxuICAgIGlmIChpc0FueVBJblEocCwgcSkpXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICBpZiAoaXNBbnlQSW5RKHEsIHApKVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgZm9yICh2YXIgaSA9IDEsIG4gPSBwLmxlbmd0aDsgaSA8IG47ICsraSkge1xyXG4gICAgICAgIHZhciB2ID0gcFtpXSwgdSA9IHBbaSAtIDFdO1xyXG4gICAgICAgIGlmIChpbnRlcnNlY3RzKG5ldyBMaW5lU2VnbWVudCh1LngsIHUueSwgdi54LCB2LnkpLCBxKS5sZW5ndGggPiAwKVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5leHBvcnRzLnBvbHlzT3ZlcmxhcCA9IHBvbHlzT3ZlcmxhcDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2VvbS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgcmVjdGFuZ2xlXzEgPSByZXF1aXJlKFwiLi9yZWN0YW5nbGVcIik7XHJcbnZhciB2cHNjXzEgPSByZXF1aXJlKFwiLi92cHNjXCIpO1xyXG52YXIgc2hvcnRlc3RwYXRoc18xID0gcmVxdWlyZShcIi4vc2hvcnRlc3RwYXRoc1wiKTtcclxudmFyIE5vZGVXcmFwcGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE5vZGVXcmFwcGVyKGlkLCByZWN0LCBjaGlsZHJlbikge1xyXG4gICAgICAgIHRoaXMuaWQgPSBpZDtcclxuICAgICAgICB0aGlzLnJlY3QgPSByZWN0O1xyXG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcclxuICAgICAgICB0aGlzLmxlYWYgPSB0eXBlb2YgY2hpbGRyZW4gPT09ICd1bmRlZmluZWQnIHx8IGNoaWxkcmVuLmxlbmd0aCA9PT0gMDtcclxuICAgIH1cclxuICAgIHJldHVybiBOb2RlV3JhcHBlcjtcclxufSgpKTtcclxuZXhwb3J0cy5Ob2RlV3JhcHBlciA9IE5vZGVXcmFwcGVyO1xyXG52YXIgVmVydCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBWZXJ0KGlkLCB4LCB5LCBub2RlLCBsaW5lKSB7XHJcbiAgICAgICAgaWYgKG5vZGUgPT09IHZvaWQgMCkgeyBub2RlID0gbnVsbDsgfVxyXG4gICAgICAgIGlmIChsaW5lID09PSB2b2lkIDApIHsgbGluZSA9IG51bGw7IH1cclxuICAgICAgICB0aGlzLmlkID0gaWQ7XHJcbiAgICAgICAgdGhpcy54ID0geDtcclxuICAgICAgICB0aGlzLnkgPSB5O1xyXG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XHJcbiAgICAgICAgdGhpcy5saW5lID0gbGluZTtcclxuICAgIH1cclxuICAgIHJldHVybiBWZXJ0O1xyXG59KCkpO1xyXG5leHBvcnRzLlZlcnQgPSBWZXJ0O1xyXG52YXIgTG9uZ2VzdENvbW1vblN1YnNlcXVlbmNlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIExvbmdlc3RDb21tb25TdWJzZXF1ZW5jZShzLCB0KSB7XHJcbiAgICAgICAgdGhpcy5zID0gcztcclxuICAgICAgICB0aGlzLnQgPSB0O1xyXG4gICAgICAgIHZhciBtZiA9IExvbmdlc3RDb21tb25TdWJzZXF1ZW5jZS5maW5kTWF0Y2gocywgdCk7XHJcbiAgICAgICAgdmFyIHRyID0gdC5zbGljZSgwKS5yZXZlcnNlKCk7XHJcbiAgICAgICAgdmFyIG1yID0gTG9uZ2VzdENvbW1vblN1YnNlcXVlbmNlLmZpbmRNYXRjaChzLCB0cik7XHJcbiAgICAgICAgaWYgKG1mLmxlbmd0aCA+PSBtci5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhpcy5sZW5ndGggPSBtZi5sZW5ndGg7XHJcbiAgICAgICAgICAgIHRoaXMuc2kgPSBtZi5zaTtcclxuICAgICAgICAgICAgdGhpcy50aSA9IG1mLnRpO1xyXG4gICAgICAgICAgICB0aGlzLnJldmVyc2VkID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmxlbmd0aCA9IG1yLmxlbmd0aDtcclxuICAgICAgICAgICAgdGhpcy5zaSA9IG1yLnNpO1xyXG4gICAgICAgICAgICB0aGlzLnRpID0gdC5sZW5ndGggLSBtci50aSAtIG1yLmxlbmd0aDtcclxuICAgICAgICAgICAgdGhpcy5yZXZlcnNlZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgTG9uZ2VzdENvbW1vblN1YnNlcXVlbmNlLmZpbmRNYXRjaCA9IGZ1bmN0aW9uIChzLCB0KSB7XHJcbiAgICAgICAgdmFyIG0gPSBzLmxlbmd0aDtcclxuICAgICAgICB2YXIgbiA9IHQubGVuZ3RoO1xyXG4gICAgICAgIHZhciBtYXRjaCA9IHsgbGVuZ3RoOiAwLCBzaTogLTEsIHRpOiAtMSB9O1xyXG4gICAgICAgIHZhciBsID0gbmV3IEFycmF5KG0pO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbTsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxbaV0gPSBuZXcgQXJyYXkobik7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbjsgaisrKVxyXG4gICAgICAgICAgICAgICAgaWYgKHNbaV0gPT09IHRbal0pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdiA9IGxbaV1bal0gPSAoaSA9PT0gMCB8fCBqID09PSAwKSA/IDEgOiBsW2kgLSAxXVtqIC0gMV0gKyAxO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2ID4gbWF0Y2gubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoLmxlbmd0aCA9IHY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoLnNpID0gaSAtIHYgKyAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaC50aSA9IGogLSB2ICsgMTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIGxbaV1bal0gPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbWF0Y2g7XHJcbiAgICB9O1xyXG4gICAgTG9uZ2VzdENvbW1vblN1YnNlcXVlbmNlLnByb3RvdHlwZS5nZXRTZXF1ZW5jZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5sZW5ndGggPj0gMCA/IHRoaXMucy5zbGljZSh0aGlzLnNpLCB0aGlzLnNpICsgdGhpcy5sZW5ndGgpIDogW107XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIExvbmdlc3RDb21tb25TdWJzZXF1ZW5jZTtcclxufSgpKTtcclxuZXhwb3J0cy5Mb25nZXN0Q29tbW9uU3Vic2VxdWVuY2UgPSBMb25nZXN0Q29tbW9uU3Vic2VxdWVuY2U7XHJcbnZhciBHcmlkUm91dGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEdyaWRSb3V0ZXIob3JpZ2luYWxub2RlcywgYWNjZXNzb3IsIGdyb3VwUGFkZGluZykge1xyXG4gICAgICAgIGlmIChncm91cFBhZGRpbmcgPT09IHZvaWQgMCkgeyBncm91cFBhZGRpbmcgPSAxMjsgfVxyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5vcmlnaW5hbG5vZGVzID0gb3JpZ2luYWxub2RlcztcclxuICAgICAgICB0aGlzLmdyb3VwUGFkZGluZyA9IGdyb3VwUGFkZGluZztcclxuICAgICAgICB0aGlzLmxlYXZlcyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5ub2RlcyA9IG9yaWdpbmFsbm9kZXMubWFwKGZ1bmN0aW9uICh2LCBpKSB7IHJldHVybiBuZXcgTm9kZVdyYXBwZXIoaSwgYWNjZXNzb3IuZ2V0Qm91bmRzKHYpLCBhY2Nlc3Nvci5nZXRDaGlsZHJlbih2KSk7IH0pO1xyXG4gICAgICAgIHRoaXMubGVhdmVzID0gdGhpcy5ub2Rlcy5maWx0ZXIoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHYubGVhZjsgfSk7XHJcbiAgICAgICAgdGhpcy5ncm91cHMgPSB0aGlzLm5vZGVzLmZpbHRlcihmdW5jdGlvbiAoZykgeyByZXR1cm4gIWcubGVhZjsgfSk7XHJcbiAgICAgICAgdGhpcy5jb2xzID0gdGhpcy5nZXRHcmlkTGluZXMoJ3gnKTtcclxuICAgICAgICB0aGlzLnJvd3MgPSB0aGlzLmdldEdyaWRMaW5lcygneScpO1xyXG4gICAgICAgIHRoaXMuZ3JvdXBzLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHYuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gX3RoaXMubm9kZXNbY10ucGFyZW50ID0gdjsgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5yb290ID0geyBjaGlsZHJlbjogW10gfTtcclxuICAgICAgICB0aGlzLm5vZGVzLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2LnBhcmVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgIHYucGFyZW50ID0gX3RoaXMucm9vdDtcclxuICAgICAgICAgICAgICAgIF90aGlzLnJvb3QuY2hpbGRyZW4ucHVzaCh2LmlkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2LnBvcnRzID0gW107XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5iYWNrVG9Gcm9udCA9IHRoaXMubm9kZXMuc2xpY2UoMCk7XHJcbiAgICAgICAgdGhpcy5iYWNrVG9Gcm9udC5zb3J0KGZ1bmN0aW9uICh4LCB5KSB7IHJldHVybiBfdGhpcy5nZXREZXB0aCh4KSAtIF90aGlzLmdldERlcHRoKHkpOyB9KTtcclxuICAgICAgICB2YXIgZnJvbnRUb0JhY2tHcm91cHMgPSB0aGlzLmJhY2tUb0Zyb250LnNsaWNlKDApLnJldmVyc2UoKS5maWx0ZXIoZnVuY3Rpb24gKGcpIHsgcmV0dXJuICFnLmxlYWY7IH0pO1xyXG4gICAgICAgIGZyb250VG9CYWNrR3JvdXBzLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgdmFyIHIgPSByZWN0YW5nbGVfMS5SZWN0YW5nbGUuZW1wdHkoKTtcclxuICAgICAgICAgICAgdi5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7IHJldHVybiByID0gci51bmlvbihfdGhpcy5ub2Rlc1tjXS5yZWN0KTsgfSk7XHJcbiAgICAgICAgICAgIHYucmVjdCA9IHIuaW5mbGF0ZShfdGhpcy5ncm91cFBhZGRpbmcpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciBjb2xNaWRzID0gdGhpcy5taWRQb2ludHModGhpcy5jb2xzLm1hcChmdW5jdGlvbiAocikgeyByZXR1cm4gci5wb3M7IH0pKTtcclxuICAgICAgICB2YXIgcm93TWlkcyA9IHRoaXMubWlkUG9pbnRzKHRoaXMucm93cy5tYXAoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIHIucG9zOyB9KSk7XHJcbiAgICAgICAgdmFyIHJvd3ggPSBjb2xNaWRzWzBdLCByb3dYID0gY29sTWlkc1tjb2xNaWRzLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgIHZhciBjb2x5ID0gcm93TWlkc1swXSwgY29sWSA9IHJvd01pZHNbcm93TWlkcy5sZW5ndGggLSAxXTtcclxuICAgICAgICB2YXIgaGxpbmVzID0gdGhpcy5yb3dzLm1hcChmdW5jdGlvbiAocikgeyByZXR1cm4gKHsgeDE6IHJvd3gsIHgyOiByb3dYLCB5MTogci5wb3MsIHkyOiByLnBvcyB9KTsgfSlcclxuICAgICAgICAgICAgLmNvbmNhdChyb3dNaWRzLm1hcChmdW5jdGlvbiAobSkgeyByZXR1cm4gKHsgeDE6IHJvd3gsIHgyOiByb3dYLCB5MTogbSwgeTI6IG0gfSk7IH0pKTtcclxuICAgICAgICB2YXIgdmxpbmVzID0gdGhpcy5jb2xzLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gKHsgeDE6IGMucG9zLCB4MjogYy5wb3MsIHkxOiBjb2x5LCB5MjogY29sWSB9KTsgfSlcclxuICAgICAgICAgICAgLmNvbmNhdChjb2xNaWRzLm1hcChmdW5jdGlvbiAobSkgeyByZXR1cm4gKHsgeDE6IG0sIHgyOiBtLCB5MTogY29seSwgeTI6IGNvbFkgfSk7IH0pKTtcclxuICAgICAgICB2YXIgbGluZXMgPSBobGluZXMuY29uY2F0KHZsaW5lcyk7XHJcbiAgICAgICAgbGluZXMuZm9yRWFjaChmdW5jdGlvbiAobCkgeyByZXR1cm4gbC52ZXJ0cyA9IFtdOyB9KTtcclxuICAgICAgICB0aGlzLnZlcnRzID0gW107XHJcbiAgICAgICAgdGhpcy5lZGdlcyA9IFtdO1xyXG4gICAgICAgIGhsaW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB2bGluZXMuZm9yRWFjaChmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICAgdmFyIHAgPSBuZXcgVmVydChfdGhpcy52ZXJ0cy5sZW5ndGgsIHYueDEsIGgueTEpO1xyXG4gICAgICAgICAgICAgICAgaC52ZXJ0cy5wdXNoKHApO1xyXG4gICAgICAgICAgICAgICAgdi52ZXJ0cy5wdXNoKHApO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMudmVydHMucHVzaChwKTtcclxuICAgICAgICAgICAgICAgIHZhciBpID0gX3RoaXMuYmFja1RvRnJvbnQubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGktLSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IF90aGlzLmJhY2tUb0Zyb250W2ldLCByID0gbm9kZS5yZWN0O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkeCA9IE1hdGguYWJzKHAueCAtIHIuY3goKSksIGR5ID0gTWF0aC5hYnMocC55IC0gci5jeSgpKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZHggPCByLndpZHRoKCkgLyAyICYmIGR5IDwgci5oZWlnaHQoKSAvIDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcC5ub2RlID0gbm9kZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBsaW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChsLCBsaSkge1xyXG4gICAgICAgICAgICBfdGhpcy5ub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uICh2LCBpKSB7XHJcbiAgICAgICAgICAgICAgICB2LnJlY3QubGluZUludGVyc2VjdGlvbnMobC54MSwgbC55MSwgbC54MiwgbC55MikuZm9yRWFjaChmdW5jdGlvbiAoaW50ZXJzZWN0LCBqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSBuZXcgVmVydChfdGhpcy52ZXJ0cy5sZW5ndGgsIGludGVyc2VjdC54LCBpbnRlcnNlY3QueSwgdiwgbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudmVydHMucHVzaChwKTtcclxuICAgICAgICAgICAgICAgICAgICBsLnZlcnRzLnB1c2gocCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdi5wb3J0cy5wdXNoKHApO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB2YXIgaXNIb3JpeiA9IE1hdGguYWJzKGwueTEgLSBsLnkyKSA8IDAuMTtcclxuICAgICAgICAgICAgdmFyIGRlbHRhID0gZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGlzSG9yaXogPyBiLnggLSBhLnggOiBiLnkgLSBhLnk7IH07XHJcbiAgICAgICAgICAgIGwudmVydHMuc29ydChkZWx0YSk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbC52ZXJ0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHUgPSBsLnZlcnRzW2kgLSAxXSwgdiA9IGwudmVydHNbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAodS5ub2RlICYmIHUubm9kZSA9PT0gdi5ub2RlICYmIHUubm9kZS5sZWFmKVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuZWRnZXMucHVzaCh7IHNvdXJjZTogdS5pZCwgdGFyZ2V0OiB2LmlkLCBsZW5ndGg6IE1hdGguYWJzKGRlbHRhKHUsIHYpKSB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgR3JpZFJvdXRlci5wcm90b3R5cGUuYXZnID0gZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGEucmVkdWNlKGZ1bmN0aW9uICh4LCB5KSB7IHJldHVybiB4ICsgeTsgfSkgLyBhLmxlbmd0aDsgfTtcclxuICAgIEdyaWRSb3V0ZXIucHJvdG90eXBlLmdldEdyaWRMaW5lcyA9IGZ1bmN0aW9uIChheGlzKSB7XHJcbiAgICAgICAgdmFyIGNvbHVtbnMgPSBbXTtcclxuICAgICAgICB2YXIgbHMgPSB0aGlzLmxlYXZlcy5zbGljZSgwLCB0aGlzLmxlYXZlcy5sZW5ndGgpO1xyXG4gICAgICAgIHdoaWxlIChscy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHZhciBvdmVybGFwcGluZyA9IGxzLmZpbHRlcihmdW5jdGlvbiAodikgeyByZXR1cm4gdi5yZWN0WydvdmVybGFwJyArIGF4aXMudG9VcHBlckNhc2UoKV0obHNbMF0ucmVjdCk7IH0pO1xyXG4gICAgICAgICAgICB2YXIgY29sID0ge1xyXG4gICAgICAgICAgICAgICAgbm9kZXM6IG92ZXJsYXBwaW5nLFxyXG4gICAgICAgICAgICAgICAgcG9zOiB0aGlzLmF2ZyhvdmVybGFwcGluZy5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHYucmVjdFsnYycgKyBheGlzXSgpOyB9KSlcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY29sdW1ucy5wdXNoKGNvbCk7XHJcbiAgICAgICAgICAgIGNvbC5ub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7IHJldHVybiBscy5zcGxpY2UobHMuaW5kZXhPZih2KSwgMSk7IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb2x1bW5zLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEucG9zIC0gYi5wb3M7IH0pO1xyXG4gICAgICAgIHJldHVybiBjb2x1bW5zO1xyXG4gICAgfTtcclxuICAgIEdyaWRSb3V0ZXIucHJvdG90eXBlLmdldERlcHRoID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICB2YXIgZGVwdGggPSAwO1xyXG4gICAgICAgIHdoaWxlICh2LnBhcmVudCAhPT0gdGhpcy5yb290KSB7XHJcbiAgICAgICAgICAgIGRlcHRoKys7XHJcbiAgICAgICAgICAgIHYgPSB2LnBhcmVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRlcHRoO1xyXG4gICAgfTtcclxuICAgIEdyaWRSb3V0ZXIucHJvdG90eXBlLm1pZFBvaW50cyA9IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgdmFyIGdhcCA9IGFbMV0gLSBhWzBdO1xyXG4gICAgICAgIHZhciBtaWRzID0gW2FbMF0gLSBnYXAgLyAyXTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgbWlkcy5wdXNoKChhW2ldICsgYVtpIC0gMV0pIC8gMik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1pZHMucHVzaChhW2EubGVuZ3RoIC0gMV0gKyBnYXAgLyAyKTtcclxuICAgICAgICByZXR1cm4gbWlkcztcclxuICAgIH07XHJcbiAgICBHcmlkUm91dGVyLnByb3RvdHlwZS5maW5kTGluZWFnZSA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgdmFyIGxpbmVhZ2UgPSBbdl07XHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICB2ID0gdi5wYXJlbnQ7XHJcbiAgICAgICAgICAgIGxpbmVhZ2UucHVzaCh2KTtcclxuICAgICAgICB9IHdoaWxlICh2ICE9PSB0aGlzLnJvb3QpO1xyXG4gICAgICAgIHJldHVybiBsaW5lYWdlLnJldmVyc2UoKTtcclxuICAgIH07XHJcbiAgICBHcmlkUm91dGVyLnByb3RvdHlwZS5maW5kQW5jZXN0b3JQYXRoQmV0d2VlbiA9IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgdmFyIGFhID0gdGhpcy5maW5kTGluZWFnZShhKSwgYmEgPSB0aGlzLmZpbmRMaW5lYWdlKGIpLCBpID0gMDtcclxuICAgICAgICB3aGlsZSAoYWFbaV0gPT09IGJhW2ldKVxyXG4gICAgICAgICAgICBpKys7XHJcbiAgICAgICAgcmV0dXJuIHsgY29tbW9uQW5jZXN0b3I6IGFhW2kgLSAxXSwgbGluZWFnZXM6IGFhLnNsaWNlKGkpLmNvbmNhdChiYS5zbGljZShpKSkgfTtcclxuICAgIH07XHJcbiAgICBHcmlkUm91dGVyLnByb3RvdHlwZS5zaWJsaW5nT2JzdGFjbGVzID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBwYXRoID0gdGhpcy5maW5kQW5jZXN0b3JQYXRoQmV0d2VlbihhLCBiKTtcclxuICAgICAgICB2YXIgbGluZWFnZUxvb2t1cCA9IHt9O1xyXG4gICAgICAgIHBhdGgubGluZWFnZXMuZm9yRWFjaChmdW5jdGlvbiAodikgeyByZXR1cm4gbGluZWFnZUxvb2t1cFt2LmlkXSA9IHt9OyB9KTtcclxuICAgICAgICB2YXIgb2JzdGFjbGVzID0gcGF0aC5jb21tb25BbmNlc3Rvci5jaGlsZHJlbi5maWx0ZXIoZnVuY3Rpb24gKHYpIHsgcmV0dXJuICEodiBpbiBsaW5lYWdlTG9va3VwKTsgfSk7XHJcbiAgICAgICAgcGF0aC5saW5lYWdlc1xyXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uICh2KSB7IHJldHVybiB2LnBhcmVudCAhPT0gcGF0aC5jb21tb25BbmNlc3RvcjsgfSlcclxuICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG9ic3RhY2xlcyA9IG9ic3RhY2xlcy5jb25jYXQodi5wYXJlbnQuY2hpbGRyZW4uZmlsdGVyKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjICE9PSB2LmlkOyB9KSk7IH0pO1xyXG4gICAgICAgIHJldHVybiBvYnN0YWNsZXMubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiBfdGhpcy5ub2Rlc1t2XTsgfSk7XHJcbiAgICB9O1xyXG4gICAgR3JpZFJvdXRlci5nZXRTZWdtZW50U2V0cyA9IGZ1bmN0aW9uIChyb3V0ZXMsIHgsIHkpIHtcclxuICAgICAgICB2YXIgdnNlZ21lbnRzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgZWkgPSAwOyBlaSA8IHJvdXRlcy5sZW5ndGg7IGVpKyspIHtcclxuICAgICAgICAgICAgdmFyIHJvdXRlID0gcm91dGVzW2VpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgc2kgPSAwOyBzaSA8IHJvdXRlLmxlbmd0aDsgc2krKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHMgPSByb3V0ZVtzaV07XHJcbiAgICAgICAgICAgICAgICBzLmVkZ2VpZCA9IGVpO1xyXG4gICAgICAgICAgICAgICAgcy5pID0gc2k7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2R4ID0gc1sxXVt4XSAtIHNbMF1beF07XHJcbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoc2R4KSA8IDAuMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZzZWdtZW50cy5wdXNoKHMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZzZWdtZW50cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhWzBdW3hdIC0gYlswXVt4XTsgfSk7XHJcbiAgICAgICAgdmFyIHZzZWdtZW50c2V0cyA9IFtdO1xyXG4gICAgICAgIHZhciBzZWdtZW50c2V0ID0gbnVsbDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZzZWdtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgcyA9IHZzZWdtZW50c1tpXTtcclxuICAgICAgICAgICAgaWYgKCFzZWdtZW50c2V0IHx8IE1hdGguYWJzKHNbMF1beF0gLSBzZWdtZW50c2V0LnBvcykgPiAwLjEpIHtcclxuICAgICAgICAgICAgICAgIHNlZ21lbnRzZXQgPSB7IHBvczogc1swXVt4XSwgc2VnbWVudHM6IFtdIH07XHJcbiAgICAgICAgICAgICAgICB2c2VnbWVudHNldHMucHVzaChzZWdtZW50c2V0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzZWdtZW50c2V0LnNlZ21lbnRzLnB1c2gocyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2c2VnbWVudHNldHM7XHJcbiAgICB9O1xyXG4gICAgR3JpZFJvdXRlci5udWRnZVNlZ3MgPSBmdW5jdGlvbiAoeCwgeSwgcm91dGVzLCBzZWdtZW50cywgbGVmdE9mLCBnYXApIHtcclxuICAgICAgICB2YXIgbiA9IHNlZ21lbnRzLmxlbmd0aDtcclxuICAgICAgICBpZiAobiA8PSAxKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgdmFyIHZzID0gc2VnbWVudHMubWFwKGZ1bmN0aW9uIChzKSB7IHJldHVybiBuZXcgdnBzY18xLlZhcmlhYmxlKHNbMF1beF0pOyB9KTtcclxuICAgICAgICB2YXIgY3MgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG47IGorKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IGopXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB2YXIgczEgPSBzZWdtZW50c1tpXSwgczIgPSBzZWdtZW50c1tqXSwgZTEgPSBzMS5lZGdlaWQsIGUyID0gczIuZWRnZWlkLCBsaW5kID0gLTEsIHJpbmQgPSAtMTtcclxuICAgICAgICAgICAgICAgIGlmICh4ID09ICd4Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0T2YoZTEsIGUyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoczFbMF1beV0gPCBzMVsxXVt5XSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZCA9IGosIHJpbmQgPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZCA9IGksIHJpbmQgPSBqO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlZnRPZihlMSwgZTIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzMVswXVt5XSA8IHMxWzFdW3ldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5kID0gaSwgcmluZCA9IGo7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5kID0gaiwgcmluZCA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAobGluZCA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3MucHVzaChuZXcgdnBzY18xLkNvbnN0cmFpbnQodnNbbGluZF0sIHZzW3JpbmRdLCBnYXApKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc29sdmVyID0gbmV3IHZwc2NfMS5Tb2x2ZXIodnMsIGNzKTtcclxuICAgICAgICBzb2x2ZXIuc29sdmUoKTtcclxuICAgICAgICB2cy5mb3JFYWNoKGZ1bmN0aW9uICh2LCBpKSB7XHJcbiAgICAgICAgICAgIHZhciBzID0gc2VnbWVudHNbaV07XHJcbiAgICAgICAgICAgIHZhciBwb3MgPSB2LnBvc2l0aW9uKCk7XHJcbiAgICAgICAgICAgIHNbMF1beF0gPSBzWzFdW3hdID0gcG9zO1xyXG4gICAgICAgICAgICB2YXIgcm91dGUgPSByb3V0ZXNbcy5lZGdlaWRdO1xyXG4gICAgICAgICAgICBpZiAocy5pID4gMClcclxuICAgICAgICAgICAgICAgIHJvdXRlW3MuaSAtIDFdWzFdW3hdID0gcG9zO1xyXG4gICAgICAgICAgICBpZiAocy5pIDwgcm91dGUubGVuZ3RoIC0gMSlcclxuICAgICAgICAgICAgICAgIHJvdXRlW3MuaSArIDFdWzBdW3hdID0gcG9zO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEdyaWRSb3V0ZXIubnVkZ2VTZWdtZW50cyA9IGZ1bmN0aW9uIChyb3V0ZXMsIHgsIHksIGxlZnRPZiwgZ2FwKSB7XHJcbiAgICAgICAgdmFyIHZzZWdtZW50c2V0cyA9IEdyaWRSb3V0ZXIuZ2V0U2VnbWVudFNldHMocm91dGVzLCB4LCB5KTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZzZWdtZW50c2V0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgc3MgPSB2c2VnbWVudHNldHNbaV07XHJcbiAgICAgICAgICAgIHZhciBldmVudHMgPSBbXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzcy5zZWdtZW50cy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHMgPSBzcy5zZWdtZW50c1tqXTtcclxuICAgICAgICAgICAgICAgIGV2ZW50cy5wdXNoKHsgdHlwZTogMCwgczogcywgcG9zOiBNYXRoLm1pbihzWzBdW3ldLCBzWzFdW3ldKSB9KTtcclxuICAgICAgICAgICAgICAgIGV2ZW50cy5wdXNoKHsgdHlwZTogMSwgczogcywgcG9zOiBNYXRoLm1heChzWzBdW3ldLCBzWzFdW3ldKSB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBldmVudHMuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5wb3MgLSBiLnBvcyArIGEudHlwZSAtIGIudHlwZTsgfSk7XHJcbiAgICAgICAgICAgIHZhciBvcGVuID0gW107XHJcbiAgICAgICAgICAgIHZhciBvcGVuQ291bnQgPSAwO1xyXG4gICAgICAgICAgICBldmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGUudHlwZSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9wZW4ucHVzaChlLnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIG9wZW5Db3VudCsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3BlbkNvdW50LS07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAob3BlbkNvdW50ID09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBHcmlkUm91dGVyLm51ZGdlU2Vncyh4LCB5LCByb3V0ZXMsIG9wZW4sIGxlZnRPZiwgZ2FwKTtcclxuICAgICAgICAgICAgICAgICAgICBvcGVuID0gW107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBHcmlkUm91dGVyLnByb3RvdHlwZS5yb3V0ZUVkZ2VzID0gZnVuY3Rpb24gKGVkZ2VzLCBudWRnZUdhcCwgc291cmNlLCB0YXJnZXQpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciByb3V0ZVBhdGhzID0gZWRnZXMubWFwKGZ1bmN0aW9uIChlKSB7IHJldHVybiBfdGhpcy5yb3V0ZShzb3VyY2UoZSksIHRhcmdldChlKSk7IH0pO1xyXG4gICAgICAgIHZhciBvcmRlciA9IEdyaWRSb3V0ZXIub3JkZXJFZGdlcyhyb3V0ZVBhdGhzKTtcclxuICAgICAgICB2YXIgcm91dGVzID0gcm91dGVQYXRocy5tYXAoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIEdyaWRSb3V0ZXIubWFrZVNlZ21lbnRzKGUpOyB9KTtcclxuICAgICAgICBHcmlkUm91dGVyLm51ZGdlU2VnbWVudHMocm91dGVzLCAneCcsICd5Jywgb3JkZXIsIG51ZGdlR2FwKTtcclxuICAgICAgICBHcmlkUm91dGVyLm51ZGdlU2VnbWVudHMocm91dGVzLCAneScsICd4Jywgb3JkZXIsIG51ZGdlR2FwKTtcclxuICAgICAgICBHcmlkUm91dGVyLnVucmV2ZXJzZUVkZ2VzKHJvdXRlcywgcm91dGVQYXRocyk7XHJcbiAgICAgICAgcmV0dXJuIHJvdXRlcztcclxuICAgIH07XHJcbiAgICBHcmlkUm91dGVyLnVucmV2ZXJzZUVkZ2VzID0gZnVuY3Rpb24gKHJvdXRlcywgcm91dGVQYXRocykge1xyXG4gICAgICAgIHJvdXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChzZWdtZW50cywgaSkge1xyXG4gICAgICAgICAgICB2YXIgcGF0aCA9IHJvdXRlUGF0aHNbaV07XHJcbiAgICAgICAgICAgIGlmIChwYXRoLnJldmVyc2VkKSB7XHJcbiAgICAgICAgICAgICAgICBzZWdtZW50cy5yZXZlcnNlKCk7XHJcbiAgICAgICAgICAgICAgICBzZWdtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChzZWdtZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VnbWVudC5yZXZlcnNlKCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEdyaWRSb3V0ZXIuYW5nbGVCZXR3ZWVuMkxpbmVzID0gZnVuY3Rpb24gKGxpbmUxLCBsaW5lMikge1xyXG4gICAgICAgIHZhciBhbmdsZTEgPSBNYXRoLmF0YW4yKGxpbmUxWzBdLnkgLSBsaW5lMVsxXS55LCBsaW5lMVswXS54IC0gbGluZTFbMV0ueCk7XHJcbiAgICAgICAgdmFyIGFuZ2xlMiA9IE1hdGguYXRhbjIobGluZTJbMF0ueSAtIGxpbmUyWzFdLnksIGxpbmUyWzBdLnggLSBsaW5lMlsxXS54KTtcclxuICAgICAgICB2YXIgZGlmZiA9IGFuZ2xlMSAtIGFuZ2xlMjtcclxuICAgICAgICBpZiAoZGlmZiA+IE1hdGguUEkgfHwgZGlmZiA8IC1NYXRoLlBJKSB7XHJcbiAgICAgICAgICAgIGRpZmYgPSBhbmdsZTIgLSBhbmdsZTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkaWZmO1xyXG4gICAgfTtcclxuICAgIEdyaWRSb3V0ZXIuaXNMZWZ0ID0gZnVuY3Rpb24gKGEsIGIsIGMpIHtcclxuICAgICAgICByZXR1cm4gKChiLnggLSBhLngpICogKGMueSAtIGEueSkgLSAoYi55IC0gYS55KSAqIChjLnggLSBhLngpKSA8PSAwO1xyXG4gICAgfTtcclxuICAgIEdyaWRSb3V0ZXIuZ2V0T3JkZXIgPSBmdW5jdGlvbiAocGFpcnMpIHtcclxuICAgICAgICB2YXIgb3V0Z29pbmcgPSB7fTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhaXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBwID0gcGFpcnNbaV07XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3V0Z29pbmdbcC5sXSA9PT0gJ3VuZGVmaW5lZCcpXHJcbiAgICAgICAgICAgICAgICBvdXRnb2luZ1twLmxdID0ge307XHJcbiAgICAgICAgICAgIG91dGdvaW5nW3AubF1bcC5yXSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAobCwgcikgeyByZXR1cm4gdHlwZW9mIG91dGdvaW5nW2xdICE9PSAndW5kZWZpbmVkJyAmJiBvdXRnb2luZ1tsXVtyXTsgfTtcclxuICAgIH07XHJcbiAgICBHcmlkUm91dGVyLm9yZGVyRWRnZXMgPSBmdW5jdGlvbiAoZWRnZXMpIHtcclxuICAgICAgICB2YXIgZWRnZU9yZGVyID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGggLSAxOyBpKyspIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IGkgKyAxOyBqIDwgZWRnZXMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBlID0gZWRnZXNbaV0sIGYgPSBlZGdlc1tqXSwgbGNzID0gbmV3IExvbmdlc3RDb21tb25TdWJzZXF1ZW5jZShlLCBmKTtcclxuICAgICAgICAgICAgICAgIHZhciB1LCB2aSwgdmo7XHJcbiAgICAgICAgICAgICAgICBpZiAobGNzLmxlbmd0aCA9PT0gMClcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGlmIChsY3MucmV2ZXJzZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBmLnJldmVyc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICBmLnJldmVyc2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBsY3MgPSBuZXcgTG9uZ2VzdENvbW1vblN1YnNlcXVlbmNlKGUsIGYpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKChsY3Muc2kgPD0gMCB8fCBsY3MudGkgPD0gMCkgJiZcclxuICAgICAgICAgICAgICAgICAgICAobGNzLnNpICsgbGNzLmxlbmd0aCA+PSBlLmxlbmd0aCB8fCBsY3MudGkgKyBsY3MubGVuZ3RoID49IGYubGVuZ3RoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVkZ2VPcmRlci5wdXNoKHsgbDogaSwgcjogaiB9KTtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChsY3Muc2kgKyBsY3MubGVuZ3RoID49IGUubGVuZ3RoIHx8IGxjcy50aSArIGxjcy5sZW5ndGggPj0gZi5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICB1ID0gZVtsY3Muc2kgKyAxXTtcclxuICAgICAgICAgICAgICAgICAgICB2aiA9IGVbbGNzLnNpIC0gMV07XHJcbiAgICAgICAgICAgICAgICAgICAgdmkgPSBmW2xjcy50aSAtIDFdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdSA9IGVbbGNzLnNpICsgbGNzLmxlbmd0aCAtIDJdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZpID0gZVtsY3Muc2kgKyBsY3MubGVuZ3RoXTtcclxuICAgICAgICAgICAgICAgICAgICB2aiA9IGZbbGNzLnRpICsgbGNzLmxlbmd0aF07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoR3JpZFJvdXRlci5pc0xlZnQodSwgdmksIHZqKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVkZ2VPcmRlci5wdXNoKHsgbDogaiwgcjogaSB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGVkZ2VPcmRlci5wdXNoKHsgbDogaSwgcjogaiB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gR3JpZFJvdXRlci5nZXRPcmRlcihlZGdlT3JkZXIpO1xyXG4gICAgfTtcclxuICAgIEdyaWRSb3V0ZXIubWFrZVNlZ21lbnRzID0gZnVuY3Rpb24gKHBhdGgpIHtcclxuICAgICAgICBmdW5jdGlvbiBjb3B5UG9pbnQocCkge1xyXG4gICAgICAgICAgICByZXR1cm4geyB4OiBwLngsIHk6IHAueSB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgaXNTdHJhaWdodCA9IGZ1bmN0aW9uIChhLCBiLCBjKSB7IHJldHVybiBNYXRoLmFicygoYi54IC0gYS54KSAqIChjLnkgLSBhLnkpIC0gKGIueSAtIGEueSkgKiAoYy54IC0gYS54KSkgPCAwLjAwMTsgfTtcclxuICAgICAgICB2YXIgc2VnbWVudHMgPSBbXTtcclxuICAgICAgICB2YXIgYSA9IGNvcHlQb2ludChwYXRoWzBdKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGIgPSBjb3B5UG9pbnQocGF0aFtpXSksIGMgPSBpIDwgcGF0aC5sZW5ndGggLSAxID8gcGF0aFtpICsgMV0gOiBudWxsO1xyXG4gICAgICAgICAgICBpZiAoIWMgfHwgIWlzU3RyYWlnaHQoYSwgYiwgYykpIHtcclxuICAgICAgICAgICAgICAgIHNlZ21lbnRzLnB1c2goW2EsIGJdKTtcclxuICAgICAgICAgICAgICAgIGEgPSBiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzZWdtZW50cztcclxuICAgIH07XHJcbiAgICBHcmlkUm91dGVyLnByb3RvdHlwZS5yb3V0ZSA9IGZ1bmN0aW9uIChzLCB0KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgc291cmNlID0gdGhpcy5ub2Rlc1tzXSwgdGFyZ2V0ID0gdGhpcy5ub2Rlc1t0XTtcclxuICAgICAgICB0aGlzLm9ic3RhY2xlcyA9IHRoaXMuc2libGluZ09ic3RhY2xlcyhzb3VyY2UsIHRhcmdldCk7XHJcbiAgICAgICAgdmFyIG9ic3RhY2xlTG9va3VwID0ge307XHJcbiAgICAgICAgdGhpcy5vYnN0YWNsZXMuZm9yRWFjaChmdW5jdGlvbiAobykgeyByZXR1cm4gb2JzdGFjbGVMb29rdXBbby5pZF0gPSBvOyB9KTtcclxuICAgICAgICB0aGlzLnBhc3NhYmxlRWRnZXMgPSB0aGlzLmVkZ2VzLmZpbHRlcihmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICB2YXIgdSA9IF90aGlzLnZlcnRzW2Uuc291cmNlXSwgdiA9IF90aGlzLnZlcnRzW2UudGFyZ2V0XTtcclxuICAgICAgICAgICAgcmV0dXJuICEodS5ub2RlICYmIHUubm9kZS5pZCBpbiBvYnN0YWNsZUxvb2t1cFxyXG4gICAgICAgICAgICAgICAgfHwgdi5ub2RlICYmIHYubm9kZS5pZCBpbiBvYnN0YWNsZUxvb2t1cCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBzb3VyY2UucG9ydHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHUgPSBzb3VyY2UucG9ydHNbMF0uaWQ7XHJcbiAgICAgICAgICAgIHZhciB2ID0gc291cmNlLnBvcnRzW2ldLmlkO1xyXG4gICAgICAgICAgICB0aGlzLnBhc3NhYmxlRWRnZXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBzb3VyY2U6IHUsXHJcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IHYsXHJcbiAgICAgICAgICAgICAgICBsZW5ndGg6IDBcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdGFyZ2V0LnBvcnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciB1ID0gdGFyZ2V0LnBvcnRzWzBdLmlkO1xyXG4gICAgICAgICAgICB2YXIgdiA9IHRhcmdldC5wb3J0c1tpXS5pZDtcclxuICAgICAgICAgICAgdGhpcy5wYXNzYWJsZUVkZ2VzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgc291cmNlOiB1LFxyXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiB2LFxyXG4gICAgICAgICAgICAgICAgbGVuZ3RoOiAwXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZ2V0U291cmNlID0gZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGUuc291cmNlOyB9LCBnZXRUYXJnZXQgPSBmdW5jdGlvbiAoZSkgeyByZXR1cm4gZS50YXJnZXQ7IH0sIGdldExlbmd0aCA9IGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLmxlbmd0aDsgfTtcclxuICAgICAgICB2YXIgc2hvcnRlc3RQYXRoQ2FsY3VsYXRvciA9IG5ldyBzaG9ydGVzdHBhdGhzXzEuQ2FsY3VsYXRvcih0aGlzLnZlcnRzLmxlbmd0aCwgdGhpcy5wYXNzYWJsZUVkZ2VzLCBnZXRTb3VyY2UsIGdldFRhcmdldCwgZ2V0TGVuZ3RoKTtcclxuICAgICAgICB2YXIgYmVuZFBlbmFsdHkgPSBmdW5jdGlvbiAodSwgdiwgdykge1xyXG4gICAgICAgICAgICB2YXIgYSA9IF90aGlzLnZlcnRzW3VdLCBiID0gX3RoaXMudmVydHNbdl0sIGMgPSBfdGhpcy52ZXJ0c1t3XTtcclxuICAgICAgICAgICAgdmFyIGR4ID0gTWF0aC5hYnMoYy54IC0gYS54KSwgZHkgPSBNYXRoLmFicyhjLnkgLSBhLnkpO1xyXG4gICAgICAgICAgICBpZiAoYS5ub2RlID09PSBzb3VyY2UgJiYgYS5ub2RlID09PSBiLm5vZGUgfHwgYi5ub2RlID09PSB0YXJnZXQgJiYgYi5ub2RlID09PSBjLm5vZGUpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgcmV0dXJuIGR4ID4gMSAmJiBkeSA+IDEgPyAxMDAwIDogMDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciBzaG9ydGVzdFBhdGggPSBzaG9ydGVzdFBhdGhDYWxjdWxhdG9yLlBhdGhGcm9tTm9kZVRvTm9kZVdpdGhQcmV2Q29zdChzb3VyY2UucG9ydHNbMF0uaWQsIHRhcmdldC5wb3J0c1swXS5pZCwgYmVuZFBlbmFsdHkpO1xyXG4gICAgICAgIHZhciBwYXRoUG9pbnRzID0gc2hvcnRlc3RQYXRoLnJldmVyc2UoKS5tYXAoZnVuY3Rpb24gKHZpKSB7IHJldHVybiBfdGhpcy52ZXJ0c1t2aV07IH0pO1xyXG4gICAgICAgIHBhdGhQb2ludHMucHVzaCh0aGlzLm5vZGVzW3RhcmdldC5pZF0ucG9ydHNbMF0pO1xyXG4gICAgICAgIHJldHVybiBwYXRoUG9pbnRzLmZpbHRlcihmdW5jdGlvbiAodiwgaSkge1xyXG4gICAgICAgICAgICByZXR1cm4gIShpIDwgcGF0aFBvaW50cy5sZW5ndGggLSAxICYmIHBhdGhQb2ludHNbaSArIDFdLm5vZGUgPT09IHNvdXJjZSAmJiB2Lm5vZGUgPT09IHNvdXJjZVxyXG4gICAgICAgICAgICAgICAgfHwgaSA+IDAgJiYgdi5ub2RlID09PSB0YXJnZXQgJiYgcGF0aFBvaW50c1tpIC0gMV0ubm9kZSA9PT0gdGFyZ2V0KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBHcmlkUm91dGVyLmdldFJvdXRlUGF0aCA9IGZ1bmN0aW9uIChyb3V0ZSwgY29ybmVycmFkaXVzLCBhcnJvd3dpZHRoLCBhcnJvd2hlaWdodCkge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSB7XHJcbiAgICAgICAgICAgIHJvdXRlcGF0aDogJ00gJyArIHJvdXRlWzBdWzBdLnggKyAnICcgKyByb3V0ZVswXVswXS55ICsgJyAnLFxyXG4gICAgICAgICAgICBhcnJvd3BhdGg6ICcnXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAocm91dGUubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvdXRlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGkgPSByb3V0ZVtpXTtcclxuICAgICAgICAgICAgICAgIHZhciB4ID0gbGlbMV0ueCwgeSA9IGxpWzFdLnk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZHggPSB4IC0gbGlbMF0ueDtcclxuICAgICAgICAgICAgICAgIHZhciBkeSA9IHkgLSBsaVswXS55O1xyXG4gICAgICAgICAgICAgICAgaWYgKGkgPCByb3V0ZS5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKGR4KSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeCAtPSBkeCAvIE1hdGguYWJzKGR4KSAqIGNvcm5lcnJhZGl1cztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgLT0gZHkgLyBNYXRoLmFicyhkeSkgKiBjb3JuZXJyYWRpdXM7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5yb3V0ZXBhdGggKz0gJ0wgJyArIHggKyAnICcgKyB5ICsgJyAnO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBsID0gcm91dGVbaSArIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB4MCA9IGxbMF0ueCwgeTAgPSBsWzBdLnk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHgxID0gbFsxXS54O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB5MSA9IGxbMV0ueTtcclxuICAgICAgICAgICAgICAgICAgICBkeCA9IHgxIC0geDA7XHJcbiAgICAgICAgICAgICAgICAgICAgZHkgPSB5MSAtIHkwO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhbmdsZSA9IEdyaWRSb3V0ZXIuYW5nbGVCZXR3ZWVuMkxpbmVzKGxpLCBsKSA8IDAgPyAxIDogMDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgeDIsIHkyO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhkeCkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHgyID0geDAgKyBkeCAvIE1hdGguYWJzKGR4KSAqIGNvcm5lcnJhZGl1cztcclxuICAgICAgICAgICAgICAgICAgICAgICAgeTIgPSB5MDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHgyID0geDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHkyID0geTAgKyBkeSAvIE1hdGguYWJzKGR5KSAqIGNvcm5lcnJhZGl1cztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN4ID0gTWF0aC5hYnMoeDIgLSB4KTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY3kgPSBNYXRoLmFicyh5MiAtIHkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5yb3V0ZXBhdGggKz0gJ0EgJyArIGN4ICsgJyAnICsgY3kgKyAnIDAgMCAnICsgYW5nbGUgKyAnICcgKyB4MiArICcgJyArIHkyICsgJyAnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFycm93dGlwID0gW3gsIHldO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhcnJvd2Nvcm5lcjEsIGFycm93Y29ybmVyMjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoZHgpID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4IC09IGR4IC8gTWF0aC5hYnMoZHgpICogYXJyb3doZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycm93Y29ybmVyMSA9IFt4LCB5ICsgYXJyb3d3aWR0aF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycm93Y29ybmVyMiA9IFt4LCB5IC0gYXJyb3d3aWR0aF07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB5IC09IGR5IC8gTWF0aC5hYnMoZHkpICogYXJyb3doZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycm93Y29ybmVyMSA9IFt4ICsgYXJyb3d3aWR0aCwgeV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycm93Y29ybmVyMiA9IFt4IC0gYXJyb3d3aWR0aCwgeV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5yb3V0ZXBhdGggKz0gJ0wgJyArIHggKyAnICcgKyB5ICsgJyAnO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhcnJvd2hlaWdodCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFycm93cGF0aCA9ICdNICcgKyBhcnJvd3RpcFswXSArICcgJyArIGFycm93dGlwWzFdICsgJyBMICcgKyBhcnJvd2Nvcm5lcjFbMF0gKyAnICcgKyBhcnJvd2Nvcm5lcjFbMV1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgJyBMICcgKyBhcnJvd2Nvcm5lcjJbMF0gKyAnICcgKyBhcnJvd2Nvcm5lcjJbMV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgbGkgPSByb3V0ZVswXTtcclxuICAgICAgICAgICAgdmFyIHggPSBsaVsxXS54LCB5ID0gbGlbMV0ueTtcclxuICAgICAgICAgICAgdmFyIGR4ID0geCAtIGxpWzBdLng7XHJcbiAgICAgICAgICAgIHZhciBkeSA9IHkgLSBsaVswXS55O1xyXG4gICAgICAgICAgICB2YXIgYXJyb3d0aXAgPSBbeCwgeV07XHJcbiAgICAgICAgICAgIHZhciBhcnJvd2Nvcm5lcjEsIGFycm93Y29ybmVyMjtcclxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKGR4KSA+IDApIHtcclxuICAgICAgICAgICAgICAgIHggLT0gZHggLyBNYXRoLmFicyhkeCkgKiBhcnJvd2hlaWdodDtcclxuICAgICAgICAgICAgICAgIGFycm93Y29ybmVyMSA9IFt4LCB5ICsgYXJyb3d3aWR0aF07XHJcbiAgICAgICAgICAgICAgICBhcnJvd2Nvcm5lcjIgPSBbeCwgeSAtIGFycm93d2lkdGhdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgeSAtPSBkeSAvIE1hdGguYWJzKGR5KSAqIGFycm93aGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgYXJyb3djb3JuZXIxID0gW3ggKyBhcnJvd3dpZHRoLCB5XTtcclxuICAgICAgICAgICAgICAgIGFycm93Y29ybmVyMiA9IFt4IC0gYXJyb3d3aWR0aCwgeV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVzdWx0LnJvdXRlcGF0aCArPSAnTCAnICsgeCArICcgJyArIHkgKyAnICc7XHJcbiAgICAgICAgICAgIGlmIChhcnJvd2hlaWdodCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5hcnJvd3BhdGggPSAnTSAnICsgYXJyb3d0aXBbMF0gKyAnICcgKyBhcnJvd3RpcFsxXSArICcgTCAnICsgYXJyb3djb3JuZXIxWzBdICsgJyAnICsgYXJyb3djb3JuZXIxWzFdXHJcbiAgICAgICAgICAgICAgICAgICAgKyAnIEwgJyArIGFycm93Y29ybmVyMlswXSArICcgJyArIGFycm93Y29ybmVyMlsxXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBHcmlkUm91dGVyO1xyXG59KCkpO1xyXG5leHBvcnRzLkdyaWRSb3V0ZXIgPSBHcmlkUm91dGVyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1ncmlkcm91dGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBwYWNraW5nT3B0aW9ucyA9IHtcclxuICAgIFBBRERJTkc6IDEwLFxyXG4gICAgR09MREVOX1NFQ1RJT046ICgxICsgTWF0aC5zcXJ0KDUpKSAvIDIsXHJcbiAgICBGTE9BVF9FUFNJTE9OOiAwLjAwMDEsXHJcbiAgICBNQVhfSU5FUkFUSU9OUzogMTAwXHJcbn07XHJcbmZ1bmN0aW9uIGFwcGx5UGFja2luZyhncmFwaHMsIHcsIGgsIG5vZGVfc2l6ZSwgZGVzaXJlZF9yYXRpbykge1xyXG4gICAgaWYgKGRlc2lyZWRfcmF0aW8gPT09IHZvaWQgMCkgeyBkZXNpcmVkX3JhdGlvID0gMTsgfVxyXG4gICAgdmFyIGluaXRfeCA9IDAsIGluaXRfeSA9IDAsIHN2Z193aWR0aCA9IHcsIHN2Z19oZWlnaHQgPSBoLCBkZXNpcmVkX3JhdGlvID0gdHlwZW9mIGRlc2lyZWRfcmF0aW8gIT09ICd1bmRlZmluZWQnID8gZGVzaXJlZF9yYXRpbyA6IDEsIG5vZGVfc2l6ZSA9IHR5cGVvZiBub2RlX3NpemUgIT09ICd1bmRlZmluZWQnID8gbm9kZV9zaXplIDogMCwgcmVhbF93aWR0aCA9IDAsIHJlYWxfaGVpZ2h0ID0gMCwgbWluX3dpZHRoID0gMCwgZ2xvYmFsX2JvdHRvbSA9IDAsIGxpbmUgPSBbXTtcclxuICAgIGlmIChncmFwaHMubGVuZ3RoID09IDApXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgY2FsY3VsYXRlX2JiKGdyYXBocyk7XHJcbiAgICBhcHBseShncmFwaHMsIGRlc2lyZWRfcmF0aW8pO1xyXG4gICAgcHV0X25vZGVzX3RvX3JpZ2h0X3Bvc2l0aW9ucyhncmFwaHMpO1xyXG4gICAgZnVuY3Rpb24gY2FsY3VsYXRlX2JiKGdyYXBocykge1xyXG4gICAgICAgIGdyYXBocy5mb3JFYWNoKGZ1bmN0aW9uIChnKSB7XHJcbiAgICAgICAgICAgIGNhbGN1bGF0ZV9zaW5nbGVfYmIoZyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgZnVuY3Rpb24gY2FsY3VsYXRlX3NpbmdsZV9iYihncmFwaCkge1xyXG4gICAgICAgICAgICB2YXIgbWluX3ggPSBOdW1iZXIuTUFYX1ZBTFVFLCBtaW5feSA9IE51bWJlci5NQVhfVkFMVUUsIG1heF94ID0gMCwgbWF4X3kgPSAwO1xyXG4gICAgICAgICAgICBncmFwaC5hcnJheS5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdyA9IHR5cGVvZiB2LndpZHRoICE9PSAndW5kZWZpbmVkJyA/IHYud2lkdGggOiBub2RlX3NpemU7XHJcbiAgICAgICAgICAgICAgICB2YXIgaCA9IHR5cGVvZiB2LmhlaWdodCAhPT0gJ3VuZGVmaW5lZCcgPyB2LmhlaWdodCA6IG5vZGVfc2l6ZTtcclxuICAgICAgICAgICAgICAgIHcgLz0gMjtcclxuICAgICAgICAgICAgICAgIGggLz0gMjtcclxuICAgICAgICAgICAgICAgIG1heF94ID0gTWF0aC5tYXgodi54ICsgdywgbWF4X3gpO1xyXG4gICAgICAgICAgICAgICAgbWluX3ggPSBNYXRoLm1pbih2LnggLSB3LCBtaW5feCk7XHJcbiAgICAgICAgICAgICAgICBtYXhfeSA9IE1hdGgubWF4KHYueSArIGgsIG1heF95KTtcclxuICAgICAgICAgICAgICAgIG1pbl95ID0gTWF0aC5taW4odi55IC0gaCwgbWluX3kpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgZ3JhcGgud2lkdGggPSBtYXhfeCAtIG1pbl94O1xyXG4gICAgICAgICAgICBncmFwaC5oZWlnaHQgPSBtYXhfeSAtIG1pbl95O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHB1dF9ub2Rlc190b19yaWdodF9wb3NpdGlvbnMoZ3JhcGhzKSB7XHJcbiAgICAgICAgZ3JhcGhzLmZvckVhY2goZnVuY3Rpb24gKGcpIHtcclxuICAgICAgICAgICAgdmFyIGNlbnRlciA9IHsgeDogMCwgeTogMCB9O1xyXG4gICAgICAgICAgICBnLmFycmF5LmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICAgICAgICAgIGNlbnRlci54ICs9IG5vZGUueDtcclxuICAgICAgICAgICAgICAgIGNlbnRlci55ICs9IG5vZGUueTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNlbnRlci54IC89IGcuYXJyYXkubGVuZ3RoO1xyXG4gICAgICAgICAgICBjZW50ZXIueSAvPSBnLmFycmF5Lmxlbmd0aDtcclxuICAgICAgICAgICAgdmFyIGNvcm5lciA9IHsgeDogY2VudGVyLnggLSBnLndpZHRoIC8gMiwgeTogY2VudGVyLnkgLSBnLmhlaWdodCAvIDIgfTtcclxuICAgICAgICAgICAgdmFyIG9mZnNldCA9IHsgeDogZy54IC0gY29ybmVyLnggKyBzdmdfd2lkdGggLyAyIC0gcmVhbF93aWR0aCAvIDIsIHk6IGcueSAtIGNvcm5lci55ICsgc3ZnX2hlaWdodCAvIDIgLSByZWFsX2hlaWdodCAvIDIgfTtcclxuICAgICAgICAgICAgZy5hcnJheS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgICAgICAgICBub2RlLnggKz0gb2Zmc2V0Lng7XHJcbiAgICAgICAgICAgICAgICBub2RlLnkgKz0gb2Zmc2V0Lnk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYXBwbHkoZGF0YSwgZGVzaXJlZF9yYXRpbykge1xyXG4gICAgICAgIHZhciBjdXJyX2Jlc3RfZiA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcclxuICAgICAgICB2YXIgY3Vycl9iZXN0ID0gMDtcclxuICAgICAgICBkYXRhLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGIuaGVpZ2h0IC0gYS5oZWlnaHQ7IH0pO1xyXG4gICAgICAgIG1pbl93aWR0aCA9IGRhdGEucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhLndpZHRoIDwgYi53aWR0aCA/IGEud2lkdGggOiBiLndpZHRoO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciBsZWZ0ID0geDEgPSBtaW5fd2lkdGg7XHJcbiAgICAgICAgdmFyIHJpZ2h0ID0geDIgPSBnZXRfZW50aXJlX3dpZHRoKGRhdGEpO1xyXG4gICAgICAgIHZhciBpdGVyYXRpb25Db3VudGVyID0gMDtcclxuICAgICAgICB2YXIgZl94MSA9IE51bWJlci5NQVhfVkFMVUU7XHJcbiAgICAgICAgdmFyIGZfeDIgPSBOdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgICAgIHZhciBmbGFnID0gLTE7XHJcbiAgICAgICAgdmFyIGR4ID0gTnVtYmVyLk1BWF9WQUxVRTtcclxuICAgICAgICB2YXIgZGYgPSBOdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgICAgIHdoaWxlICgoZHggPiBtaW5fd2lkdGgpIHx8IGRmID4gcGFja2luZ09wdGlvbnMuRkxPQVRfRVBTSUxPTikge1xyXG4gICAgICAgICAgICBpZiAoZmxhZyAhPSAxKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgeDEgPSByaWdodCAtIChyaWdodCAtIGxlZnQpIC8gcGFja2luZ09wdGlvbnMuR09MREVOX1NFQ1RJT047XHJcbiAgICAgICAgICAgICAgICB2YXIgZl94MSA9IHN0ZXAoZGF0YSwgeDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChmbGFnICE9IDApIHtcclxuICAgICAgICAgICAgICAgIHZhciB4MiA9IGxlZnQgKyAocmlnaHQgLSBsZWZ0KSAvIHBhY2tpbmdPcHRpb25zLkdPTERFTl9TRUNUSU9OO1xyXG4gICAgICAgICAgICAgICAgdmFyIGZfeDIgPSBzdGVwKGRhdGEsIHgyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkeCA9IE1hdGguYWJzKHgxIC0geDIpO1xyXG4gICAgICAgICAgICBkZiA9IE1hdGguYWJzKGZfeDEgLSBmX3gyKTtcclxuICAgICAgICAgICAgaWYgKGZfeDEgPCBjdXJyX2Jlc3RfZikge1xyXG4gICAgICAgICAgICAgICAgY3Vycl9iZXN0X2YgPSBmX3gxO1xyXG4gICAgICAgICAgICAgICAgY3Vycl9iZXN0ID0geDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGZfeDIgPCBjdXJyX2Jlc3RfZikge1xyXG4gICAgICAgICAgICAgICAgY3Vycl9iZXN0X2YgPSBmX3gyO1xyXG4gICAgICAgICAgICAgICAgY3Vycl9iZXN0ID0geDI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGZfeDEgPiBmX3gyKSB7XHJcbiAgICAgICAgICAgICAgICBsZWZ0ID0geDE7XHJcbiAgICAgICAgICAgICAgICB4MSA9IHgyO1xyXG4gICAgICAgICAgICAgICAgZl94MSA9IGZfeDI7XHJcbiAgICAgICAgICAgICAgICBmbGFnID0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJpZ2h0ID0geDI7XHJcbiAgICAgICAgICAgICAgICB4MiA9IHgxO1xyXG4gICAgICAgICAgICAgICAgZl94MiA9IGZfeDE7XHJcbiAgICAgICAgICAgICAgICBmbGFnID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaXRlcmF0aW9uQ291bnRlcisrID4gMTAwKSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBzdGVwKGRhdGEsIGN1cnJfYmVzdCk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKGRhdGEsIG1heF93aWR0aCkge1xyXG4gICAgICAgIGxpbmUgPSBbXTtcclxuICAgICAgICByZWFsX3dpZHRoID0gMDtcclxuICAgICAgICByZWFsX2hlaWdodCA9IDA7XHJcbiAgICAgICAgZ2xvYmFsX2JvdHRvbSA9IGluaXRfeTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIG8gPSBkYXRhW2ldO1xyXG4gICAgICAgICAgICBwdXRfcmVjdChvLCBtYXhfd2lkdGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gTWF0aC5hYnMoZ2V0X3JlYWxfcmF0aW8oKSAtIGRlc2lyZWRfcmF0aW8pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcHV0X3JlY3QocmVjdCwgbWF4X3dpZHRoKSB7XHJcbiAgICAgICAgdmFyIHBhcmVudCA9IHVuZGVmaW5lZDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKChsaW5lW2ldLnNwYWNlX2xlZnQgPj0gcmVjdC5oZWlnaHQpICYmIChsaW5lW2ldLnggKyBsaW5lW2ldLndpZHRoICsgcmVjdC53aWR0aCArIHBhY2tpbmdPcHRpb25zLlBBRERJTkcgLSBtYXhfd2lkdGgpIDw9IHBhY2tpbmdPcHRpb25zLkZMT0FUX0VQU0lMT04pIHtcclxuICAgICAgICAgICAgICAgIHBhcmVudCA9IGxpbmVbaV07XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBsaW5lLnB1c2gocmVjdCk7XHJcbiAgICAgICAgaWYgKHBhcmVudCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJlY3QueCA9IHBhcmVudC54ICsgcGFyZW50LndpZHRoICsgcGFja2luZ09wdGlvbnMuUEFERElORztcclxuICAgICAgICAgICAgcmVjdC55ID0gcGFyZW50LmJvdHRvbTtcclxuICAgICAgICAgICAgcmVjdC5zcGFjZV9sZWZ0ID0gcmVjdC5oZWlnaHQ7XHJcbiAgICAgICAgICAgIHJlY3QuYm90dG9tID0gcmVjdC55O1xyXG4gICAgICAgICAgICBwYXJlbnQuc3BhY2VfbGVmdCAtPSByZWN0LmhlaWdodCArIHBhY2tpbmdPcHRpb25zLlBBRERJTkc7XHJcbiAgICAgICAgICAgIHBhcmVudC5ib3R0b20gKz0gcmVjdC5oZWlnaHQgKyBwYWNraW5nT3B0aW9ucy5QQURESU5HO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmVjdC55ID0gZ2xvYmFsX2JvdHRvbTtcclxuICAgICAgICAgICAgZ2xvYmFsX2JvdHRvbSArPSByZWN0LmhlaWdodCArIHBhY2tpbmdPcHRpb25zLlBBRERJTkc7XHJcbiAgICAgICAgICAgIHJlY3QueCA9IGluaXRfeDtcclxuICAgICAgICAgICAgcmVjdC5ib3R0b20gPSByZWN0Lnk7XHJcbiAgICAgICAgICAgIHJlY3Quc3BhY2VfbGVmdCA9IHJlY3QuaGVpZ2h0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmVjdC55ICsgcmVjdC5oZWlnaHQgLSByZWFsX2hlaWdodCA+IC1wYWNraW5nT3B0aW9ucy5GTE9BVF9FUFNJTE9OKVxyXG4gICAgICAgICAgICByZWFsX2hlaWdodCA9IHJlY3QueSArIHJlY3QuaGVpZ2h0IC0gaW5pdF95O1xyXG4gICAgICAgIGlmIChyZWN0LnggKyByZWN0LndpZHRoIC0gcmVhbF93aWR0aCA+IC1wYWNraW5nT3B0aW9ucy5GTE9BVF9FUFNJTE9OKVxyXG4gICAgICAgICAgICByZWFsX3dpZHRoID0gcmVjdC54ICsgcmVjdC53aWR0aCAtIGluaXRfeDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIGZ1bmN0aW9uIGdldF9lbnRpcmVfd2lkdGgoZGF0YSkge1xyXG4gICAgICAgIHZhciB3aWR0aCA9IDA7XHJcbiAgICAgICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7IHJldHVybiB3aWR0aCArPSBkLndpZHRoICsgcGFja2luZ09wdGlvbnMuUEFERElORzsgfSk7XHJcbiAgICAgICAgcmV0dXJuIHdpZHRoO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZ2V0X3JlYWxfcmF0aW8oKSB7XHJcbiAgICAgICAgcmV0dXJuIChyZWFsX3dpZHRoIC8gcmVhbF9oZWlnaHQpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuYXBwbHlQYWNraW5nID0gYXBwbHlQYWNraW5nO1xyXG5mdW5jdGlvbiBzZXBhcmF0ZUdyYXBocyhub2RlcywgbGlua3MpIHtcclxuICAgIHZhciBtYXJrcyA9IHt9O1xyXG4gICAgdmFyIHdheXMgPSB7fTtcclxuICAgIHZhciBncmFwaHMgPSBbXTtcclxuICAgIHZhciBjbHVzdGVycyA9IDA7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmtzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdmFyIGxpbmsgPSBsaW5rc1tpXTtcclxuICAgICAgICB2YXIgbjEgPSBsaW5rLnNvdXJjZTtcclxuICAgICAgICB2YXIgbjIgPSBsaW5rLnRhcmdldDtcclxuICAgICAgICBpZiAod2F5c1tuMS5pbmRleF0pXHJcbiAgICAgICAgICAgIHdheXNbbjEuaW5kZXhdLnB1c2gobjIpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgd2F5c1tuMS5pbmRleF0gPSBbbjJdO1xyXG4gICAgICAgIGlmICh3YXlzW24yLmluZGV4XSlcclxuICAgICAgICAgICAgd2F5c1tuMi5pbmRleF0ucHVzaChuMSk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB3YXlzW24yLmluZGV4XSA9IFtuMV07XHJcbiAgICB9XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcclxuICAgICAgICBpZiAobWFya3Nbbm9kZS5pbmRleF0pXHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIGV4cGxvcmVfbm9kZShub2RlLCB0cnVlKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGV4cGxvcmVfbm9kZShuLCBpc19uZXcpIHtcclxuICAgICAgICBpZiAobWFya3Nbbi5pbmRleF0gIT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIGlmIChpc19uZXcpIHtcclxuICAgICAgICAgICAgY2x1c3RlcnMrKztcclxuICAgICAgICAgICAgZ3JhcGhzLnB1c2goeyBhcnJheTogW10gfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1hcmtzW24uaW5kZXhdID0gY2x1c3RlcnM7XHJcbiAgICAgICAgZ3JhcGhzW2NsdXN0ZXJzIC0gMV0uYXJyYXkucHVzaChuKTtcclxuICAgICAgICB2YXIgYWRqYWNlbnQgPSB3YXlzW24uaW5kZXhdO1xyXG4gICAgICAgIGlmICghYWRqYWNlbnQpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGFkamFjZW50Lmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgIGV4cGxvcmVfbm9kZShhZGphY2VudFtqXSwgZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBncmFwaHM7XHJcbn1cclxuZXhwb3J0cy5zZXBhcmF0ZUdyYXBocyA9IHNlcGFyYXRlR3JhcGhzO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1oYW5kbGVkaXNjb25uZWN0ZWQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHBvd2VyZ3JhcGggPSByZXF1aXJlKFwiLi9wb3dlcmdyYXBoXCIpO1xyXG52YXIgbGlua2xlbmd0aHNfMSA9IHJlcXVpcmUoXCIuL2xpbmtsZW5ndGhzXCIpO1xyXG52YXIgZGVzY2VudF8xID0gcmVxdWlyZShcIi4vZGVzY2VudFwiKTtcclxudmFyIHJlY3RhbmdsZV8xID0gcmVxdWlyZShcIi4vcmVjdGFuZ2xlXCIpO1xyXG52YXIgc2hvcnRlc3RwYXRoc18xID0gcmVxdWlyZShcIi4vc2hvcnRlc3RwYXRoc1wiKTtcclxudmFyIGdlb21fMSA9IHJlcXVpcmUoXCIuL2dlb21cIik7XHJcbnZhciBoYW5kbGVkaXNjb25uZWN0ZWRfMSA9IHJlcXVpcmUoXCIuL2hhbmRsZWRpc2Nvbm5lY3RlZFwiKTtcclxudmFyIEV2ZW50VHlwZTtcclxuKGZ1bmN0aW9uIChFdmVudFR5cGUpIHtcclxuICAgIEV2ZW50VHlwZVtFdmVudFR5cGVbXCJzdGFydFwiXSA9IDBdID0gXCJzdGFydFwiO1xyXG4gICAgRXZlbnRUeXBlW0V2ZW50VHlwZVtcInRpY2tcIl0gPSAxXSA9IFwidGlja1wiO1xyXG4gICAgRXZlbnRUeXBlW0V2ZW50VHlwZVtcImVuZFwiXSA9IDJdID0gXCJlbmRcIjtcclxufSkoRXZlbnRUeXBlID0gZXhwb3J0cy5FdmVudFR5cGUgfHwgKGV4cG9ydHMuRXZlbnRUeXBlID0ge30pKTtcclxuO1xyXG5mdW5jdGlvbiBpc0dyb3VwKGcpIHtcclxuICAgIHJldHVybiB0eXBlb2YgZy5sZWF2ZXMgIT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBnLmdyb3VwcyAhPT0gJ3VuZGVmaW5lZCc7XHJcbn1cclxudmFyIExheW91dCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBMYXlvdXQoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLl9jYW52YXNTaXplID0gWzEsIDFdO1xyXG4gICAgICAgIHRoaXMuX2xpbmtEaXN0YW5jZSA9IDIwO1xyXG4gICAgICAgIHRoaXMuX2RlZmF1bHROb2RlU2l6ZSA9IDEwO1xyXG4gICAgICAgIHRoaXMuX2xpbmtMZW5ndGhDYWxjdWxhdG9yID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9saW5rVHlwZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fYXZvaWRPdmVybGFwcyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2hhbmRsZURpc2Nvbm5lY3RlZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5fcnVubmluZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX25vZGVzID0gW107XHJcbiAgICAgICAgdGhpcy5fZ3JvdXBzID0gW107XHJcbiAgICAgICAgdGhpcy5fcm9vdEdyb3VwID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9saW5rcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX2NvbnN0cmFpbnRzID0gW107XHJcbiAgICAgICAgdGhpcy5fZGlzdGFuY2VNYXRyaXggPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX2Rlc2NlbnQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX2RpcmVjdGVkTGlua0NvbnN0cmFpbnRzID0gbnVsbDtcclxuICAgICAgICB0aGlzLl90aHJlc2hvbGQgPSAwLjAxO1xyXG4gICAgICAgIHRoaXMuX3Zpc2liaWxpdHlHcmFwaCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fZ3JvdXBDb21wYWN0bmVzcyA9IDFlLTY7XHJcbiAgICAgICAgdGhpcy5ldmVudCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5saW5rQWNjZXNzb3IgPSB7XHJcbiAgICAgICAgICAgIGdldFNvdXJjZUluZGV4OiBMYXlvdXQuZ2V0U291cmNlSW5kZXgsXHJcbiAgICAgICAgICAgIGdldFRhcmdldEluZGV4OiBMYXlvdXQuZ2V0VGFyZ2V0SW5kZXgsXHJcbiAgICAgICAgICAgIHNldExlbmd0aDogTGF5b3V0LnNldExpbmtMZW5ndGgsXHJcbiAgICAgICAgICAgIGdldFR5cGU6IGZ1bmN0aW9uIChsKSB7IHJldHVybiB0eXBlb2YgX3RoaXMuX2xpbmtUeXBlID09PSBcImZ1bmN0aW9uXCIgPyBfdGhpcy5fbGlua1R5cGUobCkgOiAwOyB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIExheW91dC5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZSwgbGlzdGVuZXIpIHtcclxuICAgICAgICBpZiAoIXRoaXMuZXZlbnQpXHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnQgPSB7fTtcclxuICAgICAgICBpZiAodHlwZW9mIGUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRbRXZlbnRUeXBlW2VdXSA9IGxpc3RlbmVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5ldmVudFtlXSA9IGxpc3RlbmVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICBMYXlvdXQucHJvdG90eXBlLnRyaWdnZXIgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIGlmICh0aGlzLmV2ZW50ICYmIHR5cGVvZiB0aGlzLmV2ZW50W2UudHlwZV0gIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRbZS50eXBlXShlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTGF5b3V0LnByb3RvdHlwZS5raWNrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHdoaWxlICghdGhpcy50aWNrKCkpXHJcbiAgICAgICAgICAgIDtcclxuICAgIH07XHJcbiAgICBMYXlvdXQucHJvdG90eXBlLnRpY2sgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2FscGhhIDwgdGhpcy5fdGhyZXNob2xkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3J1bm5pbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKHsgdHlwZTogRXZlbnRUeXBlLmVuZCwgYWxwaGE6IHRoaXMuX2FscGhhID0gMCwgc3RyZXNzOiB0aGlzLl9sYXN0U3RyZXNzIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG4gPSB0aGlzLl9ub2Rlcy5sZW5ndGgsIG0gPSB0aGlzLl9saW5rcy5sZW5ndGg7XHJcbiAgICAgICAgdmFyIG8sIGk7XHJcbiAgICAgICAgdGhpcy5fZGVzY2VudC5sb2Nrcy5jbGVhcigpO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcclxuICAgICAgICAgICAgbyA9IHRoaXMuX25vZGVzW2ldO1xyXG4gICAgICAgICAgICBpZiAoby5maXhlZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvLnB4ID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2Ygby5weSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBvLnB4ID0gby54O1xyXG4gICAgICAgICAgICAgICAgICAgIG8ucHkgPSBvLnk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgcCA9IFtvLnB4LCBvLnB5XTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2Rlc2NlbnQubG9ja3MuYWRkKGksIHApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzMSA9IHRoaXMuX2Rlc2NlbnQucnVuZ2VLdXR0YSgpO1xyXG4gICAgICAgIGlmIChzMSA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLl9hbHBoYSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB0aGlzLl9sYXN0U3RyZXNzICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICB0aGlzLl9hbHBoYSA9IHMxO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9sYXN0U3RyZXNzID0gczE7XHJcbiAgICAgICAgdGhpcy51cGRhdGVOb2RlUG9zaXRpb25zKCk7XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyKHsgdHlwZTogRXZlbnRUeXBlLnRpY2ssIGFscGhhOiB0aGlzLl9hbHBoYSwgc3RyZXNzOiB0aGlzLl9sYXN0U3RyZXNzIH0pO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbiAgICBMYXlvdXQucHJvdG90eXBlLnVwZGF0ZU5vZGVQb3NpdGlvbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHggPSB0aGlzLl9kZXNjZW50LnhbMF0sIHkgPSB0aGlzLl9kZXNjZW50LnhbMV07XHJcbiAgICAgICAgdmFyIG8sIGkgPSB0aGlzLl9ub2Rlcy5sZW5ndGg7XHJcbiAgICAgICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgICAgICBvID0gdGhpcy5fbm9kZXNbaV07XHJcbiAgICAgICAgICAgIG8ueCA9IHhbaV07XHJcbiAgICAgICAgICAgIG8ueSA9IHlbaV07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIExheW91dC5wcm90b3R5cGUubm9kZXMgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIGlmICghdikge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fbm9kZXMubGVuZ3RoID09PSAwICYmIHRoaXMuX2xpbmtzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHZhciBuID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xpbmtzLmZvckVhY2goZnVuY3Rpb24gKGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBuID0gTWF0aC5tYXgobiwgbC5zb3VyY2UsIGwudGFyZ2V0KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbm9kZXMgPSBuZXcgQXJyYXkoKytuKTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbm9kZXNbaV0gPSB7fTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbm9kZXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX25vZGVzID0gdjtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICBMYXlvdXQucHJvdG90eXBlLmdyb3VwcyA9IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAoIXgpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ncm91cHM7XHJcbiAgICAgICAgdGhpcy5fZ3JvdXBzID0geDtcclxuICAgICAgICB0aGlzLl9yb290R3JvdXAgPSB7fTtcclxuICAgICAgICB0aGlzLl9ncm91cHMuZm9yRWFjaChmdW5jdGlvbiAoZykge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGcucGFkZGluZyA9PT0gXCJ1bmRlZmluZWRcIilcclxuICAgICAgICAgICAgICAgIGcucGFkZGluZyA9IDE7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZy5sZWF2ZXMgIT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICAgICAgICAgICAgIGcubGVhdmVzLmZvckVhY2goZnVuY3Rpb24gKHYsIGkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHYgPT09ICdudW1iZXInKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoZy5sZWF2ZXNbaV0gPSBfdGhpcy5fbm9kZXNbdl0pLnBhcmVudCA9IGc7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGcuZ3JvdXBzICE9PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgICAgICAgICBnLmdyb3Vwcy5mb3JFYWNoKGZ1bmN0aW9uIChnaSwgaSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZ2kgPT09ICdudW1iZXInKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoZy5ncm91cHNbaV0gPSBfdGhpcy5fZ3JvdXBzW2dpXSkucGFyZW50ID0gZztcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fcm9vdEdyb3VwLmxlYXZlcyA9IHRoaXMuX25vZGVzLmZpbHRlcihmdW5jdGlvbiAodikgeyByZXR1cm4gdHlwZW9mIHYucGFyZW50ID09PSAndW5kZWZpbmVkJzsgfSk7XHJcbiAgICAgICAgdGhpcy5fcm9vdEdyb3VwLmdyb3VwcyA9IHRoaXMuX2dyb3Vwcy5maWx0ZXIoZnVuY3Rpb24gKGcpIHsgcmV0dXJuIHR5cGVvZiBnLnBhcmVudCA9PT0gJ3VuZGVmaW5lZCc7IH0pO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIExheW91dC5wcm90b3R5cGUucG93ZXJHcmFwaEdyb3VwcyA9IGZ1bmN0aW9uIChmKSB7XHJcbiAgICAgICAgdmFyIGcgPSBwb3dlcmdyYXBoLmdldEdyb3Vwcyh0aGlzLl9ub2RlcywgdGhpcy5fbGlua3MsIHRoaXMubGlua0FjY2Vzc29yLCB0aGlzLl9yb290R3JvdXApO1xyXG4gICAgICAgIHRoaXMuZ3JvdXBzKGcuZ3JvdXBzKTtcclxuICAgICAgICBmKGcpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIExheW91dC5wcm90b3R5cGUuYXZvaWRPdmVybGFwcyA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYXZvaWRPdmVybGFwcztcclxuICAgICAgICB0aGlzLl9hdm9pZE92ZXJsYXBzID0gdjtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICBMYXlvdXQucHJvdG90eXBlLmhhbmRsZURpc2Nvbm5lY3RlZCA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faGFuZGxlRGlzY29ubmVjdGVkO1xyXG4gICAgICAgIHRoaXMuX2hhbmRsZURpc2Nvbm5lY3RlZCA9IHY7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgTGF5b3V0LnByb3RvdHlwZS5mbG93TGF5b3V0ID0gZnVuY3Rpb24gKGF4aXMsIG1pblNlcGFyYXRpb24pIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpXHJcbiAgICAgICAgICAgIGF4aXMgPSAneSc7XHJcbiAgICAgICAgdGhpcy5fZGlyZWN0ZWRMaW5rQ29uc3RyYWludHMgPSB7XHJcbiAgICAgICAgICAgIGF4aXM6IGF4aXMsXHJcbiAgICAgICAgICAgIGdldE1pblNlcGFyYXRpb246IHR5cGVvZiBtaW5TZXBhcmF0aW9uID09PSAnbnVtYmVyJyA/IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1pblNlcGFyYXRpb247IH0gOiBtaW5TZXBhcmF0aW9uXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICBMYXlvdXQucHJvdG90eXBlLmxpbmtzID0gZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9saW5rcztcclxuICAgICAgICB0aGlzLl9saW5rcyA9IHg7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgTGF5b3V0LnByb3RvdHlwZS5jb25zdHJhaW50cyA9IGZ1bmN0aW9uIChjKSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29uc3RyYWludHM7XHJcbiAgICAgICAgdGhpcy5fY29uc3RyYWludHMgPSBjO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIExheW91dC5wcm90b3R5cGUuZGlzdGFuY2VNYXRyaXggPSBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aClcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc3RhbmNlTWF0cml4O1xyXG4gICAgICAgIHRoaXMuX2Rpc3RhbmNlTWF0cml4ID0gZDtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICBMYXlvdXQucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgIGlmICgheClcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhbnZhc1NpemU7XHJcbiAgICAgICAgdGhpcy5fY2FudmFzU2l6ZSA9IHg7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgTGF5b3V0LnByb3RvdHlwZS5kZWZhdWx0Tm9kZVNpemUgPSBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgIGlmICgheClcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZmF1bHROb2RlU2l6ZTtcclxuICAgICAgICB0aGlzLl9kZWZhdWx0Tm9kZVNpemUgPSB4O1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIExheW91dC5wcm90b3R5cGUuZ3JvdXBDb21wYWN0bmVzcyA9IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgaWYgKCF4KVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ3JvdXBDb21wYWN0bmVzcztcclxuICAgICAgICB0aGlzLl9ncm91cENvbXBhY3RuZXNzID0geDtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICBMYXlvdXQucHJvdG90eXBlLmxpbmtEaXN0YW5jZSA9IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgaWYgKCF4KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9saW5rRGlzdGFuY2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2xpbmtEaXN0YW5jZSA9IHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCIgPyB4IDogK3g7XHJcbiAgICAgICAgdGhpcy5fbGlua0xlbmd0aENhbGN1bGF0b3IgPSBudWxsO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIExheW91dC5wcm90b3R5cGUubGlua1R5cGUgPSBmdW5jdGlvbiAoZikge1xyXG4gICAgICAgIHRoaXMuX2xpbmtUeXBlID0gZjtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICBMYXlvdXQucHJvdG90eXBlLmNvbnZlcmdlbmNlVGhyZXNob2xkID0gZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICBpZiAoIXgpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90aHJlc2hvbGQ7XHJcbiAgICAgICAgdGhpcy5fdGhyZXNob2xkID0gdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIiA/IHggOiAreDtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICBMYXlvdXQucHJvdG90eXBlLmFscGhhID0gZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hbHBoYTtcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgeCA9ICt4O1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fYWxwaGEpIHtcclxuICAgICAgICAgICAgICAgIGlmICh4ID4gMClcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hbHBoYSA9IHg7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWxwaGEgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3J1bm5pbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ydW5uaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoeyB0eXBlOiBFdmVudFR5cGUuc3RhcnQsIGFscGhhOiB0aGlzLl9hbHBoYSA9IHggfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5raWNrKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIExheW91dC5wcm90b3R5cGUuZ2V0TGlua0xlbmd0aCA9IGZ1bmN0aW9uIChsaW5rKSB7XHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB0aGlzLl9saW5rRGlzdGFuY2UgPT09IFwiZnVuY3Rpb25cIiA/ICsodGhpcy5fbGlua0Rpc3RhbmNlKGxpbmspKSA6IHRoaXMuX2xpbmtEaXN0YW5jZTtcclxuICAgIH07XHJcbiAgICBMYXlvdXQuc2V0TGlua0xlbmd0aCA9IGZ1bmN0aW9uIChsaW5rLCBsZW5ndGgpIHtcclxuICAgICAgICBsaW5rLmxlbmd0aCA9IGxlbmd0aDtcclxuICAgIH07XHJcbiAgICBMYXlvdXQucHJvdG90eXBlLmdldExpbmtUeXBlID0gZnVuY3Rpb24gKGxpbmspIHtcclxuICAgICAgICByZXR1cm4gdHlwZW9mIHRoaXMuX2xpbmtUeXBlID09PSBcImZ1bmN0aW9uXCIgPyB0aGlzLl9saW5rVHlwZShsaW5rKSA6IDA7XHJcbiAgICB9O1xyXG4gICAgTGF5b3V0LnByb3RvdHlwZS5zeW1tZXRyaWNEaWZmTGlua0xlbmd0aHMgPSBmdW5jdGlvbiAoaWRlYWxMZW5ndGgsIHcpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmICh3ID09PSB2b2lkIDApIHsgdyA9IDE7IH1cclxuICAgICAgICB0aGlzLmxpbmtEaXN0YW5jZShmdW5jdGlvbiAobCkgeyByZXR1cm4gaWRlYWxMZW5ndGggKiBsLmxlbmd0aDsgfSk7XHJcbiAgICAgICAgdGhpcy5fbGlua0xlbmd0aENhbGN1bGF0b3IgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBsaW5rbGVuZ3Roc18xLnN5bW1ldHJpY0RpZmZMaW5rTGVuZ3RocyhfdGhpcy5fbGlua3MsIF90aGlzLmxpbmtBY2Nlc3Nvciwgdyk7IH07XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgTGF5b3V0LnByb3RvdHlwZS5qYWNjYXJkTGlua0xlbmd0aHMgPSBmdW5jdGlvbiAoaWRlYWxMZW5ndGgsIHcpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmICh3ID09PSB2b2lkIDApIHsgdyA9IDE7IH1cclxuICAgICAgICB0aGlzLmxpbmtEaXN0YW5jZShmdW5jdGlvbiAobCkgeyByZXR1cm4gaWRlYWxMZW5ndGggKiBsLmxlbmd0aDsgfSk7XHJcbiAgICAgICAgdGhpcy5fbGlua0xlbmd0aENhbGN1bGF0b3IgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBsaW5rbGVuZ3Roc18xLmphY2NhcmRMaW5rTGVuZ3RocyhfdGhpcy5fbGlua3MsIF90aGlzLmxpbmtBY2Nlc3Nvciwgdyk7IH07XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgTGF5b3V0LnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uIChpbml0aWFsVW5jb25zdHJhaW5lZEl0ZXJhdGlvbnMsIGluaXRpYWxVc2VyQ29uc3RyYWludEl0ZXJhdGlvbnMsIGluaXRpYWxBbGxDb25zdHJhaW50c0l0ZXJhdGlvbnMsIGdyaWRTbmFwSXRlcmF0aW9ucywga2VlcFJ1bm5pbmcpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmIChpbml0aWFsVW5jb25zdHJhaW5lZEl0ZXJhdGlvbnMgPT09IHZvaWQgMCkgeyBpbml0aWFsVW5jb25zdHJhaW5lZEl0ZXJhdGlvbnMgPSAwOyB9XHJcbiAgICAgICAgaWYgKGluaXRpYWxVc2VyQ29uc3RyYWludEl0ZXJhdGlvbnMgPT09IHZvaWQgMCkgeyBpbml0aWFsVXNlckNvbnN0cmFpbnRJdGVyYXRpb25zID0gMDsgfVxyXG4gICAgICAgIGlmIChpbml0aWFsQWxsQ29uc3RyYWludHNJdGVyYXRpb25zID09PSB2b2lkIDApIHsgaW5pdGlhbEFsbENvbnN0cmFpbnRzSXRlcmF0aW9ucyA9IDA7IH1cclxuICAgICAgICBpZiAoZ3JpZFNuYXBJdGVyYXRpb25zID09PSB2b2lkIDApIHsgZ3JpZFNuYXBJdGVyYXRpb25zID0gMDsgfVxyXG4gICAgICAgIGlmIChrZWVwUnVubmluZyA9PT0gdm9pZCAwKSB7IGtlZXBSdW5uaW5nID0gdHJ1ZTsgfVxyXG4gICAgICAgIHZhciBpLCBqLCBuID0gdGhpcy5ub2RlcygpLmxlbmd0aCwgTiA9IG4gKyAyICogdGhpcy5fZ3JvdXBzLmxlbmd0aCwgbSA9IHRoaXMuX2xpbmtzLmxlbmd0aCwgdyA9IHRoaXMuX2NhbnZhc1NpemVbMF0sIGggPSB0aGlzLl9jYW52YXNTaXplWzFdO1xyXG4gICAgICAgIHZhciB4ID0gbmV3IEFycmF5KE4pLCB5ID0gbmV3IEFycmF5KE4pO1xyXG4gICAgICAgIHZhciBHID0gbnVsbDtcclxuICAgICAgICB2YXIgYW8gPSB0aGlzLl9hdm9pZE92ZXJsYXBzO1xyXG4gICAgICAgIHRoaXMuX25vZGVzLmZvckVhY2goZnVuY3Rpb24gKHYsIGkpIHtcclxuICAgICAgICAgICAgdi5pbmRleCA9IGk7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygdi54ID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgdi54ID0gdyAvIDIsIHYueSA9IGggLyAyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHhbaV0gPSB2LngsIHlbaV0gPSB2Lnk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKHRoaXMuX2xpbmtMZW5ndGhDYWxjdWxhdG9yKVxyXG4gICAgICAgICAgICB0aGlzLl9saW5rTGVuZ3RoQ2FsY3VsYXRvcigpO1xyXG4gICAgICAgIHZhciBkaXN0YW5jZXM7XHJcbiAgICAgICAgaWYgKHRoaXMuX2Rpc3RhbmNlTWF0cml4KSB7XHJcbiAgICAgICAgICAgIGRpc3RhbmNlcyA9IHRoaXMuX2Rpc3RhbmNlTWF0cml4O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZGlzdGFuY2VzID0gKG5ldyBzaG9ydGVzdHBhdGhzXzEuQ2FsY3VsYXRvcihOLCB0aGlzLl9saW5rcywgTGF5b3V0LmdldFNvdXJjZUluZGV4LCBMYXlvdXQuZ2V0VGFyZ2V0SW5kZXgsIGZ1bmN0aW9uIChsKSB7IHJldHVybiBfdGhpcy5nZXRMaW5rTGVuZ3RoKGwpOyB9KSkuRGlzdGFuY2VNYXRyaXgoKTtcclxuICAgICAgICAgICAgRyA9IGRlc2NlbnRfMS5EZXNjZW50LmNyZWF0ZVNxdWFyZU1hdHJpeChOLCBmdW5jdGlvbiAoKSB7IHJldHVybiAyOyB9KTtcclxuICAgICAgICAgICAgdGhpcy5fbGlua3MuZm9yRWFjaChmdW5jdGlvbiAobCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBsLnNvdXJjZSA9PSBcIm51bWJlclwiKVxyXG4gICAgICAgICAgICAgICAgICAgIGwuc291cmNlID0gX3RoaXMuX25vZGVzW2wuc291cmNlXTtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbC50YXJnZXQgPT0gXCJudW1iZXJcIilcclxuICAgICAgICAgICAgICAgICAgICBsLnRhcmdldCA9IF90aGlzLl9ub2Rlc1tsLnRhcmdldF07XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLl9saW5rcy5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdSA9IExheW91dC5nZXRTb3VyY2VJbmRleChlKSwgdiA9IExheW91dC5nZXRUYXJnZXRJbmRleChlKTtcclxuICAgICAgICAgICAgICAgIEdbdV1bdl0gPSBHW3ZdW3VdID0gZS53ZWlnaHQgfHwgMTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBEID0gZGVzY2VudF8xLkRlc2NlbnQuY3JlYXRlU3F1YXJlTWF0cml4KE4sIGZ1bmN0aW9uIChpLCBqKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkaXN0YW5jZXNbaV1bal07XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKHRoaXMuX3Jvb3RHcm91cCAmJiB0eXBlb2YgdGhpcy5fcm9vdEdyb3VwLmdyb3VwcyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgdmFyIGkgPSBuO1xyXG4gICAgICAgICAgICB2YXIgYWRkQXR0cmFjdGlvbiA9IGZ1bmN0aW9uIChpLCBqLCBzdHJlbmd0aCwgaWRlYWxEaXN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgR1tpXVtqXSA9IEdbal1baV0gPSBzdHJlbmd0aDtcclxuICAgICAgICAgICAgICAgIERbaV1bal0gPSBEW2pdW2ldID0gaWRlYWxEaXN0YW5jZTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5fZ3JvdXBzLmZvckVhY2goZnVuY3Rpb24gKGcpIHtcclxuICAgICAgICAgICAgICAgIGFkZEF0dHJhY3Rpb24oaSwgaSArIDEsIF90aGlzLl9ncm91cENvbXBhY3RuZXNzLCAwLjEpO1xyXG4gICAgICAgICAgICAgICAgeFtpXSA9IDAsIHlbaSsrXSA9IDA7XHJcbiAgICAgICAgICAgICAgICB4W2ldID0gMCwgeVtpKytdID0gMDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgdGhpcy5fcm9vdEdyb3VwID0geyBsZWF2ZXM6IHRoaXMuX25vZGVzLCBncm91cHM6IFtdIH07XHJcbiAgICAgICAgdmFyIGN1ckNvbnN0cmFpbnRzID0gdGhpcy5fY29uc3RyYWludHMgfHwgW107XHJcbiAgICAgICAgaWYgKHRoaXMuX2RpcmVjdGVkTGlua0NvbnN0cmFpbnRzKSB7XHJcbiAgICAgICAgICAgIHRoaXMubGlua0FjY2Vzc29yLmdldE1pblNlcGFyYXRpb24gPSB0aGlzLl9kaXJlY3RlZExpbmtDb25zdHJhaW50cy5nZXRNaW5TZXBhcmF0aW9uO1xyXG4gICAgICAgICAgICBjdXJDb25zdHJhaW50cyA9IGN1ckNvbnN0cmFpbnRzLmNvbmNhdChsaW5rbGVuZ3Roc18xLmdlbmVyYXRlRGlyZWN0ZWRFZGdlQ29uc3RyYWludHMobiwgdGhpcy5fbGlua3MsIHRoaXMuX2RpcmVjdGVkTGlua0NvbnN0cmFpbnRzLmF4aXMsICh0aGlzLmxpbmtBY2Nlc3NvcikpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5hdm9pZE92ZXJsYXBzKGZhbHNlKTtcclxuICAgICAgICB0aGlzLl9kZXNjZW50ID0gbmV3IGRlc2NlbnRfMS5EZXNjZW50KFt4LCB5XSwgRCk7XHJcbiAgICAgICAgdGhpcy5fZGVzY2VudC5sb2Nrcy5jbGVhcigpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSB7XHJcbiAgICAgICAgICAgIHZhciBvID0gdGhpcy5fbm9kZXNbaV07XHJcbiAgICAgICAgICAgIGlmIChvLmZpeGVkKSB7XHJcbiAgICAgICAgICAgICAgICBvLnB4ID0gby54O1xyXG4gICAgICAgICAgICAgICAgby5weSA9IG8ueTtcclxuICAgICAgICAgICAgICAgIHZhciBwID0gW28ueCwgby55XTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2Rlc2NlbnQubG9ja3MuYWRkKGksIHApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2Rlc2NlbnQudGhyZXNob2xkID0gdGhpcy5fdGhyZXNob2xkO1xyXG4gICAgICAgIHRoaXMuaW5pdGlhbExheW91dChpbml0aWFsVW5jb25zdHJhaW5lZEl0ZXJhdGlvbnMsIHgsIHkpO1xyXG4gICAgICAgIGlmIChjdXJDb25zdHJhaW50cy5sZW5ndGggPiAwKVxyXG4gICAgICAgICAgICB0aGlzLl9kZXNjZW50LnByb2plY3QgPSBuZXcgcmVjdGFuZ2xlXzEuUHJvamVjdGlvbih0aGlzLl9ub2RlcywgdGhpcy5fZ3JvdXBzLCB0aGlzLl9yb290R3JvdXAsIGN1ckNvbnN0cmFpbnRzKS5wcm9qZWN0RnVuY3Rpb25zKCk7XHJcbiAgICAgICAgdGhpcy5fZGVzY2VudC5ydW4oaW5pdGlhbFVzZXJDb25zdHJhaW50SXRlcmF0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5zZXBhcmF0ZU92ZXJsYXBwaW5nQ29tcG9uZW50cyh3LCBoKTtcclxuICAgICAgICB0aGlzLmF2b2lkT3ZlcmxhcHMoYW8pO1xyXG4gICAgICAgIGlmIChhbykge1xyXG4gICAgICAgICAgICB0aGlzLl9ub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uICh2LCBpKSB7IHYueCA9IHhbaV0sIHYueSA9IHlbaV07IH0pO1xyXG4gICAgICAgICAgICB0aGlzLl9kZXNjZW50LnByb2plY3QgPSBuZXcgcmVjdGFuZ2xlXzEuUHJvamVjdGlvbih0aGlzLl9ub2RlcywgdGhpcy5fZ3JvdXBzLCB0aGlzLl9yb290R3JvdXAsIGN1ckNvbnN0cmFpbnRzLCB0cnVlKS5wcm9qZWN0RnVuY3Rpb25zKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX25vZGVzLmZvckVhY2goZnVuY3Rpb24gKHYsIGkpIHsgeFtpXSA9IHYueCwgeVtpXSA9IHYueTsgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2Rlc2NlbnQuRyA9IEc7XHJcbiAgICAgICAgdGhpcy5fZGVzY2VudC5ydW4oaW5pdGlhbEFsbENvbnN0cmFpbnRzSXRlcmF0aW9ucyk7XHJcbiAgICAgICAgaWYgKGdyaWRTbmFwSXRlcmF0aW9ucykge1xyXG4gICAgICAgICAgICB0aGlzLl9kZXNjZW50LnNuYXBTdHJlbmd0aCA9IDEwMDA7XHJcbiAgICAgICAgICAgIHRoaXMuX2Rlc2NlbnQuc25hcEdyaWRTaXplID0gdGhpcy5fbm9kZXNbMF0ud2lkdGg7XHJcbiAgICAgICAgICAgIHRoaXMuX2Rlc2NlbnQubnVtR3JpZFNuYXBOb2RlcyA9IG47XHJcbiAgICAgICAgICAgIHRoaXMuX2Rlc2NlbnQuc2NhbGVTbmFwQnlNYXhIID0gbiAhPSBOO1xyXG4gICAgICAgICAgICB2YXIgRzAgPSBkZXNjZW50XzEuRGVzY2VudC5jcmVhdGVTcXVhcmVNYXRyaXgoTiwgZnVuY3Rpb24gKGksIGopIHtcclxuICAgICAgICAgICAgICAgIGlmIChpID49IG4gfHwgaiA+PSBuKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBHW2ldW2pdO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLl9kZXNjZW50LkcgPSBHMDtcclxuICAgICAgICAgICAgdGhpcy5fZGVzY2VudC5ydW4oZ3JpZFNuYXBJdGVyYXRpb25zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy51cGRhdGVOb2RlUG9zaXRpb25zKCk7XHJcbiAgICAgICAgdGhpcy5zZXBhcmF0ZU92ZXJsYXBwaW5nQ29tcG9uZW50cyh3LCBoKTtcclxuICAgICAgICByZXR1cm4ga2VlcFJ1bm5pbmcgPyB0aGlzLnJlc3VtZSgpIDogdGhpcztcclxuICAgIH07XHJcbiAgICBMYXlvdXQucHJvdG90eXBlLmluaXRpYWxMYXlvdXQgPSBmdW5jdGlvbiAoaXRlcmF0aW9ucywgeCwgeSkge1xyXG4gICAgICAgIGlmICh0aGlzLl9ncm91cHMubGVuZ3RoID4gMCAmJiBpdGVyYXRpb25zID4gMCkge1xyXG4gICAgICAgICAgICB2YXIgbiA9IHRoaXMuX25vZGVzLmxlbmd0aDtcclxuICAgICAgICAgICAgdmFyIGVkZ2VzID0gdGhpcy5fbGlua3MubWFwKGZ1bmN0aW9uIChlKSB7IHJldHVybiAoeyBzb3VyY2U6IGUuc291cmNlLmluZGV4LCB0YXJnZXQ6IGUudGFyZ2V0LmluZGV4IH0pOyB9KTtcclxuICAgICAgICAgICAgdmFyIHZzID0gdGhpcy5fbm9kZXMubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiAoeyBpbmRleDogdi5pbmRleCB9KTsgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2dyb3Vwcy5mb3JFYWNoKGZ1bmN0aW9uIChnLCBpKSB7XHJcbiAgICAgICAgICAgICAgICB2cy5wdXNoKHsgaW5kZXg6IGcuaW5kZXggPSBuICsgaSB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2dyb3Vwcy5mb3JFYWNoKGZ1bmN0aW9uIChnLCBpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGcubGVhdmVzICE9PSAndW5kZWZpbmVkJylcclxuICAgICAgICAgICAgICAgICAgICBnLmxlYXZlcy5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7IHJldHVybiBlZGdlcy5wdXNoKHsgc291cmNlOiBnLmluZGV4LCB0YXJnZXQ6IHYuaW5kZXggfSk7IH0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBnLmdyb3VwcyAhPT0gJ3VuZGVmaW5lZCcpXHJcbiAgICAgICAgICAgICAgICAgICAgZy5ncm91cHMuZm9yRWFjaChmdW5jdGlvbiAoZ2cpIHsgcmV0dXJuIGVkZ2VzLnB1c2goeyBzb3VyY2U6IGcuaW5kZXgsIHRhcmdldDogZ2cuaW5kZXggfSk7IH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgbmV3IExheW91dCgpXHJcbiAgICAgICAgICAgICAgICAuc2l6ZSh0aGlzLnNpemUoKSlcclxuICAgICAgICAgICAgICAgIC5ub2Rlcyh2cylcclxuICAgICAgICAgICAgICAgIC5saW5rcyhlZGdlcylcclxuICAgICAgICAgICAgICAgIC5hdm9pZE92ZXJsYXBzKGZhbHNlKVxyXG4gICAgICAgICAgICAgICAgLmxpbmtEaXN0YW5jZSh0aGlzLmxpbmtEaXN0YW5jZSgpKVxyXG4gICAgICAgICAgICAgICAgLnN5bW1ldHJpY0RpZmZMaW5rTGVuZ3Rocyg1KVxyXG4gICAgICAgICAgICAgICAgLmNvbnZlcmdlbmNlVGhyZXNob2xkKDFlLTQpXHJcbiAgICAgICAgICAgICAgICAuc3RhcnQoaXRlcmF0aW9ucywgMCwgMCwgMCwgZmFsc2UpO1xyXG4gICAgICAgICAgICB0aGlzLl9ub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgICAgICB4W3YuaW5kZXhdID0gdnNbdi5pbmRleF0ueDtcclxuICAgICAgICAgICAgICAgIHlbdi5pbmRleF0gPSB2c1t2LmluZGV4XS55O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2Rlc2NlbnQucnVuKGl0ZXJhdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBMYXlvdXQucHJvdG90eXBlLnNlcGFyYXRlT3ZlcmxhcHBpbmdDb21wb25lbnRzID0gZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmICghdGhpcy5fZGlzdGFuY2VNYXRyaXggJiYgdGhpcy5faGFuZGxlRGlzY29ubmVjdGVkKSB7XHJcbiAgICAgICAgICAgIHZhciB4XzEgPSB0aGlzLl9kZXNjZW50LnhbMF0sIHlfMSA9IHRoaXMuX2Rlc2NlbnQueFsxXTtcclxuICAgICAgICAgICAgdGhpcy5fbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAodiwgaSkgeyB2LnggPSB4XzFbaV0sIHYueSA9IHlfMVtpXTsgfSk7XHJcbiAgICAgICAgICAgIHZhciBncmFwaHMgPSBoYW5kbGVkaXNjb25uZWN0ZWRfMS5zZXBhcmF0ZUdyYXBocyh0aGlzLl9ub2RlcywgdGhpcy5fbGlua3MpO1xyXG4gICAgICAgICAgICBoYW5kbGVkaXNjb25uZWN0ZWRfMS5hcHBseVBhY2tpbmcoZ3JhcGhzLCB3aWR0aCwgaGVpZ2h0LCB0aGlzLl9kZWZhdWx0Tm9kZVNpemUpO1xyXG4gICAgICAgICAgICB0aGlzLl9ub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uICh2LCBpKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fZGVzY2VudC54WzBdW2ldID0gdi54LCBfdGhpcy5fZGVzY2VudC54WzFdW2ldID0gdi55O1xyXG4gICAgICAgICAgICAgICAgaWYgKHYuYm91bmRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdi5ib3VuZHMuc2V0WENlbnRyZSh2LngpO1xyXG4gICAgICAgICAgICAgICAgICAgIHYuYm91bmRzLnNldFlDZW50cmUodi55KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIExheW91dC5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFscGhhKDAuMSk7XHJcbiAgICB9O1xyXG4gICAgTGF5b3V0LnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFscGhhKDApO1xyXG4gICAgfTtcclxuICAgIExheW91dC5wcm90b3R5cGUucHJlcGFyZUVkZ2VSb3V0aW5nID0gZnVuY3Rpb24gKG5vZGVNYXJnaW4pIHtcclxuICAgICAgICBpZiAobm9kZU1hcmdpbiA9PT0gdm9pZCAwKSB7IG5vZGVNYXJnaW4gPSAwOyB9XHJcbiAgICAgICAgdGhpcy5fdmlzaWJpbGl0eUdyYXBoID0gbmV3IGdlb21fMS5UYW5nZW50VmlzaWJpbGl0eUdyYXBoKHRoaXMuX25vZGVzLm1hcChmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICByZXR1cm4gdi5ib3VuZHMuaW5mbGF0ZSgtbm9kZU1hcmdpbikudmVydGljZXMoKTtcclxuICAgICAgICB9KSk7XHJcbiAgICB9O1xyXG4gICAgTGF5b3V0LnByb3RvdHlwZS5yb3V0ZUVkZ2UgPSBmdW5jdGlvbiAoZWRnZSwgYWgsIGRyYXcpIHtcclxuICAgICAgICBpZiAoYWggPT09IHZvaWQgMCkgeyBhaCA9IDU7IH1cclxuICAgICAgICB2YXIgbGluZURhdGEgPSBbXTtcclxuICAgICAgICB2YXIgdmcyID0gbmV3IGdlb21fMS5UYW5nZW50VmlzaWJpbGl0eUdyYXBoKHRoaXMuX3Zpc2liaWxpdHlHcmFwaC5QLCB7IFY6IHRoaXMuX3Zpc2liaWxpdHlHcmFwaC5WLCBFOiB0aGlzLl92aXNpYmlsaXR5R3JhcGguRSB9KSwgcG9ydDEgPSB7IHg6IGVkZ2Uuc291cmNlLngsIHk6IGVkZ2Uuc291cmNlLnkgfSwgcG9ydDIgPSB7IHg6IGVkZ2UudGFyZ2V0LngsIHk6IGVkZ2UudGFyZ2V0LnkgfSwgc3RhcnQgPSB2ZzIuYWRkUG9pbnQocG9ydDEsIGVkZ2Uuc291cmNlLmluZGV4KSwgZW5kID0gdmcyLmFkZFBvaW50KHBvcnQyLCBlZGdlLnRhcmdldC5pbmRleCk7XHJcbiAgICAgICAgdmcyLmFkZEVkZ2VJZlZpc2libGUocG9ydDEsIHBvcnQyLCBlZGdlLnNvdXJjZS5pbmRleCwgZWRnZS50YXJnZXQuaW5kZXgpO1xyXG4gICAgICAgIGlmICh0eXBlb2YgZHJhdyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgZHJhdyh2ZzIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc291cmNlSW5kID0gZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGUuc291cmNlLmlkOyB9LCB0YXJnZXRJbmQgPSBmdW5jdGlvbiAoZSkgeyByZXR1cm4gZS50YXJnZXQuaWQ7IH0sIGxlbmd0aCA9IGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLmxlbmd0aCgpOyB9LCBzcENhbGMgPSBuZXcgc2hvcnRlc3RwYXRoc18xLkNhbGN1bGF0b3IodmcyLlYubGVuZ3RoLCB2ZzIuRSwgc291cmNlSW5kLCB0YXJnZXRJbmQsIGxlbmd0aCksIHNob3J0ZXN0UGF0aCA9IHNwQ2FsYy5QYXRoRnJvbU5vZGVUb05vZGUoc3RhcnQuaWQsIGVuZC5pZCk7XHJcbiAgICAgICAgaWYgKHNob3J0ZXN0UGF0aC5sZW5ndGggPT09IDEgfHwgc2hvcnRlc3RQYXRoLmxlbmd0aCA9PT0gdmcyLlYubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHZhciByb3V0ZSA9IHJlY3RhbmdsZV8xLm1ha2VFZGdlQmV0d2VlbihlZGdlLnNvdXJjZS5pbm5lckJvdW5kcywgZWRnZS50YXJnZXQuaW5uZXJCb3VuZHMsIGFoKTtcclxuICAgICAgICAgICAgbGluZURhdGEgPSBbcm91dGUuc291cmNlSW50ZXJzZWN0aW9uLCByb3V0ZS5hcnJvd1N0YXJ0XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBuID0gc2hvcnRlc3RQYXRoLmxlbmd0aCAtIDIsIHAgPSB2ZzIuVltzaG9ydGVzdFBhdGhbbl1dLnAsIHEgPSB2ZzIuVltzaG9ydGVzdFBhdGhbMF1dLnAsIGxpbmVEYXRhID0gW2VkZ2Uuc291cmNlLmlubmVyQm91bmRzLnJheUludGVyc2VjdGlvbihwLngsIHAueSldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gbjsgaSA+PSAwOyAtLWkpXHJcbiAgICAgICAgICAgICAgICBsaW5lRGF0YS5wdXNoKHZnMi5WW3Nob3J0ZXN0UGF0aFtpXV0ucCk7XHJcbiAgICAgICAgICAgIGxpbmVEYXRhLnB1c2gocmVjdGFuZ2xlXzEubWFrZUVkZ2VUbyhxLCBlZGdlLnRhcmdldC5pbm5lckJvdW5kcywgYWgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGxpbmVEYXRhO1xyXG4gICAgfTtcclxuICAgIExheW91dC5nZXRTb3VyY2VJbmRleCA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBlLnNvdXJjZSA9PT0gJ251bWJlcicgPyBlLnNvdXJjZSA6IGUuc291cmNlLmluZGV4O1xyXG4gICAgfTtcclxuICAgIExheW91dC5nZXRUYXJnZXRJbmRleCA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBlLnRhcmdldCA9PT0gJ251bWJlcicgPyBlLnRhcmdldCA6IGUudGFyZ2V0LmluZGV4O1xyXG4gICAgfTtcclxuICAgIExheW91dC5saW5rSWQgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIHJldHVybiBMYXlvdXQuZ2V0U291cmNlSW5kZXgoZSkgKyBcIi1cIiArIExheW91dC5nZXRUYXJnZXRJbmRleChlKTtcclxuICAgIH07XHJcbiAgICBMYXlvdXQuZHJhZ1N0YXJ0ID0gZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICBpZiAoaXNHcm91cChkKSkge1xyXG4gICAgICAgICAgICBMYXlvdXQuc3RvcmVPZmZzZXQoZCwgTGF5b3V0LmRyYWdPcmlnaW4oZCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgTGF5b3V0LnN0b3BOb2RlKGQpO1xyXG4gICAgICAgICAgICBkLmZpeGVkIHw9IDI7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIExheW91dC5zdG9wTm9kZSA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgdi5weCA9IHYueDtcclxuICAgICAgICB2LnB5ID0gdi55O1xyXG4gICAgfTtcclxuICAgIExheW91dC5zdG9yZU9mZnNldCA9IGZ1bmN0aW9uIChkLCBvcmlnaW4pIHtcclxuICAgICAgICBpZiAodHlwZW9mIGQubGVhdmVzICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICBkLmxlYXZlcy5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgICAgICB2LmZpeGVkIHw9IDI7XHJcbiAgICAgICAgICAgICAgICBMYXlvdXQuc3RvcE5vZGUodik7XHJcbiAgICAgICAgICAgICAgICB2Ll9kcmFnR3JvdXBPZmZzZXRYID0gdi54IC0gb3JpZ2luLng7XHJcbiAgICAgICAgICAgICAgICB2Ll9kcmFnR3JvdXBPZmZzZXRZID0gdi55IC0gb3JpZ2luLnk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIGQuZ3JvdXBzICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICBkLmdyb3Vwcy5mb3JFYWNoKGZ1bmN0aW9uIChnKSB7IHJldHVybiBMYXlvdXQuc3RvcmVPZmZzZXQoZywgb3JpZ2luKTsgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIExheW91dC5kcmFnT3JpZ2luID0gZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICBpZiAoaXNHcm91cChkKSkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgeDogZC5ib3VuZHMuY3goKSxcclxuICAgICAgICAgICAgICAgIHk6IGQuYm91bmRzLmN5KClcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBMYXlvdXQuZHJhZyA9IGZ1bmN0aW9uIChkLCBwb3NpdGlvbikge1xyXG4gICAgICAgIGlmIChpc0dyb3VwKGQpKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZC5sZWF2ZXMgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICBkLmxlYXZlcy5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZC5ib3VuZHMuc2V0WENlbnRyZShwb3NpdGlvbi54KTtcclxuICAgICAgICAgICAgICAgICAgICBkLmJvdW5kcy5zZXRZQ2VudHJlKHBvc2l0aW9uLnkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHYucHggPSB2Ll9kcmFnR3JvdXBPZmZzZXRYICsgcG9zaXRpb24ueDtcclxuICAgICAgICAgICAgICAgICAgICB2LnB5ID0gdi5fZHJhZ0dyb3VwT2Zmc2V0WSArIHBvc2l0aW9uLnk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGQuZ3JvdXBzICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgZC5ncm91cHMuZm9yRWFjaChmdW5jdGlvbiAoZykgeyByZXR1cm4gTGF5b3V0LmRyYWcoZywgcG9zaXRpb24pOyB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZC5weCA9IHBvc2l0aW9uLng7XHJcbiAgICAgICAgICAgIGQucHkgPSBwb3NpdGlvbi55O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBMYXlvdXQuZHJhZ0VuZCA9IGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgaWYgKGlzR3JvdXAoZCkpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBkLmxlYXZlcyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgIGQubGVhdmVzLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgICAgICAgICBMYXlvdXQuZHJhZ0VuZCh2KTtcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdi5fZHJhZ0dyb3VwT2Zmc2V0WDtcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdi5fZHJhZ0dyb3VwT2Zmc2V0WTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZC5ncm91cHMgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICBkLmdyb3Vwcy5mb3JFYWNoKExheW91dC5kcmFnRW5kKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZC5maXhlZCAmPSB+NjtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTGF5b3V0Lm1vdXNlT3ZlciA9IGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgZC5maXhlZCB8PSA0O1xyXG4gICAgICAgIGQucHggPSBkLngsIGQucHkgPSBkLnk7XHJcbiAgICB9O1xyXG4gICAgTGF5b3V0Lm1vdXNlT3V0ID0gZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICBkLmZpeGVkICY9IH40O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBMYXlvdXQ7XHJcbn0oKSk7XHJcbmV4cG9ydHMuTGF5b3V0ID0gTGF5b3V0O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1sYXlvdXQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHNob3J0ZXN0cGF0aHNfMSA9IHJlcXVpcmUoXCIuL3Nob3J0ZXN0cGF0aHNcIik7XHJcbnZhciBkZXNjZW50XzEgPSByZXF1aXJlKFwiLi9kZXNjZW50XCIpO1xyXG52YXIgcmVjdGFuZ2xlXzEgPSByZXF1aXJlKFwiLi9yZWN0YW5nbGVcIik7XHJcbnZhciBsaW5rbGVuZ3Roc18xID0gcmVxdWlyZShcIi4vbGlua2xlbmd0aHNcIik7XHJcbnZhciBMaW5rM0QgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTGluazNEKHNvdXJjZSwgdGFyZ2V0KSB7XHJcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XHJcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICB9XHJcbiAgICBMaW5rM0QucHJvdG90eXBlLmFjdHVhbExlbmd0aCA9IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHgucmVkdWNlKGZ1bmN0aW9uIChjLCB2KSB7XHJcbiAgICAgICAgICAgIHZhciBkeCA9IHZbX3RoaXMudGFyZ2V0XSAtIHZbX3RoaXMuc291cmNlXTtcclxuICAgICAgICAgICAgcmV0dXJuIGMgKyBkeCAqIGR4O1xyXG4gICAgICAgIH0sIDApKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gTGluazNEO1xyXG59KCkpO1xyXG5leHBvcnRzLkxpbmszRCA9IExpbmszRDtcclxudmFyIE5vZGUzRCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBOb2RlM0QoeCwgeSwgeikge1xyXG4gICAgICAgIGlmICh4ID09PSB2b2lkIDApIHsgeCA9IDA7IH1cclxuICAgICAgICBpZiAoeSA9PT0gdm9pZCAwKSB7IHkgPSAwOyB9XHJcbiAgICAgICAgaWYgKHogPT09IHZvaWQgMCkgeyB6ID0gMDsgfVxyXG4gICAgICAgIHRoaXMueCA9IHg7XHJcbiAgICAgICAgdGhpcy55ID0geTtcclxuICAgICAgICB0aGlzLnogPSB6O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIE5vZGUzRDtcclxufSgpKTtcclxuZXhwb3J0cy5Ob2RlM0QgPSBOb2RlM0Q7XHJcbnZhciBMYXlvdXQzRCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBMYXlvdXQzRChub2RlcywgbGlua3MsIGlkZWFsTGlua0xlbmd0aCkge1xyXG4gICAgICAgIGlmIChpZGVhbExpbmtMZW5ndGggPT09IHZvaWQgMCkgeyBpZGVhbExpbmtMZW5ndGggPSAxOyB9XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLm5vZGVzID0gbm9kZXM7XHJcbiAgICAgICAgdGhpcy5saW5rcyA9IGxpbmtzO1xyXG4gICAgICAgIHRoaXMuaWRlYWxMaW5rTGVuZ3RoID0gaWRlYWxMaW5rTGVuZ3RoO1xyXG4gICAgICAgIHRoaXMuY29uc3RyYWludHMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMudXNlSmFjY2FyZExpbmtMZW5ndGhzID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnJlc3VsdCA9IG5ldyBBcnJheShMYXlvdXQzRC5rKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IExheW91dDNELms7ICsraSkge1xyXG4gICAgICAgICAgICB0aGlzLnJlc3VsdFtpXSA9IG5ldyBBcnJheShub2Rlcy5sZW5ndGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uICh2LCBpKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBMYXlvdXQzRC5kaW1zOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRpbSA9IF9hW19pXTtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdltkaW1dID09ICd1bmRlZmluZWQnKVxyXG4gICAgICAgICAgICAgICAgICAgIHZbZGltXSA9IE1hdGgucmFuZG9tKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgX3RoaXMucmVzdWx0WzBdW2ldID0gdi54O1xyXG4gICAgICAgICAgICBfdGhpcy5yZXN1bHRbMV1baV0gPSB2Lnk7XHJcbiAgICAgICAgICAgIF90aGlzLnJlc3VsdFsyXVtpXSA9IHYuejtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIExheW91dDNELnByb3RvdHlwZS5saW5rTGVuZ3RoID0gZnVuY3Rpb24gKGwpIHtcclxuICAgICAgICByZXR1cm4gbC5hY3R1YWxMZW5ndGgodGhpcy5yZXN1bHQpO1xyXG4gICAgfTtcclxuICAgIExheW91dDNELnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uIChpdGVyYXRpb25zKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAoaXRlcmF0aW9ucyA9PT0gdm9pZCAwKSB7IGl0ZXJhdGlvbnMgPSAxMDA7IH1cclxuICAgICAgICB2YXIgbiA9IHRoaXMubm9kZXMubGVuZ3RoO1xyXG4gICAgICAgIHZhciBsaW5rQWNjZXNzb3IgPSBuZXcgTGlua0FjY2Vzc29yKCk7XHJcbiAgICAgICAgaWYgKHRoaXMudXNlSmFjY2FyZExpbmtMZW5ndGhzKVxyXG4gICAgICAgICAgICBsaW5rbGVuZ3Roc18xLmphY2NhcmRMaW5rTGVuZ3Rocyh0aGlzLmxpbmtzLCBsaW5rQWNjZXNzb3IsIDEuNSk7XHJcbiAgICAgICAgdGhpcy5saW5rcy5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLmxlbmd0aCAqPSBfdGhpcy5pZGVhbExpbmtMZW5ndGg7IH0pO1xyXG4gICAgICAgIHZhciBkaXN0YW5jZU1hdHJpeCA9IChuZXcgc2hvcnRlc3RwYXRoc18xLkNhbGN1bGF0b3IobiwgdGhpcy5saW5rcywgZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGUuc291cmNlOyB9LCBmdW5jdGlvbiAoZSkgeyByZXR1cm4gZS50YXJnZXQ7IH0sIGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLmxlbmd0aDsgfSkpLkRpc3RhbmNlTWF0cml4KCk7XHJcbiAgICAgICAgdmFyIEQgPSBkZXNjZW50XzEuRGVzY2VudC5jcmVhdGVTcXVhcmVNYXRyaXgobiwgZnVuY3Rpb24gKGksIGopIHsgcmV0dXJuIGRpc3RhbmNlTWF0cml4W2ldW2pdOyB9KTtcclxuICAgICAgICB2YXIgRyA9IGRlc2NlbnRfMS5EZXNjZW50LmNyZWF0ZVNxdWFyZU1hdHJpeChuLCBmdW5jdGlvbiAoKSB7IHJldHVybiAyOyB9KTtcclxuICAgICAgICB0aGlzLmxpbmtzLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBfYS5zb3VyY2UsIHRhcmdldCA9IF9hLnRhcmdldDtcclxuICAgICAgICAgICAgcmV0dXJuIEdbc291cmNlXVt0YXJnZXRdID0gR1t0YXJnZXRdW3NvdXJjZV0gPSAxO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuZGVzY2VudCA9IG5ldyBkZXNjZW50XzEuRGVzY2VudCh0aGlzLnJlc3VsdCwgRCk7XHJcbiAgICAgICAgdGhpcy5kZXNjZW50LnRocmVzaG9sZCA9IDFlLTM7XHJcbiAgICAgICAgdGhpcy5kZXNjZW50LkcgPSBHO1xyXG4gICAgICAgIGlmICh0aGlzLmNvbnN0cmFpbnRzKVxyXG4gICAgICAgICAgICB0aGlzLmRlc2NlbnQucHJvamVjdCA9IG5ldyByZWN0YW5nbGVfMS5Qcm9qZWN0aW9uKHRoaXMubm9kZXMsIG51bGwsIG51bGwsIHRoaXMuY29uc3RyYWludHMpLnByb2plY3RGdW5jdGlvbnMoKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubm9kZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHYgPSB0aGlzLm5vZGVzW2ldO1xyXG4gICAgICAgICAgICBpZiAodi5maXhlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kZXNjZW50LmxvY2tzLmFkZChpLCBbdi54LCB2LnksIHYuel0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZGVzY2VudC5ydW4oaXRlcmF0aW9ucyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgTGF5b3V0M0QucHJvdG90eXBlLnRpY2sgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5kZXNjZW50LmxvY2tzLmNsZWFyKCk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm5vZGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciB2ID0gdGhpcy5ub2Rlc1tpXTtcclxuICAgICAgICAgICAgaWYgKHYuZml4ZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVzY2VudC5sb2Nrcy5hZGQoaSwgW3YueCwgdi55LCB2LnpdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5kZXNjZW50LnJ1bmdlS3V0dGEoKTtcclxuICAgIH07XHJcbiAgICBMYXlvdXQzRC5kaW1zID0gWyd4JywgJ3knLCAneiddO1xyXG4gICAgTGF5b3V0M0QuayA9IExheW91dDNELmRpbXMubGVuZ3RoO1xyXG4gICAgcmV0dXJuIExheW91dDNEO1xyXG59KCkpO1xyXG5leHBvcnRzLkxheW91dDNEID0gTGF5b3V0M0Q7XHJcbnZhciBMaW5rQWNjZXNzb3IgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTGlua0FjY2Vzc29yKCkge1xyXG4gICAgfVxyXG4gICAgTGlua0FjY2Vzc29yLnByb3RvdHlwZS5nZXRTb3VyY2VJbmRleCA9IGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLnNvdXJjZTsgfTtcclxuICAgIExpbmtBY2Nlc3Nvci5wcm90b3R5cGUuZ2V0VGFyZ2V0SW5kZXggPSBmdW5jdGlvbiAoZSkgeyByZXR1cm4gZS50YXJnZXQ7IH07XHJcbiAgICBMaW5rQWNjZXNzb3IucHJvdG90eXBlLmdldExlbmd0aCA9IGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLmxlbmd0aDsgfTtcclxuICAgIExpbmtBY2Nlc3Nvci5wcm90b3R5cGUuc2V0TGVuZ3RoID0gZnVuY3Rpb24gKGUsIGwpIHsgZS5sZW5ndGggPSBsOyB9O1xyXG4gICAgcmV0dXJuIExpbmtBY2Nlc3NvcjtcclxufSgpKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGF5b3V0M2QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZnVuY3Rpb24gdW5pb25Db3VudChhLCBiKSB7XHJcbiAgICB2YXIgdSA9IHt9O1xyXG4gICAgZm9yICh2YXIgaSBpbiBhKVxyXG4gICAgICAgIHVbaV0gPSB7fTtcclxuICAgIGZvciAodmFyIGkgaW4gYilcclxuICAgICAgICB1W2ldID0ge307XHJcbiAgICByZXR1cm4gT2JqZWN0LmtleXModSkubGVuZ3RoO1xyXG59XHJcbmZ1bmN0aW9uIGludGVyc2VjdGlvbkNvdW50KGEsIGIpIHtcclxuICAgIHZhciBuID0gMDtcclxuICAgIGZvciAodmFyIGkgaW4gYSlcclxuICAgICAgICBpZiAodHlwZW9mIGJbaV0gIT09ICd1bmRlZmluZWQnKVxyXG4gICAgICAgICAgICArK247XHJcbiAgICByZXR1cm4gbjtcclxufVxyXG5mdW5jdGlvbiBnZXROZWlnaGJvdXJzKGxpbmtzLCBsYSkge1xyXG4gICAgdmFyIG5laWdoYm91cnMgPSB7fTtcclxuICAgIHZhciBhZGROZWlnaGJvdXJzID0gZnVuY3Rpb24gKHUsIHYpIHtcclxuICAgICAgICBpZiAodHlwZW9mIG5laWdoYm91cnNbdV0gPT09ICd1bmRlZmluZWQnKVxyXG4gICAgICAgICAgICBuZWlnaGJvdXJzW3VdID0ge307XHJcbiAgICAgICAgbmVpZ2hib3Vyc1t1XVt2XSA9IHt9O1xyXG4gICAgfTtcclxuICAgIGxpbmtzLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICB2YXIgdSA9IGxhLmdldFNvdXJjZUluZGV4KGUpLCB2ID0gbGEuZ2V0VGFyZ2V0SW5kZXgoZSk7XHJcbiAgICAgICAgYWRkTmVpZ2hib3Vycyh1LCB2KTtcclxuICAgICAgICBhZGROZWlnaGJvdXJzKHYsIHUpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gbmVpZ2hib3VycztcclxufVxyXG5mdW5jdGlvbiBjb21wdXRlTGlua0xlbmd0aHMobGlua3MsIHcsIGYsIGxhKSB7XHJcbiAgICB2YXIgbmVpZ2hib3VycyA9IGdldE5laWdoYm91cnMobGlua3MsIGxhKTtcclxuICAgIGxpbmtzLmZvckVhY2goZnVuY3Rpb24gKGwpIHtcclxuICAgICAgICB2YXIgYSA9IG5laWdoYm91cnNbbGEuZ2V0U291cmNlSW5kZXgobCldO1xyXG4gICAgICAgIHZhciBiID0gbmVpZ2hib3Vyc1tsYS5nZXRUYXJnZXRJbmRleChsKV07XHJcbiAgICAgICAgbGEuc2V0TGVuZ3RoKGwsIDEgKyB3ICogZihhLCBiKSk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBzeW1tZXRyaWNEaWZmTGlua0xlbmd0aHMobGlua3MsIGxhLCB3KSB7XHJcbiAgICBpZiAodyA9PT0gdm9pZCAwKSB7IHcgPSAxOyB9XHJcbiAgICBjb21wdXRlTGlua0xlbmd0aHMobGlua3MsIHcsIGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBNYXRoLnNxcnQodW5pb25Db3VudChhLCBiKSAtIGludGVyc2VjdGlvbkNvdW50KGEsIGIpKTsgfSwgbGEpO1xyXG59XHJcbmV4cG9ydHMuc3ltbWV0cmljRGlmZkxpbmtMZW5ndGhzID0gc3ltbWV0cmljRGlmZkxpbmtMZW5ndGhzO1xyXG5mdW5jdGlvbiBqYWNjYXJkTGlua0xlbmd0aHMobGlua3MsIGxhLCB3KSB7XHJcbiAgICBpZiAodyA9PT0gdm9pZCAwKSB7IHcgPSAxOyB9XHJcbiAgICBjb21wdXRlTGlua0xlbmd0aHMobGlua3MsIHcsIGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKE9iamVjdC5rZXlzKGEpLmxlbmd0aCwgT2JqZWN0LmtleXMoYikubGVuZ3RoKSA8IDEuMSA/IDAgOiBpbnRlcnNlY3Rpb25Db3VudChhLCBiKSAvIHVuaW9uQ291bnQoYSwgYik7XHJcbiAgICB9LCBsYSk7XHJcbn1cclxuZXhwb3J0cy5qYWNjYXJkTGlua0xlbmd0aHMgPSBqYWNjYXJkTGlua0xlbmd0aHM7XHJcbmZ1bmN0aW9uIGdlbmVyYXRlRGlyZWN0ZWRFZGdlQ29uc3RyYWludHMobiwgbGlua3MsIGF4aXMsIGxhKSB7XHJcbiAgICB2YXIgY29tcG9uZW50cyA9IHN0cm9uZ2x5Q29ubmVjdGVkQ29tcG9uZW50cyhuLCBsaW5rcywgbGEpO1xyXG4gICAgdmFyIG5vZGVzID0ge307XHJcbiAgICBjb21wb25lbnRzLmZvckVhY2goZnVuY3Rpb24gKGMsIGkpIHtcclxuICAgICAgICByZXR1cm4gYy5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7IHJldHVybiBub2Rlc1t2XSA9IGk7IH0pO1xyXG4gICAgfSk7XHJcbiAgICB2YXIgY29uc3RyYWludHMgPSBbXTtcclxuICAgIGxpbmtzLmZvckVhY2goZnVuY3Rpb24gKGwpIHtcclxuICAgICAgICB2YXIgdWkgPSBsYS5nZXRTb3VyY2VJbmRleChsKSwgdmkgPSBsYS5nZXRUYXJnZXRJbmRleChsKSwgdSA9IG5vZGVzW3VpXSwgdiA9IG5vZGVzW3ZpXTtcclxuICAgICAgICBpZiAodSAhPT0gdikge1xyXG4gICAgICAgICAgICBjb25zdHJhaW50cy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIGF4aXM6IGF4aXMsXHJcbiAgICAgICAgICAgICAgICBsZWZ0OiB1aSxcclxuICAgICAgICAgICAgICAgIHJpZ2h0OiB2aSxcclxuICAgICAgICAgICAgICAgIGdhcDogbGEuZ2V0TWluU2VwYXJhdGlvbihsKVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBjb25zdHJhaW50cztcclxufVxyXG5leHBvcnRzLmdlbmVyYXRlRGlyZWN0ZWRFZGdlQ29uc3RyYWludHMgPSBnZW5lcmF0ZURpcmVjdGVkRWRnZUNvbnN0cmFpbnRzO1xyXG5mdW5jdGlvbiBzdHJvbmdseUNvbm5lY3RlZENvbXBvbmVudHMobnVtVmVydGljZXMsIGVkZ2VzLCBsYSkge1xyXG4gICAgdmFyIG5vZGVzID0gW107XHJcbiAgICB2YXIgaW5kZXggPSAwO1xyXG4gICAgdmFyIHN0YWNrID0gW107XHJcbiAgICB2YXIgY29tcG9uZW50cyA9IFtdO1xyXG4gICAgZnVuY3Rpb24gc3Ryb25nQ29ubmVjdCh2KSB7XHJcbiAgICAgICAgdi5pbmRleCA9IHYubG93bGluayA9IGluZGV4Kys7XHJcbiAgICAgICAgc3RhY2sucHVzaCh2KTtcclxuICAgICAgICB2Lm9uU3RhY2sgPSB0cnVlO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB2Lm91dDsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdmFyIHcgPSBfYVtfaV07XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygdy5pbmRleCA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgIHN0cm9uZ0Nvbm5lY3Qodyk7XHJcbiAgICAgICAgICAgICAgICB2Lmxvd2xpbmsgPSBNYXRoLm1pbih2Lmxvd2xpbmssIHcubG93bGluayk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAody5vblN0YWNrKSB7XHJcbiAgICAgICAgICAgICAgICB2Lmxvd2xpbmsgPSBNYXRoLm1pbih2Lmxvd2xpbmssIHcuaW5kZXgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2Lmxvd2xpbmsgPT09IHYuaW5kZXgpIHtcclxuICAgICAgICAgICAgdmFyIGNvbXBvbmVudCA9IFtdO1xyXG4gICAgICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB3ID0gc3RhY2sucG9wKCk7XHJcbiAgICAgICAgICAgICAgICB3Lm9uU3RhY2sgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5wdXNoKHcpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHcgPT09IHYpXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29tcG9uZW50cy5wdXNoKGNvbXBvbmVudC5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHYuaWQ7IH0pKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVZlcnRpY2VzOyBpKyspIHtcclxuICAgICAgICBub2Rlcy5wdXNoKHsgaWQ6IGksIG91dDogW10gfSk7XHJcbiAgICB9XHJcbiAgICBmb3IgKHZhciBfaSA9IDAsIGVkZ2VzXzEgPSBlZGdlczsgX2kgPCBlZGdlc18xLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIHZhciBlID0gZWRnZXNfMVtfaV07XHJcbiAgICAgICAgdmFyIHZfMSA9IG5vZGVzW2xhLmdldFNvdXJjZUluZGV4KGUpXSwgdyA9IG5vZGVzW2xhLmdldFRhcmdldEluZGV4KGUpXTtcclxuICAgICAgICB2XzEub3V0LnB1c2godyk7XHJcbiAgICB9XHJcbiAgICBmb3IgKHZhciBfYSA9IDAsIG5vZGVzXzEgPSBub2RlczsgX2EgPCBub2Rlc18xLmxlbmd0aDsgX2ErKykge1xyXG4gICAgICAgIHZhciB2ID0gbm9kZXNfMVtfYV07XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2LmluZGV4ID09PSAndW5kZWZpbmVkJylcclxuICAgICAgICAgICAgc3Ryb25nQ29ubmVjdCh2KTtcclxuICAgIH1cclxuICAgIHJldHVybiBjb21wb25lbnRzO1xyXG59XHJcbmV4cG9ydHMuc3Ryb25nbHlDb25uZWN0ZWRDb21wb25lbnRzID0gc3Ryb25nbHlDb25uZWN0ZWRDb21wb25lbnRzO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1saW5rbGVuZ3Rocy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgUG93ZXJFZGdlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFBvd2VyRWRnZShzb3VyY2UsIHRhcmdldCwgdHlwZSkge1xyXG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xyXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUG93ZXJFZGdlO1xyXG59KCkpO1xyXG5leHBvcnRzLlBvd2VyRWRnZSA9IFBvd2VyRWRnZTtcclxudmFyIENvbmZpZ3VyYXRpb24gPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQ29uZmlndXJhdGlvbihuLCBlZGdlcywgbGlua0FjY2Vzc29yLCByb290R3JvdXApIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMubGlua0FjY2Vzc29yID0gbGlua0FjY2Vzc29yO1xyXG4gICAgICAgIHRoaXMubW9kdWxlcyA9IG5ldyBBcnJheShuKTtcclxuICAgICAgICB0aGlzLnJvb3RzID0gW107XHJcbiAgICAgICAgaWYgKHJvb3RHcm91cCkge1xyXG4gICAgICAgICAgICB0aGlzLmluaXRNb2R1bGVzRnJvbUdyb3VwKHJvb3RHcm91cCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnJvb3RzLnB1c2gobmV3IE1vZHVsZVNldCgpKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJvb3RzWzBdLmFkZCh0aGlzLm1vZHVsZXNbaV0gPSBuZXcgTW9kdWxlKGkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5SID0gZWRnZXMubGVuZ3RoO1xyXG4gICAgICAgIGVkZ2VzLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgdmFyIHMgPSBfdGhpcy5tb2R1bGVzW2xpbmtBY2Nlc3Nvci5nZXRTb3VyY2VJbmRleChlKV0sIHQgPSBfdGhpcy5tb2R1bGVzW2xpbmtBY2Nlc3Nvci5nZXRUYXJnZXRJbmRleChlKV0sIHR5cGUgPSBsaW5rQWNjZXNzb3IuZ2V0VHlwZShlKTtcclxuICAgICAgICAgICAgcy5vdXRnb2luZy5hZGQodHlwZSwgdCk7XHJcbiAgICAgICAgICAgIHQuaW5jb21pbmcuYWRkKHR5cGUsIHMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgQ29uZmlndXJhdGlvbi5wcm90b3R5cGUuaW5pdE1vZHVsZXNGcm9tR3JvdXAgPSBmdW5jdGlvbiAoZ3JvdXApIHtcclxuICAgICAgICB2YXIgbW9kdWxlU2V0ID0gbmV3IE1vZHVsZVNldCgpO1xyXG4gICAgICAgIHRoaXMucm9vdHMucHVzaChtb2R1bGVTZXQpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXAubGVhdmVzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIHZhciBub2RlID0gZ3JvdXAubGVhdmVzW2ldO1xyXG4gICAgICAgICAgICB2YXIgbW9kdWxlID0gbmV3IE1vZHVsZShub2RlLmlkKTtcclxuICAgICAgICAgICAgdGhpcy5tb2R1bGVzW25vZGUuaWRdID0gbW9kdWxlO1xyXG4gICAgICAgICAgICBtb2R1bGVTZXQuYWRkKG1vZHVsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChncm91cC5ncm91cHMpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBncm91cC5ncm91cHMubGVuZ3RoOyArK2opIHtcclxuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IGdyb3VwLmdyb3Vwc1tqXTtcclxuICAgICAgICAgICAgICAgIHZhciBkZWZpbml0aW9uID0ge307XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIGNoaWxkKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wICE9PSBcImxlYXZlc1wiICYmIHByb3AgIT09IFwiZ3JvdXBzXCIgJiYgY2hpbGQuaGFzT3duUHJvcGVydHkocHJvcCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmluaXRpb25bcHJvcF0gPSBjaGlsZFtwcm9wXTtcclxuICAgICAgICAgICAgICAgIG1vZHVsZVNldC5hZGQobmV3IE1vZHVsZSgtMSAtIGosIG5ldyBMaW5rU2V0cygpLCBuZXcgTGlua1NldHMoKSwgdGhpcy5pbml0TW9kdWxlc0Zyb21Hcm91cChjaGlsZCksIGRlZmluaXRpb24pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbW9kdWxlU2V0O1xyXG4gICAgfTtcclxuICAgIENvbmZpZ3VyYXRpb24ucHJvdG90eXBlLm1lcmdlID0gZnVuY3Rpb24gKGEsIGIsIGspIHtcclxuICAgICAgICBpZiAoayA9PT0gdm9pZCAwKSB7IGsgPSAwOyB9XHJcbiAgICAgICAgdmFyIGluSW50ID0gYS5pbmNvbWluZy5pbnRlcnNlY3Rpb24oYi5pbmNvbWluZyksIG91dEludCA9IGEub3V0Z29pbmcuaW50ZXJzZWN0aW9uKGIub3V0Z29pbmcpO1xyXG4gICAgICAgIHZhciBjaGlsZHJlbiA9IG5ldyBNb2R1bGVTZXQoKTtcclxuICAgICAgICBjaGlsZHJlbi5hZGQoYSk7XHJcbiAgICAgICAgY2hpbGRyZW4uYWRkKGIpO1xyXG4gICAgICAgIHZhciBtID0gbmV3IE1vZHVsZSh0aGlzLm1vZHVsZXMubGVuZ3RoLCBvdXRJbnQsIGluSW50LCBjaGlsZHJlbik7XHJcbiAgICAgICAgdGhpcy5tb2R1bGVzLnB1c2gobSk7XHJcbiAgICAgICAgdmFyIHVwZGF0ZSA9IGZ1bmN0aW9uIChzLCBpLCBvKSB7XHJcbiAgICAgICAgICAgIHMuZm9yQWxsKGZ1bmN0aW9uIChtcywgbGlua3R5cGUpIHtcclxuICAgICAgICAgICAgICAgIG1zLmZvckFsbChmdW5jdGlvbiAobikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBubHMgPSBuW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIG5scy5hZGQobGlua3R5cGUsIG0pO1xyXG4gICAgICAgICAgICAgICAgICAgIG5scy5yZW1vdmUobGlua3R5cGUsIGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5scy5yZW1vdmUobGlua3R5cGUsIGIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFbb10ucmVtb3ZlKGxpbmt0eXBlLCBuKTtcclxuICAgICAgICAgICAgICAgICAgICBiW29dLnJlbW92ZShsaW5rdHlwZSwgbik7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB1cGRhdGUob3V0SW50LCBcImluY29taW5nXCIsIFwib3V0Z29pbmdcIik7XHJcbiAgICAgICAgdXBkYXRlKGluSW50LCBcIm91dGdvaW5nXCIsIFwiaW5jb21pbmdcIik7XHJcbiAgICAgICAgdGhpcy5SIC09IGluSW50LmNvdW50KCkgKyBvdXRJbnQuY291bnQoKTtcclxuICAgICAgICB0aGlzLnJvb3RzW2tdLnJlbW92ZShhKTtcclxuICAgICAgICB0aGlzLnJvb3RzW2tdLnJlbW92ZShiKTtcclxuICAgICAgICB0aGlzLnJvb3RzW2tdLmFkZChtKTtcclxuICAgICAgICByZXR1cm4gbTtcclxuICAgIH07XHJcbiAgICBDb25maWd1cmF0aW9uLnByb3RvdHlwZS5yb290TWVyZ2VzID0gZnVuY3Rpb24gKGspIHtcclxuICAgICAgICBpZiAoayA9PT0gdm9pZCAwKSB7IGsgPSAwOyB9XHJcbiAgICAgICAgdmFyIHJzID0gdGhpcy5yb290c1trXS5tb2R1bGVzKCk7XHJcbiAgICAgICAgdmFyIG4gPSBycy5sZW5ndGg7XHJcbiAgICAgICAgdmFyIG1lcmdlcyA9IG5ldyBBcnJheShuICogKG4gLSAxKSk7XHJcbiAgICAgICAgdmFyIGN0ciA9IDA7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlfID0gbiAtIDE7IGkgPCBpXzsgKytpKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSBpICsgMTsgaiA8IG47ICsraikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGEgPSByc1tpXSwgYiA9IHJzW2pdO1xyXG4gICAgICAgICAgICAgICAgbWVyZ2VzW2N0cl0gPSB7IGlkOiBjdHIsIG5FZGdlczogdGhpcy5uRWRnZXMoYSwgYiksIGE6IGEsIGI6IGIgfTtcclxuICAgICAgICAgICAgICAgIGN0cisrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtZXJnZXM7XHJcbiAgICB9O1xyXG4gICAgQ29uZmlndXJhdGlvbi5wcm90b3R5cGUuZ3JlZWR5TWVyZ2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJvb3RzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnJvb3RzW2ldLm1vZHVsZXMoKS5sZW5ndGggPCAyKVxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIHZhciBtcyA9IHRoaXMucm9vdE1lcmdlcyhpKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLm5FZGdlcyA9PSBiLm5FZGdlcyA/IGEuaWQgLSBiLmlkIDogYS5uRWRnZXMgLSBiLm5FZGdlczsgfSk7XHJcbiAgICAgICAgICAgIHZhciBtID0gbXNbMF07XHJcbiAgICAgICAgICAgIGlmIChtLm5FZGdlcyA+PSB0aGlzLlIpXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgdGhpcy5tZXJnZShtLmEsIG0uYiwgaSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBDb25maWd1cmF0aW9uLnByb3RvdHlwZS5uRWRnZXMgPSBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgIHZhciBpbkludCA9IGEuaW5jb21pbmcuaW50ZXJzZWN0aW9uKGIuaW5jb21pbmcpLCBvdXRJbnQgPSBhLm91dGdvaW5nLmludGVyc2VjdGlvbihiLm91dGdvaW5nKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5SIC0gaW5JbnQuY291bnQoKSAtIG91dEludC5jb3VudCgpO1xyXG4gICAgfTtcclxuICAgIENvbmZpZ3VyYXRpb24ucHJvdG90eXBlLmdldEdyb3VwSGllcmFyY2h5ID0gZnVuY3Rpb24gKHJldGFyZ2V0ZWRFZGdlcykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGdyb3VwcyA9IFtdO1xyXG4gICAgICAgIHZhciByb290ID0ge307XHJcbiAgICAgICAgdG9Hcm91cHModGhpcy5yb290c1swXSwgcm9vdCwgZ3JvdXBzKTtcclxuICAgICAgICB2YXIgZXMgPSB0aGlzLmFsbEVkZ2VzKCk7XHJcbiAgICAgICAgZXMuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICB2YXIgYSA9IF90aGlzLm1vZHVsZXNbZS5zb3VyY2VdO1xyXG4gICAgICAgICAgICB2YXIgYiA9IF90aGlzLm1vZHVsZXNbZS50YXJnZXRdO1xyXG4gICAgICAgICAgICByZXRhcmdldGVkRWRnZXMucHVzaChuZXcgUG93ZXJFZGdlKHR5cGVvZiBhLmdpZCA9PT0gXCJ1bmRlZmluZWRcIiA/IGUuc291cmNlIDogZ3JvdXBzW2EuZ2lkXSwgdHlwZW9mIGIuZ2lkID09PSBcInVuZGVmaW5lZFwiID8gZS50YXJnZXQgOiBncm91cHNbYi5naWRdLCBlLnR5cGUpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gZ3JvdXBzO1xyXG4gICAgfTtcclxuICAgIENvbmZpZ3VyYXRpb24ucHJvdG90eXBlLmFsbEVkZ2VzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBlcyA9IFtdO1xyXG4gICAgICAgIENvbmZpZ3VyYXRpb24uZ2V0RWRnZXModGhpcy5yb290c1swXSwgZXMpO1xyXG4gICAgICAgIHJldHVybiBlcztcclxuICAgIH07XHJcbiAgICBDb25maWd1cmF0aW9uLmdldEVkZ2VzID0gZnVuY3Rpb24gKG1vZHVsZXMsIGVzKSB7XHJcbiAgICAgICAgbW9kdWxlcy5mb3JBbGwoZnVuY3Rpb24gKG0pIHtcclxuICAgICAgICAgICAgbS5nZXRFZGdlcyhlcyk7XHJcbiAgICAgICAgICAgIENvbmZpZ3VyYXRpb24uZ2V0RWRnZXMobS5jaGlsZHJlbiwgZXMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBDb25maWd1cmF0aW9uO1xyXG59KCkpO1xyXG5leHBvcnRzLkNvbmZpZ3VyYXRpb24gPSBDb25maWd1cmF0aW9uO1xyXG5mdW5jdGlvbiB0b0dyb3Vwcyhtb2R1bGVzLCBncm91cCwgZ3JvdXBzKSB7XHJcbiAgICBtb2R1bGVzLmZvckFsbChmdW5jdGlvbiAobSkge1xyXG4gICAgICAgIGlmIChtLmlzTGVhZigpKSB7XHJcbiAgICAgICAgICAgIGlmICghZ3JvdXAubGVhdmVzKVxyXG4gICAgICAgICAgICAgICAgZ3JvdXAubGVhdmVzID0gW107XHJcbiAgICAgICAgICAgIGdyb3VwLmxlYXZlcy5wdXNoKG0uaWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIGcgPSBncm91cDtcclxuICAgICAgICAgICAgbS5naWQgPSBncm91cHMubGVuZ3RoO1xyXG4gICAgICAgICAgICBpZiAoIW0uaXNJc2xhbmQoKSB8fCBtLmlzUHJlZGVmaW5lZCgpKSB7XHJcbiAgICAgICAgICAgICAgICBnID0geyBpZDogbS5naWQgfTtcclxuICAgICAgICAgICAgICAgIGlmIChtLmlzUHJlZGVmaW5lZCgpKVxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gbS5kZWZpbml0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBnW3Byb3BdID0gbS5kZWZpbml0aW9uW3Byb3BdO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFncm91cC5ncm91cHMpXHJcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXAuZ3JvdXBzID0gW107XHJcbiAgICAgICAgICAgICAgICBncm91cC5ncm91cHMucHVzaChtLmdpZCk7XHJcbiAgICAgICAgICAgICAgICBncm91cHMucHVzaChnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0b0dyb3VwcyhtLmNoaWxkcmVuLCBnLCBncm91cHMpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbnZhciBNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTW9kdWxlKGlkLCBvdXRnb2luZywgaW5jb21pbmcsIGNoaWxkcmVuLCBkZWZpbml0aW9uKSB7XHJcbiAgICAgICAgaWYgKG91dGdvaW5nID09PSB2b2lkIDApIHsgb3V0Z29pbmcgPSBuZXcgTGlua1NldHMoKTsgfVxyXG4gICAgICAgIGlmIChpbmNvbWluZyA9PT0gdm9pZCAwKSB7IGluY29taW5nID0gbmV3IExpbmtTZXRzKCk7IH1cclxuICAgICAgICBpZiAoY2hpbGRyZW4gPT09IHZvaWQgMCkgeyBjaGlsZHJlbiA9IG5ldyBNb2R1bGVTZXQoKTsgfVxyXG4gICAgICAgIHRoaXMuaWQgPSBpZDtcclxuICAgICAgICB0aGlzLm91dGdvaW5nID0gb3V0Z29pbmc7XHJcbiAgICAgICAgdGhpcy5pbmNvbWluZyA9IGluY29taW5nO1xyXG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcclxuICAgICAgICB0aGlzLmRlZmluaXRpb24gPSBkZWZpbml0aW9uO1xyXG4gICAgfVxyXG4gICAgTW9kdWxlLnByb3RvdHlwZS5nZXRFZGdlcyA9IGZ1bmN0aW9uIChlcykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5vdXRnb2luZy5mb3JBbGwoZnVuY3Rpb24gKG1zLCBlZGdldHlwZSkge1xyXG4gICAgICAgICAgICBtcy5mb3JBbGwoZnVuY3Rpb24gKHRhcmdldCkge1xyXG4gICAgICAgICAgICAgICAgZXMucHVzaChuZXcgUG93ZXJFZGdlKF90aGlzLmlkLCB0YXJnZXQuaWQsIGVkZ2V0eXBlKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIE1vZHVsZS5wcm90b3R5cGUuaXNMZWFmID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuLmNvdW50KCkgPT09IDA7XHJcbiAgICB9O1xyXG4gICAgTW9kdWxlLnByb3RvdHlwZS5pc0lzbGFuZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5vdXRnb2luZy5jb3VudCgpID09PSAwICYmIHRoaXMuaW5jb21pbmcuY291bnQoKSA9PT0gMDtcclxuICAgIH07XHJcbiAgICBNb2R1bGUucHJvdG90eXBlLmlzUHJlZGVmaW5lZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdHlwZW9mIHRoaXMuZGVmaW5pdGlvbiAhPT0gXCJ1bmRlZmluZWRcIjtcclxuICAgIH07XHJcbiAgICByZXR1cm4gTW9kdWxlO1xyXG59KCkpO1xyXG5leHBvcnRzLk1vZHVsZSA9IE1vZHVsZTtcclxuZnVuY3Rpb24gaW50ZXJzZWN0aW9uKG0sIG4pIHtcclxuICAgIHZhciBpID0ge307XHJcbiAgICBmb3IgKHZhciB2IGluIG0pXHJcbiAgICAgICAgaWYgKHYgaW4gbilcclxuICAgICAgICAgICAgaVt2XSA9IG1bdl07XHJcbiAgICByZXR1cm4gaTtcclxufVxyXG52YXIgTW9kdWxlU2V0ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE1vZHVsZVNldCgpIHtcclxuICAgICAgICB0aGlzLnRhYmxlID0ge307XHJcbiAgICB9XHJcbiAgICBNb2R1bGVTZXQucHJvdG90eXBlLmNvdW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnRhYmxlKS5sZW5ndGg7XHJcbiAgICB9O1xyXG4gICAgTW9kdWxlU2V0LnByb3RvdHlwZS5pbnRlcnNlY3Rpb24gPSBmdW5jdGlvbiAob3RoZXIpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IE1vZHVsZVNldCgpO1xyXG4gICAgICAgIHJlc3VsdC50YWJsZSA9IGludGVyc2VjdGlvbih0aGlzLnRhYmxlLCBvdGhlci50YWJsZSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgICBNb2R1bGVTZXQucHJvdG90eXBlLmludGVyc2VjdGlvbkNvdW50ID0gZnVuY3Rpb24gKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJzZWN0aW9uKG90aGVyKS5jb3VudCgpO1xyXG4gICAgfTtcclxuICAgIE1vZHVsZVNldC5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiAoaWQpIHtcclxuICAgICAgICByZXR1cm4gaWQgaW4gdGhpcy50YWJsZTtcclxuICAgIH07XHJcbiAgICBNb2R1bGVTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChtKSB7XHJcbiAgICAgICAgdGhpcy50YWJsZVttLmlkXSA9IG07XHJcbiAgICB9O1xyXG4gICAgTW9kdWxlU2V0LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAobSkge1xyXG4gICAgICAgIGRlbGV0ZSB0aGlzLnRhYmxlW20uaWRdO1xyXG4gICAgfTtcclxuICAgIE1vZHVsZVNldC5wcm90b3R5cGUuZm9yQWxsID0gZnVuY3Rpb24gKGYpIHtcclxuICAgICAgICBmb3IgKHZhciBtaWQgaW4gdGhpcy50YWJsZSkge1xyXG4gICAgICAgICAgICBmKHRoaXMudGFibGVbbWlkXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE1vZHVsZVNldC5wcm90b3R5cGUubW9kdWxlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdnMgPSBbXTtcclxuICAgICAgICB0aGlzLmZvckFsbChmdW5jdGlvbiAobSkge1xyXG4gICAgICAgICAgICBpZiAoIW0uaXNQcmVkZWZpbmVkKCkpXHJcbiAgICAgICAgICAgICAgICB2cy5wdXNoKG0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB2cztcclxuICAgIH07XHJcbiAgICByZXR1cm4gTW9kdWxlU2V0O1xyXG59KCkpO1xyXG5leHBvcnRzLk1vZHVsZVNldCA9IE1vZHVsZVNldDtcclxudmFyIExpbmtTZXRzID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIExpbmtTZXRzKCkge1xyXG4gICAgICAgIHRoaXMuc2V0cyA9IHt9O1xyXG4gICAgICAgIHRoaXMubiA9IDA7XHJcbiAgICB9XHJcbiAgICBMaW5rU2V0cy5wcm90b3R5cGUuY291bnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubjtcclxuICAgIH07XHJcbiAgICBMaW5rU2V0cy5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiAoaWQpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5mb3JBbGxNb2R1bGVzKGZ1bmN0aW9uIChtKSB7XHJcbiAgICAgICAgICAgIGlmICghcmVzdWx0ICYmIG0uaWQgPT0gaWQpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIExpbmtTZXRzLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAobGlua3R5cGUsIG0pIHtcclxuICAgICAgICB2YXIgcyA9IGxpbmt0eXBlIGluIHRoaXMuc2V0cyA/IHRoaXMuc2V0c1tsaW5rdHlwZV0gOiB0aGlzLnNldHNbbGlua3R5cGVdID0gbmV3IE1vZHVsZVNldCgpO1xyXG4gICAgICAgIHMuYWRkKG0pO1xyXG4gICAgICAgICsrdGhpcy5uO1xyXG4gICAgfTtcclxuICAgIExpbmtTZXRzLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAobGlua3R5cGUsIG0pIHtcclxuICAgICAgICB2YXIgbXMgPSB0aGlzLnNldHNbbGlua3R5cGVdO1xyXG4gICAgICAgIG1zLnJlbW92ZShtKTtcclxuICAgICAgICBpZiAobXMuY291bnQoKSA9PT0gMCkge1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5zZXRzW2xpbmt0eXBlXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLS10aGlzLm47XHJcbiAgICB9O1xyXG4gICAgTGlua1NldHMucHJvdG90eXBlLmZvckFsbCA9IGZ1bmN0aW9uIChmKSB7XHJcbiAgICAgICAgZm9yICh2YXIgbGlua3R5cGUgaW4gdGhpcy5zZXRzKSB7XHJcbiAgICAgICAgICAgIGYodGhpcy5zZXRzW2xpbmt0eXBlXSwgTnVtYmVyKGxpbmt0eXBlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIExpbmtTZXRzLnByb3RvdHlwZS5mb3JBbGxNb2R1bGVzID0gZnVuY3Rpb24gKGYpIHtcclxuICAgICAgICB0aGlzLmZvckFsbChmdW5jdGlvbiAobXMsIGx0KSB7IHJldHVybiBtcy5mb3JBbGwoZik7IH0pO1xyXG4gICAgfTtcclxuICAgIExpbmtTZXRzLnByb3RvdHlwZS5pbnRlcnNlY3Rpb24gPSBmdW5jdGlvbiAob3RoZXIpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IExpbmtTZXRzKCk7XHJcbiAgICAgICAgdGhpcy5mb3JBbGwoZnVuY3Rpb24gKG1zLCBsdCkge1xyXG4gICAgICAgICAgICBpZiAobHQgaW4gb3RoZXIuc2V0cykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGkgPSBtcy5pbnRlcnNlY3Rpb24ob3RoZXIuc2V0c1tsdF0pLCBuID0gaS5jb3VudCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG4gPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnNldHNbbHRdID0gaTtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQubiArPSBuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gTGlua1NldHM7XHJcbn0oKSk7XHJcbmV4cG9ydHMuTGlua1NldHMgPSBMaW5rU2V0cztcclxuZnVuY3Rpb24gaW50ZXJzZWN0aW9uQ291bnQobSwgbikge1xyXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGludGVyc2VjdGlvbihtLCBuKSkubGVuZ3RoO1xyXG59XHJcbmZ1bmN0aW9uIGdldEdyb3Vwcyhub2RlcywgbGlua3MsIGxhLCByb290R3JvdXApIHtcclxuICAgIHZhciBuID0gbm9kZXMubGVuZ3RoLCBjID0gbmV3IENvbmZpZ3VyYXRpb24obiwgbGlua3MsIGxhLCByb290R3JvdXApO1xyXG4gICAgd2hpbGUgKGMuZ3JlZWR5TWVyZ2UoKSlcclxuICAgICAgICA7XHJcbiAgICB2YXIgcG93ZXJFZGdlcyA9IFtdO1xyXG4gICAgdmFyIGcgPSBjLmdldEdyb3VwSGllcmFyY2h5KHBvd2VyRWRnZXMpO1xyXG4gICAgcG93ZXJFZGdlcy5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgdmFyIGYgPSBmdW5jdGlvbiAoZW5kKSB7XHJcbiAgICAgICAgICAgIHZhciBnID0gZVtlbmRdO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGcgPT0gXCJudW1iZXJcIilcclxuICAgICAgICAgICAgICAgIGVbZW5kXSA9IG5vZGVzW2ddO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgZihcInNvdXJjZVwiKTtcclxuICAgICAgICBmKFwidGFyZ2V0XCIpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4geyBncm91cHM6IGcsIHBvd2VyRWRnZXM6IHBvd2VyRWRnZXMgfTtcclxufVxyXG5leHBvcnRzLmdldEdyb3VwcyA9IGdldEdyb3VwcztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cG93ZXJncmFwaC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgUGFpcmluZ0hlYXAgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUGFpcmluZ0hlYXAoZWxlbSkge1xyXG4gICAgICAgIHRoaXMuZWxlbSA9IGVsZW07XHJcbiAgICAgICAgdGhpcy5zdWJoZWFwcyA9IFtdO1xyXG4gICAgfVxyXG4gICAgUGFpcmluZ0hlYXAucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XHJcbiAgICAgICAgdmFyIHN0ciA9IFwiXCIsIG5lZWRDb21tYSA9IGZhbHNlO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zdWJoZWFwcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICB2YXIgc3ViaGVhcCA9IHRoaXMuc3ViaGVhcHNbaV07XHJcbiAgICAgICAgICAgIGlmICghc3ViaGVhcC5lbGVtKSB7XHJcbiAgICAgICAgICAgICAgICBuZWVkQ29tbWEgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChuZWVkQ29tbWEpIHtcclxuICAgICAgICAgICAgICAgIHN0ciA9IHN0ciArIFwiLFwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN0ciA9IHN0ciArIHN1YmhlYXAudG9TdHJpbmcoc2VsZWN0b3IpO1xyXG4gICAgICAgICAgICBuZWVkQ29tbWEgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3RyICE9PSBcIlwiKSB7XHJcbiAgICAgICAgICAgIHN0ciA9IFwiKFwiICsgc3RyICsgXCIpXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAodGhpcy5lbGVtID8gc2VsZWN0b3IodGhpcy5lbGVtKSA6IFwiXCIpICsgc3RyO1xyXG4gICAgfTtcclxuICAgIFBhaXJpbmdIZWFwLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGYpIHtcclxuICAgICAgICBpZiAoIXRoaXMuZW1wdHkoKSkge1xyXG4gICAgICAgICAgICBmKHRoaXMuZWxlbSwgdGhpcyk7XHJcbiAgICAgICAgICAgIHRoaXMuc3ViaGVhcHMuZm9yRWFjaChmdW5jdGlvbiAocykgeyByZXR1cm4gcy5mb3JFYWNoKGYpOyB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgUGFpcmluZ0hlYXAucHJvdG90eXBlLmNvdW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVtcHR5KCkgPyAwIDogMSArIHRoaXMuc3ViaGVhcHMucmVkdWNlKGZ1bmN0aW9uIChuLCBoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuICsgaC5jb3VudCgpO1xyXG4gICAgICAgIH0sIDApO1xyXG4gICAgfTtcclxuICAgIFBhaXJpbmdIZWFwLnByb3RvdHlwZS5taW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbTtcclxuICAgIH07XHJcbiAgICBQYWlyaW5nSGVhcC5wcm90b3R5cGUuZW1wdHkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbSA9PSBudWxsO1xyXG4gICAgfTtcclxuICAgIFBhaXJpbmdIZWFwLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uIChoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMgPT09IGgpXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zdWJoZWFwcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zdWJoZWFwc1tpXS5jb250YWlucyhoKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgUGFpcmluZ0hlYXAucHJvdG90eXBlLmlzSGVhcCA9IGZ1bmN0aW9uIChsZXNzVGhhbikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ViaGVhcHMuZXZlcnkoZnVuY3Rpb24gKGgpIHsgcmV0dXJuIGxlc3NUaGFuKF90aGlzLmVsZW0sIGguZWxlbSkgJiYgaC5pc0hlYXAobGVzc1RoYW4pOyB9KTtcclxuICAgIH07XHJcbiAgICBQYWlyaW5nSGVhcC5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gKG9iaiwgbGVzc1RoYW4pIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tZXJnZShuZXcgUGFpcmluZ0hlYXAob2JqKSwgbGVzc1RoYW4pO1xyXG4gICAgfTtcclxuICAgIFBhaXJpbmdIZWFwLnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uIChoZWFwMiwgbGVzc1RoYW4pIHtcclxuICAgICAgICBpZiAodGhpcy5lbXB0eSgpKVxyXG4gICAgICAgICAgICByZXR1cm4gaGVhcDI7XHJcbiAgICAgICAgZWxzZSBpZiAoaGVhcDIuZW1wdHkoKSlcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgZWxzZSBpZiAobGVzc1RoYW4odGhpcy5lbGVtLCBoZWFwMi5lbGVtKSkge1xyXG4gICAgICAgICAgICB0aGlzLnN1YmhlYXBzLnB1c2goaGVhcDIpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGhlYXAyLnN1YmhlYXBzLnB1c2godGhpcyk7XHJcbiAgICAgICAgICAgIHJldHVybiBoZWFwMjtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgUGFpcmluZ0hlYXAucHJvdG90eXBlLnJlbW92ZU1pbiA9IGZ1bmN0aW9uIChsZXNzVGhhbikge1xyXG4gICAgICAgIGlmICh0aGlzLmVtcHR5KCkpXHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWVyZ2VQYWlycyhsZXNzVGhhbik7XHJcbiAgICB9O1xyXG4gICAgUGFpcmluZ0hlYXAucHJvdG90eXBlLm1lcmdlUGFpcnMgPSBmdW5jdGlvbiAobGVzc1RoYW4pIHtcclxuICAgICAgICBpZiAodGhpcy5zdWJoZWFwcy5sZW5ndGggPT0gMClcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQYWlyaW5nSGVhcChudWxsKTtcclxuICAgICAgICBlbHNlIGlmICh0aGlzLnN1YmhlYXBzLmxlbmd0aCA9PSAxKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN1YmhlYXBzWzBdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIGZpcnN0UGFpciA9IHRoaXMuc3ViaGVhcHMucG9wKCkubWVyZ2UodGhpcy5zdWJoZWFwcy5wb3AoKSwgbGVzc1RoYW4pO1xyXG4gICAgICAgICAgICB2YXIgcmVtYWluaW5nID0gdGhpcy5tZXJnZVBhaXJzKGxlc3NUaGFuKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZpcnN0UGFpci5tZXJnZShyZW1haW5pbmcsIGxlc3NUaGFuKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgUGFpcmluZ0hlYXAucHJvdG90eXBlLmRlY3JlYXNlS2V5ID0gZnVuY3Rpb24gKHN1YmhlYXAsIG5ld1ZhbHVlLCBzZXRIZWFwTm9kZSwgbGVzc1RoYW4pIHtcclxuICAgICAgICB2YXIgbmV3SGVhcCA9IHN1YmhlYXAucmVtb3ZlTWluKGxlc3NUaGFuKTtcclxuICAgICAgICBzdWJoZWFwLmVsZW0gPSBuZXdIZWFwLmVsZW07XHJcbiAgICAgICAgc3ViaGVhcC5zdWJoZWFwcyA9IG5ld0hlYXAuc3ViaGVhcHM7XHJcbiAgICAgICAgaWYgKHNldEhlYXBOb2RlICE9PSBudWxsICYmIG5ld0hlYXAuZWxlbSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBzZXRIZWFwTm9kZShzdWJoZWFwLmVsZW0sIHN1YmhlYXApO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcGFpcmluZ05vZGUgPSBuZXcgUGFpcmluZ0hlYXAobmV3VmFsdWUpO1xyXG4gICAgICAgIGlmIChzZXRIZWFwTm9kZSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBzZXRIZWFwTm9kZShuZXdWYWx1ZSwgcGFpcmluZ05vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5tZXJnZShwYWlyaW5nTm9kZSwgbGVzc1RoYW4pO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBQYWlyaW5nSGVhcDtcclxufSgpKTtcclxuZXhwb3J0cy5QYWlyaW5nSGVhcCA9IFBhaXJpbmdIZWFwO1xyXG52YXIgUHJpb3JpdHlRdWV1ZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBQcmlvcml0eVF1ZXVlKGxlc3NUaGFuKSB7XHJcbiAgICAgICAgdGhpcy5sZXNzVGhhbiA9IGxlc3NUaGFuO1xyXG4gICAgfVxyXG4gICAgUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUudG9wID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmVtcHR5KCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnJvb3QuZWxlbTtcclxuICAgIH07XHJcbiAgICBQcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBhcmdzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcGFpcmluZ05vZGU7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGFyZzsgYXJnID0gYXJnc1tpXTsgKytpKSB7XHJcbiAgICAgICAgICAgIHBhaXJpbmdOb2RlID0gbmV3IFBhaXJpbmdIZWFwKGFyZyk7XHJcbiAgICAgICAgICAgIHRoaXMucm9vdCA9IHRoaXMuZW1wdHkoKSA/XHJcbiAgICAgICAgICAgICAgICBwYWlyaW5nTm9kZSA6IHRoaXMucm9vdC5tZXJnZShwYWlyaW5nTm9kZSwgdGhpcy5sZXNzVGhhbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwYWlyaW5nTm9kZTtcclxuICAgIH07XHJcbiAgICBQcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5lbXB0eSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gIXRoaXMucm9vdCB8fCAhdGhpcy5yb290LmVsZW07XHJcbiAgICB9O1xyXG4gICAgUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuaXNIZWFwID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJvb3QuaXNIZWFwKHRoaXMubGVzc1RoYW4pO1xyXG4gICAgfTtcclxuICAgIFByaW9yaXR5UXVldWUucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoZikge1xyXG4gICAgICAgIHRoaXMucm9vdC5mb3JFYWNoKGYpO1xyXG4gICAgfTtcclxuICAgIFByaW9yaXR5UXVldWUucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5lbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgb2JqID0gdGhpcy5yb290Lm1pbigpO1xyXG4gICAgICAgIHRoaXMucm9vdCA9IHRoaXMucm9vdC5yZW1vdmVNaW4odGhpcy5sZXNzVGhhbik7XHJcbiAgICAgICAgcmV0dXJuIG9iajtcclxuICAgIH07XHJcbiAgICBQcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5yZWR1Y2VLZXkgPSBmdW5jdGlvbiAoaGVhcE5vZGUsIG5ld0tleSwgc2V0SGVhcE5vZGUpIHtcclxuICAgICAgICBpZiAoc2V0SGVhcE5vZGUgPT09IHZvaWQgMCkgeyBzZXRIZWFwTm9kZSA9IG51bGw7IH1cclxuICAgICAgICB0aGlzLnJvb3QgPSB0aGlzLnJvb3QuZGVjcmVhc2VLZXkoaGVhcE5vZGUsIG5ld0tleSwgc2V0SGVhcE5vZGUsIHRoaXMubGVzc1RoYW4pO1xyXG4gICAgfTtcclxuICAgIFByaW9yaXR5UXVldWUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdC50b1N0cmluZyhzZWxlY3Rvcik7XHJcbiAgICB9O1xyXG4gICAgUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuY291bnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdC5jb3VudCgpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBQcmlvcml0eVF1ZXVlO1xyXG59KCkpO1xyXG5leHBvcnRzLlByaW9yaXR5UXVldWUgPSBQcmlvcml0eVF1ZXVlO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcXVldWUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBUcmVlQmFzZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBUcmVlQmFzZSgpIHtcclxuICAgICAgICB0aGlzLmZpbmRJdGVyID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICAgICAgdmFyIHJlcyA9IHRoaXMuX3Jvb3Q7XHJcbiAgICAgICAgICAgIHZhciBpdGVyID0gdGhpcy5pdGVyYXRvcigpO1xyXG4gICAgICAgICAgICB3aGlsZSAocmVzICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYyA9IHRoaXMuX2NvbXBhcmF0b3IoZGF0YSwgcmVzLmRhdGEpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGMgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBpdGVyLl9jdXJzb3IgPSByZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZXI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpdGVyLl9hbmNlc3RvcnMucHVzaChyZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcyA9IHJlcy5nZXRfY2hpbGQoYyA+IDApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBUcmVlQmFzZS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5fcm9vdCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5zaXplID0gMDtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICBUcmVlQmFzZS5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgdmFyIHJlcyA9IHRoaXMuX3Jvb3Q7XHJcbiAgICAgICAgd2hpbGUgKHJlcyAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB2YXIgYyA9IHRoaXMuX2NvbXBhcmF0b3IoZGF0YSwgcmVzLmRhdGEpO1xyXG4gICAgICAgICAgICBpZiAoYyA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcy5kYXRhO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVzID0gcmVzLmdldF9jaGlsZChjID4gMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgVHJlZUJhc2UucHJvdG90eXBlLmxvd2VyQm91bmQgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9ib3VuZChkYXRhLCB0aGlzLl9jb21wYXJhdG9yKTtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICBUcmVlQmFzZS5wcm90b3R5cGUudXBwZXJCb3VuZCA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgdmFyIGNtcCA9IHRoaXMuX2NvbXBhcmF0b3I7XHJcbiAgICAgICAgZnVuY3Rpb24gcmV2ZXJzZV9jbXAoYSwgYikge1xyXG4gICAgICAgICAgICByZXR1cm4gY21wKGIsIGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fYm91bmQoZGF0YSwgcmV2ZXJzZV9jbXApO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIFRyZWVCYXNlLnByb3RvdHlwZS5taW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHJlcyA9IHRoaXMuX3Jvb3Q7XHJcbiAgICAgICAgaWYgKHJlcyA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgd2hpbGUgKHJlcy5sZWZ0ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJlcyA9IHJlcy5sZWZ0O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzLmRhdGE7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgVHJlZUJhc2UucHJvdG90eXBlLm1heCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcmVzID0gdGhpcy5fcm9vdDtcclxuICAgICAgICBpZiAocmVzID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB3aGlsZSAocmVzLnJpZ2h0ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJlcyA9IHJlcy5yaWdodDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlcy5kYXRhO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIFRyZWVCYXNlLnByb3RvdHlwZS5pdGVyYXRvciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKHRoaXMpO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIFRyZWVCYXNlLnByb3RvdHlwZS5lYWNoID0gZnVuY3Rpb24gKGNiKSB7XHJcbiAgICAgICAgdmFyIGl0ID0gdGhpcy5pdGVyYXRvcigpLCBkYXRhO1xyXG4gICAgICAgIHdoaWxlICgoZGF0YSA9IGl0Lm5leHQoKSkgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgY2IoZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIDtcclxuICAgIFRyZWVCYXNlLnByb3RvdHlwZS5yZWFjaCA9IGZ1bmN0aW9uIChjYikge1xyXG4gICAgICAgIHZhciBpdCA9IHRoaXMuaXRlcmF0b3IoKSwgZGF0YTtcclxuICAgICAgICB3aGlsZSAoKGRhdGEgPSBpdC5wcmV2KCkpICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGNiKGRhdGEpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICA7XHJcbiAgICBUcmVlQmFzZS5wcm90b3R5cGUuX2JvdW5kID0gZnVuY3Rpb24gKGRhdGEsIGNtcCkge1xyXG4gICAgICAgIHZhciBjdXIgPSB0aGlzLl9yb290O1xyXG4gICAgICAgIHZhciBpdGVyID0gdGhpcy5pdGVyYXRvcigpO1xyXG4gICAgICAgIHdoaWxlIChjdXIgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgdmFyIGMgPSB0aGlzLl9jb21wYXJhdG9yKGRhdGEsIGN1ci5kYXRhKTtcclxuICAgICAgICAgICAgaWYgKGMgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIGl0ZXIuX2N1cnNvciA9IGN1cjtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpdGVyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGl0ZXIuX2FuY2VzdG9ycy5wdXNoKGN1cik7XHJcbiAgICAgICAgICAgIGN1ciA9IGN1ci5nZXRfY2hpbGQoYyA+IDApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciBpID0gaXRlci5fYW5jZXN0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XHJcbiAgICAgICAgICAgIGN1ciA9IGl0ZXIuX2FuY2VzdG9yc1tpXTtcclxuICAgICAgICAgICAgaWYgKGNtcChkYXRhLCBjdXIuZGF0YSkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBpdGVyLl9jdXJzb3IgPSBjdXI7XHJcbiAgICAgICAgICAgICAgICBpdGVyLl9hbmNlc3RvcnMubGVuZ3RoID0gaTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpdGVyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGl0ZXIuX2FuY2VzdG9ycy5sZW5ndGggPSAwO1xyXG4gICAgICAgIHJldHVybiBpdGVyO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIHJldHVybiBUcmVlQmFzZTtcclxufSgpKTtcclxuZXhwb3J0cy5UcmVlQmFzZSA9IFRyZWVCYXNlO1xyXG52YXIgSXRlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gSXRlcmF0b3IodHJlZSkge1xyXG4gICAgICAgIHRoaXMuX3RyZWUgPSB0cmVlO1xyXG4gICAgICAgIHRoaXMuX2FuY2VzdG9ycyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX2N1cnNvciA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBJdGVyYXRvci5wcm90b3R5cGUuZGF0YSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY3Vyc29yICE9PSBudWxsID8gdGhpcy5fY3Vyc29yLmRhdGEgOiBudWxsO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIEl0ZXJhdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9jdXJzb3IgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgdmFyIHJvb3QgPSB0aGlzLl90cmVlLl9yb290O1xyXG4gICAgICAgICAgICBpZiAocm9vdCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbWluTm9kZShyb290KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2N1cnNvci5yaWdodCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNhdmU7XHJcbiAgICAgICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2F2ZSA9IHRoaXMuX2N1cnNvcjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fYW5jZXN0b3JzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jdXJzb3IgPSB0aGlzLl9hbmNlc3RvcnMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jdXJzb3IgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IHdoaWxlICh0aGlzLl9jdXJzb3IucmlnaHQgPT09IHNhdmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYW5jZXN0b3JzLnB1c2godGhpcy5fY3Vyc29yKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX21pbk5vZGUodGhpcy5fY3Vyc29yLnJpZ2h0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fY3Vyc29yICE9PSBudWxsID8gdGhpcy5fY3Vyc29yLmRhdGEgOiBudWxsO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIEl0ZXJhdG9yLnByb3RvdHlwZS5wcmV2ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9jdXJzb3IgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgdmFyIHJvb3QgPSB0aGlzLl90cmVlLl9yb290O1xyXG4gICAgICAgICAgICBpZiAocm9vdCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbWF4Tm9kZShyb290KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2N1cnNvci5sZWZ0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2F2ZTtcclxuICAgICAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgICAgICBzYXZlID0gdGhpcy5fY3Vyc29yO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9hbmNlc3RvcnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnNvciA9IHRoaXMuX2FuY2VzdG9ycy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnNvciA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gd2hpbGUgKHRoaXMuX2N1cnNvci5sZWZ0ID09PSBzYXZlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FuY2VzdG9ycy5wdXNoKHRoaXMuX2N1cnNvcik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXhOb2RlKHRoaXMuX2N1cnNvci5sZWZ0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fY3Vyc29yICE9PSBudWxsID8gdGhpcy5fY3Vyc29yLmRhdGEgOiBudWxsO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIEl0ZXJhdG9yLnByb3RvdHlwZS5fbWluTm9kZSA9IGZ1bmN0aW9uIChzdGFydCkge1xyXG4gICAgICAgIHdoaWxlIChzdGFydC5sZWZ0ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2FuY2VzdG9ycy5wdXNoKHN0YXJ0KTtcclxuICAgICAgICAgICAgc3RhcnQgPSBzdGFydC5sZWZ0O1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9jdXJzb3IgPSBzdGFydDtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICBJdGVyYXRvci5wcm90b3R5cGUuX21heE5vZGUgPSBmdW5jdGlvbiAoc3RhcnQpIHtcclxuICAgICAgICB3aGlsZSAoc3RhcnQucmlnaHQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5fYW5jZXN0b3JzLnB1c2goc3RhcnQpO1xyXG4gICAgICAgICAgICBzdGFydCA9IHN0YXJ0LnJpZ2h0O1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9jdXJzb3IgPSBzdGFydDtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICByZXR1cm4gSXRlcmF0b3I7XHJcbn0oKSk7XHJcbmV4cG9ydHMuSXRlcmF0b3IgPSBJdGVyYXRvcjtcclxudmFyIE5vZGUgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTm9kZShkYXRhKSB7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcclxuICAgICAgICB0aGlzLmxlZnQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMucmlnaHQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMucmVkID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIE5vZGUucHJvdG90eXBlLmdldF9jaGlsZCA9IGZ1bmN0aW9uIChkaXIpIHtcclxuICAgICAgICByZXR1cm4gZGlyID8gdGhpcy5yaWdodCA6IHRoaXMubGVmdDtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICBOb2RlLnByb3RvdHlwZS5zZXRfY2hpbGQgPSBmdW5jdGlvbiAoZGlyLCB2YWwpIHtcclxuICAgICAgICBpZiAoZGlyKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmlnaHQgPSB2YWw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmxlZnQgPSB2YWw7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIDtcclxuICAgIHJldHVybiBOb2RlO1xyXG59KCkpO1xyXG52YXIgUkJUcmVlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhSQlRyZWUsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBSQlRyZWUoY29tcGFyYXRvcikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuX3Jvb3QgPSBudWxsO1xyXG4gICAgICAgIF90aGlzLl9jb21wYXJhdG9yID0gY29tcGFyYXRvcjtcclxuICAgICAgICBfdGhpcy5zaXplID0gMDtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBSQlRyZWUucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgdmFyIHJldCA9IGZhbHNlO1xyXG4gICAgICAgIGlmICh0aGlzLl9yb290ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Jvb3QgPSBuZXcgTm9kZShkYXRhKTtcclxuICAgICAgICAgICAgcmV0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5zaXplKys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgaGVhZCA9IG5ldyBOb2RlKHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgIHZhciBkaXIgPSBmYWxzZTtcclxuICAgICAgICAgICAgdmFyIGxhc3QgPSBmYWxzZTtcclxuICAgICAgICAgICAgdmFyIGdwID0gbnVsbDtcclxuICAgICAgICAgICAgdmFyIGdncCA9IGhlYWQ7XHJcbiAgICAgICAgICAgIHZhciBwID0gbnVsbDtcclxuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLl9yb290O1xyXG4gICAgICAgICAgICBnZ3AucmlnaHQgPSB0aGlzLl9yb290O1xyXG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlID0gbmV3IE5vZGUoZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcC5zZXRfY2hpbGQoZGlyLCBub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2l6ZSsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoUkJUcmVlLmlzX3JlZChub2RlLmxlZnQpICYmIFJCVHJlZS5pc19yZWQobm9kZS5yaWdodCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlLnJlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5sZWZ0LnJlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUucmlnaHQucmVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoUkJUcmVlLmlzX3JlZChub2RlKSAmJiBSQlRyZWUuaXNfcmVkKHApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpcjIgPSBnZ3AucmlnaHQgPT09IGdwO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlID09PSBwLmdldF9jaGlsZChsYXN0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBnZ3Auc2V0X2NoaWxkKGRpcjIsIFJCVHJlZS5zaW5nbGVfcm90YXRlKGdwLCAhbGFzdCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2dwLnNldF9jaGlsZChkaXIyLCBSQlRyZWUuZG91YmxlX3JvdGF0ZShncCwgIWxhc3QpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgY21wID0gdGhpcy5fY29tcGFyYXRvcihub2RlLmRhdGEsIGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNtcCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGFzdCA9IGRpcjtcclxuICAgICAgICAgICAgICAgIGRpciA9IGNtcCA8IDA7XHJcbiAgICAgICAgICAgICAgICBpZiAoZ3AgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBnZ3AgPSBncDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGdwID0gcDtcclxuICAgICAgICAgICAgICAgIHAgPSBub2RlO1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUuZ2V0X2NoaWxkKGRpcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fcm9vdCA9IGhlYWQucmlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3Jvb3QucmVkID0gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuIHJldDtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICBSQlRyZWUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3Jvb3QgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgaGVhZCA9IG5ldyBOb2RlKHVuZGVmaW5lZCk7XHJcbiAgICAgICAgdmFyIG5vZGUgPSBoZWFkO1xyXG4gICAgICAgIG5vZGUucmlnaHQgPSB0aGlzLl9yb290O1xyXG4gICAgICAgIHZhciBwID0gbnVsbDtcclxuICAgICAgICB2YXIgZ3AgPSBudWxsO1xyXG4gICAgICAgIHZhciBmb3VuZCA9IG51bGw7XHJcbiAgICAgICAgdmFyIGRpciA9IHRydWU7XHJcbiAgICAgICAgd2hpbGUgKG5vZGUuZ2V0X2NoaWxkKGRpcikgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgdmFyIGxhc3QgPSBkaXI7XHJcbiAgICAgICAgICAgIGdwID0gcDtcclxuICAgICAgICAgICAgcCA9IG5vZGU7XHJcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmdldF9jaGlsZChkaXIpO1xyXG4gICAgICAgICAgICB2YXIgY21wID0gdGhpcy5fY29tcGFyYXRvcihkYXRhLCBub2RlLmRhdGEpO1xyXG4gICAgICAgICAgICBkaXIgPSBjbXAgPiAwO1xyXG4gICAgICAgICAgICBpZiAoY21wID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBmb3VuZCA9IG5vZGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFSQlRyZWUuaXNfcmVkKG5vZGUpICYmICFSQlRyZWUuaXNfcmVkKG5vZGUuZ2V0X2NoaWxkKGRpcikpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoUkJUcmVlLmlzX3JlZChub2RlLmdldF9jaGlsZCghZGlyKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3IgPSBSQlRyZWUuc2luZ2xlX3JvdGF0ZShub2RlLCBkaXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHAuc2V0X2NoaWxkKGxhc3QsIHNyKTtcclxuICAgICAgICAgICAgICAgICAgICBwID0gc3I7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghUkJUcmVlLmlzX3JlZChub2RlLmdldF9jaGlsZCghZGlyKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2libGluZyA9IHAuZ2V0X2NoaWxkKCFsYXN0KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2libGluZyAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIVJCVHJlZS5pc19yZWQoc2libGluZy5nZXRfY2hpbGQoIWxhc3QpKSAmJiAhUkJUcmVlLmlzX3JlZChzaWJsaW5nLmdldF9jaGlsZChsYXN0KSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAucmVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWJsaW5nLnJlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLnJlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGlyMiA9IGdwLnJpZ2h0ID09PSBwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFJCVHJlZS5pc19yZWQoc2libGluZy5nZXRfY2hpbGQobGFzdCkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3Auc2V0X2NoaWxkKGRpcjIsIFJCVHJlZS5kb3VibGVfcm90YXRlKHAsIGxhc3QpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKFJCVHJlZS5pc19yZWQoc2libGluZy5nZXRfY2hpbGQoIWxhc3QpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdwLnNldF9jaGlsZChkaXIyLCBSQlRyZWUuc2luZ2xlX3JvdGF0ZShwLCBsYXN0KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ3BjID0gZ3AuZ2V0X2NoaWxkKGRpcjIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3BjLnJlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLnJlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncGMubGVmdC5yZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdwYy5yaWdodC5yZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZm91bmQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgZm91bmQuZGF0YSA9IG5vZGUuZGF0YTtcclxuICAgICAgICAgICAgcC5zZXRfY2hpbGQocC5yaWdodCA9PT0gbm9kZSwgbm9kZS5nZXRfY2hpbGQobm9kZS5sZWZ0ID09PSBudWxsKSk7XHJcbiAgICAgICAgICAgIHRoaXMuc2l6ZS0tO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9yb290ID0gaGVhZC5yaWdodDtcclxuICAgICAgICBpZiAodGhpcy5fcm9vdCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLl9yb290LnJlZCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZm91bmQgIT09IG51bGw7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgUkJUcmVlLmlzX3JlZCA9IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgcmV0dXJuIG5vZGUgIT09IG51bGwgJiYgbm9kZS5yZWQ7XHJcbiAgICB9O1xyXG4gICAgUkJUcmVlLnNpbmdsZV9yb3RhdGUgPSBmdW5jdGlvbiAocm9vdCwgZGlyKSB7XHJcbiAgICAgICAgdmFyIHNhdmUgPSByb290LmdldF9jaGlsZCghZGlyKTtcclxuICAgICAgICByb290LnNldF9jaGlsZCghZGlyLCBzYXZlLmdldF9jaGlsZChkaXIpKTtcclxuICAgICAgICBzYXZlLnNldF9jaGlsZChkaXIsIHJvb3QpO1xyXG4gICAgICAgIHJvb3QucmVkID0gdHJ1ZTtcclxuICAgICAgICBzYXZlLnJlZCA9IGZhbHNlO1xyXG4gICAgICAgIHJldHVybiBzYXZlO1xyXG4gICAgfTtcclxuICAgIFJCVHJlZS5kb3VibGVfcm90YXRlID0gZnVuY3Rpb24gKHJvb3QsIGRpcikge1xyXG4gICAgICAgIHJvb3Quc2V0X2NoaWxkKCFkaXIsIFJCVHJlZS5zaW5nbGVfcm90YXRlKHJvb3QuZ2V0X2NoaWxkKCFkaXIpLCAhZGlyKSk7XHJcbiAgICAgICAgcmV0dXJuIFJCVHJlZS5zaW5nbGVfcm90YXRlKHJvb3QsIGRpcik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFJCVHJlZTtcclxufShUcmVlQmFzZSkpO1xyXG5leHBvcnRzLlJCVHJlZSA9IFJCVHJlZTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmJ0cmVlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdnBzY18xID0gcmVxdWlyZShcIi4vdnBzY1wiKTtcclxudmFyIHJidHJlZV8xID0gcmVxdWlyZShcIi4vcmJ0cmVlXCIpO1xyXG5mdW5jdGlvbiBjb21wdXRlR3JvdXBCb3VuZHMoZykge1xyXG4gICAgZy5ib3VuZHMgPSB0eXBlb2YgZy5sZWF2ZXMgIT09IFwidW5kZWZpbmVkXCIgP1xyXG4gICAgICAgIGcubGVhdmVzLnJlZHVjZShmdW5jdGlvbiAociwgYykgeyByZXR1cm4gYy5ib3VuZHMudW5pb24ocik7IH0sIFJlY3RhbmdsZS5lbXB0eSgpKSA6XHJcbiAgICAgICAgUmVjdGFuZ2xlLmVtcHR5KCk7XHJcbiAgICBpZiAodHlwZW9mIGcuZ3JvdXBzICE9PSBcInVuZGVmaW5lZFwiKVxyXG4gICAgICAgIGcuYm91bmRzID0gZy5ncm91cHMucmVkdWNlKGZ1bmN0aW9uIChyLCBjKSB7IHJldHVybiBjb21wdXRlR3JvdXBCb3VuZHMoYykudW5pb24ocik7IH0sIGcuYm91bmRzKTtcclxuICAgIGcuYm91bmRzID0gZy5ib3VuZHMuaW5mbGF0ZShnLnBhZGRpbmcpO1xyXG4gICAgcmV0dXJuIGcuYm91bmRzO1xyXG59XHJcbmV4cG9ydHMuY29tcHV0ZUdyb3VwQm91bmRzID0gY29tcHV0ZUdyb3VwQm91bmRzO1xyXG52YXIgUmVjdGFuZ2xlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFJlY3RhbmdsZSh4LCBYLCB5LCBZKSB7XHJcbiAgICAgICAgdGhpcy54ID0geDtcclxuICAgICAgICB0aGlzLlggPSBYO1xyXG4gICAgICAgIHRoaXMueSA9IHk7XHJcbiAgICAgICAgdGhpcy5ZID0gWTtcclxuICAgIH1cclxuICAgIFJlY3RhbmdsZS5lbXB0eSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBSZWN0YW5nbGUoTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKTsgfTtcclxuICAgIFJlY3RhbmdsZS5wcm90b3R5cGUuY3ggPSBmdW5jdGlvbiAoKSB7IHJldHVybiAodGhpcy54ICsgdGhpcy5YKSAvIDI7IH07XHJcbiAgICBSZWN0YW5nbGUucHJvdG90eXBlLmN5ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHRoaXMueSArIHRoaXMuWSkgLyAyOyB9O1xyXG4gICAgUmVjdGFuZ2xlLnByb3RvdHlwZS5vdmVybGFwWCA9IGZ1bmN0aW9uIChyKSB7XHJcbiAgICAgICAgdmFyIHV4ID0gdGhpcy5jeCgpLCB2eCA9IHIuY3goKTtcclxuICAgICAgICBpZiAodXggPD0gdnggJiYgci54IDwgdGhpcy5YKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5YIC0gci54O1xyXG4gICAgICAgIGlmICh2eCA8PSB1eCAmJiB0aGlzLnggPCByLlgpXHJcbiAgICAgICAgICAgIHJldHVybiByLlggLSB0aGlzLng7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9O1xyXG4gICAgUmVjdGFuZ2xlLnByb3RvdHlwZS5vdmVybGFwWSA9IGZ1bmN0aW9uIChyKSB7XHJcbiAgICAgICAgdmFyIHV5ID0gdGhpcy5jeSgpLCB2eSA9IHIuY3koKTtcclxuICAgICAgICBpZiAodXkgPD0gdnkgJiYgci55IDwgdGhpcy5ZKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ZIC0gci55O1xyXG4gICAgICAgIGlmICh2eSA8PSB1eSAmJiB0aGlzLnkgPCByLlkpXHJcbiAgICAgICAgICAgIHJldHVybiByLlkgLSB0aGlzLnk7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9O1xyXG4gICAgUmVjdGFuZ2xlLnByb3RvdHlwZS5zZXRYQ2VudHJlID0gZnVuY3Rpb24gKGN4KSB7XHJcbiAgICAgICAgdmFyIGR4ID0gY3ggLSB0aGlzLmN4KCk7XHJcbiAgICAgICAgdGhpcy54ICs9IGR4O1xyXG4gICAgICAgIHRoaXMuWCArPSBkeDtcclxuICAgIH07XHJcbiAgICBSZWN0YW5nbGUucHJvdG90eXBlLnNldFlDZW50cmUgPSBmdW5jdGlvbiAoY3kpIHtcclxuICAgICAgICB2YXIgZHkgPSBjeSAtIHRoaXMuY3koKTtcclxuICAgICAgICB0aGlzLnkgKz0gZHk7XHJcbiAgICAgICAgdGhpcy5ZICs9IGR5O1xyXG4gICAgfTtcclxuICAgIFJlY3RhbmdsZS5wcm90b3R5cGUud2lkdGggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuWCAtIHRoaXMueDtcclxuICAgIH07XHJcbiAgICBSZWN0YW5nbGUucHJvdG90eXBlLmhlaWdodCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ZIC0gdGhpcy55O1xyXG4gICAgfTtcclxuICAgIFJlY3RhbmdsZS5wcm90b3R5cGUudW5pb24gPSBmdW5jdGlvbiAocikge1xyXG4gICAgICAgIHJldHVybiBuZXcgUmVjdGFuZ2xlKE1hdGgubWluKHRoaXMueCwgci54KSwgTWF0aC5tYXgodGhpcy5YLCByLlgpLCBNYXRoLm1pbih0aGlzLnksIHIueSksIE1hdGgubWF4KHRoaXMuWSwgci5ZKSk7XHJcbiAgICB9O1xyXG4gICAgUmVjdGFuZ2xlLnByb3RvdHlwZS5saW5lSW50ZXJzZWN0aW9ucyA9IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5Mikge1xyXG4gICAgICAgIHZhciBzaWRlcyA9IFtbdGhpcy54LCB0aGlzLnksIHRoaXMuWCwgdGhpcy55XSxcclxuICAgICAgICAgICAgW3RoaXMuWCwgdGhpcy55LCB0aGlzLlgsIHRoaXMuWV0sXHJcbiAgICAgICAgICAgIFt0aGlzLlgsIHRoaXMuWSwgdGhpcy54LCB0aGlzLlldLFxyXG4gICAgICAgICAgICBbdGhpcy54LCB0aGlzLlksIHRoaXMueCwgdGhpcy55XV07XHJcbiAgICAgICAgdmFyIGludGVyc2VjdGlvbnMgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7ICsraSkge1xyXG4gICAgICAgICAgICB2YXIgciA9IFJlY3RhbmdsZS5saW5lSW50ZXJzZWN0aW9uKHgxLCB5MSwgeDIsIHkyLCBzaWRlc1tpXVswXSwgc2lkZXNbaV1bMV0sIHNpZGVzW2ldWzJdLCBzaWRlc1tpXVszXSk7XHJcbiAgICAgICAgICAgIGlmIChyICE9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgaW50ZXJzZWN0aW9ucy5wdXNoKHsgeDogci54LCB5OiByLnkgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpbnRlcnNlY3Rpb25zO1xyXG4gICAgfTtcclxuICAgIFJlY3RhbmdsZS5wcm90b3R5cGUucmF5SW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gKHgyLCB5Mikge1xyXG4gICAgICAgIHZhciBpbnRzID0gdGhpcy5saW5lSW50ZXJzZWN0aW9ucyh0aGlzLmN4KCksIHRoaXMuY3koKSwgeDIsIHkyKTtcclxuICAgICAgICByZXR1cm4gaW50cy5sZW5ndGggPiAwID8gaW50c1swXSA6IG51bGw7XHJcbiAgICB9O1xyXG4gICAgUmVjdGFuZ2xlLnByb3RvdHlwZS52ZXJ0aWNlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICB7IHg6IHRoaXMueCwgeTogdGhpcy55IH0sXHJcbiAgICAgICAgICAgIHsgeDogdGhpcy5YLCB5OiB0aGlzLnkgfSxcclxuICAgICAgICAgICAgeyB4OiB0aGlzLlgsIHk6IHRoaXMuWSB9LFxyXG4gICAgICAgICAgICB7IHg6IHRoaXMueCwgeTogdGhpcy5ZIH1cclxuICAgICAgICBdO1xyXG4gICAgfTtcclxuICAgIFJlY3RhbmdsZS5saW5lSW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHg0LCB5NCkge1xyXG4gICAgICAgIHZhciBkeDEyID0geDIgLSB4MSwgZHgzNCA9IHg0IC0geDMsIGR5MTIgPSB5MiAtIHkxLCBkeTM0ID0geTQgLSB5MywgZGVub21pbmF0b3IgPSBkeTM0ICogZHgxMiAtIGR4MzQgKiBkeTEyO1xyXG4gICAgICAgIGlmIChkZW5vbWluYXRvciA9PSAwKVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB2YXIgZHgzMSA9IHgxIC0geDMsIGR5MzEgPSB5MSAtIHkzLCBudW1hID0gZHgzNCAqIGR5MzEgLSBkeTM0ICogZHgzMSwgYSA9IG51bWEgLyBkZW5vbWluYXRvciwgbnVtYiA9IGR4MTIgKiBkeTMxIC0gZHkxMiAqIGR4MzEsIGIgPSBudW1iIC8gZGVub21pbmF0b3I7XHJcbiAgICAgICAgaWYgKGEgPj0gMCAmJiBhIDw9IDEgJiYgYiA+PSAwICYmIGIgPD0gMSkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgeDogeDEgKyBhICogZHgxMixcclxuICAgICAgICAgICAgICAgIHk6IHkxICsgYSAqIGR5MTJcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG4gICAgUmVjdGFuZ2xlLnByb3RvdHlwZS5pbmZsYXRlID0gZnVuY3Rpb24gKHBhZCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUmVjdGFuZ2xlKHRoaXMueCAtIHBhZCwgdGhpcy5YICsgcGFkLCB0aGlzLnkgLSBwYWQsIHRoaXMuWSArIHBhZCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFJlY3RhbmdsZTtcclxufSgpKTtcclxuZXhwb3J0cy5SZWN0YW5nbGUgPSBSZWN0YW5nbGU7XHJcbmZ1bmN0aW9uIG1ha2VFZGdlQmV0d2Vlbihzb3VyY2UsIHRhcmdldCwgYWgpIHtcclxuICAgIHZhciBzaSA9IHNvdXJjZS5yYXlJbnRlcnNlY3Rpb24odGFyZ2V0LmN4KCksIHRhcmdldC5jeSgpKSB8fCB7IHg6IHNvdXJjZS5jeCgpLCB5OiBzb3VyY2UuY3koKSB9LCB0aSA9IHRhcmdldC5yYXlJbnRlcnNlY3Rpb24oc291cmNlLmN4KCksIHNvdXJjZS5jeSgpKSB8fCB7IHg6IHRhcmdldC5jeCgpLCB5OiB0YXJnZXQuY3koKSB9LCBkeCA9IHRpLnggLSBzaS54LCBkeSA9IHRpLnkgLSBzaS55LCBsID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KSwgYWwgPSBsIC0gYWg7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHNvdXJjZUludGVyc2VjdGlvbjogc2ksXHJcbiAgICAgICAgdGFyZ2V0SW50ZXJzZWN0aW9uOiB0aSxcclxuICAgICAgICBhcnJvd1N0YXJ0OiB7IHg6IHNpLnggKyBhbCAqIGR4IC8gbCwgeTogc2kueSArIGFsICogZHkgLyBsIH1cclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5tYWtlRWRnZUJldHdlZW4gPSBtYWtlRWRnZUJldHdlZW47XHJcbmZ1bmN0aW9uIG1ha2VFZGdlVG8ocywgdGFyZ2V0LCBhaCkge1xyXG4gICAgdmFyIHRpID0gdGFyZ2V0LnJheUludGVyc2VjdGlvbihzLngsIHMueSk7XHJcbiAgICBpZiAoIXRpKVxyXG4gICAgICAgIHRpID0geyB4OiB0YXJnZXQuY3goKSwgeTogdGFyZ2V0LmN5KCkgfTtcclxuICAgIHZhciBkeCA9IHRpLnggLSBzLngsIGR5ID0gdGkueSAtIHMueSwgbCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XHJcbiAgICByZXR1cm4geyB4OiB0aS54IC0gYWggKiBkeCAvIGwsIHk6IHRpLnkgLSBhaCAqIGR5IC8gbCB9O1xyXG59XHJcbmV4cG9ydHMubWFrZUVkZ2VUbyA9IG1ha2VFZGdlVG87XHJcbnZhciBOb2RlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE5vZGUodiwgciwgcG9zKSB7XHJcbiAgICAgICAgdGhpcy52ID0gdjtcclxuICAgICAgICB0aGlzLnIgPSByO1xyXG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xyXG4gICAgICAgIHRoaXMucHJldiA9IG1ha2VSQlRyZWUoKTtcclxuICAgICAgICB0aGlzLm5leHQgPSBtYWtlUkJUcmVlKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gTm9kZTtcclxufSgpKTtcclxudmFyIEV2ZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEV2ZW50KGlzT3BlbiwgdiwgcG9zKSB7XHJcbiAgICAgICAgdGhpcy5pc09wZW4gPSBpc09wZW47XHJcbiAgICAgICAgdGhpcy52ID0gdjtcclxuICAgICAgICB0aGlzLnBvcyA9IHBvcztcclxuICAgIH1cclxuICAgIHJldHVybiBFdmVudDtcclxufSgpKTtcclxuZnVuY3Rpb24gY29tcGFyZUV2ZW50cyhhLCBiKSB7XHJcbiAgICBpZiAoYS5wb3MgPiBiLnBvcykge1xyXG4gICAgICAgIHJldHVybiAxO1xyXG4gICAgfVxyXG4gICAgaWYgKGEucG9zIDwgYi5wb3MpIHtcclxuICAgICAgICByZXR1cm4gLTE7XHJcbiAgICB9XHJcbiAgICBpZiAoYS5pc09wZW4pIHtcclxuICAgICAgICByZXR1cm4gLTE7XHJcbiAgICB9XHJcbiAgICBpZiAoYi5pc09wZW4pIHtcclxuICAgICAgICByZXR1cm4gMTtcclxuICAgIH1cclxuICAgIHJldHVybiAwO1xyXG59XHJcbmZ1bmN0aW9uIG1ha2VSQlRyZWUoKSB7XHJcbiAgICByZXR1cm4gbmV3IHJidHJlZV8xLlJCVHJlZShmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5wb3MgLSBiLnBvczsgfSk7XHJcbn1cclxudmFyIHhSZWN0ID0ge1xyXG4gICAgZ2V0Q2VudHJlOiBmdW5jdGlvbiAocikgeyByZXR1cm4gci5jeCgpOyB9LFxyXG4gICAgZ2V0T3BlbjogZnVuY3Rpb24gKHIpIHsgcmV0dXJuIHIueTsgfSxcclxuICAgIGdldENsb3NlOiBmdW5jdGlvbiAocikgeyByZXR1cm4gci5ZOyB9LFxyXG4gICAgZ2V0U2l6ZTogZnVuY3Rpb24gKHIpIHsgcmV0dXJuIHIud2lkdGgoKTsgfSxcclxuICAgIG1ha2VSZWN0OiBmdW5jdGlvbiAob3BlbiwgY2xvc2UsIGNlbnRlciwgc2l6ZSkgeyByZXR1cm4gbmV3IFJlY3RhbmdsZShjZW50ZXIgLSBzaXplIC8gMiwgY2VudGVyICsgc2l6ZSAvIDIsIG9wZW4sIGNsb3NlKTsgfSxcclxuICAgIGZpbmROZWlnaGJvdXJzOiBmaW5kWE5laWdoYm91cnNcclxufTtcclxudmFyIHlSZWN0ID0ge1xyXG4gICAgZ2V0Q2VudHJlOiBmdW5jdGlvbiAocikgeyByZXR1cm4gci5jeSgpOyB9LFxyXG4gICAgZ2V0T3BlbjogZnVuY3Rpb24gKHIpIHsgcmV0dXJuIHIueDsgfSxcclxuICAgIGdldENsb3NlOiBmdW5jdGlvbiAocikgeyByZXR1cm4gci5YOyB9LFxyXG4gICAgZ2V0U2l6ZTogZnVuY3Rpb24gKHIpIHsgcmV0dXJuIHIuaGVpZ2h0KCk7IH0sXHJcbiAgICBtYWtlUmVjdDogZnVuY3Rpb24gKG9wZW4sIGNsb3NlLCBjZW50ZXIsIHNpemUpIHsgcmV0dXJuIG5ldyBSZWN0YW5nbGUob3BlbiwgY2xvc2UsIGNlbnRlciAtIHNpemUgLyAyLCBjZW50ZXIgKyBzaXplIC8gMik7IH0sXHJcbiAgICBmaW5kTmVpZ2hib3VyczogZmluZFlOZWlnaGJvdXJzXHJcbn07XHJcbmZ1bmN0aW9uIGdlbmVyYXRlR3JvdXBDb25zdHJhaW50cyhyb290LCBmLCBtaW5TZXAsIGlzQ29udGFpbmVkKSB7XHJcbiAgICBpZiAoaXNDb250YWluZWQgPT09IHZvaWQgMCkgeyBpc0NvbnRhaW5lZCA9IGZhbHNlOyB9XHJcbiAgICB2YXIgcGFkZGluZyA9IHJvb3QucGFkZGluZywgZ24gPSB0eXBlb2Ygcm9vdC5ncm91cHMgIT09ICd1bmRlZmluZWQnID8gcm9vdC5ncm91cHMubGVuZ3RoIDogMCwgbG4gPSB0eXBlb2Ygcm9vdC5sZWF2ZXMgIT09ICd1bmRlZmluZWQnID8gcm9vdC5sZWF2ZXMubGVuZ3RoIDogMCwgY2hpbGRDb25zdHJhaW50cyA9ICFnbiA/IFtdXHJcbiAgICAgICAgOiByb290Lmdyb3Vwcy5yZWR1Y2UoZnVuY3Rpb24gKGNjcywgZykgeyByZXR1cm4gY2NzLmNvbmNhdChnZW5lcmF0ZUdyb3VwQ29uc3RyYWludHMoZywgZiwgbWluU2VwLCB0cnVlKSk7IH0sIFtdKSwgbiA9IChpc0NvbnRhaW5lZCA/IDIgOiAwKSArIGxuICsgZ24sIHZzID0gbmV3IEFycmF5KG4pLCBycyA9IG5ldyBBcnJheShuKSwgaSA9IDAsIGFkZCA9IGZ1bmN0aW9uIChyLCB2KSB7IHJzW2ldID0gcjsgdnNbaSsrXSA9IHY7IH07XHJcbiAgICBpZiAoaXNDb250YWluZWQpIHtcclxuICAgICAgICB2YXIgYiA9IHJvb3QuYm91bmRzLCBjID0gZi5nZXRDZW50cmUoYiksIHMgPSBmLmdldFNpemUoYikgLyAyLCBvcGVuID0gZi5nZXRPcGVuKGIpLCBjbG9zZSA9IGYuZ2V0Q2xvc2UoYiksIG1pbiA9IGMgLSBzICsgcGFkZGluZyAvIDIsIG1heCA9IGMgKyBzIC0gcGFkZGluZyAvIDI7XHJcbiAgICAgICAgcm9vdC5taW5WYXIuZGVzaXJlZFBvc2l0aW9uID0gbWluO1xyXG4gICAgICAgIGFkZChmLm1ha2VSZWN0KG9wZW4sIGNsb3NlLCBtaW4sIHBhZGRpbmcpLCByb290Lm1pblZhcik7XHJcbiAgICAgICAgcm9vdC5tYXhWYXIuZGVzaXJlZFBvc2l0aW9uID0gbWF4O1xyXG4gICAgICAgIGFkZChmLm1ha2VSZWN0KG9wZW4sIGNsb3NlLCBtYXgsIHBhZGRpbmcpLCByb290Lm1heFZhcik7XHJcbiAgICB9XHJcbiAgICBpZiAobG4pXHJcbiAgICAgICAgcm9vdC5sZWF2ZXMuZm9yRWFjaChmdW5jdGlvbiAobCkgeyByZXR1cm4gYWRkKGwuYm91bmRzLCBsLnZhcmlhYmxlKTsgfSk7XHJcbiAgICBpZiAoZ24pXHJcbiAgICAgICAgcm9vdC5ncm91cHMuZm9yRWFjaChmdW5jdGlvbiAoZykge1xyXG4gICAgICAgICAgICB2YXIgYiA9IGcuYm91bmRzO1xyXG4gICAgICAgICAgICBhZGQoZi5tYWtlUmVjdChmLmdldE9wZW4oYiksIGYuZ2V0Q2xvc2UoYiksIGYuZ2V0Q2VudHJlKGIpLCBmLmdldFNpemUoYikpLCBnLm1pblZhcik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB2YXIgY3MgPSBnZW5lcmF0ZUNvbnN0cmFpbnRzKHJzLCB2cywgZiwgbWluU2VwKTtcclxuICAgIGlmIChnbikge1xyXG4gICAgICAgIHZzLmZvckVhY2goZnVuY3Rpb24gKHYpIHsgdi5jT3V0ID0gW10sIHYuY0luID0gW107IH0pO1xyXG4gICAgICAgIGNzLmZvckVhY2goZnVuY3Rpb24gKGMpIHsgYy5sZWZ0LmNPdXQucHVzaChjKSwgYy5yaWdodC5jSW4ucHVzaChjKTsgfSk7XHJcbiAgICAgICAgcm9vdC5ncm91cHMuZm9yRWFjaChmdW5jdGlvbiAoZykge1xyXG4gICAgICAgICAgICB2YXIgZ2FwQWRqdXN0bWVudCA9IChnLnBhZGRpbmcgLSBmLmdldFNpemUoZy5ib3VuZHMpKSAvIDI7XHJcbiAgICAgICAgICAgIGcubWluVmFyLmNJbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLmdhcCArPSBnYXBBZGp1c3RtZW50OyB9KTtcclxuICAgICAgICAgICAgZy5taW5WYXIuY091dC5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7IGMubGVmdCA9IGcubWF4VmFyOyBjLmdhcCArPSBnYXBBZGp1c3RtZW50OyB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiBjaGlsZENvbnN0cmFpbnRzLmNvbmNhdChjcyk7XHJcbn1cclxuZnVuY3Rpb24gZ2VuZXJhdGVDb25zdHJhaW50cyhycywgdmFycywgcmVjdCwgbWluU2VwKSB7XHJcbiAgICB2YXIgaSwgbiA9IHJzLmxlbmd0aDtcclxuICAgIHZhciBOID0gMiAqIG47XHJcbiAgICBjb25zb2xlLmFzc2VydCh2YXJzLmxlbmd0aCA+PSBuKTtcclxuICAgIHZhciBldmVudHMgPSBuZXcgQXJyYXkoTik7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XHJcbiAgICAgICAgdmFyIHIgPSByc1tpXTtcclxuICAgICAgICB2YXIgdiA9IG5ldyBOb2RlKHZhcnNbaV0sIHIsIHJlY3QuZ2V0Q2VudHJlKHIpKTtcclxuICAgICAgICBldmVudHNbaV0gPSBuZXcgRXZlbnQodHJ1ZSwgdiwgcmVjdC5nZXRPcGVuKHIpKTtcclxuICAgICAgICBldmVudHNbaSArIG5dID0gbmV3IEV2ZW50KGZhbHNlLCB2LCByZWN0LmdldENsb3NlKHIpKTtcclxuICAgIH1cclxuICAgIGV2ZW50cy5zb3J0KGNvbXBhcmVFdmVudHMpO1xyXG4gICAgdmFyIGNzID0gbmV3IEFycmF5KCk7XHJcbiAgICB2YXIgc2NhbmxpbmUgPSBtYWtlUkJUcmVlKCk7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgTjsgKytpKSB7XHJcbiAgICAgICAgdmFyIGUgPSBldmVudHNbaV07XHJcbiAgICAgICAgdmFyIHYgPSBlLnY7XHJcbiAgICAgICAgaWYgKGUuaXNPcGVuKSB7XHJcbiAgICAgICAgICAgIHNjYW5saW5lLmluc2VydCh2KTtcclxuICAgICAgICAgICAgcmVjdC5maW5kTmVpZ2hib3Vycyh2LCBzY2FubGluZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBzY2FubGluZS5yZW1vdmUodik7XHJcbiAgICAgICAgICAgIHZhciBtYWtlQ29uc3RyYWludCA9IGZ1bmN0aW9uIChsLCByKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2VwID0gKHJlY3QuZ2V0U2l6ZShsLnIpICsgcmVjdC5nZXRTaXplKHIucikpIC8gMiArIG1pblNlcDtcclxuICAgICAgICAgICAgICAgIGNzLnB1c2gobmV3IHZwc2NfMS5Db25zdHJhaW50KGwudiwgci52LCBzZXApKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdmFyIHZpc2l0TmVpZ2hib3VycyA9IGZ1bmN0aW9uIChmb3J3YXJkLCByZXZlcnNlLCBta2Nvbikge1xyXG4gICAgICAgICAgICAgICAgdmFyIHUsIGl0ID0gdltmb3J3YXJkXS5pdGVyYXRvcigpO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKCh1ID0gaXRbZm9yd2FyZF0oKSkgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBta2Nvbih1LCB2KTtcclxuICAgICAgICAgICAgICAgICAgICB1W3JldmVyc2VdLnJlbW92ZSh2KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdmlzaXROZWlnaGJvdXJzKFwicHJldlwiLCBcIm5leHRcIiwgZnVuY3Rpb24gKHUsIHYpIHsgcmV0dXJuIG1ha2VDb25zdHJhaW50KHUsIHYpOyB9KTtcclxuICAgICAgICAgICAgdmlzaXROZWlnaGJvdXJzKFwibmV4dFwiLCBcInByZXZcIiwgZnVuY3Rpb24gKHUsIHYpIHsgcmV0dXJuIG1ha2VDb25zdHJhaW50KHYsIHUpOyB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zb2xlLmFzc2VydChzY2FubGluZS5zaXplID09PSAwKTtcclxuICAgIHJldHVybiBjcztcclxufVxyXG5mdW5jdGlvbiBmaW5kWE5laWdoYm91cnModiwgc2NhbmxpbmUpIHtcclxuICAgIHZhciBmID0gZnVuY3Rpb24gKGZvcndhcmQsIHJldmVyc2UpIHtcclxuICAgICAgICB2YXIgaXQgPSBzY2FubGluZS5maW5kSXRlcih2KTtcclxuICAgICAgICB2YXIgdTtcclxuICAgICAgICB3aGlsZSAoKHUgPSBpdFtmb3J3YXJkXSgpKSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB2YXIgdW92ZXJ2WCA9IHUuci5vdmVybGFwWCh2LnIpO1xyXG4gICAgICAgICAgICBpZiAodW92ZXJ2WCA8PSAwIHx8IHVvdmVydlggPD0gdS5yLm92ZXJsYXBZKHYucikpIHtcclxuICAgICAgICAgICAgICAgIHZbZm9yd2FyZF0uaW5zZXJ0KHUpO1xyXG4gICAgICAgICAgICAgICAgdVtyZXZlcnNlXS5pbnNlcnQodik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHVvdmVydlggPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgZihcIm5leHRcIiwgXCJwcmV2XCIpO1xyXG4gICAgZihcInByZXZcIiwgXCJuZXh0XCIpO1xyXG59XHJcbmZ1bmN0aW9uIGZpbmRZTmVpZ2hib3Vycyh2LCBzY2FubGluZSkge1xyXG4gICAgdmFyIGYgPSBmdW5jdGlvbiAoZm9yd2FyZCwgcmV2ZXJzZSkge1xyXG4gICAgICAgIHZhciB1ID0gc2NhbmxpbmUuZmluZEl0ZXIodilbZm9yd2FyZF0oKTtcclxuICAgICAgICBpZiAodSAhPT0gbnVsbCAmJiB1LnIub3ZlcmxhcFgodi5yKSA+IDApIHtcclxuICAgICAgICAgICAgdltmb3J3YXJkXS5pbnNlcnQodSk7XHJcbiAgICAgICAgICAgIHVbcmV2ZXJzZV0uaW5zZXJ0KHYpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBmKFwibmV4dFwiLCBcInByZXZcIik7XHJcbiAgICBmKFwicHJldlwiLCBcIm5leHRcIik7XHJcbn1cclxuZnVuY3Rpb24gZ2VuZXJhdGVYQ29uc3RyYWludHMocnMsIHZhcnMpIHtcclxuICAgIHJldHVybiBnZW5lcmF0ZUNvbnN0cmFpbnRzKHJzLCB2YXJzLCB4UmVjdCwgMWUtNik7XHJcbn1cclxuZXhwb3J0cy5nZW5lcmF0ZVhDb25zdHJhaW50cyA9IGdlbmVyYXRlWENvbnN0cmFpbnRzO1xyXG5mdW5jdGlvbiBnZW5lcmF0ZVlDb25zdHJhaW50cyhycywgdmFycykge1xyXG4gICAgcmV0dXJuIGdlbmVyYXRlQ29uc3RyYWludHMocnMsIHZhcnMsIHlSZWN0LCAxZS02KTtcclxufVxyXG5leHBvcnRzLmdlbmVyYXRlWUNvbnN0cmFpbnRzID0gZ2VuZXJhdGVZQ29uc3RyYWludHM7XHJcbmZ1bmN0aW9uIGdlbmVyYXRlWEdyb3VwQ29uc3RyYWludHMocm9vdCkge1xyXG4gICAgcmV0dXJuIGdlbmVyYXRlR3JvdXBDb25zdHJhaW50cyhyb290LCB4UmVjdCwgMWUtNik7XHJcbn1cclxuZXhwb3J0cy5nZW5lcmF0ZVhHcm91cENvbnN0cmFpbnRzID0gZ2VuZXJhdGVYR3JvdXBDb25zdHJhaW50cztcclxuZnVuY3Rpb24gZ2VuZXJhdGVZR3JvdXBDb25zdHJhaW50cyhyb290KSB7XHJcbiAgICByZXR1cm4gZ2VuZXJhdGVHcm91cENvbnN0cmFpbnRzKHJvb3QsIHlSZWN0LCAxZS02KTtcclxufVxyXG5leHBvcnRzLmdlbmVyYXRlWUdyb3VwQ29uc3RyYWludHMgPSBnZW5lcmF0ZVlHcm91cENvbnN0cmFpbnRzO1xyXG5mdW5jdGlvbiByZW1vdmVPdmVybGFwcyhycykge1xyXG4gICAgdmFyIHZzID0gcnMubWFwKGZ1bmN0aW9uIChyKSB7IHJldHVybiBuZXcgdnBzY18xLlZhcmlhYmxlKHIuY3goKSk7IH0pO1xyXG4gICAgdmFyIGNzID0gZ2VuZXJhdGVYQ29uc3RyYWludHMocnMsIHZzKTtcclxuICAgIHZhciBzb2x2ZXIgPSBuZXcgdnBzY18xLlNvbHZlcih2cywgY3MpO1xyXG4gICAgc29sdmVyLnNvbHZlKCk7XHJcbiAgICB2cy5mb3JFYWNoKGZ1bmN0aW9uICh2LCBpKSB7IHJldHVybiByc1tpXS5zZXRYQ2VudHJlKHYucG9zaXRpb24oKSk7IH0pO1xyXG4gICAgdnMgPSBycy5tYXAoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIG5ldyB2cHNjXzEuVmFyaWFibGUoci5jeSgpKTsgfSk7XHJcbiAgICBjcyA9IGdlbmVyYXRlWUNvbnN0cmFpbnRzKHJzLCB2cyk7XHJcbiAgICBzb2x2ZXIgPSBuZXcgdnBzY18xLlNvbHZlcih2cywgY3MpO1xyXG4gICAgc29sdmVyLnNvbHZlKCk7XHJcbiAgICB2cy5mb3JFYWNoKGZ1bmN0aW9uICh2LCBpKSB7IHJldHVybiByc1tpXS5zZXRZQ2VudHJlKHYucG9zaXRpb24oKSk7IH0pO1xyXG59XHJcbmV4cG9ydHMucmVtb3ZlT3ZlcmxhcHMgPSByZW1vdmVPdmVybGFwcztcclxudmFyIEluZGV4ZWRWYXJpYWJsZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoSW5kZXhlZFZhcmlhYmxlLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gSW5kZXhlZFZhcmlhYmxlKGluZGV4LCB3KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgMCwgdykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5pbmRleCA9IGluZGV4O1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIHJldHVybiBJbmRleGVkVmFyaWFibGU7XHJcbn0odnBzY18xLlZhcmlhYmxlKSk7XHJcbmV4cG9ydHMuSW5kZXhlZFZhcmlhYmxlID0gSW5kZXhlZFZhcmlhYmxlO1xyXG52YXIgUHJvamVjdGlvbiA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBQcm9qZWN0aW9uKG5vZGVzLCBncm91cHMsIHJvb3RHcm91cCwgY29uc3RyYWludHMsIGF2b2lkT3ZlcmxhcHMpIHtcclxuICAgICAgICBpZiAocm9vdEdyb3VwID09PSB2b2lkIDApIHsgcm9vdEdyb3VwID0gbnVsbDsgfVxyXG4gICAgICAgIGlmIChjb25zdHJhaW50cyA9PT0gdm9pZCAwKSB7IGNvbnN0cmFpbnRzID0gbnVsbDsgfVxyXG4gICAgICAgIGlmIChhdm9pZE92ZXJsYXBzID09PSB2b2lkIDApIHsgYXZvaWRPdmVybGFwcyA9IGZhbHNlOyB9XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLm5vZGVzID0gbm9kZXM7XHJcbiAgICAgICAgdGhpcy5ncm91cHMgPSBncm91cHM7XHJcbiAgICAgICAgdGhpcy5yb290R3JvdXAgPSByb290R3JvdXA7XHJcbiAgICAgICAgdGhpcy5hdm9pZE92ZXJsYXBzID0gYXZvaWRPdmVybGFwcztcclxuICAgICAgICB0aGlzLnZhcmlhYmxlcyA9IG5vZGVzLm1hcChmdW5jdGlvbiAodiwgaSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdi52YXJpYWJsZSA9IG5ldyBJbmRleGVkVmFyaWFibGUoaSwgMSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKGNvbnN0cmFpbnRzKVxyXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZUNvbnN0cmFpbnRzKGNvbnN0cmFpbnRzKTtcclxuICAgICAgICBpZiAoYXZvaWRPdmVybGFwcyAmJiByb290R3JvdXAgJiYgdHlwZW9mIHJvb3RHcm91cC5ncm91cHMgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgICAgIGlmICghdi53aWR0aCB8fCAhdi5oZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2LmJvdW5kcyA9IG5ldyBSZWN0YW5nbGUodi54LCB2LngsIHYueSwgdi55KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgdzIgPSB2LndpZHRoIC8gMiwgaDIgPSB2LmhlaWdodCAvIDI7XHJcbiAgICAgICAgICAgICAgICB2LmJvdW5kcyA9IG5ldyBSZWN0YW5nbGUodi54IC0gdzIsIHYueCArIHcyLCB2LnkgLSBoMiwgdi55ICsgaDIpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY29tcHV0ZUdyb3VwQm91bmRzKHJvb3RHcm91cCk7XHJcbiAgICAgICAgICAgIHZhciBpID0gbm9kZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICBncm91cHMuZm9yRWFjaChmdW5jdGlvbiAoZykge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMudmFyaWFibGVzW2ldID0gZy5taW5WYXIgPSBuZXcgSW5kZXhlZFZhcmlhYmxlKGkrKywgdHlwZW9mIGcuc3RpZmZuZXNzICE9PSBcInVuZGVmaW5lZFwiID8gZy5zdGlmZm5lc3MgOiAwLjAxKTtcclxuICAgICAgICAgICAgICAgIF90aGlzLnZhcmlhYmxlc1tpXSA9IGcubWF4VmFyID0gbmV3IEluZGV4ZWRWYXJpYWJsZShpKyssIHR5cGVvZiBnLnN0aWZmbmVzcyAhPT0gXCJ1bmRlZmluZWRcIiA/IGcuc3RpZmZuZXNzIDogMC4wMSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIFByb2plY3Rpb24ucHJvdG90eXBlLmNyZWF0ZVNlcGFyYXRpb24gPSBmdW5jdGlvbiAoYykge1xyXG4gICAgICAgIHJldHVybiBuZXcgdnBzY18xLkNvbnN0cmFpbnQodGhpcy5ub2Rlc1tjLmxlZnRdLnZhcmlhYmxlLCB0aGlzLm5vZGVzW2MucmlnaHRdLnZhcmlhYmxlLCBjLmdhcCwgdHlwZW9mIGMuZXF1YWxpdHkgIT09IFwidW5kZWZpbmVkXCIgPyBjLmVxdWFsaXR5IDogZmFsc2UpO1xyXG4gICAgfTtcclxuICAgIFByb2plY3Rpb24ucHJvdG90eXBlLm1ha2VGZWFzaWJsZSA9IGZ1bmN0aW9uIChjKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAoIXRoaXMuYXZvaWRPdmVybGFwcylcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIHZhciBheGlzID0gJ3gnLCBkaW0gPSAnd2lkdGgnO1xyXG4gICAgICAgIGlmIChjLmF4aXMgPT09ICd4JylcclxuICAgICAgICAgICAgYXhpcyA9ICd5JywgZGltID0gJ2hlaWdodCc7XHJcbiAgICAgICAgdmFyIHZzID0gYy5vZmZzZXRzLm1hcChmdW5jdGlvbiAobykgeyByZXR1cm4gX3RoaXMubm9kZXNbby5ub2RlXTsgfSkuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYVtheGlzXSAtIGJbYXhpc107IH0pO1xyXG4gICAgICAgIHZhciBwID0gbnVsbDtcclxuICAgICAgICB2cy5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgIGlmIChwKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV4dFBvcyA9IHBbYXhpc10gKyBwW2RpbV07XHJcbiAgICAgICAgICAgICAgICBpZiAobmV4dFBvcyA+IHZbYXhpc10pIHtcclxuICAgICAgICAgICAgICAgICAgICB2W2F4aXNdID0gbmV4dFBvcztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwID0gdjtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBQcm9qZWN0aW9uLnByb3RvdHlwZS5jcmVhdGVBbGlnbm1lbnQgPSBmdW5jdGlvbiAoYykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHUgPSB0aGlzLm5vZGVzW2Mub2Zmc2V0c1swXS5ub2RlXS52YXJpYWJsZTtcclxuICAgICAgICB0aGlzLm1ha2VGZWFzaWJsZShjKTtcclxuICAgICAgICB2YXIgY3MgPSBjLmF4aXMgPT09ICd4JyA/IHRoaXMueENvbnN0cmFpbnRzIDogdGhpcy55Q29uc3RyYWludHM7XHJcbiAgICAgICAgYy5vZmZzZXRzLnNsaWNlKDEpLmZvckVhY2goZnVuY3Rpb24gKG8pIHtcclxuICAgICAgICAgICAgdmFyIHYgPSBfdGhpcy5ub2Rlc1tvLm5vZGVdLnZhcmlhYmxlO1xyXG4gICAgICAgICAgICBjcy5wdXNoKG5ldyB2cHNjXzEuQ29uc3RyYWludCh1LCB2LCBvLm9mZnNldCwgdHJ1ZSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFByb2plY3Rpb24ucHJvdG90eXBlLmNyZWF0ZUNvbnN0cmFpbnRzID0gZnVuY3Rpb24gKGNvbnN0cmFpbnRzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgaXNTZXAgPSBmdW5jdGlvbiAoYykgeyByZXR1cm4gdHlwZW9mIGMudHlwZSA9PT0gJ3VuZGVmaW5lZCcgfHwgYy50eXBlID09PSAnc2VwYXJhdGlvbic7IH07XHJcbiAgICAgICAgdGhpcy54Q29uc3RyYWludHMgPSBjb25zdHJhaW50c1xyXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLmF4aXMgPT09IFwieFwiICYmIGlzU2VwKGMpOyB9KVxyXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiBfdGhpcy5jcmVhdGVTZXBhcmF0aW9uKGMpOyB9KTtcclxuICAgICAgICB0aGlzLnlDb25zdHJhaW50cyA9IGNvbnN0cmFpbnRzXHJcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMuYXhpcyA9PT0gXCJ5XCIgJiYgaXNTZXAoYyk7IH0pXHJcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIF90aGlzLmNyZWF0ZVNlcGFyYXRpb24oYyk7IH0pO1xyXG4gICAgICAgIGNvbnN0cmFpbnRzXHJcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMudHlwZSA9PT0gJ2FsaWdubWVudCc7IH0pXHJcbiAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7IHJldHVybiBfdGhpcy5jcmVhdGVBbGlnbm1lbnQoYyk7IH0pO1xyXG4gICAgfTtcclxuICAgIFByb2plY3Rpb24ucHJvdG90eXBlLnNldHVwVmFyaWFibGVzQW5kQm91bmRzID0gZnVuY3Rpb24gKHgwLCB5MCwgZGVzaXJlZCwgZ2V0RGVzaXJlZCkge1xyXG4gICAgICAgIHRoaXMubm9kZXMuZm9yRWFjaChmdW5jdGlvbiAodiwgaSkge1xyXG4gICAgICAgICAgICBpZiAodi5maXhlZCkge1xyXG4gICAgICAgICAgICAgICAgdi52YXJpYWJsZS53ZWlnaHQgPSB2LmZpeGVkV2VpZ2h0ID8gdi5maXhlZFdlaWdodCA6IDEwMDA7XHJcbiAgICAgICAgICAgICAgICBkZXNpcmVkW2ldID0gZ2V0RGVzaXJlZCh2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHYudmFyaWFibGUud2VpZ2h0ID0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgdyA9ICh2LndpZHRoIHx8IDApIC8gMiwgaCA9ICh2LmhlaWdodCB8fCAwKSAvIDI7XHJcbiAgICAgICAgICAgIHZhciBpeCA9IHgwW2ldLCBpeSA9IHkwW2ldO1xyXG4gICAgICAgICAgICB2LmJvdW5kcyA9IG5ldyBSZWN0YW5nbGUoaXggLSB3LCBpeCArIHcsIGl5IC0gaCwgaXkgKyBoKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBQcm9qZWN0aW9uLnByb3RvdHlwZS54UHJvamVjdCA9IGZ1bmN0aW9uICh4MCwgeTAsIHgpIHtcclxuICAgICAgICBpZiAoIXRoaXMucm9vdEdyb3VwICYmICEodGhpcy5hdm9pZE92ZXJsYXBzIHx8IHRoaXMueENvbnN0cmFpbnRzKSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIHRoaXMucHJvamVjdCh4MCwgeTAsIHgwLCB4LCBmdW5jdGlvbiAodikgeyByZXR1cm4gdi5weDsgfSwgdGhpcy54Q29uc3RyYWludHMsIGdlbmVyYXRlWEdyb3VwQ29uc3RyYWludHMsIGZ1bmN0aW9uICh2KSB7IHJldHVybiB2LmJvdW5kcy5zZXRYQ2VudHJlKHhbdi52YXJpYWJsZS5pbmRleF0gPSB2LnZhcmlhYmxlLnBvc2l0aW9uKCkpOyB9LCBmdW5jdGlvbiAoZykge1xyXG4gICAgICAgICAgICB2YXIgeG1pbiA9IHhbZy5taW5WYXIuaW5kZXhdID0gZy5taW5WYXIucG9zaXRpb24oKTtcclxuICAgICAgICAgICAgdmFyIHhtYXggPSB4W2cubWF4VmFyLmluZGV4XSA9IGcubWF4VmFyLnBvc2l0aW9uKCk7XHJcbiAgICAgICAgICAgIHZhciBwMiA9IGcucGFkZGluZyAvIDI7XHJcbiAgICAgICAgICAgIGcuYm91bmRzLnggPSB4bWluIC0gcDI7XHJcbiAgICAgICAgICAgIGcuYm91bmRzLlggPSB4bWF4ICsgcDI7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgUHJvamVjdGlvbi5wcm90b3R5cGUueVByb2plY3QgPSBmdW5jdGlvbiAoeDAsIHkwLCB5KSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnJvb3RHcm91cCAmJiAhdGhpcy55Q29uc3RyYWludHMpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB0aGlzLnByb2plY3QoeDAsIHkwLCB5MCwgeSwgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHYucHk7IH0sIHRoaXMueUNvbnN0cmFpbnRzLCBnZW5lcmF0ZVlHcm91cENvbnN0cmFpbnRzLCBmdW5jdGlvbiAodikgeyByZXR1cm4gdi5ib3VuZHMuc2V0WUNlbnRyZSh5W3YudmFyaWFibGUuaW5kZXhdID0gdi52YXJpYWJsZS5wb3NpdGlvbigpKTsgfSwgZnVuY3Rpb24gKGcpIHtcclxuICAgICAgICAgICAgdmFyIHltaW4gPSB5W2cubWluVmFyLmluZGV4XSA9IGcubWluVmFyLnBvc2l0aW9uKCk7XHJcbiAgICAgICAgICAgIHZhciB5bWF4ID0geVtnLm1heFZhci5pbmRleF0gPSBnLm1heFZhci5wb3NpdGlvbigpO1xyXG4gICAgICAgICAgICB2YXIgcDIgPSBnLnBhZGRpbmcgLyAyO1xyXG4gICAgICAgICAgICBnLmJvdW5kcy55ID0geW1pbiAtIHAyO1xyXG4gICAgICAgICAgICA7XHJcbiAgICAgICAgICAgIGcuYm91bmRzLlkgPSB5bWF4ICsgcDI7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgUHJvamVjdGlvbi5wcm90b3R5cGUucHJvamVjdEZ1bmN0aW9ucyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uICh4MCwgeTAsIHgpIHsgcmV0dXJuIF90aGlzLnhQcm9qZWN0KHgwLCB5MCwgeCk7IH0sXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uICh4MCwgeTAsIHkpIHsgcmV0dXJuIF90aGlzLnlQcm9qZWN0KHgwLCB5MCwgeSk7IH1cclxuICAgICAgICBdO1xyXG4gICAgfTtcclxuICAgIFByb2plY3Rpb24ucHJvdG90eXBlLnByb2plY3QgPSBmdW5jdGlvbiAoeDAsIHkwLCBzdGFydCwgZGVzaXJlZCwgZ2V0RGVzaXJlZCwgY3MsIGdlbmVyYXRlQ29uc3RyYWludHMsIHVwZGF0ZU5vZGVCb3VuZHMsIHVwZGF0ZUdyb3VwQm91bmRzKSB7XHJcbiAgICAgICAgdGhpcy5zZXR1cFZhcmlhYmxlc0FuZEJvdW5kcyh4MCwgeTAsIGRlc2lyZWQsIGdldERlc2lyZWQpO1xyXG4gICAgICAgIGlmICh0aGlzLnJvb3RHcm91cCAmJiB0aGlzLmF2b2lkT3ZlcmxhcHMpIHtcclxuICAgICAgICAgICAgY29tcHV0ZUdyb3VwQm91bmRzKHRoaXMucm9vdEdyb3VwKTtcclxuICAgICAgICAgICAgY3MgPSBjcy5jb25jYXQoZ2VuZXJhdGVDb25zdHJhaW50cyh0aGlzLnJvb3RHcm91cCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNvbHZlKHRoaXMudmFyaWFibGVzLCBjcywgc3RhcnQsIGRlc2lyZWQpO1xyXG4gICAgICAgIHRoaXMubm9kZXMuZm9yRWFjaCh1cGRhdGVOb2RlQm91bmRzKTtcclxuICAgICAgICBpZiAodGhpcy5yb290R3JvdXAgJiYgdGhpcy5hdm9pZE92ZXJsYXBzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzLmZvckVhY2godXBkYXRlR3JvdXBCb3VuZHMpO1xyXG4gICAgICAgICAgICBjb21wdXRlR3JvdXBCb3VuZHModGhpcy5yb290R3JvdXApO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBQcm9qZWN0aW9uLnByb3RvdHlwZS5zb2x2ZSA9IGZ1bmN0aW9uICh2cywgY3MsIHN0YXJ0aW5nLCBkZXNpcmVkKSB7XHJcbiAgICAgICAgdmFyIHNvbHZlciA9IG5ldyB2cHNjXzEuU29sdmVyKHZzLCBjcyk7XHJcbiAgICAgICAgc29sdmVyLnNldFN0YXJ0aW5nUG9zaXRpb25zKHN0YXJ0aW5nKTtcclxuICAgICAgICBzb2x2ZXIuc2V0RGVzaXJlZFBvc2l0aW9ucyhkZXNpcmVkKTtcclxuICAgICAgICBzb2x2ZXIuc29sdmUoKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gUHJvamVjdGlvbjtcclxufSgpKTtcclxuZXhwb3J0cy5Qcm9qZWN0aW9uID0gUHJvamVjdGlvbjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVjdGFuZ2xlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBwcXVldWVfMSA9IHJlcXVpcmUoXCIuL3BxdWV1ZVwiKTtcclxudmFyIE5laWdoYm91ciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBOZWlnaGJvdXIoaWQsIGRpc3RhbmNlKSB7XHJcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xyXG4gICAgICAgIHRoaXMuZGlzdGFuY2UgPSBkaXN0YW5jZTtcclxuICAgIH1cclxuICAgIHJldHVybiBOZWlnaGJvdXI7XHJcbn0oKSk7XHJcbnZhciBOb2RlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE5vZGUoaWQpIHtcclxuICAgICAgICB0aGlzLmlkID0gaWQ7XHJcbiAgICAgICAgdGhpcy5uZWlnaGJvdXJzID0gW107XHJcbiAgICB9XHJcbiAgICByZXR1cm4gTm9kZTtcclxufSgpKTtcclxudmFyIFF1ZXVlRW50cnkgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUXVldWVFbnRyeShub2RlLCBwcmV2LCBkKSB7XHJcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcclxuICAgICAgICB0aGlzLnByZXYgPSBwcmV2O1xyXG4gICAgICAgIHRoaXMuZCA9IGQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUXVldWVFbnRyeTtcclxufSgpKTtcclxudmFyIENhbGN1bGF0b3IgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQ2FsY3VsYXRvcihuLCBlcywgZ2V0U291cmNlSW5kZXgsIGdldFRhcmdldEluZGV4LCBnZXRMZW5ndGgpIHtcclxuICAgICAgICB0aGlzLm4gPSBuO1xyXG4gICAgICAgIHRoaXMuZXMgPSBlcztcclxuICAgICAgICB0aGlzLm5laWdoYm91cnMgPSBuZXcgQXJyYXkodGhpcy5uKTtcclxuICAgICAgICB2YXIgaSA9IHRoaXMubjtcclxuICAgICAgICB3aGlsZSAoaS0tKVxyXG4gICAgICAgICAgICB0aGlzLm5laWdoYm91cnNbaV0gPSBuZXcgTm9kZShpKTtcclxuICAgICAgICBpID0gdGhpcy5lcy5sZW5ndGg7XHJcbiAgICAgICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgICAgICB2YXIgZSA9IHRoaXMuZXNbaV07XHJcbiAgICAgICAgICAgIHZhciB1ID0gZ2V0U291cmNlSW5kZXgoZSksIHYgPSBnZXRUYXJnZXRJbmRleChlKTtcclxuICAgICAgICAgICAgdmFyIGQgPSBnZXRMZW5ndGgoZSk7XHJcbiAgICAgICAgICAgIHRoaXMubmVpZ2hib3Vyc1t1XS5uZWlnaGJvdXJzLnB1c2gobmV3IE5laWdoYm91cih2LCBkKSk7XHJcbiAgICAgICAgICAgIHRoaXMubmVpZ2hib3Vyc1t2XS5uZWlnaGJvdXJzLnB1c2gobmV3IE5laWdoYm91cih1LCBkKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgQ2FsY3VsYXRvci5wcm90b3R5cGUuRGlzdGFuY2VNYXRyaXggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIEQgPSBuZXcgQXJyYXkodGhpcy5uKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubjsgKytpKSB7XHJcbiAgICAgICAgICAgIERbaV0gPSB0aGlzLmRpamtzdHJhTmVpZ2hib3VycyhpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIEQ7XHJcbiAgICB9O1xyXG4gICAgQ2FsY3VsYXRvci5wcm90b3R5cGUuRGlzdGFuY2VzRnJvbU5vZGUgPSBmdW5jdGlvbiAoc3RhcnQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kaWprc3RyYU5laWdoYm91cnMoc3RhcnQpO1xyXG4gICAgfTtcclxuICAgIENhbGN1bGF0b3IucHJvdG90eXBlLlBhdGhGcm9tTm9kZVRvTm9kZSA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlqa3N0cmFOZWlnaGJvdXJzKHN0YXJ0LCBlbmQpO1xyXG4gICAgfTtcclxuICAgIENhbGN1bGF0b3IucHJvdG90eXBlLlBhdGhGcm9tTm9kZVRvTm9kZVdpdGhQcmV2Q29zdCA9IGZ1bmN0aW9uIChzdGFydCwgZW5kLCBwcmV2Q29zdCkge1xyXG4gICAgICAgIHZhciBxID0gbmV3IHBxdWV1ZV8xLlByaW9yaXR5UXVldWUoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEuZCA8PSBiLmQ7IH0pLCB1ID0gdGhpcy5uZWlnaGJvdXJzW3N0YXJ0XSwgcXUgPSBuZXcgUXVldWVFbnRyeSh1LCBudWxsLCAwKSwgdmlzaXRlZEZyb20gPSB7fTtcclxuICAgICAgICBxLnB1c2gocXUpO1xyXG4gICAgICAgIHdoaWxlICghcS5lbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIHF1ID0gcS5wb3AoKTtcclxuICAgICAgICAgICAgdSA9IHF1Lm5vZGU7XHJcbiAgICAgICAgICAgIGlmICh1LmlkID09PSBlbmQpIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBpID0gdS5uZWlnaGJvdXJzLmxlbmd0aDtcclxuICAgICAgICAgICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5laWdoYm91ciA9IHUubmVpZ2hib3Vyc1tpXSwgdiA9IHRoaXMubmVpZ2hib3Vyc1tuZWlnaGJvdXIuaWRdO1xyXG4gICAgICAgICAgICAgICAgaWYgKHF1LnByZXYgJiYgdi5pZCA9PT0gcXUucHJldi5ub2RlLmlkKVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgdmFyIHZpZHVpZCA9IHYuaWQgKyAnLCcgKyB1LmlkO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZpZHVpZCBpbiB2aXNpdGVkRnJvbSAmJiB2aXNpdGVkRnJvbVt2aWR1aWRdIDw9IHF1LmQpXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2MgPSBxdS5wcmV2ID8gcHJldkNvc3QocXUucHJldi5ub2RlLmlkLCB1LmlkLCB2LmlkKSA6IDAsIHQgPSBxdS5kICsgbmVpZ2hib3VyLmRpc3RhbmNlICsgY2M7XHJcbiAgICAgICAgICAgICAgICB2aXNpdGVkRnJvbVt2aWR1aWRdID0gdDtcclxuICAgICAgICAgICAgICAgIHEucHVzaChuZXcgUXVldWVFbnRyeSh2LCBxdSwgdCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBwYXRoID0gW107XHJcbiAgICAgICAgd2hpbGUgKHF1LnByZXYpIHtcclxuICAgICAgICAgICAgcXUgPSBxdS5wcmV2O1xyXG4gICAgICAgICAgICBwYXRoLnB1c2gocXUubm9kZS5pZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwYXRoO1xyXG4gICAgfTtcclxuICAgIENhbGN1bGF0b3IucHJvdG90eXBlLmRpamtzdHJhTmVpZ2hib3VycyA9IGZ1bmN0aW9uIChzdGFydCwgZGVzdCkge1xyXG4gICAgICAgIGlmIChkZXN0ID09PSB2b2lkIDApIHsgZGVzdCA9IC0xOyB9XHJcbiAgICAgICAgdmFyIHEgPSBuZXcgcHF1ZXVlXzEuUHJpb3JpdHlRdWV1ZShmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5kIDw9IGIuZDsgfSksIGkgPSB0aGlzLm5laWdoYm91cnMubGVuZ3RoLCBkID0gbmV3IEFycmF5KGkpO1xyXG4gICAgICAgIHdoaWxlIChpLS0pIHtcclxuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLm5laWdoYm91cnNbaV07XHJcbiAgICAgICAgICAgIG5vZGUuZCA9IGkgPT09IHN0YXJ0ID8gMCA6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcclxuICAgICAgICAgICAgbm9kZS5xID0gcS5wdXNoKG5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB3aGlsZSAoIXEuZW1wdHkoKSkge1xyXG4gICAgICAgICAgICB2YXIgdSA9IHEucG9wKCk7XHJcbiAgICAgICAgICAgIGRbdS5pZF0gPSB1LmQ7XHJcbiAgICAgICAgICAgIGlmICh1LmlkID09PSBkZXN0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGF0aCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgdmFyIHYgPSB1O1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKHR5cGVvZiB2LnByZXYgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0aC5wdXNoKHYucHJldi5pZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdiA9IHYucHJldjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBwYXRoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGkgPSB1Lm5laWdoYm91cnMubGVuZ3RoO1xyXG4gICAgICAgICAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmVpZ2hib3VyID0gdS5uZWlnaGJvdXJzW2ldO1xyXG4gICAgICAgICAgICAgICAgdmFyIHYgPSB0aGlzLm5laWdoYm91cnNbbmVpZ2hib3VyLmlkXTtcclxuICAgICAgICAgICAgICAgIHZhciB0ID0gdS5kICsgbmVpZ2hib3VyLmRpc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHUuZCAhPT0gTnVtYmVyLk1BWF9WQUxVRSAmJiB2LmQgPiB0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdi5kID0gdDtcclxuICAgICAgICAgICAgICAgICAgICB2LnByZXYgPSB1O1xyXG4gICAgICAgICAgICAgICAgICAgIHEucmVkdWNlS2V5KHYucSwgdiwgZnVuY3Rpb24gKGUsIHEpIHsgcmV0dXJuIGUucSA9IHE7IH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBDYWxjdWxhdG9yO1xyXG59KCkpO1xyXG5leHBvcnRzLkNhbGN1bGF0b3IgPSBDYWxjdWxhdG9yO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaG9ydGVzdHBhdGhzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBQb3NpdGlvblN0YXRzID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFBvc2l0aW9uU3RhdHMoc2NhbGUpIHtcclxuICAgICAgICB0aGlzLnNjYWxlID0gc2NhbGU7XHJcbiAgICAgICAgdGhpcy5BQiA9IDA7XHJcbiAgICAgICAgdGhpcy5BRCA9IDA7XHJcbiAgICAgICAgdGhpcy5BMiA9IDA7XHJcbiAgICB9XHJcbiAgICBQb3NpdGlvblN0YXRzLnByb3RvdHlwZS5hZGRWYXJpYWJsZSA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgdmFyIGFpID0gdGhpcy5zY2FsZSAvIHYuc2NhbGU7XHJcbiAgICAgICAgdmFyIGJpID0gdi5vZmZzZXQgLyB2LnNjYWxlO1xyXG4gICAgICAgIHZhciB3aSA9IHYud2VpZ2h0O1xyXG4gICAgICAgIHRoaXMuQUIgKz0gd2kgKiBhaSAqIGJpO1xyXG4gICAgICAgIHRoaXMuQUQgKz0gd2kgKiBhaSAqIHYuZGVzaXJlZFBvc2l0aW9uO1xyXG4gICAgICAgIHRoaXMuQTIgKz0gd2kgKiBhaSAqIGFpO1xyXG4gICAgfTtcclxuICAgIFBvc2l0aW9uU3RhdHMucHJvdG90eXBlLmdldFBvc24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLkFEIC0gdGhpcy5BQikgLyB0aGlzLkEyO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBQb3NpdGlvblN0YXRzO1xyXG59KCkpO1xyXG5leHBvcnRzLlBvc2l0aW9uU3RhdHMgPSBQb3NpdGlvblN0YXRzO1xyXG52YXIgQ29uc3RyYWludCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBDb25zdHJhaW50KGxlZnQsIHJpZ2h0LCBnYXAsIGVxdWFsaXR5KSB7XHJcbiAgICAgICAgaWYgKGVxdWFsaXR5ID09PSB2b2lkIDApIHsgZXF1YWxpdHkgPSBmYWxzZTsgfVxyXG4gICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XHJcbiAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xyXG4gICAgICAgIHRoaXMuZ2FwID0gZ2FwO1xyXG4gICAgICAgIHRoaXMuZXF1YWxpdHkgPSBlcXVhbGl0eTtcclxuICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMudW5zYXRpc2ZpYWJsZSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XHJcbiAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xyXG4gICAgICAgIHRoaXMuZ2FwID0gZ2FwO1xyXG4gICAgICAgIHRoaXMuZXF1YWxpdHkgPSBlcXVhbGl0eTtcclxuICAgIH1cclxuICAgIENvbnN0cmFpbnQucHJvdG90eXBlLnNsYWNrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnVuc2F0aXNmaWFibGUgPyBOdW1iZXIuTUFYX1ZBTFVFXHJcbiAgICAgICAgICAgIDogdGhpcy5yaWdodC5zY2FsZSAqIHRoaXMucmlnaHQucG9zaXRpb24oKSAtIHRoaXMuZ2FwXHJcbiAgICAgICAgICAgICAgICAtIHRoaXMubGVmdC5zY2FsZSAqIHRoaXMubGVmdC5wb3NpdGlvbigpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBDb25zdHJhaW50O1xyXG59KCkpO1xyXG5leHBvcnRzLkNvbnN0cmFpbnQgPSBDb25zdHJhaW50O1xyXG52YXIgVmFyaWFibGUgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVmFyaWFibGUoZGVzaXJlZFBvc2l0aW9uLCB3ZWlnaHQsIHNjYWxlKSB7XHJcbiAgICAgICAgaWYgKHdlaWdodCA9PT0gdm9pZCAwKSB7IHdlaWdodCA9IDE7IH1cclxuICAgICAgICBpZiAoc2NhbGUgPT09IHZvaWQgMCkgeyBzY2FsZSA9IDE7IH1cclxuICAgICAgICB0aGlzLmRlc2lyZWRQb3NpdGlvbiA9IGRlc2lyZWRQb3NpdGlvbjtcclxuICAgICAgICB0aGlzLndlaWdodCA9IHdlaWdodDtcclxuICAgICAgICB0aGlzLnNjYWxlID0gc2NhbGU7XHJcbiAgICAgICAgdGhpcy5vZmZzZXQgPSAwO1xyXG4gICAgfVxyXG4gICAgVmFyaWFibGUucHJvdG90eXBlLmRmZHYgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIDIuMCAqIHRoaXMud2VpZ2h0ICogKHRoaXMucG9zaXRpb24oKSAtIHRoaXMuZGVzaXJlZFBvc2l0aW9uKTtcclxuICAgIH07XHJcbiAgICBWYXJpYWJsZS5wcm90b3R5cGUucG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmJsb2NrLnBzLnNjYWxlICogdGhpcy5ibG9jay5wb3NuICsgdGhpcy5vZmZzZXQpIC8gdGhpcy5zY2FsZTtcclxuICAgIH07XHJcbiAgICBWYXJpYWJsZS5wcm90b3R5cGUudmlzaXROZWlnaGJvdXJzID0gZnVuY3Rpb24gKHByZXYsIGYpIHtcclxuICAgICAgICB2YXIgZmYgPSBmdW5jdGlvbiAoYywgbmV4dCkgeyByZXR1cm4gYy5hY3RpdmUgJiYgcHJldiAhPT0gbmV4dCAmJiBmKGMsIG5leHQpOyB9O1xyXG4gICAgICAgIHRoaXMuY091dC5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7IHJldHVybiBmZihjLCBjLnJpZ2h0KTsgfSk7XHJcbiAgICAgICAgdGhpcy5jSW4uZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZmYoYywgYy5sZWZ0KTsgfSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFZhcmlhYmxlO1xyXG59KCkpO1xyXG5leHBvcnRzLlZhcmlhYmxlID0gVmFyaWFibGU7XHJcbnZhciBCbG9jayA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBCbG9jayh2KSB7XHJcbiAgICAgICAgdGhpcy52YXJzID0gW107XHJcbiAgICAgICAgdi5vZmZzZXQgPSAwO1xyXG4gICAgICAgIHRoaXMucHMgPSBuZXcgUG9zaXRpb25TdGF0cyh2LnNjYWxlKTtcclxuICAgICAgICB0aGlzLmFkZFZhcmlhYmxlKHYpO1xyXG4gICAgfVxyXG4gICAgQmxvY2sucHJvdG90eXBlLmFkZFZhcmlhYmxlID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICB2LmJsb2NrID0gdGhpcztcclxuICAgICAgICB0aGlzLnZhcnMucHVzaCh2KTtcclxuICAgICAgICB0aGlzLnBzLmFkZFZhcmlhYmxlKHYpO1xyXG4gICAgICAgIHRoaXMucG9zbiA9IHRoaXMucHMuZ2V0UG9zbigpO1xyXG4gICAgfTtcclxuICAgIEJsb2NrLnByb3RvdHlwZS51cGRhdGVXZWlnaHRlZFBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMucHMuQUIgPSB0aGlzLnBzLkFEID0gdGhpcy5wcy5BMiA9IDA7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSB0aGlzLnZhcnMubGVuZ3RoOyBpIDwgbjsgKytpKVxyXG4gICAgICAgICAgICB0aGlzLnBzLmFkZFZhcmlhYmxlKHRoaXMudmFyc1tpXSk7XHJcbiAgICAgICAgdGhpcy5wb3NuID0gdGhpcy5wcy5nZXRQb3NuKCk7XHJcbiAgICB9O1xyXG4gICAgQmxvY2sucHJvdG90eXBlLmNvbXB1dGVfbG0gPSBmdW5jdGlvbiAodiwgdSwgcG9zdEFjdGlvbikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGRmZHYgPSB2LmRmZHYoKTtcclxuICAgICAgICB2LnZpc2l0TmVpZ2hib3Vycyh1LCBmdW5jdGlvbiAoYywgbmV4dCkge1xyXG4gICAgICAgICAgICB2YXIgX2RmZHYgPSBfdGhpcy5jb21wdXRlX2xtKG5leHQsIHYsIHBvc3RBY3Rpb24pO1xyXG4gICAgICAgICAgICBpZiAobmV4dCA9PT0gYy5yaWdodCkge1xyXG4gICAgICAgICAgICAgICAgZGZkdiArPSBfZGZkdiAqIGMubGVmdC5zY2FsZTtcclxuICAgICAgICAgICAgICAgIGMubG0gPSBfZGZkdjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRmZHYgKz0gX2RmZHYgKiBjLnJpZ2h0LnNjYWxlO1xyXG4gICAgICAgICAgICAgICAgYy5sbSA9IC1fZGZkdjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwb3N0QWN0aW9uKGMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBkZmR2IC8gdi5zY2FsZTtcclxuICAgIH07XHJcbiAgICBCbG9jay5wcm90b3R5cGUucG9wdWxhdGVTcGxpdEJsb2NrID0gZnVuY3Rpb24gKHYsIHByZXYpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHYudmlzaXROZWlnaGJvdXJzKHByZXYsIGZ1bmN0aW9uIChjLCBuZXh0KSB7XHJcbiAgICAgICAgICAgIG5leHQub2Zmc2V0ID0gdi5vZmZzZXQgKyAobmV4dCA9PT0gYy5yaWdodCA/IGMuZ2FwIDogLWMuZ2FwKTtcclxuICAgICAgICAgICAgX3RoaXMuYWRkVmFyaWFibGUobmV4dCk7XHJcbiAgICAgICAgICAgIF90aGlzLnBvcHVsYXRlU3BsaXRCbG9jayhuZXh0LCB2KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBCbG9jay5wcm90b3R5cGUudHJhdmVyc2UgPSBmdW5jdGlvbiAodmlzaXQsIGFjYywgdiwgcHJldikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKHYgPT09IHZvaWQgMCkgeyB2ID0gdGhpcy52YXJzWzBdOyB9XHJcbiAgICAgICAgaWYgKHByZXYgPT09IHZvaWQgMCkgeyBwcmV2ID0gbnVsbDsgfVxyXG4gICAgICAgIHYudmlzaXROZWlnaGJvdXJzKHByZXYsIGZ1bmN0aW9uIChjLCBuZXh0KSB7XHJcbiAgICAgICAgICAgIGFjYy5wdXNoKHZpc2l0KGMpKTtcclxuICAgICAgICAgICAgX3RoaXMudHJhdmVyc2UodmlzaXQsIGFjYywgbmV4dCwgdik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgQmxvY2sucHJvdG90eXBlLmZpbmRNaW5MTSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgbSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5jb21wdXRlX2xtKHRoaXMudmFyc1swXSwgbnVsbCwgZnVuY3Rpb24gKGMpIHtcclxuICAgICAgICAgICAgaWYgKCFjLmVxdWFsaXR5ICYmIChtID09PSBudWxsIHx8IGMubG0gPCBtLmxtKSlcclxuICAgICAgICAgICAgICAgIG0gPSBjO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBtO1xyXG4gICAgfTtcclxuICAgIEJsb2NrLnByb3RvdHlwZS5maW5kTWluTE1CZXR3ZWVuID0gZnVuY3Rpb24gKGx2LCBydikge1xyXG4gICAgICAgIHRoaXMuY29tcHV0ZV9sbShsdiwgbnVsbCwgZnVuY3Rpb24gKCkgeyB9KTtcclxuICAgICAgICB2YXIgbSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5maW5kUGF0aChsdiwgbnVsbCwgcnYsIGZ1bmN0aW9uIChjLCBuZXh0KSB7XHJcbiAgICAgICAgICAgIGlmICghYy5lcXVhbGl0eSAmJiBjLnJpZ2h0ID09PSBuZXh0ICYmIChtID09PSBudWxsIHx8IGMubG0gPCBtLmxtKSlcclxuICAgICAgICAgICAgICAgIG0gPSBjO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBtO1xyXG4gICAgfTtcclxuICAgIEJsb2NrLnByb3RvdHlwZS5maW5kUGF0aCA9IGZ1bmN0aW9uICh2LCBwcmV2LCB0bywgdmlzaXQpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBlbmRGb3VuZCA9IGZhbHNlO1xyXG4gICAgICAgIHYudmlzaXROZWlnaGJvdXJzKHByZXYsIGZ1bmN0aW9uIChjLCBuZXh0KSB7XHJcbiAgICAgICAgICAgIGlmICghZW5kRm91bmQgJiYgKG5leHQgPT09IHRvIHx8IF90aGlzLmZpbmRQYXRoKG5leHQsIHYsIHRvLCB2aXNpdCkpKSB7XHJcbiAgICAgICAgICAgICAgICBlbmRGb3VuZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB2aXNpdChjLCBuZXh0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBlbmRGb3VuZDtcclxuICAgIH07XHJcbiAgICBCbG9jay5wcm90b3R5cGUuaXNBY3RpdmVEaXJlY3RlZFBhdGhCZXR3ZWVuID0gZnVuY3Rpb24gKHUsIHYpIHtcclxuICAgICAgICBpZiAodSA9PT0gdilcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgdmFyIGkgPSB1LmNPdXQubGVuZ3RoO1xyXG4gICAgICAgIHdoaWxlIChpLS0pIHtcclxuICAgICAgICAgICAgdmFyIGMgPSB1LmNPdXRbaV07XHJcbiAgICAgICAgICAgIGlmIChjLmFjdGl2ZSAmJiB0aGlzLmlzQWN0aXZlRGlyZWN0ZWRQYXRoQmV0d2VlbihjLnJpZ2h0LCB2KSlcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgQmxvY2suc3BsaXQgPSBmdW5jdGlvbiAoYykge1xyXG4gICAgICAgIGMuYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuIFtCbG9jay5jcmVhdGVTcGxpdEJsb2NrKGMubGVmdCksIEJsb2NrLmNyZWF0ZVNwbGl0QmxvY2soYy5yaWdodCldO1xyXG4gICAgfTtcclxuICAgIEJsb2NrLmNyZWF0ZVNwbGl0QmxvY2sgPSBmdW5jdGlvbiAoc3RhcnRWYXIpIHtcclxuICAgICAgICB2YXIgYiA9IG5ldyBCbG9jayhzdGFydFZhcik7XHJcbiAgICAgICAgYi5wb3B1bGF0ZVNwbGl0QmxvY2soc3RhcnRWYXIsIG51bGwpO1xyXG4gICAgICAgIHJldHVybiBiO1xyXG4gICAgfTtcclxuICAgIEJsb2NrLnByb3RvdHlwZS5zcGxpdEJldHdlZW4gPSBmdW5jdGlvbiAodmwsIHZyKSB7XHJcbiAgICAgICAgdmFyIGMgPSB0aGlzLmZpbmRNaW5MTUJldHdlZW4odmwsIHZyKTtcclxuICAgICAgICBpZiAoYyAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB2YXIgYnMgPSBCbG9jay5zcGxpdChjKTtcclxuICAgICAgICAgICAgcmV0dXJuIHsgY29uc3RyYWludDogYywgbGI6IGJzWzBdLCByYjogYnNbMV0gfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG4gICAgQmxvY2sucHJvdG90eXBlLm1lcmdlQWNyb3NzID0gZnVuY3Rpb24gKGIsIGMsIGRpc3QpIHtcclxuICAgICAgICBjLmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBiLnZhcnMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XHJcbiAgICAgICAgICAgIHZhciB2ID0gYi52YXJzW2ldO1xyXG4gICAgICAgICAgICB2Lm9mZnNldCArPSBkaXN0O1xyXG4gICAgICAgICAgICB0aGlzLmFkZFZhcmlhYmxlKHYpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnBvc24gPSB0aGlzLnBzLmdldFBvc24oKTtcclxuICAgIH07XHJcbiAgICBCbG9jay5wcm90b3R5cGUuY29zdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc3VtID0gMCwgaSA9IHRoaXMudmFycy5sZW5ndGg7XHJcbiAgICAgICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgICAgICB2YXIgdiA9IHRoaXMudmFyc1tpXSwgZCA9IHYucG9zaXRpb24oKSAtIHYuZGVzaXJlZFBvc2l0aW9uO1xyXG4gICAgICAgICAgICBzdW0gKz0gZCAqIGQgKiB2LndlaWdodDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN1bTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQmxvY2s7XHJcbn0oKSk7XHJcbmV4cG9ydHMuQmxvY2sgPSBCbG9jaztcclxudmFyIEJsb2NrcyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBCbG9ja3ModnMpIHtcclxuICAgICAgICB0aGlzLnZzID0gdnM7XHJcbiAgICAgICAgdmFyIG4gPSB2cy5sZW5ndGg7XHJcbiAgICAgICAgdGhpcy5saXN0ID0gbmV3IEFycmF5KG4pO1xyXG4gICAgICAgIHdoaWxlIChuLS0pIHtcclxuICAgICAgICAgICAgdmFyIGIgPSBuZXcgQmxvY2sodnNbbl0pO1xyXG4gICAgICAgICAgICB0aGlzLmxpc3Rbbl0gPSBiO1xyXG4gICAgICAgICAgICBiLmJsb2NrSW5kID0gbjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBCbG9ja3MucHJvdG90eXBlLmNvc3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHN1bSA9IDAsIGkgPSB0aGlzLmxpc3QubGVuZ3RoO1xyXG4gICAgICAgIHdoaWxlIChpLS0pXHJcbiAgICAgICAgICAgIHN1bSArPSB0aGlzLmxpc3RbaV0uY29zdCgpO1xyXG4gICAgICAgIHJldHVybiBzdW07XHJcbiAgICB9O1xyXG4gICAgQmxvY2tzLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiAoYikge1xyXG4gICAgICAgIGIuYmxvY2tJbmQgPSB0aGlzLmxpc3QubGVuZ3RoO1xyXG4gICAgICAgIHRoaXMubGlzdC5wdXNoKGIpO1xyXG4gICAgfTtcclxuICAgIEJsb2Nrcy5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGIpIHtcclxuICAgICAgICB2YXIgbGFzdCA9IHRoaXMubGlzdC5sZW5ndGggLSAxO1xyXG4gICAgICAgIHZhciBzd2FwQmxvY2sgPSB0aGlzLmxpc3RbbGFzdF07XHJcbiAgICAgICAgdGhpcy5saXN0Lmxlbmd0aCA9IGxhc3Q7XHJcbiAgICAgICAgaWYgKGIgIT09IHN3YXBCbG9jaykge1xyXG4gICAgICAgICAgICB0aGlzLmxpc3RbYi5ibG9ja0luZF0gPSBzd2FwQmxvY2s7XHJcbiAgICAgICAgICAgIHN3YXBCbG9jay5ibG9ja0luZCA9IGIuYmxvY2tJbmQ7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEJsb2Nrcy5wcm90b3R5cGUubWVyZ2UgPSBmdW5jdGlvbiAoYykge1xyXG4gICAgICAgIHZhciBsID0gYy5sZWZ0LmJsb2NrLCByID0gYy5yaWdodC5ibG9jaztcclxuICAgICAgICB2YXIgZGlzdCA9IGMucmlnaHQub2Zmc2V0IC0gYy5sZWZ0Lm9mZnNldCAtIGMuZ2FwO1xyXG4gICAgICAgIGlmIChsLnZhcnMubGVuZ3RoIDwgci52YXJzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByLm1lcmdlQWNyb3NzKGwsIGMsIGRpc3QpO1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZShsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGwubWVyZ2VBY3Jvc3MociwgYywgLWRpc3QpO1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZShyKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQmxvY2tzLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGYpIHtcclxuICAgICAgICB0aGlzLmxpc3QuZm9yRWFjaChmKTtcclxuICAgIH07XHJcbiAgICBCbG9ja3MucHJvdG90eXBlLnVwZGF0ZUJsb2NrUG9zaXRpb25zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMubGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChiKSB7IHJldHVybiBiLnVwZGF0ZVdlaWdodGVkUG9zaXRpb24oKTsgfSk7XHJcbiAgICB9O1xyXG4gICAgQmxvY2tzLnByb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uIChpbmFjdGl2ZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy51cGRhdGVCbG9ja1Bvc2l0aW9ucygpO1xyXG4gICAgICAgIHRoaXMubGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChiKSB7XHJcbiAgICAgICAgICAgIHZhciB2ID0gYi5maW5kTWluTE0oKTtcclxuICAgICAgICAgICAgaWYgKHYgIT09IG51bGwgJiYgdi5sbSA8IFNvbHZlci5MQUdSQU5HSUFOX1RPTEVSQU5DRSkge1xyXG4gICAgICAgICAgICAgICAgYiA9IHYubGVmdC5ibG9jaztcclxuICAgICAgICAgICAgICAgIEJsb2NrLnNwbGl0KHYpLmZvckVhY2goZnVuY3Rpb24gKG5iKSB7IHJldHVybiBfdGhpcy5pbnNlcnQobmIpOyB9KTtcclxuICAgICAgICAgICAgICAgIF90aGlzLnJlbW92ZShiKTtcclxuICAgICAgICAgICAgICAgIGluYWN0aXZlLnB1c2godik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQmxvY2tzO1xyXG59KCkpO1xyXG5leHBvcnRzLkJsb2NrcyA9IEJsb2NrcztcclxudmFyIFNvbHZlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBTb2x2ZXIodnMsIGNzKSB7XHJcbiAgICAgICAgdGhpcy52cyA9IHZzO1xyXG4gICAgICAgIHRoaXMuY3MgPSBjcztcclxuICAgICAgICB0aGlzLnZzID0gdnM7XHJcbiAgICAgICAgdnMuZm9yRWFjaChmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICB2LmNJbiA9IFtdLCB2LmNPdXQgPSBbXTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmNzID0gY3M7XHJcbiAgICAgICAgY3MuZm9yRWFjaChmdW5jdGlvbiAoYykge1xyXG4gICAgICAgICAgICBjLmxlZnQuY091dC5wdXNoKGMpO1xyXG4gICAgICAgICAgICBjLnJpZ2h0LmNJbi5wdXNoKGMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuaW5hY3RpdmUgPSBjcy5tYXAoZnVuY3Rpb24gKGMpIHsgYy5hY3RpdmUgPSBmYWxzZTsgcmV0dXJuIGM7IH0pO1xyXG4gICAgICAgIHRoaXMuYnMgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgU29sdmVyLnByb3RvdHlwZS5jb3N0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJzLmNvc3QoKTtcclxuICAgIH07XHJcbiAgICBTb2x2ZXIucHJvdG90eXBlLnNldFN0YXJ0aW5nUG9zaXRpb25zID0gZnVuY3Rpb24gKHBzKSB7XHJcbiAgICAgICAgdGhpcy5pbmFjdGl2ZSA9IHRoaXMuY3MubWFwKGZ1bmN0aW9uIChjKSB7IGMuYWN0aXZlID0gZmFsc2U7IHJldHVybiBjOyB9KTtcclxuICAgICAgICB0aGlzLmJzID0gbmV3IEJsb2Nrcyh0aGlzLnZzKTtcclxuICAgICAgICB0aGlzLmJzLmZvckVhY2goZnVuY3Rpb24gKGIsIGkpIHsgcmV0dXJuIGIucG9zbiA9IHBzW2ldOyB9KTtcclxuICAgIH07XHJcbiAgICBTb2x2ZXIucHJvdG90eXBlLnNldERlc2lyZWRQb3NpdGlvbnMgPSBmdW5jdGlvbiAocHMpIHtcclxuICAgICAgICB0aGlzLnZzLmZvckVhY2goZnVuY3Rpb24gKHYsIGkpIHsgcmV0dXJuIHYuZGVzaXJlZFBvc2l0aW9uID0gcHNbaV07IH0pO1xyXG4gICAgfTtcclxuICAgIFNvbHZlci5wcm90b3R5cGUubW9zdFZpb2xhdGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBtaW5TbGFjayA9IE51bWJlci5NQVhfVkFMVUUsIHYgPSBudWxsLCBsID0gdGhpcy5pbmFjdGl2ZSwgbiA9IGwubGVuZ3RoLCBkZWxldGVQb2ludCA9IG47XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHtcclxuICAgICAgICAgICAgdmFyIGMgPSBsW2ldO1xyXG4gICAgICAgICAgICBpZiAoYy51bnNhdGlzZmlhYmxlKVxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIHZhciBzbGFjayA9IGMuc2xhY2soKTtcclxuICAgICAgICAgICAgaWYgKGMuZXF1YWxpdHkgfHwgc2xhY2sgPCBtaW5TbGFjaykge1xyXG4gICAgICAgICAgICAgICAgbWluU2xhY2sgPSBzbGFjaztcclxuICAgICAgICAgICAgICAgIHYgPSBjO1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlUG9pbnQgPSBpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGMuZXF1YWxpdHkpXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRlbGV0ZVBvaW50ICE9PSBuICYmXHJcbiAgICAgICAgICAgIChtaW5TbGFjayA8IFNvbHZlci5aRVJPX1VQUEVSQk9VTkQgJiYgIXYuYWN0aXZlIHx8IHYuZXF1YWxpdHkpKSB7XHJcbiAgICAgICAgICAgIGxbZGVsZXRlUG9pbnRdID0gbFtuIC0gMV07XHJcbiAgICAgICAgICAgIGwubGVuZ3RoID0gbiAtIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2O1xyXG4gICAgfTtcclxuICAgIFNvbHZlci5wcm90b3R5cGUuc2F0aXNmeSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5icyA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYnMgPSBuZXcgQmxvY2tzKHRoaXMudnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmJzLnNwbGl0KHRoaXMuaW5hY3RpdmUpO1xyXG4gICAgICAgIHZhciB2ID0gbnVsbDtcclxuICAgICAgICB3aGlsZSAoKHYgPSB0aGlzLm1vc3RWaW9sYXRlZCgpKSAmJiAodi5lcXVhbGl0eSB8fCB2LnNsYWNrKCkgPCBTb2x2ZXIuWkVST19VUFBFUkJPVU5EICYmICF2LmFjdGl2ZSkpIHtcclxuICAgICAgICAgICAgdmFyIGxiID0gdi5sZWZ0LmJsb2NrLCByYiA9IHYucmlnaHQuYmxvY2s7XHJcbiAgICAgICAgICAgIGlmIChsYiAhPT0gcmIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYnMubWVyZ2Uodik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobGIuaXNBY3RpdmVEaXJlY3RlZFBhdGhCZXR3ZWVuKHYucmlnaHQsIHYubGVmdCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2LnVuc2F0aXNmaWFibGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHNwbGl0ID0gbGIuc3BsaXRCZXR3ZWVuKHYubGVmdCwgdi5yaWdodCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3BsaXQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJzLmluc2VydChzcGxpdC5sYik7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5icy5pbnNlcnQoc3BsaXQucmIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnMucmVtb3ZlKGxiKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmluYWN0aXZlLnB1c2goc3BsaXQuY29uc3RyYWludCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2LnVuc2F0aXNmaWFibGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHYuc2xhY2soKSA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmFjdGl2ZS5wdXNoKHYpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5icy5tZXJnZSh2KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBTb2x2ZXIucHJvdG90eXBlLnNvbHZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuc2F0aXNmeSgpO1xyXG4gICAgICAgIHZhciBsYXN0Y29zdCA9IE51bWJlci5NQVhfVkFMVUUsIGNvc3QgPSB0aGlzLmJzLmNvc3QoKTtcclxuICAgICAgICB3aGlsZSAoTWF0aC5hYnMobGFzdGNvc3QgLSBjb3N0KSA+IDAuMDAwMSkge1xyXG4gICAgICAgICAgICB0aGlzLnNhdGlzZnkoKTtcclxuICAgICAgICAgICAgbGFzdGNvc3QgPSBjb3N0O1xyXG4gICAgICAgICAgICBjb3N0ID0gdGhpcy5icy5jb3N0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb3N0O1xyXG4gICAgfTtcclxuICAgIFNvbHZlci5MQUdSQU5HSUFOX1RPTEVSQU5DRSA9IC0xZS00O1xyXG4gICAgU29sdmVyLlpFUk9fVVBQRVJCT1VORCA9IC0xZS0xMDtcclxuICAgIHJldHVybiBTb2x2ZXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuU29sdmVyID0gU29sdmVyO1xyXG5mdW5jdGlvbiByZW1vdmVPdmVybGFwSW5PbmVEaW1lbnNpb24oc3BhbnMsIGxvd2VyQm91bmQsIHVwcGVyQm91bmQpIHtcclxuICAgIHZhciB2cyA9IHNwYW5zLm1hcChmdW5jdGlvbiAocykgeyByZXR1cm4gbmV3IFZhcmlhYmxlKHMuZGVzaXJlZENlbnRlcik7IH0pO1xyXG4gICAgdmFyIGNzID0gW107XHJcbiAgICB2YXIgbiA9IHNwYW5zLmxlbmd0aDtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbiAtIDE7IGkrKykge1xyXG4gICAgICAgIHZhciBsZWZ0ID0gc3BhbnNbaV0sIHJpZ2h0ID0gc3BhbnNbaSArIDFdO1xyXG4gICAgICAgIGNzLnB1c2gobmV3IENvbnN0cmFpbnQodnNbaV0sIHZzW2kgKyAxXSwgKGxlZnQuc2l6ZSArIHJpZ2h0LnNpemUpIC8gMikpO1xyXG4gICAgfVxyXG4gICAgdmFyIGxlZnRNb3N0ID0gdnNbMF0sIHJpZ2h0TW9zdCA9IHZzW24gLSAxXSwgbGVmdE1vc3RTaXplID0gc3BhbnNbMF0uc2l6ZSAvIDIsIHJpZ2h0TW9zdFNpemUgPSBzcGFuc1tuIC0gMV0uc2l6ZSAvIDI7XHJcbiAgICB2YXIgdkxvd2VyID0gbnVsbCwgdlVwcGVyID0gbnVsbDtcclxuICAgIGlmIChsb3dlckJvdW5kKSB7XHJcbiAgICAgICAgdkxvd2VyID0gbmV3IFZhcmlhYmxlKGxvd2VyQm91bmQsIGxlZnRNb3N0LndlaWdodCAqIDEwMDApO1xyXG4gICAgICAgIHZzLnB1c2godkxvd2VyKTtcclxuICAgICAgICBjcy5wdXNoKG5ldyBDb25zdHJhaW50KHZMb3dlciwgbGVmdE1vc3QsIGxlZnRNb3N0U2l6ZSkpO1xyXG4gICAgfVxyXG4gICAgaWYgKHVwcGVyQm91bmQpIHtcclxuICAgICAgICB2VXBwZXIgPSBuZXcgVmFyaWFibGUodXBwZXJCb3VuZCwgcmlnaHRNb3N0LndlaWdodCAqIDEwMDApO1xyXG4gICAgICAgIHZzLnB1c2godlVwcGVyKTtcclxuICAgICAgICBjcy5wdXNoKG5ldyBDb25zdHJhaW50KHJpZ2h0TW9zdCwgdlVwcGVyLCByaWdodE1vc3RTaXplKSk7XHJcbiAgICB9XHJcbiAgICB2YXIgc29sdmVyID0gbmV3IFNvbHZlcih2cywgY3MpO1xyXG4gICAgc29sdmVyLnNvbHZlKCk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG5ld0NlbnRlcnM6IHZzLnNsaWNlKDAsIHNwYW5zLmxlbmd0aCkubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiB2LnBvc2l0aW9uKCk7IH0pLFxyXG4gICAgICAgIGxvd2VyQm91bmQ6IHZMb3dlciA/IHZMb3dlci5wb3NpdGlvbigpIDogbGVmdE1vc3QucG9zaXRpb24oKSAtIGxlZnRNb3N0U2l6ZSxcclxuICAgICAgICB1cHBlckJvdW5kOiB2VXBwZXIgPyB2VXBwZXIucG9zaXRpb24oKSA6IHJpZ2h0TW9zdC5wb3NpdGlvbigpICsgcmlnaHRNb3N0U2l6ZVxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLnJlbW92ZU92ZXJsYXBJbk9uZURpbWVuc2lvbiA9IHJlbW92ZU92ZXJsYXBJbk9uZURpbWVuc2lvbjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dnBzYy5qcy5tYXAiLCIoZnVuY3Rpb24oc2VsZikge1xuICAndXNlIHN0cmljdCc7XG5cbiAgaWYgKHNlbGYuZmV0Y2gpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBzdXBwb3J0ID0ge1xuICAgIHNlYXJjaFBhcmFtczogJ1VSTFNlYXJjaFBhcmFtcycgaW4gc2VsZixcbiAgICBpdGVyYWJsZTogJ1N5bWJvbCcgaW4gc2VsZiAmJiAnaXRlcmF0b3InIGluIFN5bWJvbCxcbiAgICBibG9iOiAnRmlsZVJlYWRlcicgaW4gc2VsZiAmJiAnQmxvYicgaW4gc2VsZiAmJiAoZnVuY3Rpb24oKSB7XG4gICAgICB0cnkge1xuICAgICAgICBuZXcgQmxvYigpXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfSkoKSxcbiAgICBmb3JtRGF0YTogJ0Zvcm1EYXRhJyBpbiBzZWxmLFxuICAgIGFycmF5QnVmZmVyOiAnQXJyYXlCdWZmZXInIGluIHNlbGZcbiAgfVxuXG4gIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyKSB7XG4gICAgdmFyIHZpZXdDbGFzc2VzID0gW1xuICAgICAgJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgICAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgICAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICAgICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICAgICdbb2JqZWN0IFVpbnQzMkFycmF5XScsXG4gICAgICAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICAgICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nXG4gICAgXVxuXG4gICAgdmFyIGlzRGF0YVZpZXcgPSBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgRGF0YVZpZXcucHJvdG90eXBlLmlzUHJvdG90eXBlT2Yob2JqKVxuICAgIH1cblxuICAgIHZhciBpc0FycmF5QnVmZmVyVmlldyA9IEFycmF5QnVmZmVyLmlzVmlldyB8fCBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdmlld0NsYXNzZXMuaW5kZXhPZihPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSkgPiAtMVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZU5hbWUobmFtZSkge1xuICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIG5hbWUgPSBTdHJpbmcobmFtZSlcbiAgICB9XG4gICAgaWYgKC9bXmEtejAtOVxcLSMkJSYnKisuXFxeX2B8fl0vaS50ZXN0KG5hbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGNoYXJhY3RlciBpbiBoZWFkZXIgZmllbGQgbmFtZScpXG4gICAgfVxuICAgIHJldHVybiBuYW1lLnRvTG93ZXJDYXNlKClcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHZhbHVlID0gU3RyaW5nKHZhbHVlKVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIC8vIEJ1aWxkIGEgZGVzdHJ1Y3RpdmUgaXRlcmF0b3IgZm9yIHRoZSB2YWx1ZSBsaXN0XG4gIGZ1bmN0aW9uIGl0ZXJhdG9yRm9yKGl0ZW1zKSB7XG4gICAgdmFyIGl0ZXJhdG9yID0ge1xuICAgICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGl0ZW1zLnNoaWZ0KClcbiAgICAgICAgcmV0dXJuIHtkb25lOiB2YWx1ZSA9PT0gdW5kZWZpbmVkLCB2YWx1ZTogdmFsdWV9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN1cHBvcnQuaXRlcmFibGUpIHtcbiAgICAgIGl0ZXJhdG9yW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGl0ZXJhdG9yXG4gIH1cblxuICBmdW5jdGlvbiBIZWFkZXJzKGhlYWRlcnMpIHtcbiAgICB0aGlzLm1hcCA9IHt9XG5cbiAgICBpZiAoaGVhZGVycyBpbnN0YW5jZW9mIEhlYWRlcnMpIHtcbiAgICAgIGhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgICB0aGlzLmFwcGVuZChuYW1lLCB2YWx1ZSlcbiAgICAgIH0sIHRoaXMpXG5cbiAgICB9IGVsc2UgaWYgKGhlYWRlcnMpIHtcbiAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGhlYWRlcnMpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICB0aGlzLmFwcGVuZChuYW1lLCBoZWFkZXJzW25hbWVdKVxuICAgICAgfSwgdGhpcylcbiAgICB9XG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIG5hbWUgPSBub3JtYWxpemVOYW1lKG5hbWUpXG4gICAgdmFsdWUgPSBub3JtYWxpemVWYWx1ZSh2YWx1ZSlcbiAgICB2YXIgbGlzdCA9IHRoaXMubWFwW25hbWVdXG4gICAgaWYgKCFsaXN0KSB7XG4gICAgICBsaXN0ID0gW11cbiAgICAgIHRoaXMubWFwW25hbWVdID0gbGlzdFxuICAgIH1cbiAgICBsaXN0LnB1c2godmFsdWUpXG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgZGVsZXRlIHRoaXMubWFwW25vcm1hbGl6ZU5hbWUobmFtZSldXG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIHZhbHVlcyA9IHRoaXMubWFwW25vcm1hbGl6ZU5hbWUobmFtZSldXG4gICAgcmV0dXJuIHZhbHVlcyA/IHZhbHVlc1swXSA6IG51bGxcbiAgfVxuXG4gIEhlYWRlcnMucHJvdG90eXBlLmdldEFsbCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5tYXBbbm9ybWFsaXplTmFtZShuYW1lKV0gfHwgW11cbiAgfVxuXG4gIEhlYWRlcnMucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAuaGFzT3duUHJvcGVydHkobm9ybWFsaXplTmFtZShuYW1lKSlcbiAgfVxuXG4gIEhlYWRlcnMucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgdGhpcy5tYXBbbm9ybWFsaXplTmFtZShuYW1lKV0gPSBbbm9ybWFsaXplVmFsdWUodmFsdWUpXVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcy5tYXApLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgdGhpcy5tYXBbbmFtZV0uZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHZhbHVlLCBuYW1lLCB0aGlzKVxuICAgICAgfSwgdGhpcylcbiAgICB9LCB0aGlzKVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpdGVtcyA9IFtdXG4gICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7IGl0ZW1zLnB1c2gobmFtZSkgfSlcbiAgICByZXR1cm4gaXRlcmF0b3JGb3IoaXRlbXMpXG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaXRlbXMgPSBbXVxuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkgeyBpdGVtcy5wdXNoKHZhbHVlKSB9KVxuICAgIHJldHVybiBpdGVyYXRvckZvcihpdGVtcylcbiAgfVxuXG4gIEhlYWRlcnMucHJvdG90eXBlLmVudHJpZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaXRlbXMgPSBbXVxuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkgeyBpdGVtcy5wdXNoKFtuYW1lLCB2YWx1ZV0pIH0pXG4gICAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxuICB9XG5cbiAgaWYgKHN1cHBvcnQuaXRlcmFibGUpIHtcbiAgICBIZWFkZXJzLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gSGVhZGVycy5wcm90b3R5cGUuZW50cmllc1xuICB9XG5cbiAgZnVuY3Rpb24gY29uc3VtZWQoYm9keSkge1xuICAgIGlmIChib2R5LmJvZHlVc2VkKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IFR5cGVFcnJvcignQWxyZWFkeSByZWFkJykpXG4gICAgfVxuICAgIGJvZHkuYm9keVVzZWQgPSB0cnVlXG4gIH1cblxuICBmdW5jdGlvbiBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXNvbHZlKHJlYWRlci5yZXN1bHQpXG4gICAgICB9XG4gICAgICByZWFkZXIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QocmVhZGVyLmVycm9yKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiByZWFkQmxvYkFzQXJyYXlCdWZmZXIoYmxvYikge1xuICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpXG4gICAgdmFyIHByb21pc2UgPSBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKVxuICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihibG9iKVxuICAgIHJldHVybiBwcm9taXNlXG4gIH1cblxuICBmdW5jdGlvbiByZWFkQmxvYkFzVGV4dChibG9iKSB7XG4gICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKClcbiAgICB2YXIgcHJvbWlzZSA9IGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpXG4gICAgcmVhZGVyLnJlYWRBc1RleHQoYmxvYilcbiAgICByZXR1cm4gcHJvbWlzZVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZEFycmF5QnVmZmVyQXNUZXh0KGJ1Zikge1xuICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYnVmKVxuICAgIHZhciBjaGFycyA9IG5ldyBBcnJheSh2aWV3Lmxlbmd0aClcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5sZW5ndGg7IGkrKykge1xuICAgICAgY2hhcnNbaV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHZpZXdbaV0pXG4gICAgfVxuICAgIHJldHVybiBjaGFycy5qb2luKCcnKVxuICB9XG5cbiAgZnVuY3Rpb24gYnVmZmVyQ2xvbmUoYnVmKSB7XG4gICAgaWYgKGJ1Zi5zbGljZSkge1xuICAgICAgcmV0dXJuIGJ1Zi5zbGljZSgwKVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGJ1Zi5ieXRlTGVuZ3RoKVxuICAgICAgdmlldy5zZXQobmV3IFVpbnQ4QXJyYXkoYnVmKSlcbiAgICAgIHJldHVybiB2aWV3LmJ1ZmZlclxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIEJvZHkoKSB7XG4gICAgdGhpcy5ib2R5VXNlZCA9IGZhbHNlXG5cbiAgICB0aGlzLl9pbml0Qm9keSA9IGZ1bmN0aW9uKGJvZHkpIHtcbiAgICAgIHRoaXMuX2JvZHlJbml0ID0gYm9keVxuICAgICAgaWYgKCFib2R5KSB7XG4gICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gJydcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gYm9keVxuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmJsb2IgJiYgQmxvYi5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5QmxvYiA9IGJvZHlcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5mb3JtRGF0YSAmJiBGb3JtRGF0YS5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5Rm9ybURhdGEgPSBib2R5XG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuc2VhcmNoUGFyYW1zICYmIFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5VGV4dCA9IGJvZHkudG9TdHJpbmcoKVxuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyICYmIHN1cHBvcnQuYmxvYiAmJiBpc0RhdGFWaWV3KGJvZHkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlBcnJheUJ1ZmZlciA9IGJ1ZmZlckNsb25lKGJvZHkuYnVmZmVyKVxuICAgICAgICAvLyBJRSAxMC0xMSBjYW4ndCBoYW5kbGUgYSBEYXRhVmlldyBib2R5LlxuICAgICAgICB0aGlzLl9ib2R5SW5pdCA9IG5ldyBCbG9iKFt0aGlzLl9ib2R5QXJyYXlCdWZmZXJdKVxuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyICYmIChBcnJheUJ1ZmZlci5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSB8fCBpc0FycmF5QnVmZmVyVmlldyhib2R5KSkpIHtcbiAgICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyID0gYnVmZmVyQ2xvbmUoYm9keSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5zdXBwb3J0ZWQgQm9keUluaXQgdHlwZScpXG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJykpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsICd0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLTgnKVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlCbG9iICYmIHRoaXMuX2JvZHlCbG9iLnR5cGUpIHtcbiAgICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCB0aGlzLl9ib2R5QmxvYi50eXBlKVxuICAgICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuc2VhcmNoUGFyYW1zICYmIFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD1VVEYtOCcpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3VwcG9ydC5ibG9iKSB7XG4gICAgICB0aGlzLmJsb2IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlamVjdGVkID0gY29uc3VtZWQodGhpcylcbiAgICAgICAgaWYgKHJlamVjdGVkKSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdGVkXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fYm9keUJsb2IpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2JvZHlCbG9iKVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEJsb2IoW3RoaXMuX2JvZHlBcnJheUJ1ZmZlcl0pKVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlGb3JtRGF0YSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHJlYWQgRm9ybURhdGEgYm9keSBhcyBibG9iJylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBCbG9iKFt0aGlzLl9ib2R5VGV4dF0pKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYXJyYXlCdWZmZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikge1xuICAgICAgICAgIHJldHVybiBjb25zdW1lZCh0aGlzKSB8fCBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keUFycmF5QnVmZmVyKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLmJsb2IoKS50aGVuKHJlYWRCbG9iQXNBcnJheUJ1ZmZlcilcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMudGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJlamVjdGVkID0gY29uc3VtZWQodGhpcylcbiAgICAgIGlmIChyZWplY3RlZCkge1xuICAgICAgICByZXR1cm4gcmVqZWN0ZWRcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2JvZHlCbG9iKSB7XG4gICAgICAgIHJldHVybiByZWFkQmxvYkFzVGV4dCh0aGlzLl9ib2R5QmxvYilcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVhZEFycmF5QnVmZmVyQXNUZXh0KHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikpXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlGb3JtRGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkIG5vdCByZWFkIEZvcm1EYXRhIGJvZHkgYXMgdGV4dCcpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2JvZHlUZXh0KVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdXBwb3J0LmZvcm1EYXRhKSB7XG4gICAgICB0aGlzLmZvcm1EYXRhID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRleHQoKS50aGVuKGRlY29kZSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmpzb24gPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnRleHQoKS50aGVuKEpTT04ucGFyc2UpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8vIEhUVFAgbWV0aG9kcyB3aG9zZSBjYXBpdGFsaXphdGlvbiBzaG91bGQgYmUgbm9ybWFsaXplZFxuICB2YXIgbWV0aG9kcyA9IFsnREVMRVRFJywgJ0dFVCcsICdIRUFEJywgJ09QVElPTlMnLCAnUE9TVCcsICdQVVQnXVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZU1ldGhvZChtZXRob2QpIHtcbiAgICB2YXIgdXBjYXNlZCA9IG1ldGhvZC50b1VwcGVyQ2FzZSgpXG4gICAgcmV0dXJuIChtZXRob2RzLmluZGV4T2YodXBjYXNlZCkgPiAtMSkgPyB1cGNhc2VkIDogbWV0aG9kXG4gIH1cblxuICBmdW5jdGlvbiBSZXF1ZXN0KGlucHV0LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgICB2YXIgYm9keSA9IG9wdGlvbnMuYm9keVxuXG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMudXJsID0gaW5wdXRcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlucHV0LmJvZHlVc2VkKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FscmVhZHkgcmVhZCcpXG4gICAgICB9XG4gICAgICB0aGlzLnVybCA9IGlucHV0LnVybFxuICAgICAgdGhpcy5jcmVkZW50aWFscyA9IGlucHV0LmNyZWRlbnRpYWxzXG4gICAgICBpZiAoIW9wdGlvbnMuaGVhZGVycykge1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhpbnB1dC5oZWFkZXJzKVxuICAgICAgfVxuICAgICAgdGhpcy5tZXRob2QgPSBpbnB1dC5tZXRob2RcbiAgICAgIHRoaXMubW9kZSA9IGlucHV0Lm1vZGVcbiAgICAgIGlmICghYm9keSAmJiBpbnB1dC5fYm9keUluaXQgIT0gbnVsbCkge1xuICAgICAgICBib2R5ID0gaW5wdXQuX2JvZHlJbml0XG4gICAgICAgIGlucHV0LmJvZHlVc2VkID0gdHJ1ZVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuY3JlZGVudGlhbHMgPSBvcHRpb25zLmNyZWRlbnRpYWxzIHx8IHRoaXMuY3JlZGVudGlhbHMgfHwgJ29taXQnXG4gICAgaWYgKG9wdGlvbnMuaGVhZGVycyB8fCAhdGhpcy5oZWFkZXJzKSB7XG4gICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhvcHRpb25zLmhlYWRlcnMpXG4gICAgfVxuICAgIHRoaXMubWV0aG9kID0gbm9ybWFsaXplTWV0aG9kKG9wdGlvbnMubWV0aG9kIHx8IHRoaXMubWV0aG9kIHx8ICdHRVQnKVxuICAgIHRoaXMubW9kZSA9IG9wdGlvbnMubW9kZSB8fCB0aGlzLm1vZGUgfHwgbnVsbFxuICAgIHRoaXMucmVmZXJyZXIgPSBudWxsXG5cbiAgICBpZiAoKHRoaXMubWV0aG9kID09PSAnR0VUJyB8fCB0aGlzLm1ldGhvZCA9PT0gJ0hFQUQnKSAmJiBib2R5KSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCb2R5IG5vdCBhbGxvd2VkIGZvciBHRVQgb3IgSEVBRCByZXF1ZXN0cycpXG4gICAgfVxuICAgIHRoaXMuX2luaXRCb2R5KGJvZHkpXG4gIH1cblxuICBSZXF1ZXN0LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgUmVxdWVzdCh0aGlzLCB7IGJvZHk6IHRoaXMuX2JvZHlJbml0IH0pXG4gIH1cblxuICBmdW5jdGlvbiBkZWNvZGUoYm9keSkge1xuICAgIHZhciBmb3JtID0gbmV3IEZvcm1EYXRhKClcbiAgICBib2R5LnRyaW0oKS5zcGxpdCgnJicpLmZvckVhY2goZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICAgIGlmIChieXRlcykge1xuICAgICAgICB2YXIgc3BsaXQgPSBieXRlcy5zcGxpdCgnPScpXG4gICAgICAgIHZhciBuYW1lID0gc3BsaXQuc2hpZnQoKS5yZXBsYWNlKC9cXCsvZywgJyAnKVxuICAgICAgICB2YXIgdmFsdWUgPSBzcGxpdC5qb2luKCc9JykucmVwbGFjZSgvXFwrL2csICcgJylcbiAgICAgICAgZm9ybS5hcHBlbmQoZGVjb2RlVVJJQ29tcG9uZW50KG5hbWUpLCBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpKVxuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIGZvcm1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlSGVhZGVycyhyYXdIZWFkZXJzKSB7XG4gICAgdmFyIGhlYWRlcnMgPSBuZXcgSGVhZGVycygpXG4gICAgcmF3SGVhZGVycy5zcGxpdCgnXFxyXFxuJykuZm9yRWFjaChmdW5jdGlvbihsaW5lKSB7XG4gICAgICB2YXIgcGFydHMgPSBsaW5lLnNwbGl0KCc6JylcbiAgICAgIHZhciBrZXkgPSBwYXJ0cy5zaGlmdCgpLnRyaW0oKVxuICAgICAgaWYgKGtleSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBwYXJ0cy5qb2luKCc6JykudHJpbSgpXG4gICAgICAgIGhlYWRlcnMuYXBwZW5kKGtleSwgdmFsdWUpXG4gICAgICB9XG4gICAgfSlcbiAgICByZXR1cm4gaGVhZGVyc1xuICB9XG5cbiAgQm9keS5jYWxsKFJlcXVlc3QucHJvdG90eXBlKVxuXG4gIGZ1bmN0aW9uIFJlc3BvbnNlKGJvZHlJbml0LCBvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0ge31cbiAgICB9XG5cbiAgICB0aGlzLnR5cGUgPSAnZGVmYXVsdCdcbiAgICB0aGlzLnN0YXR1cyA9ICdzdGF0dXMnIGluIG9wdGlvbnMgPyBvcHRpb25zLnN0YXR1cyA6IDIwMFxuICAgIHRoaXMub2sgPSB0aGlzLnN0YXR1cyA+PSAyMDAgJiYgdGhpcy5zdGF0dXMgPCAzMDBcbiAgICB0aGlzLnN0YXR1c1RleHQgPSAnc3RhdHVzVGV4dCcgaW4gb3B0aW9ucyA/IG9wdGlvbnMuc3RhdHVzVGV4dCA6ICdPSydcbiAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhvcHRpb25zLmhlYWRlcnMpXG4gICAgdGhpcy51cmwgPSBvcHRpb25zLnVybCB8fCAnJ1xuICAgIHRoaXMuX2luaXRCb2R5KGJvZHlJbml0KVxuICB9XG5cbiAgQm9keS5jYWxsKFJlc3BvbnNlLnByb3RvdHlwZSlcblxuICBSZXNwb25zZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKHRoaXMuX2JvZHlJbml0LCB7XG4gICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgICAgc3RhdHVzVGV4dDogdGhpcy5zdGF0dXNUZXh0LFxuICAgICAgaGVhZGVyczogbmV3IEhlYWRlcnModGhpcy5oZWFkZXJzKSxcbiAgICAgIHVybDogdGhpcy51cmxcbiAgICB9KVxuICB9XG5cbiAgUmVzcG9uc2UuZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UobnVsbCwge3N0YXR1czogMCwgc3RhdHVzVGV4dDogJyd9KVxuICAgIHJlc3BvbnNlLnR5cGUgPSAnZXJyb3InXG4gICAgcmV0dXJuIHJlc3BvbnNlXG4gIH1cblxuICB2YXIgcmVkaXJlY3RTdGF0dXNlcyA9IFszMDEsIDMwMiwgMzAzLCAzMDcsIDMwOF1cblxuICBSZXNwb25zZS5yZWRpcmVjdCA9IGZ1bmN0aW9uKHVybCwgc3RhdHVzKSB7XG4gICAgaWYgKHJlZGlyZWN0U3RhdHVzZXMuaW5kZXhPZihzdGF0dXMpID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgc3RhdHVzIGNvZGUnKVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgUmVzcG9uc2UobnVsbCwge3N0YXR1czogc3RhdHVzLCBoZWFkZXJzOiB7bG9jYXRpb246IHVybH19KVxuICB9XG5cbiAgc2VsZi5IZWFkZXJzID0gSGVhZGVyc1xuICBzZWxmLlJlcXVlc3QgPSBSZXF1ZXN0XG4gIHNlbGYuUmVzcG9uc2UgPSBSZXNwb25zZVxuXG4gIHNlbGYuZmV0Y2ggPSBmdW5jdGlvbihpbnB1dCwgaW5pdCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciByZXF1ZXN0ID0gbmV3IFJlcXVlc3QoaW5wdXQsIGluaXQpXG4gICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KClcblxuICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICBzdGF0dXM6IHhoci5zdGF0dXMsXG4gICAgICAgICAgc3RhdHVzVGV4dDogeGhyLnN0YXR1c1RleHQsXG4gICAgICAgICAgaGVhZGVyczogcGFyc2VIZWFkZXJzKHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSB8fCAnJylcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zLnVybCA9ICdyZXNwb25zZVVSTCcgaW4geGhyID8geGhyLnJlc3BvbnNlVVJMIDogb3B0aW9ucy5oZWFkZXJzLmdldCgnWC1SZXF1ZXN0LVVSTCcpXG4gICAgICAgIHZhciBib2R5ID0gJ3Jlc3BvbnNlJyBpbiB4aHIgPyB4aHIucmVzcG9uc2UgOiB4aHIucmVzcG9uc2VUZXh0XG4gICAgICAgIHJlc29sdmUobmV3IFJlc3BvbnNlKGJvZHksIG9wdGlvbnMpKVxuICAgICAgfVxuXG4gICAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QobmV3IFR5cGVFcnJvcignTmV0d29yayByZXF1ZXN0IGZhaWxlZCcpKVxuICAgICAgfVxuXG4gICAgICB4aHIub250aW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKCdOZXR3b3JrIHJlcXVlc3QgZmFpbGVkJykpXG4gICAgICB9XG5cbiAgICAgIHhoci5vcGVuKHJlcXVlc3QubWV0aG9kLCByZXF1ZXN0LnVybCwgdHJ1ZSlcblxuICAgICAgaWYgKHJlcXVlc3QuY3JlZGVudGlhbHMgPT09ICdpbmNsdWRlJykge1xuICAgICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZVxuICAgICAgfVxuXG4gICAgICBpZiAoJ3Jlc3BvbnNlVHlwZScgaW4geGhyICYmIHN1cHBvcnQuYmxvYikge1xuICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2Jsb2InXG4gICAgICB9XG5cbiAgICAgIHJlcXVlc3QuaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKG5hbWUsIHZhbHVlKVxuICAgICAgfSlcblxuICAgICAgeGhyLnNlbmQodHlwZW9mIHJlcXVlc3QuX2JvZHlJbml0ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiByZXF1ZXN0Ll9ib2R5SW5pdClcbiAgICB9KVxuICB9XG4gIHNlbGYuZmV0Y2gucG9seWZpbGwgPSB0cnVlXG59KSh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDogdGhpcyk7XG4iLCJleHBvcnQgY29uc3QgVU5LTk9XX0lNQUdFID0gJ2RhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBSkFBQUFDN0NBWUFBQUNLTFJkTkFBQUFCSE5DU1ZRSUNBZ0lmQWhraUFBQUFBbHdTRmx6QUFBUzZ3QUFFdXNCeEk4dE93QUFBQmwwUlZoMFUyOW1kSGRoY21VQWQzZDNMbWx1YTNOallYQmxMbTl5WjV2dVBCb0FBQW5zU1VSQlZIaWM3ZHhaU0ZUOUg4Znh6OHprbzZJcGFKb29MYlpSWnRFWUZVRVVhaGR0Qm1MTGhiUlIxb1dSWUVsaWxDMDNTUnNaYmJTTDBZSTNsVkZVdE9GUzRCSldUdjdUSkVpeGJNOXd5em4vaXg3aTMvUFhIajNmMzh5WmNUNHZHQ2ltMzYrdjh1WWNuVGx6Z0o5U0FMd0VvUEhCUnk4ZUwvR3pHWmdBckFWd0hFUjl0ODRFNEQ4QVJoczlDYm1sbHlZQVhRRE1SazlDYnNsdXdzOXpHcEV1UFBLUXlJQ2VuZ2dPRG9iVmFuWG1MT1NpS2lzcjhlSERoMjZmNnpHZ0tWT200TWFOR3c0Yml0ekgzTGx6Y2ZQbXpXNmY0eW1NUkJnUWlUQWdFbUZBSk1LQVNJUUJrUWdESWhFR1JDSU1pRVFZRUlrd0lCSmhRQ1RDZ0VpRUFaRUlBeUlSQmtRaURJaEVHQkNKTUNBU1lVQWt3b0JJaEFHUkNBTWlFUVpFSWd5SVJCZ1FpVEFnRW1GQUpNS0FTSVFCa1FnRElwRWU3dy9rS1JvYkc5SFEwSURtNW1hOGYvOGV6YzNOK1BIakJ6NTkrdlRidndzTURJVFpiTWFnUVlNUUZoYUdpSWdJaEllSEl6UTAxS0RKWFlOSEJOVFoyUW1iellhcXFpcFVWVldodXJvYXIxNjlRbjE5UGRyYTJrUjdCd1VGWWNLRUNZaU9qc2EwYWRNUUh4K1A4UEJ3UlpPN3ZuNFpVRk5URTBwS1NsQlVWSVRTMGxKVVZGU2dvNlBESWYvWHg0OGY4ZURCQXp4NDhBQ0hEeDhHQUl3Yk53N3o1czFEY25KeXY3OU5ZTDhJcUs2dURuZnUzRUZKU1FtS2k0dFJWMWRuNkR3Mm13MDJtdzM3OXUzRCtQSGpzV2JOR3F4WnN3YisvdjZHenVVbzNkN09mczZjT1pxcnN0dnRXbkZ4c2JacDB5WnQ3Tml4UnQvMnYxZVA0T0JnYmZ2Mjdkcm56NStOL3ZiMTJadzVjLzcwdGJsWFFQdjI3ZE1pSXlNTkQwTHZJeXdzVE12THk5UHNkcnZSMzhwZSsxTkFidmRyZkg1K1B1cnI2NDBlUTdlbXBpWXNYNzRjY1hGeGVQUG1qZEhqaUxsZFFQM0YvZnYzWWJWYWU3eDlycnRnUUFaNi8vNDk1cytmajl6Y1hLTkgwWTBCR2N4dXR5TXRMUTJabVpsR2o2SUxBM0lST1RrNTJMWnRtOUZqOUJrRGNpRzdkdTNDMGFOSGpSNmpUeGlRaTBsTFMwTkpTWW5SWS9SYXYzZ2x1cThzRmd1aW9xSmd0Vm94WXNRSURCOCtITU9HRFVORVJBUzh2THdRR0JnSWIyOXZtTTFtZlBueTVkZWpxYWtKVDU0OFFWbFpHY3JMeTlIUTBLQjh0czdPVHF4WXNRSlBuanlCbjUrZjh2MVY4NGlBekdZenBrNmRpb1NFQk15WU1RTXhNVEc5Zmx2Qng4Y0hnd2NQL3ZYM2hJU0VYMyt1cTZ0RFFVRUJ6cHc1ZzVxYUdtWHoxdGJXSWpNekU0Y09IVksycHlPNTFTdlJWcXUxVjYvNG1rd21MVFkyVmp0NThxVFcxTlRrMEpuc2RydDIvZnAxTFNZbVJ0a3IxZ01HRE5CcWFtb2NPbmR2OWF1M012NHRvTkRRVUMwakk4T1FiNzdkYnRkT25EaWhCUVFFS0lsbzZkS2xUdjhhdXRQdkF6S1pUTnJzMmJPMVM1Y3VhZTN0N1VhUHFOWFgxMnVUSmswU0IyUTJtN1ZYcjE0Wi9lWDByL2ZDL3BmRllrRnljaktlUFh1RzI3ZHZZOG1TSmZqcnI3K01IZ3ZEaHc5SFVWRVJaczJhSmRySGJyZmo3Tm16YW9aeUVMY05LQ2twQ1RhYkRmbjUrWWlLaWpKNm5QL2o1K2VIcTFldklqbzZXclRQdVhQbm9HbWFvcW5VYzd1QWtwS1NjUGZ1WFJRVUZHRDA2TkZHai9OSEFRRUJ1SERoQXJ5OXZYWHY4ZnIxYTFSWFZ5dWNTaTIzQzJqTGxpMklqWTAxZW94ZWk0Nk9SbXBxcW1pUHUzZnZLcHBHUGJjTHlCMWxabWFLZmpaNytQQ2h3bW5VWWtCT0VCSVM4dHNMa0gybDhrVksxUmlRa3l4WXNFRDMydHJhV3RqdGRvWFRxTU9BbkdUbXpKbTYxN2EydHVMZHUzY0twMUdIQVRsSlpHUWtmSDE5ZGEvLzl1MmJ3bW5VWVVCT1lqS1pNR3pZTU4zckdSQWhJQ0JBOTFycFI3QWRoUUU1a2VRVTVxclhCakVnSi9yKy9idnV0YTc2c1dnRzVFUXRMUzI2MXpJZ3d1ZlBuM1d0OC9iMnhxQkJneFJQb3dZRGNwS3ZYNy9pN2R1M3V0YU9HREVDRm90RjhVUnFNQ0Fuc2Rsc3VpL0xjT1dyRGhpUWsxUlVWT2hlTzNIaVJJV1RxTVdBbktTd3NGRDMycmk0T0lXVHFNV0FuS0NscFFYMzd0M1R0ZGJIeHdmVHAwOVhQSkU2RE1nSlRwOCtqZGJXVmwxcjQrTGk0T1BqbzNnaWRSaVFnM1YyZG1MLy92MjYxNjljdVZMZE1BN0FnQnhzNzk2OWVQMzZ0YTYxd2NIQldMaHdvZUtKMUdKQURsUlRVNE9kTzNmcVhwK1NraUs2SU44WkdKQ0R0TFcxSVRrNVdmZTc2UDcrL2toUFQxYzhsWG9NeUVIV3IxK1A4dkp5M2V2VDA5TVJFaEtpY0NMSFlFQU9zSHYzYnB3NmRVcjMraUZEaGlBakkwUGhSSTdEZ0JRN2ZmbzBzckt5UkhzY1BIalFaZDk5L3ljR3BOQ1pNMmV3ZHUxYTBVZVJFeE1Ua1ppWXFIQXF4MkpBaWh3NWNnU3JWNjlHVjFlWDdqMkdEaDJLa3lkUEtweks4UmlRa0tacHlNcktRbXBxcXVqSTQrWGxoWXNYTHlJb0tFamhkSTduRWJlNGM1U1dsaGFzWHIwYWx5OWZGdTFqTXBsdy9QaHhsMzdQcXljTVNLZWFtaG9zV3JRSXo1NDlFKysxWThjT3JGcTFTc0ZVenNkVFdCOTFkWFhod0lFRGlJbUpVUkpQZW5vNnRtN2RxbUF5WS9BSTFBZFBuejVGU2tvS0hqOStyR1MvelpzM1kvZnUzVXIyTWdxUFFMM1EzdDZPclZ1M1l2TGt5VXJpTVp2TjJMTm5qOXZIQS9BSTlLOXUzYnFGdExRMHZIanhRc2wrUGo0K09IZnVISllzV2FKa1A2TXhvQjdVMXRaaTQ4YU51SHIxcXJJOWh3d1pna3VYTHJubGIxczlZVUQvOFAzN2Qrelpzd2M1T1RsS1A0OGVIeCtQOCtmUC8zYlgrLzZBUHdQOVRkTTA1T1hsWWRTb1VkaXhZNGV5ZUN3V0M3S3pzM0hyMXExK0Z3L0FJeEFBb0t5c0RCczJiRUJwYWFuU2ZVTkRRM0grL0huTW5qMWI2YjZ1eEtPUFFJMk5qVmkzYmgybVRadW1QSjdGaXhmaitmUG4vVG9ld0lPUFFGKytmTUdZTVdORWQ4em9Ua1JFQkk0ZE95YTZKNkk3OGRnalVFZEhoOUo0VENZVGxpMWJocXFxS28rSkIvRGdJNUJLbzBhTndyRmp4eEFmSDIvMEtFN25zVWNnRlh4OWZaR2RuWTJuVDU5NlpEd0FqMEM2TFZpd0FMbTV1WWlNakRSNkZFUHhDTlJISTBlT1JHRmhJYTVkdStieDhRQThBdlhabzBlUFhQWnVZVWJnRWFpUHZMeThqQjdCcFRBZ0VtRkFKTUtBU0lRQmtRZ0RJaEVHUkNJTWlFUVlFSWt3SUJKaFFDVENnRWlFQVpFSUF5SVJCa1FpSG5zOWtMZTNOeFl2WHR6bmRieWM0M2NlRzFCQVFJRDR6bUxFVXhnSk1TQVNZVUFrd29CSWhBR1JDQU1pRVFaRUlneUlSQmdRaVRBZ0VtRkFKTUtBU01SajMwd3RMQ3hFWTJPanJyVUxGeTVFV0ZpWTRvbmNrOGNHdEgvL2Z0eTdkMC9YMnFpb0tBYjBONTdDU0lRQmtRZ0RJaEVHUkNJTWlFUVlFSWt3SUJKaFFDVENnRWlFQVpFSUF5SVJCa1FpREloRUdCQ0plT3psSEZldVhNR1BIejkwclIwNGNLRGlhZHlYeHdiRUNOVGdLWXhFR0JDSk1DQVNZVUFrd29CSWhBR1JDQU1pRVFaRUlneUlSQmdRaVRBZ0VtRkFKTUtBU0lRQmtRZ0RJaEVHUkNJTWlFUVlFSWt3SUJKaFFDVENnRWlFQVpFSUF5SVJCa1FpREloRUdCQ0pNQ0FTTVFIUXVuc2lPRGdZVnF2VnllT1FLNnFzck1TSER4KzZmYTdIZ0loNmc2Y3dFakVEc0JzOUJMa3R1eGxBbmRGVGtOdXFzd0JvQjVCZzlDVGtscklzQU1vQk5BSVlCeURJMkhuSVRkUUN5QVJ3NHIrMEtoMnVQM1o2YUFBQUFBQkpSVTVFcmtKZ2dnPT0nO1xuZXhwb3J0IGNvbnN0IExJTktfT1BUSU9OUyA9ICdkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUpZQUFBQ1dDQVlBQUFBOEFYSGlBQUFBQkhOQ1NWUUlDQWdJZkFoa2lBQUFBQWx3U0ZsekFBQUc3QUFBQnV3QkhuVTROUUFBQUJsMFJWaDBVMjltZEhkaGNtVUFkM2QzTG1sdWEzTmpZWEJsTG05eVo1dnVQQm9BQUJlVVNVUkJWSGljN1oxNWRGUlZuc2MvcjZxU3lpNlFCVm9nSVFrRVJGbE10RHNxUVFWRWo0YmphTHMwS0RTaXdvQkhRSndNQ0xRZ09LaWNadGhVbW9HNFJCdFJiQndWQjdWcFJFQUpBbUVMSXBIRkJBSUVrckFZUXBKSzFaMC9YaElDWm5tMzZsVzlTbmlmYzM2SFVIWHZlM2Y1MW4zMzNlVjNGYTVlQW9ERUdvc0RZb0ZPUUNUUXJzWWlhOExhZ1pDYXY4dUJTa0FBcGZXc0JEZ0c1QU1Gd0tFYWMzZy9LLzZIWW5RQ2ZFUW9jQk9RQ3R3SVhBOGtBWUZldm04VmNBRDRFY2dCc29FZHdBVXYzOWR3V3F1d1FvQTA0QzVnSUhBRFlETTBSWmVvQnZZQTY0Ri9BcHVBaTRhbXlLUkoyZ09qZ2E5UUswcTBFTHNJckFXZUJxSjFMeFVUdDRnQW5nSytSVzBKakJhSnAxWU5mQU9NQXNKMUxDY1RqZlFIM2tQdHF4Z3RCbS9aQlNBTDlaRnU0a1hzd0FoZ0Y4Wlh1cTl0SitwanZ2Yk4xRVFId29BSndIR01yMkNqN1RRd0U3akdrd0s5MmdrRFhrUWRIeks2UXYzTmlvRnBxTU1vSmhxeG9UYjdKekMrQXYzZFRxTzI1djR5bE9LM0RBWit3dmdLYTJtMkh4amtSbmw3RFg4WklMMFdtQTg4NHVzYkJ3UUVrSmlZU0pjdVhZaU5qYVZUcDA1RVJVWFJybDA3MnJWclIxQlFFQ0VobC9lWnk4dkxxYWlvb0xTMGxKS1NFa3BLU2poNjlDZ0ZCUVg4OHNzdkhENThHSWZEa0ptY2xjQWsxTmJlVUl3V2xvSTZEdlZYMURFcHJ4SWFHa3BLU2dwLytNTWZTRWxKNFlZYmJpQXBLWW1BZ0FCZDcrTndPRGh3NEFENzl1MWorL2J0Yk4yNmxSMDdkbEJlWHE3cmZScmhIUEE4a09tTG0va2puWUF2OGVJandtYXppYlMwTkRGNzlteVJuWjB0SEE2SE1BcUh3eUcyYk5raVhucnBKZEd2WHo5aHM5bTgvWGo4QXZWSmNGWHhJSEFHTHhTbzNXNFg2ZW5wNHUyMzN4WWxKU1dHQ2FrNWlvdUxSV1ptcHJqdnZ2dEVZR0NndDhSVkF0enZsUnIwTSt6QUlyeFFpQ2twS1dMeDRzV2l1TGpZYU0xSWMvcjBhYkZ3NFVLUm5KenNEWEc1VVB1djNsN0pZUmlkZ0IvUXVYVWFNV0tFMkxadG05SGEwSTBmZnZoQlBQNzQ0OEp1dCtzdHNHeGE0YU14RlIxSHpzUER3OFdVS1ZORVVWR1IwVHJ3R2lkT25CQVpHUmtpTEN4TVQzRVZBamQ3c1o1OXlqQjBXc1lTR2hvcXBrK2Y3dGQ5SjcwcExpNFdVNmRPRlNFaElYcUo2eUx3cUZkcjNBZE1SSDNHZTFRWU5wdE5qQmt6UnB3NGNjTG9lamFNd3NKQzhkUlRUd21yMWFxSHVKekFlQy9YdlZkUWdEbm84QXU3N2JiYnhPN2R1NDJ1Vjc5aDU4NmRJalUxVmEvVzY3OHdmaXhUTXdxd0VBOHozYVpORzdGOCtYTGhjcm1Ncmt1L3crbDBpcVZMbDRwcnJybEdEM0hOcHdXSVN4ZFJEUjQ4V0JRVUZCaGRmMzdQOGVQSFJYcDZ1aDdpV29LZmkycytIbVF3S0NoSXZQSEdHMllySllITDVSS0xGaTNTWTNqaXJ6N1FoMXRNdzRPTWRlblNSV3pkdXRYb2VtcXg3Tml4UTNUdDJ0VlRjZjJuRDNRaXhWTjQ4UFozNzczM2luUG56aGxkTnkyZU0yZk9pSHZ1dWNjVFlibUFrZDZYaXpZR29lNzJkU3N6R1JrWm9ycTYydWc2YVRWVVYxZUxTWk1tZVNLdUt1Qk9IK2ltU1JKUVZ6RktaOEJxdFlvbFM1WVlYUSt0bHRkZmYxMVlMQlozeFZVQ2RQV0pnaG9nQW5YbG9uVEM3WGE3V0xWcWxkRmwzK3I1OE1NUFBlblU3OE9ndlkxL2R5T3hJakF3VUh6MjJXZEdsL2xWdzlxMWEwVlFVSkM3NGxycEl5M1ZNYzZkaE5ydGRsTlVCdUNodUo3MmthYm9qUnVUeWphYnpSU1ZnWHp5eVNmdXpqT1dvM3JuOFNvMllMdHM0aFJGRVptWm1VYVg3VlhQdSsrK0t4UkZjVWRjT2FqK3hEUmpsUlRXVE9CUGtuR1lQWHMyRXlaTWtJMW1vak45K3ZUQjVYTHg3YmZmeWtiOUhlcVEwa2I5VXdWOWNXTzhhdWpRb2VZVWpSL2hjcm5FUXc4OTVFNnJWWWtYSG9rSzhKMXNZbEpTVWtSNWViblJaV2x5QlJjdVhCQjkrdlJ4UjF6Zm92Tms5U2paUklTSGg0c0RCdzRZWFlZbWpmRHp6eitMaUlnSWQ4UTFYQzlSUlFDblpCUHcwVWNmR1YxMkpzMndZc1VLZDRSMUV0VmhpOGU4TEh2emtTTkhHbDFtSmhwNTdMSEgzQkhYek9aRTA5eno4bmZBejBpNHkrbllzU043OSs2bGJkdTJXcU9ZR01qWnMyZnAxYXNYeDQ0ZGs0bFdCblJEYmIwYXhOTE1CYVlqNllOcDJiSmxwcWhhRUczYXRPSDExMStYalJZR3ZPRHVQZHVqanJwcWJpSWZmUEJCbzF0MkV6Y1pNbVNJN09Qd0l0REJIV0c5Sm5PamtKQVFrWitmYjNUNW1Mako0Y09IUlhCd3NLeTQ1alFtbnNZZWhkY0EveTZqd2ttVEpoRWJHeXNUeGNTUGlJK1BkMmQyWkJ5TnVKOXFyUE0rRVhWamhDYWlvcUk0ZE9nUUVSRmVkM0ZsNGtYT25qMUwxNjVkS1NrcGtZbjJMUENiVGxwRExaWUNqSkc1OHRTcFUwMVJ0UUxhdEduRDVNbVRaYU0xK0dScnFNVWFDS3pUZXRXb3FDaCsrZVVYUWtOTkI3NnRnYkt5TXVMaTRpZ3RMWldKZGdmcWRFOGREYlZZVDhoY2NmejQ4YWFvV2hGaFlXRTgrK3l6c3RGR1h2bkJsUzFXS0JKRDlzSEJ3Unc5ZXBUSXlNam1BNXUwR0lxTGkrbmN1VE1WRlJWYW81eEhIWHFvTzhYc3loYnJmaVRtZ1lZT0hXcUtxaFVTRlJYRnd3OC9MQk1sQWtpdi84R1Z3cEp5aHoxMjdGaVo0Q1l0Q0RmcTlqS2ZXL1VmaGNHb1IybG9PZ2lvWjgrZTdOdTNUL2JtSmkySTY2Ky9uaDkvL0ZGcjhESWdDblZCNEdVdDFnQWtUcGNhTVdLRTFxQW1MWlEvL1VscUZYb1ljSHZ0ZitvTDYxNnRWMUFVUmZhbUppMlFZY09HeVVhNXIvYVArc0xTdkY4L09UbVp1TGc0Mlp1YXREQVNFeFBwMWF1WFRKUTdhditvRlZZMDBFTnI3UFQwOU9ZRG1iUUloQkJOSHNVeVpNZ1FtY3YxQWlMaGtyRFNrRmdrZisrOW1wK2FKbjZLeStWaTFhcFZYSGZkZGZUcDB3Y2hSSVBoSk90YUFmclYvMkF1RXBza2pEeVR4c1F6cXFxcXhEdnZ2Q1BpNHVJdTgwWno2TkNoUnNPSGhvYktMS1Y1RlM2MVdEZHFsZVJ0dDkyR3pXYWV1OWpTcUtpbzRNMDMzeVEyTnBZbm4zeVMvUHg4QU5MUzB0aTRjU01KQ1FrTnhnc0lDQ0ExTlZYbVZuM2drckQ2YUkxMTY2MjN5dHpFeEdBdVhMakFnZ1VMNk5TcEUrUEhqNmVvcUFpQVFZTUc4ZjMzMzdOeDQwYlMwdEthdkVaejMxOUIzOW8vcmtWaTFlRG5uMy91NDhiYnhCM09uVHNuWG5ubEZSRWVIbDducjhGaXNZaTc3NzViN05peFErcGFuMzc2cWV6SzB2WTJJRWxHampmZXFQbXBhUWdmZnZnaG1abVpqWFpHL1lXa3BDUVdMVnFFMVNyclBxTnBUcDgremVMRmk1azNieDRWRlJVSUliQmFyZnp4ajM5azFxeFpKQ1ZKVlRjQWZmdjJiVDdRNVhRRGRabU1KaVcyYTlmT0s3OHVQZW5idDY4NysrUU1zZjM3OSt1VzcvejhmUEhNTTgvVW5YMm9LSW9JQ0FnUW8wYU5Fa2VQSHZYNCtwS0hGWXl3b1BvUjFVUmlZcUxXb0liaGREcU5Ub0ptcXF1clBiN0drU05IR0RkdUhGMjdkbVhKa2lWVVYxZGp0OXNaTjI0YytmbjVaR1ptMHFsVEo0L3ZJMW4zQ1RaQTh3Nkl4dDRjVEh4UGJtNHVzMmZQNXVPUFAwWUlnYUlvaElhR01uSGlSSjU3N2puZDkzWW1KaWFTazVPak5YaWNEWFhVWFJOZHVuUnhKMDBtT3JKcjF5NW16SmpCbWpWcmNMbGNLSXBDUkVRRUV5Wk00UG5ubi9mYTNnUEp1bysyQVRGYVE4ZkVhQTVxb2pPYk4yOW01c3laYk5pd0FaZkxoY1ZpSVNZbWhxbFRwekptekJpQ2dvSzhldi9vYU0zdEQwQzBoWnE1SFMxRVJVVkpKOGpYK1B0YmF5M1IwZEdhK2o3cjFxMGpKU1dGL3YzNzg2OS8vUXVYeThXMTExN0xtMisrU1dGaElSTW1UUEM2cUdyVEswR1VEWW1seUMxaEdmTGJiNy9OckZtei9MNFQzNzU5KzBZM29iaGNMcjc0NGd0ZWVPRUZmdnJwSjV4T0oxYXJsWVNFQktaUG44NWpqejJtK3pCRmMwaldmWmdOOVdSNVRmamlsK0VwRm91bHhTN3BjVGdjZlBEQkI4eVlNWVA4L1B5Nk1hams1R1JtenB4SmVubzZpbUxNNlcrU2RXK1hFcGJkcmptb1lSUVZGZkhkZDkvNWZZdlZ0MjlmdW5YckJrQlZWUlVyVjY1azJyUnBuRGh4QXFmVGlhSW9wS1NrTUdQR0RObWxLMTVCc3U3dG9KNFByR25nS3pzNzIrT0JObStUbkp4cytNQ25GZ3NMQ3hPblRwMFM4K2ZQRjVHUmtjSnF0UXBGVVlUVmFoV0RCZzN5dTdMZXNtV0xUUDZjdGhwaE5lY25DMmgrUU8vOCtmT0d0eFNGaFlXRzNsOHJaV1ZsSkNRa2NPSENCWVFRV0N3V0JnOGV6Snc1YzBoT1RqWTZlYi9CNFhESUJLKzJvZTZxME9RY3ZyS3lzdEh2dG0vZnpzMDMzeXh6ODZ1ZXNySXlRTzIvaElXRnNXdlhMa01XVVZxdFZsYXNXTUh0dDkvZWFKaW02cjZoNExYQzB2Um0yTlRGTDE2OGlNVmlNYndmVmp2eDJsSlFGSVhLeWtyWml0TTlEYlhyc3hyREhXR1ZvM0VzNjh5Wk00MStsNXFheXVyVnE2bXFxcEpKZ082TUdUT215WFQ2RTRxaTFEMEd1M2Z2VGxwYW1pRnVOcTFXSzNmY2NVZVRZU1RMOUFLbzU2Um82cFF0V0xEQTRDNWs4eVFrSkJqZU1kZGlpcUtJRjE5OFVZU0ZoUW1ielZiWGNiLy8vdnQxWGZXZ0YvUG16WlBKM3pZYjZnbXBtamg5V25OUXc4ak16T1RMTDc4ME9obDFWRlJVa0plWHgzWFhYVWRBd0tXdWJPL2V2UmsyYkJnWkdSa3NYNzZjV2JObWNmNzhlVDc3N0RQV3JGbkRnQUVEZVBYVlYvMm1JeS9wakswWUpBNjBIRDU4dU5FL25GWkxSVVdGV0xwMHFZaU9qdjdOME1NUFAveGdkUEprL2NGbldRRE5EcjRQSHo0c28xb1RDZXgyTzZOSGorYllzV084OWRaYmRPellFVkRuQ2xOVFUwbExTeU03Tzl1dzlCMDZkRWdtK05GYXQ1Qi8weEs2UTRjT25EaHh3cDEwK1l5dnYvNmErZlBuNjdLSXpwdkV4OGV6ZVBIaVJ0K2lhNmQzL3ZLWHYxQllXRmczWDlpblR4OW16cHpwODlINDl1M2JjK3JVS2EzQm53YTRDNGxPNStuVHA0MXVsWnZrcnJ2dU1yeGpydFUyYmRyVWJINmNUcWY0NktPUFJIeDh2TERaYkFJUVZxdFZKQ2NuKyt6RTJxS2lJdG04M1drQkRtcVZJYWdMemZ3WmYyK3A2cU1sclJhTGhZY2ZmcGlEQncreWV2VnFycjllUFRJd0p5ZUhCeDU0Z0I0OWVyQnExU3F2anQzdDNyMWJOc3BCQy9BTHFxcy9UZmk3c0ZvckZvdUZJVU9Ha0p1Ynk1ZGZma252M3IwQk9IRGdBRU9IRGlVcEtZbXNyQ3l2VEtudDNMbFRKdmdaNEpnRnRlblNMTWt0VzdaSUpzdEVid1lOR3NUdTNidlpzR0ZEM1FiaWd3Y1BNbXJVS0xwMTYwWldWcGF1TGZkMzMzMG5FM3dYcXFZQVdJVEc1MmRVVkpSZkg4Vjc1NTEzR3Q1MzBtcmZmUE9OTG5uZXRHbVRHREJnd0dYREZPM2J0eGNMRml3UUZSVVZIbDNiNlhTS3lNaEltWHhkZHZERTR6SUZrcHVicTB1QmVJUHg0OGNiTGhndEZob2FxdnZaUXprNU9XTElrQ0dYQ1N3Nk9sck1uei9mN1NPVWQrM2FKWnUzWVhESmRWRWNhbDlMRTNQbnppVWpJME5yY0ovaWNya29LQ2pBNVhJWm5aUW1hZHUycmRmbUJmZnMyY1BMTDcvTTZ0V3I2elplaElXRk1XWEtGTWFQSDA5SWlHYVBvTXlaTTRkcDA2YkozRDRXT0ZyL2czdzBxckovLy82Ni90Sk12RU51YnE1NDVKRkhMbXZCd3NQRHhZc3Z2aWpPbmoycjZScTMzSEtMVEd2VjRBaERsdFlMMkd3MnZ4L1BNcm5Fb1VPSHhCTlBQRkUzMlcyeFdFUndjTERJeU1nUXBhV2xqY1k3ZWZLa3NGcXRNc0phM3BDd0hwVzRnRml5WklrUGk4WkVEdzRmUGl5ZWVPSUpFUkFRSUN3V2k3QllMQ0lvS0VpODhNSUxvckt5OGpmaEZ5NWNLTnUvZXFBaFlWMERWR205U0w5Ky9Rd29HaE05S0Nnb0VHUEhqaFdCZ1lIQ1lyRUlSVkZFUVVIQmI4TDkvdmUvbHhGVkJSQmVLNllyOXhLdFI2UDNaRVZSeU12TG8ydlhybHFDbS9naEowK2VaTzdjdVp3NmRZcjMzMy8vc3UvMjc5OVB6NTQ5WlM3M05YQjNZMStPUTZMcGUvNzU1dzM0dlpuNEFqZUdiWjZ1TDZRclc2eDJ3QWtnVUl0RTI3UnBRMkZob2RUcnE0bi9jL0hpUlRwMjdDaXpITGtLK0IxUWQ4amhsZHUrU2xHYk5FMmNQWHVXckt3c3JjRk5XZ2labVpteWE5eS9vSjZvb0dIZjdnOEJxN1JlTVQ0K25yeThQTk9UY2l2QjRYRFFyVnUzWm5mdFhNRUR3UC9XLzZDaGphcWZBc2UxWHZISWtTT3NYTGxTSmhFbWZzejc3Nzh2SzZwandCcXRnV2NpMFhHTGo0LzNlTExUeEhncUt5dmQyZVUwdlNFQk5iYTFmaGxxaDB3VFI0NGNZZG15WlZxRG0vZ3BiN3p4aHV5K2hrb2dzNkV2bXZLSmt3bU0wbnFINk9ob0RodzRZTWlHU3hQUEtTa3BvWHYzN3JMYnZKWUJveHY2b2ludlhRZFF4N1UwT1dRcUx5K25yS3pNUE1DcGhUSng0a1EyYjk0c0U4V0p1a1NtdExtQURmRVJFczlicTlVcXRtL2ZiblJYd1VTUzdPenN5dzVzMG1oL2IwbzR6YlZHM1lGY1FQTllRdS9ldmRtMmJSdUJnWnJHV0UwTXByS3lrcHR1dW9uYzNGeVphQTdnZXVEbnhnSTA1OGl5Qk9nTXBHaTlZMUZSRVlxaWNPZWRtZzlzTlRHUTZkT244OGtubjhoRyt4dndmck9obXVGYVZPOGhtcHRKbTgwbXZ2LytlNk5iZUpObTJMaHhvK3g2S3dIOENuUm9UalJhUFBrZEIxN1JMRVBVL1hLUFB2cW83QnVHaVE4cExTMWwrUERoN213WG13MmMxQ3NkZHRTM1JDbDFwNmVuQzZmVGFmUVAwK1FLbkU2bnVPZWVlMlJiS2dIc1E2UDNSNjNPd3AxQUhqQmNZM2dBOHZMeXFLNnVadURBZ1RMUlRMek1sQ2xUZVBmZGQyV2pDZFJWeGw3eERQTVdraXBYRkVXc1dMSEM2QitwU1ExWldWbnV0RlFDV09vTlFkVnlEUks3ZVdvdE1EQlFmUDMxMTBhWDZWWFArdlhyaGQxdWQwZFVSNmkzN05oYkRBWmNzb21MaUlnUU9UazVScGZ0VmN2MjdkdEZlSGk0TzZKeUFnTzhMYXBhWG5NamdTSW1Kc2F2ZDFHM1Z2YnMyU09pbzZQZGZRVE84WkdtQUhVa2ZyTTdDWTJPamhaNzl1d3h1cXl2R3ZidjN5ODZkT2pncnFnMklqSHJvaGVkZ1ZQdUpEZ21Kc2FjVS9RQjI3WnQ4NlNsT2dsMDlJbVNHdUEyMVAxazBna1BDd3NUYTlldU5icnNXeTNyMXEwVEVSRVI3b3FxQ3VqdkV3VTF3Vk80bDNnUkdCZ28zbnJyTGFQcm9OV3hiTmt5RVJBUTRLNm9CRERTRjhMUmdsdWQrVnFiTkdtU3FLNnVOcm8rV2p3T2gwTk1tRERCRTBFSmZOeFpidzRGZUFjUE1qUnc0RUJ4OHVSSm8rdW14WEw4K0hFOW5NNHRSK1BDVGw5aUF6N0hnNHgxNk5CQnJGdTN6dWc2YW5GODlkVlhJaVlteGxOUjVhQjlpcy9uQkFLZjRVRUdGVVVSbzBlUEZtVmxaVWJYbDk5VFhsNHVKaytlN003cXo0Yk1BZmoxdW5JNzhIOTRtTkh1M2J1THpaczNHMTEzZnN1bVRadEVVbEtTSG9LcWIrWEFyZDRVaDZmWWdVL3dNS09Lb29nbm4zelNkUEpXajFPblRvbVJJMGNLUlZIMEZsV3RGUU05dkNjTno3RUMvNE1PbVkyTWpCUUxGaXhvMERuWTFVSkZSWVdZTjIrZWFOdTJyYmNFVmQ4T296cjU4RnNVWUJadVRGbzNaSW1KaVdMRmloVlgxZUxCNnVwcThkNTc3NG40K0hoZkNLcSs3UVFpOUplRXZqeUs1THI1cGl3aElVRXNYYnBVT0J3T28rdmRhOVNlb2RPalJ3OWZDNnErclVPalN5c2p1UmtvUk1lTXg4WEZpZGRlZTAyVWxKUVlyUVBkS0M0dUZxKzg4b3JvM0xtemtZS3FieCtnYlcrRW9jU2crdC9TTmZNaElTSGl6My8rczlpd1lZTmZuNXJSR0U2blU2eGZ2MTZNR0RGQ0JBY0hHeTJraHV5LzlSS0FON0VBMDFESFRYUXZoUGo0ZURGbHloU3hiZHMydnhhWnkrVVNXN2R1RlpNblR4WnhjWEZHQzBlTC9ZZm5WZThiYnNHTm5UOHlGaGNYSjhhT0hTdis4WTkvaURObnpoaXRKVkZhV2lvKy92aGpNV2JNR0g5NjFHazFGK3JST0pvd2VsNG9CSFhTODFtOC9CeTNXcTMwN3QyYlcyNjVoZFRVVkZKU1V1aldyZHRsQjREcmljUGhJQzh2angwN2RwQ2RuYzJXTFZ2WXUzZXZWNDU5OHlFT0lCME43a1NORmxZdHR3SnZBbjE4ZWRQQXdFQ1NrcExvMGFNSGNYRnh4TWJHMHFWTEY5cTFhMWRuZHJ1ZDRPQmdnb0tDQU5YeGEwVkZCWldWbFpTV2xsSmFXa3BKU1FuNStmbDE5dE5QUDVHWGw0ZkQ0ZkJsZG56RnI2Z3UyM2NZblJDdDJJQ0p3RG1NYi9aTmE5cE9Bb2tOVjZQL0VnbThpcHNyVTY4eTAyWGcyVTA3QUlRMVVvZCtUVGZVTVJRbnhsZWd2MWsxcW4rcUc0RzlCcWJqcFVacnJ3V1FnTG9MMXl2REV5M01uS2pPOE9wUEVuY0NDZ3hLejZFR2E2eUZrWUI2TE94WmpLOWdYOXNaNEs5QWZDTmwweFBWbDVtdjArWENqeGNIeWhJR1BNT2xRNjFicyswRXhxS3RMOU1QZFQyVkw5UDNxNFowdFVqNkFndUFJb3dYZ1Y1MkVyVmxkbWZvNWQ5USsxKytTdXRscDFHMFJpeW92OWlGcU9jUkd5ME9XU3RBN1VjT3dmT2R4Mk44bEdZSGNKT0hhVzFSS0VBdllCS3dGaWpEZU9GY2FXV295N2VmQTI3d1FobTg1T1gwTzRBUlhraDNpOEtHNnB6M0dlQTlWQy9RbWsrUzFjR3FhdTc1WGswYWt2R05QNFJsWHNwUE1kQ3NKejEvbWRMeE5RR29yc1o3b3I1cHhRR3hOZGF1eG9JMVh1c2lxaFA5VXRSSFduN052MGRRWFN2bW9mN0NmWTBWZFdqaVFSMnZ1UmUxSDllc1Y3K3JWVmhhQ0VGOUc2dDlJd3V0K2ZkQ3piOWxOVmJ1NDNUSkVBejhFOVhIaHFlc0FSNER6dXR3TFpOV1FDU3dIL2NmZlU3Z0w1aU5rRWtEdURzNi95dnFJWmNtSm8xeUEyby9VS3VvZmtZOTFzVEVwRmx1UjMzWmFFNVVYd0htK1lBbVV0eEY0L090TG1BdXJXait6OFMzeEFLTFVWY25WQU1uZ0kvUjUrMFJnUDhIKzRzbnZpVkp1clVBQUFBQVNVVk9SSzVDWUlJPSc7XG5leHBvcnQgY29uc3QgRkVFRF9QSVBFID0gJ2RhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBWG9BQUFGNkNBWUFBQUFYb0pPUUFBQUFCSE5DU1ZRSUNBZ0lmQWhraUFBQUFBbHdTRmx6QUFBT3hBQUFEc1FCbFNzT0d3QUFBQmwwUlZoMFUyOW1kSGRoY21VQWQzZDNMbWx1YTNOallYQmxMbTl5WjV2dVBCb0FBQ0FBU1VSQlZIaWM3ZDE1ZkZYVnZmZnh6OGxJbUVuQ0hDQmhSb1F3aUVxUXRqS0tRcTBWVVI4RUZISHFWYnhhZXgyZTluSmZyVzN2Yzl2YllxMUNCTnVLMUZZUVJCbVZ5UkltaFlJSllBRUZ3aVJqbUFLWmsvMzhzUk1NR0NESldYdnZNM3pmcjlkK2hTSG50elo2OWpmcnJMMzJXajVFQWw4VWtGRHBTQ3ovMnZTeVAyOEUxQ3QvVFgwZ3V2elhUY3EveGxUNit3dEFVZm12VDVkL0xRYk9WL3I3czBCTytYRVNPRkhwOTVXUEVpUC9TaEdIK0x3K0FaRnlUWUQyVnpqYVlvZDlvRG9ON0wzQ3NSOG85ZTdVUkJUMDRxNG9vQlBRQTBndC8zb2RkcEJIWCtWMXdhd0lPQWg4QVd3RE1zdS9mb2srQ1loTEZQVGlsSGlnRDlBVE85QjdZb2Q2SFM5UEtvQVVZSWQvRm5id1p3RmJnRk5lbnBTRUpnVzltTklLR0FEY1V2NjFOeERoNlJrRnA3M0FPbUJ0K2RjdkFNdlRNNUtncDZDWDJvZ0IrZ0pwMk1HZUJqVHo5SXhDMXpGZ1BYYndid0EyWTk4MEZxazJCYjFVVndvd0ZCZ0NETU9lNFNMdXk4TU8va1hBQjBDMnAyY2pRVUZCTDFkU0I3dTNQcVQ4Nk92dDZjZ1Y3QVZXWUFmL2N1eXhmNUZMS09pbHNtYkEzY0FvNEh0QW5LZG5JeldWQjN3Q2ZBak14NTczTHlKQ0l2QW9kcSt3QlB2R240N2dQMHFBajRGSjJBK1RpVWlZYVF5TUJ4Wml6L1AyT3BSME9CLzZhNEduc1o4bUZwRVFGUXZjaXoyV1c0ajM0YVBEbTZNUSt3ZjhQZGl6cDBRa0JIUUcvaHQ3bXA3WElhTWpzSTVUUURyMkEyMGlFbVJpc1h0c3k0RXl2QThVSFlGL2JNYStWMU1YRVFsb1BZQlhzUmZaOGpvNGRBVG5jUXA0QmJnZUVRa290MkNQdTZyM3JzUGtzUlo3cXEybVlZdDRKQVo3NWt3VzNnZUNqdEErTXJHSGRiUWduWWhMR21KUGt6dUk5d0dnSTd5T284Qi9ZYTlNS2tGRUg4bUNSeHZnT1dBaTl1NUpZYTFodzRZa0ppWmVQQklTRWtoSVNLQlJvMGJFeGNWZC9KN0l5RWdpSWlKbzFNaGVtcWRPblRwWWxrVmhZU0VBWjgrZXBheXNqSktTRW5KemN3SEl6OC9uekprejVPVGtYRHhPbmp6SnlaTW5PWGZ1bkRmLzRNQ1NDN3dKL0JZNDdQRzVTRFVvNkFOZlMrQkY3SS9Pc1I2Zml5dmk0K05KVGs2KzVFaEpTU0U1T2ZsaXFFZEhlN05QU1hGeDhjWGd6ODdPWnQrK2ZaZDh6YzdPNXZUcDA5Y3VGQm9Lc0tkbi9ocDcrcTRFS0FWOTRHb0tQQS84aUJCZGN5WWxKWVVlUFhyUW8wY1BVbE5UNmR5NU04bkp5UmQ3MzhIcTdObXo3TnUzajkyN2Q1T1ptY20yYmR2WXRtMGIyZG5aWHArYVUvS0ExNEQvd2Q1YlZ3S01najd3eEdNUDBUeEZpQXpSeE1iRzBxZFBIMUpUVTBsTlRiMFk3ZzBiTnZUNjFGeDE5dXpaaTZHZm1abEpabVltVzdac29haW82Tm92RGc2NTJGTXpmOGMzRzY1TEFGRFFCNDZHd0RQbFIxQjNhUk1URTBsTFMyUEFnQUdrcGFWeHd3MDNVS2VPSm14VXBhQ2dnRTJiTnJGKy9YcldyVnZIK3ZYcnljbko4ZnEwL0hVRytIMzVrZXZ4dVFnSytrQVFBVHdFL0JKbzd2RzUxRXFiTm0wWU1tUUlBd2NPcEgvLy9uVHQydFhyVXdwYWxtV3hjK2RPTm16WVFFWkdCaXRXck9EUW9VTmVuMVp0SFFIK0wvQVc5ak1lNGhFRnZiZHVBcVlDTjN0OUlqVVJGUlhGVFRmZHhLaFJveGd5WkFoOSt2VEI1OU5ieVNsNzkrNWw0Y0tGTEZxMGlJeU1qSXN6aG9MSUZ1RGZnUXl2VHlSYzZlcjBSakwyamF0N1BENlBhbXZYcmgwalJvemd0dHR1WS9EZ3dkU3ZIeEszRDRKT2JtNHVLMWV1Wk9uU3BTeGJ0b3dEQnc1NGZVclZaUUh2WWs4d0NKcVRGcW1OdXRnUG5PVGgvY012MXp6YXRtMXJUWjQ4MmNySXlMREt5c29zQ1R6YnQyKzNwa3laWW5YczJOSHo5MHMxanp6czFWUWJWUCt5RVFrZVk3QWZMdkg2UXJ0bXVQLzR4eisyUHYzMFU0VjdFQ2tySzdNMmJOaGdQZlBNTTFaU1VwTG43Nk5xSEFlQkg5YndHaElKV0VuQUIzaC9ZVjN4U0V4TXRKNSsrbWxyL2ZyMUN2Y1FVRnBhYXExZHU5WjY2cW1ucklTRUJNL2ZYOWM0NWdPdGFueFZpUVFJSC9haVl6bDRmekZWZWZUdDI5ZEtUMCszOHZMeXZNNG1jVWhCUVlFMVo4NGNhOGlRSVpiUDUvUDhQWGVGNHd6MitrMFJOYi9NUkx6VEVWaUo5eGZRdDQ0V0xWcFl6ei8vdlBYVlYxOTVuVUhpc2krLy9OS2FNbVdLMWFaTkc4L2ZoMWM0TWdETnpaV0FGdzM4Rk1qSCs0dm00dUh6K2F6aHc0ZGI4K2ZQdDRxS2lyek9HL0ZZVVZHUjlkNTc3MW5EaGcwTHhGNStQdmJhVHQ0c1ppUnlEVDJ3MSszMitrSzVlTVRHeGxvUFBmU1F0VzNiTnErelJRSlVWbGFXOWVDREQxb3hNVEdldjE4dk83WUMzV3Q5TllvWTVzTmVXZklDM2w4Y0ZtQTFiTmpRbWp4NXNuWHc0RUd2YzBTQ3hOR2pSNjBwVTZaWThmSHhucjkvS3gzNTJQUHVOWFl2bm1vR0xNTDdDOElDckpTVUZHdnExS25XK2ZQbnZjNE5DVks1dWJsV2VucTYxYVZMRjgvZno1V09qOUhNSFBISTk0SGplSDhSV0owNmRiSm16NTV0bFpTVWVKMFRFaUpLU2txc1diTm1CZEtEV01lQU8veTZZa1ZxSUE1N0tWYlBOK0p1MjdhdGxaNmViaFVYRjN1ZEN4S2lTa3RMclRsejVsZ2RPblR3T3VncmpsbEFQYit1WUpGcjZBbjhDNC9mN0VsSlNkYjA2ZE90d3NKQ3IzTkF3a1JoWWFIMTJtdXZXYTFidC9ZNjZDMWdCM0M5bjlleVNKWEc0dkVOMXhZdFdsaXZ2UEtLVlZCUTRQVjFMMkVxUHovZit2M3ZmMjgxYjk3YzY3QS9EOXpuOTFVdFVpNEtleEVtejk3VU1URXgxdVRKazYyelo4OTZmWjJMV0pabFdlZlBuN2VtVEpsaTFhbFR4K3ZBVDBkejdzVlBUZkg0Q2RlUkkwZGFlL2JzOGZxNkZxblNnUU1IckhIanhua2Q5aGxBUzcrdmRnbExBNEN2OGVqTjI2MWJOMnZac21WZVg4Y2kxYkpxMVNvck5UWFZ5N0EvREtRWnVPNGxqRHdLRk9MQkd6WWhJY0dhT25XcXBrcEswQ2t0TGJYZWV1c3RMOGZ2aTdFZnNCSzVxbWpnVFR4NGsvcDhQbXZpeEluV3FWT252TDVlUmZ5U2s1TmpQZmpnZzE2dW8vTUc5cjAxS2FldEJML1JBSHVyc3hGdU45eStmWHVtVDUvTzBLRkQzVzVheERGcjFxemhrVWNlWWZmdTNWNDB2d0lZRFp6MW92RkFFK24xQ1FTSTFzQnlZS0NialVaRlJmSGtrMDh5ZCs1Y3VuWHI1bWJUSW81cjE2NGRreVpOb3FTa2hJMGJOMkpabHB2TnR3ZEdBb3RSMkt0SGovMFExR0xzbmFEY2E3Um5UMmJPbkVtL2Z2M2NiRmJFRTVtWm1VeWFOSW5ObXplNzNmUVJZQlR3VDdjYkRpVGgzcU1mQ1N3QkV0MXFNRG82bWwvODRoZk1taldMTm0zYXVOV3NpS2RhdEdqQlF3ODlSR3hzTEJrWkdaU1ZsYm5WZEFQZ2Z1Qno0Q3UzR2cwMDRkeWpud1JNdzhXYk5pa3BLY3llUFp1ME5NMENrL0MxZWZObXhvNGQ2L2JZZlNuMmRvV3Z1ZGxvb0FqWEh2MHZnTi9pNGpyWGp6enlDQjk4OEFFZE9uUndxMG1SZ05TcVZTc2VldWdoamg4L3p0YXRXOTFxTmdLNEhidHorNGxialFhS2NPdlIrN0FEL2xtM0dtemN1REhUcGszanZ2dTBMSWZJNWQ1Ly8zMGVlZVFSY25KeTNHejJOZUFwN0ttWVlTR2NndDRIL0FGNDBxMEdCdzhlekZ0dnZVWHIxcTNkYWxJazZCdzdkb3lISG5xSXBVdVh1dG5zRzhBVDJNdU5oN3h3R2JxSndsN0hlcElialVWR1J2S3JYLzJLOVBSMEdqWnM2RWFUSWtHcmZ2MzYzSC8vL1VSSFI3Tm16UnEzcG1IMnhaNkMrU0ZoMExNUGh4NTlEUEFPY0xjYmpTVWtKUERPTys4d2JOZ3dONW9UQ1NtclY2L212dnZ1NC9qeDQyNDF1UkM0QjN2Sms1QVY2a0VmQzh6QjN2YlBjYjE3OTJiZXZIbWtwS1M0MFp4SVNEcDQ4Q0NqUjQvbXM4OCtjNnZKcGRnZHdYeTNHblJiS08rdUhvZjlQOUNWa0o4NGNTTHIxNjlYeUl2NHFVMmJObnp5eVNkTW1EREJyU1pIWVBmczQ5eHEwRzJoR3ZReHdGemdWcWNiaW8yTlplclVxYno1NXB2VXFWUEg2ZVpFd2tKY1hCeC8rY3RmU0U5UEp5WW14bzBtQndNTHNFY0JRazRvRHQxRVlTOU85a09uRzJyV3JCa2ZmUEFCTjk5OHM5Tk5pWVN0OWV2WDg0TWYvSUFUSjA2NDBkeDcyRnNVbHJyUm1GdENMZWdqc0dmWGpIVzZvWTRkTzdKa3lSSTZkZXJrZEZNaVlXL3YzcjNjY2NjZDdOeTUwNDNtM2dZZUpJU21Yb2JTMEkwUCswRUl4ME0rTFMyTkRSczJLT1JGWE5LK2ZYdldyMS9QZDcvN1hUZWFHd2ZNSUlRNndxRTBqLzUvc05leWNOUTk5OXpEZ2dVTE5EOWV4R1Z4Y1hIY2YvLzlaR2RuazVXVjVYUnp2WUhHd0RLbkczSkRxQVQ5TDRBWG5XN2twei85S2ErLy9qclIwZHAwWHNRTFVWRlIzSFhYWFJRWEY1T1JrZUYwY3hVMzMvN2hkRU5PQzRXZy94SHcvNXhzSUNvcWlwa3paL0xzczgvaTg0WE1wem1Sb09UeitSZzhlREJKU1Vrc1diTEU2U2RwdjRlOXBuMVFyMmNmN0trMUF2c1Jac2VXR282SmllR3ZmLzBybzBlUGRxb0pFYW1sRHovOGtERmp4bEJZNk9pRHJhWEFYZGh6N1lOU01BZDlIK3lQVlBXZGFpQTJOcFozMzMyWE8rKzgwNmttUk1SUFM1Y3U1ZTY3N3lZLzM5RUhXM09CNzJCdllCSjBnalhvV3dNYmNYRDd2M3IxNnJGZ3dRS0dEQm5pVkJNaVlzaWFOV3NZT1hJa3VibTVUamJ6TmZhNC9VRW5HM0ZDTUFaOVF5QURlNjlYUnpSdTNKZ2xTNWJRdjM5L3A1b1FFY00yYmRyRWlCRWpuRjdiZmdjd2dDRGJjRHpZNXRGSFl6KzU1bGpJeDhmSDgvSEhIeXZrUllKTXYzNzlXTDU4T1UyYk5uV3ltZTdZVDk2N3RnV3BDY0VXOU5PQm9VNFZiOXEwS1d2V3JLRmZ2MzVPTlNFaUR1cmR1emVyVjY5Mk91eUhBNjg3MllCcHdSVDBUd0VUblNyZXFGRWpsaTVkU3ZmdTNaMXFRa1JjMEwxN2Q1WXZYMDU4Zkx5VHpUeUN2VU5WVUFpV01mcisyQnY2T3JLTVhkMjZkVm0yYkJrREJ3NTBvcnlJZUdEanhvME1HemJNeVJ1MHhjQWdZSzFURFpnU0RFSGZIUHRoQlVjMlhvMkxpMlB4NHNYY2VxdmpLeHFMaU10V3JWckZIWGZjUVVGQmdWTk5ITVhlbHZCcnB4b3dJZENIYnFLeGQ0aHlKT1NqbzZPWk8zZXVRbDRrUkEwYU5JZ1BQdmlBMkZqSGxwbHZnYjMzUlVDdml4TG9TeUJNQmNZNFVUZ3lNcExaczJkejExMTNPVkZlUkFKRWh3NGR1TzY2NjVnL2Z6NWxaWTZzUE53R3FBZDg3RVJ4RXdJNTZNZmk0Qm8yYjc3NUpnODg4SUJUNVVVa2dIVHIxbzJXTFZ1eWNLRmpxeGowQjNaaXo3TVBPSUVhOUQyQkQzRG80OURQZnZZem5uMzJXU2RLaTBpQTZ0dTNMMFZGUmF4ZDY5aTkwOXV3MTk1eVpTdXNtZ2pFbTdGMWdFM0E5VTRVdi9mZWUvbmIzLzZtVlNoRndwQmxXWXdmUDU3WnMyYzcxY1FYd0EyQW93dnYxRlFnOXVoZkJXNTNvdkRBZ1FPWlAzOCtVVkZCOVZDYmlCamk4L2tZT1hJazY5YXRJenM3MjRrbW1tSXYwN0xVaWVLMUZXamQyaEhBWWh3NHI2NWR1N0p1M1Rxbkg2SVFrU0J3NnRRcDB0TFMyTFZybHhQbExlRDd3Q0luaXRkR0lBVjlNeUFMZTk2OFVZbUppV3pZc0lHT0hUdWFMaTBpUVdyZnZuM2NmUFBOSEQ5KzNJbnlKN0R2TlI1MW9uaE5CY284ZWgvd0ZnNkVmR3hzTEFzWExsVElpOGdsVWxKU21EOS9QakV4amp4dzN4U1lTWUIwcGdObGpQNXA0RWtuQ2srYk5rMGJoNGhJbGRxMmJVdGlZaUtMRnk5Mm9ueG43Sjc5SmllSzEwUWdCSDNGc3AvR3AxS09HemVPbDE5KzJYUlpFUWtoL2ZyMTQrREJnMnpkdXRXSjhvT3dwMXc2TWo1VVhWNS9ySWpHL21tWGFycndEVGZjUUVaR0JuWHExREZkV2tSQ1RINStQZ01HREhBcTdMY0NOd0lsVGhTdkRxL0g2Si9IZ1pDUGo0OW56cHc1Q25rUnFaYTR1RGplZi85OUVoTVRuU2pmRzNqT2ljTFY1V1dQdmpPUWlmMkFsREVSRVJFc1diS0U0Y09IbXl3ckltRmd4WW9WM0hiYmJaU1dscG91WFFqMHdsNG13WFZlamRGSEFQT0JEcVlMLytwWHYrTEJCeDgwWFZaRXdrRDc5dTJKaUloZzllclZwa3RIWWQrUG5HVzZjSFY0MWFOL0FnZTI0aG82ZENnZmZmU1JsamNRa1Zvckt5dGoyTEJockZ5NTBvbnlrNEEzblNoOE5WNGtZaXZzRmQ0YW15eWFtSmhJWm1ZbXJWcTFNbGxXUk1MUTRjT0hTVTFOSlNjbngzVHBzOWc5KzhPbUMxK05GemRqWDhOd3lBTzgvdnJyQ25rUk1hSjE2OWJNbURIRGlkS05nTjg3VWZocTNCNmpId1A4ekhUUnh4NTdqT2VmZjk1MFdSRUpZOTI2ZFhOcWZuMTM3SWtvcnQyWWRYUG9wajZ3QzN2b3hwaU9IVHV5ZGV0VzZ0ZXZiN0tzaUFnWExseWdUNTgrN042OTIzVHBRMEJYNElMcHdsVnhjK2ptUlF5SGZIUjBOSC85NjE4VjhpTGlpSHIxNnZIT08rOFFIVzM4d2YwazRNZW1pMTZKVzBNM3ljQnNEQzl6OFBMTEwzUGZmZmVaTENraWNvbUtlMzhPVExtOEVYdTY1VG5UaFMvbjF0RE5YR0MweVlLcHFhbHMyclRKaVorMElpS1hLQ2twNGNZYmIzUml2UDZ2Z09PYlY3c1I5QU9BREpOdFJVVkZzWEhqUnZyMjdXdXFwSWpJVlczYXRJbisvZnViZm1yV0FyNERPTGFSTFRnL2RCTUJ6QU5hbXl6NjNIUFBNWDc4ZUpNbFJVU3VxblhyMXB3NWM0YU5HemVhTE92RFhocGhKbmJvTzhMcEh2MGt3T2hrMUpTVUZMWnQyMGE5ZXZWTWxoVVJ1YWE4dkR4NjlPakIzcjE3VFpkK0VIdnpKVWM0T2V1bUlXQjBNWGlmejhmTW1UTVY4aUxpaWJwMTZ6SnQyalFuU3Y4S2V3cTZJNXdNK21jeHZEWGd3dzgvektCQmcweVdGQkdwa1dIRGhqRnUzRGpUWlZ0aDc3VG5DS2VHYnVLQnZkaVAreHJSckZremR1N2NTWk1tVFV5VkZCR3BsWk1uVDlLMWExZlRhK0djQnRvRFowd1dCZWR1eHY0TUdHS3k0TlNwVXhrd1lJREpraUlpdFZLM2JsM3ExYXZIa2lWTFRKYU5BNHFBVDB3V0JXZDY5SW5ZdmZrR3BncjI2dFdMelpzM0V4a1pDRnZjaW9oQWFXa3B2WHYzWnR1MmJTYkxuc2Z1MVo4d1dkU0pNZm9YTVJqeVlQZm1GZklpRWtnaUl5T1pPbldxNmJMMXNlOXZHbVc2Ujk4UytBcW9hNnJnNk5Ham1UdDNycWx5SWlKRzNYbm5uWHo0NFljbVMxN0EzbjN2bUttQ3BvUCtWZUJKVThWaVkyUFp2bjA3SFR0Mk5GVlNSTVNvUFh2MjBMMTdkd29MQzAyVy9SMEdGejB6T1hUVENuallZRDErL09NZksrUkZKS0IxNk5DQnlaTW5teTc3SXd5dUtHQ3lSLzhLWU94ZjI2SkZDM2J2M2syREJrYUgrMFZFakR0MzdoeWRPblhpK1BIakpzc2E2OVdiNnRFM0FTWWFxZ1hBaXkrK3FKQVhrYURRc0dGREozYTVld1JEMjY2YTZ0Ry9CUHpTVUMxYXRXckZWMTk5UlZ4Y25LbVNJaUtPS2lnb29HUEhqaHcrYkhUZjcvOEFmdU52RVJNOStsZ00zb0FGK00vLy9FK0Z2SWdFbFRwMTZ2RENDeStZTHZzMEVPTnZFUk05K29uQW13YnFBTkN1WFR0Mjc5NU5USXpmL3pZUkVWY1ZGUlhScFVzWHNyT3pUWllkRDd6dFR3RVRQWHFqQy9GTW1USkZJUzhpUVNrbUpvWVhYM3pSZE5tZjRHZW4zTjhlL1FqQTJHSVBuVHAxNG9zdnZpQXFLc3BVU1JFUlZ4VVhGOU8xYTFmVGE5WVBBNWJYOXNYK3Jpc3dIWHRkQmlOZWZmVlZVbE5UVFpVVEVYRmRaR1FralJvMTRvTVBQakJadGhrd3U3WXY5cWRIM3dQSTh1UDFsK2pRb1FPN2R1M1NtallpRXZSS1Nrcm8yTEVqKy9mdk4xWFN3czdjSGJWNXNUOWo5SS81OGRwdmVlYVpaeFR5SWhJU29xS2llUHBwbzdjdmZkano2bXY5NHRxSUF3NWpQeWpsdC9qNGVQYnYzMC85K283dHBDVWk0cXJjM0Z6YXRtM0xtVFBHOWhFNWhiMHNRa0ZOWDFqYkh2MDlHQXA1Z0NlZWVFSWhMeUlocFVHREJqejJtTkdCajNqZ3J0cThzTFk5K2d6Z2xscSs5aEt4c2JIczI3ZVBsaTFibWlnbkloSXd2djc2YTFKU1VpZ3FLakpWY2pWUTQ0MnphOU9qN3dJWTI5TnY3Tml4Q25rUkNVbXRXclhpL3Z2dk4xbnllMENubXI2b05rSC9LQVpYdlRSOHcwSkVKS0E4OTl4eitIekdJdE5ITFphRHIyblF4d0xqYXRySWxRd2JOb3llUFh1YUtpY2lFbkN1di81Nmhnd1pZckxrQkNDNkppK29hZEQvQUdoYXc5ZGMwZU9QUDI2cWxJaEl3SHIwMFVkTmxtc0JqS3pKQzJyNmVXSXhjSHNOWDFPbDVzMmJjL0RnUWFLamEvU0RTVVFrNkJRWEY5TzJiVnVPSGoxcXF1UUNhakFEcHlZOStpYUFzYzhmRXlkT1ZNaUxTRmlJam81bTNEaGpvOTVncnpQV3FMcmZYSk9nL3lFRzFrVUc4UGw4VEp4b2RFTXFFWkdBTm1uU0pKTTNaV09CNzFmM20yc1M5R05xZmk1Vkd6Um9rRGI5RnBHdzBybHpad1lPSEdpeTVMM1YvY2JxQm4waXRaaWtmeVdQUEZMckpSdEVSSUtXNGV3Ymh2MjA3RFZWOTNQRVk5aExFdnN0SVNHQnc0Y1BFeHNiYTZLY2lFalFLQ2dvb0hYcjFwdzZkY3BVeVluQW42LzFUZFh0MGQvajM3bDg0NEVISGxESWkwaFlxbE9uRHZmZGQ1L0prdFVhdnFsTzBEY0Z2dXZmdVh6RDhEOVNSQ1NvM0h0dnRZZldxMk13OXFZa1YxV2RvWnNuZ05mOVBoMmdiZHUyWkdkbm03enpiTXdUVHp6Qm9VT0hYRzN6cHovOUtUZmRkSk9yYllwNDRkTlBQK1hsbDE5MnRjMmtwQ1NtVFp2bWFwdlZVVlpXUnBzMmJmajY2NjlObFh3VW1IRzFiNmpPNXF5anpKd0xqQmt6SmlCREhtRFZxbFhzM3IzYjFUWWZmcmpHUzFhSUJLVWpSNDZ3YU5FaVY5dnMzTG16cSsxVlYwUkVCS05IaitZUGYvaURxWklqdVViUVgydm9wZzRHaDIzR2pERTJRMU5FSkdnWnpzTEIyUFBxcitoYVFmODlvSzZKTTBsSlNlR0dHMjR3VVVwRUpLaWxwYVhScmwwN1UrWHFjWTM5UWE0VjlMZVpPcE5BSHJZUkVYR1R6K2ZqN3J2dk5sbnlxbGw5clRGNm8wRWZiSm8zYjI1c0t1alJvMGRON2pJakV2UmlZbUpvMGFLRmtWcUZoWVVjTzNiTVNDMjNqQmt6aHQvOTduZW15dDBHL09SS2YzbTFvRS9CM2szS2IrM2F0YU5Qbno0bVNybXFVYU5HTkdqUXdFaXRuSndjQmIxSUpkSFIwVFJ0YW1iVjg5emMzS0FMK2h0dnZKR2twQ1JUcy8ydUI5b0FCNnY2eTZzTjNZd3cwVHJBaUJIR1NvbUloQVNmejhmdzRjTk5scnppQ016Vmd0N1lzSTJDWGtUazJ3eG5ZNDJEUGdhNDFVVExNVEV4REJwa2JEMDBFWkdRTVdUSUVKUDdjZ3poQ2xzTVhpbm9id0RxbTJoNTRNQ0IxSzl2cEpTSVNFaHAxS2dSL2Z2M04xV3VJZENycXIrNFV0QVBNTlh5YmJjWkd3RVNFUWs1aGpPeXl1eDJQT2cxUGk4aWNtV0dNN0xLN0s1cWVxVVBNUEpaSWlrcGllN2R1NXNvRlpJT0hUckV2LzcxTDY5UFE4UnhiaThZR0V4U1UxTnAxYXFWcVVYT3F0ekNxcXFnNzBnMWxyMnNqbUhEaHBrb0U3S2VldW9wcjA5QlJEem04L2tZTW1RSXMyYk5NbEd1T2RBZTJGdjVENnNhdXJucW1nazFjY3N0eGtxSmlJUXN3MW41cmVHYnFvTGUyUGo4Z0FIR1NvbUloQ3pEV2VsZTBDY21KdEtwVXljVHBVUkVRbHEzYnQySWo2L1dQdC9WOGEyUEI1ZVAwY2RqYUgyYnRMUTByVlpaU1VSRUJKR1JrVjZmaGtqQWlJaW83cGJWb2Mvbjg5Ry9mMzhXTDE1c29sdzNvQWx3dXVJUExnLzZHNmplOW9MWHBQSDVTd1hxYmpjaUVoZ0dEQmhnS3VnamdEN0F5c3AvVUZrUEU2MkEzYU1YRVpIcU1UeE9mMG1XT3hMMHNiR3g5TzNiMTBRcEVaR3cwSzlmUDJKaVlreVZjejdvZS9mdVRaMDZkVXlVRWhFSkMzRnhjZlRxVmVWU05iWFJzL0p2S2dkOUZIQ2RpUlo2OSs1dG9veUlTRmd4R1BUZGdZdXpQeW9IZlJmQVNEZThSdzlqUS8waUltSERZSGJHQVIwcWZsTTU2SHQrKzN0cnAyZFBZNlZFUk1LRzRleThXS3h5MEJ2NVVlTHorZFNqRnhHcGhaNDllNXA4L3VoaUVCc1ArdVRrWkJvMmJHaWlsSWhJV0duY3VERkpTVW1teWxYWm8rOW1vcko2OHlJaXRXY3dReTltZWtYUVJ3SnRUVlJPVFUwMVVVWkVKQ3daSEtkdlIzbkdWd1I5YTY2d3FXeE5xVWN2SWxKN0JqTzBEdEFDdmduNkZGT1Z0YWFMaUVqdGRlbGlaRjNKQ3Nud1RkQW5HNnVhYkt5VWlFallNWnloS1dDNFJ4OGZIMCtqUm8xTWxCSVJDVXNKQ1FrbVp5NWVFdlR0VEZSVWIxNUV4SDhHc3pRWkRQZm9VMUtNRGZXTGlJUXRnMEYvU1kvZVNGWDE2RVZFL0dldzA1d01kdEJIWVUrdjlMK2lnbDVFeEc4R2c3NHRFQmtCSlBMdExRVnJSVU0zSWlMK005aHBqZ0xpSTdBM0JEZWliVnNqRDllS2lJUTF3Nk1qQ1JGQVUxUFZtalZyWnFxVWlFallhdHJVV0N3REpFWUFDU1lxK1h3KzR1T05mVGdRRVFsYmlZbUpKc3NsVkl6Uis2MVJvMFpFUnh0WkxrZEVKS3pGeE1UUW9FRURVK1hNOWVnVEVveVVFUkVSakdacWdyR2dOL3hSUTBRa3JCbk1WSE5ETityUmk0aVlZekJUelEzZHFFY3ZJbUtPNlI2OWtlVW1OZU5HUk1RY2d6MzZ4aEZBcklsS1dwNVlSTVFjZzVrYWF5em9ZMk9ObEJFUkVld3BscVpLUlFCR3FoazhLUkdSc0dldzg2d2V2WWhJSURJZDlPclJpNGdFR0EzZGlJaUVPQTNkaUlpRU9QWG9SVVJDbk1ib1JVUkNuT21nRnhHUkVCWUJGSmtvVkZSa3BJeUlpQUNGaFlYR1Npbm9SVVFDa09tZ04xTE40RW1KaUlROWc1M25JdlhvUlVRQ2tJWnVSRVJDbk1HZ0w5TFFqWWhJQURMWWVWYVBYa1FrRU9sbXJJaElpRE45TTlaSVFwODllOVpFR1JFUndXaW1Ga1lBWjB4VXlzbkpNVkZHUkVTQUV5ZE9tQ3AxT2dJNGFhTFN5Wk5HeW9pSUNFWTd6eWNqQUNQVkZQUWlJdVlZek5RY1kwR3ZvUnNSRVhNTVptcU9obTVFUkFKUVFQYm96NTA3cDduMElpSUdGQlFVY09IQ0JWUGxUaHJyMFFPY09uWEtWQ2tSa2JCbGVDamNYSThlNFBqeDQ2WktpWWlFTFlOVEs4RjAwQjg0Y01CVUtSR1JzTFYvLzM2VDVTNU9yeXd4VVczZnZuMG15b2lJaExYczdHeFRwWW9wZjJDcUJEaHNvcUxobjBJaUltSEpZS2Y1SUZCYXNUbDR0b21LNnRHTGlQalBZSmJ1QTN0ejhJdS84WmZCanhzaUltSExZSlptd3pkQmI2U3FnbDVFeEg4R3MvU1NIcjJScXFkT25kSnl4U0lpZnNqSnllSGN1WE9teXBrZnVnSDE2a1ZFL0dINFhtYzJHTzdSQSt6Y3VkTlVLUkdSc0xOcjF5NlQ1UzdwMFIvRzBONngyN1p0TTFGR1JDUXNHY3pRQXVBb2ZCUDBwWUNSeDFxenNySk1sQkVSQ1VzR2d6NGJzT0Nib0FmNHdrUmw5ZWhGUkdvdk16UFRWS2tkRmIrb0hQUkd1dUw3OSsvbnpCa2oyOUNLaUlTVlU2ZE9jZml3a1lVS0FDNzJ1aU9xK2tOL1dKYkY5dTNiVFpRU0VRa3Joa2RFbkF0NjBEaTlpRWh0R003T2k4VXFCLzF1SU45RWRZM1RpNGpVbk1Ic3ZBRHNyZmhONWFBdnhkQU4yYzgvLzl4RUdSR1JzR0w0Um14WnhXOGlMdnRMSTU4YnRtelpRbjYra1E4SElpSmhJVDgvMzJRbitaSXN2enpvalh4dUtDb3E0cC8vL0tlSlVpSWlZZUhUVHorbHFNakljNnR3V1pZN0V2UUE2OWF0TTFWS1JDVGtHYzdNUzNyMFVaZjk1UmJzSjZsOC9yYWlvTC9VN3QyN3ljdkw4L28wUkFKRzNicDE2ZHk1czllbkVURFdyMTl2cWxRWmNNa1kwT1ZCZndyNEYzQ2R2eTJ0WDc4ZXk3THcrZnorbVJFU3lzcktLQzB0OWZvMFJBSkdXVm5adGI4cFRGaVd4Y2FORzAyVjJ3NWM4dFRxNVVNM0FFYTY0ams1T2FaWFlSTVJDVWs3ZHV6ZzFLbFRwc3A5SzhNZEMzclE4STJJU0hVWXprb0Z2WWhJb0RHY2xkOGE3TDk4akI3Z0srdzFqRnY0MjlyeTVjczFUbjhWcjc3NktvTUhEL2I2TkVRY3QzTGxTcDU2NmltdlR5TWdXWmJGaWhVclRKWDdtaXAyREt3cTZBRTJBSGY1MitLaFE0Zll2bjA3UFhyMDhMZFVTRXBLU3FKYnQyNWVuNGFJNDNTLzdzbysvL3h6amh3NVlxcmMycXIrc0txaEd6QTRmTE5zMlRKVHBVUkVRczdTcFV0Tmxxc3l1eDBQZXNQL0NCR1JrT0psMEc4QnpodHBkZDA2Y25OelRaUVNFUWtwWjg2Y01UbC8vaXhRNWFwb1Z3cjZJbUNWaVphTGlvcFliZEo1SUFBQUdDaEpSRUZVdVhLbGlWSWlJaUZsK2ZMbGxKU1VtQ3EzQXFpeTJKV0NIc0RZNExyRzZVVkV2czF3Tmw2eDJOV0MzdGpBMGRLbFM3RXN5MVE1RVpHZ1oxa1dIMzMwa2NtU1Z3ejZLMDJ2Qk1nR2RnSmQvVzM5d0lFRGJONjhtWDc5K3ZsYnlsVm56NTZsb0tEQVNLM2k0bUlqZFVSQ1JYRnhNU2RPbkRCU3E3Q3cwRWdkTjIzWXNNSDBSdUNIcnZTWFZ3dDZzSDlDK0IzMEFIUG56ZzI2b0Q5MjdKalhweUFTc29xS2lqaHc0SURYcCtHWk9YUG1tQ3gzMVJHWXF3M2RYUFBGTmZIM3YvOWR3emNpSXRncmQ3NzMzbnNtUzE1MXNQOWFRYjhHTUxLSStzR0RCL24wMDA5TmxCSVJDV3ByMTY0MU9XeHpnU3JXdDZuc1drRmZBSHhpNm13TWYxUVJFUWxLaHJOd0JYRFZteFRYR3FNSFdBamNidUpzNXM2ZHkyOS8rMXNpSXE3MTg4Vjlnd1lOY24yM201WXRXN3Jhbm9oWFdyWnN5Y2lSSTExdE15a3B5ZFgycXF1MHRKUjU4K2FaTExub1d0OVFuV1VsRTRFalZPK0h3ald0WGJ1V0FRTUdtQ2dsSWhKMFZxOWV6YUJCZzB5Vkt3WmFBamxYKzZicWRLMVBBcXRObkJIQXUrKythNnFVaUVqUU1aeUJLN2hHeUVQMU53R2ZCTXp3NjNUS0pTUWtjT2pRSWVyVXFXT2luSWhJME1qUHo2ZDE2OWFjUG4zYVZNa0hnYmV1OVUzVkhTeWZoNzMramQ5eWNuSllzR0NCaVZJaUlrRmw3dHk1SmtPK0NQaXdPdDlZM2FBL0RSaGJtV3pHRENNZkRrUkVnb3JoN0Z1R25jM1hWSlBwTDhibUE2MWV2Wm92di96U1ZEa1JrWUMzYTljdTAzdkRWanVUYXhMMEM3akdYTTNxc2l5TFAvM3BUeVpLaVlnRWhSa3pacGhjSGFBQWUrcDd0ZFIwMSs2RmdKSEpzTTJiTitmZ3dZTkVSMGViS0NjaUVyQ0tpb3BvMDZZTng0OGZOMVZ5UG5CM2RiKzVwazh1emFyaDkxL1JzV1BIV0xUb212UDhSVVNDM29JRkMweUdQTURiTmZubW1nYjlCNEN4czUwK2ZicXBVaUlpQWV1Tk45NHdXZTRvc0xnbUw2aHAwQmRoc0ZmLzhjY2ZrNWxaNVJhSElpSWhJU3NyaTFXcmpPek1XdUhQMkUvRVZsdHRGcDJaQVJpN296QjE2bFJUcFVSRUFzNXZmdk1ia3pkaExhREdNMWxxZWpPMndqK0E3OVR5dFplSWpvNW03OTY5QWJzQWtZaEliUjArZkpqMjdkdFRWR1RrZVZPQVZjRGdtcjZvdHN0SUdwdjFYMXhjekd1dnZXYXFuSWhJd0pnNmRhckprSWRhWm05dGUvUjFnTU5BZkMxZmY0a21UWnB3NE1BQjZ0ZXZiNktjaUlqbmNuTnphZE9tRFdmUG5qVlZNZ2RJd3A1RFh5TzE3ZEVYQUxOcitkcHZPWDM2TkcrKythYXBjaUlpbmt0UFR6Y1o4bUJQaEtseHlFUHRlL1FBM2JGM0h2ZW54a1hKeWNsOCtlV1hSRVVaV2ZaZVJNUXp4Y1hGZE96WTBlVG01eFp3UGZCRmJWN3N6MVpQTzREbGZyeitFdG5aMmJ6enpqdW15b21JZU9idHQ5ODJHZkpnTDJCV3E1QUgvM3ZqdzRDUC9LeHhVWEp5TXJ0MjdTSW1Kc1pVU1JFUlZ4VVhGOU8xYTFmMjd0MXJzdXdRL0ZoQjJOL05XejhHUHZlenhrWFoyZG5NbW1Yc2VTd1JFZGU5K2VhYnBrTStDM3RhWmEyWkdGK2ZBUHpGUUIwQTJyWnR5KzdkdTRtTmpUVlZVa1RFRllXRmhYVHExSW1EQncrYUxEc1c4R3RjMjk4ZVBlVW5ZT3hmZGVEQUFjM0FFWkdnbEo2ZWJqcmtEd0Z6L1MxaVpNWU04RHp3MzRacTBiSmxTL2JzMlVOY1hKeXBraUlpamlvb0tLQmp4NDRjUG56WVpOa2ZBNy96dDRpSkhqM0FOT0Njb1ZvY09YS0U5UFIwVStWRVJCejN4ei8rMFhUSW53T01ERytZNnRFRFRBV2VObFdzV2JObWZQbmxselJzMk5CVVNSRVJSNXc5ZTVaT25UcHg0c1FKazJWL0EveUhpVUtSSm9xVXl3SitCQmpaTXVyQ2hRdVVsWlV4ZE9oUUUrVkVSQnp6MGtzdnNYSmxyV2MvVmlVZitEOUFyb2xpSm52MEFLOEFrMDBWaTRtSllmdjI3WFRxMU1sVVNSRVJvNzc2Nml1dXYvNTZDZ3VOYktsZHdWaHZIc3lOMFZmNE5aQm5xbGhSVVJILzhSL0cvcTBpSXNZOS9mVFRwa1ArUFBCYmt3Vk5CLzFSNEhXVEJSY3NXTURISDM5c3NxU0lpQkVyVnF4Z3laSWxwc3UrZ3NFdFc4SDgwQTFBSXJBWGFHQ3E0SFhYWFVkbVpxWVdQQk9SZ0ZGU1VrS3ZYcjNZc1dPSHliSm5nZmJBS1pORlRmZm9BVTRDcjVvcytNVVhYekJqaHJHOVRrUkUvUGJIUC83UmRNZ0QvQjdESVEvTzlPZ0JtbUQzNmh1YktwaVltTWpPblR0SlNFZ3dWVkpFcEZhT0h6OU8xNjVkT1gzNnRNbXlwN0I3ODBZWHNRZG5ldlFBcDdGL01obHo4dVJKbm52dU9aTWxSVVJxNVpsbm5qRWQ4bURmZ0RVZTh1QmNqeDdzTWZyZFFBdFRCWDArSHg5OTlKSG0xb3VJWjVZc1djSWRkOXhodXV4aG9BdHd3WFJoY0Rib0FSNEMvbVN5WUhKeU10dTJiZFArc2lMaXVnc1hMdENqUncvMjdkdG51dlE0REc3UGVqbVRUOFpXSlF1NEhXaHRxdUNaTTJjb0xpNW0yTEJocGtxS2lGVExUMzd5RXo3NnlOaGVTeFUyQXY5dXVtaGxUdmZvQWZvRDYweTJGUmtaeWNhTkc3bmhoaHRNbFJRUnVhclBQdnVNdExRMFNrdExUWmExc0RQeVU1TkZMK2ZVemRqS05nQnpUQllzTFMzbDRZY2Zwcmk0MkdSWkVaRXFsWlNVOE5oamo1a09lWUMzY1Rqa3dmbWhtd3FmQVk5amFNRXpnR1BIamhFVEU4TjN2dk1kVXlWRlJLcjBpMS84Z3IvLy9lK215MTRBN3NMUXdtVlg0OGJRVFlXZkF6OHpXVEFxS29xMWE5ZHkwMDAzbVN3ckluTFI1czJiU1V0TGMySUU0YWZBTDAwWHJZcWJRUjhIN0FUYW1pemFvVU1IdG03ZFNvTUd4bFpjRUJFQjRQejU4L1R0MjVmZHUzZWJMbjBRNklyQlJTQ3Z4cTJoRzRBUzdQMFB4NWdzZXZyMGFVNmNPTUgzdi85OWsyVkZSSGowMFVkWnRXcVZFNlVuQU51ZEtGd1ZOM3YwRmVaamowc1o5ZTY3N3pKbWpOR2ZJU0lTeHViTm04Zm8wYU9kS1AwdWNKOFRoYS9FaTZCdkNlekFYZy9IbUNaTm12RDU1NS9UdHEzUmtTRVJDVU9IRGgwaU5UV1ZVNmVNcnk5MkZyZ08rTnAwNGF0eFkzcmw1WTRBTDVvdWV2cjBhY2FQSDA5WldabnAwaUlTUnNyS3lwZ3dZWUlUSVEvd0RDNkhQTGc3UmwvWkZ1QjdRTExKb3Z2Mzc5ZVVTeEh4eTg5Ly9uUCsvT2MvTzFGNkZmQ3NFNFd2eFl1aG13cWRnRXpzMlRqR1JFUkVzR2pSSWthTUdHR3lySWlFZ2VYTGx6Tml4QWduSG96S0Izb0NYNWt1WEIxZUROMVUrQko0MlhUUnNySXl4bzRkeTk2OWUwMlhGcEVRbHAyZHpmMzMzKzlFeUFQOEZ4NkZQSGpib3dmN1NkblBnRjZtQy9mcDA0ZTFhOWNTRjJmMEE0T0loS0M4dkR6UzB0TEl6TXgwb3Z3VzRDYnNLZWFlOExKSEQxQU1qTVgrV0dQVWxpMWJlUFRSUjAyWEZaRVE5Ry8vOW05T2hYd0I4Q0FlaGp4NGR6TzJzaFBBT2NENG9IcFdWaFl0V3JUUUtwY2lja1d2dnZvcXYvNzFyNTBxUHhsWTdGVHg2dko2NkthQ0QxaUV2WGE5VVRFeE1heGV2WnEwdERUVHBVVWt5SzFkdTVaQmd3WTV0Ukx1UXVCTzdLV0lQUlVvUVEvUUZIdWpFbU5iRDFaSVRFeGsvZnIxZE9yVXlYUnBFUWxTZS9mdXBYLy8vaHcvZnR5SjhzZXhaOWtjYzZKNFRYazlSbC9aQ2V5dEI0My85RHQ1OGlRalJvemd4SWtUcGt1TFNCREt5Y2xoeElnUlRvVzhCVXdrUUVJZUFpdm9BWllCcnp0UmVNK2VQZHg5OTkwVUZoWTZVVjVFZ2tSQlFRRjMzbm1uRXl0U1Z2Z0RBVEF1WDFtZ0JUM0FjOEEySndwblpHUXdmdng0TE12eklUTVI4WUJsV1V5YU5JbDE2OVk1MWNRT0hGaml4VitCTU92bWNpVkFCdll5bmpHbWkrL1lzWVBpNG1JR0R4NXN1clNJQkxnWFhuaUI2ZE9uTzFVK0Z4aUd2WjVYUUFuRW9BZjdSc1pld0pFMVFqTXlNa2hLU3FKUG56NU9sQmVSQURSOStuUmVldWtscDhwYndBUEFHcWNhOEVlZ0JqM1lpL0kzd3Q0aDNiZ2xTNWJRdVhObnJyLytlaWZLaTBnQW1UOS9QaE1uVG5SeWRkdmZBcTg0VmR4ZmdUUzlzaXBSd0FyZ3UwNFVqNDZPWnY3OCtZd2NPZEtKOGlJU0FENzY2Q1B1dlBOT0p5ZGlyTVllc3ZIMDZkZXJDZlNnQjJnT2JBYVNuQ2dlRXhQRGh4OSt5UERodzUwb0x5SWVXcmx5SlNOSGpxU2dvTUNwSmc0Q04yQVBOd2VzWUFoNnNCY0UrZ2NRNjBUeHVuWHJzbXpaTWdZT0hPaEVlUkh4d01hTkd4azZkQ2puejU5M3FvbGk0RmJBc1NrOHBnVGk5TXFxZklxOU00c2o4dkx5R0RWcUZQLzg1eitkYWtKRVhKU1ptY250dDkvdVpNZ0RQRWtRaER3RVQ0Kyt3aHZBSTA0VmI5cTBLYXRYcjZaNzkrNU9OU0VpRHR1K2ZUdTMzbm9ySjArZWRMS1o2Y0FUVGpaZ1VyQUZmU1N3QUhEczdtbVRKazFZdG13Wk45NTRvMU5OaUloRHRtelp3dkRodzUwTytXWEFLQUw0NXV2bGdpM29BUnBnUDFDVjZsUURqUm8xWXNtU0pWcnhVaVNJZlBiWlo0d1lNY0twVGIwcmJBZHVBYzQ2MllocHdUSkdYMWt1OW5MR0I1MXE0T3pac3d3Yk5vemx5NWM3MVlTSUdQVEpKNTh3Wk1nUXAwUCthK3pzQ2FxUWgrQU1lbkRoUC9pRkN4Y1lOV29VQ3hZc2NLb0pFVEZnOGVMRmpCZ3hndHpjWENlYmNieUQ2YVJnRFhxd1AwTGRoNFBqWklXRmhZd1pNNGE1YytjNjFZU0krT0hkZDkvbHJydnVjbktlUE5nWmN3L2d5RjZEYmdqa0pSQ3E0eXZzZGV3ZHV6bGJWbGJHL1BuemFkbXlKWDM3OW5XcUdSR3BvZlQwZEI1KytHRktTaHkvSi9vWUVOUzl2V0FQZXJDZm12VUIzM09xQWN1eVdMaHdJVVZGUlF3YU5BaWZMeGp2WVl1RUJzdXllT0dGRjNqeHhSZmRXSEw4UDRHcFRqZml0RkFJZW9CUGdMckFBQ2NiV2J0MkxkdTNiMmZVcUZGRVIwYzcyWlNJVktHd3NKQUpFeVk0dWRSd1pWTUJ4NWE3ZEZNb2RVMTl3R3U0OEJERHpUZmZ6SWNmZmtqVHBrMmRia3BFeXAwNmRZcTc3cnFMTld0Y1dRbjRkZURmM0dqSURhRVU5R0QvZTJZQUR6dmRVSWNPSFZpOGVERmR1blJ4dWltUnNMZG56eDd1dU9NT2R1M2E1VVp6YndNUEFvNnRhZXkyWUo1MVV4VUxlQnlZNTNSRGUvYnNZZURBZ1U1dVNTWWkyRU9tTjk5OHMxc2gveDd3RUNFVThoQTZZL1NWbFFIdkE3MkJ6azQybEplWHg2eFpzNGlOamVXV1cyNXhzaW1Sc1BUR0cyOXczMzMzT1QxSHZzTEgyTk1vaTkxb3pFMmhOblJUV1J5d0VIQmxjOWdKRXlZd2JkbzA0dUxpM0doT0pLVGw1ZVh4K09PUDgvYmJiN3ZWNUVyczlXdnkzV3JRVGFFYzlHQ3ZYLzkzNEFkdU5OYXJWeS9telp0SCsvYnQzV2hPSkNRZE9IQ0F1KysrbTgyYk43dlY1QkxzL2FsRE11UWg5TWJvTDFjSTNJczk3dWE0enovL25INzkrckZzMlRJM21oTUpPVXVYTHFWWHIxNXVodndId0E4SjRaQ0gwQnlqdjF3cE1COUl4c0VWTHl2azUrZnp0Ny85amNqSVNHNjU1Ulk5WENWU0RXVmxaZno4NXovbnNjY2VJei9mdGN4OUN4aExDSTdKWHk2Y1VzaUgvUURFWkxjYXZQWFdXNWsxYXhaSlNZNXNkeXNTRWc0ZVBNajQ4ZVA1NUpOUDNHeDJPdlk4K1pDYVhYTWw0ZENqcit3am9CN2d5a0x6MmRuWi9PbFBmNkpkdTNiMDZOSERqU1pGZ3NxOGVmTzQ0NDQ3K05lLy91Vm1zLzhEL0R2MmRPeXdFRzVCRDFDeHlQejMzR2lzc0xDUWVmUG1jZWpRSVFZTkdrUk1USXdiellvRXROemNYQjUvL0hGZWV1a2xONGRxd0Y2NzVtZHVOaGdJd21ubzVuSVRzVCsrdWJab1RYSnlNck5uejJiQUFFZVg1QkVKYUpzMmJXTHMyTEY4K2VXWGJqWmJnajFzTzgzTlJnTkZPUGJvSzJ6Rlh2bnkrOWpUTUIxMzVzd1ozbjc3Ylh3K0gvMzc5eWN5TXB6LzgwdTRLUzR1NXBlLy9DVVRKa3h3ZWsvWHk1M0RubUw5cnB1TkJwSnc3dEZYNkFFc0F0cTYybWlQSHN5WU1ZT2JicnJKeldaRlBMRjE2MVltVFpyRWxpMWIzRzc2YSt6OUtyYTYzWEFnQ2ZWNTlOV3hEZWdQdVBvTzNMWnRHMmxwYVR6MjJHT2NQMy9lemFaRlhKT1hsOGNMTDd4QXYzNzl2QWo1YmNETmhIbkl5NlhxWS9mc0xiZVA1T1JrYTlteVpaWklLRm15WkluVnJsMDcxNituOHVNam9LR1JaSkNRRXdXOGdUZHZUR3ZjdUhIV2lSTW52TDQrUmZ4eS9QaHhhK3pZc1Y0RnZJVjl3elhLUUI2RUROME52RlFaOWtKb1I0RGh1UHpmSnlzcmk1a3pad0p3NDQwMzZtYXRCSldTa2hKbXpweko2TkdqMmJoeG94ZW5VQWc4aHoxOU1pd2VoQkwvOVFXeThhaFgwcVZMRjJ2eDRzVmVkODVFcW1YRmloVldqeDQ5dk96Rkg4SWVqeGVwc1VSZ0JkNjllYTBoUTRaWU8zYnM4UG82RnFuUzd0MjdyWHZ1dWNmTGdMZUFmd0F0L0w3YUpheEZBZitOL1ZIUWt6ZHlkSFMwTlhueVpPdk1tVE5lWDljaWxtVlpWbTV1cmpWbHloUXJOamJXNjVCUHg4V0hIaVgwM1F2azR1R2J1bW5UcHRiLy91Ly9Xbmw1ZVY1ZjV4S21MbHk0WVAzbU43K3hFaE1UdlE3NGM5aHJ5SXNZMXgzWWpyZHZjS3RseTViV3E2KythaFVVRkhoOTNVdVl5TS9QdDZaT25XcTFhTkhDNjRDM2dDeWdtNS9Yc3NoVjFjRWV5aW5GNHpkOG16WnRyS2xUcHlyd3hURkZSVVZXZW5xNmxaU1U1SFc0VzlqRHArbEFYYit1WUpFYXVCMDRpdmR2ZnF0OSsvYldYLzd5RjZ1NHVOanJYSkFRVVZSVVpNMmNPZFBMQjU0dVA0NEF0L2wxeFlyVVVsUGdRN3kvQ0N5d2gzU21USmxpblQ1OTJ1dWNrQ0IxN3R3NWErclVxVmJidG0wOWZ6OVhPcFlCTGYyNFRrV01HQStjeC9zTHdnS3NCZzBhV0pNblQ3WU9IRGpnZFc1SWtEaHk1SWcxWmNvVXEwbVRKcDYvZnlzZCtjRFRhUEZGQ1NEWFlTK001dlhGY2ZHSWlZbXhKa3lZWUdWbFpYbWRJeEtndG03ZGFqM3d3QU5XZEhTMDUrL1h5NDdOUU5kYVg0MGlEb29DWGdEeThQNUN1WGo0ZkQ1cjZOQ2gxbnZ2dldjVkZSVjVuUzNpc2NMQ1Ftdk9uRG5XNE1HRFBYOXZWbkZjQUg2QzFxcVJJTkFlZTh0Q3J5K2FieDFObWpTeEhuMzBVV3ZidG0xZTU0MjRiTmV1WGRienp6OXZOV3ZXelBQMzRSV09md0JkYW5YRmlYakVoejEyZnhMdkw2QXFqNzU5KzFycDZlbldoUXNYdk00Z2NVaEJRWUUxWjg0Y2E4aVFJWmJQNS9QOFBYZUY0elR3S0JxTGx5RFdFbmdQN3krbUt4NU5talN4ZnZTakgxbi8rTWMvck5MU1VxK3pTZnhVV2xwcXJWNjkybnI4OGNldHhvMGJlLzcrdXNieGQ2QjVqYThxa1FEMUErQUEzbDlZVnoxYXRXcGxUWjQ4MlZxN2RxMVZWbGJtZFdaSk5aV1dsbG9aR1JuV2swOCthYlZzMmRMejkxRTFqbjNBcUJwZVF5SkJJUTU0SG51ZERxOHZ0R3NlU1VsSjF1VEprNjJNakF5RmZvRGF2bjI3TldYS0ZLdDkrL2FldjErcWVWd0EvcXY4V2hDWGFFek1HNjJCWHdNUEVDVC9ENW8xYThidzRjTVpOV29VUTRjT3BYSGp4bDZmVWxpNmNPRUNxMWF0WXRHaVJTeGR1cFNEQnc5NmZVclZaV0VQWVQ2SC9jbFdYQlFVSVJQQytnRlRnVFN2VDZRbUlpTWo2ZFdyRnlOSGptVFVxRkgwNmRNSG4wOXZKYWZzMkxHRFJZc1dzV0xGQ3Rhc1dVTlJVWkhYcDFSVG00Ri9COVo1ZlNMaFNsZW45eUtBY2RnOS9LQjh6THRseTVZTUhUcVVXMjY1aGJTME5LNjc3am9GZnkyVmxaWHh4UmRmc0c3ZE90YXRXOGZ5NWNzNWV2U28xNmRWVzRlQkY0SFoyRDE2OFlpdXhzQlJIN3ZYOHl6UXhPTno4VXQ4ZkR6OSsvZG53SUFCREJnd2dINzkraEVYcHlIWnF1VGw1YkZwMDZhTHdiNWh3d1pPbno3dDlXbjU2eFR3djhBcjJHUHk0akVGZmVCcEREeURIZm9OUFQ0WEk2S2pvK25UcHcrcHFhbjA3Tm1USGoxNjBMTm56N0FiNXo5OStqUlpXVmxzMjdhTnJLd3NNak16MmJwMUs4WEZ4VjZmbWlsbnNZY2lmMS8rYXdrUUN2ckFsWUI5NCtvcG9KN0g1K0tJdG0zYmN2MzExOU96WjA5Njl1eEo1ODZkU1VsSklUNCszdXRUODB0T1RnNzc5dTFqOSs3ZFpHVmxYUXozUTRjT2VYMXFUamtQdkFyOEZyczNMd0ZHUVIvNG1tR3ZuL000WVRJbHJXSERoaVFuSjVPU2tuTHhhMHBLQ3UzYXRhTnAwNllrSkNRUUd4dnJ5YmtWRmhhU2s1UERpUk1ueU03T0pqczdtMzM3OXJGdjM3Nkx2ODdOemZYazNEeVFCMHdEL2g5d3d1TnprYXRRMEFlUFZ0amo5NDhRSWtNNi9xaGZ2ejRKQ1FrMGJkcVV4TVJFRWhJU1NFaElvSDc5K2pSc2FQL25xVnUzN3NVZkNFMmEyTGM5S241ZldGZ0ljSEU4dkxDd2tMeThQQURPblR2SCtmUG55Y25KSVNjbmg1TW5UM0xpeEFseWNuSTRmLzY4cS8vT0FIVU9lQVA0SGZhR0lDSmlXQVBzTmJyMzQvM0RMenJDNnppQy9iQlRVRThXRUFrbTBjQTl3S2Q0SHdBNlF2djRISHVCdm1oRXhETzNBQXV4TjAvMk9oUjBoTTZ4Rm5zOUdnM3hpZ1NRNjdDbnQrWGdmVWpvQ003akpQYjB5T3NRa1lBV2l6MnNzeHoxOG5WVTc5aU12U1o4WFVRazZIVEV2b0VXOEVzazYzRDlPQUw4Ti9aN1JFUkNRRFR3UStCOUlCL3ZRMGFITjBjK01COTdmd1R0eXlvU3d1cGlEKzBzQkFyeFBueDBPSHVVWUEvampVZlBZSWlFcFNiQVE4QXlvQmp2UTBtSG1hTUlXQUk4aUwxK2tvUXhUWnVTeWhLd2gzZEdBWU1JMFRWMlF0aDVZQ1d3Q0h0NFJ1dk9DS0NnbHl1TEFtNEdSZ0pEZ0Q3by9SS0k5Z0lyc01QOVkreWhPSkZMNk1LVjZtb09ETWNPL3FGb09NQXJGNEFOMk1IK1B0cVdUNnBCUVMrMUVZWGR3MDhEQnBRZlFiazdWaEQ0R25zTHZuWEFlbUFyOXMxVmtXcFQwSXNwcmJBRC81YnlyNzJ4dDBtVW10bUxIZXByeTc5K2dYMXpWYVRXRlBUaWxNYll2ZjRlNVVjcTltUDFldkxTbGdmc0FMS0FiZVhIRnVDTWx5Y2xvVWxCTDI2S0JOcGpoMzdGRDREcmdHVHNaUnRDVVNHUWpkMHpyd2owVEdBUDl2SVVJbzVUMEV1Z2FJTDlRK0R5b3hXUVF1RHVybFdNdlJEWTE5akRMcGNmKzRGU3o4NU9CQVc5QkljSUlCRjdudi9sUjlQeXI0blk4LzRyWmdQVjRac2ZEbzNLYTBRRDljdi83RHgyU0pmeHpVYlcrVUJCK2EvUGxIOVBUdmx4b3RLdmM3RER2ZUxYNnBsTFFQdi9GU0g1KytTUzlNWUFBQUFBU1VWT1JLNUNZSUk9JzsiLCIvKipcclxuICogTWFwcyBpcyB0aGUgc2V0IG9mIHRoZSBtYXAgZnVuY3Rpb25zXHJcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE1hcHNcclxuICogQHByb3BlcnR5IHtbaWQ6IHN0cmluZ106IE5vZGV9IG5vZGVNYXAgLSBtYXAgaWQgdG8gW05vZGVde0BsaW5rIE5vZGV9IC0gUmV0dXJucyBOb2RlIGJ5IGlkIGFuZCAob3B0aW9uYWwpIHJvbGUuXHJcbiAqIEBwcm9wZXJ0eSB7W2lkOiBzdHJpbmddOiBMaW5rfSBsaW5rTWFwIC0gbWFwIGlkIHRvICBbTGlua117QGxpbmsgTGlua30gLSBSZXR1cm5zIExpbmsgYnkgaWQgYW5kIChvcHRpb25hbCkgcm9sZS5cclxuICogQHByb3BlcnR5IHtbaWQ6IHN0cmluZ106IExpbmt9IHNvdXJjZU1hcCAtIG1hcCBpZCB0byAgW0xpbmtde0BsaW5rIExpbmt9W10gLSBSZXR1cm5zIGFsbCBpbmNvbWluZyBsaW5rcyBmb3IgdGhlIG5vZGUgd2l0aCBzcGVjaWZpZWQgaWQgKGZpbHRlcnMgYnkgcm9sZSkuXHJcbiAqIEBwcm9wZXJ0eSB7W2lkOiBzdHJpbmddOiBMaW5rfSB0YXJnZXRNYXAgLSBtYXAgaWQgdG8gIFtMaW5rXXtAbGluayBMaW5rfVtdIC0gUmV0dXJucyBhbGwgb3V0Z29pbmcgbGlua3MgZm9yIHRoZSBub2RlIHdpdGggc3BlY2lmaWVkIGlkIChmaWx0ZXJzIGJ5IHJvbGUpLlxyXG4qL1xyXG5cclxuLyoqXHJcbiAqIEVuZCBlbGVtZW50cyBvZiB0aGUgZ3JhcGgsIHdoaWNoIHdlcmUgY3JlYXRlZCBmcm9tIHtAbGluayBTZXJ2ZXJEYXRhfS5cclxuICogQHR5cGVkZWYge09iamVjdH0gR3JhcGhEYXRhXHJcbiAqIEBwcm9wZXJ0eSB7TGlua1tdfSBsaW5rcyAtIExpc3Qgb2YgTGlua3Mgb2YgdGhlIGdyYXBoXHJcbiAqIEBwcm9wZXJ0eSB7Tm9kZVtdfSBub2RlcyAtIExpc3Qgb2YgTm9kZXMgb2YgdGhlIGdyYXBoXHJcbiovXHJcblxyXG4vKipcclxuICogQHByaXZhdGVcclxuICogRGF0YUNvbnRhaW5lciAtIGFuIG9iamVjdCB3aGljaCBpcyBhIGRhdGEgbW9kZWwgb2YgdGhlIExpbmVnZUdyYW0uIEl0IHN0b3JlcyBhbmQgb3JnaW5pemVzXHJcbiAqIGRhdGEgZm9yIHRoZSB2aWV3cyBhbmQgYWxzbyBwcm92aWRlcyBzZXQgb2YgbWFwcyAoZGljdGlvbmFyaWVzKSBmb3IgbGlua3MgYW5kIG5vZGVzIG9mIHRoZSBncmFwaC5cclxuICogWW91IGNhbiBnZXQgdGhpcyBtb2RlbCB1c2luZyBhIExpbmVhR3JhbSBtZXRob2Qgd2hpY2ggaXMgY2FsbGVkICdnZXRHcmFwaE1vZGVsJy5cclxuICogRGF0YUNvbnRhaW5lciBpbXBsZW1lbnRzIHNlcGFyYXRpb24gYW5kIGZpbHRyYXRpb24gbWVjaGFuaXNtcywgaW4gb3RoZXIgd29yZHMsXHJcbiAqIHlvdSBjYW4gcmV0dXJuIGRpZmZlcmVudCBkYXRhIGZvciBkaWZmZXJlbnQgcm9sZXMuXHJcbiAqIEBjbGFzc1xyXG4gKiBAcGFyYW0ge0dyYXBoRGF0YX0gZGF0YSAtIFJhdyBkYXRhIC0gbW9kZWxzIGZvciBsaW5rcyBhbmQgbm9kZXMgb2YgdGhlIGdyYXBoLlxyXG4gKiBAcGFyYW0ge1BhcmFtZXRlcnN9IHBhcmFtZXRlcnMgLSBQYXJhbWV0ZXJzIHNldFxyXG4gKiBcclxuICogQHByb3BlcnR5IHtNYXBzfSBtYXBzIC0gU2V0IG9mIHRoZSBtYXAgZnVuY3Rpb25zXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gRGF0YUNvbnRhaW5lciAoZGF0YSwgcGFyYW1ldGVycykge1xyXG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgaWYgKCFkYXRhKSBkYXRhID0ge307XHJcbiAgICBpZiAoIWRhdGEubm9kZXMpIGRhdGEubm9kZXMgPSBbXTtcclxuICAgIGlmICghZGF0YS5saW5rcykgZGF0YS5saW5rcyA9IFtdO1xyXG5cclxuICAgIHNlbGYubm9kZXMgPSBkYXRhLm5vZGVzO1xyXG4gICAgc2VsZi5saW5rcyA9IGRhdGEubGlua3M7XHJcbiAgICBzZWxmLm1hcHMgPSB7IHNvdXJjZU1hcDoge30sIHRhcmdldE1hcDoge30sIG5vZGVNYXA6IHt9LCBsaW5rTWFwOiB7fSwgaWRNYXA6IHt9IH07XHJcbiAgICBzZWxmLnpvbmVzID0gW107XHJcbiAgICBcclxuICAgIGNvbnN0IF96b25lU2l6ZSA9IHBhcmFtZXRlcnMuZGF0YVpvbmVTaXplO1xyXG4gICAgY29uc3QgX2VsZW1lbnRTaXplID0gcGFyYW1ldGVycy5lbGVtZW50U2l6ZTtcclxuICAgIGNvbnN0IF96b25lc0luR3JvdXAgPSBwYXJhbWV0ZXJzLnpvbmVzSW5Hcm91cDtcclxuXHJcbiAgICAvLyBJZiBzb21lIG5vZGUgZG9udCBoaXQgYW55IHJlYWwgem9uZSBpdCB3aWxsIGhpdCB0aGlzIG9uZS5cclxuICAgIGNvbnN0IF9mYWtlWm9uZSA9IG5ldyBOb2Rlc1pvbmUobnVsbCwge1xyXG4gICAgICAgIHg6IDAsXHJcbiAgICAgICAgeTogMCxcclxuICAgICAgICB3aWR0aDogMCxcclxuICAgICAgICBoZWlnaHQ6IDAsXHJcbiAgICAgICAgZWxlbWVudFNpemU6IDAsXHJcbiAgICAgICAgZmFrZVpvbmU6IHRydWUsXHJcbiAgICB9KTtcclxuICAgIGlmIChfZWxlbWVudFNpemUud2lkdGggPj0gX3pvbmVTaXplLndpZHRoIHx8IF9lbGVtZW50U2l6ZS5oZWlnaHQgPj0gX3pvbmVTaXplLmhlaWdodCkge1xyXG4gICAgICAgIF96b25lU2l6ZS53aWR0aCA9IF9lbGVtZW50U2l6ZS53aWR0aCAqIDIwO1xyXG4gICAgICAgIF96b25lU2l6ZS5oZWlnaHQgPSBfZWxlbWVudFNpemUuaGVpZ2h0ICogMjA7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIG5vZGVzIGFuZCBsaW5rcyB3aGljaCBhcmUgbGllIG5lYXIgdGhlIHBvaW50XHJcbiAgICAgKiBAcGFyYW0ge1BvaW50W119IHBvaW50cyAtIEFycmF5IG9mIHBvaW50c1xyXG4gICAgICogQHJldHVybiB7R3JhcGhEYXRhfSAtIE5vZGVzIGFuZCBMaW5rc1xyXG4gICAgICogQG1lbWJlcm9mIERhdGFDb250YWluZXJcclxuICAgICAqIEBtZXRob2RcclxuICAgICovXHJcbiAgICBzZWxmLmdldEVsZW1lbnRzTmVhclRoZVBvaW50cyA9IGZ1bmN0aW9uIChwb2ludHMpIHtcclxuICAgICAgICBjb25zdCBzdWl0YWJsZVpvbmVzID0gX3pvbmVzRm9yUG9pbnRzIChwb2ludHMpO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdE5vZGVzID0gW107XHJcbiAgICAgICAgY29uc3QgcmVzdWx0TGlua3MgPSBbXTtcclxuXHJcbiAgICAgICAgc3VpdGFibGVab25lcy5mb3JFYWNoKHogPT4ge1xyXG4gICAgICAgICAgICB6LnJlbGF0ZWROb2Rlcy5mb3JFYWNoKG4gPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdE5vZGVzLmluZGV4T2YobikgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0Tm9kZXMucHVzaChuKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHoubm9kZXMuZm9yRWFjaChuID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHROb2Rlcy5pbmRleE9mKG4pID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdE5vZGVzLnB1c2gobik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB6LmxpbmtzLmZvckVhY2gobCA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0TGlua3MuaW5kZXhPZihsKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRMaW5rcy5wdXNoKGwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgbm9kZXM6IHJlc3VsdE5vZGVzLFxyXG4gICAgICAgICAgICBsaW5rczogcmVzdWx0TGlua3MsXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWN0YW5nbGVcclxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFJlY3RhbmdsZVxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHggLSBQb3NpdGlvbiBieSB4IGF4aXNcclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB5IC0gUG9zaXRpb24gYnkgeSBheGlzXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gd2lkdGggLSBXaWR0aCBvZiB0aGUgcmVjdGFuZ2xlXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gaGVpZ2h0IC0gSGVpZ2h0IG9mIHRoZSByZWN0YW5nbGVcclxuICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIG5vZGVzIGFuZCBsaW5rcyB3aGljaCBhcmUgbGllIGludG8gdGhlIHJlY3RhbmdsZVxyXG4gICAgICogQHBhcmFtIHtSZWN0YW5nbGV9IHJlY3QgLSBIaXQgcmVjdGFuZ2xlXHJcbiAgICAgKiBAcmV0dXJuIHtHcmFwaERhdGF9IC0gTm9kZXMgYW5kIExpbmtzXHJcbiAgICAgKiBAbWVtYmVyb2YgRGF0YUNvbnRhaW5lclxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgKi9cclxuICAgIHNlbGYuZ2V0RWxlbWVudHNGb3JSZWN0YW5nbGUgPSBmdW5jdGlvbiAocmVjdCkge1xyXG5cclxuICAgICAgICBpZiAoIXJlY3QpIHJldHVybiB7IG5vZGVzOiBbXSwgbGlua3M6IFtdIH07XHJcbiAgICAgICAgY29uc3QgcG9pbnRzID0gW107XHJcbiAgICAgICAgaWYgKHJlY3Qud2lkdGggPD0gX3pvbmVTaXplLndpZHRoICYmIHJlY3QuaGVpZ2h0IDw9IF96b25lU2l6ZS5oZWlnaHQpIHtcclxuICAgICAgICAgICAgcG9pbnRzLnB1c2goeyB4OiByZWN0LngsICAgICAgICAgICAgICB5OiByZWN0Lnl9KTtcclxuICAgICAgICAgICAgcG9pbnRzLnB1c2goeyB4OiByZWN0LnggKyByZWN0LndpZHRoLCB5OiByZWN0LnkgfSk7XHJcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKHsgeDogcmVjdC54LCAgICAgICAgICAgICAgeTogcmVjdC55ICsgcmVjdC5oZWlnaHQgfSk7XHJcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKHsgeDogcmVjdC54ICsgcmVjdC53aWR0aCwgeTogcmVjdC55ICsgcmVjdC5oZWlnaHQgfSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgeCA9IHJlY3QueCA7OyB4ICs9IF96b25lU2l6ZS53aWR0aCkge1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgeSA9IHJlY3QueSA7OyB5ICs9IF96b25lU2l6ZS5oZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IE1hdGgubWluKHgsIHJlY3QueCArIHJlY3Qud2lkdGgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBNYXRoLm1pbih5LCByZWN0LnkgKyByZWN0LmhlaWdodClcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoeSA+PSByZWN0LnkgKyByZWN0LmhlaWdodCkgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoeCA+PSByZWN0LnggKyByZWN0LndpZHRoKSBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2VsZi5nZXRFbGVtZW50c05lYXJUaGVQb2ludHMocG9pbnRzKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIG5vZGVzIHJlbGF0ZWQgd2l0aCB0aGUgdGFyZ2V0IG5vZGVcclxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSAtIHRhcmdldCBub2RlXHJcbiAgICAgKiBAcmV0dXJuIHtOb2RlW119XHJcbiAgICAgKiBAbWVtYmVyb2YgRGF0YUNvbnRhaW5lclxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgKi9cclxuICAgIHNlbGYuZ2V0UmVsYXRlZE5vZGVzID0gZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICBjb25zdCBuZWlnaGJvcnMgPSBbXTtcclxuICAgICAgICBpZiAoc2VsZi5tYXBzLnRhcmdldE1hcFtub2RlLmlkXSkge1xyXG4gICAgICAgICAgICBzZWxmLm1hcHMudGFyZ2V0TWFwW25vZGUuaWRdXHJcbiAgICAgICAgICAgICAgICAuZm9yRWFjaChsID0+IG5laWdoYm9ycy5wdXNoKHNlbGYubWFwcy5ub2RlTWFwW2wubW9kZWwudGFyZ2V0XSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2VsZi5tYXBzLnNvdXJjZU1hcFtub2RlLmlkXSkge1xyXG4gICAgICAgICAgICBzZWxmLm1hcHMuc291cmNlTWFwW25vZGUuaWRdXHJcbiAgICAgICAgICAgICAgICAuZm9yRWFjaChsID0+IG5laWdoYm9ycy5wdXNoKHNlbGYubWFwcy5ub2RlTWFwW2wubW9kZWwuc291cmNlXSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmVpZ2hib3JzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZnJlc2hlcyBjb250YWluZXIuIEl0IG1lYW5zIHRoYXQgYWxsIG1hcHMgd2lsbFxyXG4gICAgICogYmUgdXBkYXRlZCBhbmQgbm9kZXMgaW4gdGhlIGNvbnRhaW5lciB3aWxsIGJlIG9yZ2FuaXplZC5cclxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSAtIFRhcmdldCBub2RlIChvcHRpb25hbClcclxuICAgICAqIEBtZW1iZXJvZiBEYXRhQ29udGFpbmVyXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAqL1xyXG4gICAgc2VsZi5yZWZyZXNoID0gZnVuY3Rpb24gKG5ld0RhdGEpIHtcclxuICAgICAgICBpZiAobmV3RGF0YSkge1xyXG4gICAgICAgICAgICBpZiAobmV3RGF0YS5ub2Rlcykge1xyXG4gICAgICAgICAgICAgICAgc2VsZi5ub2RlcyA9IG5ld0RhdGEubm9kZXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG5ld0RhdGEubGlua3MpIHtcclxuICAgICAgICAgICAgICAgIHNlbGYubGlua3MgPSBuZXdEYXRhLmxpbmtzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9yZWZyZXNoTWFwcygpO1xyXG4gICAgICAgIF9yZWZyZXNoR3JpZCgpO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBNb3ZlcyBub2RlIGZyb20gb25lIHpvbmUgdG8gYW5vdGhlci5cclxuICAgICAqIFdlIGFyZSB1c2luZyBpdCB3aGVuIG5vZGUgaXMgZHJhZ2dlZCB0byBzb21ld2hlcmUgb24gdGhlIHBhcGVyXHJcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgLSB0YXJnZXQgbm9kZVxyXG4gICAgICogQHBhcmFtIHtQb2ludH0gb2xkUG9zIC0gcHJldmlvdXMgcG9zaXRpb24gb2YgdGhlIHRhcmdldCBub2RlXHJcbiAgICAgKiBAbWVtYmVyb2YgRGF0YUNvbnRhaW5lclxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgKi9cclxuICAgIHNlbGYudXBkYXRlWm9uZXNGb3JOb2RlID0gZnVuY3Rpb24gKG5vZGUsIG9sZFBvcykge1xyXG4gICAgICAgIGNvbnN0IGN1clBvcyA9IG5vZGUubW9kZWwucG9zaXRpb247XHJcbiAgICAgICAgY29uc3Qgb2xkWm9uZXMgPSBfem9uZXNGb3JQb2ludHMgKFtvbGRQb3NdKTtcclxuXHJcbiAgICAgICAgb2xkWm9uZXMuZm9yRWFjaCh6b25lID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbmV3Tm9kZXMgPSB6b25lLm5vZGVzLmZpbHRlcihuID0+IG4gIT09IG5vZGUpO1xyXG4gICAgICAgICAgICBfY2xlYXJab25lKHpvbmUpO1xyXG4gICAgICAgICAgICBfZmlsbFpvbmUgKHpvbmUsIG5ld05vZGVzKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgY29uc3QgbmV3Wm9uZXMgPSBfem9uZXNGb3JQb2ludHMgKFtjdXJQb3NdKTtcclxuICAgICAgICBpZiAobmV3Wm9uZXMpIHtcclxuICAgICAgICAgICAgbmV3Wm9uZXMuZm9yRWFjaCh6ID0+IHtcclxuICAgICAgICAgICAgICAgIF9maWxsWm9uZSAoeiwgW25vZGVdKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgX2ZpbGxab25lIChfZmFrZVpvbmUsIFtub2RlXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYWxsIHpvbmVzIHdoaWNoIGNvbnRhaW4gb2J0YWluZWQgcG9pbnRzLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7UG9pbnRbXX0gcG9pbnRzXHJcbiAgICAgKiBAcmV0dXJuIHtOb2Rlc1pvbmVbXX1cclxuICAgICovXHJcbiAgICBmdW5jdGlvbiBfem9uZXNGb3JQb2ludHMgKHBvaW50cykge1xyXG4gICAgICAgIHBvaW50cyA9IHBvaW50cyB8fCBbXTtcclxuICAgICAgICBjb25zdCBzdWl0YWJsZVpvbmVzID0gW107XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHJlY3Vyc2lvbiAocCwgem9uZXMpIHtcclxuICAgICAgICAgICAgem9uZXMuZm9yRWFjaCh6ID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh6LmhpdFRlc3QocCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoeiBpbnN0YW5jZW9mIEdyb3VwT2Zab25lcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWN1cnNpb24ocCwgei56b25lcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdWl0YWJsZVpvbmVzLmluZGV4T2YoeikgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1aXRhYmxlWm9uZXMucHVzaCh6KTsgXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcG9pbnRzLmZvckVhY2gocCA9PiB7XHJcbiAgICAgICAgICAgIHJlY3Vyc2lvbiAocCwgc2VsZi56b25lcyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgc3VpdGFibGVab25lcy5wdXNoKF9mYWtlWm9uZSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIHN1aXRhYmxlWm9uZXM7XHJcbiAgICAgICAgXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGVzIHpvbmVzIHRyZWUuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgKi9cclxuICAgIGZ1bmN0aW9uIF9yZWZyZXNoR3JpZCAoKSB7XHJcbiAgICAgICAgbGV0IG1pblggPSB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIG1pblkgPSB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIG1heFggPSB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIG1heFkgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgIHNlbGYubm9kZXMuZm9yRWFjaChub2RlID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcG9zID0gbm9kZS5tb2RlbC5wb3NpdGlvbjtcclxuICAgICAgICAgICAgbWluWCA9IChtaW5YID09PSB1bmRlZmluZWQgPyBwb3MueCA6IE1hdGgubWluKG1pblgsIHBvcy54KSk7XHJcbiAgICAgICAgICAgIG1pblkgPSAobWluWSA9PT0gdW5kZWZpbmVkID8gcG9zLnkgOiBNYXRoLm1pbihtaW5ZLCBwb3MueSkpO1xyXG4gICAgICAgICAgICBtYXhYID0gKG1heFggPT09IHVuZGVmaW5lZCA/IHBvcy54IDogTWF0aC5tYXgobWF4WCwgcG9zLngpKTtcclxuICAgICAgICAgICAgbWF4WSA9IChtYXhZID09PSB1bmRlZmluZWQgPyBwb3MueSA6IE1hdGgubWF4KG1heFksIHBvcy55KSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGxldCB6b25lcyA9IFtdO1xyXG4gICAgICAgIGxldCBub2RlcyA9IFtdLmNvbmNhdChzZWxmLm5vZGVzKTtcclxuICAgICAgICBmb3IgKGxldCB4ID0gbWluWCwgaSA9IDA7IHggPD0gbWF4WDsgeCArPSAoX3pvbmVTaXplLndpZHRoIC0gX2VsZW1lbnRTaXplLndpZHRoKSwgaSsrKSB7XHJcbiAgICAgICAgICAgIHpvbmVzW2ldID0gW107XHJcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSBtaW5ZLCBqID0gMDsgeSA8PSBtYXhZOyB5ICs9IChfem9uZVNpemUuaGVpZ2h0IC0gX2VsZW1lbnRTaXplLmhlaWdodCksIGorKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3Wm9uZSA9IG5ldyBOb2Rlc1pvbmUobnVsbCwge1xyXG4gICAgICAgICAgICAgICAgICAgIHg6IHgsXHJcbiAgICAgICAgICAgICAgICAgICAgeTogeSxcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogX3pvbmVTaXplLndpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogX3pvbmVTaXplLmhlaWdodCxcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50U2l6ZTogX2VsZW1lbnRTaXplLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBub2RlcyA9IF9maWxsWm9uZSAobmV3Wm9uZSwgbm9kZXMpO1xyXG4gICAgICAgICAgICAgICAgem9uZXNbaV1bal0gPSBuZXdab25lO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNlbGYuem9uZXMgPSBfZ3JvdXBab25lcyh6b25lcyk7XHJcbiAgICAgICAgc2VsZi56b25lcy5wdXNoKF9mYWtlWm9uZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHcm91cHMgem9uZXMgYnkgZ3JvdXBzIG9mIChieSBkZWZhdWx0KSBmb3VyLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7Tm9kZVpvbmVbXX0gem9uZXNcclxuICAgICAqIEByZXR1cm4ge05vZGVab25lW10gfCBHcm91cE9mWm9uZXN9XHJcbiAgICAqL1xyXG4gICAgZnVuY3Rpb24gX2dyb3VwWm9uZXMgKHpvbmVzKSB7XHJcbiAgICAgICAgY29uc3QgTUFYX0RFRVAgPSAxMDAwO1xyXG4gICAgICAgIGNvbnN0IHNpZGUgPSBNYXRoLnNxcnQoX3pvbmVzSW5Hcm91cCk7IC8vIGxlbmd0aCBvZiBzaWRlIG9mIGdyb3VwXHJcbiAgICAgICAgbGV0IG5ld1pvbmVzO1xyXG4gICAgICAgIGZvciAobGV0IG4gPSAwOyBuIDwgTUFYX0RFRVAgJiYgem9uZXMubGVuZ3RoICE9PSAxOyBuKyspIHsgLy8gaXRlcmF0aW9uc1xyXG4gICAgICAgICAgICBuZXdab25lcyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbmkgPSAwOyBpIDwgem9uZXMubGVuZ3RoOyBpICs9IHNpZGUsIG5pKyspIHtcclxuICAgICAgICAgICAgICAgIG5ld1pvbmVzW25pXSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDAsIG5qID0gMDsgaiA8IHpvbmVzW2ldLmxlbmd0aDsgaiArPSBzaWRlLCBuaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgem9uZXNPZkdyb3VwID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgem9uZXNPZkdyb3VwLnB1c2goem9uZXNbaV1bal0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh6b25lc1tpICsgMV0gJiYgem9uZXNbaSArIDFdW2pdKSB6b25lc09mR3JvdXAucHVzaCh6b25lc1tpICsgMV1bal0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh6b25lc1tpXSAmJiB6b25lc1tpXVtqICsgMV0pIHpvbmVzT2ZHcm91cC5wdXNoKHpvbmVzW2ldW2ogKyAxXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHpvbmVzW2kgKyAxXSAmJiB6b25lc1tpICsgMV1baiArIDFdKSB6b25lc09mR3JvdXAucHVzaCh6b25lc1tpICsgMV1baiArIDFdKTtcclxuICAgICAgICAgICAgICAgICAgICBuZXdab25lc1tuaV1bbmpdID0gbmV3IEdyb3VwT2Zab25lcyh6b25lc09mR3JvdXApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHpvbmVzID0gbmV3Wm9uZXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChuZXdab25lcykgem9uZXMgPSBuZXdab25lcztcclxuICAgICAgICByZXR1cm4gem9uZXNbMF0gfHwgW107XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQdXRzIG5vZGVzIGFuZCBsaW5rcyBpbnRvIHpvbmUuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtOb2RlWm9uZX0gem9uZVxyXG4gICAgICogQHBhcmFtIHtOb2RlW119IG5vZGVzXHJcbiAgICAgKiBAcmV0dXJuIHtOb2RlW119XHJcbiAgICAqL1xyXG4gICAgZnVuY3Rpb24gX2ZpbGxab25lICh6b25lLCBub2Rlcykge1xyXG4gICAgICAgIGNvbnN0IG5vdEZpdGVkTm9kZXMgPSBbXTsgLy8gaW5kZXhlcyB0byByZW1vdmUgdGhlIGNhdGNoZWQgbm9kZXMgZnJvbSB0aGUgbGlzdFxyXG4gICAgICAgIG5vZGVzLmZvckVhY2goKG5vZGUpID0+IHtcclxuICAgICAgICAgICAgaWYgKHpvbmUubm9kZUhpdFRlc3Qobm9kZSkpIHtcclxuICAgICAgICAgICAgICAgIHpvbmUubm9kZXMucHVzaChub2RlKTtcclxuXHJcbiAgICAgICAgICAgICAgICBzZWxmLmdldFJlbGF0ZWROb2Rlcyhub2RlKS5mb3JFYWNoKG4gPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh6b25lLnJlbGF0ZWROb2Rlcy5pbmRleE9mKG4pID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB6b25lLnJlbGF0ZWROb2Rlcy5wdXNoKG4pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChzZWxmLm1hcHMuc291cmNlTWFwW25vZGUuaWRdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5tYXBzLnNvdXJjZU1hcFtub2RlLmlkXS5mb3JFYWNoKGxpbmsgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB6b25lLmxpbmtzLnB1c2gobGluayk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5tYXBzLnRhcmdldE1hcFtub2RlLmlkXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYubWFwcy50YXJnZXRNYXBbbm9kZS5pZF0uZm9yRWFjaChsaW5rID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgem9uZS5saW5rcy5wdXNoKGxpbmspO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbm90Rml0ZWROb2Rlcy5wdXNoKG5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIG5vdEZpdGVkTm9kZXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhciB6b25lIC0gcmVtb3ZlIGFsbCBkYXRhIGZyb20gdGhlIHpvbmUuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtOb2RlWm9uZX0gem9uZVxyXG4gICAgKi9cclxuICAgIGZ1bmN0aW9uIF9jbGVhclpvbmUgKHpvbmUpIHtcclxuICAgICAgICB6b25lLnJlbGF0ZWROb2RlcyA9IFtdO1xyXG4gICAgICAgIHpvbmUubm9kZXMgPSBbXTtcclxuICAgICAgICB6b25lLmxpbmtzID0gW107XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIG1hcCBmb3Igbm9kZXNcclxuICAgICAqIGFuZCB1cGRhdGVzIGFzcGVjdCByZWxhdGlvbnMgYmV0d2VlbiBub2Rlc1xyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEByZXR1cm5zIG5vZGVNYXBcclxuICAgICovXHJcbiAgICBmdW5jdGlvbiBfY3JlYXRlTm9kZU1hcHMgKCkge1xyXG4gICAgICAgIGNvbnN0IG5vZGVNYXAgPSB7fTtcclxuICAgICAgICBjb25zdCBpZE1hcCA9IHt9O1xyXG4gICAgICAgIHNlbGYubm9kZXMuZm9yRWFjaChub2RlID0+IHtcclxuICAgICAgICAgICAgbm9kZU1hcFtub2RlLmlkXSA9IG5vZGU7XHJcbiAgICAgICAgICAgIG5vZGVNYXBbbm9kZS5tb2RlbC5pZF0gPSBub2RlLmlkO1xyXG5cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBub2RlTWFwOiBub2RlTWFwLFxyXG4gICAgICAgICAgICBpZE1hcDogaWRNYXAsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgbWFwcyBmb3IgbGlua3MuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG5vZGVNYXBcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpZE1hcFxyXG4gICAgICogQHJldHVybnMge2xpbmtNYXAsIGlkTWFwfVxyXG4gICAgKi9cclxuICAgIGZ1bmN0aW9uIF9jcmVhdGVMaW5rTWFwcyAobm9kZU1hcCwgaWRNYXApIHtcclxuICAgICAgICBjb25zdCBzb3VyY2VNYXAgPSB7fTtcclxuICAgICAgICBjb25zdCB0YXJnZXRNYXAgPSB7fTtcclxuICAgICAgICBjb25zdCBsaW5rTWFwID0ge307XHJcblxyXG4gICAgICAgIHNlbGYubGlua3MuZm9yRWFjaChsaW5rID0+IHtcclxuICAgICAgICAgICAgbGlua01hcFtsaW5rLmlkXSA9IGxpbms7XHJcbiAgICAgICAgICAgIGlkTWFwW2xpbmsubW9kZWwuaWRdID0gbGluay5pZDtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IG5vZGVNYXBbbGluay5tb2RlbC5zb3VyY2VdO1xyXG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSBub2RlTWFwW2xpbmsubW9kZWwudGFyZ2V0XTtcclxuXHJcbiAgICAgICAgICAgIGlmICghc291cmNlTWFwW3RhcmdldC5pZF0pIHtcclxuICAgICAgICAgICAgICAgIHNvdXJjZU1hcFt0YXJnZXQuaWRdID0gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc291cmNlTWFwW3RhcmdldC5pZF0ucHVzaChsaW5rKTtcclxuXHJcbiAgICAgICAgICAgIGlmICghdGFyZ2V0TWFwW3NvdXJjZS5pZF0pIHtcclxuICAgICAgICAgICAgICAgIHRhcmdldE1hcFtzb3VyY2UuaWRdID0gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGFyZ2V0TWFwW3NvdXJjZS5pZF0ucHVzaChsaW5rKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBsaW5rTWFwOiBsaW5rTWFwLFxyXG4gICAgICAgICAgICBzb3VyY2VNYXA6IHNvdXJjZU1hcCxcclxuICAgICAgICAgICAgdGFyZ2V0TWFwOiB0YXJnZXRNYXAsXHJcbiAgICAgICAgICAgIGlkTWFwOiBpZE1hcCxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyBtYXBzLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICovXHJcbiAgICBmdW5jdGlvbiBfcmVmcmVzaE1hcHMgKCkge1xyXG4gICAgICAgIGNvbnN0IHsgbm9kZU1hcCwgaWRNYXAgfSA9IF9jcmVhdGVOb2RlTWFwcygpO1xyXG4gICAgICAgIGNvbnN0IGxpbmtNYXBzID0gX2NyZWF0ZUxpbmtNYXBzKG5vZGVNYXAsIGlkTWFwKTtcclxuXHJcbiAgICAgICAgc2VsZi5tYXBzID0ge1xyXG4gICAgICAgICAgICBzb3VyY2VNYXA6IGxpbmtNYXBzLnNvdXJjZU1hcCxcclxuICAgICAgICAgICAgdGFyZ2V0TWFwOiBsaW5rTWFwcy50YXJnZXRNYXAsXHJcbiAgICAgICAgICAgIG5vZGVNYXA6IG5vZGVNYXAsXHJcbiAgICAgICAgICAgIGlkTWFwOiBsaW5rTWFwcy5pZE1hcCxcclxuICAgICAgICAgICAgbGlua01hcDogbGlua01hcHMubGlua01hcCxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIHNlbGYucmVmcmVzaCgpO1xyXG59XHJcbmV4cG9ydCBkZWZhdWx0IERhdGFDb250YWluZXI7XHJcblxyXG4vKipcclxuICogQHByaXZhdGVcclxuICogT2JqZWN0IHRoYXQgaXMgdGhlIGxlYWYgb2YgdGhlIHpvbmVzIHRyZWVcclxuICogQGNsYXNzXHJcbiAqIEBwYXJhbSB7Tm9kZVpvbmVbXX0gem9uZXMgLSBBcnJheSBvZiB6b25uZXMgZm9yIGNvbnRhaW5pbmdcclxuICogQHByb3BlcnR5IHtOb2RlWm9uZVtdfSB6b25lcyAtIEFycmF5IG9mIHpvbm5lc1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIEdyb3VwT2Zab25lcyAoem9uZXMpIHtcclxuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xyXG5cclxuICAgIHNlbGYubW9kZWwgPSB7fTtcclxuICAgIHNlbGYuem9uZXMgPSB6b25lcztcclxuXHJcbiAgICBfY2FsY3VsYXRlQm91bmRzKCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQ2FsY3VsYXRlcyBib3VuZHMgb2YgdGhlIHRvdGFsIGFyZWEgb2YgY29udGFpbmVkIHpvbmVzLiBcclxuICAgICovXHJcbiAgICBmdW5jdGlvbiBfY2FsY3VsYXRlQm91bmRzICgpIHtcclxuICAgICAgICBsZXQgbWluWCA9IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgbWluWSA9IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgbWF4WCA9IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgbWF4WSA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgc2VsZi56b25lcy5mb3JFYWNoKHpvbmUgPT4ge1xyXG4gICAgICAgICAgICBtaW5YID0gKG1pblggPT09IHVuZGVmaW5lZCA/IHpvbmUubW9kZWwueCA6IE1hdGgubWluKG1pblgsIHpvbmUubW9kZWwueCkpO1xyXG4gICAgICAgICAgICBtaW5ZID0gKG1pblkgPT09IHVuZGVmaW5lZCA/IHpvbmUubW9kZWwueSA6IE1hdGgubWluKG1pblksIHpvbmUubW9kZWwueSkpO1xyXG4gICAgICAgICAgICBtYXhYID0gKG1heFggPT09IHVuZGVmaW5lZCA/IHpvbmUubW9kZWwueCArIHpvbmUubW9kZWwud2lkdGggOiBNYXRoLm1heChtYXhYLCB6b25lLm1vZGVsLnggKyB6b25lLm1vZGVsLndpZHRoKSk7XHJcbiAgICAgICAgICAgIG1heFkgPSAobWF4WSA9PT0gdW5kZWZpbmVkID8gem9uZS5tb2RlbC55ICsgem9uZS5tb2RlbC5oZWlnaHQgOiBNYXRoLm1heChtYXhZLCB6b25lLm1vZGVsLnkgKyB6b25lLm1vZGVsLmhlaWdodCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHNlbGYubW9kZWwueCA9IG1pblg7XHJcbiAgICAgICAgc2VsZi5tb2RlbC55ID0gbWluWTtcclxuICAgICAgICBzZWxmLm1vZGVsLndpZHRoID0gbWF4WCAtIG1pblg7XHJcbiAgICAgICAgc2VsZi5tb2RlbC5oZWlnaHQgPSBtYXhZIC0gbWluWTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlbGxzIHVzIHdoZXRoZXIgYSBwb2ludCBmYWxsIGludG8gdGhpcyBncm91cCBvZiB6b25lcyBvciBuby5cclxuICAgICAqIEBwYXJhbSB7UG9pbnR9IHBvaW50IC0gVGVzdGVkIHBvaW50XHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqIEBtZW1iZXJvZiBHcm91cE9mWm9uZXNcclxuICAgICAqIEBtZXRob2RcclxuICAgICovXHJcbiAgICBzZWxmLmhpdFRlc3QgPSBmdW5jdGlvbiAocG9pbnQpIHtcclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICBwb2ludC54ID49IHNlbGYubW9kZWwueCAmJlxyXG4gICAgICAgICAgICBwb2ludC54IDw9IHNlbGYubW9kZWwueCArIHNlbGYubW9kZWwud2lkdGggJiZcclxuICAgICAgICAgICAgcG9pbnQueSA+PSBzZWxmLm1vZGVsLnkgJiZcclxuICAgICAgICAgICAgcG9pbnQueSA8PSBzZWxmLm1vZGVsLnkgKyBzZWxmLm1vZGVsLmhlaWdodFxyXG4gICAgICAgICk7XHJcbiAgICB9O1xyXG59XHJcblxyXG4vKipcclxuICogQHByaXZhdGVcclxuICogT3B0aW9ucyBvZiBhIE5vZGVab25lXHJcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE5vZGVab25lT3B0aW9uc1xyXG4gKiBAcHJvcGVydHkge251bWJlcn0geCAtIFBvc2l0aW9uIGJ5IHggYXhpc1xyXG4gKiBAcHJvcGVydHkge251bWJlcn0geSAtIFBvc2l0aW9uIGJ5IHkgYXhpc1xyXG4gKiBAcHJvcGVydHkge251bWJlcn0gd2lkdGggLSBXaWR0aCBvZiB0aGUgcmVjdGFuZ2xlXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBoZWlnaHQgLSBIZWlnaHQgb2YgdGhlIHJlY3RhbmdsZVxyXG4gKiBAcHJvcGVydHkge0VsZW1lbnRTaXplfSBlbGVtZW50U2l6ZSAtIFNpemUgb2YgZWxlbWVudHMgb2YgdGhlIGdyYXBoXHJcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZmFrZVpvbmUgLSBJcyBpdCBmYWtlIHpvbmUgKGFic3RyYWN0IG9yIGRvbid0IGhhcyBwb3NpdGlvbilcclxuKi9cclxuXHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBPYmplY3QgdGhhdCBpcyB0aGUgbGVhZiBvZiB0aGUgdHJlZSBvZiB6b25lc1xyXG4gKiBAY2xhc3NcclxuICogQHBhcmFtIHtOb2RlW119IG5vZGVzIC0gTm9kZXMgb2YgdGhlIHpvbmUgKGNhbiBiZSB1bmRlZmluZWQpXHJcbiAqIEBwYXJhbSB7Tm9kZVpvbmVPcHRpb25zfSBwYXJhbWV0ZXJzIC0gUHJvcGVydGllcyBzZXRcclxuICogXHJcbiAqIEBwcm9wZXJ0eSB7Tm9kZVpvbmVPcHRpb25zfSBtb2RlbCAtIFByb3BlcnRpZXMgc2V0XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gTm9kZXNab25lIChub2RlcywgcGFyYW1ldGVycykge1xyXG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgc2VsZi5tb2RlbCA9IHBhcmFtZXRlcnM7XHJcbiAgICBzZWxmLm5vZGVzID0gbm9kZXMgfHwgW107XHJcbiAgICBzZWxmLnJlbGF0ZWROb2RlcyA9IFtdO1xyXG4gICAgc2VsZi5saW5rcyA9IFtdO1xyXG5cclxuICAgIGNvbnN0IF9lbGVtZW50U2l6ZSA9IHBhcmFtZXRlcnMuZWxlbWVudFNpemU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZWxscyB1cyB3aGV0aGVyIGEgTm9kZSBmYWxsIGludG8gdGhlIHpvbmUgb3Igbm8uXHJcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgLSBUZXN0ZWQgbm9kZVxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKiBAbWVtYmVyb2YgTm9kZXNab25lXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAqL1xyXG4gICAgc2VsZi5ub2RlSGl0VGVzdCA9IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgaWYgKHNlbGYubW9kZWwuZmFrZVpvbmUpIHJldHVybiB0cnVlO1xyXG4gICAgICAgIGNvbnN0IG5vZGVQb3NpdGlvbiA9IG5vZGUubW9kZWwucG9zaXRpb247XHJcblxyXG4gICAgICAgIGNvbnN0IHAxID0gbm9kZVBvc2l0aW9uO1xyXG4gICAgICAgIGNvbnN0IHAyID0geyB4OiBub2RlUG9zaXRpb24ueCArIF9lbGVtZW50U2l6ZS53aWR0aCwgeTogbm9kZVBvc2l0aW9uLnkgfTtcclxuICAgICAgICBjb25zdCBwMyA9IHsgeDogbm9kZVBvc2l0aW9uLngsIHk6IG5vZGVQb3NpdGlvbi55ICsgX2VsZW1lbnRTaXplLmhlaWdodCB9O1xyXG4gICAgICAgIGNvbnN0IHA0ID0geyB4OiBub2RlUG9zaXRpb24ueCArIF9lbGVtZW50U2l6ZS53aWR0aCwgeTogbm9kZVBvc2l0aW9uLnkgKyBfZWxlbWVudFNpemUuaGVpZ2h0IH07XHJcblxyXG4gICAgICAgIHJldHVybiAoc2VsZi5oaXRUZXN0KHAxKSkgJiZcclxuICAgICAgICAgICAgICAgKHNlbGYuaGl0VGVzdChwMikpICYmXHJcbiAgICAgICAgICAgICAgIChzZWxmLmhpdFRlc3QocDMpKSAmJlxyXG4gICAgICAgICAgICAgICAoc2VsZi5oaXRUZXN0KHA0KSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVsbHMgdXMgd2hldGhlciBhIHBvaW50IGZhbGwgaW50byB0aGUgem9uZSBvciBuby5cclxuICAgICAqIEBwYXJhbSB7UG9pbnR9IHBvaW50IC0gVGVzdGVkIHBvaW50XHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqIEBtZW1iZXJvZiBOb2Rlc1pvbmVcclxuICAgICAqIEBtZXRob2RcclxuICAgICovXHJcbiAgICBzZWxmLmhpdFRlc3QgPSBmdW5jdGlvbiAocG9pbnQpIHtcclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICBzZWxmLm1vZGVsLmZha2Vab25lIHx8XHJcbiAgICAgICAgICAgIHBvaW50LnggPj0gc2VsZi5tb2RlbC54ICYmXHJcbiAgICAgICAgICAgIHBvaW50LnggPD0gc2VsZi5tb2RlbC54ICsgc2VsZi5tb2RlbC53aWR0aCAmJlxyXG4gICAgICAgICAgICBwb2ludC55ID49IHNlbGYubW9kZWwueSAmJlxyXG4gICAgICAgICAgICBwb2ludC55IDw9IHNlbGYubW9kZWwueSArIHNlbGYubW9kZWwuaGVpZ2h0XHJcbiAgICAgICAgKTtcclxuICAgIH07XHJcbn0iLCJleHBvcnQgY29uc3QgTEdfR1JPVVBfVFlQRV9JRCA9ICd0cS1sZy1ncm91cCc7XHJcblxyXG5leHBvcnQgY29uc3QgTk9ERV9NT0RFTF9GSUVMRFMgPSBbXHJcbiAgICAnaWQnLFxyXG4gICAgJ2xhYmVsJyxcclxuICAgICd2aWV3RnJhbWUnLFxyXG4gICAgJ3R5cGVJZCcsXHJcbiAgICAnYWN0aXZlUmVzb3VyY2UnLFxyXG4gICAgJ3Jlc291cmNlJyxcclxuICAgICdyZXNvdXJjZVR5cGUnLFxyXG4gICAgJ3Bvc2l0aW9uJyxcclxuICAgICdkZWZhdWx0UG9zaXRpb24nLFxyXG4gICAgJ2RhdGEnLFxyXG4gICAgJ29mZnNldCdcclxuXTtcclxuXHJcbmV4cG9ydCBjb25zdCBMSU5LX01PREVMX0ZJRUxEUyA9IFtcclxuICAgICdpZCcsXHJcbiAgICAnc291cmNlJyxcclxuICAgICd0YXJnZXQnLFxyXG4gICAgJ2xpbmtUeXBlJyxcclxuICAgICdncm91cCcsXHJcbiAgICAnZGF0YScsXHJcbl07XHJcblxyXG4vKipcclxuICogQHByaXZhdGVcclxuICpcclxuICogVGhlIGZ1bmN0aW9uIGZpbHRlcnMgdGhlIGRhdGEsIHNldHMgYXV0aG9yaXRpZXMgYW5kIGNvbGxhcHNlcyBsaW5rcy5cclxuICogQHBhcmFtIHtcclxuICogIG5vZGVzOiBOb2RlTW9kZWxbXSxcclxuICogIGxpbmtzOiBMaW5rTW9kZWxbXVxyXG4gKiB9IGRhdGFcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBwcm9jZXNzRGF0YSAoZGF0YSkge1xyXG4gICAgaWYgKCFkYXRhIHx8ICFkYXRhLm5vZGVzKSByZXR1cm47XHJcbiAgICBkYXRhLmxpbmtzID0gZGF0YS5saW5rcyB8fCBbXTtcclxuXHJcbiAgICBjb25zdCBub2RlTWFwID0ge307XHJcblxyXG4gICAgZGF0YS5ub2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xyXG4gICAgICAgIG5vZGVNYXBbbm9kZS5pZF0gPSBub2RlO1xyXG4gICAgICAgIG5vZGUucG9zaXRpb24gPSB7IHg6IDAsIHk6IDAgfTtcclxuICAgICAgICAvLyBleHRyYWN0aW5nIGFkZGl0aW9uYWwgZGF0YVxyXG4gICAgICAgIGNvbnN0IGRhdGEgPSB7fTtcclxuICAgICAgICBPYmplY3Qua2V5cyhub2RlKS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vdFBlcm1hbmVudEZpZWxkID0gTk9ERV9NT0RFTF9GSUVMRFMuaW5kZXhPZihrZXkpID09PSAtMTtcclxuICAgICAgICAgICAgaWYgKG5vdFBlcm1hbmVudEZpZWxkKSB7XHJcbiAgICAgICAgICAgICAgICBkYXRhW2tleV0gPSBub2RlW2tleV07XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgbm9kZVtrZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgbm9kZS5kYXRhID0gZGF0YTtcclxuICAgIH0pO1xyXG5cclxuXHJcbiAgICBjb25zdCBkZXN0aW5hdGlvbk1hcCA9IHt9O1xyXG4gICAgZGF0YS5saW5rcy5mb3JFYWNoKHJhd0xpbmsgPT4ge1xyXG4gICAgICAgIGlmIChub2RlTWFwW3Jhd0xpbmsuc291cmNlXSAmJiBub2RlTWFwW3Jhd0xpbmsudGFyZ2V0XSkge1xyXG4gICAgICAgICAgICBjb25zdCBsaW5rQ2FjaGVJZCA9IGdldENhY2hlSWQocmF3TGluayk7XHJcblxyXG4gICAgICAgICAgICBpZiAoZGVzdGluYXRpb25NYXBbbGlua0NhY2hlSWRdKSB7XHJcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbk1hcFtsaW5rQ2FjaGVJZF0gPSBncm91cChkZXN0aW5hdGlvbk1hcFtsaW5rQ2FjaGVJZF0sIHJhd0xpbmspO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb25NYXBbbGlua0NhY2hlSWRdID0gcmF3TGluaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICghbm9kZU1hcFtyYXdMaW5rLnNvdXJjZV0pIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignU291cmNlIG5vdCBmb3VuZCEgVGhlIGxpbmsgZnJvbSAnICsgcmF3TGluay5zb3VyY2UgKyAnIHRvICcgKyByYXdMaW5rLnRhcmdldCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1RhcmdldCBub3QgZm91bmQhIFRoZSBsaW5rIGZyb20gJyArIHJhd0xpbmsuc291cmNlICsgJyB0byAnICsgcmF3TGluay50YXJnZXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3Qgc291cmNlTWFwID0ge307XHJcbiAgICBjb25zdCB0YXJnZXRNYXAgPSB7fTtcclxuICAgIGNvbnN0IGxpbmtzID0gT2JqZWN0LmtleXMoZGVzdGluYXRpb25NYXApLm1hcChjYWNoZUlkID0+IHtcclxuICAgICAgICBjb25zdCBsaW5rID0gZGVzdGluYXRpb25NYXBbY2FjaGVJZF07XHJcbiAgICAgICAgT2JqZWN0LmtleXMobGluaykuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBub3RQZXJtYW5lbnRGaWVsZCA9IExJTktfTU9ERUxfRklFTERTLmluZGV4T2Yoa2V5KSA9PT0gLTE7XHJcbiAgICAgICAgICAgIGlmIChub3RQZXJtYW5lbnRGaWVsZCkge1xyXG4gICAgICAgICAgICAgICAgZGF0YVtrZXldID0gbGlua1trZXldO1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIGxpbmtba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpZiAoIXNvdXJjZU1hcFtsaW5rLnRhcmdldF0pIHNvdXJjZU1hcFtsaW5rLnRhcmdldF0gPSBbXTtcclxuICAgICAgICBzb3VyY2VNYXBbbGluay50YXJnZXRdLnB1c2gobGluayk7XHJcblxyXG4gICAgICAgIGlmICghdGFyZ2V0TWFwW2xpbmsuc291cmNlXSkgdGFyZ2V0TWFwW2xpbmsuc291cmNlXSA9IFtdO1xyXG4gICAgICAgIHRhcmdldE1hcFtsaW5rLnNvdXJjZV0ucHVzaChsaW5rKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGxpbms7XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG5vZGVzOiBPYmplY3Qua2V5cyhub2RlTWFwKS5tYXAoa2V5ID0+IG5vZGVNYXBba2V5XSksXHJcbiAgICAgICAgbGlua3M6IGxpbmtzLFxyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBnZXRDYWNoZUlkIChsaW5rKSB7XHJcbiAgICAgICAgcmV0dXJuIGBzb3VyY2U6KCR7bGluay5zb3VyY2V9KX4jfnRhcmdldDooJHtsaW5rLnRhcmdldH0pYDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBncm91cCAoZXhpc3RlZExpbmssIG5ld0xpbmspIHtcclxuICAgICAgICBjb25zdCBncm91cCA9IGV4aXN0ZWRMaW5rLmdyb3VwID8gZXhpc3RlZExpbmsgOiB7XHJcbiAgICAgICAgICAgIGlkOiBnZXRDYWNoZUlkKGV4aXN0ZWRMaW5rKSxcclxuICAgICAgICAgICAgc291cmNlOiBleGlzdGVkTGluay5zb3VyY2UsXHJcbiAgICAgICAgICAgIHRhcmdldDogZXhpc3RlZExpbmsudGFyZ2V0LFxyXG4gICAgICAgICAgICBsaW5rVHlwZTogTEdfR1JPVVBfVFlQRV9JRCwgLy8gZXhpc3RlZExpbmsubGlua1R5cGUsXHJcbiAgICAgICAgICAgIGdyb3VwOiBbZXhpc3RlZExpbmtdLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgZ3JvdXAuZ3JvdXAucHVzaChuZXdMaW5rKTtcclxuICAgICAgICAvLyBleHRyYWN0aW5nIGFkZGl0aW9uYWwgZGF0YVxyXG4gICAgICAgIHJldHVybiBncm91cDtcclxuICAgIH1cclxufVxyXG5leHBvcnQgZGVmYXVsdCBwcm9jZXNzRGF0YTtcclxuXHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKlxyXG4gKiBUaGUgZnVuY3Rpb24gZmlsdGVycyB0aGUgZGF0YSwgc2V0cyBhdXRob3JpdGllcyBhbmQgY29sbGFwc2VzIGxpbmtzLlxyXG4gKiBAcGFyYW0ge1xyXG4gKiAgbm9kZXM6IE5vZGVNb2RlbFtdLFxyXG4gKiAgbGlua3M6IExpbmtNb2RlbFtdXHJcbiAqIH0gZGF0YVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUFzcGVjdFJlbGF0aW9ucyAobm9kZXMpIHtcclxuICAgIGNvbnN0IGFzcGVjdE1hcCA9IHt9O1xyXG4gICAgbm9kZXMuZm9yRWFjaChub2RlID0+IHtcclxuICAgICAgICAvLyBjb21iaW5lIG5vZGVzIHdpdGggdGhlIHNhbWUgaWRcclxuICAgICAgICBjb25zdCBjbGVhcklkID0gbm9kZS5tb2RlbC5yZXNvdXJjZTtcclxuICAgICAgICBpZiAoY2xlYXJJZCkge1xyXG4gICAgICAgICAgICBpZiAoIWFzcGVjdE1hcFtjbGVhcklkXSkge1xyXG4gICAgICAgICAgICAgICAgYXNwZWN0TWFwW2NsZWFySWRdID0gW25vZGVdO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYXNwZWN0TWFwW2NsZWFySWRdLnB1c2gobm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5rZXlzKGFzcGVjdE1hcCkuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICAgIGlmIChhc3BlY3RNYXBba2V5XS5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgIGFzcGVjdE1hcFtrZXldLmZvckVhY2gobiA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IGFzcGVjdE1hcFtrZXldLmluZGV4T2Yobik7XHJcbiAgICAgICAgICAgICAgICBuLmFzcGVjdHMgPSBhc3BlY3RNYXBba2V5XS5zbGljZSgwLCBpbmRleClcclxuICAgICAgICAgICAgICAgICAgICAuY29uY2F0KGFzcGVjdE1hcFtrZXldLnNsaWNlKGluZGV4ICsgMSwgYXNwZWN0TWFwW2tleV0ubGVuZ3RoKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBEZWZhdWx0RGF0YVByb3ZpZGVyKHBhcmFtZXRlcnMpIHtcclxuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xyXG4gICAgaWYgKCFwYXJhbWV0ZXJzKSBwYXJhbWV0ZXJzID0ge307XHJcblxyXG4gICAgY29uc3QgX3NlcnZlclVSTCA9IHBhcmFtZXRlcnMuc2VydmVyVVJMIHx8ICcvYXBpL3RibC9zd3AnO1xyXG4gICAgY29uc3QgX2RlZmF1bHRMaW5lYWdlR3JhbVZpZXdDbGFzcyA9IHBhcmFtZXRlcnMubGdWaWV3Q2xhc3MgfHwgJ2h0dHA6Ly9lZGcudG9wYnJhaWQuc29sdXRpb25zL21vZGVsL0J1aWxkSlNPTmZvckxpbmVhZ2VNb2RlbExpbmVhZ2VHcmFtJztcclxuICAgIGNvbnN0IF92ZlZpZXdDbGFzcyA9IHBhcmFtZXRlcnMudmZWaWV3Q2xhc3MgfHwgJ2VkZzpnZXRWaWV3RnJhbWVzRm9yUmVzb3VyY2UnO1xyXG4gICAgY29uc3QgX2RtVmlld0NsYXNzID0gcGFyYW1ldGVycy5kbVZpZXdDbGFzcyB8fCAnZWRnOkRlcml2YXRpb25NYXBEYXRhU2VydmljZSc7XHJcbiAgICBjb25zdCBfdmNWaWV3Q2xhc3MgPSBwYXJhbWV0ZXJzLnZjVmlld0NsYXNzIHx8ICdlZGc6Z2V0TGluZWFnZUdyYW1EYXRhUHJvdmlkZXInO1xyXG5cclxuICAgIGNvbnN0IF9ncmFwaCA9IHBhcmFtZXRlcnMuZ3JhcGggfHwgJ3VuZGVmaW5lZCc7XHJcbiAgICBjb25zdCBfY29uZmlnR3JhcGggPSBwYXJhbWV0ZXJzLmNvbmZpZ0dyYXBoIHx8ICdodHRwOi8vZWRnLnRvcGJyYWlkbGl2ZS5vcmcvMS4wL2NvbmZpZy9kaWFncmFtcyc7XHJcbiAgICBjb25zdCBfYmFzZSA9IHBhcmFtZXRlcnMuYmFzZSB8fCAndW5kZWZpbmVkJztcclxuXHJcbiAgICBjb25zdCBfcmVhY2ggPSBwYXJhbWV0ZXJzLnJlYWNoO1xyXG4gICAgY29uc3QgX3JhbmdlID0gcGFyYW1ldGVycy5yYW5nZTtcclxuICAgIGNvbnN0IF9icmVhZHRoID0gcGFyYW1ldGVycy5icmVhZHRoO1xyXG4gICAgY29uc3QgX2RlcHRoID0gcGFyYW1ldGVycy5kZXB0aDtcclxuXHJcbiAgICBzZWxmLmZldGNoRGF0YSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIF9leGVjdXRRdWVyeShnZXRGZXRjaERhdGFVcmwoXHJcbiAgICAgICAgICAgIG9wdGlvbnMudGFyZ2V0Tm9kZUlkLFxyXG4gICAgICAgICAgICBvcHRpb25zLnZpZXdGcmFtZSxcclxuICAgICAgICAgICAgb3B0aW9ucy5saW5lYWdlR3JhbVZpZXdDbGFzcyxcclxuICAgICAgICAgICAgb3B0aW9ucy5kaWFncmFtVHlwZSxcclxuICAgICAgICAgICAgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ29mZnNldCcpID8gb3B0aW9ucy5vZmZzZXQgOiBudWxsKVxyXG4gICAgICAgICkpO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLmdldFZpZXdGcmFtZXMgPSBmdW5jdGlvbiAocmVzb3VyY2UpIHtcclxuICAgICAgICByZXR1cm4gX2V4ZWN1dFF1ZXJ5KGdldFZpZXdGcmFtZXNVcmwocmVzb3VyY2UpKTtcclxuICAgIH07XHJcblxyXG4gICAgc2VsZi5nZXRWaWV3Q2xhc3NGb3JSZXNvdXJjZSA9IGZ1bmN0aW9uIChyZXNvdXJjZSkge1xyXG4gICAgICAgIHJldHVybiBfZXhlY3V0UXVlcnkoZ2V0Vmlld0NsYXNzVXJsKHJlc291cmNlKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYucmVsYXRpb25JbmZvID0gZnVuY3Rpb24gKHJlbGF0aW9uKSB7XHJcbiAgICAgICBsZXQgc291cmNlUmVzb3VyY2UgPSByZWxhdGlvbi5zb3VyY2UucmVzb3VyY2U7XHJcblxyXG4gICAgICAgIGlmKHJlbGF0aW9uLnNvdXJjZS5oYXNPd25Qcm9wZXJ0eSgnYWN0aXZlUmVzb3VyY2UnKSl7XHJcbiAgICAgICAgICAgIHNvdXJjZVJlc291cmNlID0gcmVsYXRpb24uc291cmNlLmFjdGl2ZVJlc291cmNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IHRhcmdldFJlc291cmNlID0gcmVsYXRpb24udGFyZ2V0LnJlc291cmNlO1xyXG5cclxuICAgICAgICBpZihyZWxhdGlvbi50YXJnZXQuaGFzT3duUHJvcGVydHkoJ2FjdGl2ZVJlc291cmNlJykpe1xyXG4gICAgICAgICAgICB0YXJnZXRSZXNvdXJjZSA9IHJlbGF0aW9uLnRhcmdldC5hY3RpdmVSZXNvdXJjZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBfZXhlY3V0UXVlcnkoZ2V0RGVyaXZhdGlvbkRhdGFVcmwoXHJcbiAgICAgICAgICAgIHNvdXJjZVJlc291cmNlLFxyXG4gICAgICAgICAgICB0YXJnZXRSZXNvdXJjZSxcclxuICAgICAgICAgICAgcmVsYXRpb24ubGlua1R5cGVcclxuICAgICAgICApKTtcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0Vmlld0ZyYW1lc1VybCAocmVzb3VyY2UpIHtcclxuICAgICAgICByZXR1cm4gX3NlcnZlclVSTCArICc/JyArXHJcbiAgICAgICAgICAgICdfdmlld0NsYXNzPScgKyBfdmZWaWV3Q2xhc3MgKyAnJicgK1xyXG4gICAgICAgICAgICAnZ3JhcGg9JyArIF9ncmFwaCArICcmJyArXHJcbiAgICAgICAgICAgICdyZXNvdXJjZT0nICsgcmVzb3VyY2UgKyAnJicgK1xyXG4gICAgICAgICAgICAnY29uZmlnR3JhcGg9JyArIF9jb25maWdHcmFwaCArICcmJyArXHJcbiAgICAgICAgICAgICdfYmFzZT0nICsgX2Jhc2U7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0Vmlld0NsYXNzVXJsIChyZXNvdXJjZSkge1xyXG4gICAgICAgIHJldHVybiBfc2VydmVyVVJMICsgJz8nICtcclxuICAgICAgICAgICAgJ192aWV3Q2xhc3M9JyArIF92Y1ZpZXdDbGFzcyArICcmJyArXHJcbiAgICAgICAgICAgICdncmFwaD0nICsgX2dyYXBoICsgJyYnICtcclxuICAgICAgICAgICAgJ3Jlc291cmNlPScgKyByZXNvdXJjZSArICcmJyArXHJcbiAgICAgICAgICAgICdjb25maWdHcmFwaD0nICsgX2NvbmZpZ0dyYXBoICsgJyYnICtcclxuICAgICAgICAgICAgJ19iYXNlPScgKyBfYmFzZTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRGZXRjaERhdGFVcmwgKGZvY3VzTm9kZSwgdmlld0ZyYW1lLCBsaW5lYWdlR3JhbVZpZXdDbGFzcywgZGlhZ3JhbVR5cGUsIG9mZnNldCkge1xyXG4gICAgICAgIHZhciBkYXRhVXJsID0gX3NlcnZlclVSTCArICc/JyArXHJcbiAgICAgICAgICAgICdfdmlld0NsYXNzPScgKyAobGluZWFnZUdyYW1WaWV3Q2xhc3MgfHwgX2RlZmF1bHRMaW5lYWdlR3JhbVZpZXdDbGFzcykgKyAnJicgK1xyXG4gICAgICAgICAgICAnZ3JhcGg9JyArIF9ncmFwaCArICcmJyArXHJcbiAgICAgICAgICAgICdmb2N1c05vZGU9JyArIGVuY29kZVVSSUNvbXBvbmVudChmb2N1c05vZGUpICsgJyYnICtcclxuICAgICAgICAgICAgJ19iYXNlPScgKyBfYmFzZTtcclxuXHJcbiAgICAgICAgaWYgKHZpZXdGcmFtZSkge1xyXG4gICAgICAgICAgICBkYXRhVXJsICs9ICcmdmlld0ZyYW1lPScgKyB2aWV3RnJhbWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAob2Zmc2V0KSB7XHJcbiAgICAgICAgICAgIGRhdGFVcmwgKz0gJyZvZmZzZXQ9JyArIG9mZnNldDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChfcmVhY2gpIHtcclxuICAgICAgICAgICAgZGF0YVVybCArPSAnJnJlYWNoPScgKyBfcmVhY2g7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoX3JhbmdlKSB7XHJcbiAgICAgICAgICAgIGRhdGFVcmwgKz0gJyZyYW5nZT0nICsgX3JhbmdlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKF9icmVhZHRoKSB7XHJcbiAgICAgICAgICAgIGRhdGFVcmwgKz0gJyZicmVhZHRoPScgKyBfYnJlYWR0aDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChfZGVwdGgpIHtcclxuICAgICAgICAgICAgZGF0YVVybCArPSAnJmRlcHRoPScgKyBfZGVwdGg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZGlhZ3JhbVR5cGUpIHtcclxuICAgICAgICAgICAgZGF0YVVybCArPSAnJmRpYWdyYW1UeXBlPScgKyBkaWFncmFtVHlwZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBkYXRhVXJsO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIF9leGVjdXRRdWVyeSAodXJsKSB7XHJcbiAgICAgICAgcmV0dXJuIGZldGNoKHVybCwge1xyXG4gICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxyXG4gICAgICAgICAgICBjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJyxcclxuICAgICAgICAgICAgbW9kZTogJ2NvcnMnLFxyXG4gICAgICAgICAgICBjYWNoZTogJ2RlZmF1bHQnLFxyXG4gICAgICAgICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgICAgICAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24sIHRleHQvdHVydGxlJyxcclxuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vc3BhcnFsLXF1ZXJ5JyxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xyXG4gICAgICAgICAgICBpZiAocmVzcG9uc2Uub2spIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7IC8vIEFsc28gcG9zc2libGUgdG8gdXNlOiByZXNwb25zZS50ZXh0KCk7IC8vcmVzcG9uc2UudHlwZTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihyZXNwb25zZS5zdGF0dXNUZXh0KTtcclxuICAgICAgICAgICAgICAgIGVycm9yLnJlc3BvbnNlID0gcmVzcG9uc2U7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldERlcml2YXRpb25EYXRhVXJsIChsZWZ0Tm9kZSwgcmlnaHROb2RlLCBsaW5rVHlwZSkge1xyXG4gICAgICAgIGxldCBkYXRhVVJMID0gX3NlcnZlclVSTCArICc/JyArXHJcbiAgICAgICAgICAgICdfYmFzZT0nICsgX2Jhc2UgKyAnJicgK1xyXG4gICAgICAgICAgICAnX3ZpZXdDbGFzcz0nICsgX2RtVmlld0NsYXNzICsgJyYnICtcclxuICAgICAgICAgICAgJ2xlZnROb2RlPScgKyBsZWZ0Tm9kZSArICcmJyArXHJcbiAgICAgICAgICAgICdyaWdodE5vZGU9JyArIHJpZ2h0Tm9kZTtcclxuXHJcbiAgICAgICAgICAgIGlmKGxpbmtUeXBlKXtcclxuICAgICAgICAgICAgICBkYXRhVVJMICs9ICcmbGlua1R5cGU9JyArIGxpbmtUeXBlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZGF0YVVSTDtcclxuICAgIH1cclxufVxyXG5leHBvcnQgZGVmYXVsdCBEZWZhdWx0RGF0YVByb3ZpZGVyO1xyXG4iLCJpbXBvcnQgKiBhcyBfIGZyb20gJ2xvZGFzaCc7XHJcbmltcG9ydCAqIGFzIGltYWdlcyBmcm9tICcuL2Jhc2U2NEltYWdlcyc7XHJcblxyXG5leHBvcnQgY29uc3QgRkVFRF9QSVBFX1RZUEUgPSAnZmVlZHBpcGUnO1xyXG5cclxuZXhwb3J0IGNvbnN0IExHX0dST1VQX1RZUEVfSUQgPSAndHEtbGctZ3JvdXAnO1xyXG5cclxuZXhwb3J0IGNvbnN0IERFRkFVTFRfREVSSVZBVElPTl9NQVBfTElOS19TVFlMRSA9IHtcclxuICAgIGNzc0NsYXNzOiAnZGVyaXZhdGlvbi1saW5rJyxcclxuICAgIGxpbmVUeXBlOiAnc29saWQnLCAvLyAnZGFzaGVkJ1xyXG4gICAgY29sb3I6ICdibGFjaycsXHJcbiAgICB0ZXh0Q29sb3I6ICdibGFjaycsXHJcbiAgICB0ZXh0QmFja2dyb3VuZENvbG9yOiAnd2hpdGUnLCBcclxuICAgIHRoaWNrbmVzczogMixcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBERUZBVUxUX0xJTktfU1RZTEUgPSB7XHJcbiAgICBjc3NDbGFzczogJ2xpbmVhZ2UtZ3JhbS1saW5rJyxcclxuICAgIGxpbmVUeXBlOiAnc29saWQnLCAvLyAnZGFzaGVkJ1xyXG4gICAgY29sb3I6ICcjM2M0MjYwJyxcclxuICAgIHRvb2xCdXR0b246IHtcclxuICAgICAgICBpbWFnZTogaW1hZ2VzLkxJTktfT1BUSU9OUyxcclxuICAgICAgICB3aWR0aDogMzAsXHJcbiAgICAgICAgaGVpZ2h0OiAzMCxcclxuICAgICAgICBhbHdheXNWaXNpYmxlOiBmYWxzZSxcclxuICAgIH0sXHJcbiAgICB0aGlja25lc3M6IDIsXHJcbiAgICBoYXNBcnJvdzogdHJ1ZSxcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBERUZBVUxUX0dST1VQX0xJTktfU1RZTEUgPSB7XHJcbiAgICBjc3NDbGFzczogJ2xpbmVhZ2UtZ3JhbS1saW5rcy1ncm91cCcsXHJcbiAgICBsaW5lVHlwZTogJ3NvbGlkJywgLy8gJ2Rhc2hlZCdcclxuICAgIGNvbG9yOiAnIzNjNDI2MCcsXHJcbiAgICB0aGlja25lc3M6IDIsXHJcbiAgICBoYXNBcnJvdzogdHJ1ZSxcclxuICAgIHRvb2xCdXR0b246IHtcclxuICAgICAgICBhbHdheXNWaXNpYmxlOiB0cnVlLFxyXG4gICAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IEZFRURfUElQRV9MSU5LX1NUWUxFID0ge1xyXG4gICAgY3NzQ2xhc3M6ICdsaW5lYWdlLWdyYW0tZmVlZC1waXBlLWxpbmsnLFxyXG4gICAgbGluZVR5cGU6ICdzb2xpZCcsIC8vICdkYXNoZWQnXHJcbiAgICBjb2xvcjogJyMzYzQyNjAnLFxyXG4gICAgdG9vbEJ1dHRvbjoge1xyXG4gICAgICAgIGltYWdlOiBpbWFnZXMuRkVFRF9QSVBFLFxyXG4gICAgICAgIHdpZHRoOiAzMCxcclxuICAgICAgICBoZWlnaHQ6IDMwLFxyXG4gICAgICAgIGFsd2F5c1Zpc2libGU6IHRydWUsXHJcbiAgICB9LFxyXG4gICAgdGhpY2tuZXNzOiAzLFxyXG4gICAgaGFzQXJyb3c6IHRydWUsXHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gUmVzb3VyY2VQcm92aWRlciAoX3BhcmFtZXRlcnMpIHtcclxuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xyXG5cclxuICAgIHNlbGYuZ2V0TGlua1N0eWxlID0gX2dldExpbmtTdHlsZTtcclxuICAgIHNlbGYuZ2V0SW1hZ2UgPSBfZ2V0SW1hZ2U7XHJcbiAgICBzZWxmLmdldENvbG9yID0gX2dldENvbG9yO1xyXG4gICAgc2VsZi5nZXRJY29uID0gX2dldEljb247XHJcblxyXG4gICAgZnVuY3Rpb24gX2dldENvbG9yICh0eXBlKSB7XHJcbiAgICAgICAgaWYgKCF0eXBlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnd2hpdGUnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXR5cGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9wYXJhbWV0ZXJzLmNvbG9yc1snZGVmYXVsdCddO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfcGFyYW1ldGVycy5jb2xvcnNbdHlwZV0gfHwgX3BhcmFtZXRlcnMuY29sb3JzWydkZWZhdWx0J107XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIF9nZXRJbWFnZSAodHlwZSkge1xyXG4gICAgICAgIGlmICghdHlwZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gaW1hZ2VzLlVOS05PV19JTUFHRTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFfcGFyYW1ldGVycy5pbWFnZXNbdHlwZV0gJiYgdHlwZSA9PT0gJ2xpbmstb3B0aW9ucycgfHwgdHlwZSA9PT0gJ2RlZmF1bHQtbGluay1vcHRpb25zJykge1xyXG4gICAgICAgICAgICByZXR1cm4gaW1hZ2VzLkxJTktfT1BUSU9OUztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFfcGFyYW1ldGVycy5pbWFnZXNbdHlwZV0gJiYgdHlwZSA9PT0gJ2ZlZWQtcGlwZScgfHwgdHlwZSA9PT0gJ2RlZmF1bHQtZmVlZC1waXBlJykge1xyXG4gICAgICAgICAgICByZXR1cm4gaW1hZ2VzLkZFRURfUElQRTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIF9wYXJhbWV0ZXJzLnJlc291cmNlUGF0aCArIChcclxuICAgICAgICAgICAgX3BhcmFtZXRlcnMuaW1hZ2VzW3R5cGVdIHx8XHJcbiAgICAgICAgICAgIF9wYXJhbWV0ZXJzLmltYWdlc1sndW5rbm93biddIHx8XHJcbiAgICAgICAgICAgIGltYWdlcy5VTktOT1dfSU1BR0VcclxuICAgICAgICApO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfZ2V0TGlua1N0eWxlICh0eXBlKSB7XHJcbiAgICAgICAgY29uc3QgbGlua1N0eWxlcyA9IF9wYXJhbWV0ZXJzLmxpbmtTdHlsZXM7XHJcbiAgICAgICAgY29uc3QgZGVmYXVsdFN0eWxlID0gXy5jbG9uZURlZXAobGlua1N0eWxlc1snZGVmYXVsdC1saW5rLXN0eWxlJ10gfHwgREVGQVVMVF9MSU5LX1NUWUxFKTtcclxuXHJcbiAgICAgICAgbGV0IGxpbmtTdHlsZTtcclxuICAgICAgICBpZiAoIXR5cGUpIHtcclxuICAgICAgICAgICAgbGlua1N0eWxlID0gZGVmYXVsdFN0eWxlIHx8IGRlZmF1bHRTdHlsZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAobGlua1N0eWxlc1t0eXBlXSkge1xyXG4gICAgICAgICAgICAgICAgbGlua1N0eWxlID0gbGlua1N0eWxlc1t0eXBlXTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGxpbmtTdHlsZSA9IGRlZmF1bHRTdHlsZSB8fCBkZWZhdWx0U3R5bGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIF8ubWVyZ2UoZGVmYXVsdFN0eWxlLCBsaW5rU3R5bGUpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIF9nZXRJY29uICh0eXBlKSB7XHJcbiAgICAgICAgaWYgKCF0eXBlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiBfcGFyYW1ldGVycy5pY29uc1t0eXBlXTtcclxuXHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IFRRR3JhbVVJIGZyb20gJ3Zpc3VhbGl6YXRpb25zLWxpYnJhcnknO1xyXG5pbXBvcnQgeyBWaWV3RnJhbWVCdXR0b25zIH0gZnJvbSAnLi92aWV3RnJhbWVCdXR0b25zJztcclxuaW1wb3J0IE1hcCBmcm9tICcuL21hcCc7XHJcbmltcG9ydCBJbmZvUGFuZWwgZnJvbSAnLi9pbmZvUGFuZWwnO1xyXG5pbXBvcnQgT3B0aW9uc1BhbmVsIGZyb20gJy4vb3B0aW9uc1BhbmVsJztcclxuXHJcbi8qKlxyXG4gKiBQYXJhbWV0ZXJzIHNldCBmb3IgYSB7QGxpbmsgVG9vbGJhcn0uXHJcbiAqIEB0eXBlZGVmIHtPYmplY3R9IERlZmF1bHRVSU9wdGlvbnNcclxuICogQHByb3BlcnR5IHtIVE1MRWxlbWVudCB8IFN0cmluZ30gYmFzZUVsZW1lbnQgLSBSb290IEhUTUxFbGVtZW50XHJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsIExlZ2VuZERlc2NyaXB0b3I+fSBsZWdlbmRzXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuZWlnaGJvckdyYW1WaWV3Q2xhc3NcclxuICovXHJcblxyXG4vKipcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtEZWZhdWx0VUlPcHRpb25zfSBvcHRpb25zXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gRGVmYXVsdFVJIChvcHRpb25zKSB7XHJcbiAgICBjb25zdCBzZWxmID0gdGhpcztcclxuICAgIC8vIEluaXRpYWxpemF0aW9uXHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICBjb25zdCBfbGluZWFnZUdyYW0gPSBvcHRpb25zLmxpbmVhZ2VHcmFtO1xyXG4gICAgY29uc3QgbWFya3VwID0gYFxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJ0cS1sZy1kZWZhdWx0LXVzZXItdWlcIj5cclxuICAgICAgICAgICAgPGRpdiBpZD1cInRxTGdUb29sYmFyXCI+PC9kaXY+XHJcbiAgICAgICAgICAgIDxkaXYgaWQ9XCJ0cUxnTWluaU1hcFwiPjwvZGl2PlxyXG4gICAgICAgICAgICA8ZGl2IGlkPVwidHFMZ0luZm9QYW5lbFwiPjwvZGl2PlxyXG4gICAgICAgICAgICA8ZGl2IGlkPVwidHFMZ09wdGlvbnNQYW5lbFwiPjwvZGl2PlxyXG4gICAgICAgICAgICA8ZGl2IGlkPVwidHFMZ1NlYXJjaFBhbmVsXCI+PC9kaXY+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICBgO1xyXG5cclxuICAgIGxldCBfZWw7XHJcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuYmFzZUVsZW1lbnQgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgX2VsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQob3B0aW9ucy5iYXNlRWxlbWVudCk7XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLmJhc2VFbGVtZW50ID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIF9lbCA9IG9wdGlvbnMuYmFzZUVsZW1lbnQ7XHJcbiAgICB9XHJcbiAgICBpZiAoIV9lbCkgcmV0dXJuO1xyXG4gICAgX2VsLmlubmVySFRNTCA9IG1hcmt1cDtcclxuXHJcbiAgICBjb25zdCB0cUxnVG9vbGJhciA9IF9lbC5xdWVyeVNlbGVjdG9yKCcjdHFMZ1Rvb2xiYXInKTtcclxuICAgIGNvbnN0IHRxTGdNaW5pTWFwID0gX2VsLnF1ZXJ5U2VsZWN0b3IoJyN0cUxnTWluaU1hcCcpO1xyXG4gICAgY29uc3QgdHFMZ0luZm9QYW5lbCA9IF9lbC5xdWVyeVNlbGVjdG9yKCcjdHFMZ0luZm9QYW5lbCcpO1xyXG4gICAgY29uc3QgdHFMZ09wdGlvbnNQYW5lbCA9IF9lbC5xdWVyeVNlbGVjdG9yKCcjdHFMZ09wdGlvbnNQYW5lbCcpO1xyXG4gICAgY29uc3QgdHFMZ1NlYXJjaFBhbmVsID0gX2VsLnF1ZXJ5U2VsZWN0b3IoJyN0cUxnU2VhcmNoUGFuZWwnKTtcclxuXHJcbiAgICBsZXQgX3pvb21pbmcgPSBfbGluZWFnZUdyYW0uem9vbSgpO1xyXG4gICAgbGV0IF9leHBhbmRBbGwgPSB0cnVlO1xyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuICAgIGNvbnN0IF9jb2xvcmVkQnV0dG9ucyA9IG5ldyBWaWV3RnJhbWVCdXR0b25zKHtcclxuICAgICAgICBsaW5lYWdlR3JhbTogX2xpbmVhZ2VHcmFtXHJcbiAgICB9KTtcclxuICAgIGNvbnN0IF9zd2l0Y2hlciA9IG5ldyBUUUdyYW1VSS5Td2l0Y2hlcih7XHJcbiAgICAgICAgc3RhdGVzOiBbXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlkOiAnbGluZWFnZURpYWdyYW0nLFxyXG4gICAgICAgICAgICAgICAgbGFiZWw6ICdMaW5lYWdlIGRpYWdyYW0gdmlldycsXHJcbiAgICAgICAgICAgICAgICBpY29uOiAnZ2x5cGhpY29uIGdseXBoaWNvbi1tb2RhbC13aW5kb3cnLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZDogJ2JpcmRFeWUnLFxyXG4gICAgICAgICAgICAgICAgbGFiZWw6ICdCaXJkIGV5ZSB2aWV3JyxcclxuICAgICAgICAgICAgICAgIGljb246ICdnbHlwaGljb24gZ2x5cGhpY29uLWV5ZS1vcGVuJyxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICBdLFxyXG4gICAgICAgIHZlcnRpY2FsT3JpZW50YXRpb246IHRydWUsXHJcbiAgICB9KTtcclxuXHJcbiAgICBfc3dpdGNoZXIub24oJ3N0YXRlLWNoYW5nZWQnLCB0YWJJZCA9PiB7XHJcbiAgICAgICAgX2xpbmVhZ2VHcmFtLnNldEN1cnJlbnRWaWV3KHRhYklkKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IF90b29sYmFyID0gbmV3IFRRR3JhbVVJLlRvb2xiYXIoe1xyXG4gICAgICAgIGJhc2VFbGVtZW50OiB0cUxnVG9vbGJhcixcclxuICAgICAgICB0b29sczogW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZDogJ3RxTGdTZWFyY2gnLFxyXG4gICAgICAgICAgICAgICAgaWNvbjogJ2dseXBoaWNvbiBnbHlwaGljb24tc2VhcmNoJyxcclxuICAgICAgICAgICAgICAgIGxhYmVsOiAnU2VhcmNoJyxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWQ6ICd0cUxnWm9vbUluJyxcclxuICAgICAgICAgICAgICAgIGljb246ICdnbHlwaGljb24gZ2x5cGhpY29uLXpvb20taW4nLFxyXG4gICAgICAgICAgICAgICAgbGFiZWw6ICdab29tIGluJyxcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3pvb21pbmcgPSBfbGluZWFnZUdyYW0uem9vbUluKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgX3Rvb2xiYXIucm9vdEh0bWwucXVlcnlTZWxlY3RvcignI3RxTGdab29tSW4nKS5kaXNhYmxlZCA9IChfem9vbWluZy5jdXIgPT09IF96b29taW5nLm1heCk7XHJcbiAgICAgICAgICAgICAgICAgICAgX3Rvb2xiYXIucm9vdEh0bWwucXVlcnlTZWxlY3RvcignI3RxTGdab29tT3V0JykuZGlzYWJsZWQgPSAoX3pvb21pbmcuY3VyID09PSBfem9vbWluZy5taW4pO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWQ6ICd0cUxnWm9vbU91dCcsXHJcbiAgICAgICAgICAgICAgICBpY29uOiAnZ2x5cGhpY29uIGdseXBoaWNvbi16b29tLW91dCcsXHJcbiAgICAgICAgICAgICAgICBsYWJlbDogJ1pvb20gb3V0JyxcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3pvb21pbmcgPSBfbGluZWFnZUdyYW0uem9vbU91dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF90b29sYmFyLnJvb3RIdG1sLnF1ZXJ5U2VsZWN0b3IoJyN0cUxnWm9vbUluJykuZGlzYWJsZWQgPSAoX3pvb21pbmcuY3VyID09PSBfem9vbWluZy5tYXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF90b29sYmFyLnJvb3RIdG1sLnF1ZXJ5U2VsZWN0b3IoJyN0cUxnWm9vbU91dCcpLmRpc2FibGVkID0gKF96b29taW5nLmN1ciA9PT0gX3pvb21pbmcubWluKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlkOiAndHFMZ1pvb21Ub0ZpdCcsXHJcbiAgICAgICAgICAgICAgICBpY29uOiAnZ2x5cGhpY29uIGdseXBoaWNvbi1mdWxsc2NyZWVuJyxcclxuICAgICAgICAgICAgICAgIGxhYmVsOiAnWm9vbSB0byBmaXQnLFxyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBfem9vbWluZyA9IF9saW5lYWdlR3JhbS56b29tVG9GaXQoKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlkOiAndHFMZ1Jlc2V0JyxcclxuICAgICAgICAgICAgICAgIGljb246ICdnbHlwaGljb24gZ2x5cGhpY29uLXJlZnJlc2gnLFxyXG4gICAgICAgICAgICAgICAgbGFiZWw6ICdSZXNldCBsYXlvdXQnLFxyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBfbGluZWFnZUdyYW0ucmVzZXRMYXlvdXQoKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlkOiAndHFMZ0dhdGhlcicsXHJcbiAgICAgICAgICAgICAgICBpY29uOiAnZ2x5cGhpY29uIGdseXBoaWNvbi1wdXNocGluJyxcclxuICAgICAgICAgICAgICAgIGxhYmVsOiAnR2F0aGVyIHJlbGF0aXZlcycsXHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjazogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF9saW5lYWdlR3JhbS5jb21iaW5lKCk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZDogJ2V4cGFuZEFsbCcsXHJcbiAgICAgICAgICAgICAgICBpY29uOiAnZ2x5cGhpY29uIGdseXBoaWNvbi1yZXNpemUtZnVsbCcsXHJcbiAgICAgICAgICAgICAgICBpY29uMjogJ2dseXBoaWNvbiBnbHlwaGljb24tcmVzaXplLXNtYWxsJyxcclxuICAgICAgICAgICAgICAgIGxhYmVsOiAnRXhwYW5kIGFsbCBub2RlcycsXHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjazogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfZXhwYW5kQWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9saW5lYWdlR3JhbS5leHBhbmRBbGxOb2RlcygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9saW5lYWdlR3JhbS5jb2xsYXBzZUFsbE5vZGVzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIF9leHBhbmRBbGwgPSAhX2V4cGFuZEFsbDtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIF9jb2xvcmVkQnV0dG9ucyxcclxuICAgICAgICAgICAgX3N3aXRjaGVyLFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZDogJ2luZm9QYW5lbEJ0bicsXHJcbiAgICAgICAgICAgICAgICBpY29uOiAnZ2x5cGhpY29uIGdseXBoaWNvbi1pbmZvLXNpZ24nLFxyXG4gICAgICAgICAgICAgICAgbGFiZWw6ICdJbmZvIHBhbmVsJyxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWQ6ICd0cUxnT3B0aW9uc0J1dHRvbicsXHJcbiAgICAgICAgICAgICAgICBpY29uOiAnZ2x5cGhpY29uIGdseXBoaWNvbi1tZW51LWhhbWJ1cmdlcicsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgXSxcclxuICAgIH0pO1xyXG4gICAgc2VsZi50b29sYmFyID0gX3Rvb2xiYXI7XHJcblxyXG4gICAgX2xpbmVhZ2VHcmFtLm9uKCdjdXJyZW50LXZpZXctY2hhbmdlZCcsICh2aWV3SWQpID0+IHtcclxuICAgICAgICBjb25zdCBkaXNhYmxlZCA9ICh2aWV3SWQgIT09ICdsaW5lYWdlRGlhZ3JhbScpO1xyXG4gICAgICAgIF9zd2l0Y2hlci5zZXRTdGF0ZSh2aWV3SWQpO1xyXG4gICAgICAgIF90b29sYmFyLnJvb3RIdG1sLnF1ZXJ5U2VsZWN0b3IoJyNleHBhbmRBbGwnKS5kaXNhYmxlZCA9IGRpc2FibGVkO1xyXG4gICAgICAgIF90b29sYmFyLnJvb3RIdG1sLnF1ZXJ5U2VsZWN0b3IoJyN0cUxnUmVzZXQnKS5kaXNhYmxlZCA9IGRpc2FibGVkO1xyXG4gICAgICAgIF90b29sYmFyLnJvb3RIdG1sLnF1ZXJ5U2VsZWN0b3IoJyN0cUxnWm9vbUluJykuZGlzYWJsZWQgPSBkaXNhYmxlZDtcclxuICAgICAgICBfdG9vbGJhci5yb290SHRtbC5xdWVyeVNlbGVjdG9yKCcjdHFMZ1pvb21PdXQnKS5kaXNhYmxlZCA9IGRpc2FibGVkO1xyXG4gICAgICAgIF90b29sYmFyLnJvb3RIdG1sLnF1ZXJ5U2VsZWN0b3IoJyN0cUxnWm9vbVRvRml0JykuZGlzYWJsZWQgPSBkaXNhYmxlZDtcclxuICAgIH0pO1xyXG5cclxuICAgIG5ldyBUUUdyYW1VSS5TZWFyY2hQYW5lbCh7XHJcbiAgICAgICAgYmFzZUVsZW1lbnQ6IHRxTGdTZWFyY2hQYW5lbCxcclxuICAgICAgICB0cmlnZ2VyQnV0dG9uOiBfdG9vbGJhci5yb290SHRtbC5xdWVyeVNlbGVjdG9yKCcjdHFMZ1NlYXJjaCcpLFxyXG4gICAgICAgIGFjdGl2ZTogZmFsc2UsXHJcbiAgICB9KTtcclxuXHJcbiAgICBuZXcgSW5mb1BhbmVsKHtcclxuICAgICAgICBiYXNlRWxlbWVudDogdHFMZ0luZm9QYW5lbCxcclxuICAgICAgICBhY3RpdmU6IGZhbHNlLFxyXG4gICAgICAgIHRyaWdnZXJCdXR0b246IF90b29sYmFyLnJvb3RIdG1sLnF1ZXJ5U2VsZWN0b3IoJyNpbmZvUGFuZWxCdG4nKSxcclxuICAgICAgICBsaW5lYWdlR3JhbTogX2xpbmVhZ2VHcmFtXHJcbiAgICB9KTtcclxuXHJcbiAgICBuZXcgT3B0aW9uc1BhbmVsKHtcclxuICAgICAgICBsaW5lYWdlR3JhbTogX2xpbmVhZ2VHcmFtLFxyXG4gICAgICAgIGJhc2VFbGVtZW50OiB0cUxnT3B0aW9uc1BhbmVsLFxyXG4gICAgICAgIGFjdGl2ZTogZmFsc2UsXHJcbiAgICAgICAgdHJpZ2dlckJ1dHRvbjogX3Rvb2xiYXIucm9vdEh0bWwucXVlcnlTZWxlY3RvcignI3RxTGdPcHRpb25zQnV0dG9uJyksXHJcbiAgICAgICAgbGVnZW5kczogb3B0aW9ucy5sZWdlbmRzLFxyXG4gICAgICAgIG9uUHJlc3NIZWxwOiBvcHRpb25zLm9uUHJlc3NIZWxwLFxyXG4gICAgfSk7XHJcblxyXG4gICAgbmV3IE1hcCh7XHJcbiAgICAgICAgYmFzZUVsZW1lbnQ6IHRxTGdNaW5pTWFwLFxyXG4gICAgICAgIGFjdGl2ZTogZmFsc2UsXHJcbiAgICAgICAgbGluZWFnZUdyYW06IF9saW5lYWdlR3JhbSxcclxuICAgICAgICBwb3NpdGlvbjoge1xyXG4gICAgICAgICAgICB4OiAnY2FsYygxMDAlIC0gMjY1cHgpJyxcclxuICAgICAgICAgICAgeTogJ2NhbGMoMTAwJSAtIDI2NXB4KScsXHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG59XHJcbmV4cG9ydCBkZWZhdWx0IERlZmF1bHRVSTtcclxuIiwiaW1wb3J0IFRRR3JhbVVJIGZyb20gJ3Zpc3VhbGl6YXRpb25zLWxpYnJhcnknO1xyXG5pbXBvcnQgeyBETUluZm9QYW5lbCB9IGZyb20gJy4vZG1JbmZvUGFuZWwnO1xyXG5cclxuLyoqXHJcbiAqIFBhcmFtZXRlcnMgc2V0IGZvciBhIHtAbGluayBUb29sYmFyfS5cclxuICogQHR5cGVkZWYge09iamVjdH0gRGVmYXVsdFVJT3B0aW9uc1xyXG4gKiBAcHJvcGVydHkge0hUTUxFbGVtZW50IHwgU3RyaW5nfSBiYXNlRWxlbWVudCAtIFJvb3QgSFRNTEVsZW1lbnRcclxuICogQHByb3BlcnR5IHtPYmplY3QuPHN0cmluZywgTGVnZW5kRGVzY3JpcHRvcj59IGxlZ2VuZHNcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IG5laWdoYm9yR3JhbVZpZXdDbGFzc1xyXG4gKiBAcHJvcGVydHkge0Rlcml2YXRpb25NYXB9IGRlcml2YXRpb25NYXBcclxuICovXHJcblxyXG4vKipcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtEZWZhdWx0VUlPcHRpb25zfSBvcHRpb25zXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gRE1EZWZhdWx0VUkgKG9wdGlvbnMpIHtcclxuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xyXG4gICAgY29uc3QgX2Rlcml2YXRpb25NYXAgPSBvcHRpb25zLmRlcml2YXRpb25NYXA7XHJcbiAgICBjb25zdCBfYmFzZSA9IF9jcmVhdGVCYXNlKFxyXG4gICAgICAgIF9nZXRIdG1sRWxlbWVudChvcHRpb25zLmJhc2VFbGVtZW50KSxcclxuICAgICAgICBfZ2V0SHRtbEVsZW1lbnQob3B0aW9ucy5pbmZvUGFuZWwpLFxyXG4gICAgKTtcclxuICAgIGxldCBfZXhwYW5kQWxsID0gdHJ1ZTtcclxuICAgIGxldCBfZGlhZ3JhbUluZm8gPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgLy8gSW5pdGlhbGl6YXRpb25cclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG4gICAgbGV0IGJhc2VUb29scyA9IFtcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlkOiAndHFETVNlYXJjaCcsXHJcbiAgICAgICAgICAgIGljb246ICdnbHlwaGljb24gZ2x5cGhpY29uLXNlYXJjaCcsXHJcbiAgICAgICAgICAgIGxhYmVsOiAnU2VhcmNoJyxcclxuICAgICAgICAgICAgY2FsbGJhY2s6IF9vcGVuQ2xvc2VTZWFyY2hQYW5lbCxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWQ6ICd0cURNRXhwb3J0U1ZHJyxcclxuICAgICAgICAgICAgaWNvbjogJ3Rvb2wtYmFyLXN2Zy1pY29uJyxcclxuICAgICAgICAgICAgbGFiZWw6ICdFeHBvcnQgdG8gU1ZHJyxcclxuICAgICAgICAgICAgY2FsbGJhY2s6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIF9kZXJpdmF0aW9uTWFwLmV4cG9ydFRvU3ZnKCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlkOiAndHFETUV4cG9ydFBORycsXHJcbiAgICAgICAgICAgIGljb246ICd0b29sLWJhci1wbmctaWNvbicsXHJcbiAgICAgICAgICAgIGxhYmVsOiAnRXhwb3J0IHRvIFBORycsXHJcbiAgICAgICAgICAgIGNhbGxiYWNrOiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBfZGVyaXZhdGlvbk1hcC5leHBvcnRUb1BuZygpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZDogJ3RxUHJpbnQnLFxyXG4gICAgICAgICAgICBpY29uOiAnZ2x5cGhpY29uIGdseXBoaWNvbi1wcmludCcsXHJcbiAgICAgICAgICAgIGxhYmVsOiAnUHJpbnQnLFxyXG4gICAgICAgICAgICBjYWxsYmFjazogKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgX2Rlcml2YXRpb25NYXAucHJpbnQoKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWQ6ICd0cURNWm9vbUluJyxcclxuICAgICAgICAgICAgaWNvbjogJ2dseXBoaWNvbiBnbHlwaGljb24tem9vbS1pbicsXHJcbiAgICAgICAgICAgIGxhYmVsOiAnWm9vbSBpbicsXHJcbiAgICAgICAgICAgIGNhbGxiYWNrOiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBfZGVyaXZhdGlvbk1hcC56b29tSW4oKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWQ6ICd0cURNWm9vbU91dCcsXHJcbiAgICAgICAgICAgIGljb246ICdnbHlwaGljb24gZ2x5cGhpY29uLXpvb20tb3V0JyxcclxuICAgICAgICAgICAgbGFiZWw6ICdab29tIG91dCcsXHJcbiAgICAgICAgICAgIGNhbGxiYWNrOiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBfZGVyaXZhdGlvbk1hcC56b29tT3V0KCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlkOiAndHFETVpvb21Ub0ZpdCcsXHJcbiAgICAgICAgICAgIGljb246ICdnbHlwaGljb24gZ2x5cGhpY29uLWZ1bGxzY3JlZW4nLFxyXG4gICAgICAgICAgICBsYWJlbDogJ1pvb20gdG8gZml0JyxcclxuICAgICAgICAgICAgY2FsbGJhY2s6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIF9kZXJpdmF0aW9uTWFwLnpvb21Ub0ZpdCgpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZDogJ2luZm9QYW5lbEJ0bicsXHJcbiAgICAgICAgICAgIGljb246ICdnbHlwaGljb24gZ2x5cGhpY29uLWluZm8tc2lnbicsXHJcbiAgICAgICAgICAgIGxhYmVsOiAnT3BlbiBJbmZvIHBhbmVsJyxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWQ6ICdleHBhbmRBbGwnLFxyXG4gICAgICAgICAgICBpY29uOiAnZ2x5cGhpY29uIGdseXBoaWNvbi1yZXNpemUtZnVsbCcsXHJcbiAgICAgICAgICAgIGljb24yOiAnZ2x5cGhpY29uIGdseXBoaWNvbi1yZXNpemUtc21hbGwnLFxyXG4gICAgICAgICAgICBsYWJlbDogJ0V4cGFuZCBhbGwnLFxyXG4gICAgICAgICAgICBjYWxsYmFjazogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKF9leHBhbmRBbGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBfZGVyaXZhdGlvbk1hcC5leHBhbmRBbGxFbGVtZW50cygpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBfZGVyaXZhdGlvbk1hcC5jb2xsYXBzZUFsbEVsZW1lbnRzKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBfZXhwYW5kQWxsID0gIV9leHBhbmRBbGw7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfSxcclxuICAgIF07XHJcblxyXG4gICAgaWYgKG9wdGlvbnMudG9vbHMpIHtcclxuICAgICAgICBvcHRpb25zLnRvb2xzLmZvckVhY2goKHRvb2wpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRvb2wucG9zaXRpb24gPCBiYXNlVG9vbHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBiYXNlVG9vbHMuc3BsaWNlKHRvb2wucG9zaXRpb24sIDAsIHRvb2wpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYmFzZVRvb2xzLnB1c2godG9vbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBzZWxmLnRvb2xiYXIgPSBuZXcgVFFHcmFtVUkuVG9vbGJhcih7XHJcbiAgICAgICAgYmFzZUVsZW1lbnQ6IF9iYXNlLnRvb2xiYXIsXHJcbiAgICAgICAgdG9vbHM6IGJhc2VUb29sc1xyXG4gICAgfSk7XHJcblxyXG4gICAgc2VsZi5pbmZvUGFuZWwgPSBuZXcgRE1JbmZvUGFuZWwoe1xyXG4gICAgICAgIGJhc2VFbGVtZW50OiBfYmFzZS5pbmZvUGFuZWwsXHJcbiAgICAgICAgdHJpZ2dlckJ1dHRvbjogc2VsZi50b29sYmFyLnJvb3RIdG1sLnF1ZXJ5U2VsZWN0b3IoJyNpbmZvUGFuZWxCdG4nKVxyXG4gICAgfSk7XHJcblxyXG4gICAgc2VsZi5pbmZvUGFuZWwub24oJ3NpemUtY2hhbmdlZCcsICgpID0+IF9kZXJpdmF0aW9uTWFwLnJlc2V0Rm9jdXMoKSk7XHJcblxyXG4gICAgc2VsZi5pbmZvUGFuZWwub24oJ2VsZW1lbnQtY2xpY2snLCBlbGVtZW50SWQgPT4ge1xyXG4gICAgICAgIF9kZXJpdmF0aW9uTWFwLnNldFNlbGVjdGVkRWxlbWVudChlbGVtZW50SWQpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgX2Rlcml2YXRpb25NYXAub24oJ2RpYWdyYW0tc3RhdGUtY2hhbmdlZCcsIChzdGF0ZUlkKSA9PiB7XHJcbiAgICAgICAgaWYgKHN0YXRlSWQgPT09ICdjb21wbGV0ZWQnKSB7XHJcbiAgICAgICAgICAgIF9kaWFncmFtSW5mbyA9IF9kZXJpdmF0aW9uTWFwLmdldERpYWdyYW1JbmZvKCk7XHJcbiAgICAgICAgICAgIGlmIChfZGlhZ3JhbUluZm8gJiYgX2RpYWdyYW1JbmZvLnRpdGxlKSB7XHJcbiAgICAgICAgICAgICAgICBfYmFzZS5kaWFncmFtVGl0bGUuaW5uZXJUZXh0ID0gX2RpYWdyYW1JbmZvLnRpdGxlO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgX2Jhc2UuZGlhZ3JhbVRpdGxlLmlubmVyVGV4dCA9ICcnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuICAgIGxldCBzZWFyY2hQYW5lVmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgbGV0IGRlYm91bmNlID0gZmFsc2U7XHJcbiAgICBjb25zdCBzZWFyY2hCdXR0b24gPSBzZWxmLnRvb2xiYXIucm9vdEh0bWwucXVlcnlTZWxlY3RvcignI3RxRE1TZWFyY2gnKTtcclxuICAgIGNvbnN0IHNlYXJjaElucHV0ID0gX2Jhc2Uuc2VhcmNoUGFuZWwucXVlcnlTZWxlY3RvcignaW5wdXQnKTtcclxuICAgIHNlYXJjaElucHV0Lm9ua2V5dXAgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKGRlYm91bmNlKSBjbGVhclRpbWVvdXQoZGVib3VuY2UpO1xyXG5cclxuICAgICAgICBkZWJvdW5jZSA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBzZWFyY2hLZXkgPSBzZWFyY2hJbnB1dC52YWx1ZTtcclxuICAgICAgICAgICAgX2Rlcml2YXRpb25NYXAuc2V0U2VhcmNoS2V5KHNlYXJjaEtleSk7XHJcbiAgICAgICAgfSwgMzAwKTtcclxuICAgIH07XHJcbiAgICBmdW5jdGlvbiBfb3BlbkNsb3NlU2VhcmNoUGFuZWwgKCkge1xyXG4gICAgICAgIGlmIChzZWFyY2hQYW5lVmlzaWJsZSkge1xyXG4gICAgICAgICAgICBfZGVyaXZhdGlvbk1hcC5zZXRTZWFyY2hLZXkodW5kZWZpbmVkKTtcclxuICAgICAgICAgICAgX2Jhc2Uuc2VhcmNoUGFuZWwuY2xhc3NMaXN0LmFkZCgndHEtZG0taGlkZGVuJyk7XHJcbiAgICAgICAgICAgIHNlYXJjaEJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKCd0cS11aS1zZWxlY3RlZCcpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIF9kZXJpdmF0aW9uTWFwLnNldFNlYXJjaEtleShzZWFyY2hJbnB1dC52YWx1ZSk7XHJcbiAgICAgICAgICAgIF9iYXNlLnNlYXJjaFBhbmVsLmNsYXNzTGlzdC5yZW1vdmUoJ3RxLWRtLWhpZGRlbicpO1xyXG4gICAgICAgICAgICBzZWFyY2hCdXR0b24uY2xhc3NMaXN0LmFkZCgndHEtdWktc2VsZWN0ZWQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2VhcmNoUGFuZVZpc2libGUgPSAhc2VhcmNoUGFuZVZpc2libGU7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX2dldEh0bWxFbGVtZW50IChiYXNlRWxlbWVudCkge1xyXG4gICAgICAgIGxldCBiYXNlSHRtbDtcclxuICAgICAgICBpZiAodHlwZW9mIGJhc2VFbGVtZW50ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBiYXNlSHRtbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGJhc2VFbGVtZW50KTtcclxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBiYXNlRWxlbWVudCA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgYmFzZUh0bWwgPSBiYXNlRWxlbWVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFiYXNlSHRtbCkgdGhyb3cgbmV3IEVycm9yKCdCYXNlIGVsZW1lbnQgaXMgbm90IGZvdW5kIScpO1xyXG4gICAgICAgIHJldHVybiBiYXNlSHRtbDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgaHRtbCBtYXJrdXAuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gaHRtbE5vZGUgLSBSb290IG5vZGUgZm9yIG1hcmt1cFxyXG4gICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCBIVE1MRWxlbWVudD59IC0gTWFwIG9mIGh0bWwgZWxlbWVudHNcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gX2NyZWF0ZUJhc2UgKGh0bWxOb2RlLCBpbmZvUGFuZWwpIHtcclxuICAgICAgICBodG1sTm9kZS5pbm5lckhUTUwgPSAnJztcclxuICAgICAgICBodG1sTm9kZS50YWJJbmRleCA9IDE7XHJcblxyXG4gICAgICAgIGNvbnN0IHRvb2xiYXJCYXNlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7XHJcbiAgICAgICAgdG9vbGJhckJhc2UuY2xhc3NOYW1lID0gJ3RxLWRlcml2YXRpb24tbWFwX190b29sYmFyJztcclxuICAgICAgICB0b29sYmFyQmFzZS5pZCA9ICd0cS1kZXJpdmF0aW9uLW1hcC10b29sYmFyJztcclxuICAgICAgICBodG1sTm9kZS5hcHBlbmRDaGlsZCh0b29sYmFyQmFzZSk7XHJcblxyXG4gICAgICAgIGNvbnN0IGRpYWdyYW1UaXRsZUNvbnRhaW50ZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTtcclxuICAgICAgICBkaWFncmFtVGl0bGVDb250YWludGVyLmNsYXNzTmFtZSA9ICd0cS1kZXJpdmF0aW9uLW1hcF9jb250YWluZXInO1xyXG4gICAgICAgIGNvbnN0IGRpYWdyYW1UaXRsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO1xyXG4gICAgICAgIGRpYWdyYW1UaXRsZS5jbGFzc05hbWUgPSAndHEtZGVyaXZhdGlvbi1tYXBfY29udGFpbmVyX190aXRsZSc7XHJcbiAgICAgICAgZGlhZ3JhbVRpdGxlLmlubmVyVGV4dCA9ICcnO1xyXG4gICAgICAgIGRpYWdyYW1UaXRsZUNvbnRhaW50ZXIuYXBwZW5kQ2hpbGQoZGlhZ3JhbVRpdGxlKTtcclxuICAgICAgICBodG1sTm9kZS5hcHBlbmRDaGlsZChkaWFncmFtVGl0bGVDb250YWludGVyKTtcclxuXHJcbiAgICAgICAgY29uc3Qgc2VhcmNoUGFuZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTtcclxuICAgICAgICBzZWFyY2hQYW5lbC5jbGFzc05hbWUgPSAndHEtZGVyaXZhdGlvbi1tYXBfc2VhcmNoLXBhbmUgdHEtZG0taGlkZGVuJztcclxuICAgICAgICBzZWFyY2hQYW5lbC5pbm5lckhUTUwgPSBgXHJcbiAgICAgICAgICAgIDxpbnB1dFxyXG4gICAgICAgICAgICAgICAgaWQ9XCJ0cS1kbS1zZWFyY2gtcGFuZVwiXHJcbiAgICAgICAgICAgICAgICB0eXBlPVwidGV4dFwiXHJcbiAgICAgICAgICAgICAgICBjbGFzcz1cInRxLWRlcml2YXRpb24tbWFwX3NlYXJjaC1wYW5lX19pbnB1dFwiPlxyXG4gICAgICAgICAgICA8L2lucHV0PlxyXG4gICAgICAgIGA7XHJcbiAgICAgICAgaHRtbE5vZGUuYXBwZW5kQ2hpbGQoc2VhcmNoUGFuZWwpO1xyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBzZWFyY2hQYW5lbDogc2VhcmNoUGFuZWwsXHJcbiAgICAgICAgICAgIHJvb3RIdG1sOiBodG1sTm9kZSxcclxuICAgICAgICAgICAgaW5mb1BhbmVsOiBpbmZvUGFuZWwsXHJcbiAgICAgICAgICAgIHRvb2xiYXI6IHRvb2xiYXJCYXNlLFxyXG4gICAgICAgICAgICBkaWFncmFtVGl0bGU6IGRpYWdyYW1UaXRsZSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBkZWZhdWx0IERNRGVmYXVsdFVJO1xyXG4iLCJpbXBvcnQgU3Vic2NyaWJhYmxlIGZyb20gJy4uL3N1YnNjcmlwdGlvbkFQSS9zdWJzY3JpYmVhYmxlJztcbmltcG9ydCB7IExpbmssIE5vZGUgfSBmcm9tICcuLi9qb2ludFZpZXdzL2Rlcml2YXRpb25NYXAvbWFwRWxlbWVudHMnO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBUaGUgZGF0YSBtb2RlbCBmb3IgYSB7QGxpbmsgRE1JbmZvUGFuZWx9IG9iamVjdC5cbiAqIEB0eXBlZGVmIHtPYmplY3R9IERNSW5mb1BhbmVsTW9kZWxcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfEhUTUxFbGVtZW50fSBiYXNlRWxlbWVudCAtIFJvb3QgZm9yIHRoaXMgcGFuZWxcbiAqIEBwcm9wZXJ0eSB7TGluZWFnZUdyYW19IGRlcml2YXRpb25NYXAgLSBEZXJpdmF0aW9uTWFwIG9iamVjdC5cbiAqL1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7RE1JbmZvUGFuZWxNb2RlbH0gLSBEYXRhIG1vZGVsLlxuICogQGZpcmVzIHNpemUtY2hhbmdlZFxuICogQGZpcmVzIGVsZW1lbnQtY2xpY2sgKGlkOnN0cmluZylcbiovXG5leHBvcnQgZnVuY3Rpb24gRE1JbmZvUGFuZWwgKHBhcmFtZXRlcnMpIHtcbiAgICBTdWJzY3JpYmFibGUuYXBwbHkodGhpcyk7ICAgLy8gbWFrZSB0aGlzIGNsYXNzIFN1YnNjcmliYWJsZVxuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG4gICAgaWYgKCFwYXJhbWV0ZXJzKSBwYXJhbWV0ZXJzID0ge307XG5cbiAgICBsZXQgX3NlbGVjdGVkRWxlbWVudCA9IHBhcmFtZXRlcnMuc2VsZWN0ZWRFbGVtZW50O1xuICAgIGxldCBfd2lkdGggPSAyNTA7XG4gICAgbGV0IF9oaWRkZW4gPSB0cnVlO1xuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIHNlbGYucm9vdEh0bWwgPSBfZ2V0RWxlbWVudChwYXJhbWV0ZXJzLmJhc2VFbGVtZW50KTtcblxuICAgIGNvbnN0IF9jb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTtcbiAgICBfY29udGFpbmVyLmNsYXNzTmFtZSA9ICd0cS1sZy1kbS1wcm9wZXJ0eS1wYW5lLWNvbnRhaW5lcic7XG4gICAgc2VsZi5yb290SHRtbC5hcHBlbmRDaGlsZChfY29udGFpbmVyKTtcblxuICAgIGNvbnN0IF90cmlnZ2VyQnV0dG9uID0gcGFyYW1ldGVycy50cmlnZ2VyQnV0dG9uO1xuICAgIF90cmlnZ2VyQnV0dG9uLm9uY2xpY2sgPSAoKSA9PiB7XG4gICAgICAgIGlmIChfaGlkZGVuKSB7XG4gICAgICAgICAgICBfc2hvdygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX2hpZGUoKTtcbiAgICAgICAgfVxuICAgIH07XG5cblxuICAgIGNvbnN0IF9zbGlkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTtcbiAgICBfc2xpZGVyLmNsYXNzTmFtZSA9ICd0cS1sZy1kbS1zbGlkZXInO1xuICAgIF9zbGlkZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgKGV2ZW50KSA9PiB7IF9vbk1vdXNlZG93bihldmVudCk7IH0pO1xuICAgIF9jb250YWluZXIuYXBwZW5kQ2hpbGQoX3NsaWRlcik7XG5cbiAgICBjb25zdCBfY2xvc2VCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTtcbiAgICBfY2xvc2VCdXR0b24uc2V0QXR0cmlidXRlKCd0aXRsZScsICdDbG9zZSBpbmZvIHBhbmVsJyk7XG4gICAgX2Nsb3NlQnV0dG9uLmNsYXNzTmFtZSA9ICd0cS1sZy1kbS1oaWRlLWJ1dHRvbic7XG4gICAgX2Nsb3NlQnV0dG9uLm9uY2xpY2sgPSAoKSA9PiB7IF9oaWRlKCk7IH07XG4gICAgX2NvbnRhaW5lci5hcHBlbmRDaGlsZChfY2xvc2VCdXR0b24pO1xuXG4gICAgc2VsZi5ib2R5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7XG4gICAgX2NvbnRhaW5lci5hcHBlbmRDaGlsZChzZWxmLmJvZHkpO1xuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIHNlbGYuaWQgPSAnZGVyaXZhdGlvbk1hcEluZm9QYW5lbCc7XG4gICAgc2VsZi5yZWRyYXcgPSBfcmVkcmF3O1xuICAgIHNlbGYuc2V0U2VsZWN0ZWRFbGVtZW50ID0gX3NldFNlbGVjdGVkRWxlbWVudDtcbiAgICBzZWxmLnNob3cgPSBfc2hvdztcbiAgICBzZWxmLmhpZGRlID0gX2hpZGU7XG4gICAgLy8gd2lkdGg6IDI1MHB4O1xuXG4gICAgX3JlZHJhdygpO1xuXG4gICAgZnVuY3Rpb24gX3JlZHJhdyAoKSB7XG4gICAgICAgIGlmIChfaGlkZGVuKSByZXR1cm47XG4gICAgICAgIGxldCBtYXJrdXA7XG4gICAgICAgIGlmIChfc2VsZWN0ZWRFbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAoX3NlbGVjdGVkRWxlbWVudCBpbnN0YW5jZW9mIE5vZGUpIHtcbiAgICAgICAgICAgICAgICBtYXJrdXAgPSBfZ2V0Tm9kZUluZm8oX3NlbGVjdGVkRWxlbWVudCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKF9zZWxlY3RlZEVsZW1lbnQgaW5zdGFuY2VvZiBMaW5rKSB7XG4gICAgICAgICAgICAgICAgbWFya3VwID0gX2dldExpbmtJbmZvKF9zZWxlY3RlZEVsZW1lbnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtYXJrdXAgPSBgXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0cS1sZy1kbS1wcm9wZXJ0eS1wYW5lIHRxLWxnLWRtLWVtcHR5XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2PlVua25vd24gdHlwZSBvZiBlbGVtZW50PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIGA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXJrdXAgPSBgXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRxLWxnLWRtLXByb3BlcnR5LXBhbmUgdHEtbGctZG0tZW1wdHlcIj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdj5TZWxlY3QgYSBkaWFncmFtIGVsZW1lbnQ8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIGA7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5ib2R5LnN0eWxlLndpZHRoID0gYCR7X3dpZHRofXB4YDtcbiAgICAgICAgc2VsZi5ib2R5LmlubmVySFRNTCA9IG1hcmt1cDtcblxuICAgICAgICBpZiAoX3NlbGVjdGVkRWxlbWVudCBpbnN0YW5jZW9mIE5vZGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuID0gc2VsZi5ib2R5LnF1ZXJ5U2VsZWN0b3JBbGwoJy50cS1sZy1kbS1jaGlsZC1idXR0b24nKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbltpXS5vbmNsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnRyaWdnZXIoJ2VsZW1lbnQtY2xpY2snLCB0aGlzLmlkKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiAoX3NlbGVjdGVkRWxlbWVudCBpbnN0YW5jZW9mIExpbmspIHtcbiAgICAgICAgICAgIHNlbGYuYm9keS5xdWVyeVNlbGVjdG9yKCcudHEtbGctZG0tc291cmNlLWJ1dHRvbicpLm9uY2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc2VsZi50cmlnZ2VyKCdlbGVtZW50LWNsaWNrJywgdGhpcy5pZCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgc2VsZi5ib2R5LnF1ZXJ5U2VsZWN0b3IoJy50cS1sZy1kbS10YXJnZXQtYnV0dG9uJykub25jbGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnRyaWdnZXIoJ2VsZW1lbnQtY2xpY2snLCB0aGlzLmlkKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLy4uLlxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2dldE5vZGVJbmZvIChub2RlKSB7XG4gICAgICAgIGNvbnN0IGNoaWxyZW4gPSBub2RlLmNoaWxkcmVuLm1hcChjaGlsZCA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYDxkaXZcbiAgICAgICAgICAgICAgICBpZD1cIiR7Y2hpbGQuaWR9XCJcbiAgICAgICAgICAgICAgICB0aXRsZT1cIiR7Y2hpbGQubGFiZWx9KCR7Y2hpbGQuZW5kcG9pbnRJZH0pXCJcbiAgICAgICAgICAgICAgICB0eXBlPVwidGV4dFwiXG4gICAgICAgICAgICAgICAgY2xhc3M9XCJ0cS11aS1wcm9wZXJ0eS1idXR0b24gdHEtbGctZG0tY2hpbGQtYnV0dG9uXCI+XG4gICAgICAgICAgICAgICAgJHtjaGlsZC5sYWJlbH1cbiAgICAgICAgICAgIDwvZGl2PmA7XG4gICAgICAgIH0pLmpvaW4oJycpO1xuICAgICAgICByZXR1cm4gYFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRxLWxnLWRtLXByb3BlcnR5LXBhbmVcIj5cbiAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJ0cS1sYWJlbFwiPklEPC9sYWJlbD5cbiAgICAgICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU9XCIke25vZGUuZW5kcG9pbnRJZH1cIlxuICAgICAgICAgICAgICAgICAgICB0aXRsZT1cIiR7bm9kZS5lbmRwb2ludElkfVwiIHR5cGU9XCJ0ZXh0XCIgIGNsYXNzPVwidHEtdWktcHJvcGVydHlcIiBkaXNhYmxlZD5cbiAgICAgICAgICAgICAgICA8L2lucHV0PlxuICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cInRxLWxhYmVsXCI+RGlhZ3JhbSBJRDwvbGFiZWw+XG4gICAgICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlPVwiJHtub2RlLmlkfVwiXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlPVwiJHtub2RlLmlkfVwiXG4gICAgICAgICAgICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJ0cS11aS1wcm9wZXJ0eVwiXG4gICAgICAgICAgICAgICAgICAgIGRpc2FibGVkPlxuICAgICAgICAgICAgICAgIDwvaW5wdXQ+XG4gICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVwidHEtbGFiZWxcIj5MYWJlbDwvbGFiZWw+XG4gICAgICAgICAgICAgICAgPGlucHV0IHZhbHVlPVwiJHtub2RlLmxhYmVsfVwiIHRpdGxlPVwiJHtub2RlLmxhYmVsfVwiIHR5cGU9XCJ0ZXh0XCIgY2xhc3M9XCJ0cS11aS1wcm9wZXJ0eVwiIGRpc2FibGVkPjwvaW5wdXQ+XG4gICAgICAgICAgICAgICAgJHtjaGlscmVuLmxlbmd0aCA+IDAgPyAnPGxhYmVsIGNsYXNzPVwidHEtbGFiZWxcIj5DaGlsZHJlbjwvbGFiZWw+JyA6ICcnfVxuICAgICAgICAgICAgICAgICR7Y2hpbHJlbn1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICBgO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9nZXRMaW5rSW5mbyAobGluaykge1xuICAgICAgICByZXR1cm4gYFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRxLWxnLWRtLXByb3BlcnR5LXBhbmVcIj5cbiAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJ0cS1sYWJlbFwiPkxhYmVsPC9sYWJlbD5cbiAgICAgICAgICAgICAgICA8aW5wdXQgdmFsdWU9XCIke2xpbmsubGFiZWx9XCIgdGl0bGU9XCIke2xpbmsubGFiZWx9XCIgdHlwZT1cInRleHRcIiBjbGFzcz1cInRxLXVpLXByb3BlcnR5XCIgZGlzYWJsZWQ+PC9pbnB1dD5cbiAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJ0cS1sYWJlbFwiPlNvdXJjZTwvbGFiZWw+XG4gICAgICAgICAgICAgICAgPGRpdiBpZD1cIiR7bGluay5zb3VyY2UuaWR9XCJcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU9XCIke2xpbmsuc291cmNlLmxhYmVsfSgke2xpbmsuc291cmNlLmVuZHBvaW50SWR9KVwiXG4gICAgICAgICAgICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJ0cS11aS1wcm9wZXJ0eS1idXR0b24gdHEtbGctZG0tc291cmNlLWJ1dHRvblwiPlxuICAgICAgICAgICAgICAgICAgICAke2xpbmsuc291cmNlLmxhYmVsfVxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cInRxLWxhYmVsXCI+VGFyZ2V0PC9sYWJlbD5cbiAgICAgICAgICAgICAgICA8ZGl2IGlkPVwiJHtsaW5rLnRhcmdldC5pZH1cIlxuICAgICAgICAgICAgICAgICAgICB0aXRsZT1cIiR7bGluay50YXJnZXQubGFiZWx9KCR7bGluay50YXJnZXQuZW5kcG9pbnRJZH0pXCJcbiAgICAgICAgICAgICAgICAgICAgdHlwZT1cInRleHRcIlxuICAgICAgICAgICAgICAgICAgICBjbGFzcz1cInRxLXVpLXByb3BlcnR5LWJ1dHRvbiB0cS1sZy1kbS10YXJnZXQtYnV0dG9uXCI+XG4gICAgICAgICAgICAgICAgICAgICR7bGluay50YXJnZXQubGFiZWx9XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgYDtcbiAgICB9XG5cbiAgICBjb25zdCBTRUxFQ1RFRF9DTEFTUyA9ICd0cS11aS1zZWxlY3RlZCc7XG4gICAgZnVuY3Rpb24gX3Nob3cgKCkge1xuICAgICAgICBfaGlkZGVuID0gZmFsc2U7XG4gICAgICAgIF9jb250YWluZXIuc3R5bGUuZGlzcGxheSA9IG51bGw7XG4gICAgICAgIF90cmlnZ2VyQnV0dG9uLmNsYXNzTGlzdC5hZGQoU0VMRUNURURfQ0xBU1MpO1xuICAgICAgICBfcmVkcmF3KCk7XG4gICAgICAgIHNldFRpbWVvdXQoKCk9PntcbiAgICAgICAgICAgIHNlbGYudHJpZ2dlcignc2l6ZS1jaGFuZ2VkJyk7XG4gICAgICAgIH0sIDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9oaWRlICgpIHtcbiAgICAgICAgX2hpZGRlbiA9IHRydWU7XG4gICAgICAgIF9jb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgX3RyaWdnZXJCdXR0b24uY2xhc3NMaXN0LnJlbW92ZShTRUxFQ1RFRF9DTEFTUyk7XG4gICAgICAgIHNldFRpbWVvdXQoKCk9PntcbiAgICAgICAgICAgIHNlbGYudHJpZ2dlcignc2l6ZS1jaGFuZ2VkJyk7XG4gICAgICAgIH0sIDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9vbk1vdXNlZG93biAoZXZlbnQpIHtcbiAgICAgICAgbGV0IHN0YXJ0WCA9IDA7XG4gICAgICAgIGNvbnN0IE1JTl9XSURUSCA9IDEwMDtcblxuICAgICAgICBpZiAoZXZlbnQucGFnZVgpIHN0YXJ0WCA9IGV2ZW50LnBhZ2VYO1xuICAgICAgICBlbHNlIGlmIChldmVudC5jbGllbnRYKSBzdGFydFggPSBldmVudC5jbGllbnRYO1xuXG4gICAgICAgIHdpbmRvdy5nZXRTZWxlY3Rpb24oKS5yZW1vdmVBbGxSYW5nZXMoKTtcblxuICAgICAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIF9vbmNoYW5nZSk7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIF9vbm1vdXNldXApO1xuXG4gICAgICAgIGZ1bmN0aW9uIF9vbmNoYW5nZSAoZXZlbnQpIHtcbiAgICAgICAgICAgIGxldCBlbmRYID0gMDtcblxuICAgICAgICAgICAgaWYgKGV2ZW50LnBhZ2VYKSBlbmRYID0gZXZlbnQucGFnZVg7XG4gICAgICAgICAgICBlbHNlIGlmIChldmVudC5jbGllbnRYKSBlbmRYID0gZXZlbnQuY2xpZW50WDtcblxuICAgICAgICAgICAgY29uc3QgZGlmZlggPSBzdGFydFggLSBlbmRYO1xuICAgICAgICAgICAgc3RhcnRYID0gZW5kWDtcblxuICAgICAgICAgICAgX3dpZHRoICs9IGRpZmZYO1xuICAgICAgICAgICAgX3dpZHRoID0gTWF0aC5tYXgoTUlOX1dJRFRILCBfd2lkdGgpO1xuICAgICAgICAgICAgc2VsZi50cmlnZ2VyKCdzaXplLWNoYW5nZWQnKTtcbiAgICAgICAgICAgIF9yZWRyYXcoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIF9vbm1vdXNldXAgKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5fbW91c2VNb3ZlKSB7XG4gICAgICAgICAgICAgICAgX29uY2hhbmdlKGV2ZW50LCB0cnVlKTtcbiAgICAgICAgICAgICAgICBzZWxmLl9tb3VzZU1vdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkub25tb3VzZW1vdmUgPSBkb2N1bWVudC5ib2R5Lm9ubW91c2V1cCA9IG51bGw7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIF9vbmNoYW5nZSk7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBfb25tb3VzZXVwKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX3NldFNlbGVjdGVkRWxlbWVudCAoZWxlbWVudCkge1xuICAgICAgICBfc2VsZWN0ZWRFbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgX3JlZHJhdygpO1xuICAgIH1cbn1cbmV4cG9ydCBkZWZhdWx0IERNSW5mb1BhbmVsO1xuXG5mdW5jdGlvbiBfZ2V0RWxlbWVudCAoZWwpIHtcbiAgICBsZXQgZWxlbWVudDtcbiAgICBpZiAodHlwZW9mIGVsID09PSAnc3RyaW5nJykge1xuICAgICAgICBlbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZWwpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVsID09PSAnb2JqZWN0Jykge1xuICAgICAgICBlbGVtZW50ID0gZWw7XG4gICAgfVxuICAgIHJldHVybiBlbGVtZW50O1xufVxuIiwiaW1wb3J0ICogYXMgXyBmcm9tICdsb2Rhc2gnO1xyXG5pbXBvcnQgVFFHcmFtVUkgZnJvbSAndmlzdWFsaXphdGlvbnMtbGlicmFyeSc7XHJcbmltcG9ydCBTdWJzY3JpYmFibGUgZnJvbSAnLi4vc3Vic2NyaXB0aW9uQVBJL3N1YnNjcmliZWFibGUnO1xyXG5cclxuLyoqXHJcbiAqIFRoZSBkYXRhIG1vZGVsIGZvciBhIHtAbGluayBJbmZvUGFuZWx9IG9iamVjdC5cclxuICogQHR5cGVkZWYge09iamVjdH0gSW5mb1BhbmVsTW9kZWxcclxuICogQHByb3BlcnR5IHtzdHJpbmd8SFRNTEVsZW1lbnR9IGJhc2VFbGVtZW50IC0gUm9vdCBmb3IgdGhpcyBwYW5lbFxyXG4gKiBAcHJvcGVydHkge0xpbmVhZ2VHcmFtfSBsaW5lYWdlR3JhbSAtIExpbmVhZ2VHcmFtIG9iamVjdC5cclxuICogQHByb3BlcnR5IHtib29sZWFufSBhY3RpdmUgLSBmYWxzZSAtIGNvbGxhcHNlZCwgdHJ1ZSAtIGV4cGFuZGVkXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfEhUTUxFbGVtZW50fSB0cmlnZ2VyQnV0dG9uXHJcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IG9uUHJlc3NFeHRlcm5hbFxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBDbGFzcyB3aGljaCBpcyBhIHNpbXBsZSBVSSBwYW5lbC5cclxuICogVGhpcyBwYW5lbCBjYW4gcmVwcmVzZW50IGFuIGluZm9ybWF0aW9uIGFib3V0IHNlbGVjdGVkIGVsZW1lbnRcclxuICogYW5kIGFsc28sIGl0IHN1cHBvcnRzIHNpbXBsZSBuYXZpZ2F0aW9uIGJldHdlZW4gZWxlbWVudHMuXHJcbiAqIEBjbGFzc1xyXG4gKiBAcGFyYW0ge0luZm9QYW5lbE1vZGVsfSBvcHRpb25zIC0gRGF0YSBtb2RlbC5cclxuICogQGZpcmVzIHN0YXRlLWNoYW5nZWRcclxuKi9cclxuZXhwb3J0IGZ1bmN0aW9uIEluZm9QYW5lbCAob3B0aW9ucykge1xyXG4gICAgU3Vic2NyaWJhYmxlLmFwcGx5KHRoaXMpOyAgIC8vIG1ha2UgdGhpcyBjbGFzcyBTdWJzY3JpYmFibGVcclxuXHJcbiAgICBjb25zdCBpbmZvVGVtcGxhdGUgPSBuZXcgVFFHcmFtVUkuSW5mb1BhbmVsKHtsYXVuY2hFeHRlcm5hbDpvcHRpb25zLmxpbmVhZ2VHcmFtLmxhdW5jaEV4dGVybmFsfSk7XHJcblxyXG4gICAgY29uc3QgX2xpbmVhZ2VHcmFtID0gb3B0aW9ucy5saW5lYWdlR3JhbTtcclxuXHJcbiAgICBUUUdyYW1VSS5GbHlpbmdQYW5lbC5hcHBseSh0aGlzLCBbe1xyXG4gICAgICAgIGJhc2VFbGVtZW50OiBvcHRpb25zLmJhc2VFbGVtZW50LFxyXG4gICAgICAgIGFjdGl2ZTogb3B0aW9ucy5hY3RpdmUsXHJcbiAgICAgICAgaGVhZGVyOiAnSW5mbyBwYW5lbCcsXHJcbiAgICAgICAgdHJpZ2dlckJ1dHRvbjogb3B0aW9ucy50cmlnZ2VyQnV0dG9uLFxyXG4gICAgICAgIGxhdW5jaEV4dGVybmFsOiBvcHRpb25zLm9uUHJlc3NFeHRlcm5hbCxcclxuICAgICAgICBlbXB0eUJvZHk6IGZhbHNlLFxyXG4gICAgICAgIHNpemU6IHsgd2lkdGg6ICczMDBweCcsIGhlaWdodDogJzQ1MHB4JyB9LFxyXG4gICAgICAgIGJvZHk6IGluZm9UZW1wbGF0ZSxcclxuICAgICAgICByZXNpemFibGU6IHRydWUsXHJcbiAgICB9XSk7XHJcblxyXG4gICAgX2xpbmVhZ2VHcmFtLm9uKCdzZWxlY3RlZC1lbGVtZW50LWNoYW5nZWQnLCBmdW5jdGlvbiAoZWxlbWVudE1vZGVsKSB7XHJcbiAgICAgICAgY29uc3QgZ3JhcGhNb2RlbCA9IF9saW5lYWdlR3JhbS5nZXRHcmFwaE1vZGVsKCk7XHJcbiAgICAgICAgY29uc3Qgbm9kZU1hcCA9IGdyYXBoTW9kZWwubWFwcy5ub2RlTWFwO1xyXG5cclxuICAgICAgICBpZiAoZWxlbWVudE1vZGVsKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IG5vZGVNYXBbZWxlbWVudE1vZGVsLnNvdXJjZV07XHJcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IG5vZGVNYXBbZWxlbWVudE1vZGVsLnRhcmdldF07XHJcblxyXG4gICAgICAgICAgICBsZXQgZGF0YTtcclxuICAgICAgICAgICAgaWYgKGVsZW1lbnRNb2RlbC5saW5rVHlwZSAmJiBlbGVtZW50TW9kZWwuZ3JvdXApIHtcclxuICAgICAgICAgICAgICAgIGRhdGEgPSB7fTtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnRNb2RlbC5ncm91cC5mb3JFYWNoKGVsID0+IGRhdGEgPSBfLm1lcmdlKGRhdGEsIGVsLmRhdGEpKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRhdGEgPSBfLmNsb25lRGVlcChlbGVtZW50TW9kZWwuZGF0YSkgfHwge307XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChlbGVtZW50TW9kZWwubGlua1R5cGUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50TW9kZWwubGlua1R5cGUgJiYgIWVsZW1lbnRNb2RlbC5ncm91cCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGFbJ0xpbmsgdHlwZSddID0gZWxlbWVudE1vZGVsLmxpbmtUeXBlO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0eXBlTWFwID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudE1vZGVsLmdyb3VwLmZvckVhY2goZWwgPT4gdHlwZU1hcFtlbC5saW5rVHlwZV0gPSBlbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHlwZXMgPSBPYmplY3Qua2V5cyh0eXBlTWFwKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZXMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhWydMaW5rIHR5cGUnXSA9IGVsZW1lbnRNb2RlbC5saW5rVHlwZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVsnR3JvdXBlZCB0eXBlcyddID0gdHlwZXMuam9pbignLCAnKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhWydMaW5rIHR5cGUnXSA9IHR5cGVzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBkYXRhWydJRHMnXSA9IGVsZW1lbnRNb2RlbC5ncm91cC5tYXAoZWwgPT4gZWwuaWQpLmpvaW4oJywgJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKGVsZW1lbnRNb2RlbC5hY3RpdmVSZXNvdXJjZSkgZGF0YVtcIkFjdGl2ZSBSZXNvdXJjZVwiXSA9IGRlY29kZVVSSUNvbXBvbmVudChlbGVtZW50TW9kZWwuYWN0aXZlUmVzb3VyY2UpO1xyXG4gICAgICAgICAgICBpZiAoZWxlbWVudE1vZGVsLm9mZnNldCkgZGF0YVsnT2Zmc2V0J10gPSBlbGVtZW50TW9kZWwub2Zmc2V0O1xyXG4gICAgICAgICAgICBpZiAoZWxlbWVudE1vZGVsLnZpZXdGcmFtZSkgZGF0YVsnVmlldyBmcmFtZSddID0gZWxlbWVudE1vZGVsLnZpZXdGcmFtZTtcclxuXHJcbiAgICAgICAgICAgIGluZm9UZW1wbGF0ZS5zZXRTZWxlY3RlZEVsZW1lbnQoe1xyXG4gICAgICAgICAgICAgICAgaWQ6IGVsZW1lbnRNb2RlbC5pZCxcclxuICAgICAgICAgICAgICAgIGxhYmVsOiBlbGVtZW50TW9kZWwubGFiZWwsXHJcbiAgICAgICAgICAgICAgICByZXNvdXJjZTogZWxlbWVudE1vZGVsLnJlc291cmNlLFxyXG4gICAgICAgICAgICAgICAgcmVzb3VyY2VUeXBlOiBlbGVtZW50TW9kZWwucmVzb3VyY2VUeXBlLFxyXG4gICAgICAgICAgICAgICAgZGlhZ3JhbVR5cGU6IGVsZW1lbnRNb2RlbC5kaWFncmFtVHlwZSxcclxuICAgICAgICAgICAgICAgIHR5cGVzOiBlbGVtZW50TW9kZWwudHlwZUlkLFxyXG4gICAgICAgICAgICAgICAgc291cmNlOiBzb3VyY2UgPyB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHNvdXJjZS5pZCxcclxuICAgICAgICAgICAgICAgICAgICBsYWJlbDogc291cmNlLmxhYmVsLFxyXG4gICAgICAgICAgICAgICAgfSA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0ID8ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlkOiB0YXJnZXQuaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6IHRhcmdldC5sYWJlbCxcclxuICAgICAgICAgICAgICAgIH0gOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxyXG4gICAgICAgICAgICAgICAgcmVsYXRpb25zOiBfZ2V0UmVsYXRpb25zKGVsZW1lbnRNb2RlbCwgZ3JhcGhNb2RlbCksXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGluZm9UZW1wbGF0ZS5zZXRTZWxlY3RlZEVsZW1lbnQodW5kZWZpbmVkKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBpbmZvVGVtcGxhdGUub24oJ3NlbGVjdGVkLWVsZW1lbnQtY2hhbmdlZCcsIGZ1bmN0aW9uIChlbGVtZW50SWQpIHtcclxuICAgICAgICBfbGluZWFnZUdyYW0uc2V0U2VsZWN0ZWRFbGVtZW50KGVsZW1lbnRJZCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBmdW5jdGlvbiBfZ2V0QXNwZWN0cyAoZWxlbWVudE1vZGVsLCBub2Rlcykge1xyXG4gICAgICAgIGNvbnN0IGFzcGVjdHMgPSBbXTtcclxuICAgICAgICBpZiAoZWxlbWVudE1vZGVsLnJlc291cmNlKSB7XHJcbiAgICAgICAgICAgIG5vZGVzLmZvckVhY2gobm9kZSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5yZXNvdXJjZSA9PT0gZWxlbWVudE1vZGVsLnJlc291cmNlKSBhc3BlY3RzLnB1c2gobm9kZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGFzcGVjdHMucHVzaChlbGVtZW50TW9kZWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXNwZWN0cztcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfZ2V0UmVsYXRpb25zIChlbGVtZW50TW9kZWwsIGdyYXBoTW9kZWwpIHtcclxuICAgICAgICBjb25zdCBzb3VyY2VNYXAgPSBncmFwaE1vZGVsLm1hcHMuc291cmNlTWFwO1xyXG4gICAgICAgIGNvbnN0IHRhcmdldE1hcCA9IGdyYXBoTW9kZWwubWFwcy50YXJnZXRNYXA7XHJcbiAgICAgICAgY29uc3Qgbm9kZU1hcCA9IGdyYXBoTW9kZWwubWFwcy5ub2RlTWFwO1xyXG5cclxuICAgICAgICBjb25zdCBpZHMgPSBfZ2V0QXNwZWN0cyhlbGVtZW50TW9kZWwsIGdyYXBoTW9kZWwubm9kZXMpLm1hcChhID0+IGEuaWQpO1xyXG5cclxuICAgICAgICBsZXQgc291cmNlcyA9IFtdO1xyXG4gICAgICAgIGxldCB0YXJnZXRzID0gW107XHJcbiAgICAgICAgaWRzLmZvckVhY2goaWQgPT4ge1xyXG4gICAgICAgICAgICBpZiAoc291cmNlTWFwW2lkXSkge1xyXG4gICAgICAgICAgICAgICAgc291cmNlcyA9IHNvdXJjZXMuY29uY2F0KHNvdXJjZU1hcFtpZF0ubWFwKGwgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBub2RlTWFwW2wuc291cmNlXTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogbm9kZS5pZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IG5vZGUubGFiZWwsXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGFyZ2V0TWFwW2lkXSkge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0cyA9IHRhcmdldHMuY29uY2F0KHRhcmdldE1hcFtpZF0ubWFwKGwgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBub2RlTWFwW2wudGFyZ2V0XTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogbm9kZS5pZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IG5vZGUubGFiZWwsXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpZiAoc291cmNlcyAmJiBzb3VyY2VzLmxlbmd0aCA+IDAgfHwgdGFyZ2V0cyAmJiB0YXJnZXRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGluY29taW5nczogc291cmNlcyxcclxuICAgICAgICAgICAgICAgIG91dGdvaW5nczogdGFyZ2V0cyxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbn1cclxuZXhwb3J0IGRlZmF1bHQgSW5mb1BhbmVsO1xyXG4iLCJpbXBvcnQgVFFHcmFtVUkgZnJvbSAndmlzdWFsaXphdGlvbnMtbGlicmFyeSc7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gTWFwIChvcHRpb25zKSB7XHJcbiAgICBjb25zdCBtYXJrdXAgPSBgXHJcbiAgICAgICAgPGRpdiBpZD1cIm1hcEJ1dHRvblwiIGNsYXNzPVwidHEtbGctbWFwXCI+XHJcbiAgICAgICAgICAgIDxzcGFuIHRpdGxlPVwiTWluaSBtYXBcIiBjbGFzcz1cInRxLWxnLWNvbGxhcHNlLXBhbmVsX2JvZHlfX2xhYmVsIGdseXBoaWNvbiBnbHlwaGljb24tcGljdHVyZVwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjwvc3Bhbj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8ZGl2IGlkPVwiYmFzZUVsZW1lbnRGb3JNYXBcIj48L2Rpdj5cclxuICAgIGA7XHJcbiAgICBjb25zdCBfbGluZWFnZUdyYW0gPSBvcHRpb25zLmxpbmVhZ2VHcmFtO1xyXG5cclxuICAgIGxldCBfZWw7XHJcblxyXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmJhc2VFbGVtZW50ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIF9lbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG9wdGlvbnMuYmFzZUVsZW1lbnQpO1xyXG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5iYXNlRWxlbWVudCA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICBfZWwgPSBvcHRpb25zLmJhc2VFbGVtZW50O1xyXG4gICAgfVxyXG4gICAgaWYgKCFfZWwpIHJldHVybjtcclxuXHJcbiAgICBfZWwuaW5uZXJIVE1MID0gbWFya3VwO1xyXG5cclxuXHJcbiAgICBjb25zdCBtYXBGbHlpbmdQYW5lbCA9IG5ldyBUUUdyYW1VSS5GbHlpbmdQYW5lbCh7XHJcbiAgICAgICAgYmFzZUVsZW1lbnQ6IF9lbC5xdWVyeVNlbGVjdG9yKCcjYmFzZUVsZW1lbnRGb3JNYXAnKSxcclxuICAgICAgICBhY3RpdmU6IG9wdGlvbnMuYWN0aXZlLFxyXG4gICAgICAgIGhlYWRlcjogJ01hcCcsXHJcbiAgICAgICAgdHJpZ2dlckJ1dHRvbjogX2VsLnF1ZXJ5U2VsZWN0b3IoJyNtYXBCdXR0b24nKSxcclxuICAgICAgICBlbXB0eUJvZHk6IGZhbHNlLFxyXG4gICAgICAgIHNpemU6IHsgd2lkdGg6ICcyNTBweCcsIGhlaWdodDogJzI1MHB4J30sXHJcbiAgICAgICAgcG9zaXRpb246IG9wdGlvbnMucG9zaXRpb24sXHJcbiAgICAgICAgYm9keTogJycsXHJcbiAgICAgICAgcmVzaXphYmxlOiB0cnVlLFxyXG4gICAgfSk7XHJcblxyXG4gICAgX2xpbmVhZ2VHcmFtLnNldFJvb3RIdG1sRm9yTWFwKG1hcEZseWluZ1BhbmVsLnJvb3RIdG1sLnF1ZXJ5U2VsZWN0b3IoJy50cS11aS1ib2R5X2NvbnRhaW5lcicpKTtcclxuICAgIFxyXG4gICAgbWFwRmx5aW5nUGFuZWwub24oJ3NpemUtY2hhbmdlZCcsICgpID0+IHtcclxuICAgICAgICBfbGluZWFnZUdyYW0ucmVmcmVzaCgnZ3JhcGhNYXAnKTtcclxuICAgIH0pO1xyXG59XHJcbmV4cG9ydCBkZWZhdWx0IE1hcDtcclxuIiwiaW1wb3J0IFN1YnNjcmliYWJsZSBmcm9tICcuLi9zdWJzY3JpcHRpb25BUEkvc3Vic2NyaWJlYWJsZSc7XHJcbmltcG9ydCBUUUdyYW1VSSBmcm9tICd2aXN1YWxpemF0aW9ucy1saWJyYXJ5JztcclxuXHJcbi8qKlxyXG4gKiBUaGUgZGF0YSBtb2RlbCBmb3IgYSB7QGxpbmsgT3B0aW9uc1BhbmVsfSBvYmplY3QuXHJcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNQYW5lbE1vZGVsXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfEhUTUxFbGVtZW50fSBiYXNlRWxlbWVudCAtIFJvb3QgZm9yIHRoaXMgcGFuZWxcclxuICogQHByb3BlcnR5IHtMaW5lYWdlR3JhbX0gbGluZWFnZUdyYW0gLSBMaW5lYWdlR3JhbSBvYmplY3QuXHJcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gYWN0aXZlIC0gZmFsc2UgLSBjb2xsYXBzZWQsIHRydWUgLSBleHBhbmRlZFxyXG4gKiBAcHJvcGVydHkge3N0cmluZ3xIVE1MRWxlbWVudH0gdHJpZ2dlckJ1dHRvblxyXG4gKi9cclxuXHJcbi8qKiBcclxuICogQ2xhc3Mgd2hpY2ggaXMgYSBzaW1wbGUgVUkgcGFuZWwuXHJcbiAqIFRoaXMgcGFuZWwgY2FuIHJlcHJlc2VudCBhbiBpbmZvcm1hdGlvbiBhYm91dCBzZWxlY3RlZCBlbGVtZW50XHJcbiAqIGFuZCBhbHNvLCBpdCBzdXBwb3J0cyBzaW1wbGUgbmF2aWdhdGlvbiBiZXR3ZWVuIGVsZW1lbnRzLlxyXG4gKiBAY2xhc3NcclxuICogQHBhcmFtIHtPcHRpb25zUGFuZWxNb2RlbH0gb3B0aW9ucyAtIERhdGEgbW9kZWwuXHJcbiAqIEBmaXJlcyBzdGF0ZS1jaGFuZ2VkXHJcbiovXHJcbmV4cG9ydCBmdW5jdGlvbiBPcHRpb25zUGFuZWwgKG9wdGlvbnMpIHtcclxuICAgIFN1YnNjcmliYWJsZS5hcHBseSh0aGlzKTsgICAvLyBtYWtlIHRoaXMgY2xhc3MgU3Vic2NyaWJhYmxlXHJcblxyXG4gICAgY29uc3QgbGVnZW5kcyA9IG9wdGlvbnMubGVnZW5kcyB8fCBbXTtcclxuICAgIGNvbnN0IF9saW5lYWdlR3JhbSA9IG9wdGlvbnMubGluZWFnZUdyYW07XHJcbiAgICBjb25zdCBzZWxmID0gdGhpcztcclxuXHJcbiAgICBUUUdyYW1VSS5GbHlpbmdQYW5lbC5hcHBseSh0aGlzLCBbe1xyXG4gICAgICAgIGJhc2VFbGVtZW50OiBvcHRpb25zLmJhc2VFbGVtZW50LFxyXG4gICAgICAgIGFjdGl2ZTogb3B0aW9ucy5hY3RpdmUsXHJcbiAgICAgICAgaGVhZGVyOiAnT3B0aW9ucyBwYW5lbCcsXHJcbiAgICAgICAgdHJpZ2dlckJ1dHRvbjogb3B0aW9ucy50cmlnZ2VyQnV0dG9uLFxyXG4gICAgICAgIGVtcHR5Qm9keTogdHJ1ZSxcclxuICAgICAgICBzaXplOiB7XHJcbiAgICAgICAgICAgIHdpZHRoOiAnNDAwcHgnLFxyXG4gICAgICAgICAgICBoZWlnaHQ6ICc1MDBweCcsXHJcbiAgICAgICAgfSxcclxuICAgICAgICByZW1vdmVCYWNrZ3JvdW5kOiB0cnVlLFxyXG4gICAgICAgIGJvZHk6IG5ldyBUUUdyYW1VSS5UYWJQYW5lbCh7XHJcbiAgICAgICAgICAgIHRhYnM6IFtcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpZDogJ3RxVWlHZW5lcmFsJyxcclxuICAgICAgICAgICAgICAgICAgICBsYWJlbDogJ0dlbmVyYWwnLFxyXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IGBcclxuICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGZvcj1cImRpc3BsYXlHcm91cFwiIGNsYXNzPVwidHEtbGFiZWxcIj5EaXNwbGF5PC9sYWJlbD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBpZD1cImRpc3BsYXlHcm91cFwiIGNsYXNzPVwidHEtdWktZ3JvdXBcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0cS11aS1ncm91cF9fc2VsZWN0LWxpbmVcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c2VsZWN0IGlkPVwidHFVaU9yaWVudGF0aW9uXCIgc2l6ZT1cIjFcIiBuYW1lPVwib3JpZW50YXRpb25cIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cImxlZnQtdG8tcmlnaHRcIj5sZWZ0IHRvIHJpZ2h0PC9vcHRpb24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyaWdodC10by1sZWZ0XCI+cmlnaHQgdG8gbGVmdDwvb3B0aW9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwidG9wLXRvLWJvdHRvbVwiPnRvcCB0byBib3R0b208L29wdGlvbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cImJvdHRvbS10by10b3BcIj5ib3R0b20gdG8gdG9wPC9vcHRpb24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zZWxlY3Q+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4+IC0gR3JhcGggb3JpZW50YXRpb248L3NwYW4+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0cS11aS1ncm91cF9fc2VsZWN0LWxpbmVcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c2VsZWN0IGlkPVwidHFVaVJvdXRpbmdcIiBzaXplPVwiMVwiIG5hbWU9XCJyb3V0aW5nXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJtZXRyb1wiPk1ldHJvPC9vcHRpb24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJsZ3JvdXRlclwiPlJhaWxSb2FkPC9vcHRpb24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJub3JtYWxcIj5Ob3JtYWw8L29wdGlvbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIm1hbmhhdHRhblwiPk1hbmhhdHRhbjwvb3B0aW9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc2VsZWN0PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuPiAtIExpbmsgcm91dGluZzwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRxLXVpLWdyb3VwX19zZWxlY3QtbGluZVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzZWxlY3QgaWQ9XCJ0cVVpTGF5b3V0XCIgc2l6ZT1cIjFcIiBuYW1lPVwibGF5b3V0XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJzYW5rZXlcIj5TYW5rZXk8L29wdGlvbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cImZsb3ctZGlyZWN0ZWRcIj5GbG93LWRpcmVjdGVkPC9vcHRpb24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zZWxlY3Q+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4+IC0gTGF5b3V0IGFsZ29yaXRobTwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRxLXVpLWdyb3VwX19jaGVjay1ib3gtbGluZVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuPjxpbnB1dCBpZD1cInRxVWlFeHBhbmRDb2xsYXBzZVwiIHR5cGU9XCJjaGVja2JveFwiPjwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3Bhbj5FeHBhbmQgbm9kZSBjb250YWluZXJzIHRvIHNob3cgZnVsbCB0ZXh0IGxhYmVsczwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRxLXVpLWdyb3VwX19jaGVjay1ib3gtbGluZVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuPjxpbnB1dCBpZD1cInRxVWlDbGlwTm9kZXNcIiB0eXBlPVwiY2hlY2tib3hcIj48L3NwYW4+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4+Tm9kZXMgdHJpbW1pbmcgb24gYm9yZGVyczwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGZvcj1cImV4cG9ydEdyb3VwXCIgY2xhc3M9XCJ0cS1sYWJlbFwiPkV4cG9ydCBhczwvbGFiZWw+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgaWQ9XCJleHBvcnRHcm91cFwiIGNsYXNzPVwidHEtdWktZ3JvdXAgdHEtdWktZXhwb3J0LWdyb3VwXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGlkPVwidHFVaUV4cG9ydFNWR1wiIHRpdGxlPVwiRXhwb3J0IGRpYWdyYW0gdG8gU1ZHXCIgY2xhc3M9XCJ0cS1idXR0b25cIj5TVkc8L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gaWQ9XCJ0cVVpRXhwb3J0UE5HXCIgdGl0bGU9XCJFeHBvcnQgZGlhZ3JhbSB0byBQTkdcIiBjbGFzcz1cInRxLWJ1dHRvblwiPlBORzwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBpZD1cInRxVWlQcmludFwiIHRpdGxlPVwiUHJpbnRcIiBjbGFzcz1cInRxLWJ1dHRvblwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZ2x5cGhpY29uIGdseXBoaWNvbi1wcmludFwiPjwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGZvcj1cImhvd1RvVXNlR3JvdXBcIiBjbGFzcz1cInRxLWxhYmVsXCI+SG93IHRvIHVzZTwvbGFiZWw+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgaWQ9XCJob3dUb1VzZUdyb3VwXCIgY2xhc3M9XCJ0cS11aS1ncm91cCB0cS11aS1vcHQtZ3JvdXBcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gaWQ9XCJ0cVVpSGVscEJ0blwiIHRpdGxlPVwiSGVscFwiIGNsYXNzPVwidHEtYnV0dG9uXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJnbHlwaGljb24gZ2x5cGhpY29uLWluZm8tc2lnblwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGEgY2xhc3M9XCJ0cS1idXR0b25cIiB0aXRsZT1cIkRvY3VtZW50YXRpb25cIiBocmVmPVwiLi9kb2N1bWVudGF0aW9uL2luZGV4Lmh0bWxcIj5ET0M8L2E+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgIGAsXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGlkOiAndHFVaUxlZ2VuZHMnLFxyXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiAnTGVnZW5kcycsXHJcbiAgICAgICAgICAgICAgICAgICAgYm9keTogbmV3IFRRR3JhbVVJLkxlZ2VuZHMoe2xlZ2VuZHM6IGxlZ2VuZHN9KSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICB9KSxcclxuICAgIH1dKTtcclxuXHJcbiAgICAvLyBHZW5lcmFsXHJcblxyXG4gICAgY29uc3Qgc3ZnQnV0dG9uID0gc2VsZi5yb290SHRtbC5xdWVyeVNlbGVjdG9yKCcjdHFVaUV4cG9ydFNWRycpO1xyXG4gICAgY29uc3QgcG5nQnV0dG9uID0gc2VsZi5yb290SHRtbC5xdWVyeVNlbGVjdG9yKCcjdHFVaUV4cG9ydFBORycpO1xyXG4gICAgY29uc3QgcHJpbnRCdXR0b24gPSBzZWxmLnJvb3RIdG1sLnF1ZXJ5U2VsZWN0b3IoJyN0cVVpUHJpbnQnKTtcclxuICAgIGNvbnN0IGV4cGFuZENvbGxhcHNlID0gc2VsZi5yb290SHRtbC5xdWVyeVNlbGVjdG9yKCcjdHFVaUV4cGFuZENvbGxhcHNlJyk7XHJcbiAgICBjb25zdCBvcmllbnRhdGlvbiA9IHNlbGYucm9vdEh0bWwucXVlcnlTZWxlY3RvcignI3RxVWlPcmllbnRhdGlvbicpO1xyXG4gICAgY29uc3Qgcm91dGluZyA9IHNlbGYucm9vdEh0bWwucXVlcnlTZWxlY3RvcignI3RxVWlSb3V0aW5nJyk7XHJcbiAgICBjb25zdCBsYXlvdXQgPSBzZWxmLnJvb3RIdG1sLnF1ZXJ5U2VsZWN0b3IoJyN0cVVpTGF5b3V0Jyk7XHJcbiAgICBjb25zdCBjbGlwcGluZyA9IHNlbGYucm9vdEh0bWwucXVlcnlTZWxlY3RvcignI3RxVWlDbGlwTm9kZXMnKTtcclxuICAgIGNvbnN0IGhlbHBCdXR0b24gPSBzZWxmLnJvb3RIdG1sLnF1ZXJ5U2VsZWN0b3IoJyN0cVVpSGVscEJ0bicpO1xyXG5cclxuICAgIF9saW5lYWdlR3JhbS5vbignY3VycmVudC12aWV3LWNoYW5nZWQnLCBmdW5jdGlvbiAodmlld0lkKSB7XHJcbiAgICAgICAgc3ZnQnV0dG9uLmRpc2FibGVkID0gKHZpZXdJZCAhPT0gJ2xpbmVhZ2VEaWFncmFtJyk7XHJcbiAgICAgICAgZXhwYW5kQ29sbGFwc2UuZGlzYWJsZWQgPSAodmlld0lkICE9PSAnbGluZWFnZURpYWdyYW0nKTtcclxuICAgIH0pO1xyXG5cclxuICAgIHN2Z0J1dHRvbi5vbmNsaWNrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF9saW5lYWdlR3JhbS5leHBvcnQoe1xyXG4gICAgICAgICAgICB0eXBlOiAnc3ZnJyxcclxuICAgICAgICAgICAgdmlldzogJ2xpbmVhZ2VEaWFncmFtJ1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIHBuZ0J1dHRvbi5vbmNsaWNrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF9saW5lYWdlR3JhbS5leHBvcnQoe1xyXG4gICAgICAgICAgICB0eXBlOiAncG5nJyxcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBwcmludEJ1dHRvbi5vbmNsaWNrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF9saW5lYWdlR3JhbS5wcmludCgpO1xyXG4gICAgfTtcclxuXHJcbiAgICBleHBhbmRDb2xsYXBzZS5vbmNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoZXhwYW5kQ29sbGFwc2UuY2hlY2tlZCkge1xyXG4gICAgICAgICAgICBfbGluZWFnZUdyYW0uZXhwYW5kQWxsTm9kZXMoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBfbGluZWFnZUdyYW0uY29sbGFwc2VBbGxOb2RlcygpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgb3JpZW50YXRpb24udmFsdWUgPSBfbGluZWFnZUdyYW0uZ2V0T3JpZW50YXRpb24oKTtcclxuICAgIG9yaWVudGF0aW9uLm9uY2hhbmdlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF9saW5lYWdlR3JhbS5zZXRPcmllbnRhdGlvbihvcmllbnRhdGlvbi52YWx1ZSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICByb3V0aW5nLnZhbHVlID0gX2xpbmVhZ2VHcmFtLmdldFJvdXRpbmcoKTtcclxuICAgIHJvdXRpbmcub25jaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgX2xpbmVhZ2VHcmFtLnNldFJvdXRpbmcocm91dGluZy52YWx1ZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGxheW91dC52YWx1ZSA9IF9saW5lYWdlR3JhbS5nZXRMYXlvdXRBbGdvcml0aG0oKTtcclxuICAgIGxheW91dC5vbmNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfbGluZWFnZUdyYW0uc2V0TGF5b3V0QWxnb3JpdGhtKGxheW91dC52YWx1ZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGhlbHBCdXR0b24ub25jbGljayA9IG9wdGlvbnMub25QcmVzc0hlbHA7XHJcblxyXG4gICAgY2xpcHBpbmcuY2hlY2tlZCA9IF9saW5lYWdlR3JhbS5nZXRDbGlwcGluZygpO1xyXG4gICAgY2xpcHBpbmcub25jaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgX2xpbmVhZ2VHcmFtLnNldENsaXBwaW5nKGNsaXBwaW5nLmNoZWNrZWQpO1xyXG4gICAgfTtcclxuXHJcbiAgICBoZWxwQnV0dG9uLm9uY2xpY2sgPSBvcHRpb25zLm9uUHJlc3NIZWxwO1xyXG59XHJcbmV4cG9ydCBkZWZhdWx0IE9wdGlvbnNQYW5lbDsiLCJpbXBvcnQgKiBhcyBqb2ludCBmcm9tICdyYXBwaWQnO1xyXG5pbXBvcnQgU3Vic2NyaWJhYmxlIGZyb20gJy4uL3N1YnNjcmlwdGlvbkFQSS9zdWJzY3JpYmVhYmxlJztcclxuXHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBcclxuICogSHRtbC1VSSBlbGVtZW50IHdoaWNoIG1hbmFnZSBzaXplIG9mIHR3byBzcGxpdHRlZCB3aW5kb3dzLlxyXG4gKiBcclxuICogQ29uc3RydWN0b3IgcGFyYW1ldGVyczpcclxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gKiBAcGFyYW0ge1xyXG4gKiAgdmlld0ZyYW1lQTogVmlld0ZyYW1lLFxyXG4gKiAgdmlld0ZyYW1lQjogVmlld0ZyYW1lLFxyXG4gKiB9IG1vZGVsXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbWV0ZXJzIC0gcGFyYW1ldGVycyBzZXRcclxuICogXHJcbiAqIFB1YmxpYyBwcm9wZXJ0aWVzOlxyXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAqIGVsOiBIVE1MRUxlbWVudFxyXG4gKiBcclxuICogUHVibGljIG1ldGhvZHM6XHJcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICogb24gKGV2ZW50OiBzdHJpbmcsIGNhbGxiYWNrOiBmdW5jdGlvbik6IHZvaWRcclxuICogdW5zdWJzY3JpYmUgKGNhbGxiYWNrOiBmdW5jdGlvbik6IHZvaWRcclxuICogdHJpZ2dlciAoZXZlbnQ6IHN0cmluZywgcGFyYW1ldGVyczogYW55KTogdm9pZFxyXG4gKiBcclxuICogRXZlbnRzOlxyXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAqIEBmaXJlcyBkaWZmKHsgZGlmZjogbnVtYmVyLCBsYXN0Q2hhbmdlOiBib29sZWFuIH0pXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gU3BsaXR0ZXIgKG1vZGVsLCBwYXJhbWV0ZXJzKSB7XHJcbiAgICAvLyBJbml0XHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICBTdWJzY3JpYmFibGUuYXBwbHkodGhpcyk7ICAgLy8gbWFrZSB0aGlzIGNsYXNzIFN1YnNjcmliYWJsZVxyXG5cclxuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xyXG4gICAgY29uc3QgX2dyYXBoT3JpZW50YXRpb24gPSBwYXJhbWV0ZXJzLmdyYXBoT3JpZW50YXRpb24gPT09ICdsZWZ0LXRvLXJpZ2h0JyB8fCBwYXJhbWV0ZXJzLmdyYXBoT3JpZW50YXRpb24gPT09ICdyaWdodC10by1sZWZ0JztcclxuICAgIGxldCBfdmlzaWJsZSA9IHRydWU7XHJcblxyXG4gICAgc2VsZi5tb2RlbCA9IG1vZGVsO1xyXG4gICAgaWYgKHBhcmFtZXRlcnMuZ3JhcGhPcmllbnRhdGlvbiA9PT0gJ3JpZ2h0LXRvLWxlZnQnIHx8IHBhcmFtZXRlcnMuZ3JhcGhPcmllbnRhdGlvbiA9PT0gJ2JvdHRvbS10by10b3AnKSB7XHJcbiAgICAgICAgX3N3YXBWaWV3RnJhbWVzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgc2VsZi5lbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO1xyXG4gICAgc2VsZi5lbC5jbGFzc05hbWUgPSBfZ3JhcGhPcmllbnRhdGlvbiA/ICd0cV9saW5lYWdlX3VpX192aWV3LWZyYW1lLXNwbGl0dGVyJyA6ICd0cV9saW5lYWdlX3VpX192aWV3LWZyYW1lLXNwbGl0dGVyLXZlcnRpY2FsJztcclxuICAgIHNlbGYuZWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgX29ubW91c2Vkb3duKTtcclxuICAgIFxyXG4gICAgbGV0IHN0YXJ0ID0gMDtcclxuICAgIGZ1bmN0aW9uIF9vbm1vdXNlZG93biAoZXZlbnQpIHtcclxuICAgICAgICBldmVudCA9IGV2ZW50IHx8IHdpbmRvdy5ldmVudDtcclxuICAgICAgICBzdGFydCA9IDA7XHJcbiAgICAgICAgd2luZG93LmdldFNlbGVjdGlvbigpLnJlbW92ZUFsbFJhbmdlcygpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChfZ3JhcGhPcmllbnRhdGlvbikge1xyXG4gICAgICAgICAgICBpZiAoZXZlbnQucGFnZVgpIHN0YXJ0ID0gZXZlbnQucGFnZVg7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LmNsaWVudFgpIHN0YXJ0ID0gZXZlbnQuY2xpZW50WDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoZXZlbnQucGFnZVkpIHN0YXJ0ID0gZXZlbnQucGFnZVk7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LmNsaWVudFkpIHN0YXJ0ID0gZXZlbnQuY2xpZW50WTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgX29uY2hhbmdlKTtcclxuICAgICAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBfb25tb3VzZXVwKTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gX29uY2hhbmdlIChldmVudCwgb25Nb3VzZVVwKSB7XHJcbiAgICAgICAgICAgIGV2ZW50ID0gZXZlbnQgfHwgd2luZG93LmV2ZW50O1xyXG4gICAgICAgICAgICBsZXQgZW5kID0gMDtcclxuXHJcbiAgICAgICAgICAgIGlmIChfZ3JhcGhPcmllbnRhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LnBhZ2VYKSBlbmQgPSBldmVudC5wYWdlWDtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LmNsaWVudFgpIGVuZCA9IGV2ZW50LmNsaWVudFg7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQucGFnZVkpIGVuZCA9IGV2ZW50LnBhZ2VZO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQuY2xpZW50WSkgZW5kID0gZXZlbnQuY2xpZW50WTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY29uc3QgZGlmZiA9IGVuZCAtIHN0YXJ0O1xyXG4gICAgICAgICAgICBzdGFydCA9IGVuZDtcclxuICAgICAgICAgICAgc2VsZi50cmlnZ2VyKCdzcGxpdHRlci1wb3NpdGlvbi1jaGFuZ2VkJywgeyBkaWZmOiBfbGltaXREaWZmKGRpZmYpLCBsYXN0Q2hhbmdlOiBvbk1vdXNlVXAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBfb25tb3VzZXVwIChldmVudCkge1xyXG4gICAgICAgICAgICBfb25jaGFuZ2UoZXZlbnQsIHRydWUpO1xyXG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5Lm9ubW91c2Vtb3ZlID0gZG9jdW1lbnQuYm9keS5vbm1vdXNldXAgPSBudWxsO1xyXG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIF9vbmNoYW5nZSk7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIF9vbm1vdXNldXApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG4gICAgc2VsZi51cGRhdGVOZWlnaGJvdXIgPSBmdW5jdGlvbiAobmV3TmVpZ2hib3VyKSB7XHJcbiAgICAgICAgaWYgKHNlbGYubW9kZWwudmlld0ZyYW1lQiAhPT0gbmV3TmVpZ2hib3VyKSB7XHJcbiAgICAgICAgICAgIHNlbGYubW9kZWwudmlld0ZyYW1lQiA9IG5ld05laWdoYm91cjtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYuaGlkZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoX3Zpc2libGUpIHtcclxuICAgICAgICAgICAgc2VsZi5lbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gICAgICAgICAgICBfdmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgc2VsZi5zaG93ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghX3Zpc2libGUpIHtcclxuICAgICAgICAgICAgc2VsZi5lbC5zdHlsZS5kaXNwbGF5ID0gJyc7XHJcbiAgICAgICAgICAgIF92aXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIF9zd2FwVmlld0ZyYW1lcyAoKSB7XHJcbiAgICAgICAgY29uc3QgdGVtcCA9IG1vZGVsLnZpZXdGcmFtZUE7XHJcbiAgICAgICAgbW9kZWwudmlld0ZyYW1lQSA9IG1vZGVsLnZpZXdGcmFtZUI7XHJcbiAgICAgICAgbW9kZWwudmlld0ZyYW1lQiA9IHRlbXA7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX2xpbWl0RGlmZiAoZGlmZikge1xyXG4gICAgICAgIGlmIChkaWZmID09PSAwKSByZXR1cm47XHJcbiAgICAgICAgY29uc3QgdmZBID0gc2VsZi5tb2RlbC52aWV3RnJhbWVBO1xyXG4gICAgICAgIGNvbnN0IHZmQiA9IHNlbGYubW9kZWwudmlld0ZyYW1lQjtcclxuXHJcbiAgICAgICAgbGV0IHNpZGVBO1xyXG4gICAgICAgIGxldCBzaWRlQjtcclxuICAgICAgICBsZXQgbWluU2lkZVNob3VsZEJlO1xyXG5cclxuICAgICAgICBpZiAoX2dyYXBoT3JpZW50YXRpb24pIHtcclxuICAgICAgICAgICAgc2lkZUEgPSB2ZkEuc2l6ZS53aWR0aDtcclxuICAgICAgICAgICAgc2lkZUIgPSB2ZkIuc2l6ZS53aWR0aDtcclxuICAgICAgICAgICAgbWluU2lkZVNob3VsZEJlID0gcGFyYW1ldGVycy5mcmFtZVBhZGRpbmcueCAqIDIgKyAxO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHNpZGVBID0gdmZBLnNpemUuaGVpZ2h0O1xyXG4gICAgICAgICAgICBzaWRlQiA9IHZmQi5zaXplLmhlaWdodDtcclxuICAgICAgICAgICAgbWluU2lkZVNob3VsZEJlID0gcGFyYW1ldGVycy5mcmFtZVBhZGRpbmcueSAqIDIgKyAxO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgcmVzdWx0U2lkZUEgPSBzaWRlQSArIGRpZmY7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0U2lkZUIgPSBzaWRlQiAtIGRpZmY7XHJcblxyXG4gICAgICAgIGxldCBsaW1pdGF0aW9uQSA9IDA7XHJcbiAgICAgICAgbGV0IGxpbWl0YXRpb25CID0gMDtcclxuICAgICAgICBpZiAocmVzdWx0U2lkZUEgPCBtaW5TaWRlU2hvdWxkQmUgJiYgcmVzdWx0U2lkZUIgPCBtaW5TaWRlU2hvdWxkQmUpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmVzdWx0U2lkZUEgPCBtaW5TaWRlU2hvdWxkQmUpIHtcclxuICAgICAgICAgICAgbGltaXRhdGlvbkEgPSAgbWluU2lkZVNob3VsZEJlIC0gcmVzdWx0U2lkZUE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZXN1bHRTaWRlQiA8IG1pblNpZGVTaG91bGRCZSkge1xyXG4gICAgICAgICAgICBsaW1pdGF0aW9uQiA9ICByZXN1bHRTaWRlQiAtIG1pblNpZGVTaG91bGRCZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxpbWl0YXRpb25BICE9PSAwIHx8IGxpbWl0YXRpb25CICE9PSAwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdERpZmYgPSBNYXRoLmFicyhsaW1pdGF0aW9uQSkgPiBNYXRoLmFicyhsaW1pdGF0aW9uQikgPyBkaWZmICsgbGltaXRhdGlvbkEgOiBkaWZmICsgbGltaXRhdGlvbkI7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdFNpZGVBID0gc2lkZUEgKyByZXN1bHREaWZmO1xyXG4gICAgICAgICAgICBjb25zdCByZXN1bHRTaWRlQiA9IHNpZGVCIC0gcmVzdWx0RGlmZjtcclxuICAgICAgICAgICAgaWYgKHJlc3VsdFNpZGVBIDwgbWluU2lkZVNob3VsZEJlIHx8IHJlc3VsdFNpZGVCIDwgbWluU2lkZVNob3VsZEJlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdERpZmY7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRpZmY7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxufVxyXG5TcGxpdHRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGpvaW50LnNoYXBlcy5iYXNpYy5SZWN0LnByb3RvdHlwZSk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBTcGxpdHRlcjsiLCIvKipcclxuICogQ29sb3JlZEJ1dHRvbk1vZGVsIC0gZGF0YSBtb2RlbCBmb3IgQ29sb3JlZEJ1dHRvbnMgaW4gdGhlIENvbG9yZWRCdXR0b25zTGlzdFxyXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBDb2xvcmVkQnV0dG9uTW9kZWxcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGlkIC0gU3RyaW5nIGlkXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBsYWJlbCAtIGFyZSB1c2VkIGZvciBpbXBsZW1lbnRpbmcgdG9vbHRpcCBhbmQgaWNvblxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gYm9yZGVyQ29sb3IgLSBCb3JkZXIgY29sb3JcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGJhY2tncm91bmRDb2xvciAtIEJhY2tncm91bmQgY29sb3JcclxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBGdW5jdGlvbiB3aWNoIHdpbGwgYmUgY29sbGVkIG9uIG1vdXNlIGNsaWNrIG9uIGJ1dHRvblxyXG4qL1xyXG5cclxubGV0IHVuaXF1ZUlkID0gMDtcclxuXHJcbi8qKlxyXG4gKiBDbGFzcyBpcyBhIGNvbGxlY3Rpb24gb2YgY29sb3JlZCBidXR0b25zLFxyXG4gKiB3aGljaCB1c2UgZmlyc3QgbGV0dGVycyBvZiB0aGUgbGFiZWwgYXMgYW4gaWNvbnMgZm9yIHRoZSBidXR0b25zLlxyXG4gKiAoSW5pdGlhbGx5IGl0IHdhcyBkZXZlbG9wZWQgYXMgYSBjb2xsZWN0aW9uIG9mIGNvbGxhcHNlZCB2aWV3RnJhbWVzIGZvciBMaW5lYWdlR3JhbSlcclxuICogQGNsYXNzXHJcbiAqIEBhdWdtZW50cyBUUVVJRWxlbWVudFxyXG4gKiBAcGFyYW0ge0xpbmVhZ2VHcmFtfSBsaW5lYWdlR3JhbVxyXG4gKiBcclxuICogQHByb3BlcnR5IHtDb2xvcmVkQnV0dG9uTW9kZWxbXX0gYnV0dG9ucyAtIGxpc3Qgb2YgYnV0dG9uIG1vZGVsc1xyXG4qL1xyXG5leHBvcnQgZnVuY3Rpb24gVmlld0ZyYW1lQnV0dG9ucyAocGFyYW1ldGVycykge1xyXG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XHJcbiAgICBpZiAoIXBhcmFtZXRlcnMpIHRocm93IEVycm9yKCdUaGUgYXJndW1lbnRzIHBhcmFtZXRlcnMgc2hvdWxkblxcJ3QgYmUgdW5kZWZpbmVkIScpO1xyXG4gICAgaWYgKCFwYXJhbWV0ZXJzLmxpbmVhZ2VHcmFtKSB0aHJvdyBFcnJvcignbGluZWFnZUdyYW0gZmllbGQgaXMgdW5kZWZpbmVkIScpO1xyXG5cclxuICAgIHNlbGYucm9vdEh0bWwgPSBfaW5pdFJvb3RFbGVtZW50KCk7XHJcbiAgICBzZWxmLmlkID0gcGFyYW1ldGVycy5saW5lYWdlR3JhbS5pZCB8fCAnY29sb3JlZEJ1dHRvbnMtJyArIHVuaXF1ZUlkKys7XHJcbiAgICBzZWxmLnJvb3RIdG1sLmlkID0gc2VsZi5pZDtcclxuICAgIFxyXG4gICAgbGV0IF9saW5lYWdlR3JhbSA9IHBhcmFtZXRlcnMubGluZWFnZUdyYW07XHJcbiAgICBsZXQgX3N0YXRlID0ge307XHJcbiAgICBsZXQgX2J1dHRvbnMgPSB7fTtcclxuICAgIGxldCBfb3ZlclZpZXdGcmFtZUJ1dHRvbjtcclxuXHJcbiAgICBfY3JlYXRlQnV0dG9ucygpO1xyXG5cclxuICAgIF9saW5lYWdlR3JhbS5vbigndmlldy1mcmFtZS1zdGF0ZS1jaGFuZ2VkJywgX3VwZGF0ZUJ1dHRvbnMpO1xyXG4gICAgX2xpbmVhZ2VHcmFtLm9uKCdoaXN0b3J5LXN0YXRlLWNoYW5nZWQnLCBfY3JlYXRlQnV0dG9ucyk7XHJcblxyXG4gICAgZnVuY3Rpb24gX2NyZWF0ZUJ1dHRvbnMgKCkge1xyXG4gICAgICAgIGNvbnN0IHZpZXdGcmFtZXMgPSBfbGluZWFnZUdyYW0uZ2V0Vmlld0ZyYW1lcygpO1xyXG4gICAgICAgIGNvbnN0IG92ZXJWaWV3RnJhbWUgPSBfbGluZWFnZUdyYW0uZ2V0T3ZlclZpZXdGcmFtZSgpO1xyXG5cclxuICAgICAgICBfc3RhdGUgPSB7fTtcclxuICAgICAgICBfYnV0dG9ucyA9IHt9O1xyXG4gICAgICAgIHNlbGYucm9vdEh0bWwuaW5uZXJIVE1MID0gJyc7XHJcblxyXG4gICAgICAgIGlmIChvdmVyVmlld0ZyYW1lKSB7XHJcbiAgICAgICAgICAgIF9vdmVyVmlld0ZyYW1lQnV0dG9uID0gY3JlYXRlQnV0dG9uKG92ZXJWaWV3RnJhbWUpO1xyXG4gICAgICAgICAgICBfb3ZlclZpZXdGcmFtZUJ1dHRvbi5zdHlsZS5ib3JkZXJDb2xvciA9IG51bGw7XHJcbiAgICAgICAgICAgIF9vdmVyVmlld0ZyYW1lQnV0dG9uLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IG51bGw7XHJcbiAgICAgICAgICAgIF9vdmVyVmlld0ZyYW1lQnV0dG9uLnN0eWxlLmNvbG9yID0gbnVsbDtcclxuICAgICAgICAgICAgX292ZXJWaWV3RnJhbWVCdXR0b24uY2xhc3NMaXN0LmFkZCgndHEtdWktY29sb3JlZC1idXR0b25zLW92ZXJ2aWV3Jyk7XHJcbiAgICAgICAgICAgIHNlbGYucm9vdEh0bWwuYXBwZW5kQ2hpbGQoX292ZXJWaWV3RnJhbWVCdXR0b24pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmlld0ZyYW1lcy5mb3JFYWNoKHZpZXdGcmFtZSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh2aWV3RnJhbWUuaWQgIT09IG92ZXJWaWV3RnJhbWUuaWQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGh0bWxCdXR0b24gPSBjcmVhdGVCdXR0b24odmlld0ZyYW1lKTtcclxuICAgICAgICAgICAgICAgIF9idXR0b25zW3ZpZXdGcmFtZS5pZF0gPSBodG1sQnV0dG9uO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5yb290SHRtbC5hcHBlbmRDaGlsZChodG1sQnV0dG9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBfdXBkYXRlQnV0dG9ucygpO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVCdXR0b24gKHZpZXdGcmFtZSkge1xyXG4gICAgICAgICAgICBjb25zdCBodG1sQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnQlVUVE9OJyk7XHJcblxyXG4gICAgICAgICAgICBodG1sQnV0dG9uLmNsYXNzTmFtZSA9ICd0cS11aS10b29sYmFyX19idXR0b24gdHEtdWktY29sb3JlZC1idXR0b24nO1xyXG5cclxuICAgICAgICAgICAgaWYgKHZpZXdGcmFtZS5pc092ZXJWaWV3KSB7XHJcbiAgICAgICAgICAgICAgICBodG1sQnV0dG9uLmNsYXNzTGlzdC5hZGQoJ3RxLXVpLWNvbG9yZWQtYnV0dG9ucy1vdmVydmlldycpO1xyXG4gICAgICAgICAgICAgICAgaHRtbEJ1dHRvbi5vbmNsaWNrID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfc3RhdGVbdmlld0ZyYW1lLmlkXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfbGluZWFnZUdyYW0uc2V0RnVsbFNjcmVlbk1vZGUoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9saW5lYWdlR3JhbS5zZXRGdWxsU2NyZWVuTW9kZSh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaHRtbEJ1dHRvbi5pbm5lckhUTUwgPSBgPHNwYW4+JHtfZ2V0U2hvcnRMYWJlbCh2aWV3RnJhbWUubGFiZWwpfTwvc3Bhbj5gO1xyXG4gICAgICAgICAgICAgICAgaHRtbEJ1dHRvbi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSB2aWV3RnJhbWUuYmFja2dyb3VuZENvbG9yIHx8ICd3aGl0ZSc7XHJcbiAgICAgICAgICAgICAgICBodG1sQnV0dG9uLnN0eWxlLmJvcmRlckNvbG9yID0gdmlld0ZyYW1lLmJvcmRlckNvbG9yIHx8ICdibGFjayc7XHJcbiAgICAgICAgICAgICAgICBodG1sQnV0dG9uLnN0eWxlLmNvbG9yID0gdmlld0ZyYW1lLmJvcmRlckNvbG9yIHx8ICdibGFjayc7XHJcbiAgICAgICAgICAgICAgICBodG1sQnV0dG9uLm9uY2xpY2sgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9zdGF0ZVt2aWV3RnJhbWUuaWRdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9saW5lYWdlR3JhbS5jb2xsYXBzZVZpZXdGcmFtZSh2aWV3RnJhbWUuaWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9saW5lYWdlR3JhbS5leHBhbmRWaWV3RnJhbWUodmlld0ZyYW1lLmlkKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBfc3RhdGVbdmlld0ZyYW1lLmlkXSA9IHZpZXdGcmFtZS5leHBhbmRlZDtcclxuICAgICAgICAgICAgcmV0dXJuIGh0bWxCdXR0b247XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIF91cGRhdGVCdXR0b25zICgpIHtcclxuICAgICAgICBjb25zdCB2aWV3RnJhbWVzID0gX2xpbmVhZ2VHcmFtLmdldFZpZXdGcmFtZXMoKTtcclxuICAgICAgICBjb25zdCBvdmVyVmlld0ZyYW1lID0gX2xpbmVhZ2VHcmFtLmdldE92ZXJWaWV3RnJhbWUoKTtcclxuXHJcbiAgICAgICAgaWYgKG92ZXJWaWV3RnJhbWUpIHtcclxuICAgICAgICAgICAgX3N0YXRlW292ZXJWaWV3RnJhbWUuaWRdID0gb3ZlclZpZXdGcmFtZS5hY3RpdmU7XHJcbiAgICAgICAgICAgIF9vdmVyVmlld0ZyYW1lQnV0dG9uLmlubmVySFRNTCA9IGA8c3Bhbj4ke292ZXJWaWV3RnJhbWUuYWN0aXZlID8gJ0YnIDogJ08nfTwvc3Bhbj5gO1xyXG4gICAgICAgICAgICBpZiAob3ZlclZpZXdGcmFtZS5hY3RpdmUpIHtcclxuICAgICAgICAgICAgICAgIF9vdmVyVmlld0ZyYW1lQnV0dG9uLnRpdGxlID0gJ1N3aXRjaCB0byBGcmFtZXMgbW9kZSc7XHJcbiAgICAgICAgICAgICAgICBzZWxmLnJvb3RIdG1sLmNsYXNzTGlzdC5hZGQoJ3RxLXVpLWNvbG9yZWQtYnV0dG9ucy1jb2xsYXBzZWQnKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIF9vdmVyVmlld0ZyYW1lQnV0dG9uLnRpdGxlID0gJ1N3aXRjaCB0byBzaW5nbGUgZnJhbWUgbW9kZSc7XHJcbiAgICAgICAgICAgICAgICBzZWxmLnJvb3RIdG1sLmNsYXNzTGlzdC5yZW1vdmUoJ3RxLXVpLWNvbG9yZWQtYnV0dG9ucy1jb2xsYXBzZWQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmlld0ZyYW1lcy5mb3JFYWNoKHZpZXdGcmFtZSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh2aWV3RnJhbWUuaWQgIT09IG92ZXJWaWV3RnJhbWUuaWQpIHtcclxuICAgICAgICAgICAgICAgIF9zdGF0ZVt2aWV3RnJhbWUuaWRdID0gdmlld0ZyYW1lLmV4cGFuZGVkO1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlQnV0dG9uKHZpZXdGcmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlQnV0dG9uICh2aWV3RnJhbWUpIHtcclxuICAgICAgICAgICAgY29uc3QgaHRtbEJ1dHRvbiA9IF9idXR0b25zW3ZpZXdGcmFtZS5pZF07XHJcbiAgICAgICAgICAgIGlmIChfc3RhdGVbdmlld0ZyYW1lLmlkXSkge1xyXG4gICAgICAgICAgICAgICAgaHRtbEJ1dHRvbi50aXRsZSA9ICdDb2xsYXBzZSAnICsgdmlld0ZyYW1lLmxhYmVsO1xyXG4gICAgICAgICAgICAgICAgaHRtbEJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKCd0cS11aS1zZWxlY3RlZCcpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaHRtbEJ1dHRvbi50aXRsZSA9ICdFeHBhbmQgJyArIHZpZXdGcmFtZS5sYWJlbDtcclxuICAgICAgICAgICAgICAgIGh0bWxCdXR0b24uY2xhc3NMaXN0LmFkZCgndHEtdWktc2VsZWN0ZWQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfZ2V0U2hvcnRMYWJlbCAobGFiZWwpIHtcclxuICAgICAgICBpZiAoIWxhYmVsKSByZXR1cm47XHJcbiAgICAgICAgY29uc3Qgd29yZHMgPSBsYWJlbC5tYXRjaCgvW2EteidcXC1dKy9naSk7XHJcbiAgICAgICAgcmV0dXJuIHdvcmRzLmZpbHRlcih3ID0+ICh3LnRvTG93ZXJDYXNlKCkgIT09ICdhbmQnICYmIHcgIT09ICcmJykpLm1hcCh3ID0+IHdbMF0pLmpvaW4oJycpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIF9pbml0Um9vdEVsZW1lbnQgKCkge1xyXG4gICAgICAgIGxldCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO1xyXG4gICAgICAgIGVsLmNsYXNzTmFtZSA9ICd0cS11aS1jb2xvcmVkLWJ1dHRvbnMtbGlzdCc7XHJcbiAgICAgICAgZWwuaW5uZXJIVE1MID0gJyc7XHJcbiAgICAgICAgcmV0dXJuIGVsO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBkZWZhdWx0IFZpZXdGcmFtZUJ1dHRvbnM7IiwiaW1wb3J0IFN1YnNjcmliYWJsZSBmcm9tICcuLi9zdWJzY3JpcHRpb25BUEkvc3Vic2NyaWJlYWJsZSc7XHJcbmltcG9ydCBTcGxpdHRlciBmcm9tICcuL3NwbGl0dGVyJztcclxuaW1wb3J0IHsgY2hlY2tQYWdpbmF0aW9uLCBjYWNoZUlkRm9yVmlld0ZyYW1lVUkgfSBmcm9tICcuLi91dGlscy9saW5lYWdlRGlhZ3JhbVV0aWxzJztcclxuaW1wb3J0IHsgYXJyYXlUb01hcCB9IGZyb20gJy4uL3V0aWxzL3V0aWxzJztcclxuXHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBcclxuICogTWFuYWdlcyB0aGUgbWFpbiB2aWV3IG9mIGFwcGxpY2F0aW9uIChWaWV3LTIpXHJcbiAqIFxyXG4gKiBDb25zdHJ1Y3RvciBwYXJhbWV0ZXJzOlxyXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAqIEBwYXJhbSB7XHJcbiAqICByb290RWw6IEhUTUxFbGVtZW50XHJcbiAqICB2aWV3RnJhbWVzOiBBcnJheSBvZiBWaWV3RnJhbWVcclxuICogfSBvcHRpb25zXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbWV0ZXJzIC0gcGFyYW1ldGVycyBzZXRcclxuICogXHJcbiAqIFB1YmxpYyBtZXRob2RzOlxyXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAqIHJlZnJlc2hTdGF0ZSAoKTogdm9pZFxyXG4gKiB1cGRhdGVWaWV3RnJhbWVzICh2aWV3RnJhbWVzOiBWaWV3RnJhbWVbXSk6IHZvaWRcclxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiBvbiAoZXZlbnQ6IHN0cmluZywgY2FsbGJhY2s6IGZ1bmN0aW9uKTogdm9pZFxyXG4gKiB1bnN1YnNjcmliZSAoY2FsbGJhY2s6IGZ1bmN0aW9uKTogdm9pZFxyXG4gKiB0cmlnZ2VyIChldmVudDogc3RyaW5nLCBwYXJhbWV0ZXJzOiBhbnkpOiB2b2lkXHJcbiAqIFxyXG4gKiBFdmVudHM6XHJcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICogQGZpcmVzIHZpZXctcG9ydC1wb3NpdGlvbi1jaGFuZ2VkIChWaWV3RnJhbWUpXHJcbiAqIEBmaXJlcyBzcGxpdHRlci1wb3NpdGlvbi1jaGFuZ2VkICh2ZjogVmlld0ZyYW1lLCBkaWZmOiB7IGRpZmY6IG51bWJlciwgbGFzdENoYW5nZTogYm9vbGVhbiB9KVxyXG4gKiBAZmlyZXMgdmlldy1mcmFtZS1jb2xsYXBzZWQgKFZpZXdGcmFtZSwgYm9vbGVhbilcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBWaWV3RnJhbWVzVUkgKG9wdGlvbnMsIHBhcmFtZXRlcnMpIHtcclxuICAgIC8vIEluaXRcclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgICBTdWJzY3JpYmFibGUuYXBwbHkodGhpcyk7ICAgLy8gbWFrZSB0aGlzIGNsYXNzIFN1YnNjcmliYWJsZVxyXG5cclxuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xyXG4gICAgY29uc3QgX3Jvb3QgPSBvcHRpb25zLnJvb3RFbDtcclxuXHJcbiAgICBsZXQgX29yaWVudGF0aW9uID0gcGFyYW1ldGVycy5ncmFwaE9yaWVudGF0aW9uID09PSAncmlnaHQtdG8tbGVmdCcgfHwgcGFyYW1ldGVycy5ncmFwaE9yaWVudGF0aW9uID09PSAnYm90dG9tLXRvLXRvcCc7XHJcbiAgICBsZXQgX2dyYXBoT3JpZW50YXRpb24gPSBwYXJhbWV0ZXJzLmdyYXBoT3JpZW50YXRpb24gPT09ICdsZWZ0LXRvLXJpZ2h0JyB8fCBwYXJhbWV0ZXJzLmdyYXBoT3JpZW50YXRpb24gPT09ICdyaWdodC10by1sZWZ0JztcclxuICAgIFxyXG4gICAgbGV0IF92aWV3TWFuYWdlciA9IG9wdGlvbnMudmlld01hbmFnZXI7XHJcbiAgICBsZXQgX3ZpZXdGcmFtZXMgPSBfdmlld01hbmFnZXIuZ2V0Vmlld0ZyYW1lcygpIHx8IFtdO1xyXG4gICAgbGV0IF92aWV3RnJhbWVzTWFwID0gYXJyYXlUb01hcChfdmlld0ZyYW1lcyk7XHJcbiAgICBsZXQgX3VpU2V0Rm9yVmlld0ZyYW1lcztcclxuICAgIGxldCBfYnV0dG9uczRTZXRzO1xyXG4gICAgbGV0IF9zcGxpdHRlcnM7XHJcbiAgICBsZXQgX3VpQm9keTtcclxuICAgIFxyXG4gICAgX2NyZWF0ZVVJKCk7XHJcbiAgICBcclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZnJlc2hlcyBhIHN0YXRlIG9mIFVJLiAoQ2hhbmdlIGFycm93cyBzdGF0ZXMpXHJcbiAgICAgKi9cclxuICAgIHNlbGYucmVmcmVzaCA9IF9yZWZyZXNoO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IG5ldyB2aWV3IG1hbmFnZXJcclxuICAgICAqIEBwYXJhbSB7QXJyYXkgb2YgVmlld0ZyYW1lfSB2aWV3RnJhbWVzXHJcbiAgICAgKi9cclxuICAgIHNlbGYuc2V0Vmlld01hbmFnZXIgPSBmdW5jdGlvbiAodmlld01hbmFnZXIpIHtcclxuICAgICAgICBfdmlld01hbmFnZXIgPSB2aWV3TWFuYWdlcjtcclxuICAgICAgICBfdmlld0ZyYW1lcyA9IF92aWV3TWFuYWdlci5nZXRWaWV3RnJhbWVzKCk7XHJcbiAgICAgICAgX2NyZWF0ZVVJKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSXQgY2hhbmdlcyBvcmllbnRhdGlvbiBvZiB0aGUgZ3JhcGguXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3JpZW50YXRpb24gLSBWYWx1ZXM6ICdsZWZ0LXRvLXJpZ2h0JywgJ3JpZ2h0LXRvLWxlZnQnLCAndG9wLXRvLWJvdHRvbScsICdib3R0b20tdG8tdG9wJ1xyXG4gICAgICogQG1lbWJlcm9mIFZpZXdGcmFtZXNVSVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICovXHJcbiAgICBzZWxmLnNldE9yaWVudGF0aW9uID0gZnVuY3Rpb24gKG9yaWVudGF0aW9uKSB7XHJcbiAgICAgICAgX29yaWVudGF0aW9uID0gb3JpZW50YXRpb24gPT09ICdyaWdodC10by1sZWZ0JyB8fCBvcmllbnRhdGlvbiA9PT0gJ2JvdHRvbS10by10b3AnO1xyXG4gICAgICAgIF9ncmFwaE9yaWVudGF0aW9uID0gb3JpZW50YXRpb24gPT09ICdsZWZ0LXRvLXJpZ2h0JyB8fCBvcmllbnRhdGlvbiA9PT0gJ3JpZ2h0LXRvLWxlZnQnO1xyXG4gICAgICAgIF9jcmVhdGVVSSgpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZnJlc2hlcyBhIHN0YXRlIG9mIFVJLiAoQ2hhbmdlIGFycm93cyBzdGF0ZXMpXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIF9yZWZyZXNoICgpIHtcclxuICAgICAgICBfdXBkYXRlVmlld0ZyYW1lcygpO1xyXG4gICAgICAgIF9yZWZyZXNoVUkoKTtcclxuICAgICAgICBfdmlld0ZyYW1lcy5mb3JFYWNoKHZmID0+IHtcclxuICAgICAgICAgICAgaWYgKHZmLmN1c3RvbWVTaXplZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHZmLnNpemUud2lkdGgpIF91aVNldEZvclZpZXdGcmFtZXNbdmYuaWRdLnN0eWxlLndpZHRoID0gdmYuc2l6ZS53aWR0aCArICdweCc7XHJcbiAgICAgICAgICAgICAgICBpZiAodmYuc2l6ZS5oZWlnaHQpIF91aVNldEZvclZpZXdGcmFtZXNbdmYuaWRdLnN0eWxlLmhlaWdodCA9IHZmLnNpemUuaGVpZ2h0ICsgJ3B4JztcclxuICAgICAgICAgICAgICAgIF91aVNldEZvclZpZXdGcmFtZXNbdmYuaWRdLnN0eWxlLmZsZXhHcm93ID0gMDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIF91aVNldEZvclZpZXdGcmFtZXNbdmYuaWRdLnN0eWxlLmZsZXhHcm93ID0gdmYuc3BhY2VTaGFyZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIF91cGRhdGVWaWV3RnJhbWVzICgpIHtcclxuICAgICAgICBfdmlld0ZyYW1lcyA9IF92aWV3TWFuYWdlci5nZXRWaWV3RnJhbWVzKCk7XHJcbiAgICAgICAgY29uc3QgdmZNYXAgPSBhcnJheVRvTWFwKF92aWV3RnJhbWVzKTtcclxuICAgICAgICBfc3BsaXR0ZXJzLmZvckVhY2goc3BsaXR0ZXIgPT4ge1xyXG4gICAgICAgICAgICBzcGxpdHRlci5tb2RlbC52aWV3RnJhbWVBID0gdmZNYXBbc3BsaXR0ZXIubW9kZWwudmlld0ZyYW1lQS5pZF07XHJcbiAgICAgICAgICAgIHNwbGl0dGVyLm1vZGVsLnZpZXdGcmFtZUIgPSB2Zk1hcFtzcGxpdHRlci5tb2RlbC52aWV3RnJhbWVCLmlkXTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBfdmlld0ZyYW1lc01hcCA9IGFycmF5VG9NYXAoX3ZpZXdGcmFtZXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBodG1sIG5hdmlnYXRlIGJ1dHRvbnMgZm9yIHRoZSB2aWV3cy5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gX2NyZWF0ZVVJICgpIHtcclxuICAgICAgICBpZiAoIV9yb290KSByZXR1cm47XHJcbiAgICAgICAgZWxzZSBfcm9vdC5pbm5lckhUTUwgPSAnJztcclxuXHJcbiAgICAgICAgX3VpQm9keSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO1xyXG4gICAgICAgIF91aUJvZHkuY2xhc3NOYW1lID0gJ3RxX2xpbmVhZ2VfdWknO1xyXG4gICAgICAgIF9yb290LmFwcGVuZENoaWxkKF91aUJvZHkpO1xyXG4gICAgICAgIF9zcGxpdHRlcnMgPSBbXTtcclxuXHJcbiAgICAgICAgX3VpQm9keS5pbm5lckhUTUwgPSAnJztcclxuICAgICAgICBfdWlTZXRGb3JWaWV3RnJhbWVzID0ge307XHJcbiAgICAgICAgX2J1dHRvbnM0U2V0cyA9IHt9O1xyXG5cclxuICAgICAgICBjb25zdCBNT0RJRklFUiA9IDAuNTtcclxuXHJcbiAgICAgICAgaWYgKHBhcmFtZXRlcnMuZ3JhcGhPcmllbnRhdGlvbiA9PT0gJ3JpZ2h0LXRvLWxlZnQnKSB7XHJcbiAgICAgICAgICAgIF91aUJvZHkuc3R5bGUuZmxleERpcmVjdGlvbiA9ICdyb3ctcmV2ZXJzZSc7XHJcbiAgICAgICAgfSBlbHNlIGlmIChwYXJhbWV0ZXJzLmdyYXBoT3JpZW50YXRpb24gPT09ICd0b3AtdG8tYm90dG9tJykge1xyXG4gICAgICAgICAgICBfdWlCb2R5LnN0eWxlLmZsZXhEaXJlY3Rpb24gPSAnY29sdW1uJztcclxuICAgICAgICB9IGVsc2UgaWYgKHBhcmFtZXRlcnMuZ3JhcGhPcmllbnRhdGlvbiA9PT0gJ2JvdHRvbS10by10b3AnKSB7XHJcbiAgICAgICAgICAgIF91aUJvZHkuc3R5bGUuZmxleERpcmVjdGlvbiA9ICdjb2x1bW4tcmV2ZXJzZSc7XHJcbiAgICAgICAgfSBlbHNlIHsgLy8gaG9yaXpvbnRhbFxyXG4gICAgICAgICAgICBfdWlCb2R5LnN0eWxlLmZsZXhEaXJlY3Rpb24gPSAncm93JztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIF92aWV3RnJhbWVzLmZvckVhY2goKHZmLCBpbmRleCwgYXJyKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHZpZXdGcmFtZVVpID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7XHJcbiAgICAgICAgICAgIHZpZXdGcmFtZVVpLmlkID0gY2FjaGVJZEZvclZpZXdGcmFtZVVJKHZmKTtcclxuICAgICAgICAgICAgaWYgKF9vcmllbnRhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgdmlld0ZyYW1lVWkuY2xhc3NOYW1lID0gJ3RxX2xpbmVhZ2VfdWlfdmlldy1mcmFtZV8nICsgcGFyYW1ldGVycy5ncmFwaE9yaWVudGF0aW9uO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmlld0ZyYW1lVWkuY2xhc3NOYW1lID0gJ3RxX2xpbmVhZ2VfdWlfdmlldy1mcmFtZV8nICsgcGFyYW1ldGVycy5ncmFwaE9yaWVudGF0aW9uO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodmYuY3VzdG9tZVNpemVkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodmYuc2l6ZS53aWR0aCkgdmlld0ZyYW1lVWkuc3R5bGUud2lkdGggPSB2Zi5zaXplLndpZHRoICsgJ3B4JztcclxuICAgICAgICAgICAgICAgIGlmICh2Zi5zaXplLmhlaWdodCkgdmlld0ZyYW1lVWkuc3R5bGUuaGVpZ2h0ID0gdmYuc2l6ZS5oZWlnaHQgKyAncHgnO1xyXG4gICAgICAgICAgICAgICAgdmlld0ZyYW1lVWkuc3R5bGUuZmxleEdyb3cgPSAwO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmlld0ZyYW1lVWkuc3R5bGUuZmxleEdyb3cgPSB2Zi5zcGFjZVNoYXJlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF91aUJvZHkuYXBwZW5kQ2hpbGQodmlld0ZyYW1lVWkpO1xyXG5cclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHVwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnSU1HJyk7XHJcbiAgICAgICAgICAgIHVwLmNsYXNzTmFtZSA9ICd0cV9saW5lYWdlX3VpX19idXR0b24gdHFfbGluZWFnZV91aV9fdXAtYnV0dG9uJztcclxuICAgICAgICAgICAgdXAub25jbGljayA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHZpZXdGcmFtZSA9IF92aWV3RnJhbWVzTWFwW3ZmLmlkXTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGN1clBvcyA9IHZpZXdGcmFtZS52aWV3UG9ydFBvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgc2VsZi50cmlnZ2VyKCd2aWV3LXBvcnQtcG9zaXRpb24tY2hhbmdlZCcsIHtcclxuICAgICAgICAgICAgICAgICAgICBpZDogdmYuaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgdmlld1BvcnRQb3NpdGlvbjogeyB4OiBjdXJQb3MueCwgeTogY3VyUG9zLnkgLSB2aWV3RnJhbWUuc2l6ZS5oZWlnaHQgKiBNT0RJRklFUiB9LFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHZpZXdGcmFtZVVpLmFwcGVuZENoaWxkKHVwKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGRvd24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdJTUcnKTtcclxuICAgICAgICAgICAgZG93bi5jbGFzc05hbWUgPSAndHFfbGluZWFnZV91aV9fYnV0dG9uIHRxX2xpbmVhZ2VfdWlfX2Rvd24tYnV0dG9uJztcclxuICAgICAgICAgICAgZG93bi5vbmNsaWNrID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgdmlld0ZyYW1lID0gX3ZpZXdGcmFtZXNNYXBbdmYuaWRdO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY3VyUG9zID0gdmlld0ZyYW1lLnZpZXdQb3J0UG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICBzZWxmLnRyaWdnZXIoJ3ZpZXctcG9ydC1wb3NpdGlvbi1jaGFuZ2VkJywge1xyXG4gICAgICAgICAgICAgICAgICAgIGlkOiB2Zi5pZCxcclxuICAgICAgICAgICAgICAgICAgICB2aWV3UG9ydFBvc2l0aW9uOiB7IHg6IGN1clBvcy54LCB5OiBjdXJQb3MueSArIHZpZXdGcmFtZS5zaXplLmhlaWdodCAqIE1PRElGSUVSIH0sXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdmlld0ZyYW1lVWkuYXBwZW5kQ2hpbGQoZG93bik7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBsZWZ0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnSU1HJyk7XHJcbiAgICAgICAgICAgIGxlZnQuY2xhc3NOYW1lID0gJ3RxX2xpbmVhZ2VfdWlfX2J1dHRvbiB0cV9saW5lYWdlX3VpX19sZWZ0LWJ1dHRvbic7XHJcbiAgICAgICAgICAgIGxlZnQub25jbGljayA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHZpZXdGcmFtZSA9IF92aWV3RnJhbWVzTWFwW3ZmLmlkXTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGN1clBvcyA9IHZpZXdGcmFtZS52aWV3UG9ydFBvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgc2VsZi50cmlnZ2VyKCd2aWV3LXBvcnQtcG9zaXRpb24tY2hhbmdlZCcsIHtcclxuICAgICAgICAgICAgICAgICAgICBpZDogdmYuaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgdmlld1BvcnRQb3NpdGlvbjogeyB4OiBjdXJQb3MueCAtIHZpZXdGcmFtZS5zaXplLndpZHRoICogTU9ESUZJRVIsIHk6IGN1clBvcy55IH0sXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdmlld0ZyYW1lVWkuYXBwZW5kQ2hpbGQobGVmdCk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCByaWdodCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0lNRycpO1xyXG4gICAgICAgICAgICByaWdodC5jbGFzc05hbWUgPSAndHFfbGluZWFnZV91aV9fYnV0dG9uIHRxX2xpbmVhZ2VfdWlfX3JpZ2h0LWJ1dHRvbic7XHJcbiAgICAgICAgICAgIHJpZ2h0Lm9uY2xpY2sgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2aWV3RnJhbWUgPSBfdmlld0ZyYW1lc01hcFt2Zi5pZF07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJQb3MgPSB2aWV3RnJhbWUudmlld1BvcnRQb3NpdGlvbjtcclxuICAgICAgICAgICAgICAgIHNlbGYudHJpZ2dlcigndmlldy1wb3J0LXBvc2l0aW9uLWNoYW5nZWQnLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHZmLmlkLFxyXG4gICAgICAgICAgICAgICAgICAgIHZpZXdQb3J0UG9zaXRpb246IHsgeDogY3VyUG9zLnggKyB2aWV3RnJhbWUuc2l6ZS53aWR0aCAqIE1PRElGSUVSLCB5OiBjdXJQb3MueSB9LFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHZpZXdGcmFtZVVpLmFwcGVuZENoaWxkKHJpZ2h0KTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGNvbGxhcHNlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnSU1HJyk7XHJcbiAgICAgICAgICAgIGNvbGxhcHNlLmNsYXNzTmFtZSA9ICd0cV9saW5lYWdlX3VpX19idXR0b24gdHFfbGluZWFnZV91aV9fY29sbGFwc2UtYnV0dG9uJztcclxuICAgICAgICAgICAgY29sbGFwc2Uub25jbGljayA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHNlbGYudHJpZ2dlcigndmlldy1mcmFtZS1jb2xsYXBzZWQnLCB7IGlkOiB2Zi5pZCwgZXhwYW5kZWQ6IGZhbHNlIH0pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB2aWV3RnJhbWVVaS5hcHBlbmRDaGlsZChjb2xsYXBzZSk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBfYnV0dG9uczRTZXRzW3ZmLmlkXSA9IHtcclxuICAgICAgICAgICAgICAgIHVwOiB1cCxcclxuICAgICAgICAgICAgICAgIGRvd246IGRvd24sXHJcbiAgICAgICAgICAgICAgICBsZWZ0OiBsZWZ0LFxyXG4gICAgICAgICAgICAgICAgcmlnaHQ6IHJpZ2h0LFxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgaWYgKGluZGV4ICE9PSBhcnIubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3BsaXR0ZXIgPSBuZXcgU3BsaXR0ZXIoe1xyXG4gICAgICAgICAgICAgICAgICAgIHZpZXdGcmFtZUE6IHZmLFxyXG4gICAgICAgICAgICAgICAgICAgIHZpZXdGcmFtZUI6IGFycltpbmRleCArIDFdLFxyXG4gICAgICAgICAgICAgICAgfSwgcGFyYW1ldGVycyk7XHJcbiAgICAgICAgICAgICAgICBfc3BsaXR0ZXJzLnB1c2goc3BsaXR0ZXIpO1xyXG4gICAgICAgICAgICAgICAgX3VpQm9keS5hcHBlbmRDaGlsZChzcGxpdHRlci5lbCk7XHJcbiAgICAgICAgICAgICAgICBzcGxpdHRlci5vbignc3BsaXR0ZXItcG9zaXRpb24tY2hhbmdlZCcsIGZ1bmN0aW9uIChkaWZmKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi50cmlnZ2VyKCdzcGxpdHRlci1wb3NpdGlvbi1jaGFuZ2VkJywgW3NwbGl0dGVyLCBkaWZmXSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgX3VpU2V0Rm9yVmlld0ZyYW1lc1t2Zi5pZF0gPSB2aWV3RnJhbWVVaTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgX3JlZnJlc2hVSSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVmcmVzaCBuYXZpZ2F0aW9uIGJ1dHRvbnMuIEJ1dHRvbiBpc24ndCBhY3RpdmUgaWYgdGhlIHZpZXdQb3J0IGNhbid0IG1vdmUgYnkgdGhpcyBkaXJlY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIF9yZWZyZXNoVUkgKCkge1xyXG4gICAgICAgIGlmICghX3Jvb3QpIHJldHVybjtcclxuICAgICAgICBfcmVmcmVzaFNwbGl0dGVyc1N0YXRlKCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgX3ZpZXdGcmFtZXMuZm9yRWFjaCh2ZiA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrID0gY2hlY2tQYWdpbmF0aW9uKHZmKTtcclxuXHJcbiAgICAgICAgICAgIF91aVNldEZvclZpZXdGcmFtZXNbdmYuaWRdLnN0eWxlLmRpc3BsYXkgPSB2Zi5hY3RpdmUgPyAnJyA6ICdub25lJztcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHVwID0gX2J1dHRvbnM0U2V0c1t2Zi5pZF0udXA7XHJcbiAgICAgICAgICAgIGNvbnN0IGRvd24gPSBfYnV0dG9uczRTZXRzW3ZmLmlkXS5kb3duO1xyXG4gICAgICAgICAgICBjb25zdCBsZWZ0ID0gX2J1dHRvbnM0U2V0c1t2Zi5pZF0ubGVmdDtcclxuICAgICAgICAgICAgY29uc3QgcmlnaHQgPSBfYnV0dG9uczRTZXRzW3ZmLmlkXS5yaWdodDtcclxuXHJcbiAgICAgICAgICAgIHVwLnN0eWxlLmN1cnNvciA9IGNoZWNrLmNhbk1vdmVVcCA/ICdwb2ludGVyJyA6ICdub3QtYWxsb3dlZCc7XHJcbiAgICAgICAgICAgIGRvd24uc3R5bGUuY3Vyc29yID0gY2hlY2suY2FuTW92ZURvd24gPyAncG9pbnRlcicgOiAnbm90LWFsbG93ZWQnO1xyXG4gICAgICAgICAgICBsZWZ0LnN0eWxlLmN1cnNvciA9IGNoZWNrLmNhbk1vdmVMZWZ0ID8gJ3BvaW50ZXInIDogJ25vdC1hbGxvd2VkJztcclxuICAgICAgICAgICAgcmlnaHQuc3R5bGUuY3Vyc29yID0gY2hlY2suY2FuTW92ZVJpZ2h0ID8gJ3BvaW50ZXInIDogJ25vdC1hbGxvd2VkJztcclxuXHJcbiAgICAgICAgICAgIHVwLnN0eWxlLm9wYWNpdHkgPSBjaGVjay5jYW5Nb3ZlVXAgPyAnJyA6ICcwLjAzJztcclxuICAgICAgICAgICAgZG93bi5zdHlsZS5vcGFjaXR5ID0gY2hlY2suY2FuTW92ZURvd24gPyAnJyA6ICcwLjAzJztcclxuICAgICAgICAgICAgbGVmdC5zdHlsZS5vcGFjaXR5ID0gY2hlY2suY2FuTW92ZUxlZnQgPyAnJyA6ICcwLjAzJztcclxuICAgICAgICAgICAgcmlnaHQuc3R5bGUub3BhY2l0eSA9IGNoZWNrLmNhbk1vdmVSaWdodCA/ICcnIDogJzAuMDMnO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIF9yZWZyZXNoU3BsaXR0ZXJzU3RhdGUgKCkge1xyXG4gICAgICAgIGNvbnN0IGFjdGl2ZUZyYW1lcyA9IF92aWV3RnJhbWVzLmZpbHRlcih2ZiA9PiB2Zi5hY3RpdmUpXHJcbiAgICAgICAgLnNvcnQoKGEsYikgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBwb3NBID0gYS5wb3NpdGlvbjtcclxuICAgICAgICAgICAgY29uc3QgcG9zQiA9IGIucG9zaXRpb247XHJcbiAgICAgICAgICAgIGlmIChfZ3JhcGhPcmllbnRhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvc0EueCAtIHBvc0IueDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwb3NBLnkgLSBwb3NCLnk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCBhY3RpdmVJZHMgPSBhY3RpdmVGcmFtZXMubWFwKHZmID0+IHZmLmlkKTtcclxuXHJcbiAgICAgICAgaWYgKF9vcmllbnRhdGlvbikge1xyXG4gICAgICAgICAgICBfc3BsaXR0ZXJzLmZvckVhY2goc3BsaXR0ZXIgPT4ge1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlU3BsaXR0ZXIoc3BsaXR0ZXIpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gX3NwbGl0dGVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlU3BsaXR0ZXIoX3NwbGl0dGVyc1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVNwbGl0dGVyIChzcGxpdHRlcikge1xyXG4gICAgICAgICAgICBpZiAoc3BsaXR0ZXIubW9kZWwudmlld0ZyYW1lQS5hY3RpdmUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5laWdoYm91ciA9IGdldE5laWdoYm91cihzcGxpdHRlci5tb2RlbC52aWV3RnJhbWVBLmlkKTtcclxuICAgICAgICAgICAgICAgIGlmICghbmVpZ2hib3VyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3BsaXR0ZXIuaGlkZSgpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzcGxpdHRlci51cGRhdGVOZWlnaGJvdXIobmVpZ2hib3VyKTtcclxuICAgICAgICAgICAgICAgICAgICBzcGxpdHRlci5zaG93KCk7XHJcbiAgICAgICAgICAgICAgICB9ICBcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHNwbGl0dGVyLmhpZGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gZ2V0TmVpZ2hib3VyICh2aWV3RnJhbWVJZCkge1xyXG4gICAgICAgICAgICBpZiAoIXZpZXdGcmFtZUlkKSByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBhY3RpdmVJZHMuaW5kZXhPZih2aWV3RnJhbWVJZCk7XHJcbiAgICAgICAgICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgYWN0aXZlSWRzLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhY3RpdmVGcmFtZXNbaW5kZXggKyAxXTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBkZWZhdWx0IFZpZXdGcmFtZXNVSTtcclxuIiwiaW1wb3J0IHsgdW5pcXVlSWQsIGNsb25lLCBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xyXG5pbXBvcnQgeyBOb2RlLCBMaW5rLCBHcmFwaE5vZGUsIEdyYXBoTGluaywgR3JhcGhDcm9zc05vZGUsIEdyYXBoQ3Jvc3NMaW5rIH0gZnJvbSAnLi9tYXBFbGVtZW50cyc7XHJcbmltcG9ydCB7IFJlc291cmNlUHJvdmlkZXIgfSBmcm9tICcuLi8uLi9kYXRhL3Jlc291cmNlUHJvdmlkZXInO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHByb2Nlc3NEYXRhIChyYXdEYXRhLCBwYXJhbWV0ZXJzKSB7XHJcbiAgICBjb25zdCB0b3BOb2RlTW9kZWxzID0gcHJvY2Vzc05vZGVzKHJhd0RhdGEubm9kZXMsIHBhcmFtZXRlcnMpO1xyXG4gICAgY29uc3QgZGVyaXZhdGlvbk1hcE5vZGVzID0gY3JlYXRlRGlhZ3JhbU5vZGVzKHRvcE5vZGVNb2RlbHMsIHBhcmFtZXRlcnMpO1xyXG5cclxuICAgIGNvbnN0IG1hcExpbmtNb2RlbHMgPSBwcm9jZXNzTGlua3MocmF3RGF0YS5lZGdlcywgZGVyaXZhdGlvbk1hcE5vZGVzKTtcclxuICAgIC8vIENyZWF0ZSBmYWtlIGxpbmsgaWYgdGhlcmUgYXJlIG5vIGxpbmtzIGF0IGFsbCAoaXQgbWVhbnMgd2UgaGF2ZSBhIHByb2JsZW0gd2l0aCBhIGRhdGEpXHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgaWYgKG1hcExpbmtNb2RlbHMubGVuZ3RoID09PSAwICYmIHRvcE5vZGVNb2RlbHMubGVuZ3RoID09PSAyKSB7XHJcbiAgICAgICAgY29uc3QgdG9wSWRzID0gdG9wTm9kZU1vZGVscy5tYXAodG0gPT4gdG0uaWQpO1xyXG4gICAgICAgIGNvbnN0IHRvcFZpZXdzID0gZGVyaXZhdGlvbk1hcE5vZGVzLmZpbHRlcihuID0+IHRvcElkcy5pbmRleE9mKG4uaWQpICE9PSAtMSk7XHJcbiAgICAgICAgbWFwTGlua01vZGVscy5wdXNoKHtcclxuICAgICAgICAgICAgc291cmNlOiB0b3BWaWV3c1swXSxcclxuICAgICAgICAgICAgdGFyZ2V0OiB0b3BWaWV3c1sxXSxcclxuICAgICAgICAgICAgbGFiZWw6ICcnLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIGNvbnN0IGZpbmFsTGlua01vZGVscyA9IGdyb3VwTGlua3MobWFwTGlua01vZGVscywgcGFyYW1ldGVycyk7XHJcbiAgICBjb25zdCBkZXJpdmF0aW9uTWFwTGlua3MgPSBmaW5hbExpbmtNb2RlbHMubWFwKG1vZGVsID0+IG5ldyBMaW5rKG1vZGVsLCBwYXJhbWV0ZXJzKSk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGVsZW1lbnRzOiBkZXJpdmF0aW9uTWFwTm9kZXMsXHJcbiAgICAgICAgbGlua3M6IGRlcml2YXRpb25NYXBMaW5rcyxcclxuICAgIH07XHJcbn1cclxuZXhwb3J0IGRlZmF1bHQgcHJvY2Vzc0RhdGE7XHJcblxyXG5mdW5jdGlvbiBwcm9jZXNzTGlua3MgKHJhd0xpbmtzLCBkZXJpdmF0aW9uTWFwTm9kZXMpIHtcclxuICAgIGlmICghcmF3TGlua3MpIHJldHVybiBbXTtcclxuIFxyXG4gICAgY29uc3Qgbm9kZU1hcCA9IHt9O1xyXG4gICAgZGVyaXZhdGlvbk1hcE5vZGVzLmZvckVhY2gobm9kZSA9PiB7XHJcbiAgICAgICAgaWYgKG5vZGVNYXBbbm9kZS5lbmRwb2ludElkXSkge1xyXG4gICAgICAgICAgICBub2RlTWFwW25vZGUuZW5kcG9pbnRJZF0ucHVzaChub2RlKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBub2RlTWFwW25vZGUuZW5kcG9pbnRJZF0gPSBbbm9kZV07XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gY29uc3QgZXhpc3RpbmdMaW5rcyA9IHt9O1xyXG4gICAgLy8gcmF3TGlua3MuZm9yRWFjaChsaW5rID0+IHtcclxuICAgIC8vICAgICAobm9kZU1hcFtsaW5rLnNvdXJjZV0gfHwgW10pLmZvckVhY2goc291cmNlID0+IHtcclxuICAgIC8vICAgICAgICAgKG5vZGVNYXBbbGluay50YXJnZXRdIHx8IFtdKS5mb3JFYWNoKHRhcmdldCA9PiB7XHJcbiAgICAvLyAgICAgICAgICAgICBpZiAoIShleGlzdGluZ0xpbmtzW3NvdXJjZS5pZF0gJiYgZXhpc3RpbmdMaW5rc1tzb3VyY2UuaWRdW3RhcmdldC5pZF0pKSB7XHJcbiAgICAvLyAgICAgICAgICAgICAgICAgY29uc3QgZmluYWxMaW5rID0ge1xyXG4gICAgLy8gICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcclxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXHJcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBsaW5rLmxhYmVsIHx8IGdldExhYmVsRnJvbUlkKGxpbmsuaWQpLFxyXG4gICAgLy8gICAgICAgICAgICAgICAgICAgICB0eXBlSWQ6IGxpbmsuaWQsXHJcbiAgICAvLyAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAvLyAgICAgICAgICAgICAgICAgW3NvdXJjZS5pZF0uY29uY2F0KHNvdXJjZS5vcmRlcmVkUG9zc2libGVJZHMpLmZvckVhY2goc291cmNlSWQgPT4ge1xyXG4gICAgLy8gICAgICAgICAgICAgICAgICAgICBpZiAoIWV4aXN0aW5nTGlua3Nbc291cmNlSWRdKSBleGlzdGluZ0xpbmtzW3NvdXJjZUlkXSA9IHt9O1xyXG4gICAgLy8gICAgICAgICAgICAgICAgICAgICBbdGFyZ2V0LmlkXS5jb25jYXQodGFyZ2V0Lm9yZGVyZWRQb3NzaWJsZUlkcykuZm9yRWFjaCh0YXJnZXRJZCA9PiB7XHJcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZ0xpbmtzW3NvdXJjZUlkXVt0YXJnZXRJZF0gPSBmaW5hbExpbms7XHJcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgLy8gICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgLy8gICAgICAgICAgICAgfVxyXG4gICAgLy8gICAgICAgICB9KTtcclxuICAgIC8vICAgICB9KTtcclxuICAgIC8vIH0pO1xyXG5cclxuICAgIC8vIGNvbnN0IGxpbmtzID0gW107XHJcbiAgICAvLyBPYmplY3Qua2V5cyhleGlzdGluZ0xpbmtzKS5mb3JFYWNoKHNvdXJjZUlkID0+IHtcclxuICAgIC8vICAgICBPYmplY3Qua2V5cyhleGlzdGluZ0xpbmtzW3NvdXJjZUlkXSkuZm9yRWFjaCh0YXJnZXRJZCA9PiB7XHJcbiAgICAvLyAgICAgICAgIGNvbnN0IGxpbmsgPSBleGlzdGluZ0xpbmtzW3NvdXJjZUlkXVt0YXJnZXRJZF07XHJcbiAgICAvLyAgICAgICAgIGlmIChsaW5rcy5pbmRleE9mKGxpbmspID09PSAtMSkge1xyXG4gICAgLy8gICAgICAgICAgICAgbGlua3MucHVzaChsaW5rKTtcclxuICAgIC8vICAgICAgICAgfVxyXG4gICAgLy8gICAgIH0pO1xyXG4gICAgLy8gfSk7XHJcblxyXG4gICAgY29uc3QgdW5pcU1hcCA9IHt9O1xyXG4gICAgY29uc3QgbGlua3MgPSBbXTtcclxuICAgIHJhd0xpbmtzLmZvckVhY2gobGluayA9PiB7XHJcbiAgICAgICAgY29uc3Qgc291cmNlcyA9IG5vZGVNYXBbbGluay5zb3VyY2VdO1xyXG4gICAgICAgIGNvbnN0IHRhcmdldHMgPSBub2RlTWFwW2xpbmsudGFyZ2V0XTtcclxuICAgICAgICBpZiAoc291cmNlcyAmJiB0YXJnZXRzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxpbmtJZCA9IGNhY2hlRnVuY3Rpb24obGluayk7XHJcbiAgICAgICAgICAgIGlmICghdW5pcU1hcFtsaW5rSWRdKSB7XHJcbiAgICAgICAgICAgICAgICB1bmlxTWFwW2xpbmtJZF0gPSBsaW5rO1xyXG4gICAgICAgICAgICAgICAgc291cmNlcy5mb3JFYWNoKHNvdXJjZSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0cy5mb3JFYWNoKHRhcmdldCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IHRhcmdldCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBsaW5rLmxhYmVsIHx8IGdldExhYmVsRnJvbUlkKGxpbmsuaWQpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZUlkOiBsaW5rLmlkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIGxpbmtzO1xyXG5cclxuICAgIGZ1bmN0aW9uIGNhY2hlRnVuY3Rpb24gKHJhd0xpbmspIHtcclxuICAgICAgICByZXR1cm4gYCR7cmF3TGluay5zb3VyY2V9fiN0cURNTGluayN+JHtyYXdMaW5rLnRhcmdldH1gO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBncm91cExpbmtzIChsaW5rTW9kZWxzLCBwYXJhbWV0ZXJzKSB7XHJcbiAgICBjb25zdCBncm91cHNCeVNvdXJjZSA9IHt9O1xyXG4gICAgY29uc3QgZ3JvdXBzQnlUYXJnZXQgPSB7fTtcclxuXHJcbiAgICBsaW5rTW9kZWxzLmZvckVhY2gobGlua01vZGVsID0+IHtcclxuICAgICAgICBjb25zdCB0eXBlSWQgPSBsaW5rTW9kZWwudHlwZUlkIHx8IGxpbmtNb2RlbC5sYWJlbDtcclxuICAgICAgICBjb25zdCBzb3VyY2VDYWNoZUlkID0gY2FjaGVGdW5jdGlvbih0eXBlSWQsIGxpbmtNb2RlbC5zb3VyY2UuaWQpO1xyXG4gICAgICAgIGlmICghZ3JvdXBzQnlTb3VyY2Vbc291cmNlQ2FjaGVJZF0pIHtcclxuICAgICAgICAgICAgZ3JvdXBzQnlTb3VyY2Vbc291cmNlQ2FjaGVJZF0gPSBbXTtcclxuICAgICAgICAgICAgZ3JvdXBzQnlTb3VyY2Vbc291cmNlQ2FjaGVJZF0uc291cmNlID0gbGlua01vZGVsLnNvdXJjZTtcclxuICAgICAgICAgICAgZ3JvdXBzQnlTb3VyY2Vbc291cmNlQ2FjaGVJZF0ubGFiZWwgPSBsaW5rTW9kZWwubGFiZWw7XHJcbiAgICAgICAgICAgIGdyb3Vwc0J5U291cmNlW3NvdXJjZUNhY2hlSWRdLnR5cGVJZCA9IHR5cGVJZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZ3JvdXBzQnlTb3VyY2Vbc291cmNlQ2FjaGVJZF0ucHVzaChsaW5rTW9kZWwpO1xyXG5cclxuICAgICAgICBjb25zdCB0YXJnZXRDYWNoZUlkID0gY2FjaGVGdW5jdGlvbih0eXBlSWQsIGxpbmtNb2RlbC50YXJnZXQuaWQpO1xyXG4gICAgICAgIGlmICghZ3JvdXBzQnlUYXJnZXRbdGFyZ2V0Q2FjaGVJZF0pIHtcclxuICAgICAgICAgICAgZ3JvdXBzQnlUYXJnZXRbdGFyZ2V0Q2FjaGVJZF0gPSBbXTtcclxuICAgICAgICAgICAgZ3JvdXBzQnlUYXJnZXRbdGFyZ2V0Q2FjaGVJZF0udGFyZ2V0ID0gbGlua01vZGVsLnRhcmdldDtcclxuICAgICAgICAgICAgZ3JvdXBzQnlUYXJnZXRbdGFyZ2V0Q2FjaGVJZF0ubGFiZWwgPSBsaW5rTW9kZWwubGFiZWw7XHJcbiAgICAgICAgICAgIGdyb3Vwc0J5VGFyZ2V0W3RhcmdldENhY2hlSWRdLnR5cGVJZCA9IHR5cGVJZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZ3JvdXBzQnlUYXJnZXRbdGFyZ2V0Q2FjaGVJZF0ucHVzaChsaW5rTW9kZWwpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgT2JqZWN0LmtleXMoZ3JvdXBzQnlTb3VyY2UpLmZvckVhY2goZ3JvdXBJZCA9PiB7XHJcbiAgICAgICAgY29uc3QgZ3JvdXAgPSBncm91cHNCeVNvdXJjZVtncm91cElkXTtcclxuICAgICAgICBjb25zdCBjcm9zc2VkRWxlbWVudHMgPSBncm91cC5sZW5ndGggPiAxID8gZ3JvdXAgOiBbXTtcclxuICAgICAgICBjb25zdCBjcm9zc05vZGUgPSBuZXcgR3JhcGhDcm9zc05vZGUoe2Nyb3NzZWRFbGVtZW50czogY3Jvc3NlZEVsZW1lbnRzfSk7XHJcbiAgICAgICAgY29uc3Qgc291cmNlTGluayA9IG5ldyBHcmFwaExpbmsoe1xyXG4gICAgICAgICAgICBzb3VyY2U6IGdyb3VwLnNvdXJjZSxcclxuICAgICAgICAgICAgdGFyZ2V0OiBjcm9zc05vZGUsXHJcbiAgICAgICAgICAgIGxhYmVsOiBncm91cC5sYWJlbCxcclxuICAgICAgICAgICAgdHlwZUlkOiBncm91cC50eXBlSWQsXHJcbiAgICAgICAgICAgIGNyb3NzZWRFbGVtZW50czogY3Jvc3NlZEVsZW1lbnRzLFxyXG4gICAgICAgIH0sIHBhcmFtZXRlcnMpO1xyXG4gICAgICAgIGNyb3NzZWRFbGVtZW50cy5mb3JFYWNoKGxpbmtNb2RlbCA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldExpbmsgPSBuZXcgR3JhcGhDcm9zc0xpbmsoe1xyXG4gICAgICAgICAgICAgICAgdHlwZUlkOiBncm91cC50eXBlSWQsXHJcbiAgICAgICAgICAgICAgICBzb3VyY2U6IGNyb3NzTm9kZSxcclxuICAgICAgICAgICAgICAgIHRhcmdldDogbGlua01vZGVsLnRhcmdldCxcclxuICAgICAgICAgICAgICAgIGxhYmVsOiAnJyxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGxpbmtNb2RlbC5ncmFwaFByaW1pdGl2ZXMgPSBbXHJcbiAgICAgICAgICAgICAgICBjcm9zc05vZGUsIHNvdXJjZUxpbmssIHRhcmdldExpbmssXHJcbiAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgIGxpbmtNb2RlbC5ncm91cGVkQnkgPSAnc291cmNlJztcclxuICAgICAgICB9LCBwYXJhbWV0ZXJzKTtcclxuICAgIH0pO1xyXG5cclxuICAgIE9iamVjdC5rZXlzKGdyb3Vwc0J5VGFyZ2V0KS5mb3JFYWNoKGdyb3VwSWQgPT4ge1xyXG4gICAgICAgIGNvbnN0IGdyb3VwID0gZ3JvdXBzQnlUYXJnZXRbZ3JvdXBJZF07XHJcbiAgICAgICAgY29uc3QgY3Jvc3NlZEVsZW1lbnRzID0gZ3JvdXAubGVuZ3RoID4gMSA/IGdyb3VwLmZpbHRlcihsaW5rTW9kZWwgPT4gIWxpbmtNb2RlbC5ncmFwaFByaW1pdGl2ZXMpIDogW107XHJcbiAgICAgICAgY29uc3QgY3Jvc3NOb2RlID0gbmV3IEdyYXBoQ3Jvc3NOb2RlKHtjcm9zc2VkRWxlbWVudHM6IGNyb3NzZWRFbGVtZW50c30pO1xyXG4gICAgICAgIGNvbnN0IHRhcmdldExpbmsgPSBuZXcgR3JhcGhDcm9zc0xpbmsoe1xyXG4gICAgICAgICAgICBzb3VyY2U6IGNyb3NzTm9kZSxcclxuICAgICAgICAgICAgdGFyZ2V0OiBncm91cC50YXJnZXQsXHJcbiAgICAgICAgICAgIGxhYmVsOiBncm91cC5sYWJlbCxcclxuICAgICAgICAgICAgdHlwZUlkOiBncm91cC50eXBlSWQsXHJcbiAgICAgICAgICAgIGNyb3NzZWRFbGVtZW50czogY3Jvc3NlZEVsZW1lbnRzLFxyXG4gICAgICAgIH0sIHBhcmFtZXRlcnMpO1xyXG4gICAgICAgIGNyb3NzZWRFbGVtZW50cy5mb3JFYWNoKGxpbmtNb2RlbCA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZUxpbmsgPSBuZXcgR3JhcGhMaW5rKHtcclxuICAgICAgICAgICAgICAgIHR5cGVJZDogZ3JvdXAudHlwZUlkLFxyXG4gICAgICAgICAgICAgICAgc291cmNlOiBsaW5rTW9kZWwuc291cmNlLFxyXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBjcm9zc05vZGUsXHJcbiAgICAgICAgICAgICAgICBsYWJlbDogJycsXHJcbiAgICAgICAgICAgIH0sIHBhcmFtZXRlcnMpO1xyXG4gICAgICAgICAgICBsaW5rTW9kZWwuZ3JhcGhQcmltaXRpdmVzID0gW1xyXG4gICAgICAgICAgICAgICAgY3Jvc3NOb2RlLCBzb3VyY2VMaW5rLCB0YXJnZXRMaW5rLFxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICBsaW5rTW9kZWwuZ3JvdXBlZEJ5ID0gJ3RhcmdldCc7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gbGlua01vZGVscztcclxuXHJcbiAgICBmdW5jdGlvbiBjYWNoZUZ1bmN0aW9uIChsYWJlbCwgdGVybWluYWxJZCkge1xyXG4gICAgICAgIHJldHVybiBgJHtsYWJlbH1+I3RxRE1MaW5rI34ke3Rlcm1pbmFsSWR9YDtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gcHJvY2Vzc05vZGVzIChyYXdOb2RlcywgcGFyYW1ldGVycykge1xyXG4gICAgY29uc3QgdG9wTm9kZXNNYXAgPSB7fTtcclxuICAgIGNvbnN0IGFsbE5vZGVzTWFwID0ge307XHJcbiAgICBjb25zdCBwYXJlbnRNYXAgPSB7fTtcclxuICAgIGNvbnN0IHJlcyA9IG5ldyBSZXNvdXJjZVByb3ZpZGVyKHBhcmFtZXRlcnMpO1xyXG5cclxuICAgIHJhd05vZGVzLmZvckVhY2gocmF3Tm9kZSA9PiB7XHJcbiAgICAgICAgaWYgKHJhd05vZGUuaWQpIHtcclxuICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBwYXJlbnRNYXBbcmF3Tm9kZS5pZF07XHJcbiAgICAgICAgICAgIGNvbnN0IHR5cGVJY29uID0gcmVzLmdldEljb24ocmF3Tm9kZS50eXBlKTtcclxuICAgICAgICAgICAgY29uc3QgbW9kZWwgPSBhbGxOb2Rlc01hcFtyYXdOb2RlLmlkXSB8fCBjcmVhdGVNb2RlbChyYXdOb2RlLCBjaGlsZHJlbiwgdHlwZUljb24pO1xyXG4gICAgICAgICAgICBhbGxOb2Rlc01hcFtyYXdOb2RlLmlkXSA9IG1vZGVsO1xyXG4gICAgICAgICAgICBkZWxldGUgcGFyZW50TWFwW3Jhd05vZGUuaWRdO1xyXG5cclxuICAgICAgICAgICAgaWYgKHJhd05vZGUucGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYWxsTm9kZXNNYXBbcmF3Tm9kZS5wYXJlbnRdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWxsTm9kZXNNYXBbcmF3Tm9kZS5wYXJlbnRdLmNoaWxkcmVuLnB1c2gobW9kZWwpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcmVudE1hcFtyYXdOb2RlLnBhcmVudF0pIHBhcmVudE1hcFtyYXdOb2RlLnBhcmVudF0gPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRNYXBbcmF3Tm9kZS5wYXJlbnRdLnB1c2gobW9kZWwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCF0b3BOb2Rlc01hcFtyYXdOb2RlLmlkXSkge1xyXG4gICAgICAgICAgICAgICAgdG9wTm9kZXNNYXBbcmF3Tm9kZS5pZF0gPSBtb2RlbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIFByb2Nlc3Mgb3JwaGFuIG5vZGVzLlxyXG4gICAgLy8gVGhlcmUgd2VyZSBsaW5rcyB0byB0aGVtIGJ1dCBubyBkZWZlbml0aW9ucy5cclxuICAgIE9iamVjdC5rZXlzKHBhcmVudE1hcCkuZm9yRWFjaChpZCA9PiB7XHJcbiAgICAgICAgdG9wTm9kZXNNYXBbaWRdID0gY3JlYXRlTW9kZWwoe1xyXG4gICAgICAgICAgICBpZDogaWQsXHJcbiAgICAgICAgICAgIGxhYmVsOiBnZXRMYWJlbEZyb21JZChpZCksXHJcbiAgICAgICAgICAgIGNoaWxkcmVuOiBwYXJlbnRNYXBbaWRdLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgdG9wTm9kZXMgPSBPYmplY3Qua2V5cyh0b3BOb2Rlc01hcCkubWFwKGtleSA9PiB0b3BOb2Rlc01hcFtrZXldKTtcclxuXHJcbiAgICAvLyByZW1vdmUgY3ljbGVzXHJcbiAgICBjb25zdCBwcm9jZXNzZWROb2Rlc01hcCA9IHt9O1xyXG4gICAgZnVuY3Rpb24gcmVjdXJzaW9uIChyb290Tm9kZSkge1xyXG4gICAgICAgIGNvbnN0IGNoaWxkcmVuSWRzID0ge307XHJcbiAgICAgICAgcm9vdE5vZGUuY2hpbGRyZW4gPSByb290Tm9kZS5jaGlsZHJlbi5maWx0ZXIoY2hpbGQgPT4ge1xyXG4gICAgICAgICAgICBpZiAoKCFwcm9jZXNzZWROb2Rlc01hcFtjaGlsZC5pZF0pICYmICghY2hpbGRyZW5JZHNbY2hpbGQuaWRdKSkge1xyXG4gICAgICAgICAgICAgICAgY2hpbGRyZW5JZHNbY2hpbGQuaWRdID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHByb2Nlc3NlZE5vZGVzTWFwW2NoaWxkLmlkXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICByZWN1cnNpb24oY2hpbGQpO1xyXG4gICAgICAgICAgICAgICAgcHJvY2Vzc2VkTm9kZXNNYXBbY2hpbGQuaWRdID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0b3BOb2Rlcy5maWx0ZXIodG9wID0+IHtcclxuICAgICAgICBpZiAoIXByb2Nlc3NlZE5vZGVzTWFwW3RvcC5pZF0pIHtcclxuICAgICAgICAgICAgcHJvY2Vzc2VkTm9kZXNNYXBbdG9wLmlkXSA9IHRydWU7XHJcbiAgICAgICAgICAgIHJlY3Vyc2lvbih0b3ApO1xyXG4gICAgICAgICAgICBwcm9jZXNzZWROb2Rlc01hcFt0b3AuaWRdID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlTW9kZWwgKHJhd05vZGUsIGNoaWxkcmVuLCB0eXBlSWNvbikge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBpZDogdW5pcXVlSWQoJ21hcEVsZW1lbnQnKSxcclxuICAgICAgICBlbmRwb2ludElkOiByYXdOb2RlLmlkLFxyXG4gICAgICAgIGxhYmVsOiByYXdOb2RlLmxhYmVsIHx8IGdldExhYmVsRnJvbUlkKHJhd05vZGUuaWQpLFxyXG4gICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlbiB8fCBbXSxcclxuICAgICAgICByZXNvdXJjZVR5cGU6IHJhd05vZGUucmVzb3VyY2VUeXBlIHx8ICd1bmRlZmluZWQnLFxyXG4gICAgICAgIHJlc291cmNlOiByYXdOb2RlLnJlc291cmNlIHx8ICd1bmRlZmluZWQnLFxyXG4gICAgICAgIHR5cGU6IHJhd05vZGUudHlwZSB8fCAndW5kZWZpbmVkJyxcclxuICAgICAgICBjb2xsYXBzZWQ6IHJhd05vZGUuY29sbGFwc2VkLFxyXG4gICAgICAgIGljb246IHJhd05vZGUuaWNvbiB8fCB0eXBlSWNvbixcclxuICAgIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZURpYWdyYW1Ob2RlcyAodG9wTm9kZU1vZGVscywgcGFyYW1ldGVycykge1xyXG4gICAgY29uc3QgZGVyaXZhdGlvbk1hcE5vZGVzID0gW107XHJcblxyXG4gICAgZnVuY3Rpb24gY29weSAoZWxlbWVudCwgZHVibGljYXRpb25NYXApIHtcclxuICAgICAgICBjb25zdCBkdWJsaWNhdGlvbiA9IGR1YmxpY2F0aW9uTWFwIHx8IHt9O1xyXG4gICAgICAgIGlmICghZHVibGljYXRpb25bZWxlbWVudC5pZF0pIHtcclxuICAgICAgICAgICAgY29uc3QgY2xvbmVkRWxlbWVudCA9IGNsb25lKGVsZW1lbnQpO1xyXG4gICAgICAgICAgICBjbG9uZWRFbGVtZW50LmlkID0gdW5pcXVlSWQoJ2NvcHlPZk1hcEVsZW1lbnQnKTtcclxuXHJcbiAgICAgICAgICAgIGR1YmxpY2F0aW9uW2VsZW1lbnQuaWRdID0gY2xvbmVkRWxlbWVudDtcclxuICAgICAgICAgICAgY2xvbmVkRWxlbWVudC5jaGlsZHJlbiA9IGVsZW1lbnQuY2hpbGRyZW4ubWFwKGNoaWxkID0+IGNvcHkoY2hpbGQsIGR1YmxpY2F0aW9uKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkdWJsaWNhdGlvbltlbGVtZW50LmlkXTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVHcm91cCAobW9kZWwxLCBtb2RlbDIpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBpZDogdW5pcXVlSWQoJ0dyb3VwJyksXHJcbiAgICAgICAgICAgIGxhYmVsOiAnR3JvdXAnLFxyXG4gICAgICAgICAgICBlbmRwb2ludElkOiAnbm9uZScsXHJcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbIG1vZGVsMSwgbW9kZWwyIF0sXHJcbiAgICAgICAgICAgIHN5bnRoZXRpYzogdHJ1ZSxcclxuICAgICAgICAgICAgY29sbGFwc2VkOiB0cnVlLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYWRkVG9Hcm91cCAoZ3JvdXAsIG1vZGVsKSB7XHJcbiAgICAgICAgZ3JvdXAuY2hpbGRyZW4ucHVzaChtb2RlbCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gaWYgdGhlcmUgaXMgbW9yZSB0aGVuIG9uZSB0b3BFbGVtZW50IGZvciBzb21lIG1vZGVsXHJcbiAgICBjb25zdCB0b3BFbGVtZW50Rm9ySWQgPSB7fTtcclxuICAgIGNvbnN0IGZpbHRlcmVkVG9wTW9kZWxzID0ge307XHJcbiAgICB0b3BOb2RlTW9kZWxzLmZvckVhY2godG9wRWxlbWVudCA9PiB7XHJcbiAgICAgICAgcmVjdXJzaW9uKHRvcEVsZW1lbnQpO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiByZWN1cnNpb24gKGN1ck1vZGVsKSB7XHJcbiAgICAgICAgICAgIGlmICh0b3BFbGVtZW50Rm9ySWRbY3VyTW9kZWwuaWRdKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRvcEVsZW1lbnRGb3JJZFtjdXJNb2RlbC5pZF0uc3ludGhldGljICYmIHRvcEVsZW1lbnQuaWQgIT09IHRvcEVsZW1lbnRGb3JJZFtjdXJNb2RlbC5pZF0uaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgZmlsdGVyZWRUb3BNb2RlbHNbdG9wRWxlbWVudC5pZF07XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGZpbHRlcmVkVG9wTW9kZWxzW3RvcEVsZW1lbnRGb3JJZFtjdXJNb2RlbC5pZF0uaWRdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB0b3BFbGVtZW50Rm9ySWRbY3VyTW9kZWwuaWRdID0gY3JlYXRlR3JvdXAodG9wRWxlbWVudEZvcklkW2N1ck1vZGVsLmlkXSwgdG9wRWxlbWVudCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcmVkVG9wTW9kZWxzW3RvcEVsZW1lbnRGb3JJZFtjdXJNb2RlbC5pZF0uaWRdID0gdG9wRWxlbWVudEZvcklkW2N1ck1vZGVsLmlkXTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkVG9Hcm91cCh0b3BFbGVtZW50Rm9ySWRbY3VyTW9kZWwuaWRdLCB0b3BFbGVtZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBjb3B5KGN1ck1vZGVsKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRvcEVsZW1lbnRGb3JJZFtjdXJNb2RlbC5pZF0gPSB0b3BFbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgZmlsdGVyZWRUb3BNb2RlbHNbdG9wRWxlbWVudC5pZF0gPSB0b3BFbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgY3VyTW9kZWwuY2hpbGRyZW4gPSBjdXJNb2RlbC5jaGlsZHJlbi5tYXAoXHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQgPT4gcmVjdXJzaW9uKGNoaWxkKSxcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VyTW9kZWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBPYmplY3Qua2V5cyhmaWx0ZXJlZFRvcE1vZGVscykuZm9yRWFjaCh0b3BFbGVtZW50SWQgPT4ge1xyXG4gICAgICAgIGNvbnN0IHRvcEVsZW1lbnQgPSBmaWx0ZXJlZFRvcE1vZGVsc1t0b3BFbGVtZW50SWRdO1xyXG5cclxuICAgICAgICBjb25zdCBncmFwaE5vZGUgPSBuZXcgR3JhcGhOb2RlKHRvcEVsZW1lbnQsIHBhcmFtZXRlcnMpO1xyXG4gICAgICAgIGNvbnN0IHByb2Nlc3NlZE5vZGVzID0ge307XHJcbiAgICAgICAgcmVjdXJzaW9uKHRvcEVsZW1lbnQsIFtdKTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcmVjdXJzaW9uIChjdXJNb2RlbCwgcG9zc2libGVJZHMpIHtcclxuICAgICAgICAgICAgaWYgKCFwcm9jZXNzZWROb2Rlc1tjdXJNb2RlbC5pZF0pIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1vZGVsID0gY2xvbmVEZWVwKGN1ck1vZGVsKTtcclxuICAgICAgICAgICAgICAgIG1vZGVsLm9yZGVyZWRQb3NzaWJsZUlkcyA9IHBvc3NpYmxlSWRzO1xyXG4gICAgICAgICAgICAgICAgbW9kZWwuZ3JhcGhOb2RlID0gZ3JhcGhOb2RlO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBwcm9jZXNzZWROb2Rlc1tjdXJNb2RlbC5pZF0gPSBuZXcgTm9kZShtb2RlbCwgcGFyYW1ldGVycyk7XHJcbiAgICAgICAgICAgICAgICBwcm9jZXNzZWROb2Rlc1tjdXJNb2RlbC5pZF0uY2hpbGRyZW4gPSBjdXJNb2RlbC5jaGlsZHJlbi5tYXAoXHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQgPT4gcmVjdXJzaW9uKGNoaWxkLCBwb3NzaWJsZUlkcy5jb25jYXQoW2N1ck1vZGVsLmlkXSkpLFxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIGRlcml2YXRpb25NYXBOb2Rlcy5wdXNoKHByb2Nlc3NlZE5vZGVzW2N1ck1vZGVsLmlkXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHByb2Nlc3NlZE5vZGVzW2N1ck1vZGVsLmlkXTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gZGVyaXZhdGlvbk1hcE5vZGVzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRMYWJlbEZyb21JZCAoaWQpIHtcclxuICAgIGNvbnN0IHRlcm1zID0gaWQuc3BsaXQoJy8nKTtcclxuICAgIGNvbnN0IHNsYXNoTGFiZWwgPSB0ZXJtc1t0ZXJtcy5sZW5ndGggLSAxXTtcclxuICAgIGlmIChzbGFzaExhYmVsKSB7XHJcbiAgICAgICAgcmV0dXJuIHNsYXNoTGFiZWw7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IGhhc2hJbmRleCA9IGlkLmluZGV4T2YoJyMnKTtcclxuICAgICAgICBpZiAoaGFzaEluZGV4ICE9PSAtMSkge1xyXG4gICAgICAgICAgICBjb25zdCBoYXNoTGFiZWwgPSBpZC5zdWJzdHJpbmcoaGFzaEluZGV4LCBpZC5sZW5ndGggLSAxKTtcclxuICAgICAgICAgICAgcmV0dXJuIGhhc2hMYWJlbDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gaWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCBUUUdyYW1VSSBmcm9tICd2aXN1YWxpemF0aW9ucy1saWJyYXJ5JztcclxuaW1wb3J0ICogYXMgXyBmcm9tICdsb2Rhc2gnO1xyXG5pbXBvcnQgcHJvY2Vzc0RhdGEgZnJvbSAnLi9kYXRhUHJvY2Vzc2luZyc7XHJcbmltcG9ydCAqIGFzIG1hcEVsZW1lbnRzIGZyb20gJy4vbWFwRWxlbWVudHMnO1xyXG5pbXBvcnQgeyBNYXBMYXlvdXQgfSBmcm9tICcuL21hcExheW91dCc7XHJcbmltcG9ydCB7IERNRGVmYXVsdFVJIH0gZnJvbSAnLi4vLi4vaHRtbFVJL2RtRGVmYXVsdFVJJztcclxuaW1wb3J0IHsgREVGQVVMVF9ERVJJVkFUSU9OX01BUF9MSU5LX1NUWUxFIH0gZnJvbSAnLi4vLi4vZGF0YS9yZXNvdXJjZVByb3ZpZGVyJztcclxuaW1wb3J0IHsgY2hlY2tEbVJhd0RhdGEgfSBmcm9tICcuLi8uLi91dGlscy9kYXRhVXRpbHMnO1xyXG5pbXBvcnQgU3Vic2NyaWJhYmxlIGZyb20gJy4uLy4uL3N1YnNjcmlwdGlvbkFQSS9zdWJzY3JpYmVhYmxlJztcclxuXHJcbi8qKlxyXG4gKiBMaW5rIHN0eWxlIGRlZmluaXRpb24gZm9yIERNXHJcbiAqIEB0eXBlZGVmIHtPYmplY3R9IERNTGlua1N0eWxlRGVmaW5pdGlvblxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gY3NzQ2xhc3MgLSBDU1MgY2xhc3Mgd2hpY2ggd2lsbCBiZSBhdHRhY2hlZCB0byB0aGUgc3ZnIGNvbXBvbmVudFxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbGluZVR5cGUgLSAnc29saWQnIG9yICdkYXNoZWQnXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjb2xvciAtIENvbG9yIG9mIHRoZSBsaW5lXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0ZXh0Q29sb3IgLSBDb2xvciBvZiB0aGUgdGV4dCBvbiB0aGUgbGluZVxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdGV4dEJhY2tncm91bmRDb2xvciAtIENvbG9yIG9mIHRoZSBiYWNrZ3JvdW5kIG9mIHRoZSB0ZXh0IG9uIHRoZSBsaW5lXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0aGlja25lc3NcclxuKi9cclxuXHJcbi8qKlxyXG4gKiBTZXQgb2YgcGFyYW1ldGVycyBmb3IgRGVyaXZhdGlvbiBNYXBcclxuICogQHR5cGVkZWYge09iamVjdH0gRGVyaXZhdGlvbk1hcFBhcmFtZXRlcnNcclxuICogQHByb3BlcnR5IHtPYmplY3QuPHN0cmluZywgTGlua1N0eWxlRGVmaW5pdGlvbj59IGxpbmtTdHlsZXMgLSBNYXAgYmV0d2VlbiB0aGUgbGlua1R5cGVzIGFuZCBMaW5rU3R5bGVzLlxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gZGVmYXVsdEVsZW1lbnRXaWR0aFxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gZGVmYXVsdEVsZW1lbnRIZWlnaHRcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IGRlZmF1bHRMaW5rTGFiZWxMZW5ndGhcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IGRlZmF1bHRMYXlvdXRTdGVwXHJcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGVycm9yQ2FsbEJhY2sgLSBpdCBpcyBjYWxsZWQgaW4gcmVzcG9uc2UgdG8gd2FybmluZ3MgYW5kIGVycm9yc1xyXG4qL1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgZGVmYXVsdCBzZXQgb2YgcGFyYW1ldGVyc1xyXG4gKiBAcmV0dXJucyB7RGVyaXZhdGlvbk1hcFBhcmFtZXRlcnN9XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGVmYXVsdFBhcmFtZXRlcnNTZXQgKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBkZWZhdWx0RWxlbWVudFdpZHRoOiAyNTAsXHJcbiAgICAgICAgZGVmYXVsdEVsZW1lbnRIZWlnaHQ6IDI1MCxcclxuICAgICAgICBkZWZhdWx0TGlua0xhYmVsTGVuZ3RoOiAxMDAsXHJcbiAgICAgICAgZGVmYXVsdExheW91dFN0ZXA6IDE1MCxcclxuICAgICAgICBsaW5rU3R5bGVzOiB7XHJcbiAgICAgICAgICAgICdkZWZhdWx0LWxpbmstc3R5bGUnOiBERUZBVUxUX0RFUklWQVRJT05fTUFQX0xJTktfU1RZTEUsXHJcbiAgICAgICAgICAgIC8vIEV4YW1wbGU6XHJcbiAgICAgICAgICAgIC8vICd0eXBlLWlkLTEyMzQnOiB7XHJcbiAgICAgICAgICAgIC8vICAgICBsaW5lVHlwZTogJ2Rhc2hlZCcsIC8vICdzb2xpZCdcclxuICAgICAgICAgICAgLy8gICAgIGNzc0NsYXNzOiAnY2xhc3MtMTIzJ1xyXG4gICAgICAgICAgICAvLyAgICAgY29sb3I6ICdncmVlbicsXHJcbiAgICAgICAgICAgIC8vICAgICB0ZXh0Q29sb3I6ICdibHVlJyxcclxuICAgICAgICAgICAgLy8gICAgIHRleHRCYWNrZ3JvdW5kQ29sb3I6ICd5ZWxsb3cnLFxyXG4gICAgICAgICAgICAvLyAgICAgdGhpY2tuZXNzOiA1LFxyXG4gICAgICAgICAgICAvLyB9LFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaWNvbnM6IHtcclxuICAgICAgICAgICAgJ1NRTCBzY3JpcHQnOiAnZ2x5cGhpY29uIGdseXBoaWNvbi1jb2cnLFxyXG4gICAgICAgICAgICAnRGF0YWJhc2UgVGFibGUnOiAnZ2x5cGhpY29uIGdseXBoaWNvbi1mb2xkZXItY2xvc2UnLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdG9vbHM6W10sXHJcbiAgICAgICAgZXJyb3JDYWxsQmFjazogdW5kZWZpbmVkLCAvLyBJdCBpcyBjYWxsZWQgaW4gcmVzcG9uc2UgdG8gd2FybmluZ3MgYW5kIGVycm9yc1xyXG4gICAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBjbGFzc1xyXG4gKiBEaXNwbGF5cyBkZXJpdmF0aW9uIHZpZXcgZm9yIHNlbGVjdGVkIGxpbmtcclxuICpcclxuICogQ29uc3RydWN0b3IgcGFyYW1ldGVyczpcclxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gKiBAcGFyYW0ge1xyXG4gKiAgZGF0YVByb3ZpZGVyOiBEYXRhQ29udGFpbmVyXHJcbiAqICByb290RWxlbWVudDogSFRNTEVsZW1lbnRcclxuICogIHJlbGF0aW9uOiB7IHNvdXJjZTogc3RyaW5nLCB0YXJnZXQ6IHN0cmluZyB9XHJcbiAqIH0gb3B0aW9uc1xyXG4gKiBAcGFyYW0ge0Rlcml2YXRpb25NYXBQYXJhbWV0ZXJzfSBwYXJhbWV0ZXJzIC0gcGFyYW1ldGVycyBzZXRcclxuICpcclxuICogUHVibGljIHByb3BlcnRpZXM6XHJcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICogcmVsYXRpb246IHsgc291cmNlOiBzdHJpbmcsIHRhcmdldDogc3RyaW5nIH1cclxuICpcclxuICogUHVibGljIG1ldGhvZHM6XHJcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICogb3BlbldpdGhSZWxhdGlvbiAocmVsYXRpb246IHsgc291cmNlOiBzdHJpbmcsIHRhcmdldDogc3RyaW5nIH0pIC0gSW5pdGlhbGl6ZXMgRE0gZGlhZ3JhbVxyXG4gKiBleHBvcnRUb1N2ZygpXHJcbiAqIGV4cG9ydFRvUG5nKClcclxuICogcmVzZXRGb2N1cygpXHJcbiAqIHpvb21JbigpXHJcbiAqIHpvb21PdXQoKVxyXG4gKiB6b29tVG9GaXQoKVxyXG4gKiBwcmludCgpXHJcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICogb24gKGV2ZW50OiBzdHJpbmcsIGNhbGxiYWNrOiBmdW5jdGlvbik6IHZvaWRcclxuICogdW5zdWJzY3JpYmUgKGNhbGxiYWNrOiBmdW5jdGlvbik6IHZvaWRcclxuICogdHJpZ2dlciAoZXZlbnQ6IHN0cmluZywgcGFyYW1ldGVyczogYW55KTogdm9pZFxyXG4gKlxyXG4gKiBFdmVudHM6XHJcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICogQGZpcmVzIGRpYWdyYW0tc3RhdGUtY2hhbmdlZCAoc3RhdGVJZDogc3RyaW5nKVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIERlcml2YXRpb25NYXAgKHByb3BlcnRpZXMsIHBhcmFtZXRlcnMpIHtcclxuICAgIFN1YnNjcmliYWJsZS5hcHBseSh0aGlzKTtcclxuXHJcbiAgICBjb25zdCBkZWZhdWx0UGFyYW1ldGVyU2V0ID0gZ2V0RGVmYXVsdFBhcmFtZXRlcnNTZXQoKTtcclxuICAgIC8vIE1lcmdpbmcgcGFyYW1ldGVycyBkZWZhdWx0IGFuZCB1c2VyXHJcbiAgICBjb25zdCBfcGFyYW1ldGVycyA9IF8ubWVyZ2UoZGVmYXVsdFBhcmFtZXRlclNldCwgcGFyYW1ldGVycyB8fCB7fSk7XHJcblxyXG4gICAgY29uc3QgX2Vycm9yQ2FsbGJhY2sgPSAoZSkgPT4ge1xyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgICAgX3BhcmFtZXRlcnMuZXJyb3JDYWxsYmFjayAmJlxyXG4gICAgICAgICAgICBfcGFyYW1ldGVycy5lcnJvckNhbGxiYWNrIGluc3RhbmNlb2YgRnVuY3Rpb25cclxuICAgICAgICApIHtcclxuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSB0eXBlb2YgZSA9PT0gJ3N0cmluZycgPyBuZXcgRXJyb3IoZSkgOiBlO1xyXG4gICAgICAgICAgICBfcGFyYW1ldGVycy5lcnJvckNhbGxiYWNrLmNhbGwodGhpcywgZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdGF0ZSBjaGFuZ2VkIGV2ZW50IC0gZmlyZXMgd2hlbiBETSBzdGF0ZSBjaGFuZ2VzLlxyXG4gICAgICogRS5nLiBmcm9tIGEgZmV0Y2hpbmcgc3RhdGUgdG8gYSByZW5kZXJpbmcgc3RhdGUuXHJcbiAgICAgKiBUaGUgc3RhdGUgc3RyaW5nIGlkZW50aWZpZXIgaXMgcmV0dXJuZWQgYXMgYSBwYXJhbWV0ZXIgb2YgdGhlIGV2ZW50XHJcbiAgICAgKiBAZXZlbnQgZGlhZ3JhbS1zdGF0ZS1jaGFuZ2VkXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IHN0YXRlIC0gUGFyYW1ldGVyIGNhbiB0YWtlIHRoZSBmb2xsb3dpbmcgdmFsdWVzOiAnZmV0Y2hpbmcnIHwgJ3JlbmRlcmluZycgfCAnY29tcGxldGVkJyB8ICdlcnJvcidcclxuICAgICovXHJcblxyXG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XHJcbiAgICBjb25zdCBfZGF0YVByb3ZpZGVyID0gcHJvcGVydGllcy5kYXRhUHJvdmlkZXI7XHJcbiAgICBjb25zdCBfYmFzZSA9IF9jcmVhdGVCYXNlKHByb3BlcnRpZXMucm9vdEVsZW1lbnQpO1xyXG5cclxuICAgIGNvbnN0IF9sYXlvdXQgPSBuZXcgTWFwTGF5b3V0KHtcclxuICAgICAgICByb290RWxlbWVudDogX2Jhc2UuZGVyaXZhdGlvbk1hcFJvb3RIdG1sXHJcbiAgICB9LCBfcGFyYW1ldGVycyk7XHJcbiAgICBjb25zdCBfcHJvZ3Jlc3NTY3JlZW4gPSBuZXcgVFFHcmFtVUkuUHJvZ3Jlc3NTY3JlZW4oe1xyXG4gICAgICAgIGJhc2VFbGVtZW50OiBfYmFzZS5jb250YWluZXIsXHJcbiAgICB9KTtcclxuXHJcbiAgICBsZXQgX3NlbGVjdGVkRWxlbWVudCA9IHVuZGVmaW5lZDtcclxuICAgIGxldCBfZGlhZ3JhbUluZm8gPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgLy8gSW5pdGlhbGl6YXRpb25cclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG4gICAgY29uc3QgX2RlZmF1bHRVSSA9IG5ldyBETURlZmF1bHRVSSh7XHJcbiAgICAgICAgYmFzZUVsZW1lbnQ6IF9iYXNlLnRvb2xiYXIsXHJcbiAgICAgICAgaW5mb1BhbmVsOiBfYmFzZS5pbmZvUGFuZWwsXHJcbiAgICAgICAgdG9vbHM6IF9wYXJhbWV0ZXJzLnRvb2xzIHx8IG51bGwsXHJcbiAgICAgICAgZGVyaXZhdGlvbk1hcDogc2VsZixcclxuICAgIH0pO1xyXG5cclxuICAgIGlmIChwcm9wZXJ0aWVzLnJlbGF0aW9uKSB7XHJcbiAgICAgICAgX29wZW5XaXRoUmVsYXRpb24ocHJvcGVydGllcy5yZWxhdGlvbik7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUHVibGljIGZ1bmN0aW9uc1xyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgICBzZWxmLnJlbGF0aW9uO1xyXG4gICAgc2VsZi5vcGVuV2l0aFJlbGF0aW9uID0gX29wZW5XaXRoUmVsYXRpb247XHJcblxyXG4gICAgc2VsZi5yZXNldEZvY3VzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF9sYXlvdXQuem9vbSgpO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLmdldFNlbGVjdGVkRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX3NlbGVjdGVkRWxlbWVudDtcclxuICAgIH07XHJcblxyXG4gICAgc2VsZi5zZXRTZWxlY3RlZEVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudElkKSB7XHJcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRFTGVtZW50ID0gX2xheW91dC5nZXROb2RlcygpLmZpbmQoZWwgPT4gZWwuaWQgPT09IGVsZW1lbnRJZCk7XHJcbiAgICAgICAgX3NldFNlbGVjdGVkRWxlbWVudChzZWxlY3RlZEVMZW1lbnQpO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLnNldFNlYXJjaEtleSA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICBfbGF5b3V0LnNldFNlYXJjaEtleShrZXkpO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLmV4cGFuZEFsbEVsZW1lbnRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF9sYXlvdXQuZ2V0Tm9kZXMoKS5mb3JFYWNoKGVsID0+IHtcclxuICAgICAgICAgICAgZWwuZXhwYW5kKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYuY29sbGFwc2VBbGxFbGVtZW50cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfbGF5b3V0LmdldE5vZGVzKCkuZm9yRWFjaChlbCA9PiB7XHJcbiAgICAgICAgICAgIGVsLmNvbGxhcHNlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYuZXhwb3J0VG9TdmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgX2xheW91dC5leHBvcnQoeyB0eXBlOiAnc3ZnJyB9KTtcclxuICAgIH07XHJcblxyXG4gICAgc2VsZi5leHBvcnRUb1BuZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfbGF5b3V0LmV4cG9ydCh7IHR5cGU6ICdwbmcnIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLnpvb21JbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfbGF5b3V0Lnpvb20oMC4yLCB7IG1heDogNCB9KTtcclxuICAgIH07XHJcblxyXG4gICAgc2VsZi56b29tT3V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF9sYXlvdXQuem9vbSgtMC4yLCB7IG1pbjogMC4yIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLnpvb21Ub0ZpdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfbGF5b3V0Lnpvb20oKTtcclxuICAgIH07XHJcblxyXG4gICAgc2VsZi5wcmludCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfbGF5b3V0LnByaW50KCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYuZ2V0RGlhZ3JhbUluZm8gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9kaWFncmFtSW5mbztcclxuICAgIH07XHJcblxyXG4gICAgLy8gUHJpdmF0ZSBmdW5jdGlvbnNcclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG4gICAgZnVuY3Rpb24gX29wZW5XaXRoUmVsYXRpb24gKHJlbGF0aW9uKSB7XHJcbiAgICAgICAgX3NldFNlbGVjdGVkRWxlbWVudCh1bmRlZmluZWQpO1xyXG4gICAgICAgIGlmIChyZWxhdGlvbikge1xyXG4gICAgICAgICAgICBpZiAoIXNlbGYucmVsYXRpb24gfHwgcmVsYXRpb24uc291cmNlICE9PSBzZWxmLnJlbGF0aW9uLnNvdXJjZSB8fCByZWxhdGlvbi50YXJnZXQgIT09IHNlbGYucmVsYXRpb24udGFyZ2V0IHx8IHJlbGF0aW9uLmxpbmtUeXBlICE9PSBzZWxmLnJlbGF0aW9uLmxpbmtUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICBfbGF5b3V0LmNsZWFyKCk7XHJcbiAgICAgICAgICAgICAgICBzZWxmLnJlbGF0aW9uID0gcmVsYXRpb247XHJcbiAgICAgICAgICAgICAgICBfc2V0RGlhZ3JhbVN0YXRlKCdmZXRjaGluZycpO1xyXG4gICAgICAgICAgICAgICAgX2RhdGFQcm92aWRlci5yZWxhdGlvbkluZm8ocmVsYXRpb24pLnRoZW4ocmF3RGF0YSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3NldERpYWdyYW1TdGF0ZSgncmVuZGVyaW5nJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrRG1SYXdEYXRhKHJhd0RhdGEpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBfZGlhZ3JhbUluZm8gPSByYXdEYXRhLmRpYWdyYW1JbmZvO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXBFbGVtZW50cyA9IHByb2Nlc3NEYXRhKHJhd0RhdGEsIF9wYXJhbWV0ZXJzKTtcclxuICAgICAgICAgICAgICAgICAgICBfbGF5b3V0LnNldEVsZW1lbnRzKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBFbGVtZW50cy5lbGVtZW50cy5jb25jYXQobWFwRWxlbWVudHMubGlua3MpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfZGlhZ3JhbUluZm8sXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLnJlc2V0Rm9jdXMoKTtcclxuICAgICAgICAgICAgICAgICAgICBfc3Vic2NyaWJlT25FbGVtZW50cygpO1xyXG4gICAgICAgICAgICAgICAgICAgIF9zZXREaWFncmFtU3RhdGUoJ2NvbXBsZXRlZCcpO1xyXG4gICAgICAgICAgICAgICAgfSkuY2F0Y2goZSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSB0eXBlb2YgZSA9PT0gJ3N0cmluZycgPyBuZXcgRXJyb3IoZSkgOiBlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBfc2V0RGlhZ3JhbVN0YXRlKCdlcnJvcicsIGVycm9yLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIF9lcnJvckNhbGxiYWNrKGVycm9yKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvci5tZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yLnN0YWNrKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc2VsZi5yZXNldEZvY3VzKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBlcnJvclRleHQgPSAnVGhlIHJlbGF0aW9uIHlvdSB3YW50IHRvIHVzZSBpcyBlbXB0eSEnO1xyXG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihlcnJvclRleHQpO1xyXG4gICAgICAgICAgICBfc2V0RGlhZ3JhbVN0YXRlKCdlcnJvcicsIGVycm9yVGV4dCk7XHJcbiAgICAgICAgICAgIF9lcnJvckNhbGxiYWNrKGVycm9yKTtcclxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIF9zdWJzY3JpYmVPbkVsZW1lbnRzICgpIHtcclxuICAgICAgICBfbGF5b3V0LmdldE5vZGVzKCkuZm9yRWFjaChlbCA9PiB7XHJcbiAgICAgICAgICAgIGVsLm9uKCdlbGVtZW50LWNsaWNrJywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgX3NldFNlbGVjdGVkRWxlbWVudChlbCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBlbC5vbignY29sbGFwc2UtYnV0dG9uLWNsaWNrJywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbW9kZWwgPSBlbC5nZXRNb2RlbCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG1vZGVsLmNvbGxhcHNlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsLmV4cGFuZCgpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBlbC5jb2xsYXBzZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgX2xheW91dC5nZXRMaW5rcygpLmZvckVhY2goZWwgPT4ge1xyXG4gICAgICAgICAgICBlbC5vbignZWxlbWVudC1jbGljaycsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIF9zZXRTZWxlY3RlZEVsZW1lbnQoZWwpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBfbGF5b3V0Lm9uKCdibGFuay1jbGljaycsICgpID0+IF9zZXRTZWxlY3RlZEVsZW1lbnQodW5kZWZpbmVkKSk7XHJcblxyXG4gICAgZnVuY3Rpb24gX3NldFNlbGVjdGVkRWxlbWVudCAoZWxlbWVudCkge1xyXG4gICAgICAgIGlmIChfc2VsZWN0ZWRFbGVtZW50KSBfc2VsZWN0ZWRFbGVtZW50LmhpZ2hsaWdodGluZyhmYWxzZSk7XHJcbiAgICAgICAgX3NlbGVjdGVkRWxlbWVudCA9IGVsZW1lbnQ7XHJcblxyXG4gICAgICAgIGlmIChfc2VsZWN0ZWRFbGVtZW50KSBfc2VsZWN0ZWRFbGVtZW50LmhpZ2hsaWdodGluZyh0cnVlKTtcclxuICAgICAgICBfZGVmYXVsdFVJLmluZm9QYW5lbC5zZXRTZWxlY3RlZEVsZW1lbnQoZWxlbWVudCk7XHJcblxyXG4gICAgICAgIHNlbGYudHJpZ2dlcignc2VsZWN0ZWQtZWxlbWVudC1jaGFuZ2VkJywgX2dldE1vZGVsKGVsZW1lbnQpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgc3RhdGUgb2YgaW5kaWNhdG9yXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0YXRlIC0gZmV0Y2hpbmcgfCByZW5kZXJpbmcgfCBjb21wbGV0ZWRcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIC0gQ3VzdG9tIG1lc3NhZ2VcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gX3NldERpYWdyYW1TdGF0ZSAoc3RhdGUsIG1lc3NhZ2UpIHtcclxuICAgICAgICBzZWxmLnN0YXRlID0gc3RhdGU7XHJcbiAgICAgICAgaWYgKHN0YXRlID09PSAnZmV0Y2hpbmcnKSB7XHJcbiAgICAgICAgICAgIF9wcm9ncmVzc1NjcmVlbi5zZXRTdGF0ZSgnYWN0aXZlJywgbWVzc2FnZSB8fCAnRmV0Y2hpbmcgZGF0YScpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09ICdyZW5kZXJpbmcnKSB7XHJcbiAgICAgICAgICAgIF9wcm9ncmVzc1NjcmVlbi5zZXRTdGF0ZSgnYWN0aXZlJywgbWVzc2FnZSB8fCAnUmVuZGVyaW5nIGdyYXBoJyk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gJ2NvbXBsZXRlZCcpIHtcclxuICAgICAgICAgICAgX3Byb2dyZXNzU2NyZWVuLnNldFN0YXRlKCdjb21wbGV0ZWQnKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSAnZXJyb3InKSB7XHJcbiAgICAgICAgICAgIF9wcm9ncmVzc1NjcmVlbi5zZXRTdGF0ZSgnZXJyb3InLCBtZXNzYWdlIHx8ICdFcnJvciBoYXMgb2NjdXJyZWQhJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNlbGYudHJpZ2dlcignZGlhZ3JhbS1zdGF0ZS1jaGFuZ2VkJywgbWVzc2FnZSB8fCBzdGF0ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX2dldE1vZGVsIChlbGVtZW50KSB7XHJcbiAgICAgICAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBtYXBFbGVtZW50cy5Ob2RlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBpZDogZWxlbWVudC5pZCxcclxuICAgICAgICAgICAgICAgIGxhYmVsOiBlbGVtZW50LmxhYmVsLFxyXG4gICAgICAgICAgICAgICAgcmVzb3VyY2U6IGVsZW1lbnQucmVzb3VyY2UsXHJcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IGVsZW1lbnQucGFyZW50LFxyXG4gICAgICAgICAgICAgICAgcmVzb3VyY2VUeXBlOiBlbGVtZW50LnJlc291cmNlVHlwZSxcclxuICAgICAgICAgICAgICAgIGRpYWdyYW1UeXBlOiAnbm9kZScsXHJcbiAgICAgICAgICAgICAgICBlbmRwb2ludElkOiBlbGVtZW50LmVuZHBvaW50SWRcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBtYXBFbGVtZW50cy5MaW5rKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBpZDogZWxlbWVudC5pZCxcclxuICAgICAgICAgICAgICAgIHNvdXJjZTogZWxlbWVudC5zb3VyY2UuZW5kcG9pbnRJZCxcclxuICAgICAgICAgICAgICAgIHRhcmdldDogZWxlbWVudC50YXJnZXQuZW5kcG9pbnRJZCxcclxuICAgICAgICAgICAgICAgIGRpYWdyYW1UeXBlOiAnbGluaycsXHJcbiAgICAgICAgICAgICAgICB0eXBlSWQ6IGVsZW1lbnQudHlwZUlkXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGh0bWwgbWFya3VwLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGh0bWxOb2RlIC0gUm9vdCBub2RlIGZvciBtYXJrdXBcclxuICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywgSFRNTEVsZW1lbnQ+fSAtIE1hcCBvZiBodG1sIGVsZW1lbnRzXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIF9jcmVhdGVCYXNlIChodG1sTm9kZSkge1xyXG4gICAgICAgIGh0bWxOb2RlLmlubmVySFRNTCA9ICcnO1xyXG4gICAgICAgIGh0bWxOb2RlLnRhYkluZGV4ID0gMTtcclxuXHJcbiAgICAgICAgY29uc3Qgcm93Q29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7XHJcbiAgICAgICAgcm93Q29udGFpbmVyLmNsYXNzTmFtZSA9ICd0cS1yb3ctY29udGFpbmVyJztcclxuICAgICAgICBodG1sTm9kZS5hcHBlbmRDaGlsZChyb3dDb250YWluZXIpO1xyXG5cclxuICAgICAgICBjb25zdCBiYXNlRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7XHJcbiAgICAgICAgYmFzZURpdi5jbGFzc05hbWUgPSAndHEtZGVyaXZhdGlvbi1tYXAnO1xyXG4gICAgICAgIGJhc2VEaXYuaWQgPSAndHEtZGVyaXZhdGlvbi1tYXAnO1xyXG4gICAgICAgIHJvd0NvbnRhaW5lci5hcHBlbmRDaGlsZChiYXNlRGl2KTtcclxuXHJcbiAgICAgICAgY29uc3QgZGVyaXZhdGlvbk1hcFJvb3RIdG1sID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7XHJcbiAgICAgICAgZGVyaXZhdGlvbk1hcFJvb3RIdG1sLmNsYXNzTmFtZSA9ICd0cS1kZXJpdmF0aW9uLW1hcC1kaWFncmFtJztcclxuICAgICAgICBkZXJpdmF0aW9uTWFwUm9vdEh0bWwuaWQgPSAndHEtZGVyaXZhdGlvbi1tYXAtZGlhZ3JhbSc7XHJcbiAgICAgICAgYmFzZURpdi5hcHBlbmRDaGlsZChkZXJpdmF0aW9uTWFwUm9vdEh0bWwpO1xyXG5cclxuICAgICAgICBjb25zdCBwcm9ncmVzc0luZGljYXRpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTtcclxuICAgICAgICBwcm9ncmVzc0luZGljYXRpb24uY2xhc3NOYW1lID0gJ3RxLWxnLXByb2dyZXNzLXNjcmVlbic7XHJcbiAgICAgICAgYmFzZURpdi5hcHBlbmRDaGlsZChwcm9ncmVzc0luZGljYXRpb24pO1xyXG5cclxuICAgICAgICBjb25zdCB0b29sYmFyQmFzZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO1xyXG4gICAgICAgIHRvb2xiYXJCYXNlLmNsYXNzTmFtZSA9ICd0cS1kZXJpdmF0aW9uLW1hcF9fdG9vbGJhcic7XHJcbiAgICAgICAgdG9vbGJhckJhc2UuaWQgPSAndHEtZGVyaXZhdGlvbi1tYXAtdG9vbGJhcic7XHJcbiAgICAgICAgYmFzZURpdi5hcHBlbmRDaGlsZCh0b29sYmFyQmFzZSk7XHJcblxyXG4gICAgICAgIGNvbnN0IGluZm9QYW5lbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO1xyXG4gICAgICAgIGluZm9QYW5lbC5jbGFzc05hbWUgPSAndHEtcm93LWNvbnRhaW5lcl9fcHJvcGVydGllcy1wYW5lJztcclxuICAgICAgICBpbmZvUGFuZWwuaWQgPSAndHEtcHJvcGVydGllcy1wYW5lJztcclxuICAgICAgICByb3dDb250YWluZXIuYXBwZW5kQ2hpbGQoaW5mb1BhbmVsKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgY29udGFpbmVyOiBodG1sTm9kZSxcclxuICAgICAgICAgICAgYmFzZURpdjogYmFzZURpdixcclxuICAgICAgICAgICAgaW5mb1BhbmVsOiBpbmZvUGFuZWwsXHJcbiAgICAgICAgICAgIHRvb2xiYXI6IHRvb2xiYXJCYXNlLFxyXG4gICAgICAgICAgICBkZXJpdmF0aW9uTWFwUm9vdEh0bWw6IGRlcml2YXRpb25NYXBSb290SHRtbCxcclxuICAgICAgICAgICAgcHJvZ3Jlc3M6IHByb2dyZXNzSW5kaWNhdGlvbixcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBEZXJpdmF0aW9uTWFwO1xyXG4iLCJpbXBvcnQgeyBnZXREaXN0IH0gZnJvbSAnLi4vLi4vdXRpbHMvdXRpbHMnO1xyXG5pbXBvcnQgeyBnZXRDcm9zUG9pbnQgfSBmcm9tICcuLi8uLi91dGlscy9saW5lYWdlRGlhZ3JhbVV0aWxzJztcclxuXHJcbmNvbnN0IEVMRU1FTlRfT0ZGU0VUID0gMTA7XHJcblxyXG5leHBvcnQgY29uc3QgZG1yb3V0ZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtYW51YWxWZXJ0aWNlcywgb3B0cywgbGlua1ZpZXcpIHtcclxuICAgICAgICB0aGlzLl9maW5kQ29ubmVjdGlvblBvaW50cyhbXSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIGJ1aWxkV2F5KHRoaXMuc291cmNlUG9pbnQsIHRoaXMudGFyZ2V0UG9pbnQpO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBidWlsZFdheSAoc3RhcnQsIGZpbmlzaCkge1xyXG4gICAgICAgICAgICBjb25zdCBlbGVtZW50cyA9IGxpbmtWaWV3Lm1vZGVsLmdyYXBoLmdldEVsZW1lbnRzKCkubWFwKGVsID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlY3QgPSBlbC5nZXRCQm94KCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjZW50ZXIgPSByZWN0LmNlbnRlcigpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBlbDogZWwsXHJcbiAgICAgICAgICAgICAgICAgICAgcmVjdDogcmVjdCxcclxuICAgICAgICAgICAgICAgICAgICBkaXN0QTogZ2V0RGlzdChjZW50ZXIsIHN0YXJ0KSxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0pLnNvcnQoKGEsIGIpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChhLmRpc3QgPiBiLmRpc3QpIHJldHVybiAtMTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGEuZGlzdCA8IGIuZGlzdCkgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgICAgICBlbHNlIHJldHVybiAwO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY29uc3QgbGluZSA9IHsgcDE6IHN0YXJ0LCBwMjogZmluaXNoIH07XHJcblxyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbaV07XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZWN0ID0gZWxlbWVudC5yZWN0O1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRTaWRlcyA9IFtcclxuICAgICAgICAgICAgICAgICAgICB7IHAxOiB7IHg6IHJlY3QueCwgeTogcmVjdC55IH0sIHAyOiB7IHg6IHJlY3QueCArIHJlY3Qud2lkdGgsIHk6IHJlY3QueSB9IH0sXHJcbiAgICAgICAgICAgICAgICAgICAgeyBwMTogeyB4OiByZWN0LngsIHk6IHJlY3QueSB9LCBwMjogeyB4OiByZWN0LngsIHk6IHJlY3QueSArIHJlY3QuaGVpZ2h0IH0gfSxcclxuICAgICAgICAgICAgICAgICAgICB7IHAxOiB7IHg6IHJlY3QueCwgeTogcmVjdC55ICsgcmVjdC5oZWlnaHQgfSwgcDI6IHsgeDogcmVjdC54ICsgcmVjdC53aWR0aCwgeTogcmVjdC55ICsgcmVjdC5oZWlnaHQgfSB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHsgcDE6IHsgeDogcmVjdC54ICsgcmVjdC53aWR0aCwgeTogcmVjdC55IH0sIHAyOiB7IHg6IHJlY3QueCArIHJlY3Qud2lkdGgsIHk6IHJlY3QueSArIHJlY3QuaGVpZ2h0ICB9IH0sXHJcbiAgICAgICAgICAgICAgICBdO1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IGludGVyc2VjdGlvblBvaW50cyA9IGVsZW1lbnRTaWRlcy5tYXAoc2lkZSA9PiBnZXRDcm9zUG9pbnQobGluZS5wMSwgbGluZS5wMiwgc2lkZS5wMSwgc2lkZS5wMikpLmZpbHRlcihwb2ludCA9PiBwb2ludCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpbnRlcnNlY3RXaXRoT2JqZWN0ID0gaW50ZXJzZWN0aW9uUG9pbnRzLmxlbmd0aCAhPT0gMDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJzZWN0V2l0aE9iamVjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRQb2ludHMgPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgeDogcmVjdC54IC0gRUxFTUVOVF9PRkZTRVQsIHk6IHJlY3QueSAtIEVMRU1FTlRfT0ZGU0VUIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgeDogcmVjdC54ICsgcmVjdC53aWR0aCArIEVMRU1FTlRfT0ZGU0VULCB5OiByZWN0LnkgLSBFTEVNRU5UX09GRlNFVCB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7IHg6IHJlY3QueCArIHJlY3Qud2lkdGggKyBFTEVNRU5UX09GRlNFVCwgeTogcmVjdC55ICsgcmVjdC5oZWlnaHQgKyBFTEVNRU5UX09GRlNFVCB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7IHg6IHJlY3QueCAtIEVMRU1FTlRfT0ZGU0VULCB5OiByZWN0LnkgKyByZWN0LmhlaWdodCArIEVMRU1FTlRfT0ZGU0VUIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhbGxQb2ludHMgPSBlbGVtZW50UG9pbnRzLmNvbmNhdChbc3RhcnQsIGZpbmlzaF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGh1bGwgPSBnZXRDb252ZXhIdWxsKGFsbFBvaW50cyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhaGNlID0gaHVsbC5tYXAocCA9PiBwb2ludFRvU3RyaW5nKHApKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGFydEluZGV4ID0gY2FoY2UuaW5kZXhPZihwb2ludFRvU3RyaW5nKHN0YXJ0KSk7IFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVuZEluZGV4ID0gY2FoY2UuaW5kZXhPZihwb2ludFRvU3RyaW5nKGZpbmlzaCkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBsZXQgd2F5MSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFydEluZGV4ICE9PSAtMSAmJiBlbmRJbmRleCAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IHN0YXJ0SW5kZXg7IGogIT09IGVuZEluZGV4OyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqID49IGh1bGwubGVuZ3RoKSB7IGogPSAwOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaiAhPT0gc3RhcnRJbmRleCAmJiBqICE9PSBlbmRJbmRleCkgd2F5MS5wdXNoKGh1bGxbal0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdheTEubGVuZ3RoID49IGh1bGwubGVuZ3RoKSBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgd2F5MiA9IGh1bGwuZmlsdGVyKChwLCBpKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaSAhPT0gc3RhcnRJbmRleCAmJiBpICE9PSBlbmRJbmRleCAmJiB3YXkxLmluZGV4T2YocCkgPT09IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdheTEgPSBjb3JyZWN0RGlyZWN0aW9uKHN0YXJ0LCB3YXkxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2F5MiA9IGNvcnJlY3REaXJlY3Rpb24oc3RhcnQsIHdheTIpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZnVsbFdheTEgPSBbc3RhcnRdLmNvbmNhdCh3YXkxKS5jb25jYXQoZmluaXNoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZnVsbFdheTIgPSBbc3RhcnRdLmNvbmNhdCh3YXkyKS5jb25jYXQoZmluaXNoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoMSA9IGNhbGN1bGF0ZVdheUxlbmd0aChmdWxsV2F5MSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxlbmd0aDIgPSBjYWxjdWxhdGVXYXlMZW5ndGgoZnVsbFdheTIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB3YXkgPSBsZW5ndGgxIDwgbGVuZ3RoMiA/IHdheTEgOiB3YXkyO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdheTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn0pKCk7XHJcblxyXG5mdW5jdGlvbiBjb3JyZWN0RGlyZWN0aW9uIChzdGFydCwgd2F5KSB7XHJcbiAgICBjb25zdCBmaXJzdFBvaW50ID0gd2F5WzBdO1xyXG4gICAgY29uc3QgbGFzdFBvaW50ID0gd2F5W3dheS5sZW5ndGggLSAxXTtcclxuXHJcbiAgICBpZiAod2F5Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICBpZiAoZ2V0RGlzdChmaXJzdFBvaW50LCBzdGFydCkgPiBnZXREaXN0KGxhc3RQb2ludCwgc3RhcnQpKSB7XHJcbiAgICAgICAgICAgIHdheS5yZXZlcnNlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB3YXk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNhbGN1bGF0ZVdheUxlbmd0aCAod2F5KSB7XHJcbiAgICBsZXQgbGVuZ3RoID0gMDtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd2F5Lmxlbmd0aCAtIDE7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGZyb20gPSB3YXlbaV07XHJcbiAgICAgICAgY29uc3QgdG8gPSB3YXlbaSArIDFdO1xyXG4gICAgICAgIGxlbmd0aCArPSBnZXREaXN0KGZyb20sIHRvKTtcclxuICAgIH1cclxuICAgIHJldHVybiBsZW5ndGg7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBvaW50VG9TdHJpbmcgKHApIHtcclxuICAgIHJldHVybiAnJyArIHAueCArICc6JyArIHAueTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0Q29udmV4SHVsbCAobm9kZXMpIHtcclxuICAgIGNvbnN0IHBvaW50cyA9IFtdLmNvbmNhdChub2Rlcyk7XHJcbiAgICBwb2ludHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgIHJldHVybiBhLnggIT0gYi54ID8gYS54IC0gYi54IDogYS55IC0gYi55O1xyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgbiA9IHBvaW50cy5sZW5ndGg7XHJcbiAgICBjb25zdCBodWxsID0gW107XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyICogbjsgaSsrKSB7XHJcbiAgICAgICAgbGV0IGogPSBpIDwgbiA/IGkgOiAyICogbiAtIDEgLSBpO1xyXG4gICAgICAgIHdoaWxlIChcclxuICAgICAgICAgICAgaHVsbC5sZW5ndGggPj0gMiAmJlxyXG4gICAgICAgICAgICByZW1vdmVNaWRkbGUoXHJcbiAgICAgICAgICAgICAgICAgIGh1bGxbaHVsbC5sZW5ndGggLSAyXSxcclxuICAgICAgICAgICAgICAgICAgaHVsbFtodWxsLmxlbmd0aCAtIDFdLFxyXG4gICAgICAgICAgICAgICAgICBwb2ludHNbal1cclxuICAgICAgICAgICAgKVxyXG4gICAgICAgICkgaHVsbC5wb3AoKTtcclxuICAgICAgICBodWxsLnB1c2gocG9pbnRzW2pdKTtcclxuICAgIH1cclxuICAgIGh1bGwucG9wKCk7XHJcblxyXG4gICAgY29uc3QgZmlsdGVyRHVibGljYXRpb24gPSB7fTtcclxuICAgIHJldHVybiBodWxsLmZpbHRlcihwID0+IHtcclxuICAgICAgICBjb25zdCBpZCA9IGdldElkKHApO1xyXG4gICAgICAgIGlmIChmaWx0ZXJEdWJsaWNhdGlvbltpZF0pIHJldHVybiBmYWxzZTtcclxuICAgICAgICBmaWx0ZXJEdWJsaWNhdGlvbltpZF0gPSBwO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSk7XHJcblxyXG4gICAgZnVuY3Rpb24gcmVtb3ZlTWlkZGxlIChhLCBiLCBjKSB7XHJcbiAgICAgICAgY29uc3QgY3Jvc3MgPSAoYS54IC0gYi54KSAqIChjLnkgLSBiLnkpIC0gKGEueSAtIGIueSkgKiAoYy54IC0gYi54KTtcclxuICAgICAgICAvLyBjb25zdCBkb3QgPSAoYS54IC0gYi54KSAqIChjLnggLSBiLngpICsgKGEueSAtIGIueSkgKiAoYy55IC0gYi55KTtcclxuICAgICAgICByZXR1cm4gY3Jvc3MgPCAwOy8vIHx8IChjcm9zcyA9PSAwICYmIGRvdCA8PSAwKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRJZCAocG9pbnQpIHtcclxuICAgICAgICByZXR1cm4gcG9pbnQueCArICc6JyArIHBvaW50Lnk7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgKiBhcyBqb2ludCBmcm9tICdyYXBwaWQnO1xyXG5pbXBvcnQgU3Vic2NyaWJhYmxlIGZyb20gJy4uLy4uL3N1YnNjcmlwdGlvbkFQSS9zdWJzY3JpYmVhYmxlJztcclxuaW1wb3J0IHsgUmVzb3VyY2VQcm92aWRlciB9IGZyb20gJy4uLy4uL2RhdGEvcmVzb3VyY2VQcm92aWRlcic7XHJcbmltcG9ydCB7IGRtcm91dGVyIH0gZnJvbSAnLi9saW5lUm91dGluZyc7XHJcblxyXG5jb25zdCBERUZBVUxUX0xJTktfVFlQRSA9ICdkZXJpdmF0aW9uLWxpbmsnO1xyXG5jb25zdCBNQVJLRVJfVEFSR0VUID0ge1xyXG4gICAgZmlsbDogJ2JsYWNrJyxcclxuICAgIHN0cm9rZTogJ2JsYWNrJyxcclxuICAgIGQ6ICdNIDEwIDAgTCAwIDUgTCAxMCAxMCB6JyxcclxufTtcclxuZXhwb3J0IGNvbnN0IExJTktfTEFCRUxfRk9OVF9TSVpFID0gMTY7XHJcbmV4cG9ydCBjb25zdCBaX0lOREVYRVMgPSB7XHJcbiAgICBOT0RFOiAzMCxcclxuICAgIFNFTEVDVEVEX0VMRU1FTlQ6IDIwLFxyXG4gICAgTElOSzogMTUsXHJcbiAgICBCTFVSRURfTk9ERTogMTAsXHJcbiAgICBCTFVSRURfTElOSzogNSxcclxufTtcclxuXHJcbmpvaW50LnJvdXRlcnMuZG1yb3V0ZXIgPSBkbXJvdXRlcjtcclxuXHJcbi8qKlxyXG4gKiBOb2RlXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBjbGFzc1xyXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICogQGZpcmVzIGVsZW1lbnQtY2xpY2tcclxuICogQGZpcmVzIGNvbGxhcHNlLWJ1dHRvbi1jbGlja1xyXG4gKiBAZmlyZXMgcG9ydHMtc3RhdGUtY2hhbmdlZFxyXG4gKiBAZmlyZXMgZWxlbWVudC1zdGF0ZS1jaGFuZ2VkXHJcbiAqIEBmaXJlcyBwb3NpdGlvbi1jaGFuZ2VkXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gTm9kZSAob3B0aW9ucywgcGFyYW1ldGVycykge1xyXG4gICAgU3Vic2NyaWJhYmxlLmFwcGx5KHRoaXMpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSXQgZmlyZXMgd2hlbiB1c2VyIGNsaWNrIG9uIG5vZGUuXHJcbiAgICAgKiBAZXZlbnQgZWxlbWVudC1jbGlja1xyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqIEBwcm9wZXJ0eSB7TW91c2VFdmVudH0gZXZlbnQgLSBvcmlnaW4gTW91c2VFdnRudFxyXG4gICAgKi9cclxuXHJcbiAgICBjb25zdCBzZWxmID0gdGhpcztcclxuICAgIGNvbnN0IF9ncmFwaE5vZGUgPSBvcHRpb25zLmdyYXBoTm9kZSB8fCBuZXcgR3JhcGhOb2RlKG9wdGlvbnMubW9kZWwsIHBhcmFtZXRlcnMpO1xyXG5cclxuICAgIHNlbGYuaWQgPSBvcHRpb25zLmlkO1xyXG4gICAgc2VsZi5lbmRwb2ludElkID0gb3B0aW9ucy5lbmRwb2ludElkO1xyXG4gICAgc2VsZi5yZXNvdXJjZVR5cGUgPSBvcHRpb25zLnJlc291cmNlVHlwZTtcclxuICAgIHNlbGYucGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XHJcbiAgICBzZWxmLmxhYmVsID0gb3B0aW9ucy5sYWJlbDtcclxuICAgIHNlbGYuY2hpbGRyZW4gPSBvcHRpb25zLmNoaWxkcmVuO1xyXG4gICAgc2VsZi5vcmRlcmVkUG9zc2libGVJZHMgPSBvcHRpb25zLm9yZGVyZWRQb3NzaWJsZUlkcztcclxuICAgIHNlbGYucmVzb3VyY2UgPSBvcHRpb25zLnJlc291cmNlO1xyXG5cclxuICAgIHNlbGYuaGlnaGxpZ2h0aW5nID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBfZ3JhcGhOb2RlLnNldEhpZ2hsaWdodGVkSWQoc2VsZi5pZCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2VsZi5pZCA9PT0gX2dyYXBoTm9kZS5oaWdobGlnaHRlZElkKSB7XHJcbiAgICAgICAgICAgICAgICBfZ3JhcGhOb2RlLnNldEhpZ2hsaWdodGVkSWQodW5kZWZpbmVkKTsgICAgICAgICBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gX2dyYXBoTm9kZS5oaWdobGlnaHRlZElkID09PSBzZWxmLmlkO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLmNvbGxhcHNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF9ncmFwaE5vZGUuX2NvbGxhcHNlRWxlbWVudChzZWxmLmlkKTtcclxuICAgIH07XHJcblxyXG4gICAgc2VsZi5leHBhbmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgX2dyYXBoTm9kZS5fZXhwYW5kRWxlbWVudChzZWxmLmlkKTtcclxuICAgIH07XHJcblxyXG4gICAgc2VsZi5zaG93ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIG5vdCBpbXBsZW1lbnRlZC4uXHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYuaGlkZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBub3QgaW1wbGVtZW50ZWQuLlxyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLmlzVmlzaWJsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcblxyXG4gICAgc2VsZi5nZXRDZWxscyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gW19ncmFwaE5vZGVdO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLmdldFBvcnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgaWQ6IF9nZXRBdmFpbGFibGVQb3J0SWQoKSxcclxuICAgICAgICAgICAgcHJpbWl0aXZlOiBfZ3JhcGhOb2RlLFxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYuZ2V0TW9kZWwgPSBfZ2V0TW9kZWw7XHJcblxyXG4gICAgc2VsZi5nZXRQb3J0UG9zaXRpb24gPSBmdW5jdGlvbiAoZGlyZWN0aW9uKSB7XHJcbiAgICAgICAgY29uc3Qgc3ZnT2JqZWN0ID0gX2dyYXBoTm9kZS5hdHRyKGAuJHtnZXRQb3J0SWQoX2dldEF2YWlsYWJsZVBvcnRJZCgpLCBkaXJlY3Rpb24pfWApO1xyXG4gICAgICAgIGNvbnN0IHByaW1pdGl2ZVBvc2l0aW9uID0gc2VsZi5nZXRQb3J0KCkucHJpbWl0aXZlLnBvc2l0aW9uKCk7XHJcbiAgICAgICAgaWYgKHN2Z09iamVjdCkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgeDogc3ZnT2JqZWN0WydyZWYteCddICsgcHJpbWl0aXZlUG9zaXRpb24ueCxcclxuICAgICAgICAgICAgICAgIHk6IHN2Z09iamVjdFsncmVmLXknXSArIHByaW1pdGl2ZVBvc2l0aW9uLnksXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHByaW1pdGl2ZVBvc2l0aW9uO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgc2VsZi5vblBhcGVyQ2VsbFBvaW50ZXJEb3duID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIC4uLlxyXG4gICAgfTtcclxuXHJcbiAgICBfZ3JhcGhOb2RlLm9uKCdwb3J0cy1zdGF0ZS1jaGFuZ2VkJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHNlbGYudHJpZ2dlcigncG9ydHMtc3RhdGUtY2hhbmdlZCcpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgX2dyYXBoTm9kZS5vbignZWxlbWVudHMtc3RhdGUtY2hhbmdlZCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBzZWxmLnRyaWdnZXIoJ2VsZW1lbnQtc3RhdGUtY2hhbmdlZCcpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgX2dyYXBoTm9kZS5vbignYm9keS1jbGljaycsIGZ1bmN0aW9uICh7ZXZlbnQsIGVsZW1lbnRJZH0pIHtcclxuICAgICAgICBpZiAoc2VsZi5pZCA9PT0gZWxlbWVudElkKSB7XHJcbiAgICAgICAgICAgIHNlbGYudHJpZ2dlcignZWxlbWVudC1jbGljaycsIGV2ZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBfZ3JhcGhOb2RlLm9uKCdjaGFuZ2U6cG9zaXRpb24nLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgc2VsZi50cmlnZ2VyKCdwb3NpdGlvbi1jaGFuZ2VkJyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBfZ3JhcGhOb2RlLm9uKCdjb2xsYXBzZS1idXR0b24tY2xpY2snLCBmdW5jdGlvbiAoZWxlbWVudElkKSB7XHJcbiAgICAgICAgaWYgKGVsZW1lbnRJZCA9PT0gc2VsZi5pZCkge1xyXG4gICAgICAgICAgICBzZWxmLnRyaWdnZXIoJ2NvbGxhcHNlLWJ1dHRvbi1jbGljaycpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGZ1bmN0aW9uIF9nZXRNb2RlbCAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9ncmFwaE5vZGUuZWxlbWVudHNNYXBbc2VsZi5pZF07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX2dldEF2YWlsYWJsZVBvcnRJZCAoKSB7XHJcbiAgICAgICAgY29uc3QgbW9kZWwgPSBfZ2V0TW9kZWwoKTtcclxuICAgICAgICBpZiAoIW1vZGVsLmludmlzaWJsZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5pZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWxmLm9yZGVyZWRQb3NzaWJsZUlkcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBjdXJJZCA9IHNlbGYub3JkZXJlZFBvc3NpYmxlSWRzW2ldO1xyXG4gICAgICAgICAgICBpZiAoX2dyYXBoTm9kZS5lbGVtZW50c01hcFtjdXJJZF0uaW52aXNpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2SWQgPSBzZWxmLm9yZGVyZWRQb3NzaWJsZUlkc1tpIC0gMV07XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJldklkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzZWxmLm9yZGVyZWRQb3NzaWJsZUlkc1tzZWxmLm9yZGVyZWRQb3NzaWJsZUlkcy5sZW5ndGggLSAxXTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIExpbmtcclxuICogQHByaXZhdGVcclxuICogQGNsYXNzXHJcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIExpbmsgKG9wdGlvbnMsIHBhcmFtZXRlcnMpIHtcclxuICAgIFN1YnNjcmliYWJsZS5hcHBseSh0aGlzKTtcclxuXHJcbiAgICBjb25zdCBzZWxmID0gdGhpcztcclxuXHJcbiAgICBzZWxmLnNvdXJjZSA9IG9wdGlvbnMuc291cmNlO1xyXG4gICAgc2VsZi50YXJnZXQgPSBvcHRpb25zLnRhcmdldDtcclxuICAgIHNlbGYubGFiZWwgPSBvcHRpb25zLmxhYmVsO1xyXG4gICAgc2VsZi50eXBlSWQgPSBvcHRpb25zLnR5cGVJZDtcclxuICAgIHNlbGYuZ3JvdXBlZEJ5ID0gb3B0aW9ucy5ncm91cGVkQnk7IC8vIHNvdXJjZSB8IHRhcmdldCB8IHVuZGVmaW5lZFxyXG5cclxuICAgIGNvbnN0IHtcclxuICAgICAgICBzb3VyY2UsXHJcbiAgICAgICAgdGFyZ2V0LFxyXG4gICAgfSA9IF9nZXRDb25uZWN0aW9uUGFyYW1ldGVycygpO1xyXG5cclxuICAgIGNvbnN0IHByaW1pdGl2ZXNBcmVEZWZpbmVkID0gb3B0aW9ucy5ncmFwaFByaW1pdGl2ZXMgJiYgb3B0aW9ucy5ncmFwaFByaW1pdGl2ZXMubGVuZ3RoID4gMDtcclxuICAgIGNvbnN0IF9ncmFwaFByaW1pdGl2ZXMgPSBwcmltaXRpdmVzQXJlRGVmaW5lZCA/XHJcbiAgICBvcHRpb25zLmdyYXBoUHJpbWl0aXZlcyA6IFtcclxuICAgICAgICBuZXcgR3JhcGhMaW5rKHtcclxuICAgICAgICAgICAgdHlwZUlkOiBvcHRpb25zLnR5cGVJZCxcclxuICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsXHJcbiAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0LFxyXG4gICAgICAgICAgICBsYWJlbDogX2dldExhYmVsKCksXHJcbiAgICAgICAgfSwgcGFyYW1ldGVycyksXHJcbiAgICBdO1xyXG5cclxuICAgIF9yZWZyZXNoUG9ydHMoKTtcclxuXHJcbiAgICBzZWxmLmdldENlbGxzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfZ3JhcGhQcmltaXRpdmVzO1xyXG4gICAgfTtcclxuXHJcbiAgICBsZXQgX2hpZ2hsaWdodGVkID0gZmFsc2U7XHJcbiAgICBzZWxmLmhpZ2hsaWdodGluZyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIF9oaWdobGlnaHRlZCA9IHZhbHVlO1xyXG4gICAgICAgICAgICBfZ3JhcGhQcmltaXRpdmVzLmZvckVhY2gocHJpbWl0aXZlID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHByaW1pdGl2ZS5oaWdobGlnaHQoKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJpbWl0aXZlLnVuaGlnaGxpZ2h0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gX2hpZ2hsaWdodGVkO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLnNob3cgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgX2dyYXBoUHJpbWl0aXZlcy5mb3JFYWNoKHByaW1pdGl2ZSA9PlxyXG4gICAgICAgICAgICBwcmltaXRpdmUuc2hvdygpXHJcbiAgICAgICAgKTtcclxuICAgIH07XHJcblxyXG4gICAgc2VsZi5oaWRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF9ncmFwaFByaW1pdGl2ZXMuZm9yRWFjaChwcmltaXRpdmUgPT5cclxuICAgICAgICAgICAgcHJpbWl0aXZlLmhpZGUoKVxyXG4gICAgICAgICk7XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYuaXNWaXNpYmxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAhc2VsZi5nZXQoJ2hpZGRlbicpO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLm9uUGFwZXJDZWxsUG9pbnRlckRvd24gPSBmdW5jdGlvbiAoY2VsbCkge1xyXG4gICAgICAgIGNvbnN0IGNlbGxJc015UHJpbWl0aXZlID0gX2dyYXBoUHJpbWl0aXZlcy5pbmRleE9mKGNlbGwpICE9PSAtMTtcclxuICAgICAgICBpZiAoY2VsbElzTXlQcmltaXRpdmUpIHtcclxuICAgICAgICAgICAgc2VsZi50cmlnZ2VyKCdlbGVtZW50LWNsaWNrJywgZXZlbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgc2VsZi5hbGlnbkNyb3NzTm9kZSA9IF9hbGlnbkNyb3NzTm9kZTtcclxuICAgIHNlbGYuZ2V0Q3Jvc3NOb2RlID0gX2dldENyb3NzTm9kZTtcclxuXHJcbiAgICBmdW5jdGlvbiBfZ2V0Q3Jvc3NOb2RlICgpIHtcclxuICAgICAgICBjb25zdCBpc0Nyb3NzZWQgPSBfZ3JhcGhQcmltaXRpdmVzLmxlbmd0aCA+IDE7XHJcbiAgICAgICAgaWYgKGlzQ3Jvc3NlZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX2dyYXBoUHJpbWl0aXZlc1swXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfYWxpZ25Dcm9zc05vZGUgKCkge1xyXG4gICAgICAgIGNvbnN0IGNyb3NzTm9kZSA9IF9nZXRDcm9zc05vZGUoKTtcclxuICAgICAgICBpZiAoIWNyb3NzTm9kZSkgcmV0dXJuO1xyXG5cclxuICAgICAgICBjb25zdCBjcm9zc2VkRWxlbWVudHMgPSBjcm9zc05vZGUuZ2V0Q3Jvc3NlZEVsZW1lbnRzKCk7XHJcbiAgICAgICAgY29uc3QgZmlyc3RDcm9zc2VkRWxlbWVudCA9IGNyb3NzZWRFbGVtZW50c1swXTtcclxuICAgICAgICBjb25zdCBncm91cGVkQnlTb3VyY2UgPSBmaXJzdENyb3NzZWRFbGVtZW50Lmdyb3VwZWRCeSA9PT0gJ3NvdXJjZSc7XHJcbiAgICAgICAgY29uc3QgREVGQVVMVF9QQURESU5HID0gMzA7XHJcbiAgICAgICAgbGV0IHN1bVkgPSAwO1xyXG4gICAgICAgIGxldCBtaW5YID0gSW5maW5pdHk7XHJcbiAgICAgICAgbGV0IG1heFggPSAtSW5maW5pdHk7XHJcblxyXG4gICAgICAgIGNyb3NzZWRFbGVtZW50cy5mb3JFYWNoKGNyb3NzZWRMaW5rcyA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGFsbGlnblRvID0gZ3JvdXBlZEJ5U291cmNlID9cclxuICAgICAgICAgICAgICAgIGNyb3NzZWRMaW5rcy50YXJnZXQuZ2V0UG9ydFBvc2l0aW9uKCdpbicpIDpcclxuICAgICAgICAgICAgICAgIGNyb3NzZWRMaW5rcy5zb3VyY2UuZ2V0UG9ydFBvc2l0aW9uKCdvdXQnKTtcclxuXHJcbiAgICAgICAgICAgIHN1bVkgKz0gYWxsaWduVG8ueTtcclxuICAgICAgICAgICAgbWluWCA9IE1hdGgubWluKG1pblgsIGFsbGlnblRvLngpO1xyXG4gICAgICAgICAgICBtYXhYID0gTWF0aC5tYXgobWF4WCwgYWxsaWduVG8ueCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3QgeFBvc2l0aW9uID0gZ3JvdXBlZEJ5U291cmNlID8gbWluWCAtIERFRkFVTFRfUEFERElORyA6IG1heFggKyBERUZBVUxUX1BBRERJTkc7XHJcbiAgICAgICAgY29uc3QgeVBvc2l0aW9uID0gc3VtWSAvIGNyb3NzZWRFbGVtZW50cy5sZW5ndGg7XHJcbiAgICAgICAgY3Jvc3NOb2RlLnBvc2l0aW9uKHhQb3NpdGlvbiwgeVBvc2l0aW9uKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfZ2V0TGFiZWwgKCkge1xyXG4gICAgICAgIHJldHVybiBqb2ludC51dGlsLmJyZWFrVGV4dChzZWxmLmxhYmVsLCB7XHJcbiAgICAgICAgICAgIHdpZHRoOiBwYXJhbWV0ZXJzLmRlZmF1bHRMaW5rTGFiZWxMZW5ndGgsXHJcbiAgICAgICAgfSwgeyAnZm9udC1zaXplJzogTElOS19MQUJFTF9GT05UX1NJWkUgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX3JlZnJlc2hQb3J0cyAoKSB7XHJcbiAgICAgICAgY29uc3Qge1xyXG4gICAgICAgICAgICB0YXJnZXRUb3BJZCxcclxuICAgICAgICAgICAgc291cmNlLFxyXG4gICAgICAgICAgICB0YXJnZXQsXHJcbiAgICAgICAgfSA9IF9nZXRDb25uZWN0aW9uUGFyYW1ldGVycygpO1xyXG5cclxuICAgICAgICBjb25zdCBzb3VyY2VQcmltaXRpdmUgPSBfZ3JhcGhQcmltaXRpdmVzWzFdIHx8IF9ncmFwaFByaW1pdGl2ZXNbMF07XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0UHJpbWl0aXZlID0gX2dyYXBoUHJpbWl0aXZlc1syXSB8fCBfZ3JhcGhQcmltaXRpdmVzWzBdO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGNvbnN0IHRhcmdldExpbmtTdHlsZSA9IHRhcmdldFByaW1pdGl2ZS5nZXRMaW5rU3R5bGUoKTtcclxuICAgICAgICBpZiAodGFyZ2V0LmlkID09PSB0YXJnZXRUb3BJZCkge1xyXG4gICAgICAgICAgICB0YXJnZXRQcmltaXRpdmUuYXR0cignLm1hcmtlci10YXJnZXQnLCBnZXRMaW5rTWFya2VyVGFyZ2V0KHRhcmdldExpbmtTdHlsZSkpO1xyXG4gICAgICAgICAgICB0YXJnZXRQcmltaXRpdmUudHJpZ2dlcigndXBkYXRlTWFya2VycycpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRhcmdldFByaW1pdGl2ZS5yZW1vdmVBdHRyKCcubWFya2VyLXRhcmdldCcpO1xyXG4gICAgICAgICAgICB0YXJnZXRQcmltaXRpdmUudHJpZ2dlcigndXBkYXRlTWFya2VycycpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc291cmNlUHJpbWl0aXZlLnByb3AoeyBzb3VyY2U6IHNvdXJjZSB9KTtcclxuICAgICAgICB0YXJnZXRQcmltaXRpdmUucHJvcCh7IHRhcmdldDogdGFyZ2V0IH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIF9hbGlnbkNyb3NzTm9kZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIF9nZXRDb25uZWN0aW9uUGFyYW1ldGVycyAoKSB7XHJcbiAgICAgICAgY29uc3Qgc291cmNlUG9ydCA9IHNlbGYuc291cmNlLmdldFBvcnQoKTtcclxuICAgICAgICBjb25zdCB0YXJnZXRQb3J0ID0gc2VsZi50YXJnZXQuZ2V0UG9ydCgpO1xyXG5cclxuICAgICAgICBjb25zdCBzb3VyY2VQb3NpdGlvbiA9IHNvdXJjZVBvcnQucHJpbWl0aXZlLnBvc2l0aW9uKCk7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0UG9zaXRpb24gPSB0YXJnZXRQb3J0LnByaW1pdGl2ZS5wb3NpdGlvbigpO1xyXG5cclxuICAgICAgICBjb25zdCByZXZlcnNlID0gc291cmNlUG9zaXRpb24ueCA+IHRhcmdldFBvc2l0aW9uLng7XHJcbiAgICAgICAgY29uc3Qgc291cmNlID0ge1xyXG4gICAgICAgICAgICBpZDogc291cmNlUG9ydC5wcmltaXRpdmUuaWQsXHJcbiAgICAgICAgICAgIHBvcnQ6IGdldFBvcnRJZChzb3VyY2VQb3J0LmlkLCAocmV2ZXJzZSA/ICdpbicgOiAnb3V0JykpLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0ge1xyXG4gICAgICAgICAgICBpZDogdGFyZ2V0UG9ydC5wcmltaXRpdmUuaWQsXHJcbiAgICAgICAgICAgIHBvcnQ6IGdldFBvcnRJZCh0YXJnZXRQb3J0LmlkLCAocmV2ZXJzZSA/ICdvdXQnIDogJ2luJykpLFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHNvdXJjZVRvcElkOiBzb3VyY2VQb3J0LmlkLFxyXG4gICAgICAgICAgICB0YXJnZXRUb3BJZDogdGFyZ2V0UG9ydC5pZCxcclxuICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsXHJcbiAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0LFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgc2VsZi5zb3VyY2Uub24oJ2VsZW1lbnQtc3RhdGUtY2hhbmdlZCcsIF9yZWZyZXNoUG9ydHMpO1xyXG4gICAgc2VsZi50YXJnZXQub24oJ2VsZW1lbnQtc3RhdGUtY2hhbmdlZCcsIF9yZWZyZXNoUG9ydHMpO1xyXG4gICAgc2VsZi5zb3VyY2Uub24oJ3BvcnRzLXN0YXRlLWNoYW5nZWQnLCBfYWxpZ25Dcm9zc05vZGUpO1xyXG4gICAgc2VsZi50YXJnZXQub24oJ3BvcnRzLXN0YXRlLWNoYW5nZWQnLCBfYWxpZ25Dcm9zc05vZGUpO1xyXG4gICAgc2VsZi5zb3VyY2Uub24oJ3Bvc2l0aW9uLWNoYW5nZWQnLCBfcmVmcmVzaFBvcnRzKTtcclxuICAgIHNlbGYudGFyZ2V0Lm9uKCdwb3NpdGlvbi1jaGFuZ2VkJywgX3JlZnJlc2hQb3J0cyk7XHJcbiAgICBcclxufVxyXG5cclxuLyoqXHJcbiAqIEpvaW50Tm9kZVxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAY2xhc3NcclxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAqIEBmaXJlcyBib2R5LWNsaWNrXHJcbiAqIEBmaXJlcyBoaWdobGlnaHRlZC1pZFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIEdyYXBoTm9kZSAobW9kZWwsIHBhcmFtZXRlcnMpIHtcclxuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSXQgZmlyZXMgd2hlbiB1c2VyIGNsaWNrIG9uIG5vZGUuXHJcbiAgICAgKiBAZXZlbnQgYm9keS1jbGlja1xyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqIEBwcm9wZXJ0eSB7XHJcbiAgICAgKiAgZXZlbnQ6IE1vdXNlRXZlbnQsIC8vIG9yaWdpbmFsIG1vdXNlIGV2ZW50XHJcbiAgICAgKiAgZWxlbWVudElkOiBzdHJpbmcsIC8vIGlkIG9mIHRoZSBjbGlja2VkIGVsZW1lbnRcclxuICAgICAqIH1cclxuICAgICovXHJcblxyXG4gICAgc2VsZi5lbGVtZW50c01hcCA9IF9nZXRGbGF0RWxlbWVudHNNYXAobW9kZWwpO1xyXG4gICAgc2VsZi5tb2RlbCA9IG1vZGVsO1xyXG4gICAgc2VsZi5zY2FsZSA9IDE7XHJcbiAgICBzZWxmLmFjdGl2ZVBvcnRzID0ge307XHJcblxyXG4gICAgam9pbnQuc2hhcGVzLmJhc2ljLkdlbmVyaWMuYXBwbHkoc2VsZiwgW3tcclxuICAgICAgICBpZDogbW9kZWwuaWQsXHJcbiAgICAgICAgbWFya3VwOiBgPGcgY2xhc3M9XCJyb3RhdGFibGVcIj5cclxuICAgICAgICAgICAgPGcgY2xhc3M9XCJzY2FsYWJsZSBleHBvcnQtYW5jaG9yXCI+XHJcbiAgICAgICAgICAgICAgICA8cmVjdCBjbGFzcz1cImJvZHlcIi8+XHJcbiAgICAgICAgICAgIDwvZz5cclxuICAgICAgICAgICAgJHtfcG9ydHNUZW1wbGF0ZSgpfVxyXG4gICAgICAgIDwvZz5gLFxyXG4gICAgICAgIHR5cGU6ICdncmFwaC1kZXJpdmF0aW9uLW5vZGUuR3JhcGhOb2RlJyxcclxuICAgICAgICBwb3NpdGlvbjogeyB4OiAwLCB5OiAwIH0sXHJcbiAgICAgICAgejogWl9JTkRFWEVTLk5PREUsXHJcbiAgICAgICAgc2l6ZToge1xyXG4gICAgICAgICAgICB3aWR0aDogcGFyYW1ldGVycy5kZWZhdWx0RWxlbWVudFdpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IHBhcmFtZXRlcnMuZGVmYXVsdEVsZW1lbnRIZWlnaHQsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBhdHRyczoge1xyXG4gICAgICAgICAgICByZWN0OiB7XHJcbiAgICAgICAgICAgICAgICBzdHJva2U6ICd0cmFuc3BhcmVudCcsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNpcmNsZToge1xyXG4gICAgICAgICAgICAgICAgcjogMCxcclxuICAgICAgICAgICAgICAgIGZpbGw6ICdyZWQnLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAnLmRuLWluLXBvcnQnOiB7XHJcbiAgICAgICAgICAgICAgICByZWY6ICcuYm9keScsXHJcbiAgICAgICAgICAgICAgICAncmVmLXgnOiAwLFxyXG4gICAgICAgICAgICAgICAgJ3JlZi15JzogMCxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgJy5kbi1vdXQtcG9ydCc6IHtcclxuICAgICAgICAgICAgICAgIHJlZjogJy5ib2R5JyxcclxuICAgICAgICAgICAgICAgICdyZWYteCc6IHBhcmFtZXRlcnMuZGVmYXVsdEVsZW1lbnRXaWR0aCArIDIwLFxyXG4gICAgICAgICAgICAgICAgJ3JlZi15JzogMCxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9LFxyXG4gICAgfV0pO1xyXG5cclxuICAgIHNlbGYuc2V0KCdjb2xsYXBzZWQnLCBmYWxzZSk7XHJcbiAgICBzZWxmLnNjdG9sbFRvcCA9IDA7XHJcblxyXG4gICAgc2VsZi5zZXRIaWdobGlnaHRlZElkID0gZnVuY3Rpb24gKHRhcmdldElkKSB7XHJcbiAgICAgICAgc2VsZi5oaWdobGlnaHRlZElkID0gdGFyZ2V0SWQ7XHJcbiAgICAgICAgY29uc3QgY2hhbmdlZElkcyA9IF91cGRhdGVTdGF0ZSh0aGlzLm1vZGVsKTtcclxuICAgICAgICBjaGFuZ2VkSWRzLmNvbmNhdChfdXBkYXRlVmlzaWJpbGl0eSh0aGlzLm1vZGVsKSk7XHJcbiAgICAgICAgc2VsZi50cmlnZ2VyKCdlbGVtZW50cy1zdGF0ZS1jaGFuZ2VkJywgW2NoYW5nZWRJZHNdKTtcclxuICAgICAgICBzZWxmLnByb3AoeyB6OiBaX0lOREVYRVMuTk9ERSB9KTtcclxuICAgIH07XHJcblxyXG4gICAgc2VsZi5fY29sbGFwc2VFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnRJZCkge1xyXG4gICAgICAgIGlmIChlbGVtZW50SWQpIHtcclxuICAgICAgICAgICAgc2VsZi5lbGVtZW50c01hcFtlbGVtZW50SWRdLmNvbGxhcHNlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoYW5nZWRJZHMgPSBfdXBkYXRlVmlzaWJpbGl0eShzZWxmLmVsZW1lbnRzTWFwW2VsZW1lbnRJZF0pOyAgIFxyXG4gICAgICAgICAgICBjaGFuZ2VkSWRzLnB1c2goZWxlbWVudElkKTtcclxuICAgICAgICAgICAgaWYgKGNoYW5nZWRJZHMubGVuZ3RoID4gMCkgc2VsZi50cmlnZ2VyKCdlbGVtZW50cy1zdGF0ZS1jaGFuZ2VkJywgW2NoYW5nZWRJZHNdKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzZWxmLnNldCgnY29sbGFwc2VkJywgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLl9leHBhbmRFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnRJZCkge1xyXG4gICAgICAgIGlmIChlbGVtZW50SWQpIHtcclxuICAgICAgICAgICAgc2VsZi5lbGVtZW50c01hcFtlbGVtZW50SWRdLmNvbGxhcHNlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBjb25zdCBjaGFuZ2VkSWRzID0gX3VwZGF0ZVZpc2liaWxpdHkoc2VsZi5lbGVtZW50c01hcFtlbGVtZW50SWRdKTsgICBcclxuICAgICAgICAgICAgY2hhbmdlZElkcy5wdXNoKGVsZW1lbnRJZCk7XHJcbiAgICAgICAgICAgIGlmIChjaGFuZ2VkSWRzLmxlbmd0aCA+IDApIHNlbGYudHJpZ2dlcignZWxlbWVudHMtc3RhdGUtY2hhbmdlZCcsIFtjaGFuZ2VkSWRzXSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc2VsZi5zZXQoJ2NvbGxhcHNlZCcsIGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYub25DbGlja0NvbGxhcHNlQnV0dG9uID0gZnVuY3Rpb24gKGVsZW1lbnRJZCkge1xyXG4gICAgICAgIHNlbGYudHJpZ2dlcignY29sbGFwc2UtYnV0dG9uLWNsaWNrJywgZWxlbWVudElkKTtcclxuICAgIH07XHJcblxyXG4gICAgc2VsZi51cGRhdGVQb3J0cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBzZWxmLnRyaWdnZXIoJ3BvcnRzLXN0YXRlLWNoYW5nZWQnKTtcclxuICAgIH07XHJcblxyXG4gICAgc2VsZi5maXJlQ2xpY2tFdmVudCA9IGZ1bmN0aW9uIChldmVudCwgZWxlbWVudElkKSB7XHJcbiAgICAgICAgc2VsZi50cmlnZ2VyKCdib2R5LWNsaWNrJywge1xyXG4gICAgICAgICAgICBldmVudDogZXZlbnQsXHJcbiAgICAgICAgICAgIGVsZW1lbnRJZDogZWxlbWVudElkLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLmdldEFsbENoaWxkcmVuID0gX2dldEFsbENoaWxkcmVuO1xyXG5cclxuICAgIHNlbGYuYWN0aXZlUG9ydHMgPSB7fTtcclxuICAgIHNlbGYucmVmcmVzaCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBzZWxmLnRyaWdnZXIoJ3JlZHJhdy12aWV3Jyk7XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYuc2V0U2NhbGUgPSBmdW5jdGlvbiAoc2NhbGUpIHtcclxuICAgICAgICBzZWxmLnNjYWxlID0gc2NhbGU7XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYuc2V0U2VhcmNoS2V5ID0gZnVuY3Rpb24gKHNlYXJjaEtleSkge1xyXG4gICAgICAgIHNlbGYuc2VhcmNoS2V5ID0gc2VhcmNoS2V5ID8gc2VhcmNoS2V5LnRvTG93ZXJDYXNlKCkgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uc3QgY2hhbmdlZElkcyA9IF91cGRhdGVWaXNpYmlsaXR5KHRoaXMubW9kZWwpO1xyXG4gICAgICAgIHNlbGYudHJpZ2dlcignZWxlbWVudHMtc3RhdGUtY2hhbmdlZCcsIFtjaGFuZ2VkSWRzXSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIF91cGRhdGVTdGF0ZSAocm9vdE1vZGVsKSB7XHJcbiAgICAgICAgY29uc3QgaGlnaGxpZ2h0ZWRJZCA9IHNlbGYuaGlnaGxpZ2h0ZWRJZDtcclxuICAgICAgICBjb25zdCBjaGFuZ2VkSWRzID0gW107XHJcbiAgICAgICAgXHJcbiAgICAgICAgdXBkYXRlU3RhdGUocm9vdE1vZGVsKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGNoYW5nZWRJZHM7XHJcbiAgICAgICAgXHJcbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlU3RhdGUgKG1vZGVsKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzU2VsZWN0ZWQgPSBtb2RlbC5pZCA9PT0gaGlnaGxpZ2h0ZWRJZDtcclxuXHJcbiAgICAgICAgICAgIGxldCBjb250YWluU2VsZWN0ZWRFbGVtZW50ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIG1vZGVsLmNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29udGFpblNlbGVjdGVkRWxlbWVudCA9IHVwZGF0ZVN0YXRlKGNoaWxkKSB8fCBjb250YWluU2VsZWN0ZWRFbGVtZW50O1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IG5ld0NvbGxhcHNlZFN0YXRlID0gbW9kZWwuY29sbGFwc2VkICYmICFjb250YWluU2VsZWN0ZWRFbGVtZW50O1xyXG4gICAgICAgICAgICBpZiAoQm9vbGVhbihuZXdDb2xsYXBzZWRTdGF0ZSkgIT09IEJvb2xlYW4obW9kZWwuY29sbGFwc2VkKSkgY2hhbmdlZElkcy5wdXNoKG1vZGVsLmlkKTtcclxuICAgICAgICAgICAgbW9kZWwuY29sbGFwc2VkID0gbmV3Q29sbGFwc2VkU3RhdGU7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gaXNTZWxlY3RlZCB8fCBjb250YWluU2VsZWN0ZWRFbGVtZW50O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfdXBkYXRlVmlzaWJpbGl0eSAocm9vdE1vZGVsKSB7XHJcbiAgICAgICAgY29uc3Qgc2VhcmNoS2V5ID0gc2VsZi5zZWFyY2hLZXk7XHJcbiAgICAgICAgY29uc3QgY2hhbmdlZElkcyA9IFtdO1xyXG5cclxuICAgICAgICB1cGRhdGVWaXNpYmlsaXR5KHJvb3RNb2RlbCwgZmFsc2UpO1xyXG5cclxuICAgICAgICByZXR1cm4gY2hhbmdlZElkcztcclxuICAgICAgICBcclxuICAgICAgICBmdW5jdGlvbiB1cGRhdGVWaXNpYmlsaXR5IChtb2RlbCwgcGFyZW50SW52aXNpYmxlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vdENvbnRhaW5LZXkgPSAoIXNlYXJjaEtleSkgfHwgbW9kZWwubGFiZWwudG9Mb3dlckNhc2UoKS5pbmRleE9mKHNlYXJjaEtleSkgPT09IC0xO1xyXG4gICAgICAgICAgICBjb25zdCBpbnZpc2libGUgPSBwYXJlbnRJbnZpc2libGUgJiYgbm90Q29udGFpbktleTtcclxuXHJcbiAgICAgICAgICAgIGxldCBub1Zpc2libGVDaGlsZHJlbiA9IHRydWU7XHJcbiAgICAgICAgICAgIG1vZGVsLmNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xyXG4gICAgICAgICAgICAgICAgbm9WaXNpYmxlQ2hpbGRyZW4gPSB1cGRhdGVWaXNpYmlsaXR5KGNoaWxkLCBwYXJlbnRJbnZpc2libGUgfHwgbW9kZWwuY29sbGFwc2VkKSAmJiBub1Zpc2libGVDaGlsZHJlbjtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld1Zpc2liaWJsaXR5ID0gaW52aXNpYmxlICYmIG5vVmlzaWJsZUNoaWxkcmVuO1xyXG4gICAgICAgICAgICBpZiAoQm9vbGVhbihuZXdWaXNpYmlibGl0eSkgIT09IEJvb2xlYW4obW9kZWwuaW52aXNpYmxlKSkgY2hhbmdlZElkcy5wdXNoKG1vZGVsLmlkKTtcclxuICAgICAgICAgICAgbW9kZWwuaW52aXNpYmxlID0gaW52aXNpYmxlICYmIG5vVmlzaWJsZUNoaWxkcmVuO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG1vZGVsLmludmlzaWJsZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX2dldEFsbENoaWxkcmVuICgpIHtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoc2VsZi5lbGVtZW50c01hcCkubWFwKGlkID0+IHNlbGYuZWxlbWVudHNNYXBbaWRdKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfZ2V0RmxhdEVsZW1lbnRzTWFwIChtb2RlbCkge1xyXG4gICAgICAgIGxldCBlbGVtZW50c01hcCA9IHt9O1xyXG4gICAgICAgIHJlY3Vyc2lvbihtb2RlbCwgZmFsc2UpO1xyXG4gICAgICAgIHJldHVybiBlbGVtZW50c01hcDtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcmVjdXJzaW9uIChlbGVtZW50LCBpbnZpc2libGUpIHtcclxuICAgICAgICAgICAgaWYgKCFlbGVtZW50c01hcFtlbGVtZW50LmlkXSkge1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudHNNYXBbZWxlbWVudC5pZF0gPSBlbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudC5pbnZpc2libGUgPSBpbnZpc2libGU7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50LmNoaWxkcmVuLm1hcChjaGlsZCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVjdXJzaW9uKGNoaWxkLCBlbGVtZW50LmNvbGxhcHNlZCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfcG9ydHNUZW1wbGF0ZSAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9nZXRBbGxDaGlsZHJlbigpLm1hcChlbGVtZW50ID0+IHtcclxuICAgICAgICAgICAgY29uc3QgaW5Qb3J0SWQgPSBnZXRQb3J0SWQoZWxlbWVudC5pZCwgJ2luJyk7XHJcbiAgICAgICAgICAgIGNvbnN0IG91dFBvcnRJZCA9IGdldFBvcnRJZChlbGVtZW50LmlkLCAnb3V0Jyk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYFxyXG4gICAgICAgICAgICAgICAgPGNpcmNsZSBjbGFzcz1cImRuLWluLXBvcnQgJHtpblBvcnRJZH1cIiBwb3J0PVwiJHtpblBvcnRJZH1cIi8+XHJcbiAgICAgICAgICAgICAgICA8Y2lyY2xlIGNsYXNzPVwiZG4tb3V0LXBvcnQgJHtvdXRQb3J0SWR9XCIgcG9ydD1cIiR7b3V0UG9ydElkfVwiLz5cclxuICAgICAgICAgICAgYDtcclxuICAgICAgICB9KS5qb2luKCcnKTtcclxuICAgIH1cclxufVxyXG5HcmFwaE5vZGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShqb2ludC5zaGFwZXMuZGV2cy5Nb2RlbC5wcm90b3R5cGUpO1xyXG5cclxuXHJcbmNvbnN0IERFRkFVTFRfQ1JPU1NfTk9ERV9TSVpFID0ge1xyXG4gICAgd2lkdGg6IDEsIGhlaWdodDogMSxcclxufTtcclxuLyoqXHJcbiAqIEpvaW50Q3Jvc3NOb2RlXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBjbGFzc1xyXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBHcmFwaENyb3NzTm9kZSAobW9kZWwpIHtcclxuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xyXG5cclxuICAgIHNlbGYubW9kZWwgPSBtb2RlbDtcclxuICAgIHNlbGYuaGlkZGVuID0gZmFsc2U7XHJcblxyXG4gICAgam9pbnQuc2hhcGVzLmJhc2ljLkdlbmVyaWMuYXBwbHkoc2VsZiwgW3tcclxuICAgICAgICB0eXBlOiAnZGVyaXZhdGlvbkNyb3NzTm9kZScsXHJcbiAgICAgICAgbWFya3VwOiBgPGcgY2xhc3M9XCJyb3RhdGFibGVcIj5cclxuICAgICAgICAgICAgPGcgY2xhc3M9XCJzY2FsYWJsZSBleHBvcnQtYW5jaG9yXCI+XHJcbiAgICAgICAgICAgICAgICA8Y2lyY2xlIGNsYXNzPVwiYm9keVwiLz5cclxuICAgICAgICAgICAgPC9nPlxyXG4gICAgICAgIDwvZz5gLFxyXG4gICAgICAgIHNpemU6IERFRkFVTFRfQ1JPU1NfTk9ERV9TSVpFLFxyXG4gICAgICAgIHo6IFpfSU5ERVhFUy5MSU5LLFxyXG4gICAgICAgIGF0dHJzOiB7XHJcbiAgICAgICAgICAgIGNpcmNsZToge1xyXG4gICAgICAgICAgICAgICAgcjogJzVweCcsXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6ICdibGFjaycsXHJcbiAgICAgICAgICAgICAgICAnc3Ryb2tlLXdpZHRoJzogMyxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9LFxyXG4gICAgfV0pO1xyXG5cclxuICAgIHNlbGYuaGlnaGxpZ2h0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHNlbGYuaGlkZGVuID0gZmFsc2U7XHJcbiAgICAgICAgc2VsZi5wcm9wKHsgejogWl9JTkRFWEVTLlNFTEVDVEVEX0VMRU1FTlQgfSk7XHJcbiAgICAgICAgc2VsZi5zZXQoJ2hpZ2hsaWdodGVkJywgdHJ1ZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYudW5oaWdobGlnaHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgc2VsZi5wcm9wKHsgejogWl9JTkRFWEVTLkxJTksgfSk7XHJcbiAgICAgICAgc2VsZi5zZXQoJ2hpZ2hsaWdodGVkJywgZmFsc2UpO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLnNob3cgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgc2VsZi5oaWRkZW4gPSBmYWxzZTtcclxuICAgICAgICBzZWxmLnByb3AoeyB6OiBaX0lOREVYRVMuTElOSyB9KTtcclxuICAgICAgICBzZWxmLnRyaWdnZXIoJ3VwZGF0ZS1zdGF0ZScpO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLmhpZGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgc2VsZi5oaWRkZW4gPSB0cnVlO1xyXG4gICAgICAgIHNlbGYucHJvcCh7IHo6IFpfSU5ERVhFUy5CTFVSRURfTElOSyB9KTtcclxuICAgICAgICBzZWxmLnRyaWdnZXIoJ3VwZGF0ZS1zdGF0ZScpO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLmdldENyb3NzZWRFbGVtZW50cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gc2VsZi5tb2RlbC5jcm9zc2VkRWxlbWVudHM7XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYucmVmcmVzaCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBzZWxmLnRyaWdnZXIoJ3JlZHJhdy12aWV3Jyk7XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYuc2V0U2NhbGUgPSBmdW5jdGlvbiAoc2NhbGUpIHtcclxuICAgICAgICBzZWxmLnNjYWxlID0gc2NhbGU7XHJcbiAgICB9O1xyXG59XHJcbkdyYXBoQ3Jvc3NOb2RlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoam9pbnQuc2hhcGVzLmJhc2ljLkdlbmVyaWMucHJvdG90eXBlKTtcclxuXHJcbi8qKlxyXG4gKiBETUxpbmtNb2RlbCAtIGRhdGEgbW9kZWwgZm9yIGEge0BsaW5rIExpbmt9IG9iamVjdFxyXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBETUxpbmtNb2RlbFxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdHlwZUlkIC0gTGluayB0eXBlIGlkZW50aWZ5ZXJcclxuICogQHByb3BlcnR5IHtHcmFwaE5vZGV9IHRhcmdldCAtIFRhcmdldCBOb2RlXHJcbiAqIEBwcm9wZXJ0eSB7R3JhcGhOb2RlfSBzb3VyY2UgLSBTb3VyY2UgTm9kZVxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbGFiZWwgLSBUZXh0IGluIHRoZSBtaWRkbGUgb2YgdGhlIGxpbmtcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGxpbmt0eXBlIC0gVHlwZSBvZiB0aGUgTGlua1xyXG4gKiBAcHJvcGVydHkge0dyYXBoTGlua1tdfSBjcm9zc2VkRWxlbWVudHMgLSBpbiBjYXNlIG9mIHRoZSBsaW5rIGlzIGEgcGFydCBvZiBncm91cGVkIGxpbmtzXHJcbiovXHJcblxyXG4vKipcclxuICogSm9pbnRMaW5rXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBjbGFzc1xyXG4gKiBAcGFyYW0ge0RNTGlua01vZGVsfSBtb2RlbFxyXG4gKiBAcGFyYW0ge1BhcmFtdGVyc30gcGFyYW1ldGVyc1xyXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBHcmFwaExpbmsgKG1vZGVsLCBwYXJhbWV0ZXJzKSB7XHJcbiAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgc2VsZi5tb2RlbCA9IG1vZGVsO1xyXG4gICAgc2VsZi5oaWRkZW4gPSBmYWxzZTtcclxuXHJcbiAgICBjb25zdCBfcmVzID0gbmV3IFJlc291cmNlUHJvdmlkZXIocGFyYW1ldGVycyk7XHJcbiAgICBjb25zdCBfbGlua1N0eWxlID0gX3Jlcy5nZXRMaW5rU3R5bGUobW9kZWwudHlwZUlkKTtcclxuICAgIGNvbnN0IHR5cGVzID0gW0RFRkFVTFRfTElOS19UWVBFXTtcclxuXHJcbiAgICBpZiAoX2xpbmtTdHlsZS5jc3NDbGFzcyAmJiBfbGlua1N0eWxlLmNzc0NsYXNzICE9PSBERUZBVUxUX0xJTktfVFlQRSkge1xyXG4gICAgICAgIHR5cGVzLnB1c2goX2xpbmtTdHlsZS5jc3NDbGFzcyk7XHJcbiAgICB9XHJcblxyXG4gICAgam9pbnQuZGlhLkxpbmsuYXBwbHkoc2VsZiwgW3tcclxuICAgICAgICB0eXBlOiB0eXBlcy5qb2luKCcgJyksXHJcbiAgICAgICAgejogWl9JTkRFWEVTLkxJTkssXHJcbiAgICAgICAgc291cmNlOiBtb2RlbC5zb3VyY2UsXHJcbiAgICAgICAgdGFyZ2V0OiBtb2RlbC50YXJnZXQsXHJcbiAgICAgICAgYXR0cnM6IF9nZXRMaW5rQXR0cmlidXRlcyhfbGlua1N0eWxlKSxcclxuICAgICAgICBsYWJlbHM6IFt7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiAuNSxcclxuICAgICAgICAgICAgYXR0cnM6IHtcclxuICAgICAgICAgICAgICAgIHJlY3Q6IHsgZmlsbDogX2xpbmtTdHlsZS50ZXh0QmFja2dyb3VuZENvbG9yIH0sXHJcbiAgICAgICAgICAgICAgICB0ZXh0OiB7IGZpbGw6IF9saW5rU3R5bGUudGV4dENvbG9yLCB0ZXh0OiBtb2RlbC5sYWJlbCB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XSxcclxuICAgICAgICBjb25uZWN0b3I6IHtuYW1lOiAncm91bmRlZCd9LFxyXG4gICAgICAgIC8vIGNvbm5lY3RvcjogeyBuYW1lOiAnanVtcG92ZXInLCBhcmdzOiB7IHR5cGU6ICdnYXAnIH19LFxyXG4gICAgICAgIHJvdXRlcjoge1xyXG4gICAgICAgICAgICBuYW1lOiAnZG1yb3V0ZXInLFxyXG4gICAgICAgIH1cclxuICAgIH1dKTtcclxuXHJcbiAgICBzZWxmLmhpZ2hsaWdodCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBzZWxmLmhpZGRlbiA9IGZhbHNlO1xyXG4gICAgICAgIHNlbGYucHJvcCh7IHo6IFpfSU5ERVhFUy5TRUxFQ1RFRF9FTEVNRU5UIH0pO1xyXG4gICAgICAgIHNlbGYuc2V0KCdoaWdobGlnaHRlZCcsIHRydWUpO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLnVuaGlnaGxpZ2h0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHNlbGYucHJvcCh7IHo6IFpfSU5ERVhFUy5MSU5LIH0pO1xyXG4gICAgICAgIHNlbGYuc2V0KCdoaWdobGlnaHRlZCcsIGZhbHNlKTtcclxuICAgIH07XHJcblxyXG4gICAgc2VsZi5nZXRMaW5rU3R5bGUgPSAoKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIF9saW5rU3R5bGU7XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYuc2hvdyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBzZWxmLmhpZGRlbiA9IGZhbHNlO1xyXG4gICAgICAgIHNlbGYucHJvcCh7IHo6IFpfSU5ERVhFUy5MSU5LIH0pO1xyXG4gICAgICAgIHNlbGYudHJpZ2dlcigndXBkYXRlLXN0YXRlJyk7XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYuaGlkZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBzZWxmLmhpZGRlbiA9IHRydWU7XHJcbiAgICAgICAgc2VsZi5wcm9wKHsgejogWl9JTkRFWEVTLkJMVVJFRF9MSU5LIH0pO1xyXG4gICAgICAgIHNlbGYudHJpZ2dlcigndXBkYXRlLXN0YXRlJyk7XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIF9nZXRMaW5rQXR0cmlidXRlcyAobGlua1N0eWxlLCBoYXNBcnJvdykge1xyXG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSB7fTtcclxuICAgICAgICBhdHRyaWJ1dGVzWycuY29ubmVjdGlvbiddID0ge1xyXG4gICAgICAgICAgICBzdHJva2U6IGxpbmtTdHlsZS5jb2xvcixcclxuICAgICAgICAgICAgJ3N0cm9rZS13aWR0aCc6IGxpbmtTdHlsZS50aGlja25lc3MsXHJcbiAgICAgICAgICAgICdzdHJva2UtZGFzaGFycmF5JzogbGlua1N0eWxlLmxpbmVUeXBlID09PSAnc29saWQnID8gdW5kZWZpbmVkIDogJzUsNScsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBhdHRyaWJ1dGVzWycubWFya2VyLXRhcmdldCddID0gaGFzQXJyb3cgPyBnZXRMaW5rTWFya2VyVGFyZ2V0KGxpbmtTdHlsZSkgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZXM7XHJcbiAgICB9XHJcbn1cclxuR3JhcGhMaW5rLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoam9pbnQuZGlhLkxpbmsucHJvdG90eXBlKTtcclxuXHJcbi8qKlxyXG4gKiBKb2ludExpbmtcclxuICogQHByaXZhdGVcclxuICogQGNsYXNzXHJcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIEdyYXBoQ3Jvc3NMaW5rIChtb2RlbCwgcGFyYW10ZXJzKSB7XHJcbiAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgc2VsZi5tb2RlbCA9IG1vZGVsO1xyXG5cclxuICAgIEdyYXBoTGluay5hcHBseShzZWxmLCBbbW9kZWwsIHBhcmFtdGVyc10pO1xyXG5cclxuICAgIHNlbGYuZ2V0Q3Jvc3NlZEVsZW1lbnRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBzZWxmLm1vZGVsLmNyb3NzZWRFbGVtZW50cztcclxuICAgIH07XHJcbn1cclxuR3JhcGhDcm9zc0xpbmsucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcmFwaExpbmsucHJvdG90eXBlKTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRQb3J0SWQgKHBvcnRJZCwgZGlyZWN0aW9uKSB7XHJcbiAgICBjb25zdCBpc1RhcmdldCA9IGRpcmVjdGlvbiA9PT0gJ2luJztcclxuICAgIHJldHVybiBgJHtpc1RhcmdldCA/ICdJbl8nIDogJ091dF8nfVBvcnRfJHtlbmNvZGVVUkkocG9ydElkKX1gO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0TGlua01hcmtlclRhcmdldCAobGlua1N0eWxlKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGZpbGw6IGxpbmtTdHlsZS5jb2xvcixcclxuICAgICAgICBzdHJva2U6IGxpbmtTdHlsZS5jb2xvcixcclxuICAgICAgICBkOiBNQVJLRVJfVEFSR0VULmQsXHJcbiAgICAgICAgJ3N0cm9rZS13aWR0aCc6IGxpbmtTdHlsZS50aGlja25lc3MsXHJcbiAgICB9O1xyXG59IiwiaW1wb3J0ICogYXMgam9pbnQgZnJvbSAncmFwcGlkJztcclxuaW1wb3J0IHNhdmVBcyBmcm9tICdmaWxlLXNhdmVyanMnO1xyXG5cclxuaW1wb3J0IHsgR3JhcGhOb2RlVmlldywgR3JhcGhMaW5rVmlldyB9IGZyb20gJy4vbWFwVmlld3MnO1xyXG5pbXBvcnQgeyBOb2RlLCBMaW5rLCBHcmFwaE5vZGUsIEdyYXBoTGluayB9IGZyb20gJy4vbWFwRWxlbWVudHMnO1xyXG5pbXBvcnQgeyBleHBvcnRUb1NWRywgdG9EYXRhVVJMIH0gZnJvbSAnLi4vdG9TdmcnO1xyXG5pbXBvcnQgU3Vic2NyaWJhYmxlIGZyb20gJy4uLy4uL3N1YnNjcmlwdGlvbkFQSS9zdWJzY3JpYmVhYmxlJztcclxuaW1wb3J0IFNhbmtleSBmcm9tICcuLi8uLi9sYXlvdXQvc2Fua2V5JztcclxuaW1wb3J0IHsgcmVtb3ZlQ3ljbGVzIH0gZnJvbSAnLi4vLi4vbGF5b3V0L2xheW91dCc7XHJcbmltcG9ydCB7IGNvbnZlcnRETUVsZW1lbnRzVG9MYXlvdXRNb2RlbHMsIGNvbnZlcnRKb2ludEVsZW1lbnRzVG9MYXlvdXRNb2RlbHMgfSBmcm9tICcuLi8uLi91dGlscy9sYXlvdXRVdGlscyc7XHJcbmltcG9ydCB7IGRhdGUyU3RyaW5nLCBwbmcyQmxvYiB9IGZyb20gJy4uLy4uL3V0aWxzL2RhdGFVdGlscyc7XHJcbmltcG9ydCB7IGFkanVzdFZlcnRpY2VzIH0gZnJvbSAnLi4vLi4vdXRpbHMvbGluZWFnZURpYWdyYW1VdGlscyc7XHJcbmltcG9ydCB7IGFycmF5VG9NYXAgfSBmcm9tICcuLi8uLi91dGlscy91dGlscyc7XHJcblxyXG5qb2ludC5zaGFwZXNbJ2dyYXBoLWRlcml2YXRpb24tbm9kZSddID0ge1xyXG4gICAgR3JhcGhOb2RlOiBHcmFwaE5vZGUsXHJcbiAgICBHcmFwaE5vZGVWaWV3OiBHcmFwaE5vZGVWaWV3LFxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFNldCBvZiBvcHRpb25zIGZvciBkZXJpdmF0aW9uIG1hcCBsYXlvdXQgY2xhc3MuXHJcbiAqIEB0eXBlZGVmIHtPYmplY3R9IERNTGF5b3V0T3B0aW9uc1xyXG4gKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fSByb290RWxlbWVudFxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbGluZVR5cGUgLSAnc29saWQnIG9yICdkYXNoZWQnXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjb2xvciAtIENvbG9yIG9mIHRoZSBsaW5lXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0ZXh0Q29sb3IgLSBDb2xvciBvZiB0aGUgdGV4dCBvbiB0aGUgbGluZVxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdGV4dEJhY2tncm91bmRDb2xvciAtIENvbG9yIG9mIHRoZSBiYWNrZ3JvdW5kIG9mIHRoZSB0ZXh0IG9uIHRoZSBsaW5lXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0aGlja25lc3NcclxuKi9cclxuXHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0ge0RNTGF5b3V0T3B0aW9uc30gcHJvcGVydGllc1xyXG4gKiBAZmlyZXMgYmxhbmstY2xpY2tcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBNYXBMYXlvdXQgKHByb3BlcnRpZXMsIHBhcmFtZXRlcnMpIHtcclxuICAgIFN1YnNjcmliYWJsZS5hcHBseSh0aGlzKTtcclxuXHJcbiAgICBjb25zdCBzZWxmID0gdGhpcztcclxuICAgIGNvbnN0IF9ncmFwaCA9IG5ldyBqb2ludC5kaWEuR3JhcGgoKTtcclxuICAgIGxldCBfc3RhcnRQb2ludCA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICBjb25zdCBfcGFwZXIgPSBuZXcgam9pbnQuZGlhLlBhcGVyKHtcclxuICAgICAgICBtb2RlbDogX2dyYXBoLFxyXG4gICAgICAgIC8vIGVsZW1lbnRWaWV3OiBHcmFwaE5vZGVWaWV3LFxyXG4gICAgICAgIGxpbmtWaWV3OiBHcmFwaExpbmtWaWV3LFxyXG4gICAgICAgIGdyaWRTaXplOiAxLFxyXG4gICAgICAgIHByZXZlbnRDb250ZXh0TWVudTogZmFsc2UsXHJcbiAgICAgICAgaW50ZXJhY3RpdmU6ICgpID0+IHsgcmV0dXJuIHsgdmVydGV4QWRkOiBmYWxzZSB9OyB9LFxyXG4gICAgICAgIHdpZHRoOiA1MDAwLFxyXG4gICAgICAgIGhlaWdodDogNTAwMCxcclxuICAgIH0pO1xyXG4gICAgY29uc3QgX3BhcGVyU2Nyb2xsZXIgPSBuZXcgam9pbnQudWkuUGFwZXJTY3JvbGxlcih7XHJcbiAgICAgICAgcGFwZXI6IF9wYXBlcixcclxuICAgICAgICBhdXRvUmVzaXplUGFwZXI6IHRydWUsXHJcbiAgICB9KTtcclxuXHJcbiAgICBsZXQgX25vZGVzID0gW107XHJcbiAgICBsZXQgX2xpbmtzID0gW107XHJcblxyXG4gICAgcHJvcGVydGllcy5yb290RWxlbWVudC5pbm5lckhUTUwgPSAnJztcclxuICAgIHByb3BlcnRpZXMucm9vdEVsZW1lbnQuYXBwZW5kQ2hpbGQoX3BhcGVyU2Nyb2xsZXIucmVuZGVyKCkuZWwpO1xyXG5cclxuICAgIC8vIEluaXRpYWxpemF0aW9uXHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIYW5kbGluZyBtdWx0aXBsZSBsaW5rIHNpdHVhdGlvbnMgLSBiZW5kcyB0aGVtIHNvIHRoZXkgZG9uJ3QgY3Jvc3NcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAqL1xyXG5cclxuICAgIC8vIEp1c3QgcmVmcmVzaGVzIHJlbGF0ZWQgZWxlbWVudHMgb24gY2hhbmdlcy5cclxuICAgIF9ncmFwaC5vbignY2hhbmdlOnNvdXJjZSBjaGFuZ2U6dGFyZ2V0JywgX3JlZnJlc2hSZWxhdGVkRWxlbWVudCk7XHJcblxyXG4gICAgX3BhcGVyLm9uKCdibGFuazpwb2ludGVyZG93bicsIChldmVudCwgeCwgeSkgPT4ge1xyXG4gICAgICAgIF9zdGFydFBvaW50ID0geyB4OiBldmVudC5wYWdlWCwgeTogZXZlbnQucGFnZVkgfTtcclxuICAgICAgICBfcGFwZXJTY3JvbGxlci5zdGFydFBhbm5pbmcoZXZlbnQsIHgsIHkpO1xyXG4gICAgfSk7XHJcbiAgICBfcGFwZXIub24oJ2JsYW5rOnBvaW50ZXJjbGljaycsIChldmVudCkgPT4ge1xyXG4gICAgICAgIGlmICghX3N0YXJ0UG9pbnQpIHJldHVybjtcclxuXHJcbiAgICAgICAgY29uc3QgbmV3UG9pbnQgPSB7IHg6IGV2ZW50LnBhZ2VYLCB5OiBldmVudC5wYWdlWSB9O1xyXG4gICAgICAgIGNvbnN0IE9GRlNFVF9USFJFU0hPTEQgPSA1O1xyXG4gICAgICAgIGNvbnN0IG9mZnNldEV4Y2VlZFRocmVzaG9sZCA9IE1hdGguYWJzKG5ld1BvaW50LnggLSBfc3RhcnRQb2ludC54KSA8IE9GRlNFVF9USFJFU0hPTEQgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguYWJzKG5ld1BvaW50LnggLSBfc3RhcnRQb2ludC54KSA8IE9GRlNFVF9USFJFU0hPTEQ7XHJcbiAgICAgICAgaWYgKG9mZnNldEV4Y2VlZFRocmVzaG9sZCkge1xyXG4gICAgICAgICAgICBzZWxmLnRyaWdnZXIoJ2JsYW5rLWNsaWNrJywgZXZlbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfc3RhcnRQb2ludCA9IHVuZGVmaW5lZDtcclxuICAgIH0pO1xyXG4gICAgX3BhcGVyLm9uKCdjZWxsOnBvaW50ZXJkb3duJywgZnVuY3Rpb24gKGNlbGxWaWV3KSB7XHJcbiAgICAgICAgX25vZGVzLmZvckVhY2goZWwgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZWwub25QYXBlckNlbGxQb2ludGVyRG93bikgZWwub25QYXBlckNlbGxQb2ludGVyRG93bihjZWxsVmlldy5tb2RlbCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgX2xpbmtzLmZvckVhY2goZWwgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZWwub25QYXBlckNlbGxQb2ludGVyRG93bikgZWwub25QYXBlckNlbGxQb2ludGVyRG93bihjZWxsVmlldy5tb2RlbCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCBvbk1vdXNlV2hlZWwgPSAoZXZ0LCB4LCB5LCBkZWx0YSkgPT4ge1xyXG4gICAgICAgIGlmIChldnQuY3RybEtleSkge1xyXG4gICAgICAgICAgICBzZWxmLnpvb20oMC4xICogKGRlbHRhIDwgMCA/IC0xIDogMSksIHsgbWF4OiA0IH0pO1xyXG4gICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgX3BhcGVyLm9uKCdjZWxsOm1vdXNld2hlZWwnLCAoY2VsbCwgZXZ0LCB4LCB5LCBkZWx0YSkgPT4gb25Nb3VzZVdoZWVsKGV2dCwgeCwgeSwgZGVsdGEpKTtcclxuICAgIF9wYXBlci5vbignYmxhbms6bW91c2V3aGVlbCcsIG9uTW91c2VXaGVlbCk7XHJcblxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuICAgIHNlbGYuZ2V0Tm9kZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9ub2RlcztcclxuICAgIH07XHJcblxyXG4gICAgc2VsZi5nZXRMaW5rcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX2xpbmtzO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLmdldEdyYXBoTm9kZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9ncmFwaC5nZXRFbGVtZW50cygpO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLmdldEdyYXBoTGlua3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9ncmFwaC5nZXRMaW5rcygpO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLmNsZWFyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF9ub2Rlcz1bXTtcclxuICAgICAgICBfbGlua3M9W107XHJcbiAgICAgICAgX2dyYXBoLmNsZWFyKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYuem9vbSA9IGZ1bmN0aW9uIChzY2FsZURpZmYsIG9wdCkge1xyXG4gICAgICAgIGlmICghc2NhbGVEaWZmKSB7XHJcbiAgICAgICAgICAgIF9wYXBlclNjcm9sbGVyLnpvb21Ub0ZpdCgpO1xyXG4gICAgICAgICAgICBfcGFwZXJTY3JvbGxlci56b29tKC0wLjIsIHsgbWF4OiAyLCBtaW46IDAuMiB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBfcGFwZXJTY3JvbGxlci56b29tKHNjYWxlRGlmZiwgb3B0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG5ld1NjYWxlID0gX3BhcGVyU2Nyb2xsZXIuX3N4O1xyXG5cclxuICAgICAgICBfZ3JhcGguZ2V0RWxlbWVudHMoKS5mb3JFYWNoKG5vZGUgPT4ge1xyXG4gICAgICAgICAgICBub2RlLnNldFNjYWxlKG5ld1NjYWxlKTtcclxuICAgICAgICAgICAgbm9kZS5yZWZyZXNoKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYuc2V0RWxlbWVudHMgPSBmdW5jdGlvbiAobmV3RWxlbWVudHMsIGRpYWdyYW1JbmZvKSB7XHJcbiAgICAgICAgY29uc3QgbmV3Tm9kZXMgPSBbXTtcclxuICAgICAgICBjb25zdCBuZXdMaW5rcyA9IFtdO1xyXG4gICAgICAgIG5ld0VsZW1lbnRzLmZvckVhY2goZWwgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZWwgaW5zdGFuY2VvZiBOb2RlKSB7XHJcbiAgICAgICAgICAgICAgICBuZXdOb2Rlcy5wdXNoKGVsKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChlbCBpbnN0YW5jZW9mIExpbmspIHtcclxuICAgICAgICAgICAgICAgIG5ld0xpbmtzLnB1c2goZWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIF9ub2RlcyA9IF9ub2Rlcy5jb25jYXQobmV3Tm9kZXMpO1xyXG4gICAgICAgIF9saW5rcyA9IF9saW5rcy5jb25jYXQobmV3TGlua3MpO1xyXG5cclxuICAgICAgICBjb25zdCBwcm9jZXNzZWRJZHMgPSB7fTtcclxuICAgICAgICBjb25zdCBjZWxscyA9IFtdO1xyXG5cclxuICAgICAgICBuZXdFbGVtZW50cy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBlbGVtZW50Q2VsbHMgPSBlbGVtZW50LmdldENlbGxzKCk7XHJcbiAgICAgICAgICAgIGVsZW1lbnRDZWxscy5mb3JFYWNoKGNlbGwgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFwcm9jZXNzZWRJZHNbY2VsbC5pZF0pIHtcclxuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzZWRJZHNbY2VsbC5pZF0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNlbGxzLnB1c2goY2VsbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNlbGxzLnNvcnQoKGNlbGwxLCBjZWxsMikgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBjMSA9IGNlbGwxIGluc3RhbmNlb2Ygam9pbnQuc2hhcGVzLmJhc2ljLkdlbmVyaWMgPyAxIDogMDtcclxuICAgICAgICAgICAgY29uc3QgYzIgPSBjZWxsMiBpbnN0YW5jZW9mIGpvaW50LnNoYXBlcy5iYXNpYy5HZW5lcmljID8gMSA6IDA7XHJcbiAgICAgICAgICAgIHJldHVybiBjMiAtIGMxO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIF9ncmFwaC5hZGRDZWxscyhjZWxscyk7XHJcblxyXG4gICAgICAgIGNlbGxzLmZvckVhY2goY2VsbCA9PiBfcmVmcmVzaFJlbGF0ZWRFbGVtZW50KGNlbGwpKTtcclxuICAgICAgICBfc3Vic2NyaWJlT25FbGVtZW50cygpO1xyXG4gICAgICAgIF9kb0xheW91dChkaWFncmFtSW5mbyk7XHJcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIF9kb0xheW91dChkaWFncmFtSW5mbyk7XHJcbiAgICAgICAgICAgIHNlbGYuem9vbSgpO1xyXG4gICAgICAgIH0sIDEwMCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRXhwb3J0cyBncmFwaCB0byBwbmcgb3Igc3ZnIGZpbGVcclxuICAgICAqIEBwYXJhbSB7XHJcbiAgICAgKiAgbmFtZT86IHN0cmluZyAtIGZpbGUgbmFtZVxyXG4gICAgICogIHR5cGU/OiBzdHJpbmcgLSAocG5nL3N2ZylcclxuICAgICAqIH0gb3B0aW9uc1xyXG4gICAgKi9cclxuICAgIHNlbGYuZXhwb3J0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICBjb25zdCBmaWxlTmFtZSA9IG9wdGlvbnMubmFtZSB8fFxyXG4gICAgICAgICAgICAnRE1fbGluZWFnZV9kaWFncmFtX3NuYXBzaG90XycgKyBkYXRlMlN0cmluZyhuZXcgRGF0ZSgpKTtcclxuXHJcbiAgICAgICAgaWYgKG9wdGlvbnMudHlwZSA9PT0gJ3BuZycpIHtcclxuICAgICAgICAgICAgdG9EYXRhVVJMKF9wYXBlciwge1xyXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnd2hpdGUnLFxyXG4gICAgICAgICAgICAgICAgc3ZnT3B0aW9uczoge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzVG9SZW1vdmVTZWxlY3RvcjogJycsXHJcbiAgICAgICAgICAgICAgICAgICAgY29udmVydEh0bWw6IHRydWUsXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pLnRoZW4oYmFzZTY0VVJMID0+IHtcclxuICAgICAgICAgICAgICAgIHNhdmVEYXRhKGJhc2U2NFVSTCwgZmlsZU5hbWUsICdwbmcnKTtcclxuICAgICAgICAgICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlcnJvciA9PT0gJ3N0cmluZycpIGFsZXJ0KGVycm9yKTtcclxuICAgICAgICAgICAgICAgIGVsc2UgYWxlcnQoJ1RoaXMgdHlwZSBvZiBleHBvcnQgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGUgSW50ZXJuZXQgRXhwbG9yZXInKTtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBleHBvcnRUb1NWRyhfcGFwZXIsIHtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnRzVG9SZW1vdmVTZWxlY3RvcjogJycsXHJcbiAgICAgICAgICAgICAgICBjb252ZXJ0SHRtbDogdHJ1ZSxcclxuICAgICAgICAgICAgfSkudGhlbihzdmdTdHJpbmcgPT4ge1xyXG4gICAgICAgICAgICAgICAgc2F2ZURhdGEoc3ZnU3RyaW5nLCBmaWxlTmFtZSwgJ3N2ZycpO1xyXG4gICAgICAgICAgICB9KS5jYXRjaChlcnJvciA9PiB7XHJcbiAgICAgICAgICAgICAgICBhbGVydChlcnJvcik7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBzYXZlRGF0YSAoZGF0YSwgZmlsZU5hbWUsIHR5cGUpIHtcclxuICAgICAgICAgICAgbGV0IGJsb2I7XHJcbiAgICAgICAgICAgIGlmICh0eXBlID09PSAnc3ZnJykge1xyXG4gICAgICAgICAgICAgICAgYmxvYiA9IG5ldyBCbG9iKFtkYXRhXSwgeyB0eXBlOiB0eXBlIH0pO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdwbmcnKSB7XHJcbiAgICAgICAgICAgICAgICBibG9iID0gcG5nMkJsb2IgKGRhdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNhdmVBcyhibG9iLCBmaWxlTmFtZSArICcuJyArIHR5cGUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTaG93cyBwcmludCBkaWFsb2cuXHJcbiAgICAqL1xyXG4gICAgc2VsZi5wcmludCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0b0RhdGFVUkwoX3BhcGVyLCB7XHJcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3doaXRlJyxcclxuICAgICAgICAgICAgc3ZnT3B0aW9uczoge1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudHNUb1JlbW92ZVNlbGVjdG9yOiAnJyxcclxuICAgICAgICAgICAgICAgIGNvbnZlcnRIdG1sOiB0cnVlLFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSkudGhlbihiYXNlNjRVUkwgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBwcmludFdpbmRvdyA9IHdpbmRvdy5vcGVuKCcnLCB1bmRlZmluZWQsICd3aWR0aD0xMjgwLGhlaWdodD03MjAnKTtcclxuICAgICAgICAgICAgaWYgKHByaW50V2luZG93KSB7XHJcbiAgICAgICAgICAgICAgICBwcmludFdpbmRvdy5kb2N1bWVudC53cml0ZShgXHJcbiAgICAgICAgICAgICAgICAgICAgPGh0bWw+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxib2R5PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGltZyBzcmM9XCIke2Jhc2U2NFVSTH1cIi8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvYm9keT5cclxuICAgICAgICAgICAgICAgICAgICA8L2h0bWw+XHJcbiAgICAgICAgICAgICAgICBgKTtcclxuICAgICAgICAgICAgICAgIHByaW50V2luZG93LmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2ltZycpLm9ubG9hZCA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBwcmludFdpbmRvdy5kb2N1bWVudC5jbG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHByaW50V2luZG93LnByaW50KCk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYWxlcnQoJ1lvdSBzaG91bGQgdW5ibG9jayBwb3B1cCB3aW5kb3dzIGZvciB0aGUgY3VycmVudCB1cmwgdG8gYmUgYWJsZSB0byBwcmludCB0aGlzIGRpYWdyYW0hJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KS5jYXRjaChlcnJvciA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXJyb3IgPT09ICdzdHJpbmcnKSBhbGVydChlcnJvcik7XHJcbiAgICAgICAgICAgIGVsc2UgYWxlcnQoJ1RoaXMgdHlwZSBvZiBleHBvcnQgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGUgSW50ZXJuZXQgRXhwbG9yZXInKTtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYuc2V0U2VhcmNoS2V5ID0gZnVuY3Rpb24gKHNlYXJjaEtleSkge1xyXG4gICAgICAgIF9ncmFwaC5nZXRFbGVtZW50cygpLmZvckVhY2gobm9kZSA9PiB7XHJcbiAgICAgICAgICAgIG5vZGUuc2V0U2VhcmNoS2V5KHNlYXJjaEtleSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIF9kb0xheW91dCAoZGlhZ3JhbUluZm8pIHsgLy8gdG9kbzogcmVmYWN0b3IgdGhpcyBhbGdvcml0aG1cclxuICAgICAgICBjb25zdCBzb3VyY2VJZCA9IGRpYWdyYW1JbmZvID8gZGlhZ3JhbUluZm8uc291cmNlSWQgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0SWQgPSBkaWFncmFtSW5mbyA/IGRpYWdyYW1JbmZvLnRhcmdldElkIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIGNvbnN0IGNlbnRlclggPSBfcGFwZXJTY3JvbGxlci5vcHRpb25zLmJhc2VXaWR0aCAvIDI7XHJcbiAgICAgICAgY29uc3QgY2VudGVyWSA9IF9wYXBlclNjcm9sbGVyLm9wdGlvbnMuYmFzZUhlaWdodCAvIDI7XHJcblxyXG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0gY29udmVydERNRWxlbWVudHNUb0xheW91dE1vZGVscyhfbm9kZXMsIF9saW5rcyk7XHJcbiAgICAgICAgcmVtb3ZlQ3ljbGVzKGVsZW1lbnRzLm5vZGVzLCBlbGVtZW50cy5saW5rcyk7XHJcbiAgICAgICAgdHFTYW5rZXlMYXlvdXQoZWxlbWVudHMubm9kZXMsIGVsZW1lbnRzLmxpbmtzLCBzb3VyY2VJZCwgdGFyZ2V0SWQpO1xyXG5cclxuICAgICAgICBjb25zdCBqb2ludEVsZW1lbnRzID0gY29udmVydEpvaW50RWxlbWVudHNUb0xheW91dE1vZGVscyhfZ3JhcGguZ2V0RWxlbWVudHMoKSwgX2dyYXBoLmdldExpbmtzKCkpO1xyXG4gICAgICAgIHJlbW92ZUN5Y2xlcyhqb2ludEVsZW1lbnRzLm5vZGVzLCBqb2ludEVsZW1lbnRzLmxpbmtzKTtcclxuICAgICAgICB0cVNhbmtleUxheW91dChqb2ludEVsZW1lbnRzLm5vZGVzLCBqb2ludEVsZW1lbnRzLmxpbmtzLCBzb3VyY2VJZCwgdGFyZ2V0SWQpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGNvbnN0IGRlcHRoTWFwID0gYXJyYXlUb01hcChcclxuICAgICAgICAgICAgam9pbnRFbGVtZW50cy5ub2Rlcy5tYXAoamUgPT4gKHsgaWQ6IGplLmlkLCBkZXB0aDogamUueSB9KSksXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgbGV0IG1heENvbCA9IC1JbmZpbml0eTtcclxuICAgICAgICBlbGVtZW50cy5ub2Rlcy5mb3JFYWNoKG4gPT4ge1xyXG4gICAgICAgICAgICBtYXhDb2wgPSBNYXRoLm1heChuLngsIG1heENvbCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHBvc3NpYmxlWGVzID0ge307XHJcbiAgICAgICAgY29uc3Qgb3JkZXIgPSB7fTtcclxuICAgICAgICBlbGVtZW50cy5ub2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xyXG4gICAgICAgICAgICBwb3NzaWJsZVhlc1tub2RlLnhdID0gdHJ1ZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCBwb3NzaWJsZUNvbHVtbnNMaXN0ID0gT2JqZWN0LmtleXMocG9zc2libGVYZXMpLm1hcChweCA9PiBNYXRoLnJvdW5kKCtweCkpO1xyXG4gICAgICAgIHBvc3NpYmxlQ29sdW1uc0xpc3Quc29ydCgoeDEsIHgyKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh4MSA+IHgyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh4MSA8IHgyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pLmZvckVhY2goKHgsIGluZGV4KSA9PiBvcmRlclt4XSA9IGluZGV4KTtcclxuXHJcbiAgICAgICAgY29uc3Qgc3RlcFggPSAoXHJcbiAgICAgICAgICAgIHBhcmFtZXRlcnMuZGVmYXVsdEVsZW1lbnRXaWR0aCArXHJcbiAgICAgICAgICAgIHBhcmFtZXRlcnMuZGVmYXVsdExheW91dFN0ZXBcclxuICAgICAgICApO1xyXG4gICAgICAgIGNvbnN0IHN0YXJ0UG9zaXRpb24gPSBjZW50ZXJYIC0gc3RlcFggKiAocG9zc2libGVDb2x1bW5zTGlzdC5sZW5ndGggKyAxKSAvIDI7XHJcblxyXG4gICAgICAgIGNvbnN0IGNvbHVtbnMgPSB7fTtcclxuICAgICAgICBlbGVtZW50cy5ub2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbE5vZGUgPSBub2RlLm9yaWdpbmFsTm9kZTtcclxuICAgICAgICAgICAgY29uc3QgeCA9IHN0YXJ0UG9zaXRpb24gKyBzdGVwWCAqIG9yZGVyW01hdGgucm91bmQobm9kZS54KV07XHJcbiAgICAgICAgICAgIGlmICghY29sdW1uc1t4XSkgY29sdW1uc1t4XSA9IFtdO1xyXG4gICAgICAgICAgICBjb2x1bW5zW3hdLnB1c2gob3JpZ2luYWxOb2RlKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgY29uc3QgQk9UVE9NX01BUkdJTiA9IDUwO1xyXG4gICAgICAgIE9iamVjdC5rZXlzKGNvbHVtbnMpLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY29sdW1uID0gY29sdW1uc1trZXldO1xyXG4gICAgICAgICAgICBsZXQgdG90YWxIZWlnaHQgPSAwO1xyXG4gICAgICAgICAgICBjb2x1bW4uZm9yRWFjaCgoZWwsIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0aGVMYXN0ID0gaW5kZXggPT09IGNvbHVtbi5sZW5ndGggLSAxO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3RlcCA9ICh0aGVMYXN0ID8gMCA6IEJPVFRPTV9NQVJHSU4pO1xyXG4gICAgICAgICAgICAgICAgdG90YWxIZWlnaHQgKz0gZWwuZ2V0KCdzaXplJykuaGVpZ2h0ICsgc3RlcDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNvbHVtbi5zb3J0KChlMSwgZTIpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGUxRGVwdGggPSAoZGVwdGhNYXBbZTEuaWRdID8gZGVwdGhNYXBbZTEuaWRdLmRlcHRoIDogMCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlMkRlcHRoID0gKGRlcHRoTWFwW2UyLmlkXSA/IGRlcHRoTWFwW2UyLmlkXS5kZXB0aCA6IDApO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChlMURlcHRoID4gZTJEZXB0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlMURlcHRoIDwgZTJEZXB0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjb25zdCBzdGFydFkgPSBjZW50ZXJZIC0gdG90YWxIZWlnaHQgLyAyO1xyXG4gICAgICAgICAgICBjb25zdCB4ID0gK2tleTtcclxuICAgICAgICAgICAgbGV0IGN1clkgPSAwO1xyXG4gICAgICAgICAgICBjb2x1bW4uZm9yRWFjaCgoZWwsIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpc0xhc3QgPSBpbmRleCA9PT0gY29sdW1uLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdGVwID0gKGlzTGFzdCA/IDAgOiBCT1RUT01fTUFSR0lOKTtcclxuICAgICAgICAgICAgICAgIGVsLnBvc2l0aW9uKHgsIHN0YXJ0WSArIGN1clkpO1xyXG4gICAgICAgICAgICAgICAgY3VyWSArPSBlbC5nZXQoJ3NpemUnKS5oZWlnaHQgKyBzdGVwO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICBfcGFwZXJTY3JvbGxlci5jZW50ZXIoY2VudGVyWCwgY2VudGVyWSk7XHJcblxyXG4gICAgICAgIC8vIFdlIGhpZGUgZHVibGljYXRpb25zIHVzaW5nIGhpZ2hsaWdodGVyLlxyXG4gICAgICAgIC8vIFRoYXQncyB3aHkgd2UgbmVlZCB0byBiZSBzdXJlIHRoYXQgbm9kZXMgYXJlXHJcbiAgICAgICAgLy8gb24gdGhlIHBhZ2UsIHNvIHdlIHVzZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWVcclxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgX2FsaWduQ3Jvc3NOb2RlcygpO1xyXG4gICAgICAgICAgICBfZ3JhcGguZ2V0TGlua3MoKS5mb3JFYWNoKGxpbmsgPT4ge1xyXG4gICAgICAgICAgICAgICAgX2FkanVzdEFsbFZlcnRpY2VzKGxpbmspO1xyXG4gICAgICAgICAgICB9KTsgICAgXHJcbiAgICAgICAgICAgIF9oaWRlRHVibGljYXRpb25zKCk7XHJcbiAgICAgICAgfSwgMzAwKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBhZGp1c3RpbmcgdmVydGljZXNcclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuICAgIF9ncmFwaC5vbignY2hhbmdlOnNvdXJjZSBjaGFuZ2U6dGFyZ2V0IHVwZGF0ZS12ZXJ0aWNlcycsIF9hZGp1c3RWZXJ0aWNlcyk7XHJcbiAgICBfcGFwZXIub24oJ2NlbGw6cG9pbnRlcnVwJywgX2FkanVzdFZlcnRpY2VzKTtcclxuXHJcbiAgICBmdW5jdGlvbiBfYWRqdXN0QWxsVmVydGljZXMgKCkge1xyXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICBfZ3JhcGguZ2V0TGlua3MoKS5mb3JFYWNoKGxpbmsgPT4ge1xyXG4gICAgICAgICAgICAgICAgYWRqdXN0VmVydGljZXMoX2dyYXBoLCBsaW5rKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSwgMTAwKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfYWRqdXN0VmVydGljZXMgKGNlbGwpIHtcclxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgYWRqdXN0VmVydGljZXMoX2dyYXBoLCBjZWxsKTtcclxuICAgICAgICB9LCAxMDApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuICAgIGZ1bmN0aW9uIF9zdWJzY3JpYmVPbkVsZW1lbnRzICgpIHtcclxuICAgICAgICBfbm9kZXMuZm9yRWFjaChub2RlID0+IHtcclxuICAgICAgICAgICAgbm9kZS5vbignZWxlbWVudC1zdGF0ZS1jaGFuZ2VkJywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgX2FkanVzdFZlcnRpY2VzKG5vZGUuZ2V0UG9ydCgpLnByaW1pdGl2ZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIF9yZWZyZXNoUmVsYXRlZEVsZW1lbnQgKGNlbGwpIHtcclxuICAgICAgICBpZiAoY2VsbCBpbnN0YW5jZW9mIEdyYXBoTGluaykge1xyXG4gICAgICAgICAgICBjb25zdCBlbGVtZW50c1RvVXBkYXRlID0ge307XHJcblxyXG4gICAgICAgICAgICBjb25zdCBsaW5rID0gY2VsbDtcclxuICAgICAgICAgICAgY29uc3QgcHJldlNvdXJjZURlc2NyaXB0b3IgPSBsaW5rLnByZXZpb3VzKCdzb3VyY2UnKTtcclxuICAgICAgICAgICAgY29uc3QgcHJldlRhcmdldERlc2NyaXB0b3IgPSBsaW5rLnByZXZpb3VzKCd0YXJnZXQnKTtcclxuICAgICAgICAgICAgY29uc3QgcHJldlNvdXJjZSA9IHByZXZTb3VyY2VEZXNjcmlwdG9yID8gX2dyYXBoLmdldENlbGwocHJldlNvdXJjZURlc2NyaXB0b3IuaWQpIDogdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICBjb25zdCBwcmV2VGFyZ2V0ID0gcHJldlRhcmdldERlc2NyaXB0b3IgPyBfZ3JhcGguZ2V0Q2VsbChwcmV2VGFyZ2V0RGVzY3JpcHRvci5pZCkgOiB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBzb3VyY2VEZXNjcmlwdG9yID0gbGluay5nZXQoJ3NvdXJjZScpO1xyXG4gICAgICAgICAgICBjb25zdCB0YXJnZXREZXNjcmlwdG9yID0gbGluay5nZXQoJ3RhcmdldCcpO1xyXG4gICAgICAgICAgICBjb25zdCBzb3VyY2UgPSBfZ3JhcGguZ2V0Q2VsbChzb3VyY2VEZXNjcmlwdG9yLmlkKTtcclxuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gX2dyYXBoLmdldENlbGwodGFyZ2V0RGVzY3JpcHRvci5pZCk7XHJcblxyXG4gICAgICAgICAgICBpZiAocHJldlNvdXJjZSAmJiBwcmV2U291cmNlLmFjdGl2ZVBvcnRzKSB7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50c1RvVXBkYXRlW3ByZXZTb3VyY2UuaWRdID0gcHJldlNvdXJjZTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBvcnRJZCA9IHByZXZTb3VyY2VEZXNjcmlwdG9yLnBvcnQ7XHJcbiAgICAgICAgICAgICAgICBwcmV2U291cmNlLmFjdGl2ZVBvcnRzW3BvcnRJZF0gPSBwcmV2U291cmNlLmFjdGl2ZVBvcnRzW3BvcnRJZF0gfHwge307XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgcHJldlNvdXJjZS5hY3RpdmVQb3J0c1twb3J0SWRdW2xpbmsuaWRdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwcmV2VGFyZ2V0ICYmIHByZXZUYXJnZXQuYWN0aXZlUG9ydHMpIHtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnRzVG9VcGRhdGVbcHJldlRhcmdldC5pZF0gPSBwcmV2VGFyZ2V0O1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcG9ydElkID0gcHJldlRhcmdldERlc2NyaXB0b3IucG9ydDtcclxuICAgICAgICAgICAgICAgIHByZXZUYXJnZXQuYWN0aXZlUG9ydHNbcG9ydElkXSA9IHByZXZUYXJnZXQuYWN0aXZlUG9ydHNbcG9ydElkXSB8fCB7fTtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBwcmV2VGFyZ2V0LmFjdGl2ZVBvcnRzW3BvcnRJZF1bbGluay5pZF07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChzb3VyY2UuYWN0aXZlUG9ydHMpIHtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnRzVG9VcGRhdGVbc291cmNlLmlkXSA9IHNvdXJjZTtcclxuICAgICAgICAgICAgICAgIHNvdXJjZS5hY3RpdmVQb3J0c1tzb3VyY2VEZXNjcmlwdG9yLnBvcnRdID0gc291cmNlLmFjdGl2ZVBvcnRzW3NvdXJjZURlc2NyaXB0b3IucG9ydF0gfHwge307XHJcbiAgICAgICAgICAgICAgICBzb3VyY2UuYWN0aXZlUG9ydHNbc291cmNlRGVzY3JpcHRvci5wb3J0XVtsaW5rLmlkXSA9IGxpbms7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh0YXJnZXQuYWN0aXZlUG9ydHMpIHtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnRzVG9VcGRhdGVbdGFyZ2V0LmlkXSA9IHRhcmdldDtcclxuICAgICAgICAgICAgICAgIHRhcmdldC5hY3RpdmVQb3J0c1t0YXJnZXREZXNjcmlwdG9yLnBvcnRdID0gdGFyZ2V0LmFjdGl2ZVBvcnRzW3RhcmdldERlc2NyaXB0b3IucG9ydF0gfHwge307XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQuYWN0aXZlUG9ydHNbdGFyZ2V0RGVzY3JpcHRvci5wb3J0XVtsaW5rLmlkXSA9IGxpbms7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGVsZW1lbnRzVG9VcGRhdGUpXHJcbiAgICAgICAgICAgICAgICAuZm9yRWFjaChlbElkID0+IGVsZW1lbnRzVG9VcGRhdGVbZWxJZF0ucmVmcmVzaCgpKTtcclxuICAgICAgICAgICAgX2hpZGVEdWJsaWNhdGlvbnMoKTtcclxuICAgICAgICAgICAgX2FsaWduQ3Jvc3NOb2RlcygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfYWxpZ25Dcm9zc05vZGVzICgpIHtcclxuICAgICAgICBjb25zdCB0ZW1wTWFwID0ge307XHJcbiAgICAgICAgY29uc3QgdW5pcXVlQ3Jvc3NMaW5rcyA9IFtdO1xyXG4gICAgICAgIF9saW5rcy5mb3JFYWNoKGxpbmsgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBjcm9zc05vZGUgPSBsaW5rLmdldENyb3NzTm9kZSgpO1xyXG4gICAgICAgICAgICBpZiAoY3Jvc3NOb2RlICYmICF0ZW1wTWFwW2Nyb3NzTm9kZS5pZF0pIHtcclxuICAgICAgICAgICAgICAgIHRlbXBNYXBbY3Jvc3NOb2RlLmlkXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB1bmlxdWVDcm9zc0xpbmtzLnB1c2gobGluayk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdW5pcXVlQ3Jvc3NMaW5rcy5mb3JFYWNoKGwgPT4gbC5hbGlnbkNyb3NzTm9kZSgpKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfaGlkZUR1YmxpY2F0aW9ucyAoKSB7XHJcbiAgICAgICAgY29uc3QgdW5pcXVlTWFwID0ge307XHJcbiAgICAgICAgX2xpbmtzLmZvckVhY2gobGluayA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHR5cGVJZCA9IC8qbGluay50eXBlSWQgfHwqLyBsaW5rLmxhYmVsO1xyXG4gICAgICAgICAgICBjb25zdCBzb3VyY2VQb3J0SWQgPSBsaW5rLnNvdXJjZS5nZXRQb3J0KCkuaWQ7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldFBvcnRJZCA9IGxpbmsudGFyZ2V0LmdldFBvcnQoKS5pZDtcclxuICAgICAgICAgICAgY29uc3QgY2FjaGVLZXkgPSBjYWNoZUZ1bmN0aW9uICh0eXBlSWQsIHNvdXJjZVBvcnRJZCwgdGFyZ2V0UG9ydElkKTtcclxuICAgICAgICAgICAgY29uc3QgaXNIaWdobGlnaHRlZCA9IGxpbmsuaGlnaGxpZ2h0aW5nKCk7XHJcbiAgICAgICAgICAgIGlmIChpc0hpZ2hsaWdodGVkIHx8ICF1bmlxdWVNYXBbY2FjaGVLZXldKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodW5pcXVlTWFwW2NhY2hlS2V5XSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHVuaXF1ZU1hcFtjYWNoZUtleV0uaGlkZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdW5pcXVlTWFwW2NhY2hlS2V5XSA9IGxpbms7XHJcbiAgICAgICAgICAgICAgICBsaW5rLnNob3coKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGxpbmsuaGlkZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGNhY2hlRnVuY3Rpb24gKGxhYmVsLCBzb3VyY2VQb3J0SWQsIHRhcmdldFBvcnRJZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYCR7bGFiZWx9fiN0cURNTGluayN+JHtzb3VyY2VQb3J0SWR9fiN0cURNTGluayN+JHt0YXJnZXRQb3J0SWR9YDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGRlZmF1bHQgTWFwTGF5b3V0O1xyXG5cclxuXHJcbmZ1bmN0aW9uIHRxU2Fua2V5TGF5b3V0IChub2RlcywgbGlua3MsIHNvdXJjZUlkLCB0YXJnZXRJZCwgc2F2ZU9yZGVyKSB7XHJcbiAgICBjb25zdCBzYW5rZXlMYXlvdXQgPSBTYW5rZXkoKS5zdGVwKFsxMCwgMTBdKVxyXG4gICAgICAgIC5ncm91cHMoW3tcclxuICAgICAgICAgICAgbm9kZXM6IG5vZGVzLFxyXG4gICAgICAgICAgICBsaW5rczogbGlua3MsXHJcbiAgICAgICAgfV0pXHJcbiAgICAgICAgLm5vZGVXaWR0aCgxKVxyXG4gICAgICAgIC5ub2RlSGVpZ2h0KDEpXHJcbiAgICAgICAgLm5vZGVzKG5vZGVzKVxyXG4gICAgICAgIC5zYXZlT3JkZXIoc2F2ZU9yZGVyKVxyXG4gICAgICAgIC5saW5rcyhsaW5rcyk7XHJcbiAgICAgICAgXHJcbiAgICBpZiAoc291cmNlSWQgJiYgdGFyZ2V0SWQpIHtcclxuICAgICAgICBzYW5rZXlMYXlvdXQuY29tcHV0ZU5vZGVCcmVhZHRocyA9IGZ1bmN0aW9uIChub2Rlcykge1xyXG4gICAgICAgICAgICBub2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZUlkID0gbm9kZS5vcmlnaW5hbE5vZGUubW9kZWwucmVzb3VyY2U7XHJcbiAgICAgICAgICAgICAgICBub2RlLnggPSBub2RlSWQgPT09IHNvdXJjZUlkID8gMCA6IG5vZGVJZCA9PT0gdGFyZ2V0SWQgPyAyIDogMTtcclxuICAgICAgICAgICAgICAgIG5vZGUuZHggPT09IDE7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBzYW5rZXlMYXlvdXQubGF5b3V0KDIwMDApO1xyXG59XHJcbiIsImltcG9ydCAqIGFzIGpvaW50IGZyb20gJ3JhcHBpZCc7XHJcbmltcG9ydCB7XHJcbiAgICBnZXRQb3J0SWQsXHJcbn0gZnJvbSAnLi9tYXBFbGVtZW50cyc7XHJcbmltcG9ydCB7XHJcbiAgICBvbkRyYWdTdGFydCxcclxufSBmcm9tICcuLi8uLi91dGlscy91dGlscyc7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gR3JhcGhOb2RlVmlldyAoKSB7XHJcbiAgICBqb2ludC5kaWEuRWxlbWVudFZpZXcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IE1BWF9OT0RFX0hFSUdIVCA9IDIwMDtcclxuZXhwb3J0IGNvbnN0IENTU19DTEFTU19OVU1CRVIgPSAzO1xyXG5cclxuR3JhcGhOb2RlVmlldy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGpvaW50LmRpYS5FbGVtZW50Vmlldy5wcm90b3R5cGUpO1xyXG5HcmFwaE5vZGVWaWV3LnByb3RvdHlwZS5fcHJvY2Vzc2VkSWRzOyAvLyBwcmV2ZW50IGN5Y2xlc1xyXG5HcmFwaE5vZGVWaWV3LnByb3RvdHlwZS5fc2NhbGUgPSAxOyAvLyBkZWZhdWx0IHNjYWxlXHJcblxyXG5HcmFwaE5vZGVWaWV3LnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgam9pbnQuZGlhLkVsZW1lbnRWaWV3LnByb3RvdHlwZS5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICB0aGlzLl9wcm9jZXNzZWRJZHMgPSB7fTtcclxuICAgIHRoaXMucGFydHMgPSB7fTtcclxuXHJcbiAgICBjb25zdCBib3ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTtcclxuICAgIGJveC5jbGFzc05hbWUgPSAnZGVyaXZhdGlvbi1ub2RlJztcclxuICAgIGJveC5pZCA9IHRoaXMubW9kZWwuaWQ7XHJcbiAgICBib3gub25tb3VzZWRvd24gPSAoZXZlbnQpID0+IHtcclxuICAgICAgICBvbkRyYWdTdGFydChldmVudCwgKGRpZmYpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY3VyUG9zID0gdGhpcy5tb2RlbC5wb3NpdGlvbigpO1xyXG4gICAgICAgICAgICB0aGlzLm1vZGVsLnBvc2l0aW9uKGN1clBvcy54ICsgZGlmZi54IC8gdGhpcy5fc2NhbGUsIGN1clBvcy55ICsgZGlmZi55IC8gdGhpcy5fc2NhbGUpO1xyXG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICB9LCAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMubW9kZWwuZ3JhcGgpXHJcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLmdyYXBoLnRyaWdnZXIoJ3VwZGF0ZS12ZXJ0aWNlcycsIGV2ZW50KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5wYXJ0c1snYm94J10gPSBib3g7XHJcbiAgICBcclxuICAgIGNvbnN0IHNjcm9sbGVyID0gdGhpcy5fY3JlYXRlU2Nyb2xsZXIoKTtcclxuICAgIGJveC5hcHBlbmRDaGlsZChzY3JvbGxlcik7XHJcbiAgICB0aGlzLnBhcnRzWydzY3JvbGxlciddID0gc2Nyb2xsZXI7XHJcblxyXG4gICAgY29uc3QgaGVhZGVyID0gdGhpcy5fY3JlYXRlSGVhZGVyKHRoaXMubW9kZWwubW9kZWwpO1xyXG4gICAgYm94LmFwcGVuZENoaWxkKGhlYWRlcik7XHJcbiAgICB0aGlzLnBhcnRzWydoZWFkZXInXSA9IGhlYWRlcjtcclxuXHJcbiAgICBjb25zdCBib2R5ID0gdGhpcy5fY3JlYXRlQm9keSh0aGlzLm1vZGVsLm1vZGVsKTtcclxuICAgIGJveC5hcHBlbmRDaGlsZChib2R5KTtcclxuICAgIHRoaXMucGFydHNbJ2JvZHknXSA9IGJvZHk7XHJcbiAgICBcclxuICAgIGNvbnN0IGNvbGxhcHNlQnV0dG9uID0gdGhpcy5fY3JlYXRlQ29sbGFwc2VCdXR0b24oKTtcclxuICAgIGhlYWRlci5hcHBlbmRDaGlsZChjb2xsYXBzZUJ1dHRvbik7XHJcbiAgICB0aGlzLnBhcnRzWydjb2xsYXBzZUJ1dHRvbiddID0gY29sbGFwc2VCdXR0b247XHJcblxyXG4gICAgdGhpcy5tb2RlbC5vbignY2hhbmdlJywgdGhpcy5fdXBkYXRlQm94LCB0aGlzKTtcclxuICAgIHRoaXMubW9kZWwub24oJ3JlbW92ZScsIHRoaXMuX3JlbW92ZUJveCwgdGhpcyk7XHJcbiAgICB0aGlzLm1vZGVsLm9uKCdyZWRyYXctdmlldycsIHRoaXMuZGVib3VuY2VkUmVuZGVyLCB0aGlzKTtcclxuICAgIHRoaXMubW9kZWwub24oJ2VsZW1lbnRzLXN0YXRlLWNoYW5nZWQnLCB0aGlzLmRlYm91bmNlZFJlbmRlciwgdGhpcyk7XHJcbiAgICB0aGlzLm1vZGVsLm9uKCdwb3J0cy1zdGF0ZS1jaGFuZ2VkJywgdGhpcy5fdXBkYXRlUG9ydHMsIHRoaXMpO1xyXG4gICAgdGhpcy5tb2RlbC5vbignY2hhbmdlOmNvbGxhcHNlZCcsIHRoaXMuZGVib3VuY2VkUmVuZGVyLCB0aGlzKTtcclxuXHJcbiAgICB0aGlzLl91cGRhdGUoKTtcclxufTtcclxuXHJcbkdyYXBoTm9kZVZpZXcucHJvdG90eXBlLmRlYm91bmNlcjtcclxuR3JhcGhOb2RlVmlldy5wcm90b3R5cGUuZGVib3VuY2VkUmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5kZWJvdW5jZXIpO1xyXG4gICAgdGhpcy5kZWJvdW5jZXIgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG4gICAgICAgIHRoaXMucmVuZGVyKCk7XHJcbiAgICB9KTtcclxufTtcclxuXHJcbkdyYXBoTm9kZVZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMuX3Byb2Nlc3NlZElkcyA9IHt9O1xyXG4gICAgam9pbnQuZGlhLkVsZW1lbnRWaWV3LnByb3RvdHlwZS5yZW5kZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgIGNvbnN0IGJveCA9IHRoaXMucGFydHNbJ2JveCddO1xyXG4gICAgaWYgKHRoaXMucGFwZXIpIHtcclxuICAgICAgICB0aGlzLl91cGRhdGUoKTsgICAgICAgIFxyXG4gICAgICAgIHRoaXMucGFwZXIuJGVsLnByZXBlbmQoYm94KTsgXHJcbiAgICAgICAgdGhpcy5fdXBkYXRlU2Nyb2xsZXIoKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbn07XHJcblxyXG5HcmFwaE5vZGVWaWV3LnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKGNvbXBvbmVudHMpIHtcclxuICAgIHRoaXMuX3VwZGF0ZUJvZHkoKTtcclxuXHJcbiAgICBjb21wb25lbnRzID0gY29tcG9uZW50cyB8fCB0aGlzLm1vZGVsLmdldEFsbENoaWxkcmVuKCk7XHJcbiAgICBjb21wb25lbnRzLmZvckVhY2gobW9kZWwgPT4gdGhpcy5fdXBkYXRlTW9kZWwobW9kZWwpKTtcclxuXHJcbiAgICB0aGlzLl91cGRhdGVDb2xsYXBzZUJ1dHRvbigpO1xyXG4gICAgdGhpcy5fdXBkYXRlQm94KCk7XHJcbiAgICB0aGlzLl91cGRhdGVQb3J0cygpO1xyXG59O1xyXG5cclxuR3JhcGhOb2RlVmlldy5wcm90b3R5cGUuX3VwZGF0ZUJveCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGNvbnN0IGJveCA9IHRoaXMucGFydHNbJ2JveCddOyBcclxuXHJcbiAgICBjb25zdCBlbGVtZW50QkJveCA9IHRoaXMubW9kZWwuZ2V0QkJveCgpO1xyXG4gICAgY29uc3QgaGVpZ2h0ID0gYm94LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCAvIHRoaXMuX3NjYWxlO1xyXG4gICAgXHJcbiAgICBib3guc3R5bGUud2lkdGggPSBlbGVtZW50QkJveC53aWR0aCArICdweCc7XHJcbiAgICB0aGlzLm1vZGVsLnJlc2l6ZShlbGVtZW50QkJveC53aWR0aCwgaGVpZ2h0KTtcclxuXHJcbiAgICBjb25zdCB4X2Vycm9yID0gZWxlbWVudEJCb3gud2lkdGggLyAyO1xyXG4gICAgY29uc3QgeV9lcnJvciA9IGhlaWdodCAvIDI7XHJcbiAgICBib3guc3R5bGUubGVmdCA9ICgoZWxlbWVudEJCb3gueCArIHhfZXJyb3IpICogdGhpcy5tb2RlbC5zY2FsZSkgLSB4X2Vycm9yICsgJ3B4JztcclxuICAgIGJveC5zdHlsZS50b3AgPSAoKGVsZW1lbnRCQm94LnkgKyB5X2Vycm9yKSAqIHRoaXMubW9kZWwuc2NhbGUpIC0geV9lcnJvciArICdweCc7XHJcblxyXG4gICAgdGhpcy5fc2NhbGUgPSB0aGlzLm1vZGVsLnNjYWxlO1xyXG4gICAgYm94LnN0eWxlLnRyYW5zZm9ybSA9ICdzY2FsZSgnICsgdGhpcy5fc2NhbGUgKyAnKSc7XHJcbn07XHJcblxyXG5HcmFwaE5vZGVWaWV3LnByb3RvdHlwZS5fdXBkYXRlUG9ydHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBjb25zdCBib3ggPSB0aGlzLnBhcnRzWydib3gnXTsgXHJcbiAgICBjb25zdCBib2R5ID0gdGhpcy5wYXJ0c1snYm9keSddO1xyXG4gICAgY29uc3QgZnJlc2hQb3J0cyA9IHt9O1xyXG4gICAgY29uc3Qgc2l6ZSA9IHRoaXMubW9kZWwuZ2V0KCdzaXplJyk7XHJcbiAgICB0aGlzLm1vZGVsLmdldEFsbENoaWxkcmVuKCkuZm9yRWFjaChlbGVtZW50ID0+IHtcclxuICAgICAgICBjb25zdCBpblBvcnRJZCA9IGdldFBvcnRJZChlbGVtZW50LmlkLCAnaW4nKTtcclxuICAgICAgICBjb25zdCBvdXRQb3J0SWQgPSBnZXRQb3J0SWQoZWxlbWVudC5pZCwgJ291dCcpO1xyXG4gICAgICAgIGNvbnN0IGh0bWxFbGVtZW50ID0gYm94LnF1ZXJ5U2VsZWN0b3IoJyMnICsgZWxlbWVudC5pZCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uc3QgaGVhZGVyID0gaHRtbEVsZW1lbnQgP1xyXG4gICAgICAgICAgICBodG1sRWxlbWVudC5xdWVyeVNlbGVjdG9yKCcuZG4tZ3JvdXBfaGVhZGVyJykgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgbGV0IHBvcnRIdG1sRWxlbWVudDtcclxuICAgICAgICBpZiAoaGVhZGVyKSB7XHJcbiAgICAgICAgICAgIHBvcnRIdG1sRWxlbWVudCA9IGhlYWRlcjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBwb3J0SHRtbEVsZW1lbnQgPSBodG1sRWxlbWVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHBvcnRIdG1sRWxlbWVudCkge1xyXG4gICAgICAgICAgICBjb25zdCBvZmZzZXRUb3AgPSBnZXRPZmZzZXRUb3AocG9ydEh0bWxFbGVtZW50KTtcclxuICAgICAgICAgICAgY29uc3QgY2xpZW50SGVpZ2h0ID0gcG9ydEh0bWxFbGVtZW50LmNsaWVudEhlaWdodDtcclxuICAgICAgICAgICAgY29uc3Qgc2Nyb2xsVG9Ub3AgPSBib2R5LnNjcm9sbFRvcDtcclxuICAgICAgICAgICAgY29uc3QgbWluWSA9IGJvZHkub2Zmc2V0VG9wO1xyXG4gICAgICAgICAgICBjb25zdCBtYXhZID0gYm9keS5jbGllbnRIZWlnaHQgKyBtaW5ZO1xyXG4gICAgICAgICAgICBjb25zdCBtaWRkbGVQb2ludCA9ICgtc2Nyb2xsVG9Ub3ApICsgb2Zmc2V0VG9wICsgY2xpZW50SGVpZ2h0IC8gMjtcclxuICAgICAgICAgICAgY29uc3QgcmVmWSA9IE1hdGgubWF4KE1hdGgubWluKG1pZGRsZVBvaW50LCBtYXhZKSwgbWluWSk7XHJcblxyXG4gICAgICAgICAgICBmcmVzaFBvcnRzWycuJyArIGluUG9ydElkXSA9IHtcclxuICAgICAgICAgICAgICAgIHJlZjogJy5ib2R5JyxcclxuICAgICAgICAgICAgICAgICdyZWYteSc6IHJlZlksXHJcbiAgICAgICAgICAgICAgICAncmVmLXgnOiAwLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBmcmVzaFBvcnRzWycuJyArIG91dFBvcnRJZF0gPSB7XHJcbiAgICAgICAgICAgICAgICByZWY6ICcuYm9keScsXHJcbiAgICAgICAgICAgICAgICAncmVmLXknOiByZWZZLFxyXG4gICAgICAgICAgICAgICAgJ3JlZi14Jzogc2l6ZS53aWR0aCxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLm1vZGVsLmF0dHIoZnJlc2hQb3J0cyk7XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0T2Zmc2V0VG9wIChlbGVtZW50KSB7XHJcbiAgICAgICAgaWYoZWxlbWVudC5jbGFzc05hbWUgIT09ICdkZXJpdmF0aW9uLW5vZGUnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50Lm9mZnNldFRvcCArIGVsZW1lbnQuY2xpZW50VG9wICsgKGVsZW1lbnQub2Zmc2V0UGFyZW50ID8gZ2V0T2Zmc2V0VG9wKGVsZW1lbnQub2Zmc2V0UGFyZW50KSA6IDApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbkdyYXBoTm9kZVZpZXcucHJvdG90eXBlLl9jcmVhdGVTY3JvbGxlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGNvbnN0IHNjcm9sbGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7XHJcbiAgICBzY3JvbGxlci5jbGFzc05hbWUgPSAnZGVyaXZhdGlvbi1ub2RlX2JvZHktc2Nyb2xsZXInO1xyXG4gICAgc2Nyb2xsZXIub25zY3JvbGwgPSAoKSA9PiB7XHJcbiAgICAgICAgdGhpcy5wYXJ0c1snYm9keSddLnNjcm9sbFRvcCA9IHRoaXMubW9kZWwuc2N0b2xsVG9wID0gc2Nyb2xsZXIuc2Nyb2xsVG9wO1xyXG4gICAgICAgIHRoaXMubW9kZWwudXBkYXRlUG9ydHMoKTtcclxuICAgIH07XHJcbiAgICBjb25zdCBib2R5U2l6ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO1xyXG4gICAgYm9keVNpemUuY2xhc3NOYW1lID0gJ2Rlcml2YXRpb24tbm9kZV9ib2R5LXNjcm9sbGVyX19zaXplJztcclxuICAgIHNjcm9sbGVyLmFwcGVuZENoaWxkKGJvZHlTaXplKTtcclxuXHJcbiAgICByZXR1cm4gc2Nyb2xsZXI7XHJcbn07XHJcblxyXG5HcmFwaE5vZGVWaWV3LnByb3RvdHlwZS5fdXBkYXRlU2Nyb2xsZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBjb25zdCBzY3JvbGxlciA9IHRoaXMucGFydHNbJ3Njcm9sbGVyJ107XHJcbiAgICBjb25zdCBib2R5ID0gdGhpcy5wYXJ0c1snYm9keSddO1xyXG4gICAgY29uc3QgY29sbGFwc2VCdXR0b24gPSB0aGlzLnBhcnRzWydjb2xsYXBzZUJ1dHRvbiddO1xyXG5cclxuICAgIGNvbnN0IGJib3ggPSBib2R5LmZpcnN0Q2hpbGQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICBjb25zdCBib2R5SGVpZ2h0ID0gYmJveC5oZWlnaHQgLyB0aGlzLl9zY2FsZTtcclxuICAgIGNvbnN0IGJvZHlXaWR0aCA9IGJib3gud2lkdGggLyB0aGlzLl9zY2FsZTtcclxuICAgIGlmIChzY3JvbGxlci5maXJzdENoaWxkKSB7IC8vIGZvciBJRTExXHJcbiAgICAgICAgc2Nyb2xsZXIuZmlyc3RDaGlsZC5zdHlsZS5oZWlnaHQgPSBib2R5SGVpZ2h0ICsgJ3B4JztcclxuICAgICAgICBzY3JvbGxlci5maXJzdENoaWxkLnN0eWxlLndpZHRoID0gYm9keVdpZHRoICsgJ3B4JztcclxuICAgIH1cclxuICAgIGNvbnN0IGV4Y2VlZFNpemUgPSBib2R5SGVpZ2h0IDw9IE1BWF9OT0RFX0hFSUdIVDtcclxuICAgIGNvbnN0IGlzU2Nyb2xsYWJsZSA9IGV4Y2VlZFNpemUgfHwgIXRoaXMubW9kZWwuZ2V0KCdjb2xsYXBzZWQnKTtcclxuICAgIGNvbGxhcHNlQnV0dG9uLnN0eWxlLmRpc3BsYXkgPSBleGNlZWRTaXplID8gJ25vbmUnIDogbnVsbDtcclxuICAgIHNjcm9sbGVyLnN0eWxlLmRpc3BsYXkgPSBpc1Njcm9sbGFibGUgPyAnbm9uZScgOiBudWxsO1xyXG5cclxuICAgIGJvZHkuc2Nyb2xsVG9wID0gdGhpcy5tb2RlbC5zY3RvbGxUb3A7XHJcbiAgICBzY3JvbGxlci5zY3JvbGxUb3AgPSB0aGlzLm1vZGVsLnNjdG9sbFRvcDtcclxufTtcclxuXHJcbkdyYXBoTm9kZVZpZXcucHJvdG90eXBlLl9yZW1vdmVCb3ggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLnBhcnRzWydib3gnXS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMucGFydHNbJ2JveCddKTtcclxuICAgIHRoaXMucGFydHMgPSB7fTtcclxufTtcclxuXHJcbkdyYXBoTm9kZVZpZXcucHJvdG90eXBlLl9jcmVhdGVCb2R5ID0gZnVuY3Rpb24gKG1vZGVsKSB7XHJcbiAgICBjb25zdCBib2R5ID0gIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO1xyXG4gICAgYm9keS5jbGFzc05hbWUgPSAnZGVyaXZhdGlvbi1ub2RlX2JvZHknO1xyXG4gICAgY29uc3QgcmVuZGVyZWRNb2RlbCA9IHRoaXMuX2NyZWF0ZU1vZGVsKG1vZGVsLCAwKTtcclxuICAgIGJvZHkuYXBwZW5kQ2hpbGQocmVuZGVyZWRNb2RlbCk7XHJcblxyXG4gICAgcmV0dXJuIGJvZHk7XHJcbn07XHJcblxyXG5HcmFwaE5vZGVWaWV3LnByb3RvdHlwZS5fdXBkYXRlQm9keSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGNvbnN0IGJvZHkgPSAgdGhpcy5wYXJ0c1snYm9keSddO1xyXG4gICAgXHJcbiAgICBpZiAodGhpcy5tb2RlbC5nZXQoJ2NvbGxhcHNlZCcpKSB7XHJcbiAgICAgICAgYm9keS5zdHlsZS5tYXhIZWlnaHQgPSBNQVhfTk9ERV9IRUlHSFQgKyAncHgnO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBib2R5LnN0eWxlLm1heEhlaWdodCA9IG51bGw7XHJcbiAgICB9XHJcbn07XHJcblxyXG5HcmFwaE5vZGVWaWV3LnByb3RvdHlwZS5fY3JlYXRlQ29sbGFwc2VCdXR0b24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBjb25zdCBjb2xsYXBzZUJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0lNRycpO1xyXG4gICAgY29sbGFwc2VCdXR0b24uY2xhc3NOYW1lID0gJ2Rlcml2YXRpb24tbm9kZS1jb2xsYXBzZS1idXR0b24nO1xyXG4gICAgY29sbGFwc2VCdXR0b24ub25jbGljayA9ICgpID0+IHtcclxuICAgICAgICBpZiAodGhpcy5tb2RlbC5nZXQoJ2NvbGxhcHNlZCcpKSB7XHJcbiAgICAgICAgICAgIHRoaXMubW9kZWwuX2V4cGFuZEVsZW1lbnQoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLm1vZGVsLl9jb2xsYXBzZUVsZW1lbnQoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBjb2xsYXBzZUJ1dHRvbjtcclxufTtcclxuXHJcbkdyYXBoTm9kZVZpZXcucHJvdG90eXBlLl91cGRhdGVDb2xsYXBzZUJ1dHRvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGNvbnN0IGNvbGxhcHNlQnV0dG9uID0gdGhpcy5wYXJ0c1snY29sbGFwc2VCdXR0b24nXTtcclxuICAgIGlmICh0aGlzLm1vZGVsLmdldCgnY29sbGFwc2VkJykpIHtcclxuICAgICAgICBjb2xsYXBzZUJ1dHRvbi5jbGFzc0xpc3QuYWRkKCdjb2xsYXBzZWQnKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29sbGFwc2VCdXR0b24uY2xhc3NMaXN0LnJlbW92ZSgnY29sbGFwc2VkJyk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5HcmFwaE5vZGVWaWV3LnByb3RvdHlwZS5fY3JlYXRlSGVhZGVyID0gZnVuY3Rpb24gKG1vZGVsKSB7XHJcbiAgICBjb25zdCBoZWFkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTtcclxuICAgIGhlYWRlci5jbGFzc05hbWUgPSAnZGVyaXZhdGlvbi1ub2RlX2hlYWRlcic7XHJcblxyXG4gICAgY29uc3QgbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdMQUJFTCcpO1xyXG4gICAgbGFiZWwuY2xhc3NOYW1lID0gJ2Rlcml2YXRpb24tbm9kZV9oZWFkZXJfX2xhYmVsJztcclxuICAgIGxhYmVsLmlubmVyVGV4dCA9IG1vZGVsLnRpdGxlIHx8ICcnO1xyXG5cclxuICAgIGhlYWRlci5hcHBlbmRDaGlsZChsYWJlbCk7XHJcblxyXG4gICAgcmV0dXJuIGhlYWRlcjtcclxufTtcclxuXHJcbkdyYXBoTm9kZVZpZXcucHJvdG90eXBlLl9jcmVhdGVNb2RlbCA9IGZ1bmN0aW9uIChtb2RlbCwgZGVlcCkge1xyXG4gICAgaWYgKCF0aGlzLl9wcm9jZXNzZWRJZHNbbW9kZWwuaWRdKSB7XHJcbiAgICAgICAgdGhpcy5fcHJvY2Vzc2VkSWRzW21vZGVsLmlkXSA9IHRydWU7XHJcblxyXG4gICAgICAgIGxldCBtb2RlbFZpZXc7XHJcbiAgICAgICAgaWYgKG1vZGVsLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgbW9kZWxWaWV3ID0gdGhpcy5fY3JlYXRlR3JvdXAobW9kZWwsIGRlZXApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG1vZGVsVmlldyA9IHRoaXMuX2NyZWF0ZUVsZW1lbnQobW9kZWwsIGRlZXApO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnBhcnRzW21vZGVsLmlkXSA9IG1vZGVsVmlldztcclxuICAgICAgICByZXR1cm4gbW9kZWxWaWV3O1xyXG4gICAgfVxyXG59O1xyXG5cclxuR3JhcGhOb2RlVmlldy5wcm90b3R5cGUuX3VwZGF0ZU1vZGVsID0gZnVuY3Rpb24gKG1vZGVsKSB7XHJcbiAgICBpZiAobW9kZWwuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZUdyb3VwKG1vZGVsKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlRWxlbWVudChtb2RlbCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5HcmFwaE5vZGVWaWV3LnByb3RvdHlwZS5fY3JlYXRlR3JvdXAgPSBmdW5jdGlvbiAocm9vdE1vZGVsLCBkZWVwKSB7XHJcbiAgICBjb25zdCBpY29uID0gcm9vdE1vZGVsLmljb24gPyBgPHNwYW4gY2xhc3M9XCJkbi1oZWFkZXItaWNvblwiPjxpIGNsYXNzPVwiJHtyb290TW9kZWwuaWNvbn1cIj48L2k+PC9zcGFuPmAgOiAnJztcclxuICAgIGNvbnN0IGdyb3VwRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgY29uc3QgY3NzQ2xhc3MgPSAnZGVyaXZhdGlvbi1ub2RlX2dyb3VwXycgKyBkZWVwICUgKENTU19DTEFTU19OVU1CRVIgKyAxKTtcclxuICAgIGdyb3VwRWxlbWVudC5pZCA9IHJvb3RNb2RlbC5pZDtcclxuICAgIGdyb3VwRWxlbWVudC5jbGFzc05hbWUgPSBgJHtjc3NDbGFzc30gZG4tZ3JvdXBgO1xyXG4gICAgZ3JvdXBFbGVtZW50LmlubmVySFRNTCA9IGBcclxuICAgICAgICA8ZGl2IGNsYXNzPVwiZG4tZ3JvdXBfaGVhZGVyXCI+XHJcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZG4tYXJyb3cgZG5fX2luY29taW5nLWFycm93XCI+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZG4tYXJyb3ctdHJpYW5nbGVcIj48L2Rpdj5cclxuICAgICAgICAgICAgPC9zcGFuPlxyXG4gICAgICAgICAgICA8aW1nLz5cclxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImRuLWdyb3VwX2hlYWRlcl9fbGFiZWxcIiAgdGl0bGU9XCIke3Jvb3RNb2RlbC5lbmRwb2ludElkICsgJyh0eXBlOiAnICsgcm9vdE1vZGVsLnR5cGUgKyAnKSd9XCI+XHJcbiAgICAgICAgICAgICAgICAke2ljb259XHJcbiAgICAgICAgICAgICAgICA8bGFiZWw+JHtyb290TW9kZWwubGFiZWx9PC9sYWJlbD5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZG4tYXJyb3cgZG5fX291dGdvaW5nLWFycm93XCI+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZG4tYXJyb3ctdHJpYW5nbGVcIj48L2Rpdj5cclxuICAgICAgICAgICAgPC9zcGFuPlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDx1bCBjbGFzcz1cImRlcml2YXRpb24tbm9kZV9saXN0LW9mLWVsZW1lbnRzXCI+PC91bD5cclxuICAgIGA7XHJcblxyXG4gICAgY29uc3QgYWN0aXZlSGVhZGVyQXJlYSA9IGdyb3VwRWxlbWVudC5xdWVyeVNlbGVjdG9yKCcuZG4tZ3JvdXBfaGVhZGVyX19sYWJlbCcpO1xyXG4gICAgYWN0aXZlSGVhZGVyQXJlYS5vbmNsaWNrID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgdGhpcy5tb2RlbC5maXJlQ2xpY2tFdmVudChldmVudCwgZ3JvdXBFbGVtZW50LmlkKTtcclxuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgIH07XHJcbiAgICBcclxuICAgIGNvbnN0IGNoaWxkcmVuID0gZ3JvdXBFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5kZXJpdmF0aW9uLW5vZGVfbGlzdC1vZi1lbGVtZW50cycpO1xyXG4gICAgcm9vdE1vZGVsLmNoaWxkcmVuLmZvckVhY2goZWxlbWVudCA9PiB7XHJcbiAgICAgICAgY29uc3QgcmVuZGVyZWRNb2RlbCA9IHRoaXMuX2NyZWF0ZU1vZGVsKGVsZW1lbnQsIGRlZXAgKyAxKTtcclxuICAgICAgICBpZiAocmVuZGVyZWRNb2RlbCkge1xyXG4gICAgICAgICAgICBjaGlsZHJlbi5hcHBlbmRDaGlsZChyZW5kZXJlZE1vZGVsKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCBjb2xsYXBzZUJ1dHRvbiA9IGdyb3VwRWxlbWVudC5xdWVyeVNlbGVjdG9yKCcuZG4tZ3JvdXAgaW1nJyk7XHJcbiAgICBjb2xsYXBzZUJ1dHRvbi5vbmNsaWNrID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgdGhpcy5tb2RlbC5vbkNsaWNrQ29sbGFwc2VCdXR0b24ocm9vdE1vZGVsLmlkKTtcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIGdyb3VwRWxlbWVudDtcclxufTtcclxuXHJcbkdyYXBoTm9kZVZpZXcucHJvdG90eXBlLl91cGRhdGVHcm91cCA9IGZ1bmN0aW9uIChyb290TW9kZWwpIHtcclxuICAgIGNvbnN0IGdyb3VwRWxlbWVudCA9IHRoaXMucGFydHNbcm9vdE1vZGVsLmlkXTtcclxuXHJcbiAgICBncm91cEVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IHJvb3RNb2RlbC5pbnZpc2libGUgPyAnbm9uZScgOiBudWxsO1xyXG4gICAgaWYgKHJvb3RNb2RlbC5pbnZpc2libGUpIHJldHVybjtcclxuXHJcbiAgICBjb25zdCBub1Zpc2libGVDaGlsZHJlbiA9ICghcm9vdE1vZGVsLmNoaWxkcmVuKSB8fCByb290TW9kZWwuY2hpbGRyZW4uZmlsdGVyKGNoaWxkID0+ICFjaGlsZC5pbnZpc2libGUpLmxlbmd0aCA9PT0gMDtcclxuICAgIGlmIChyb290TW9kZWwuY29sbGFwc2VkICYmIG5vVmlzaWJsZUNoaWxkcmVuKSB7XHJcbiAgICAgICAgZ3JvdXBFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2RuLWNvbGxhcHNlZCcpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBncm91cEVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgnZG4tY29sbGFwc2VkJyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHJvb3RNb2RlbC5jb2xsYXBzZWQgJiYgbm9WaXNpYmxlQ2hpbGRyZW4pIHtcclxuICAgICAgICBncm91cEVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnZG4tY29sbGFwc2VkJyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGdyb3VwRWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdkbi1jb2xsYXBzZWQnKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBpc0hpZ2hsaWdodGVkID0gdGhpcy5tb2RlbC5oaWdobGlnaHRlZElkID09PSByb290TW9kZWwuaWQ7XHJcbiAgICBpZiAoaXNIaWdobGlnaHRlZCkge1xyXG4gICAgICAgIGdyb3VwRWxlbWVudC5jbGFzc0xpc3QuYWRkKCd0cS1kbS1oaWdobGlnaHRlZCcpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBncm91cEVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgndHEtZG0taGlnaGxpZ2h0ZWQnKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBodG1sSW5Qb3J0cyA9IGdyb3VwRWxlbWVudC5xdWVyeVNlbGVjdG9yKCcuZG4tYXJyb3cuZG5fX2luY29taW5nLWFycm93Jyk7XHJcbiAgICBjb25zdCBodG1sSW5UcmlhbmdlbCA9IGh0bWxJblBvcnRzLnF1ZXJ5U2VsZWN0b3IoJy5kbi1hcnJvdy10cmlhbmdsZScpO1xyXG4gICAgY29uc3QgaW5Qb3J0SWQgPSBnZXRQb3J0SWQocm9vdE1vZGVsLmlkLCAnaW4nKTtcclxuICAgIGNvbnN0IGluY29taW5nTGlua3NNYXAgPSB0aGlzLm1vZGVsLmFjdGl2ZVBvcnRzW2luUG9ydElkXSB8fCB7fTtcclxuICAgIGNvbnN0IGFjdGl2ZUluTGlua3MgPSBPYmplY3Qua2V5cyhpbmNvbWluZ0xpbmtzTWFwKS5tYXAoa2V5ID0+IGluY29taW5nTGlua3NNYXBba2V5XSk7XHJcbiAgICBjb25zdCBpblBvcnRWaXNpYmxlID0gYWN0aXZlSW5MaW5rcy5sZW5ndGggPiAwICYmIHJvb3RNb2RlbCE9PSB0aGlzLm1vZGVsLm1vZGVsO1xyXG4gICAgY29uc3QgbmVlZEluQXJyb3cgPSBhY3RpdmVJbkxpbmtzICYmIGNoZWNrQXJyb3codGhpcy5tb2RlbCwgYWN0aXZlSW5MaW5rcyk7XHJcbiAgICBodG1sSW5Qb3J0cy5zdHlsZS5kaXNwbGF5ID0gaW5Qb3J0VmlzaWJsZSA/IG51bGwgOiAnbm9uZSc7XHJcbiAgICBodG1sSW5UcmlhbmdlbC5zdHlsZS5kaXNwbGF5ID0gbmVlZEluQXJyb3cgPyBudWxsIDogJ25vbmUnO1xyXG5cclxuICAgIGNvbnN0IGh0bWxPdXRQb3J0cyA9IGdyb3VwRWxlbWVudC5xdWVyeVNlbGVjdG9yKCcuZG4tYXJyb3cuZG5fX291dGdvaW5nLWFycm93Jyk7XHJcbiAgICBjb25zdCBodG1sT3V0VHJpYW5nZWwgPSBodG1sT3V0UG9ydHMucXVlcnlTZWxlY3RvcignLmRuLWFycm93LXRyaWFuZ2xlJyk7XHJcbiAgICBjb25zdCBvdXRQb3J0SWQgPSBnZXRQb3J0SWQocm9vdE1vZGVsLmlkLCAnb3V0Jyk7XHJcbiAgICBjb25zdCBvdXRnb2luZ0xpbmtzTWFwID0gdGhpcy5tb2RlbC5hY3RpdmVQb3J0c1tvdXRQb3J0SWRdIHx8IHt9O1xyXG4gICAgY29uc3QgYWN0aXZlT3V0TGlua3MgPSBPYmplY3Qua2V5cyhvdXRnb2luZ0xpbmtzTWFwKS5tYXAoa2V5ID0+IG91dGdvaW5nTGlua3NNYXBba2V5XSk7XHJcbiAgICBjb25zdCBuZWVkT3V0QXJyb3cgPSBhY3RpdmVPdXRMaW5rcyAmJiBjaGVja0Fycm93KHRoaXMubW9kZWwsIGFjdGl2ZU91dExpbmtzKTtcclxuICAgIGNvbnN0IG91dFBvcnRWaXNpYmxlID0gYWN0aXZlT3V0TGlua3MubGVuZ3RoID4gMCAmJiByb290TW9kZWwhPT0gdGhpcy5tb2RlbC5tb2RlbDtcclxuICAgIGh0bWxPdXRQb3J0cy5zdHlsZS5kaXNwbGF5ID0gb3V0UG9ydFZpc2libGUgPyBudWxsIDogJ25vbmUnO1xyXG4gICAgaHRtbE91dFRyaWFuZ2VsLnN0eWxlLmRpc3BsYXkgPSBuZWVkT3V0QXJyb3cgPyBudWxsIDogJ25vbmUnO1xyXG5cclxuICAgIGNvbnN0IGltZyA9IGdyb3VwRWxlbWVudC5xdWVyeVNlbGVjdG9yKCcuZG4tZ3JvdXBfaGVhZGVyIGltZycpO1xyXG4gICAgaW1nLmNsYXNzTmFtZSA9IHJvb3RNb2RlbC5jb2xsYXBzZWQgPyAnZG4tY29sbGFwc2VkJyA6ICcnO1xyXG5cclxuICAgIGNvbnN0IGxhYmVsID0gZ3JvdXBFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5kbi1ncm91cF9oZWFkZXJfX2xhYmVsIGxhYmVsJyk7XHJcbiAgICBsYWJlbC5pbm5lckhUTUwgPSBnZXRDb2xvcmVkTGFiZWwocm9vdE1vZGVsLmxhYmVsLCB0aGlzLm1vZGVsLnNlYXJjaEtleSk7XHJcbn07XHJcblxyXG5HcmFwaE5vZGVWaWV3LnByb3RvdHlwZS5fY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uIChyb290TW9kZWwsIGRlZXApIHtcclxuICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgIGNvbnN0IGljb24gPSByb290TW9kZWwuaWNvbiA/IGA8c3BhbiBjbGFzcz1cImRuLWhlYWRlci1pY29uXCI+PGkgY2xhc3M9XCIke3Jvb3RNb2RlbC5pY29ufVwiPjwvaT48L3NwYW4+YCA6ICcnO1xyXG5cclxuICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gYGRuLWVsZW1lbnQgZGVyaXZhdGlvbi1ub2RlX2VsZW1lbnRfJHtkZWVwfWA7XHJcbiAgICBlbGVtZW50LmlkID0gcm9vdE1vZGVsLmlkO1xyXG4gICAgZWxlbWVudC5vbmNsaWNrID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgdGhpcy5tb2RlbC5maXJlQ2xpY2tFdmVudChldmVudCwgZWxlbWVudC5pZCk7XHJcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICB9O1xyXG4gICAgZWxlbWVudC5pbm5lckhUTUwgPSBgXHJcbiAgICAgICAgPHNwYW4gY2xhc3M9XCJkbi1hcnJvdyBkbl9faW5jb21pbmctYXJyb3dcIj5cclxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImRuLWFycm93LXRyaWFuZ2xlXCI+PC9kaXY+XHJcbiAgICAgICAgPC9zcGFuPlxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJkbi1lbGVtZW50X2NlbnRlclwiPlxyXG4gICAgICAgICAgICAke2ljb259XHJcbiAgICAgICAgICAgIDxsYWJlbCB0aXRsZT1cIiR7cm9vdE1vZGVsLmVuZHBvaW50SWQgKyAnKHR5cGU6ICcgKyByb290TW9kZWwudHlwZSArICcpJ31cIj5cclxuICAgICAgICAgICAgICAgICR7cm9vdE1vZGVsLmxhYmVsfVxyXG4gICAgICAgICAgICA8L2xhYmVsPlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDxzcGFuIGNsYXNzPVwiZG4tYXJyb3cgZG5fX291dGdvaW5nLWFycm93XCI+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJkbi1hcnJvdy10cmlhbmdsZVwiPjwvZGl2PlxyXG4gICAgICAgIDwvc3Bhbj5cclxuICAgIGA7XHJcblxyXG4gICAgcmV0dXJuIGVsZW1lbnQ7XHJcbn07XHJcblxyXG5HcmFwaE5vZGVWaWV3LnByb3RvdHlwZS5fdXBkYXRlRWxlbWVudCA9IGZ1bmN0aW9uIChyb290TW9kZWwpIHtcclxuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLnBhcnRzW3Jvb3RNb2RlbC5pZF07XHJcblxyXG4gICAgZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gcm9vdE1vZGVsLmludmlzaWJsZSA/ICdub25lJyA6IG51bGw7XHJcbiAgICBpZiAocm9vdE1vZGVsLmludmlzaWJsZSkgcmV0dXJuO1xyXG5cclxuICAgIGNvbnN0IGh0bWxJblBvcnRzID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yKCcuZG4tYXJyb3cuZG5fX2luY29taW5nLWFycm93Jyk7XHJcbiAgICBjb25zdCBodG1sSW5UcmlhbmdlbCA9IGh0bWxJblBvcnRzLnF1ZXJ5U2VsZWN0b3IoJy5kbi1hcnJvdy10cmlhbmdsZScpO1xyXG4gICAgY29uc3QgaW5Qb3J0SWQgPSBnZXRQb3J0SWQocm9vdE1vZGVsLmlkLCAnaW4nKTtcclxuICAgIGNvbnN0IGluY29taW5nTGlua3NNYXAgPSB0aGlzLm1vZGVsLmFjdGl2ZVBvcnRzW2luUG9ydElkXSB8fCB7fTtcclxuICAgIGNvbnN0IGFjdGl2ZUluTGlua3MgPSBPYmplY3Qua2V5cyhpbmNvbWluZ0xpbmtzTWFwKS5tYXAoa2V5ID0+IGluY29taW5nTGlua3NNYXBba2V5XSk7XHJcbiAgICBjb25zdCBpblBvcnRWaXNpYmxlID0gYWN0aXZlSW5MaW5rcy5sZW5ndGggPiAwICYmIHJvb3RNb2RlbCE9PSB0aGlzLm1vZGVsLm1vZGVsO1xyXG4gICAgY29uc3QgbmVlZEluQXJyb3cgPSBhY3RpdmVJbkxpbmtzICYmIGNoZWNrQXJyb3codGhpcy5tb2RlbCwgYWN0aXZlSW5MaW5rcyk7XHJcbiAgICBodG1sSW5Qb3J0cy5zdHlsZS5kaXNwbGF5ID0gaW5Qb3J0VmlzaWJsZSA/IG51bGwgOiAnbm9uZSc7XHJcbiAgICBodG1sSW5UcmlhbmdlbC5zdHlsZS5kaXNwbGF5ID0gbmVlZEluQXJyb3cgPyBudWxsIDogJ25vbmUnO1xyXG5cclxuICAgIGNvbnN0IGh0bWxPdXRQb3J0cyA9IGVsZW1lbnQucXVlcnlTZWxlY3RvcignLmRuLWFycm93LmRuX19vdXRnb2luZy1hcnJvdycpO1xyXG4gICAgY29uc3QgaHRtbE91dFRyaWFuZ2VsID0gaHRtbE91dFBvcnRzLnF1ZXJ5U2VsZWN0b3IoJy5kbi1hcnJvdy10cmlhbmdsZScpO1xyXG4gICAgY29uc3Qgb3V0UG9ydElkID0gZ2V0UG9ydElkKHJvb3RNb2RlbC5pZCwgJ291dCcpO1xyXG4gICAgY29uc3Qgb3V0Z29pbmdMaW5rc01hcCA9IHRoaXMubW9kZWwuYWN0aXZlUG9ydHNbb3V0UG9ydElkXSB8fCB7fTtcclxuICAgIGNvbnN0IGFjdGl2ZU91dExpbmtzID0gT2JqZWN0LmtleXMob3V0Z29pbmdMaW5rc01hcCkubWFwKGtleSA9PiBvdXRnb2luZ0xpbmtzTWFwW2tleV0pO1xyXG4gICAgY29uc3QgbmVlZE91dEFycm93ID0gYWN0aXZlT3V0TGlua3MgJiYgY2hlY2tBcnJvdyh0aGlzLm1vZGVsLCBhY3RpdmVPdXRMaW5rcyk7XHJcbiAgICBjb25zdCBvdXRQb3J0VmlzaWJsZSA9IGFjdGl2ZU91dExpbmtzLmxlbmd0aCA+IDAgJiYgcm9vdE1vZGVsIT09IHRoaXMubW9kZWwubW9kZWw7XHJcbiAgICBodG1sT3V0UG9ydHMuc3R5bGUuZGlzcGxheSA9IG91dFBvcnRWaXNpYmxlID8gbnVsbCA6ICdub25lJztcclxuICAgIGh0bWxPdXRUcmlhbmdlbC5zdHlsZS5kaXNwbGF5ID0gbmVlZE91dEFycm93ID8gbnVsbCA6ICdub25lJztcclxuXHJcbiAgICBjb25zdCBpc0hpZ2hsaWdodGVkID0gdGhpcy5tb2RlbC5oaWdobGlnaHRlZElkID09PSByb290TW9kZWwuaWQ7XHJcbiAgICBpZiAoaXNIaWdobGlnaHRlZCkge1xyXG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZCgndHEtZG0taGlnaGxpZ2h0ZWQnKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCd0cS1kbS1oaWdobGlnaHRlZCcpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGxhYmVsID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yKCcuZG4tZWxlbWVudF9jZW50ZXIgbGFiZWwnKTtcclxuICAgIGxhYmVsLmlubmVySFRNTCA9IGdldENvbG9yZWRMYWJlbChyb290TW9kZWwubGFiZWwsIHRoaXMubW9kZWwuc2VhcmNoS2V5KTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIGdldENvbG9yZWRMYWJlbCAobGFiZWwsIGtleSkge1xyXG4gICAgaWYgKCFrZXkpIHJldHVybiBsYWJlbDtcclxuICAgIGNvbnN0IGxvd2VyQ2FzZUxhYmVsID0gbGFiZWwudG9Mb3dlckNhc2UoKTtcclxuICAgIGNvbnN0IGtleUluZGV4ID0gbG93ZXJDYXNlTGFiZWwuaW5kZXhPZihrZXkpO1xyXG5cclxuICAgIGlmIChrZXlJbmRleCA9PT0gLTEpIHtcclxuICAgICAgICByZXR1cm4gbGFiZWw7XHJcbiAgICB9IGVsc2UgaWYgKGtleUluZGV4ID09PSAwKSB7XHJcbiAgICAgICAgY29uc3QgZmlyc3RQYXJ0ID0gbGFiZWwuc3Vic3RyaW5nKDAsIGtleS5sZW5ndGgpOyBcclxuICAgICAgICBjb25zdCBzZWNvbmRQYXJ0ID0gbGFiZWwuc3Vic3RyaW5nKGtleS5sZW5ndGgsIGxhYmVsLmxlbmd0aCk7IFxyXG4gICAgICAgIHJldHVybiBgPGkgY2xhc3M9XCJ0cS1kbS1oaWdobGlnaHRlZC1rZXlcIj4ke2ZpcnN0UGFydH08L2k+JHtzZWNvbmRQYXJ0fWA7XHJcbiAgICB9IGVsc2UgaWYgKGtleUluZGV4ICsga2V5Lmxlbmd0aCA9PT0gbGFiZWwubGVuZ3RoKSB7XHJcbiAgICAgICAgY29uc3QgZmlyc3RQYXJ0ID0gbGFiZWwuc3Vic3RyaW5nKDAsIGtleUluZGV4KTsgXHJcbiAgICAgICAgY29uc3Qgc2Vjb25kUGFydCA9IGxhYmVsLnN1YnN0cmluZyhrZXlJbmRleCwgbGFiZWwubGVuZ3RoKTsgXHJcbiAgICAgICAgcmV0dXJuIGAke2ZpcnN0UGFydH08aSBjbGFzcz1cInRxLWRtLWhpZ2hsaWdodGVkLWtleVwiPiR7c2Vjb25kUGFydH08L2k+YDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc3QgZmlyc3RQYXJ0ID0gbGFiZWwuc3Vic3RyaW5nKDAsIGtleUluZGV4KTsgXHJcbiAgICAgICAgY29uc3Qgc2Vjb25kUGFydCA9IGxhYmVsLnN1YnN0cmluZyhrZXlJbmRleCwga2V5SW5kZXggKyBrZXkubGVuZ3RoKTtcclxuICAgICAgICBjb25zdCB0aGlyZFBhcnQgPSBsYWJlbC5zdWJzdHJpbmcoa2V5SW5kZXggKyBrZXkubGVuZ3RoLCBsYWJlbC5sZW5ndGgpO1xyXG4gICAgICAgIHJldHVybiBgJHtmaXJzdFBhcnR9PGkgY2xhc3M9XCJ0cS1kbS1oaWdobGlnaHRlZC1rZXlcIj4ke3NlY29uZFBhcnR9PC9pPiR7dGhpcmRQYXJ0fWA7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBUaGUgR3JhcGhMaW5rVmlldyBjbGFzcy4gTWFpbmx5IGluIGNoYXJnZSBvZiBsaW5rIGhpZ2hsaWdodGluZy5cclxuICogTGlzdGVuIHRvIGV2ZW50cyBhbmQgYXBwbHkgaGlnaGxpZ2h0ZXJzLlxyXG4gKiBAY2xhc3NcclxuICogQGF1Z21lbnRzIGpvaW50LmRpYS5MaW5rVmlld1xyXG4gKiBAcGFyYW0ge05vZGVNb2RlbH0gZGF0YU1vZGVsIC0gTW9kZWwgb2YgZ3JhcGggbm9kZVxyXG4gKiBAcGFyYW0ge1BhcmFtZXRlcnN9IHBhcmFtZXRlcnMgLSBUaGUgc2V0IG9mIHBhcmFtZXRlcnNcclxuKi9cclxuZXhwb3J0IGZ1bmN0aW9uIEdyYXBoTGlua1ZpZXcgKCkge1xyXG4gICAgam9pbnQuZGlhLkxpbmtWaWV3LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn1cclxuR3JhcGhMaW5rVmlldy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGpvaW50LmRpYS5MaW5rVmlldy5wcm90b3R5cGUpO1xyXG5HcmFwaExpbmtWaWV3LnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgam9pbnQuZGlhLkxpbmtWaWV3LnByb3RvdHlwZS5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICB0aGlzLmxpc3RlblRvKHRoaXMubW9kZWwsICdjaGFuZ2U6aGlnaGxpZ2h0ZWQgY2hhbmdlOmJsdXJlZCB1cGRhdGUtc3RhdGUnLCBvbkV2ZW50KTtcclxuICAgIHRoaXMubGlzdGVuVG8odGhpcy5tb2RlbCwgJ3VwZGF0ZU1hcmtlcnMnLCB0aGlzLnVwZGF0ZU1hcmtlcnMpO1xyXG59O1xyXG5cclxuR3JhcGhMaW5rVmlldy5wcm90b3R5cGUudXBkYXRlTWFya2VycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMuX21hcmtlckNhY2hlID0ge307XHJcbiAgICB0aGlzLnJlbmRlcigpO1xyXG59O1xyXG5cclxuR3JhcGhMaW5rVmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgam9pbnQuZGlhLkxpbmtWaWV3LnByb3RvdHlwZS5yZW5kZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufTtcclxuXHJcbmNvbnN0IExHX0RNX0NFTExfSElHSExJR0hURVIgPSB7XHJcbiAgICBoaWdobGlnaHRlcjoge1xyXG4gICAgICAgIG5hbWU6ICdhZGRDbGFzcycsXHJcbiAgICAgICAgb3B0aW9uczoge1xyXG4gICAgICAgICAgICBjbGFzc05hbWU6ICd0cS1kbS1oaWdobGlnaHRlZCdcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IExHX0RNX0NFTExfQkxVUkVSID0ge1xyXG4gICAgaGlnaGxpZ2h0ZXI6IHtcclxuICAgICAgICBuYW1lOiAnYWRkQ2xhc3MnLFxyXG4gICAgICAgIG9wdGlvbnM6IHtcclxuICAgICAgICAgICAgY2xhc3NOYW1lOiAndHEtZG0tYmx1cmVkJ1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbmNvbnN0IExHX0RNX0NFTExfSElEREVOID0ge1xyXG4gICAgaGlnaGxpZ2h0ZXI6IHtcclxuICAgICAgICBuYW1lOiAnYWRkQ2xhc3MnLFxyXG4gICAgICAgIG9wdGlvbnM6IHtcclxuICAgICAgICAgICAgY2xhc3NOYW1lOiAndHEtZG0taGlkZGVuJ1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbmZ1bmN0aW9uIG9uRXZlbnQgKCkge1xyXG4gICAgaWYgKHRoaXMubW9kZWwuZ2V0KCdoaWdobGlnaHRlZCcpKSB7XHJcbiAgICAgICAgdGhpcy5oaWdobGlnaHQobnVsbCwgTEdfRE1fQ0VMTF9ISUdITElHSFRFUik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMudW5oaWdobGlnaHQobnVsbCwgTEdfRE1fQ0VMTF9ISUdITElHSFRFUik7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5tb2RlbC5nZXQoJ2JsdXJlZCcpKSB7XHJcbiAgICAgICAgdGhpcy5oaWdobGlnaHQobnVsbCwgTEdfRE1fQ0VMTF9CTFVSRVIpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLnVuaGlnaGxpZ2h0KG51bGwsIExHX0RNX0NFTExfQkxVUkVSKTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLm1vZGVsLmhpZGRlbikge1xyXG4gICAgICAgIHRoaXMuaGlnaGxpZ2h0KG51bGwsIExHX0RNX0NFTExfSElEREVOKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy51bmhpZ2hsaWdodChudWxsLCBMR19ETV9DRUxMX0hJRERFTik7XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNoZWNrQXJyb3cgKHNlbGYsIGxpbmtzKSB7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmtzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgbGluayA9IGxpbmtzW2ldO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChsaW5rLmdldCgndGFyZ2V0JykuaWQgPT09IHNlbGYuaWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59IiwiaW1wb3J0ICogYXMgam9pbnQgZnJvbSAncmFwcGlkJztcclxuaW1wb3J0IHsgUmVzb3VyY2VQcm92aWRlciB9IGZyb20gJy4uLy4uL2RhdGEvcmVzb3VyY2VQcm92aWRlcic7XHJcbmltcG9ydCB7IFpfSU5ERVhFUyB9IGZyb20gJy4vZWxlbWVudHMnO1xyXG5cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEFzcGVjdExpbmtNb2RlbCAtIGRhdGEgbW9kZWwgb2YgYW4gQXNwZWN0TGluayBvYmplY3RcclxuICogQHR5cGVkZWYge09iamVjdH0gQXNwZWN0TGlua01vZGVsXHJcbiAqIEBwcm9wZXJ0eSB7Tm9kZSB8IFRlcm1pbmF0aW9uTm9kZX0gdGFyZ2V0IC0gVGFyZ2V0IE5vZGVcclxuICogQHByb3BlcnR5IHtOb2RlIHwgVGVybWluYXRpb25Ob2RlfSBzb3VyY2UgLSBTb3VyY2UgTm9kZVxyXG4qL1xyXG5cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqIFRoZSBncmFwaCBMaW5rIGJhc2VkIG9uIGpvaW50LmRpYS5MaW5rLlxyXG4gKiBAY2xhc3NcclxuICogQGF1Z21lbnRzIGpvaW50LmRpYS5MaW5rXHJcbiAqIEBwYXJhbSB7QXNwZWN0TGlua01vZGVsfSBvcHRpb25zXHJcbiAqIEBwYXJhbSB7UGFyYW1ldGVyc30gcGFyYW1ldGVycyAtIFRoZSBzZXQgb2YgcGFyYW1ldGVyc1xyXG4gKiBAcHJvcGVydHkge1NpbXBsZUxpbmtNb2RlbH0gbW9kZWwgLSBEYXRhIG1vZGVsIFxyXG4qL1xyXG5leHBvcnQgZnVuY3Rpb24gQXNwZWN0TGluayAob3B0aW9ucywgcGFyYW1ldGVycykge1xyXG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgY29uc3QgX3JlcyA9IG5ldyBSZXNvdXJjZVByb3ZpZGVyKHBhcmFtZXRlcnMpO1xyXG5cclxuICAgIGNvbnN0IHNvdXJjZSA9IHsgaWQ6IG9wdGlvbnMuc291cmNlLmlkLCBwb3J0OiAnY2xpcFJlY3RQb3J0JyB9O1xyXG4gICAgY29uc3QgdGFyZ2V0ID0geyBpZDogb3B0aW9ucy50YXJnZXQuaWQsIHBvcnQ6ICdjbGlwUmVjdFBvcnQnIH07XHJcblxyXG4gICAgY29uc3QgbGlua0NvbG9yID0gX3Jlcy5nZXRDb2xvcignYXNwZWN0TGluaycpO1xyXG5cclxuICAgIGpvaW50LmRpYS5MaW5rLmFwcGx5KHNlbGYsIFt7XHJcbiAgICAgICAgaWQ6IG9wdGlvbnMuaWQsXHJcbiAgICAgICAgdHlwZTogJ2FzcGVjdC1saW5rJyxcclxuICAgICAgICBzb3VyY2U6IHNvdXJjZSxcclxuICAgICAgICB0YXJnZXQ6IHRhcmdldCxcclxuICAgICAgICB6OiBaX0lOREVYRVMuQVNQRUNUX0xJTkssXHJcbiAgICAgICAgYXR0cnM6IHtcclxuICAgICAgICAgICAgJy5jb25uZWN0aW9uJzoge1xyXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiBsaW5rQ29sb3IsXHJcbiAgICAgICAgICAgICAgICAnc3Ryb2tlLWRhc2hhcnJheSc6ICcxMCwgMTAnLFxyXG4gICAgICAgICAgICAgICAgJ3N0cm9rZS13aWR0aCc6ICc1cHgnLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAnLm1hcmtlci1zb3VyY2UnOiB7XHJcbiAgICAgICAgICAgICAgICBmaWxsOiBsaW5rQ29sb3IsXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6IGxpbmtDb2xvcixcclxuICAgICAgICAgICAgICAgIGQ6ICdNMCwzYTMsMyAwIDEsMCA2LDBhMywzIDAgMSwwIC02LDAnLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAnLm1hcmtlci10YXJnZXQnOiB7XHJcbiAgICAgICAgICAgICAgICBmaWxsOiBsaW5rQ29sb3IsXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6IGxpbmtDb2xvcixcclxuICAgICAgICAgICAgICAgIGQ6ICdNMCwzYTMsMyAwIDEsMCA2LDBhMywzIDAgMSwwIC02LDAnLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy8gdmFyaWFudHMgZm9yIHRoZSBleHBlcmltZW50aW5nXHJcbiAgICAgICAgY29ubmVjdG9yOiB7bmFtZTogJ3JvdW5kZWQnIH0sXHJcbiAgICB9XSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBCbHVycyB0aGUgQXNwZWN0TGluay5cclxuICAgICAqIEBtZW1iZXJvZiBBc3BlY3RMaW5rXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAqL1xyXG4gICAgc2VsZi5ibHVyZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBzZWxmLnNldCgnYmx1cmVkJywgdHJ1ZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBibHVyIGZyb20gdGhlIEFzcGVjdExpbmsuXHJcbiAgICAgKiBAbWVtYmVyb2YgQXNwZWN0TGlua1xyXG4gICAgICogQG1ldGhvZFxyXG4gICAgKi9cclxuICAgIHNlbGYudW5ibHVyZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBzZWxmLnNldCgnYmx1cmVkJywgZmFsc2UpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEhpZGVzIHRoZSBBc3BlY3RMaW5rLlxyXG4gICAgICogQG1lbWJlcm9mIEFzcGVjdExpbmtcclxuICAgICAqIEBtZXRob2RcclxuICAgICovXHJcbiAgICBzZWxmLmhpZGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgc2VsZi5zZXQoJ2hpZGRlbicsIHRydWUpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNob3dzIHRoZSBBc3BlY3RMaW5rLlxyXG4gICAgICogQG1lbWJlcm9mIEFzcGVjdExpbmtcclxuICAgICAqIEBtZXRob2RcclxuICAgICovXHJcbiAgICBzZWxmLnNob3cgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgc2VsZi5zZXQoJ2hpZGRlbicsIGZhbHNlKTtcclxuICAgIH07XHJcblxyXG4gICAgc2VsZi5tb2RlbCA9IHsgc291cmNlOiBvcHRpb25zLnNvdXJjZS5pZCwgdGFyZ2V0OiBvcHRpb25zLnRhcmdldC5pZCB9O1xyXG59XHJcbkFzcGVjdExpbmsucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShqb2ludC5kaWEuTGluay5wcm90b3R5cGUpO1xyXG5cclxuIiwiaW1wb3J0ICogYXMgam9pbnQgZnJvbSAncmFwcGlkJztcclxuaW1wb3J0ICogYXMgXyBmcm9tICdsb2Rhc2gnO1xyXG5cclxuaW1wb3J0IHsgTm9kZSB9IGZyb20gJy4vbm9kZSc7XHJcbmltcG9ydCB7IExpbmsgfSBmcm9tICcuL2xpbmsnO1xyXG5pbXBvcnQgeyBUZXJtaW5hdGlvbkxpbmsgfSBmcm9tICcuL3Rlcm1pbmF0aW9uTGluayc7XHJcbmltcG9ydCB7IFRlcm1pbmF0aW9uTm9kZSB9IGZyb20gJy4vdGVybWluYXRpb25Ob2RlJztcclxuaW1wb3J0IHsgQXNwZWN0TGluayB9IGZyb20gJy4vYXNwZWN0TGluayc7XHJcblxyXG5leHBvcnQgeyBOb2RlLCBMaW5rLCBUZXJtaW5hdGlvbk5vZGUsIFRlcm1pbmF0aW9uTGluaywgQXNwZWN0TGluayB9O1xyXG5cclxuY29uc3QgViA9IGpvaW50LlY7XHJcbmNvbnN0IGcgPSBqb2ludC5nO1xyXG5cclxuZXhwb3J0IGNvbnN0IFpfSU5ERVhFUyA9IHtcclxuICAgIEFTUEVDVF9MSU5LOiAyNSxcclxuICAgIFRFUk1JTkFUSU9OX0VMRU1FTlQ6IDI1LFxyXG4gICAgU0VMRUNURURfRUxFTUVOVDogMzAsXHJcbiAgICBOT0RFOiAyMCxcclxuICAgIExJTks6IDE1LFxyXG4gICAgQkxVUkVEX05PREU6IDEwLFxyXG4gICAgQkxVUkVEX0xJTks6IDUsXHJcbiAgICBWSUVXX0ZSQU1FOiAxLFxyXG59O1xyXG5cclxuY29uc3QgTEdfQ0VMTF9ISUdITElHSFRFUiA9IHtcclxuICAgIGhpZ2hsaWdodGVyOiB7XHJcbiAgICAgICAgbmFtZTogJ2FkZENsYXNzJyxcclxuICAgICAgICBvcHRpb25zOiB7XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ3RxLWxnLWhpZ2hsaWdodGVkJ1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuY29uc3QgTEdfQ0VMTF9ISURERU4gPSB7XHJcbiAgICBoaWdobGlnaHRlcjoge1xyXG4gICAgICAgIG5hbWU6ICdhZGRDbGFzcycsXHJcbiAgICAgICAgb3B0aW9uczoge1xyXG4gICAgICAgICAgICBjbGFzc05hbWU6ICd0cS1sZy1oaWRkZW4tZWxlbWVudCdcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IExHX0NFTExfQkxVUkVSID0ge1xyXG4gICAgaGlnaGxpZ2h0ZXI6IHtcclxuICAgICAgICBuYW1lOiAnYWRkQ2xhc3MnLFxyXG4gICAgICAgIG9wdGlvbnM6IHtcclxuICAgICAgICAgICAgY2xhc3NOYW1lOiAndHEtbGctYmx1cmVkJ1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuY29uc3QgTEdfU0hPUlRfTEFCRUwgPSB7XHJcbiAgICBoaWdobGlnaHRlcjoge1xyXG4gICAgICAgIG5hbWU6ICdhZGRDbGFzcycsXHJcbiAgICAgICAgb3B0aW9uczoge1xyXG4gICAgICAgICAgICBjbGFzc05hbWU6ICd0cS1sZy1zaG9ydC1sYWJlbCdcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IExHX0RSQUdHRURfTk9ERSA9IHtcclxuICAgIGhpZ2hsaWdodGVyOiB7XHJcbiAgICAgICAgbmFtZTogJ2FkZENsYXNzJyxcclxuICAgICAgICBvcHRpb25zOiB7XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ3RxLWxnLWRyYWdnZWQtbm9kZSdcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG5mdW5jdGlvbiBnZXRDbGFzcyAoKSB7XHJcbiAgICBpZiAodGhpcy5tb2RlbC5nZXQoJ2hpZ2hsaWdodGVkJykpIHtcclxuICAgICAgICB0aGlzLmhpZ2hsaWdodChudWxsLCBMR19DRUxMX0hJR0hMSUdIVEVSKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy51bmhpZ2hsaWdodChudWxsLCBMR19DRUxMX0hJR0hMSUdIVEVSKTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLm1vZGVsLmdldCgnYmx1cmVkJykpIHtcclxuICAgICAgICB0aGlzLmhpZ2hsaWdodChudWxsLCBMR19DRUxMX0JMVVJFUik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMudW5oaWdobGlnaHQobnVsbCwgTEdfQ0VMTF9CTFVSRVIpO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMubW9kZWwuZ2V0KCdoaWRkZW4nKSkge1xyXG4gICAgICAgIHRoaXMuaGlnaGxpZ2h0KG51bGwsIExHX0NFTExfSElEREVOKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy51bmhpZ2hsaWdodChudWxsLCBMR19DRUxMX0hJRERFTik7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5tb2RlbC5nZXQoJ3Nob3J0LWxhYmVsJykpIHtcclxuICAgICAgICB0aGlzLmhpZ2hsaWdodChudWxsLCBMR19TSE9SVF9MQUJFTCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMudW5oaWdobGlnaHQobnVsbCwgTEdfU0hPUlRfTEFCRUwpO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMubW9kZWwuZ2V0KCdkcmFnZ2VkJykpIHtcclxuICAgICAgICB0aGlzLmhpZ2hsaWdodChudWxsLCBMR19EUkFHR0VEX05PREUpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLnVuaGlnaGxpZ2h0KG51bGwsIExHX0RSQUdHRURfTk9ERSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBUaGUgTGlua1ZpZXcgY2xhc3MuIE1haW5seSBpbiBjaGFyZ2Ugb2Ygbm9kZSBoaWdobGlnaHRpbmcuXHJcbiAqIExpc3RlbiB0byBldmVudHMgYW5kIGFwcGx5IGhpZ2hsaWdodGVycy5cclxuICogQGNsYXNzXHJcbiAqIEBhdWdtZW50cyBqb2ludC5kaWEuTGlua1ZpZXdcclxuICogQHBhcmFtIHtOb2RlTW9kZWx9IGRhdGFNb2RlbCAtIE1vZGVsIG9mIGdyYXBoIG5vZGVcclxuICogQHBhcmFtIHt2ZXJ9IHBhcmFtZXRlcnMgLSBUaGUgc2V0IG9mIHBhcmFtZXRlcnNcclxuKi9cclxuZXhwb3J0IGZ1bmN0aW9uIE5vZGVWaWV3ICgpIHtcclxuICAgIGpvaW50LmRpYS5FbGVtZW50Vmlldy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59XHJcbk5vZGVWaWV3LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoam9pbnQuZGlhLkVsZW1lbnRWaWV3LnByb3RvdHlwZSk7XHJcbk5vZGVWaWV3LnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgam9pbnQuZGlhLkVsZW1lbnRWaWV3LnByb3RvdHlwZS5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICB0aGlzLmxpc3RlblRvKHRoaXMubW9kZWwsIFtcclxuICAgICAgICAnY2hhbmdlOmRyYWdnZWQnLFxyXG4gICAgICAgICdjaGFuZ2U6aGlnaGxpZ2h0ZWQnLFxyXG4gICAgICAgICdjaGFuZ2U6Ymx1cmVkJyxcclxuICAgICAgICAnY2hhbmdlOmhpZGRlbicsXHJcbiAgICAgICAgJ3JlZnJlc2gtaGlnaGxpZ2h0aW5nJyxcclxuICAgICAgICAnY2hhbmdlOnNob3J0LWxhYmVsJ1xyXG4gICAgXS5qb2luKCcgJyksIHRoaXMuZGVib3VuY2VkSGlnaGxpZ2h0aW5nKTtcclxufTtcclxuTm9kZVZpZXcucHJvdG90eXBlLmRlYm91bmNlcjtcclxuTm9kZVZpZXcucHJvdG90eXBlLmRlYm91bmNlZEhpZ2hsaWdodGluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuZGVib3VuY2VyKTtcclxuICAgIHRoaXMuZGVib3VuY2VyID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgICAgICBnZXRDbGFzcy5jYWxsKHRoaXMpO1xyXG4gICAgfSk7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqIFRoZSBMaW5rVmlldyBjbGFzcy4gTWFpbmx5IGluIGNoYXJnZSBvZiBsaW5rIGhpZ2hsaWdodGluZy5cclxuICogTGlzdGVuIHRvIGV2ZW50cyBhbmQgYXBwbHkgaGlnaGxpZ2h0ZXJzLlxyXG4gKiBAY2xhc3NcclxuICogQGF1Z21lbnRzIGpvaW50LmRpYS5MaW5rVmlld1xyXG4gKiBAcGFyYW0ge05vZGVNb2RlbH0gZGF0YU1vZGVsIC0gTW9kZWwgb2YgZ3JhcGggbm9kZVxyXG4gKiBAcGFyYW0ge1BhcmFtZXRlcnN9IHBhcmFtZXRlcnMgLSBUaGUgc2V0IG9mIHBhcmFtZXRlcnNcclxuKi9cclxuZXhwb3J0IGZ1bmN0aW9uIExpbmtWaWV3ICgpIHtcclxuICAgIGpvaW50LmRpYS5MaW5rVmlldy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59XHJcbkxpbmtWaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBqb2ludC5kaWEuTGlua1ZpZXcucHJvdG90eXBlLnJlbmRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59O1xyXG5MaW5rVmlldy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGpvaW50LmRpYS5MaW5rVmlldy5wcm90b3R5cGUpO1xyXG5MaW5rVmlldy5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGpvaW50LmRpYS5MaW5rVmlldy5wcm90b3R5cGUuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgXHJcbiAgICB0aGlzLmxpc3RlblRvKHRoaXMubW9kZWwsIFtcclxuICAgICAgICAnY2hhbmdlOmhpZ2hsaWdodGVkJyxcclxuICAgICAgICAnY2hhbmdlOmJsdXJlZCcsXHJcbiAgICAgICAgJ2NoYW5nZTpoaWRkZW4nLFxyXG4gICAgICAgICdyZWZyZXNoLWhpZ2hsaWdodGluZycsXHJcbiAgICBdLmpvaW4oJyAnKSwgdGhpcy5kZWJvdW5jZWRIaWdobGlnaHRpbmcpO1xyXG59O1xyXG5MaW5rVmlldy5wcm90b3R5cGUuZ2V0UG9pbnRBdExlbmd0aCA9IGZ1bmN0aW9uIChrKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fVi5jb25uZWN0aW9uLm5vZGUuZ2V0UG9pbnRBdExlbmd0aCh0aGlzLl9WLmNvbm5lY3Rpb24ubm9kZS5nZXRUb3RhbExlbmd0aCgpICogayk7XHJcbn07XHJcbkxpbmtWaWV3LnByb3RvdHlwZS5kZWJvdW5jZXI7XHJcbkxpbmtWaWV3LnByb3RvdHlwZS5kZWJvdW5jZWRIaWdobGlnaHRpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmRlYm91bmNlcik7XHJcbiAgICB0aGlzLmRlYm91bmNlciA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgICAgZ2V0Q2xhc3MuY2FsbCh0aGlzKTtcclxuICAgIH0pO1xyXG59O1xyXG5MaW5rVmlldy5wcm90b3R5cGUudXBkYXRlVG9vbHNQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICBpZiAoIXRoaXMuX1YubGlua1Rvb2xzKSByZXR1cm4gdGhpcztcclxuXHJcbiAgICAvLyBNb3ZlIHRoZSB0b29scyBhIGJpdCB0byB0aGUgdGFyZ2V0IHBvc2l0aW9uIGJ1dCBkb24ndCBjb3ZlciB0aGUgYHNvdXJjZUFycm93aGVhZGAgbWFya2VyLlxyXG4gICAgLy8gTm90ZSB0aGF0IHRoZSBvZmZzZXQgaXMgaGFyZGNvZGVkIGhlcmUuIFRoZSBvZmZzZXQgc2hvdWxkIGJlIGFsd2F5c1xyXG4gICAgLy8gbW9yZSB0aGFuIHRoZSBgdGhpcy4kKCcubWFya2VyLWFycm93aGVhZFtlbmQ9XCJzb3VyY2VcIl0nKVswXS5iYm94KCkud2lkdGhgIGJ1dCBsb29raW5nXHJcbiAgICAvLyB0aGlzIHVwIGFsbCB0aGUgdGltZSB3b3VsZCBiZSBzbG93LlxyXG5cclxuICAgIGxldCBzY2FsZSA9ICcnO1xyXG4gICAgY29uc3QgY29ubmVjdGlvbkxlbmd0aCA9IHRoaXMuZ2V0Q29ubmVjdGlvbkxlbmd0aCgpO1xyXG5cclxuICAgIC8vIEZpcmVmb3ggcmV0dXJucyBjb25uZWN0aW9uTGVuZ3RoPU5hTiBpbiBvZGQgY2FzZXMgKGZvciBiZXppZXIgY3VydmVzKS5cclxuICAgIC8vIEluIHRoYXQgY2FzZSB3ZSB3b24ndCB1cGRhdGUgdG9vbHMgcG9zaXRpb24gYXQgYWxsLlxyXG4gICAgaWYgKCFfLmlzTmFOKGNvbm5lY3Rpb25MZW5ndGgpKSB7XHJcblxyXG4gICAgICAgIC8vIElmIHRoZSBsaW5rIGlzIHRvbyBzaG9ydCwgbWFrZSB0aGUgdG9vbHMgaGFsZiB0aGUgc2l6ZSBhbmQgdGhlIG9mZnNldCB0d2ljZSBhcyBsb3cuXHJcbiAgICAgICAgaWYgKGNvbm5lY3Rpb25MZW5ndGggPCB0aGlzLm9wdGlvbnMuc2hvcnRMaW5rTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHNjYWxlID0gJ3NjYWxlKC41KSc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl90b29sQ2FjaGUuZm9yRWFjaCgodG9vbCwgaW5kZXgsIGFycikgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBpID0gaW5kZXggKyAxO1xyXG4gICAgICAgICAgICBjb25zdCBsID0gYXJyLmxlbmd0aCArIDE7XHJcbiAgICAgICAgICAgIGNvbnN0IGsgPSBpIC8gbDtcclxuICAgICAgICAgICAgY29uc3QgdG9vbFBvc2l0aW9uID0gdGhpcy5nZXRQb2ludEF0TGVuZ3RoKGspO1xyXG4gICAgICAgICAgICBpZiAodG9vbC5ub2RlIGluc3RhbmNlb2YgU1ZHR0VsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIHRvb2wuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgdG9vbFBvc2l0aW9uLnggKyAnLCAnICsgdG9vbFBvc2l0aW9uLnkgKyAnKSAnICsgc2NhbGUpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZG91YmxlTGlua1Rvb2xzICYmIGNvbm5lY3Rpb25MZW5ndGggPj0gdGhpcy5vcHRpb25zLmxvbmdMaW5rTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3UG9zaXRpb24gPSB0aGlzLmdldFBvaW50QXRMZW5ndGgoayAvKmNvbm5lY3Rpb25MZW5ndGggLSBkb3VibGVMaW5rVG9vbHNPZmZzZXQqLyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdG9vbDJDYWNoZS5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBuZXdQb3NpdGlvbi54ICsgJywgJyArIG5ld1Bvc2l0aW9uLnkgKyAnKSAnICsgc2NhbGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Rvb2wyQ2FjaGUuYXR0cigndmlzaWJpbGl0eScsICd2aXNpYmxlJyk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5kb3VibGVMaW5rVG9vbHMpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90b29sMkNhY2hlLmF0dHIoJ3Zpc2liaWxpdHknLCAnaGlkZGVuJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbkxpbmtWaWV3LnByb3RvdHlwZS5yZW5kZXJUb29scyA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICBpZiAoIXRoaXMuX1YubGlua1Rvb2xzKSByZXR1cm4gdGhpcztcclxuXHJcbiAgICAvLyBUb29scyBhcmUgYSBncm91cCBvZiBjbGlja2FibGUgZWxlbWVudHMgdGhhdCBtYW5pcHVsYXRlIHRoZSB3aG9sZSBsaW5rLlxyXG4gICAgLy8gQSBnb29kIGV4YW1wbGUgb2YgdGhpcyBpcyB0aGUgcmVtb3ZlIHRvb2wgdGhhdCByZW1vdmVzIHRoZSB3aG9sZSBsaW5rLlxyXG4gICAgLy8gVG9vbHMgYXBwZWFyIGFmdGVyIGhvdmVyaW5nIHRoZSBsaW5rIGNsb3NlIHRvIHRoZSBgc291cmNlYCBlbGVtZW50L3BvaW50IG9mIHRoZSBsaW5rXHJcbiAgICAvLyBidXQgYXJlIG9mZnNldCBhIGJpdCBzbyB0aGF0IHRoZXkgZG9uJ3QgY292ZXIgdGhlIGBtYXJrZXItYXJyb3doZWFkYC5cclxuXHJcbiAgICB2YXIgaHRtbFRvb2xzID0gdGhpcy5fVi5saW5rVG9vbHMubm9kZTtcclxuICAgIHZhciB0b29sVGVtcGxhdGUgPSBqb2ludC51dGlsLnRlbXBsYXRlKHRoaXMubW9kZWwuZ2V0KCd0b29sTWFya3VwJykgfHwgdGhpcy5tb2RlbC50b29sTWFya3VwKTtcclxuICAgIHZhciB2VG9vbHMgPSBWKHRvb2xUZW1wbGF0ZSgpKTtcclxuXHJcbiAgICB2YXIgdG9vbHM7XHJcbiAgICBpZiAodlRvb2xzIGluc3RhbmNlb2YgQXJyYXkpIHtcclxuICAgICAgICB0b29scyA9IHZUb29scztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdG9vbHMgPSBbdlRvb2xzXTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgdG9vbHMuZm9yRWFjaCh0b29sID0+IHtcclxuICAgICAgICBodG1sVG9vbHMuYXBwZW5kQ2hpbGQodG9vbC5ub2RlKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIENhY2hlIHRoZSB0b29sIG5vZGUgc28gdGhhdCB0aGUgYHVwZGF0ZVRvb2xzUG9zaXRpb24oKWAgY2FuIHVwZGF0ZSB0aGUgdG9vbCBwb3NpdGlvbiBxdWlja2x5LlxyXG4gICAgdGhpcy5fdG9vbENhY2hlID0gdG9vbHM7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5jb25zdCBvdmVycmlkZWRGdW5jdGlvbiA9IExpbmtWaWV3LnByb3RvdHlwZS5nZXRDb25uZWN0aW9uUG9pbnQ7XHJcbkxpbmtWaWV3LnByb3RvdHlwZS5nZXRDb25uZWN0aW9uUG9pbnQgPSBmdW5jdGlvbiAoZW5kLCBzZWxlY3Rvck9yUG9pbnQsIHJlZmVyZW5jZVNlbGVjdG9yT3JQb2ludCkge1xyXG4gICAgbGV0IGNvbm5lY3Rpb25Qb2ludCA9IG92ZXJyaWRlZEZ1bmN0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblxyXG4gICAgbGV0IGxpbWl0Qm94O1xyXG4gICAgXy5pc0VtcHR5KHNlbGVjdG9yT3JQb2ludCkgJiYgKHNlbGVjdG9yT3JQb2ludCA9IHsgeDogMCwgeTogMCB9KTtcclxuICAgIF8uaXNFbXB0eShyZWZlcmVuY2VTZWxlY3Rvck9yUG9pbnQpICYmIChyZWZlcmVuY2VTZWxlY3Rvck9yUG9pbnQgPSB7IHg6IDAsIHk6IDAgfSk7XHJcblxyXG4gICAgaWYgKCFzZWxlY3Rvck9yUG9pbnQuaWQpIHtcclxuICAgICAgICBjb25zdCBwb2ludCA9IGcucG9pbnQoc2VsZWN0b3JPclBvaW50KTtcclxuICAgICAgICBsaW1pdEJveCA9IHtcclxuICAgICAgICAgICAgeDogcG9pbnQueCxcclxuICAgICAgICAgICAgeTogcG9pbnQueSxcclxuICAgICAgICAgICAgd2lkdGg6IDAsXHJcbiAgICAgICAgICAgIGhlaWdodDogMCxcclxuICAgICAgICAgICAgY2VudGVyOiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9pbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBsaW1pdEJveCA9IChlbmQgPT09ICdzb3VyY2UnID8gdGhpcy5zb3VyY2VCQm94IDogdGhpcy50YXJnZXRCQm94KTtcclxuICAgIH1cclxuICAgIGNvbnN0IGxpbWl0Q2V0ZXIgPSBsaW1pdEJveC5jZW50ZXIoKTtcclxuXHJcbiAgICBjb25zdCByaWdodEJvcmRlciA9IE1hdGgucm91bmQobGltaXRDZXRlci54ICsgbGltaXRCb3gud2lkdGggLyAyKTtcclxuICAgIGNvbnN0IGxlZnRCb3JkZXIgPSBNYXRoLnJvdW5kKGxpbWl0Q2V0ZXIueCAtIGxpbWl0Qm94LndpZHRoIC8gMik7XHJcbiAgICBjb25zdCBib3R0b21Cb3JkZXIgPSBNYXRoLnJvdW5kKGxpbWl0Q2V0ZXIueSArIGxpbWl0Qm94LmhlaWdodCAvIDIpO1xyXG4gICAgY29uc3QgdG9wQm9yZGVyID0gTWF0aC5yb3VuZChsaW1pdENldGVyLnkgLSBsaW1pdEJveC5oZWlnaHQgLyAyKTtcclxuXHJcbiAgICBjb25zdCB4SW5zaWRlID0gbGVmdEJvcmRlciA8IGNvbm5lY3Rpb25Qb2ludC54ICYmIGNvbm5lY3Rpb25Qb2ludC54IDwgcmlnaHRCb3JkZXI7XHJcbiAgICBjb25zdCB5SW5zaWRlID0gdG9wQm9yZGVyIDwgY29ubmVjdGlvblBvaW50LnkgJiYgY29ubmVjdGlvblBvaW50LnkgPCBib3R0b21Cb3JkZXI7XHJcbiAgICBjb25zdCBpc0luVGhlQm9keSA9IHhJbnNpZGUgJiYgeUluc2lkZTtcclxuXHJcbiAgICBpZiAoaXNJblRoZUJvZHkpIHtcclxuICAgICAgICBjb25zdCByaWdodERpc3QgPSByaWdodEJvcmRlciAtIGNvbm5lY3Rpb25Qb2ludC54O1xyXG4gICAgICAgIGNvbnN0IGxlZnREaXN0ID0gY29ubmVjdGlvblBvaW50LnggLSBsZWZ0Qm9yZGVyO1xyXG4gICAgICAgIGNvbnN0IGJvdHRvbURpc3QgPSBib3R0b21Cb3JkZXIgLSBjb25uZWN0aW9uUG9pbnQueTtcclxuICAgICAgICBjb25zdCB0b3BEaXN0ID0gY29ubmVjdGlvblBvaW50LnkgLSB0b3BCb3JkZXI7XHJcblxyXG4gICAgICAgIGNvbnN0IG1pbkRpc3QgPSBNYXRoLm1pbihyaWdodERpc3QsIGxlZnREaXN0LCBib3R0b21EaXN0LCB0b3BEaXN0KTtcclxuXHJcbiAgICAgICAgaWYgKHJpZ2h0RGlzdCA9PT0gbWluRGlzdCkge1xyXG4gICAgICAgICAgICBjb25uZWN0aW9uUG9pbnQub2Zmc2V0KHJpZ2h0RGlzdCwgMCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChsZWZ0RGlzdCA9PT0gbWluRGlzdCkge1xyXG4gICAgICAgICAgICBjb25uZWN0aW9uUG9pbnQub2Zmc2V0KC1sZWZ0RGlzdCwgMCk7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0b3BEaXN0ID09PSBtaW5EaXN0KSB7XHJcbiAgICAgICAgICAgIGNvbm5lY3Rpb25Qb2ludC5vZmZzZXQoMCwgLXRvcERpc3QpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoYm90dG9tRGlzdCA9PT0gbWluRGlzdCkge1xyXG4gICAgICAgICAgICBjb25uZWN0aW9uUG9pbnQub2Zmc2V0KDAsIGJvdHRvbURpc3QpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBsZXQgcmVmZXJlbmNlO1xyXG4gICAgdmFyIHNwb3RCYm94ID0gZW5kID09PSAnc291cmNlJyA/IHRoaXMuc291cmNlQkJveCA6IHRoaXMudGFyZ2V0QkJveDtcclxuICAgIGlmICghcmVmZXJlbmNlU2VsZWN0b3JPclBvaW50LmlkKSB7XHJcbiAgICAgICAgcmVmZXJlbmNlID0gZy5wb2ludChyZWZlcmVuY2VTZWxlY3Rvck9yUG9pbnQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zdCByZWZlcmVuY2VCYm94ID0gZW5kID09PSAnc291cmNlJyA/IHRoaXMudGFyZ2V0QkJveCA6IHRoaXMuc291cmNlQkJveDtcclxuXHJcbiAgICAgICAgcmVmZXJlbmNlID0gZy5yZWN0KHJlZmVyZW5jZUJib3gpLmludGVyc2VjdGlvbldpdGhMaW5lRnJvbUNlbnRlclRvUG9pbnQoZy5yZWN0KHNwb3RCYm94KS5jZW50ZXIoKSk7XHJcbiAgICAgICAgcmVmZXJlbmNlID0gcmVmZXJlbmNlIHx8IGcucmVjdChyZWZlcmVuY2VCYm94KS5jZW50ZXIoKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBhbGlnblggPSBNYXRoLmFicyhyZWZlcmVuY2UueCAtIGNvbm5lY3Rpb25Qb2ludC54KTtcclxuICAgIGNvbnN0IGFsaWduWSA9IE1hdGguYWJzKHJlZmVyZW5jZS55IC0gY29ubmVjdGlvblBvaW50LnkpO1xyXG5cclxuICAgIGNvbnN0IHJvdXRlcklkID0gdGhpcy5tb2RlbC5nZXQoJ3JvdXRlcicpICYmIHRoaXMubW9kZWwuZ2V0KCdyb3V0ZXInKS5uYW1lO1xyXG4gICAgY29uc3Qgc3BlY2lhbFJvdXRlciA9IHJvdXRlcklkICYmIChyb3V0ZXJJZCA9PT0gJ2xncm91dGVyJyB8fCByb3V0ZXJJZCA9PT0gJ21ldHJvJyk7XHJcbiAgICBpZiAodGhpcy5tb2RlbCBpbnN0YW5jZW9mIExpbmsgJiYgc3BlY2lhbFJvdXRlcikge1xyXG4gICAgICAgIGlmIChhbGlnblggPD0gYWxpZ25ZKSB7XHJcbiAgICAgICAgICAgIGNvbm5lY3Rpb25Qb2ludC5vZmZzZXQocmVmZXJlbmNlLnggLSBjb25uZWN0aW9uUG9pbnQueCwgMCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29ubmVjdGlvblBvaW50Lm9mZnNldCgwLCByZWZlcmVuY2UueSAtIGNvbm5lY3Rpb25Qb2ludC55KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29ubmVjdGlvblBvaW50ID0gZy5wb2ludCh7XHJcbiAgICAgICAgeDogTWF0aC5tYXgoTWF0aC5taW4oTWF0aC5yb3VuZChjb25uZWN0aW9uUG9pbnQueCksIHJpZ2h0Qm9yZGVyKSwgbGVmdEJvcmRlciksXHJcbiAgICAgICAgeTogTWF0aC5tYXgoTWF0aC5taW4oTWF0aC5yb3VuZChjb25uZWN0aW9uUG9pbnQueSksIGJvdHRvbUJvcmRlciksIHRvcEJvcmRlciksXHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gY29ubmVjdGlvblBvaW50O1xyXG59OyIsImltcG9ydCAqIGFzIGpvaW50IGZyb20gJ3JhcHBpZCc7XHJcbmltcG9ydCB7IFJlc291cmNlUHJvdmlkZXIgfSBmcm9tICcuLi8uLi9kYXRhL3Jlc291cmNlUHJvdmlkZXInO1xyXG5pbXBvcnQgeyBaX0lOREVYRVMgfSBmcm9tICcuL2VsZW1lbnRzJztcclxuXHJcbmV4cG9ydCBjb25zdCBERUZBVUxUX0xJTktfVFlQRSA9ICdsaW5lYWdlLWdyYW0tbGluayc7XHJcbmV4cG9ydCBjb25zdCBBTFdBWVNfVklTSUJMRV9UT09MX0JVVFRPTlM9ICdsZy12aXNpYmxlLXRvb2wtYnV0dG9ucyc7XHJcblxyXG4vKipcclxuICogTGlua01vZGVsIC0gZGF0YSBtb2RlbCBmb3IgYSB7QGxpbmsgTGlua30gb2JqZWN0XHJcbiAqIEB0eXBlZGVmIHtPYmplY3R9IExpbmtNb2RlbFxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gaWQgLSBMaW5rIGlkZW50aWZ5ZXJcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHRhcmdldCAtIFRhcmdldCBOb2RlIGlkXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzb3VyY2UgLSBTb3VyY2UgTm9kZSBpZFxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbGlua3R5cGUgLSBUeXBlIG9mIHRoZSBMaW5rXHJcbiovXHJcblxyXG4vKipcclxuICogVGhlIGdyYXBoIExpbmsgY2xhc3Mgd2hpY2ggaXMgIGJhc2VkIG9uIGpvaW50LmRpYS5MaW5rLiBJcyB0aGUgb25lIG9mIHRoZSBtYWluIGVsZW1lbnRzIG9mIHRoZSBMaW5lYWdlRnJhbS5cclxuICogUmVwcmVzZW50cyBleGlzdGluZyByZWxhdGlvbiBvZiB0aGUgcGFydHMgb2YgdGhlIGRhdGFzZXQuICBIYXMgc3BlY2lmaWMgdHlwZSBhbmQgaWQuXHJcbiAqIEBjbGFzc1xyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAYXVnbWVudHMgam9pbnQuZGlhLkxpbmtcclxuICogXHJcbiAqIEBwYXJhbSB7TGlua01vZGVsfSBkYXRhTW9kZWwgLSBEYXRhIG1vZGVsXHJcbiAqIEBwYXJhbSB7UGFyYW1ldGVyc30gcGFyYW1ldGVycyAtIFRoZSBzZXQgb2YgcGFyYW1ldGVyc1xyXG4gKiBcclxuICogQHByb3BlcnR5IHtMaW5rTW9kZWx9IG1vZGVsIC0gRGF0YSBtb2RlbFxyXG4gKiBAcHJvcGVydHkge1Rlcm1pbmF0aW9uTGlua30gdGVybWluYXRpb25MaW5rIC0gVGVybWluYXRpb24gbGluayB3aGljaFxyXG4gKiByZXByZXNlbnRzIHRoaXMgbGluaywgd2hlbiB0aGUgbm9kZSBpcyBvdXQgb2YgdGhlIHZpZXdGcmFtZVxyXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGhpZ2hsaWdodGVkIC0gVGVsbHMgd2hldGVyIGhpZ2hsaWdodGVkIGxpbmsgb3Igbm90ICh1c2UgbWV0aG9kIGdldCB0byBnZXQgdGhpcyBwcm9wZXJ0eSwgZS5nLiBsaW5rLmdldCgnaGlnaGxpZ2h0ZWQnKSlcclxuICogQHByb3BlcnR5IHtib29sZWFufSBibHVyZWQgLSBUZWxscyB3aGV0ZXIgYmx1cmVkIGxpbmsgb3Igbm90ICh1c2UgbWV0aG9kIGdldCB0byBnZXQgdGhpcyBwcm9wZXJ0eSwgZS5nLiBsaW5rLmdldCgnYmx1cmVkJykpXHJcbiovXHJcbmV4cG9ydCBmdW5jdGlvbiBMaW5rIChkYXRhTW9kZWwsIHBhcmFtZXRlcnMpIHtcclxuICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgIGNvbnN0IF9yZXMgPSBuZXcgUmVzb3VyY2VQcm92aWRlcihwYXJhbWV0ZXJzKTtcclxuXHJcbiAgICBzZWxmLnRlcm1pbmF0aW9uTGlua3MgPSBbXTtcclxuICAgIHNlbGYuaGlnaGxpZ2h0ZWQgPSBmYWxzZTtcclxuICAgIHNlbGYuYmx1cmVkID0gZmFsc2U7XHJcbiAgICBcclxuICAgIGxldCBfbGlua1N0eWxlO1xyXG4gICAgbGV0IF90b29sTWFya3VwO1xyXG4gICAgaWYgKGRhdGFNb2RlbC5ncm91cCkge1xyXG4gICAgICAgIGNvbnN0IGV4aXN0ZWRUeXBlSWRzID0gW107XHJcbiAgICAgICAgY29uc3QgZ3JvdXBUb29scyA9IGRhdGFNb2RlbC5ncm91cFxyXG4gICAgICAgICAgICAuZmlsdGVyKG1vZGVsID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRlY2lzaW9uID0gZXhpc3RlZFR5cGVJZHMuaW5kZXhPZihtb2RlbC5saW5rVHlwZSkgPT09IC0xO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRlY2lzaW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhpc3RlZFR5cGVJZHMucHVzaChtb2RlbC5saW5rVHlwZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVjaXNpb247XHJcbiAgICAgICAgICAgIH0pLm1hcChtb2RlbCA9PiAoe1xyXG4gICAgICAgICAgICAgICAgbGlua1R5cGU6IG1vZGVsLmxpbmtUeXBlLFxyXG4gICAgICAgICAgICAgICAgbGlua1N0eWxlOiBfcmVzLmdldExpbmtTdHlsZShtb2RlbC5saW5rVHlwZSksXHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgaWYgKGdyb3VwVG9vbHMubGVuZ3RoID09PSAxKSBfbGlua1N0eWxlID0gZ3JvdXBUb29sc1swXS5saW5rU3R5bGU7XHJcbiAgICAgICAgZWxzZSBfbGlua1N0eWxlID0gX3Jlcy5nZXRMaW5rU3R5bGUoZGF0YU1vZGVsLmxpbmtUeXBlKTsgXHJcbiAgICAgICAgX3Rvb2xNYXJrdXAgPSBfZ2V0VG9vbE1hcmt1cChncm91cFRvb2xzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgX2xpbmtTdHlsZSA9IF9yZXMuZ2V0TGlua1N0eWxlKGRhdGFNb2RlbC5saW5rVHlwZSk7IFxyXG4gICAgICAgIF90b29sTWFya3VwID0gX2dldFRvb2xNYXJrdXAoW3tcclxuICAgICAgICAgICAgbGlua1R5cGU6IGRhdGFNb2RlbC5saW5rVHlwZSxcclxuICAgICAgICAgICAgbGlua1N0eWxlOiBfbGlua1N0eWxlLFxyXG4gICAgICAgIH1dKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgY29uc3QgdHlwZXMgPSBbREVGQVVMVF9MSU5LX1RZUEVdO1xyXG4gICAgaWYgKF9saW5rU3R5bGUuY3NzQ2xhc3MgJiYgX2xpbmtTdHlsZS5jc3NDbGFzcyAhPT0gREVGQVVMVF9MSU5LX1RZUEUpIHtcclxuICAgICAgICB0eXBlcy5wdXNoKF9saW5rU3R5bGUuY3NzQ2xhc3MpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChfbGlua1N0eWxlLnRvb2xCdXR0b24uYWx3YXlzVmlzaWJsZSkge1xyXG4gICAgICAgIHR5cGVzLnB1c2goQUxXQVlTX1ZJU0lCTEVfVE9PTF9CVVRUT05TKTtcclxuICAgIH1cclxuXHJcbiAgICBqb2ludC5kaWEuTGluay5hcHBseShzZWxmLCBbe1xyXG4gICAgICAgIHR5cGU6IHR5cGVzLmpvaW4oJyAnKSxcclxuICAgICAgICBzb3VyY2U6IHsgaWQ6IGRhdGFNb2RlbC5zb3VyY2UsIHBvcnQ6ICdjbGlwUmVjdFBvcnQnIH0sXHJcbiAgICAgICAgdGFyZ2V0OiB7IGlkOiBkYXRhTW9kZWwudGFyZ2V0LCBwb3J0OiAnY2xpcFJlY3RQb3J0JyB9LFxyXG4gICAgICAgIHo6IFpfSU5ERVhFUy5MSU5LLFxyXG4gICAgICAgIGF0dHJzOiBfZ2V0TGlua0F0dHJpYnV0ZXMoX2xpbmtTdHlsZSksXHJcbiAgICAgICAgY29ubmVjdG9yOiB7bmFtZTogJ3JvdW5kZWQnIH0sXHJcbiAgICAgICAgLy8gY29ubmVjdG9yOiB7IG5hbWU6ICdqdW1wb3ZlcicsIGFyZ3M6IHsgdHlwZTogJ2dhcCcgfX0sXHJcbiAgICAgICAgcm91dGVyOiB7XHJcbiAgICAgICAgICAgIG5hbWU6IGRhdGFNb2RlbC5yb3V0aW5nLFxyXG4gICAgICAgICAgICBhcmdzOiB7XHJcbiAgICAgICAgICAgICAgICBleGNsdWRlVHlwZXM6IFtcclxuICAgICAgICAgICAgICAgICAgICAndmlld0ZyYW1lJyxcclxuICAgICAgICAgICAgICAgICAgICAndGVybWluYXRpb25MaW5rJyxcclxuICAgICAgICAgICAgICAgICAgICAndGVybWluYXRpb25Ob2RlJyxcclxuICAgICAgICAgICAgICAgICAgICAndmlldy1mcmFtZS1zcGxpdHRlcicsXHJcbiAgICAgICAgICAgICAgICAgICAgJ3ZpZXctZnJhbWUtc3BsaXR0ZXItdmVydGljYWwnLFxyXG4gICAgICAgICAgICAgICAgICAgICdhc3BlY3RMaW5rJyxcclxuICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgICAgICBtYXhpbXVtTG9vcHM6IDMwMDAsXHJcbiAgICAgICAgICAgICAgICBtYXhBbGxvd2VkRGlyZWN0aW9uQ2hhbmdlOiAzMDAwLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdG9vbE1hcmt1cDogX3Rvb2xNYXJrdXAsXHJcbiAgICB9XSk7XHJcblxyXG4gICAgZnVuY3Rpb24gX2dldExpbmtBdHRyaWJ1dGVzIChsaW5rU3R5bGUpIHtcclxuICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0ge307XHJcbiAgICAgICAgYXR0cmlidXRlc1snLmNvbm5lY3Rpb24nXSA9IHtcclxuICAgICAgICAgICAgc3Ryb2tlOiBsaW5rU3R5bGUuY29sb3IsXHJcbiAgICAgICAgICAgICdzdHJva2Utd2lkdGgnOiBsaW5rU3R5bGUudGhpY2tuZXNzLFxyXG4gICAgICAgICAgICAnc3Ryb2tlLWRhc2hhcnJheSc6IGxpbmtTdHlsZS5saW5lVHlwZSA9PT0gJ3NvbGlkJyA/IHVuZGVmaW5lZCA6ICc1LDUnLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKGxpbmtTdHlsZS5oYXNBcnJvdykge1xyXG4gICAgICAgICAgICBhdHRyaWJ1dGVzWycubWFya2VyLXNvdXJjZSddID0ge1xyXG4gICAgICAgICAgICAgICAgZmlsbDogbGlua1N0eWxlLmNvbG9yLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiBsaW5rU3R5bGUuY29sb3IsXHJcbiAgICAgICAgICAgICAgICBkOiAnTTAsM2EzLDMgMCAxLDAgNiwwYTMsMyAwIDEsMCAtNiwwJyxcclxuICAgICAgICAgICAgICAgICdzdHJva2Utd2lkdGgnOiBsaW5rU3R5bGUudGhpY2tuZXNzLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBhdHRyaWJ1dGVzWycubWFya2VyLXRhcmdldCddID0ge1xyXG4gICAgICAgICAgICAgICAgZmlsbDogbGlua1N0eWxlLmNvbG9yLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiBsaW5rU3R5bGUuY29sb3IsXHJcbiAgICAgICAgICAgICAgICBkOiAnTSAxMCAwIEwgMCA1IEwgMTAgMTAgeicsXHJcbiAgICAgICAgICAgICAgICAnc3Ryb2tlLXdpZHRoJzogbGlua1N0eWxlLnRoaWNrbmVzcyxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZXM7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX2dldFRvb2xNYXJrdXAgKGxpbmtUb29scykge1xyXG4gICAgICAgIHJldHVybiBsaW5rVG9vbHMubWFwKGxpbmtUb29sID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbGlua1R5cGVJZCA9IGxpbmtUb29sLmxpbmtUeXBlO1xyXG4gICAgICAgICAgICBjb25zdCB0b29sID0gbGlua1Rvb2wubGlua1N0eWxlLnRvb2xCdXR0b247XHJcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gdG9vbC53aWR0aCB8fCAzMDtcclxuICAgICAgICAgICAgY29uc3QgaGllZ2h0ID0gdG9vbC5oaWVnaHQgfHwgMzA7XHJcbiAgICAgICAgICAgIHJldHVybiBgPGcgY2xhc3M9XCJsaW5rLXRvb2xcIj5cclxuICAgICAgICAgICAgICAgIDxnIGNsYXNzPVwidG9vbC1vcHRpb25zXCIgZXZlbnQ9XCJsaW5rOm9wdGlvbnNcIiBsaW5rVHlwZT1cIiR7bGlua1R5cGVJZH1cIj5cclxuICAgICAgICAgICAgICAgICAgICA8aW1hZ2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg9XCIke3dpZHRofVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodD1cIiR7aGllZ2h0fVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHg9XCItJHt3aWR0aC8yfVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHk9XCItJHtoaWVnaHQvMn1cIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB4bGluazpocmVmPVwiJHt0b29sLmltYWdlfVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uZXJyb3I9XCJ0aGlzLnNldEF0dHJpYnV0ZSggJ3hsaW5rOmhyZWYnLCAnJHtfcmVzLmdldEltYWdlKCdkZWZhdWx0LWxpbmstb3B0aW9ucycpfScgKTtcIlxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPHRpdGxlPk9wZW4gZGVyaXZhdGlvbiBtYXAke2xpbmtUeXBlSWQgPyAnIGZvciAnICsgbGlua1R5cGVJZCA6ICcnfTwvdGl0bGU+XHJcbiAgICAgICAgICAgICAgICA8L2c+XHJcbiAgICAgICAgICAgIDwvZz5gO1xyXG4gICAgICAgIH0pLmpvaW4oKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlbGxzIHVzIHdoZXRoZXIgdGhlIGxpbmsgaXMgY3VycmVudGx5XHJcbiAgICAgKiBvbiB0aGUgZ3JhcGggKGluIHRoZSBhbnkgb2YgdmlldyBmcmFtZXMpIG9yIG5vdFxyXG4gICAgICogQHJldHVybnMge2Jvb2xlbmF9XHJcbiAgICAgKi9cclxuICAgIHNlbGYuaXNPblRoZUdyYXBoID0gKCkgPT4ge1xyXG4gICAgICAgIHJldHVybiAoc2VsZi5ncmFwaCA/IHRydWUgOiBmYWxzZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSGlnaGxpZ2h0cyB0aGUgTGluay5cclxuICAgICAqIEBtZW1iZXJvZiBMaW5rXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAqL1xyXG4gICAgc2VsZi5zZWxlY3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgc2VsZi50ZXJtaW5hdGlvbkxpbmtzLmZvckVhY2godGwgPT4gdGwuc2VsZWN0KHRydWUpKTtcclxuICAgICAgICBpZiAoc2VsZi5nZXQoJ2JsdXJlZCcpKSBzZWxmLnVuYmx1cmUoKTtcclxuICAgICAgICBpZiAoc2VsZi5nZXQoJ2hpZGRlbicpKSBzZWxmLnNob3coKTtcclxuICAgICAgICBzZWxmLnByb3AoeyB6OiBaX0lOREVYRVMuU0VMRUNURURfRUxFTUVOVCB9KTtcclxuICAgICAgICBzZWxmLnNldCgnaGlnaGxpZ2h0ZWQnLCB0cnVlKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGhpZ2hsaWdodGluZyBmcm9tIHRoZSBMaW5rLlxyXG4gICAgICogQG1lbWJlcm9mIExpbmtcclxuICAgICAqIEBtZXRob2RcclxuICAgICovXHJcbiAgICBzZWxmLnVuc2VsZWN0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHNlbGYudGVybWluYXRpb25MaW5rcy5mb3JFYWNoKHRsID0+IHRsLnVuc2VsZWN0KHRydWUpKTtcclxuICAgICAgICBzZWxmLnByb3AoeyB6OiBaX0lOREVYRVMuTElOSyB9KTtcclxuICAgICAgICBzZWxmLnNldCgnaGlnaGxpZ2h0ZWQnLCBmYWxzZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQmx1cnMgdGhlIExpbmsuXHJcbiAgICAgKiBAbWVtYmVyb2YgTGlua1xyXG4gICAgICogQG1ldGhvZFxyXG4gICAgKi9cclxuICAgIHNlbGYuYmx1cmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHNlbGYuZ2V0KCdoaWdobGlnaHRlZCcpKSByZXR1cm47XHJcbiAgICAgICAgc2VsZi50ZXJtaW5hdGlvbkxpbmtzLmZvckVhY2godGwgPT4gdGwuYmx1cmUodHJ1ZSkpO1xyXG4gICAgICAgIHNlbGYucHJvcCh7IHo6IFpfSU5ERVhFUy5CTFVSRURfTElOSyB9KTtcclxuICAgICAgICBzZWxmLnNldCgnYmx1cmVkJywgdHJ1ZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBibHVyIGZyb20gdGhlIExpbmsuXHJcbiAgICAgKiBAbWVtYmVyb2YgTGlua1xyXG4gICAgICogQG1ldGhvZFxyXG4gICAgKi9cclxuICAgIHNlbGYudW5ibHVyZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBzZWxmLnRlcm1pbmF0aW9uTGlua3MuZm9yRWFjaCh0bCA9PiB0bC51bmJsdXJlKHRydWUpKTtcclxuICAgICAgICBzZWxmLnByb3AoeyB6OiBaX0lOREVYRVMuTElOSyB9KTtcclxuICAgICAgICBzZWxmLnNldCgnYmx1cmVkJywgZmFsc2UpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEhpZGVzIHRoZSBMaW5rLlxyXG4gICAgICogQG1lbWJlcm9mIExpbmtcclxuICAgICAqIEBtZXRob2RcclxuICAgICovXHJcbiAgICBzZWxmLmhpZGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgc2VsZi50ZXJtaW5hdGlvbkxpbmtzLmZvckVhY2godGwgPT4gdGwuaGlkZSh0cnVlKSk7XHJcbiAgICAgICAgc2VsZi5zZXQoJ2hpZGRlbicsIHRydWUpO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBTaG93cyB0aGUgTGluay5cclxuICAgICAqIEBtZW1iZXJvZiBMaW5rXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAqL1xyXG4gICAgc2VsZi5zaG93ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHNlbGYudGVybWluYXRpb25MaW5rcy5mb3JFYWNoKHRsID0+IHRsLnNob3codHJ1ZSkpO1xyXG4gICAgICAgIHNlbGYuc2V0KCdoaWRkZW4nLCBmYWxzZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVmcmVzaGVzIGhpZ2hsaWdodGVycyBvZiB0aGUgdmlldyBvZiB0aGlzIGVsZW1lbnQuXHJcbiAgICAgKiBAbWVtYmVyb2YgTGlua1xyXG4gICAgICogQG1ldGhvZFxyXG4gICAgKi9cclxuICAgIHNlbGYucmVmcmVzaEhpZ2hsaWdodGluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBzZWxmLnRyaWdnZXIoJ3JlZnJlc2gtaGlnaGxpZ2h0aW5nJywgc2VsZik7XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYubW9kZWwgPSBkYXRhTW9kZWw7XHJcbn1cclxuTGluay5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGpvaW50LmRpYS5MaW5rLnByb3RvdHlwZSk7XHJcbiIsImltcG9ydCAqIGFzIGpvaW50IGZyb20gJ3JhcHBpZCc7XHJcbmltcG9ydCB7IHVuaXF1ZUlkIH0gZnJvbSAnbG9kYXNoJztcclxuaW1wb3J0IHsgUmVzb3VyY2VQcm92aWRlciB9IGZyb20gJy4uLy4uL2RhdGEvcmVzb3VyY2VQcm92aWRlcic7XHJcbmltcG9ydCB7IFpfSU5ERVhFUyB9IGZyb20gJy4vZWxlbWVudHMnO1xyXG5cclxuZXhwb3J0IGNvbnN0IExBQkVMX0xFRlRfUklHSFRfUEFERElORyA9IDU7XHJcbmV4cG9ydCBjb25zdCBMQUJFTF9UT1BfQk9UVE9NX1BBRERJTkcgPSAxMDtcclxuZXhwb3J0IGNvbnN0IExBQkVMX0xJTkVfSEVJR0hUID0gMjA7XHJcbmV4cG9ydCBjb25zdCBCT0RZX1BBRERJTkcgPSAyNTtcclxuZXhwb3J0IGNvbnN0IElNR19QQURESU5HID0gMTA7XHJcbmV4cG9ydCBjb25zdCBGT05UX1NJWkUgPSAxNjtcclxuZXhwb3J0IGNvbnN0IEVYUEFOREVEX05PREVfR1JPV0lORyA9IDEuNTtcclxuXHJcbi8qKlxyXG4gKiBOb2RlTW9kZWwgLSBkYXRhIG1vZGVsIGZvciBhIHtAbGluayBOb2RlfSBvYmplY3RcclxuICogQHR5cGVkZWYge09iamVjdH0gTm9kZU1vZGVsXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBpZCAtIE5vZGUgaWRlbnRpZnllclxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbGFiZWwgLSBUaXRsZSBvZiB0aGUgTm9kZSxcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHZpZXdGcmFtZSAtIElkIG9mIFZpZXdGcmFtZSB3aWNoIHdpbGwgaW5jbHVkZSB0aGlzIG5vZGVcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHR5cGVJZCAtIFR5cGUgaWRlbnRpZnllclxyXG4qL1xyXG5cclxuLyoqXHJcbiAqIFRoZSBncmFwaCBOb2RlIGNsYXNzIHdoaWNoIGlzIGJhc2VkIG9uIGpvaW50LnNoYXBlcy5iYXNpYy5HZW5lcmljLiBJcyB0aGUgb25lIG9mIHRoZSBtYWluIGVsZW1lbnRzIG9mIHRoZSBMaW5lYWdlRnJhbS5cclxuICogUmVwcmVzZW50cyBleGlzdGluZyBwYXJ0IG9mIHRoZSBkYXRhc2V0IHdpdGggc3BlY2lmaWVkIGltYWdlLCBjb2xvciwgdHlwZSBhbmQgaWQgYW5kIHBsYWNlZCBpbiBzZXBhcmF0ZWQgVmlld0ZyYW1lLlxyXG4gKiBAY2xhc3NcclxuICogQHByaXZhdGVcclxuICogQGF1Z21lbnRzIGpvaW50LnNoYXBlcy5iYXNpYy5HZW5lcmljXHJcbiAqIEBwYXJhbSB7Tm9kZU1vZGVsfSBkYXRhTW9kZWwgLSBNb2RlbCBvZiBncmFwaCBub2RlXHJcbiAqIEBwYXJhbSB7UGFyYW1ldGVyc30gcGFyYW1ldGVycyAtIFRoZSBzZXQgb2YgcGFyYW1ldGVyc1xyXG4gKiBcclxuICogQHByb3BlcnR5IHtOb2RlW119IGFzcGVjdHMgLSBDb3BpZXMgb2YgdGhpcyBub2RlIGluIG90aGVyIGZyYW1lc1xyXG4gKiBAcHJvcGVydHkge05vZGVNb2RlbH0gbW9kZWwgLSBEYXRhIG1vZGVsXHJcbiAqIEBwcm9wZXJ0eSB7VGVybWluYXRpb25Ob2RlW119IHRlcm1pbmF0aW9uTm9kZXMgLSBUZXJtaW5hdGlvbiBub2RlcyB3aGljaCBleGlzdHMgb24gaW4gdGhlIGZyYW1lXHJcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaGlnaGxpZ2h0ZWQgLSBUZWxscyB3aGV0ZXIgaGlnaGxpZ2h0ZWQgbm9kZSBvciBub3QgKHVzZSBtZXRob2QgZ2V0IHRvIGdldCB0aGlzIHByb3BlcnR5LCBlLmcuIG5vZGUuZ2V0KCdoaWdobGlnaHRlZCcpKVxyXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGJsdXJlZCAtIFRlbGxzIHdoZXRlciBibHVyZWQgbm9kZSBvciBub3QgKHVzZSBtZXRob2QgZ2V0IHRvIGdldCB0aGlzIHByb3BlcnR5LCBlLmcuIG5vZGUuZ2V0KCdibHVyZWQnKSlcclxuICogQHByb3BlcnR5IHtWaWV3RnJhbWV9IHZpZXdGcmFtZU93bmVySWQgLSBFeGlzdHMgb25seSBpZiBlbGVtZW50IHdhcyBkcmFnZ2VkIGZyb20gb25lIHRvIGFub3RoZXIgZnJhbWVcclxuICogQHByb3BlcnR5IHtib29sZWFufSBkcmFnZ2VkIC0gSWYgc29tZWJvZHkgaXMgZHJhZ2dpbmcgdGhpcyBOb2RlIG5vdywgdGhlbiB0cnVlLlxyXG4qL1xyXG5leHBvcnQgZnVuY3Rpb24gTm9kZSAoZGF0YU1vZGVsLCBwYXJhbWV0ZXJzKSB7XHJcbiAgICBjb25zdCBzZWxmID0gdGhpcztcclxuICAgIGNvbnN0IF9zaXplID0gcGFyYW1ldGVycy5lbGVtZW50U2l6ZTtcclxuICAgIGNvbnN0IF9yZXMgPSBuZXcgUmVzb3VyY2VQcm92aWRlcihwYXJhbWV0ZXJzKTtcclxuICAgIFxyXG4gICAgbGV0IF9pc1ZlcnRpY2FsT3JpZW50ZWQgPSBwYXJhbWV0ZXJzLmdyYXBoT3JpZW50YXRpb24gPT09ICd0b3AtdG8tYm90dG9tJyB8fFxyXG4gICAgICAgIHBhcmFtZXRlcnMuZ3JhcGhPcmllbnRhdGlvbiA9PT0gJ2JvdHRvbS10by10b3AnO1xyXG5cclxuICAgIHNlbGYubW9kZWwgPSBkYXRhTW9kZWw7XHJcbiAgICBzZWxmLnRlcm1pbmF0aW9uTm9kZXMgPSBbXTtcclxuICAgIHNlbGYuYXNwZWN0cyA9IFtdO1xyXG4gICAgc2VsZi52aWV3RnJhbWVPd25lcklkID0gbnVsbDtcclxuICAgIHNlbGYuZHJhZ2dlZCA9IGZhbHNlO1xyXG4gICAgc2VsZi5ibHVyZWQgPSBmYWxzZTtcclxuICAgIHNlbGYuaGlnaGxpZ2h0ZWQgPSBmYWxzZTtcclxuICAgIHNlbGYuc2l6ZSA9IHsgd2lkdGg6IF9zaXplLndpZHRoLCBoZWlnaHQ6IF9zaXplLmhlaWdodCwgbWF4V2lkdGg6IF9zaXplLndpZHRoLCBtYXhIZWlnaHQ6IF9zaXplLmhlaWdodCB9O1xyXG4gICAgXHJcbiAgICBjb25zdCBpbWFnZSA9IF9yZXMuZ2V0SW1hZ2UoZGF0YU1vZGVsLnR5cGVJZCk7XHJcblxyXG4gICAgY29uc3QgSUQgPSB1bmlxdWVJZCgnTm9kZScpO1xyXG4gICAgam9pbnQuc2hhcGVzLmJhc2ljLkdlbmVyaWMuYXBwbHkoc2VsZiwgW3tcclxuICAgICAgICB0eXBlOiAnbGluZWFnZS1ncmFtLW5vZGUnLFxyXG4gICAgICAgIGlkOiBJRCxcclxuICAgICAgICBwb3NpdGlvbjogeyB4OiAwLCB5OiAwIH0sXHJcbiAgICAgICAgbWFya3VwOiBgPGcgY2xhc3M9XCJyb3RhdGFibGVcIiBjbGlwLXBhdGg9XCJ1cmwoJHsnIycgKyBJRCArICdfY2xpcFBhdGgnfSlcIj5cclxuICAgICAgICAgICAgICAgICAgICA8ZyBjbGFzcz1cInNjYWxhYmxlXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxyZWN0IGNsYXNzPVwiYm9keVwiLz5cclxuICAgICAgICAgICAgICAgICAgICA8L2c+XHJcbiAgICAgICAgICAgICAgICAgICAgPHJlY3QgY2xhc3M9XCJ0cS1sZy1ib2R5XCI+PC9yZWN0PlxyXG4gICAgICAgICAgICAgICAgICAgIDxpbWFnZSBjbGFzcz1cInNjYWxhYmxlXCIgb25lcnJvcj1cInRoaXMuc2V0QXR0cmlidXRlKCAneGxpbms6aHJlZicsICcke19yZXMuZ2V0SW1hZ2UoKX0nICk7XCIvPlxyXG4gICAgICAgICAgICAgICAgICAgIDx0ZXh0IGNsYXNzPVwibGFiZWxcIi8+XHJcbiAgICAgICAgICAgICAgICA8L2c+XHJcbiAgICAgICAgICAgICAgICA8cmVjdCBjbGFzcz1cImNsaXBSZWN0XCI+PC9yZWN0PlxyXG4gICAgICAgICAgICAgICAgPGRlZnM+XHJcbiAgICAgICAgICAgICAgICAgICAgPGNsaXBQYXRoIGlkPVwiJHtJRCArICdfY2xpcFBhdGgnfVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8cmVjdCBjbGFzcz1cImNsaXBSZWN0XCI+PC9yZWN0PlxyXG4gICAgICAgICAgICAgICAgICAgIDwvY2xpcFBhdGg+XHJcbiAgICAgICAgICAgICAgICA8L2RlZnM+YCxcclxuICAgICAgICBzaXplOiBzZWxmLnNpemUsXHJcbiAgICAgICAgYXR0cnM6IHtcclxuICAgICAgICAgICAgJ2NpcmNsZSc6IHtcclxuICAgICAgICAgICAgICAgIGZpbGw6ICd0cmFuc3BhcmVudCcsXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6ICd0cmFuc3BhcmVudCcsXHJcbiAgICAgICAgICAgICAgICByOiAxLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAnLmNsaXBSZWN0Jzoge1xyXG4gICAgICAgICAgICAgICAgcG9ydDogJ2NsaXBSZWN0UG9ydCcsXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogc2VsZi5zaXplLndpZHRoLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBzZWxmLnNpemUuaGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgZmlsbDogJ3RyYW5zcGFyZW50JyxcclxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDAsXHJcbiAgICAgICAgICAgICAgICAnc3Ryb2tlLXdpZHRoJzogMCxcclxuICAgICAgICAgICAgICAgIHJ4OiA1LFxyXG4gICAgICAgICAgICAgICAgcnk6IDUsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICcuYm9keSc6IHtcclxuICAgICAgICAgICAgICAgICdzdHJva2Utd2lkdGgnOiAwLFxyXG4gICAgICAgICAgICAgICAgZmlsbDogJ3RyYW5zcGFyZW50JyxcclxuICAgICAgICAgICAgICAgIHJ4OiA1LFxyXG4gICAgICAgICAgICAgICAgcnk6IDUsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICcubGFiZWwnOiB7XHJcbiAgICAgICAgICAgICAgICBmaWxsOiBfcmVzLmdldENvbG9yKCd0ZXh0JyksXHJcbiAgICAgICAgICAgICAgICAnZm9udC1zaXplJzogRk9OVF9TSVpFLFxyXG4gICAgICAgICAgICAgICAgJ2FsaWdubWVudC1iYXNlbGluZSc6ICdoYW5naW5nJyxcclxuICAgICAgICAgICAgICAgIHJlZjogJy5ib2R5JyxcclxuICAgICAgICAgICAgICAgIHRvb2x0aXA6IHNlbGYubW9kZWwubGFiZWwsXHJcbiAgICAgICAgICAgICAgICB5OiAwLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAnLnRxLWxnLWJvZHknOiB7XHJcbiAgICAgICAgICAgICAgICAncmVmLXgnOiAuNSxcclxuICAgICAgICAgICAgICAgICd4LWFsaWdubWVudCc6ICdtaWRkbGUnLFxyXG4gICAgICAgICAgICAgICAgJ3ktYWxpZ25tZW50JzogJ3RvcCcsXHJcbiAgICAgICAgICAgICAgICByZWY6ICcuYm9keScsXHJcbiAgICAgICAgICAgICAgICByeDogNSxcclxuICAgICAgICAgICAgICAgIHJ5OiA1LFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiBfcmVzLmdldENvbG9yKGRhdGFNb2RlbC50eXBlSWQpLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBpbWFnZToge1xyXG4gICAgICAgICAgICAgICAgJ3hsaW5rOmhyZWYnOiBpbWFnZSxcclxuICAgICAgICAgICAgICAgICdyZWYteCc6IC41LFxyXG4gICAgICAgICAgICAgICAgcmVmOiAnLmJvZHknLFxyXG4gICAgICAgICAgICAgICAgJ3gtYWxpZ25tZW50JzogJ21pZGRsZScsXHJcbiAgICAgICAgICAgICAgICAneS1hbGlnbm1lbnQnOiAndG9wJyxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgJy5sYWJlbCB0c3Bhbic6IHtcclxuICAgICAgICAgICAgICAgIGR5OiBMQUJFTF9MSU5FX0hFSUdIVCxcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgejogWl9JTkRFWEVTLk5PREUsXHJcbiAgICB9XSk7XHJcblxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuICAgIGxldCBfYmxvY2tTdWJzY3JpcHRpb24gPSBmYWxzZTtcclxuICAgIGNvbnN0IG9sZFBvc2l0aW9uID0gc2VsZi5wb3NpdGlvbjtcclxuICAgIHNlbGYucG9zaXRpb24gPSBmdW5jdGlvbiAoeCwgeSkge1xyXG4gICAgICAgIF9ibG9ja1N1YnNjcmlwdGlvbiA9IHRydWU7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gb2xkUG9zaXRpb24uY2FsbChzZWxmLCB4LCB5KTtcclxuICAgICAgICBfYmxvY2tTdWJzY3JpcHRpb24gPSBmYWxzZTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIHNlbGYub24oJ2NoYW5nZTpwb3NpdGlvbicsICgpID0+IHtcclxuICAgICAgICBpZiAoX2Jsb2NrU3Vic2NyaXB0aW9uKSByZXR1cm47XHJcbiAgICAgICAgc2VsZi5zZXRDbGlwcGluZyh1bmRlZmluZWQpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgc2VsZi5vbignY2hhbmdlOnNpemUnLCAoY2VsbCwgc2l6ZSkgPT4ge1xyXG4gICAgICAgIHNlbGYuYXR0cih7XHJcbiAgICAgICAgICAgICcuY2xpcFJlY3QnOiB7XHJcbiAgICAgICAgICAgICAgICB3aWR0aDogc2l6ZS53aWR0aCxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogc2l6ZS5oZWlnaHQsXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIHNlbGYub24oJ2NoYW5nZTpleHBhbmRlZCcsICgpID0+IHtcclxuICAgICAgICBfcmVmcmVzaFNpemUoc2VsZi5jb2xsYXBzZWRTaXplKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgICBfcmVmcmVzaFNpemUoc2VsZi5zaXplKTtcclxuXHJcbiAgICBzZWxmLnNldCgnZXhwYW5kZWQnLCBmYWxzZSk7XHJcblxyXG4gICAgc2VsZi5zZXRTaXplID0gZnVuY3Rpb24gKHNpemUpIHtcclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgIHNlbGYuY29sbGFwc2VkU2l6ZS53aWR0aCAhPT0gc2l6ZS53aWR0aCB8fFxyXG4gICAgICAgICAgICBzZWxmLmNvbGxhcHNlZFNpemUuaGVpZ2h0ICE9PSBzaXplLmhlaWdodCB8fFxyXG4gICAgICAgICAgICBzZWxmLnNpemUubWF4V2lkdGggIT09IHNpemUubWF4V2lkdGggfHxcclxuICAgICAgICAgICAgc2VsZi5zaXplLm1heEhlaWdodCAhPT0gc2l6ZS5tYXhIZWlnaHRcclxuICAgICAgICApIHtcclxuICAgICAgICAgICAgX3JlZnJlc2hTaXplKHNpemUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgc2VsZi5zZXRPcmllbnRhdGlvbiA9IGZ1bmN0aW9uIChvcmllbnRhdGlvbikge1xyXG4gICAgICAgIF9pc1ZlcnRpY2FsT3JpZW50ZWQgPSBvcmllbnRhdGlvbiA9PT0gJ3RvcC10by1ib3R0b20nIHx8IG9yaWVudGF0aW9uID09PSAnYm90dG9tLXRvLXRvcCc7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVsbHMgdXMgd2hldGhlciB0aGUgbm9kZSBpcyBjdXJyZW50bHlcclxuICAgICAqIG9uIHRoZSBncmFwaCAoaW4gdGhlIGFueSBvZiB2aWV3IGZyYW1lcykgb3Igbm90XHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVuYX1cclxuICAgICAqL1xyXG4gICAgc2VsZi5pc09uVGhlR3JhcGggPSAoKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIChzZWxmLmdyYXBoID8gdHJ1ZSA6IGZhbHNlKTtcclxuICAgIH07XHJcblxyXG4gICAgc2VsZi5jYWxjdWxhdGVTaXplID0gZnVuY3Rpb24gKHNpemUpIHtcclxuICAgICAgICBjb25zdCBjYWxjdWxhdGlvbnMgPSBfY2FsY3VsYXRlTm9kZShzaXplKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB3aWR0aDogY2FsY3VsYXRpb25zLndpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IGNhbGN1bGF0aW9ucy5oZWlnaHQsXHJcbiAgICAgICAgICAgIG1heFdpZHRoOiBjYWxjdWxhdGlvbnMubWF4V2lkdGgsXHJcbiAgICAgICAgICAgIG1heEhlaWdodDogY2FsY3VsYXRpb25zLm1heEhlaWdodFxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSGlnaGxpZ2h0cyB0aGUgTm9kZS5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gb25jZSAtIEJvb2xlYW4gZmxhZyB0byBwcm90ZWN0IGNvZGUgZnJvbSByZWN1cnNpb24gKG9wdGlvbmFsKVxyXG4gICAgICogQG1lbWJlcm9mIE5vZGVcclxuICAgICAqIEBtZXRob2RcclxuICAgICovXHJcbiAgICBzZWxmLnNlbGVjdCA9IGZ1bmN0aW9uIChvbmNlKSB7XHJcbiAgICAgICAgc2VsZi50ZXJtaW5hdGlvbk5vZGVzLmZvckVhY2godG4gPT4gdG4uc2VsZWN0KHRydWUpKTtcclxuICAgICAgICBpZiAoIW9uY2UpIHNlbGYuYXNwZWN0cy5mb3JFYWNoKGEgPT4gYS5zZWxlY3QodHJ1ZSkpO1xyXG4gICAgICAgIGlmIChzZWxmLmdldCgnYmx1cmVkJykpIHNlbGYudW5ibHVyZSgpO1xyXG4gICAgICAgIGlmIChzZWxmLmdldCgnaGlkZGVuJykpIHNlbGYuc2hvdygpO1xyXG4gICAgICAgIHNlbGYucHJvcCh7IHo6IFpfSU5ERVhFUy5TRUxFQ1RFRF9FTEVNRU5UIH0pO1xyXG4gICAgICAgIHNlbGYuc2V0KCdoaWdobGlnaHRlZCcsIHRydWUpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgaGlnaGxpZ2h0aW5nIGZyb20gdGhlIE5vZGUuXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9uY2UgLSBCb29sZWFuIGZsYWcgdG8gcHJvdGVjdCBjb2RlIGZyb20gcmVjdXJzaW9uIChvcHRpb25hbClcclxuICAgICAqIEBtZW1iZXJvZiBOb2RlXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAqL1xyXG4gICAgc2VsZi51bnNlbGVjdCA9IGZ1bmN0aW9uIChvbmNlKSB7XHJcbiAgICAgICAgc2VsZi50ZXJtaW5hdGlvbk5vZGVzLmZvckVhY2godG4gPT4gdG4udW5zZWxlY3QodHJ1ZSkpO1xyXG4gICAgICAgIGlmICghb25jZSkgc2VsZi5hc3BlY3RzLmZvckVhY2goYSA9PiBhLnVuc2VsZWN0KHRydWUpKTtcclxuICAgICAgICBzZWxmLnByb3AoeyB6OiBaX0lOREVYRVMuTk9ERSB9KTtcclxuICAgICAgICBzZWxmLnNldCgnaGlnaGxpZ2h0ZWQnLCBmYWxzZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQmx1cnMgdGhlIE5vZGUuXHJcbiAgICAgKiBAbWVtYmVyb2YgTm9kZVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgKi9cclxuICAgIHNlbGYuYmx1cmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHNlbGYuZ2V0KCdoaWdobGlnaHRlZCcpKSByZXR1cm47XHJcbiAgICAgICAgc2VsZi50ZXJtaW5hdGlvbk5vZGVzLmZvckVhY2godG4gPT4gdG4uYmx1cmUodHJ1ZSkpO1xyXG4gICAgICAgIHNlbGYucHJvcCh7IHo6IFpfSU5ERVhFUy5CTFVSRURfTk9ERSB9KTtcclxuICAgICAgICBzZWxmLnNldCgnYmx1cmVkJywgdHJ1ZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBibHVyIGZyb20gdGhlIE5vZGUuXHJcbiAgICAgKiBAbWVtYmVyb2YgTm9kZVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgKi9cclxuICAgIHNlbGYudW5ibHVyZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBzZWxmLnRlcm1pbmF0aW9uTm9kZXMuZm9yRWFjaCh0biA9PiB0bi51bmJsdXJlKHRydWUpKTtcclxuICAgICAgICBzZWxmLnByb3AoeyB6OiBaX0lOREVYRVMuTk9ERSB9KTtcclxuICAgICAgICBzZWxmLnNldCgnYmx1cmVkJywgZmFsc2UpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEhpZGVzIHRoZSBOb2RlLlxyXG4gICAgICogQG1lbWJlcm9mIE5vZGVcclxuICAgICAqIEBtZXRob2RcclxuICAgICovXHJcbiAgICBzZWxmLmhpZGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgc2VsZi50ZXJtaW5hdGlvbk5vZGVzLmZvckVhY2godG4gPT4gdG4uaGlkZSh0cnVlKSk7XHJcbiAgICAgICAgc2VsZi5zZXQoJ2hpZGRlbicsIHRydWUpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNob3dzIHRoZSBOb2RlLlxyXG4gICAgICogQG1lbWJlcm9mIE5vZGVcclxuICAgICAqIEBtZXRob2RcclxuICAgICovXHJcbiAgICBzZWxmLnNob3cgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgc2VsZi50ZXJtaW5hdGlvbk5vZGVzLmZvckVhY2godG4gPT4gdG4uc2hvdyh0cnVlKSk7XHJcbiAgICAgICAgc2VsZi5zZXQoJ2hpZGRlbicsIGZhbHNlKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWZyZXNoZXMgaGlnaGxpZ2h0ZXJzIG9mIHRoZSB2aWV3IG9mIHRoaXMgZWxlbWVudC5cclxuICAgICAqIEBtZW1iZXJvZiBMaW5rXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAqL1xyXG4gICAgc2VsZi5yZWZyZXNoSGlnaGxpZ2h0aW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHNlbGYudHJpZ2dlcigncmVmcmVzaC1oaWdobGlnaHRpbmcnLCBzZWxmKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIG9mZnNldCBhbmQgc2l6ZSBvZiBjbGlwcGluZyByZWN0YW5nbGUuXHJcbiAgICAgKiBAcGFyYW0ge1BvaW50fSBwb2ludCAtIE9mZnNldCBvZiB0aGUgY2xpcHBpbmcgcmVjdGFuZ2xlXHJcbiAgICAgKiBAbWVtYmVyb2YgTm9kZVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgKi9cclxuICAgIHNlbGYuc2V0Q2xpcHBpbmcgPSBmdW5jdGlvbiAocG9pbnQpIHtcclxuICAgICAgICBwb2ludCA9IHBvaW50IHx8IHsgeDogMCwgeTogMCB9O1xyXG5cclxuICAgICAgICBjb25zdCB4ID0gKHBvaW50LnggPiAwID8gcG9pbnQueCA6IDApO1xyXG4gICAgICAgIGNvbnN0IHkgPSAocG9pbnQueSA+IDAgPyBwb2ludC55IDogMCk7XHJcbiAgICAgICAgY29uc3Qgd2lkdGggPSBzZWxmLnNpemUud2lkdGggLSBNYXRoLmFicyhwb2ludC54KTtcclxuICAgICAgICBjb25zdCBoZWlnaHQgPSBzZWxmLnNpemUuaGVpZ2h0IC0gTWF0aC5hYnMocG9pbnQueSk7XHJcblxyXG4gICAgICAgIHNlbGYuYXR0cih7XHJcbiAgICAgICAgICAgICcuY2xpcFJlY3QnOiB7XHJcbiAgICAgICAgICAgICAgICB4OiB4LFxyXG4gICAgICAgICAgICAgICAgeTogeSxcclxuICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCA+IDAgPyB3aWR0aCA6IDAsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCA+IDAgPyBoZWlnaHQgOiAwLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBfcmVmcmVzaFNpemUgKHNpemUpIHtcclxuICAgICAgICBzZWxmLmNvbGxhcHNlZFNpemUgPSBzaXplO1xyXG5cclxuICAgICAgICBjb25zdCBjYWxjdWxhdGlvbnMgPSBfY2FsY3VsYXRlTm9kZShzaXplKTtcclxuICAgICAgICBzZWxmLnNpemUgPSB7XHJcbiAgICAgICAgICAgIHdpZHRoOiBjYWxjdWxhdGlvbnMud2lkdGgsXHJcbiAgICAgICAgICAgIGhlaWdodDogY2FsY3VsYXRpb25zLmhlaWdodCxcclxuICAgICAgICAgICAgbWF4V2lkdGg6IGNhbGN1bGF0aW9ucy5tYXhXaWR0aCxcclxuICAgICAgICAgICAgbWF4SGVpZ2h0OiBjYWxjdWxhdGlvbnMubWF4SGVpZ2h0XHJcbiAgICAgICAgfTtcclxuICAgICAgICBcclxuICAgICAgICBjb25zdCBzY2FsZSA9IGNhbGN1bGF0aW9ucy5zY2FsZTtcclxuICAgICAgICBjb25zdCBib2R5UGFkZGluZyA9IEJPRFlfUEFERElORyAqIHNjYWxlO1xyXG4gICAgICAgIGNvbnN0IHRvcEJvdHRvbVBhZGRpbmcgPSBMQUJFTF9UT1BfQk9UVE9NX1BBRERJTkcgKiBzY2FsZTtcclxuICAgICAgICBjb25zdCBsYWJlbExpbmVIZWlnaHQgPSBMQUJFTF9MSU5FX0hFSUdIVCAqIHNjYWxlO1xyXG5cclxuICAgICAgICBzZWxmLmF0dHIoe1xyXG4gICAgICAgICAgICAnLnRxLWxnLWJvZHknOiB7XHJcbiAgICAgICAgICAgICAgICB3aWR0aDogY2FsY3VsYXRpb25zLnJlY3RXaWR0aCxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogY2FsY3VsYXRpb25zLnJlY3RIZWlnaHQsXHJcbiAgICAgICAgICAgICAgICAncmVmLXknOiBib2R5UGFkZGluZyxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaW1hZ2U6IHtcclxuICAgICAgICAgICAgICAgIHdpZHRoOiBNYXRoLm1heCgwLCBjYWxjdWxhdGlvbnMucmVjdFdpZHRoIC0gSU1HX1BBRERJTkcgKiAyKSxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogTWF0aC5tYXgoMCwgY2FsY3VsYXRpb25zLnJlY3RIZWlnaHQgLSBJTUdfUEFERElORyAqIDIpLFxyXG4gICAgICAgICAgICAgICAgJ3JlZi15JzogYm9keVBhZGRpbmcgKyBJTUdfUEFERElORyxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgJy5sYWJlbCc6IHtcclxuICAgICAgICAgICAgICAgIHRleHQ6IGNhbGN1bGF0aW9ucy5sYWJlbCxcclxuICAgICAgICAgICAgICAgICdyZWYteSc6IGJvZHlQYWRkaW5nICtcclxuICAgICAgICAgICAgICAgICAgICB0b3BCb3R0b21QYWRkaW5nICtcclxuICAgICAgICAgICAgICAgICAgICBjYWxjdWxhdGlvbnMucmVjdEhlaWdodCArXHJcbiAgICAgICAgICAgICAgICAgICAgRk9OVF9TSVpFICogc2NhbGUgLVxyXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsTGluZUhlaWdodCxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgJy5sYWJlbCB0c3Bhbic6IHtcclxuICAgICAgICAgICAgICAgICdmb250LXNpemUnOiBGT05UX1NJWkUgKiBzY2FsZSxcclxuICAgICAgICAgICAgICAgIGR5OiBsYWJlbExpbmVIZWlnaHQsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHNlbGYucmVzaXplKHNlbGYuc2l6ZS53aWR0aCwgc2VsZi5zaXplLmhlaWdodCk7XHJcbiAgICAgICAgc2VsZi5zZXQoJ3Nob3J0LWxhYmVsJywgY2FsY3VsYXRpb25zLnNob3J0TGFiZWwpO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBfY2F0Y2hlZFJlc3VsdCA9IG51bGw7XHJcbiAgICBmdW5jdGlvbiBfY2FsY3VsYXRlTm9kZSAoc2l6ZSkge1xyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgICAgX2NhdGNoZWRSZXN1bHQgJiZcclxuICAgICAgICAgICAgX2NhdGNoZWRSZXN1bHQuaW5TaXplLndpZHRoID09PSBzaXplLndpZHRoICYmXHJcbiAgICAgICAgICAgIF9jYXRjaGVkUmVzdWx0LmluU2l6ZS5oZWlnaHQgPT09IHNpemUuaGVpZ2h0ICYmXHJcbiAgICAgICAgICAgIF9jYXRjaGVkUmVzdWx0LmluU2l6ZS5tYXhXaWR0aCA9PT0gc2l6ZS5tYXhXaWR0aCAmJlxyXG4gICAgICAgICAgICBfY2F0Y2hlZFJlc3VsdC5pblNpemUubWF4SGVpZ2h0ID09PSBzaXplLm1heEhlaWdodCAmJlxyXG4gICAgICAgICAgICBfY2F0Y2hlZFJlc3VsdC5leHBhbmRlZCA9PT0gc2VsZi5nZXQoJ2V4cGFuZGVkJylcclxuICAgICAgICApIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9jYXRjaGVkUmVzdWx0Lm91dFNpemU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgd2lkdGg7XHJcbiAgICAgICAgbGV0IGhlaWdodDtcclxuICAgICAgICBpZiAoIXNlbGYuZ2V0KCdleHBhbmRlZCcpKSB7XHJcbiAgICAgICAgICAgIHdpZHRoID0gc2l6ZS53aWR0aDtcclxuICAgICAgICAgICAgaGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgd2lkdGggPSBNYXRoLm1pbihzaXplLm1heFdpZHRoLCBzaXplLndpZHRoICogRVhQQU5ERURfTk9ERV9HUk9XSU5HKTtcclxuICAgICAgICAgICAgaGVpZ2h0ID0gTWF0aC5taW4oc2l6ZS5tYXhIZWlnaHQsIHNpemUuaGVpZ2h0ICogRVhQQU5ERURfTk9ERV9HUk9XSU5HKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHhTY2FsZSA9IHNpemUud2lkdGggLyBwYXJhbWV0ZXJzLmVsZW1lbnRTaXplLndpZHRoOyBcclxuICAgICAgICBjb25zdCB5U2NhbGUgPSBzaXplLmhlaWdodCAvIHBhcmFtZXRlcnMuZWxlbWVudFNpemUuaGVpZ2h0OyBcclxuICAgICAgICBjb25zdCBzY2FsZSA9IE1hdGgubWluKHhTY2FsZSwgeVNjYWxlKTtcclxuICAgICAgICBjb25zdCBib2R5UGFkZGluZyA9IEJPRFlfUEFERElORyAqIHNjYWxlO1xyXG4gICAgICAgIGNvbnN0IGxhYmVsTGluZUhlaWdodCA9IExBQkVMX0xJTkVfSEVJR0hUICogc2NhbGU7XHJcblxyXG4gICAgICAgIGxldCBjYWxjdWxhdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcclxuICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXHJcbiAgICAgICAgICAgIG1heFdpZHRoOiBzaXplLm1heFdpZHRoLFxyXG4gICAgICAgICAgICBtYXhIZWlnaHQ6IHNpemUubWF4SGVpZ2h0LFxyXG4gICAgICAgICAgICByZWN0V2lkdGg6IHdpZHRoIC0gYm9keVBhZGRpbmcgKiAyLFxyXG4gICAgICAgICAgICByZWN0SGVpZ2h0OiBoZWlnaHQgLSBib2R5UGFkZGluZyAqIDIsXHJcbiAgICAgICAgICAgIHNjYWxlOiBzY2FsZSxcclxuICAgICAgICAgICAgc2hvcnRMYWJlbDogZmFsc2UsXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgaWYgKHNlbGYubW9kZWwubGFiZWwpIHtcclxuICAgICAgICAgICAgY2FsY3VsYXRpb25zLmhlaWdodCAtPSBib2R5UGFkZGluZztcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGZvbnRTaXplID0gRk9OVF9TSVpFICogc2NhbGU7XHJcbiAgICAgICAgICAgIGNvbnN0IGxlZnRSaWdodFBhZGRpbmcgPSBMQUJFTF9MRUZUX1JJR0hUX1BBRERJTkcgKiBzY2FsZSAqIDI7XHJcbiAgICAgICAgICAgIGNvbnN0IHRvcEJvdHRvbVBhZGRpbmcgPSBMQUJFTF9UT1BfQk9UVE9NX1BBRERJTkcgKiBzY2FsZSAqIDI7XHJcblxyXG4gICAgICAgICAgICBsZXQgbGFiZWwgPSBfYnJlYWtUZXh0QnlMaW5lcyhcclxuICAgICAgICAgICAgICAgIHNlbGYubW9kZWwubGFiZWwsXHJcbiAgICAgICAgICAgICAgICB3aWR0aCAtIGxlZnRSaWdodFBhZGRpbmcsXHJcbiAgICAgICAgICAgICAgICBmb250U2l6ZVxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgbGV0IGxhYmVsSGVpZ2h0ID0gMDtcclxuICAgICAgICAgICAgbGV0IHN1YnN0cmluZ3MgPSBsYWJlbC5zcGxpdCgnXFxuJyk7XHJcblxyXG4gICAgICAgICAgICBpZiAoc3Vic3RyaW5ncy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgbWF4Um93Q291bnQgPSAoX2lzVmVydGljYWxPcmllbnRlZCA/IDIgOiAzKSArIChzZWxmLmdldCgnZXhwYW5kZWQnKSA/IDEgOiAwKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoc3Vic3RyaW5ncy5sZW5ndGggPiBtYXhSb3dDb3VudCkgY2FsY3VsYXRpb25zLnNob3J0TGFiZWwgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgICAgIHN1YnN0cmluZ3MgPSBzdWJzdHJpbmdzLnNsaWNlKDAsIG1heFJvd0NvdW50KTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgaWYgKF9pc1ZlcnRpY2FsT3JpZW50ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaW5hbExhYmVsID0gc3Vic3RyaW5ncy5qb2luKCcgJykgKyAoY2FsY3VsYXRpb25zLnNob3J0TGFiZWwgPyAnLi4uJyA6ICcnKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsYWJlbFdpZHRoID0gX2dldFRleHRXaWR0aChmaW5hbExhYmVsLCBmb250U2l6ZSArICdweCBzYW5zLXNlcmlmJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsY3VsYXRpb25zLndpZHRoID0gbGFiZWxXaWR0aCArIGxlZnRSaWdodFBhZGRpbmcgKiBzdWJzdHJpbmdzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICBjYWxjdWxhdGlvbnMubGFiZWwgPSBmaW5hbExhYmVsO1xyXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsSGVpZ2h0ID0gZm9udFNpemUgKyB0b3BCb3R0b21QYWRkaW5nO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBXZSB1c2UgZHkgcHJvcGVydHkgZm9yIGVhY2ggbGluZSB0aGF0J3Mgd2h5IGZvbnQtc2l6ZSBnb2VzIG9ubHkgb25lIHRpbWUgaW50byBhY291bnQuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQmVjYXVzZSBkeCBpcyBkaXN0YW5jZSBiZXR3ZWVuIHRvcCBsaW5lcyBvZiBlYWNoIHRleHQgbGluZS4gQW5kIGZvciBhIGZ1bGwgdGV4dCBoZWlnaHQgd2UgYWRkIGZvbnQgc2l6ZSBvZiBsdXN0IGxpbmUuXHJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxIZWlnaHQgPSAoZm9udFNpemUpICsgdG9wQm90dG9tUGFkZGluZyArIChzdWJzdHJpbmdzLmxlbmd0aCAtIDEpICogKGxhYmVsTGluZUhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsY3VsYXRpb25zLmxhYmVsID0gc3Vic3RyaW5ncy5qb2luKCdcXG4nKSArIChjYWxjdWxhdGlvbnMuc2hvcnRMYWJlbCA/ICcuLi4nIDogJycpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbGFiZWxIZWlnaHQgPSAoZm9udFNpemUpICsgdG9wQm90dG9tUGFkZGluZztcclxuICAgICAgICAgICAgICAgIGNhbGN1bGF0aW9ucy5sYWJlbCA9IHNlbGYubW9kZWwubGFiZWw7XHJcbiAgICAgICAgICAgIH0gXHJcblxyXG4gICAgICAgICAgICBjYWxjdWxhdGlvbnMuaGVpZ2h0ICs9IGxhYmVsSGVpZ2h0O1xyXG4gICAgICAgICAgICBjYWxjdWxhdGlvbnMubGFiZWxIZWlnaHQgPSBsYWJlbEhlaWdodDtcclxuICAgICAgICAgICAgY2FsY3VsYXRpb25zLmV4cGFuZGVkID0gc2VsZi5nZXQoJ2V4cGFuZGVkJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9jYXRjaGVkUmVzdWx0ID0ge1xyXG4gICAgICAgICAgICBpblNpemU6IHNpemUsXHJcbiAgICAgICAgICAgIG91dFNpemU6IGNhbGN1bGF0aW9ucyxcclxuICAgICAgICAgICAgZXhwYW5kZWQ6IGNhbGN1bGF0aW9ucy5leHBhbmRlZCxcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICByZXR1cm4gY2FsY3VsYXRpb25zO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIF9icmVha1RleHRCeUxpbmVzIChcclxuICAgICAgICBsYWJlbCwgd2lkdGgsIGZvbnRTaXplLFxyXG4gICAgKSB7XHJcbiAgICAgICAgY29uc3QgYnJva2VuVGV4dCA9IGpvaW50LnV0aWwuYnJlYWtUZXh0KGxhYmVsLCB7XHJcbiAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcclxuICAgICAgICB9LCB7ICdmb250LXNpemUnOiBmb250U2l6ZSB9KTtcclxuXHJcbiAgICAgICAgY29uc3QgbGluZXMgPSBicm9rZW5UZXh0LnNwbGl0KCdcXG4nKTtcclxuXHJcbiAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgY29uc3QgbGFzdENoaWxkID0gbGluZXNbbGluZXMubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgIGNvbnN0IE1JTl9DSEFSQUNURVJfTlVNQkVSID0gNDtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmIChsYXN0Q2hpbGQubGVuZ3RoIDwgTUlOX0NIQVJBQ1RFUl9OVU1CRVIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRpZmYgPSBNSU5fQ0hBUkFDVEVSX05VTUJFUiAtIGxhc3RDaGlsZC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0aHJlc2hvbGQgPSBsaW5lcy5sZW5ndGggLSAoZGlmZiArIDEpO1xyXG4gICAgICAgICAgICAgICAgLy8gbWF4IGVycm9yIGlzIDMgZXh0cmEgbGV0dGVycywgc28gSSBob3BlIGl0J3MgT0suXHJcbiAgICAgICAgICAgICAgICBjb25zdCBudW1iZXJPZlN0ZWFsZWROb2RlcyA9IE1hdGgucm91bmQoZGlmZiAvIE1hdGgubWluKGRpZmYsIGxpbmVzLmxlbmd0aCAtIDEpKTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgbGV0IHByZXZSZXN0ID0gJyc7XHJcbiAgICAgICAgICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0xpbmVzID0gbGluZXMubWFwKChsaW5lLCBpbmRleCwgYXJyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID49IHRocmVzaG9sZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0xhc3RMaW5lID0gaW5kZXggPT09IChhcnIubGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZ1bGxMaW5lID0gcHJldlJlc3QgKyBsaW5lO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgKz0gbnVtYmVyT2ZTdGVhbGVkTm9kZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0xhc3RMaW5lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVsbExpbmU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2UmVzdCA9IGZ1bGxMaW5lLnN1YnN0cmluZyhmdWxsTGluZS5sZW5ndGggLSBvZmZzZXQsIGZ1bGxMaW5lLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVsbExpbmUuc3Vic3RyaW5nKDAsIGZ1bGxMaW5lLmxlbmd0aCAtIG9mZnNldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGluZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3TGluZXMuam9pbignXFxuJyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYnJva2VuVGV4dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBsYWJlbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogVXBkYXRlIHNpemUgb2YgZWxlbWVudC4gVGFrZXMgY29sbGFwc2VkIHNpemUsXHJcbiAgICAgKiBhbmQgaWYgZWxlbWVudCBhcmUgZXhwYW5kZWQgdHJ5aW5nIHRvIHNldCBhIHR3aXNlIHNpemUuXHJcbiAgICAgKiBAcGFyYW0ge1NpemV9IHNpemUgXHJcbiAgICAqL1xyXG4gICAgXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZm9udCBcclxuICAgICovXHJcbiAgICBmdW5jdGlvbiBfZ2V0VGV4dFdpZHRoICh0ZXh0LCBmb250KSB7XHJcbiAgICAgICAgY29uc3QgY2FudmFzID0gX2dldFRleHRXaWR0aC5jYW52YXMgfHwgKF9nZXRUZXh0V2lkdGguY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnQ0FOVkFTJykpO1xyXG4gICAgICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICAgICAgY29udGV4dC5mb250ID0gZm9udDtcclxuICAgICAgICB2YXIgbWV0cmljcyA9IGNvbnRleHQubWVhc3VyZVRleHQodGV4dCk7XHJcbiAgICAgICAgcmV0dXJuIG1ldHJpY3Mud2lkdGg7XHJcbiAgICB9XHJcbn1cclxuXHJcbk5vZGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShqb2ludC5zaGFwZXMuZGV2cy5Nb2RlbC5wcm90b3R5cGUpO1xyXG4iLCJpbXBvcnQgKiBhcyBqb2ludCBmcm9tICdyYXBwaWQnO1xyXG5pbXBvcnQgeyBSZXNvdXJjZVByb3ZpZGVyIH0gZnJvbSAnLi4vLi4vZGF0YS9yZXNvdXJjZVByb3ZpZGVyJztcclxuaW1wb3J0IHsgWl9JTkRFWEVTIH0gZnJvbSAnLi9lbGVtZW50cyc7XHJcblxyXG4vKipcclxuICogQHByaXZhdGVcclxuICogVGVybWluYXRpb25MaW5rT3B0aW9ucyAtIG9wdGlvbnMgZm9yIFRlcm1pbmF0aW9uTGluayBvYmplY3RcclxuICogQHR5cGVkZWYge09iamVjdH0gVGVybWluYXRpb25MaW5rT3B0aW9uc1xyXG4gKiBAcHJvcGVydHkge0xpbmt9IGxpbmsgLSBPcmlnaW5hbCBsaW5rXHJcbiAqIEBwcm9wZXJ0eSB7Tm9kZX0gdGFyZ2V0IC0gVGFyZ2V0IE5vZGVcclxuICogQHByb3BlcnR5IHtOb2RlfSBzb3VyY2UgLSBTb3VyY2UgTm9kZVxyXG4qL1xyXG5cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqIFNpbXBsZUxpbmtNb2RlbCAtIGRhdGEgbW9kZWwgb2YgYSBUZXJtaW5hdGlvbkxpbmsgb2JqZWN0XHJcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFNpbXBsZUxpbmtNb2RlbCAtIERhdGEgbW9kZWxcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHRhcmdldCAtIFRhcmdldCBOb2RlIGlkXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzb3VyY2UgLSBTb3VyY2UgTm9kZSBpZFxyXG4qL1xyXG5cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqIFRoZSBncmFwaCBMaW5rIGJhc2VkIG9uIGpvaW50LmRpYS5MaW5rLlxyXG4gKiBAY2xhc3NcclxuICogQGF1Z21lbnRzIGpvaW50LmRpYS5MaW5rXHJcbiAqIFxyXG4gKiBAcGFyYW0ge1Rlcm1pbmF0aW9uTGlua09wdGlvbnN9IG9wdGlvbnMgLSBvcHRpb25zIGZvciBUZXJtaW5hdGlvbkxpbmsgb2JqZWN0XHJcbiAqIEBwYXJhbSB7UGFyYW1ldGVyc30gcGFyYW1ldGVycyAtIHRoZSBzZXQgb2YgcGFyYW1ldGVyc1xyXG4gKiBcclxuICogQHByb3BlcnR5IHtMaW5rfSBvcmlnaW5hbExpbmsgLSBPcmlnaW5hbCBMaW5rIC0gdGhlIGxpbmsgdG8gYSBub2RlIHdoaWNoIGlzIG91dCBvZiB0aGUgVmlld0ZybWFlXHJcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaGlnaGxpZ2h0ZWQgLSBUZWxscyB3aGV0ZXIgaGlnaGxpZ2h0ZWQgbGluayBvciBub3QgKHVzZSBtZXRob2QgZ2V0IHRvIGdldCB0aGlzIHByb3BlcnR5LCBlLmcuIGxpbmsuZ2V0KCdoaWdobGlnaHRlZCcpKVxyXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGJsdXJlZCAtIFRlbGxzIHdoZXRlciBibHVyZWQgbGluayBvciBub3QgKHVzZSBtZXRob2QgZ2V0IHRvIGdldCB0aGlzIHByb3BlcnR5LCBlLmcuIGxpbmsuZ2V0KCdibHVyZWQnKSlcclxuICogQHByb3BlcnR5IHtTaW1wbGVMaW5rTW9kZWx9IG1vZGVsIC0gRGF0YSBtb2RlbCBcclxuKi9cclxuZXhwb3J0IGZ1bmN0aW9uIFRlcm1pbmF0aW9uTGluayAob3B0aW9ucywgcGFyYW1ldGVycykge1xyXG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XHJcbiAgICBjb25zdCBfcmVzID0gbmV3IFJlc291cmNlUHJvdmlkZXIocGFyYW1ldGVycyk7XHJcblxyXG4gICAgc2VsZi5vcmlnaW5hbExpbmsgPSBvcHRpb25zLmxpbms7XHJcbiAgICBzZWxmLmhpZ2hsaWdodGVkID0gZmFsc2U7XHJcbiAgICBzZWxmLmJsdXJlZCA9IGZhbHNlO1xyXG4gICAgc2VsZi5vcmlnaW5hbExpbmsudGVybWluYXRpb25MaW5rcy5wdXNoKHNlbGYpO1xyXG5cclxuICAgIGNvbnN0IHNvdXJjZSA9IHsgaWQ6IG9wdGlvbnMuc291cmNlLmlkLCBwb3J0OiAnY2xpcFJlY3RQb3J0JyB9O1xyXG4gICAgY29uc3QgdGFyZ2V0ID0geyBpZDogb3B0aW9ucy50YXJnZXQuaWQsIHBvcnQ6ICdjbGlwUmVjdFBvcnQnIH07XHJcblxyXG4gICAgY29uc3QgbGlua0NvbG9yID0gX3Jlcy5nZXRDb2xvcigndGVybWluYXRpb25MaW5rJyk7XHJcblxyXG4gICAgam9pbnQuZGlhLkxpbmsuYXBwbHkoc2VsZiwgW3tcclxuICAgICAgICB0eXBlOiAndGVybWluYXRpb24tbGluaycsXHJcbiAgICAgICAgc291cmNlOiBzb3VyY2UsXHJcbiAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXHJcbiAgICAgICAgejogWl9JTkRFWEVTLlRFUk1JTkFUSU9OX0VMRU1FTlQsXHJcbiAgICAgICAgYXR0cnM6IHtcclxuICAgICAgICAgICAgJy5jb25uZWN0aW9uJzoge1xyXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiBsaW5rQ29sb3IsXHJcbiAgICAgICAgICAgICAgICAnc3Ryb2tlLXdpZHRoJzogcGFyYW1ldGVycy5saW5rVGhpY2tuZXNzICogKDEgKyAoc2VsZi5vcmlnaW5hbExpbmsubW9kZWwudGhpY2tuZXNzIHx8IDApKSxcclxuICAgICAgICAgICAgICAgICdzdHJva2UtZGFzaGFycmF5JzogJzUsNScsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICcubWFya2VyLXNvdXJjZSc6IHtcclxuICAgICAgICAgICAgICAgIGZpbGw6IGxpbmtDb2xvcixcclxuICAgICAgICAgICAgICAgIHN0cm9rZTogbGlua0NvbG9yLFxyXG4gICAgICAgICAgICAgICAgJ3N0cm9rZS13aWR0aCc6IHBhcmFtZXRlcnMubGlua1RoaWNrbmVzcyAqICgxICsgKHNlbGYub3JpZ2luYWxMaW5rLm1vZGVsLnRoaWNrbmVzcyB8fCAwKSksXHJcbiAgICAgICAgICAgICAgICBkOiAnTTAsM2EzLDMgMCAxLDAgNiwwYTMsMyAwIDEsMCAtNiwwJyxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgJy5tYXJrZXItdGFyZ2V0Jzoge1xyXG4gICAgICAgICAgICAgICAgZmlsbDogbGlua0NvbG9yLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiBsaW5rQ29sb3IsXHJcbiAgICAgICAgICAgICAgICAnc3Ryb2tlLXdpZHRoJzogcGFyYW1ldGVycy5saW5rVGhpY2tuZXNzICogKDEgKyAoc2VsZi5vcmlnaW5hbExpbmsubW9kZWwudGhpY2tuZXNzIHx8IDApKSxcclxuICAgICAgICAgICAgICAgIGQ6ICdNIDEwIDAgTCAwIDUgTCAxMCAxMCB6JyxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNvbm5lY3Rvcjoge25hbWU6ICdyb3VuZGVkJyB9LFxyXG4gICAgfV0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSGlnaGxpZ2h0cyB0aGUgVGVybWluYXRpb25MaW5rLlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBvbmNlIC0gQm9vbGVhbiBmbGFnIHRvIHByb3RlY3QgY29kZSBmcm9tIHJlY3Vyc2lvbiAob3B0aW9uYWwpXHJcbiAgICAgKiBAbWVtYmVyb2YgVGVybWluYXRpb25MaW5rXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAqL1xyXG4gICAgc2VsZi5zZWxlY3QgPSBmdW5jdGlvbiAob25jZSkge1xyXG4gICAgICAgIGlmICghb25jZSkgc2VsZi5vcmlnaW5hbExpbmsuc2VsZWN0KHRydWUpO1xyXG4gICAgICAgIGlmIChzZWxmLmdldCgnYmx1cmVkJykpIHNlbGYudW5ibHVyZSgpO1xyXG4gICAgICAgIGlmIChzZWxmLmdldCgnaGlkZGVuJykpIHNlbGYuc2hvdygpO1xyXG4gICAgICAgIHNlbGYucHJvcCh7IHo6IFpfSU5ERVhFUy5TRUxFQ1RFRF9FTEVNRU5UIH0pO1xyXG4gICAgICAgIHNlbGYuc2V0KCdoaWdobGlnaHRlZCcsIHRydWUpO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGhpZ2hsaWdodGluZyBmcm9tIHRoZSBUZXJtaW5hdGlvbkxpbmsuXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9uY2UgLSBCb29sZWFuIGZsYWcgdG8gcHJvdGVjdCBjb2RlIGZyb20gcmVjdXJzaW9uIChvcHRpb25hbClcclxuICAgICAqIEBtZW1iZXJvZiBUZXJtaW5hdGlvbkxpbmtcclxuICAgICAqIEBtZXRob2RcclxuICAgICovXHJcbiAgICBzZWxmLnVuc2VsZWN0ID0gZnVuY3Rpb24gKG9uY2UpIHtcclxuICAgICAgICBpZiAoIW9uY2UpIHNlbGYub3JpZ2luYWxMaW5rLnVuc2VsZWN0KHRydWUpO1xyXG4gICAgICAgIHNlbGYucHJvcCh7IHo6IFpfSU5ERVhFUy5URVJNSU5BVElPTl9FTEVNRU5UIH0pO1xyXG4gICAgICAgIHNlbGYuc2V0KCdoaWdobGlnaHRlZCcsIGZhbHNlKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBCbHVycyB0aGUgVGVybWluYXRpb25MaW5rLlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBvbmNlIC0gQm9vbGVhbiBmbGFnIHRvIHByb3RlY3QgY29kZSBmcm9tIHJlY3Vyc2lvbiAob3B0aW9uYWwpXHJcbiAgICAgKiBAbWVtYmVyb2YgVGVybWluYXRpb25MaW5rXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAqL1xyXG4gICAgc2VsZi5ibHVyZSA9IGZ1bmN0aW9uIChvbmNlKSB7XHJcbiAgICAgICAgaWYgKHNlbGYuZ2V0KCdoaWdobGlnaHRlZCcpKSByZXR1cm47XHJcbiAgICAgICAgaWYgKCFvbmNlKSBzZWxmLm9yaWdpbmFsTGluay5ibHVyZSh0cnVlKTtcclxuICAgICAgICBzZWxmLnByb3AoeyB6OiBaX0lOREVYRVMuQkxVUkVEX0xJTksgfSk7XHJcbiAgICAgICAgc2VsZi5zZXQoJ2JsdXJlZCcsIHRydWUpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYmx1ciBmcm9tIHRoZSBUZXJtaW5hdGlvbkxpbmsuXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9uY2UgLSBCb29sZWFuIGZsYWcgdG8gcHJvdGVjdCBjb2RlIGZyb20gcmVjdXJzaW9uIChvcHRpb25hbClcclxuICAgICAqIEBtZW1iZXJvZiBUZXJtaW5hdGlvbkxpbmtcclxuICAgICAqIEBtZXRob2RcclxuICAgICovXHJcbiAgICBzZWxmLnVuYmx1cmUgPSBmdW5jdGlvbiAob25jZSkge1xyXG4gICAgICAgIGlmICghb25jZSkgc2VsZi5vcmlnaW5hbExpbmsudW5ibHVyZSh0cnVlKTtcclxuICAgICAgICBzZWxmLnByb3AoeyB6OiBaX0lOREVYRVMuVEVSTUlOQVRJT05fRUxFTUVOVCB9KTtcclxuICAgICAgICBzZWxmLnNldCgnYmx1cmVkJywgZmFsc2UpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEhpZGVzIHRoZSBUZXJtaW5hdGlvbkxpbmsuXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9uY2UgLSBCb29sZWFuIGZsYWcgdG8gcHJvdGVjdCBjb2RlIGZyb20gcmVjdXJzaW9uIChvcHRpb25hbClcclxuICAgICAqIEBtZW1iZXJvZiBUZXJtaW5hdGlvbkxpbmtcclxuICAgICAqIEBtZXRob2RcclxuICAgICovXHJcbiAgICBzZWxmLmhpZGUgPSBmdW5jdGlvbiAob25jZSkge1xyXG4gICAgICAgIGlmICghb25jZSkgc2VsZi5vcmlnaW5hbExpbmsuaGlkZSh0cnVlKTtcclxuICAgICAgICBzZWxmLnNldCgnaGlkZGVuJywgdHJ1ZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2hvd3MgdGhlIFRlcm1pbmF0aW9uTGluay5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gb25jZSAtIEJvb2xlYW4gZmxhZyB0byBwcm90ZWN0IGNvZGUgZnJvbSByZWN1cnNpb24gKG9wdGlvbmFsKVxyXG4gICAgICogQG1lbWJlcm9mIFRlcm1pbmF0aW9uTGlua1xyXG4gICAgICogQG1ldGhvZFxyXG4gICAgKi9cclxuICAgIHNlbGYuc2hvdyA9IGZ1bmN0aW9uIChvbmNlKSB7XHJcbiAgICAgICAgaWYgKCFvbmNlKSBzZWxmLm9yaWdpbmFsTGluay5zaG93KHRydWUpO1xyXG4gICAgICAgIHNlbGYuc2V0KCdoaWRkZW4nLCBmYWxzZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVmcmVzaGVzIGhpZ2hsaWdodGVycyBvZiB0aGUgdmlldyBvZiB0aGlzIGVsZW1lbnQuXHJcbiAgICAgKiBAbWVtYmVyb2YgTGlua1xyXG4gICAgICogQG1ldGhvZFxyXG4gICAgKi9cclxuICAgIHNlbGYucmVmcmVzaEhpZ2hsaWdodGluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfc3luY2hyb25pemVXaXRoT3JpZ2luKCk7XHJcbiAgICAgICAgc2VsZi50cmlnZ2VyKCdyZWZyZXNoLWhpZ2hsaWdodGluZycsIHNlbGYpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0IGhpZ2hsaWdodGluZyBmb3IgdGhlIFRlcm1pbmF0aW9uTGluay5cclxuICAgICAqIEBtZW1iZXJvZiBUZXJtaW5hdGlvbkxpbmtcclxuICAgICAqIEBtZXRob2RcclxuICAgICovXHJcbiAgICBmdW5jdGlvbiBfc3luY2hyb25pemVXaXRoT3JpZ2luICgpIHtcclxuICAgICAgICBpZiAoc2VsZi5vcmlnaW5hbExpbmsuZ2V0KCdoaWdobGlnaHRlZCcpKSB7XHJcbiAgICAgICAgICAgIHNlbGYuc2V0KCdoaWdobGlnaHRlZCcsIHRydWUsIHsgc2lsZW50OiB0cnVlIH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHNlbGYuc2V0KCdoaWdobGlnaHRlZCcsIGZhbHNlLCB7IHNpbGVudDogdHJ1ZSB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNlbGYub3JpZ2luYWxMaW5rLmdldCgnYmx1cmVkJykpIHtcclxuICAgICAgICAgICAgc2VsZi5zZXQoJ2JsdXJlZCcsIHRydWUsIHsgc2lsZW50OiB0cnVlIH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHNlbGYuc2V0KCdibHVyZWQnLCBmYWxzZSwgeyBzaWxlbnQ6IHRydWUgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHNlbGYubW9kZWwgPSB7IHNvdXJjZTogb3B0aW9ucy5zb3VyY2UuaWQsIHRhcmdldDogb3B0aW9ucy50YXJnZXQuaWQgfTtcclxuICAgIHNlbGYucmVmcmVzaEhpZ2hsaWdodGluZygpO1xyXG5cclxuICAgIGNvbnN0IG9uUmVtb3ZlID0gc2VsZi5yZW1vdmU7XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBsaW5rIGZyb20gdGhlIHBhcGVyLlxyXG4gICAgICogQG1lbWJlcm9mIFRlcm1pbmF0aW9uTGlua1xyXG4gICAgICogQG1ldGhvZFxyXG4gICAgKi9cclxuICAgIHNlbGYucmVtb3ZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNvbnN0IGluZGV4ID0gc2VsZi5vcmlnaW5hbExpbmsudGVybWluYXRpb25MaW5rcy5pbmRleE9mKHNlbGYpO1xyXG4gICAgICAgIHNlbGYub3JpZ2luYWxMaW5rLnRlcm1pbmF0aW9uTGlua3Muc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICBvblJlbW92ZS5jYWxsKHNlbGYpO1xyXG4gICAgfTtcclxufVxyXG5UZXJtaW5hdGlvbkxpbmsucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShqb2ludC5kaWEuTGluay5wcm90b3R5cGUpO1xyXG5cclxuXHJcbiIsImltcG9ydCAqIGFzIGpvaW50IGZyb20gJ3JhcHBpZCc7XHJcbmltcG9ydCB7IFJlc291cmNlUHJvdmlkZXIgfSBmcm9tICcuLi8uLi9kYXRhL3Jlc291cmNlUHJvdmlkZXInO1xyXG5pbXBvcnQgeyBaX0lOREVYRVMgfSBmcm9tICcuL2VsZW1lbnRzJztcclxuXHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBUZXJtaW5hdGlvbk5vZGVNb2RlbCAtIGRhdGEgbW9kZWwgb2YgYSBUZXJtaW5hdGlvbk5vZGUgb2JqZWN0XHJcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFRlcm1pbmF0aW9uTm9kZU1vZGVsXHJcbiAqIEBwcm9wZXJ0eSB7UG9pbnR9IHBvc2l0aW9uIC0gTm9kZSBpZGVudGlmeWVyXHJcbiAqIEBwcm9wZXJ0eSB7Tm9kZX0gbm9kZSAtIE9yaWdpbmFsIG5vZGVcclxuKi9cclxuXHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBUaGUgZ3JhcGggVGVybWluYXRpb25Ob2RlIGJhc2VkIG9uIGpvaW50LnNoYXBlcy5iYXNpYy5SZWN0LlxyXG4gKiBAY2xhc3NcclxuICogQGF1Z21lbnRzIGpvaW50LnNoYXBlcy5iYXNpYy5SZWN0XHJcbiAqIFxyXG4gKiBAcGFyYW0ge1Rlcm1pbmF0aW9uTm9kZU1vZGVsfSBvcHRpb25zIC0gRGF0YSBtb2RlbFxyXG4gKiBAcGFyYW0ge1BhcmFtZXRlcnN9IHBhcmFtZXRlcnMgLSBUaGUgc2V0IG9mIHBhcmFtZXRlcnNcclxuICogXHJcbiAqIEBwcm9wZXJ0eSB7Tm9kZX0gb3JpZ2luYWxOb2RlIC0gVGhlIG9yaWdpbmFsIG5vZGUsXHJcbiAqIHdoaWNoIGlzIG91dCBvZiB0aGUgdmlld0ZyYW1lIHNvIHdlIHVzZSB0ZXJtaW5hdGlvbiBpbnN0ZWFkXHJcbiAqIEBwcm9wZXJ0eSB7Tm9kZVtdfSByZWxhdGVkIC0gTGlzdCBvZiB0aGUgbm9kZXMgcmVsYXRlZCB3aXRoIHRoaXMgbm9kZVxyXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGhpZ2hsaWdodGVkIC0gVGVsbHMgd2hldGVyIGhpZ2hsaWdodGVkIG5vZGUgb3Igbm90ICh1c2UgbWV0aG9kIGdldCB0byBnZXQgdGhpcyBwcm9wZXJ0eSwgZS5nLiBub2RlLmdldCgnaGlnaGxpZ2h0ZWQnKSlcclxuICogQHByb3BlcnR5IHtib29sZWFufSBibHVyZWQgLSBUZWxscyB3aGV0ZXIgYmx1cmVkIG5vZGUgb3Igbm90ICh1c2UgbWV0aG9kIGdldCB0byBnZXQgdGhpcyBwcm9wZXJ0eSwgZS5nLiBub2RlLmdldCgnYmx1cmVkJykpXHJcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gcmVtb3ZlZCAtIElzIHRoZSBub2RlIHJlbW92ZWQgZnJvbSB0aGUgcGFwZXJcclxuKi9cclxuZXhwb3J0IGZ1bmN0aW9uIFRlcm1pbmF0aW9uTm9kZSAob3B0aW9ucywgcGFyYW1ldGVycykge1xyXG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XHJcbiAgICBjb25zdCBfcmVzID0gbmV3IFJlc291cmNlUHJvdmlkZXIocGFyYW1ldGVycyk7XHJcbiAgICBcclxuICAgIHNlbGYub3JpZ2luYWxOb2RlID0gb3B0aW9ucy5ub2RlO1xyXG4gICAgc2VsZi5oaWdobGlnaHRlZCA9IGZhbHNlO1xyXG4gICAgc2VsZi5ibHVyZWQgPSBmYWxzZTtcclxuICAgIHNlbGYucmVsYXRlZCA9IFtdO1xyXG4gICAgc2VsZi5zaXplID0gcGFyYW1ldGVycy50ZXJtaW5hdGlvbk5vZGVTaXplO1xyXG4gICAgXHJcbiAgICBvcHRpb25zLm5vZGUudGVybWluYXRpb25Ob2Rlcy5wdXNoKHNlbGYpO1xyXG5cclxuICAgIGpvaW50LnNoYXBlcy5iYXNpYy5HZW5lcmljLmFwcGx5KHNlbGYsIFt7XHJcbiAgICAgICAgbWFya3VwOiBgPGcgY2xhc3M9XCJyb3RhdGFibGVcIj5cclxuICAgICAgICAgICAgICAgICAgICA8ZyBjbGFzcz1cInNjYWxhYmxlXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxyZWN0IGNsYXNzPVwiYm9keVwiLz5cclxuICAgICAgICAgICAgICAgICAgICA8L2c+XHJcbiAgICAgICAgICAgICAgICAgICAgPHJlY3QgY2xhc3M9XCJ0cS1sZy1ib2R5XCIvPlxyXG4gICAgICAgICAgICAgICAgICAgIDx0ZXh0Lz5cclxuICAgICAgICAgICAgICAgIDwvZz5gLFxyXG4gICAgICAgIHR5cGU6ICd0ZXJtaW5hdGlvbi1ub2RlJyxcclxuICAgICAgICBwb3NpdGlvbjogb3B0aW9ucy5wb3NpdGlvbixcclxuICAgICAgICBzaXplOiBwYXJhbWV0ZXJzLnRlcm1pbmF0aW9uTm9kZVNpemUsXHJcbiAgICAgICAgYXR0cnM6IHsgXHJcbiAgICAgICAgICAgICcuYm9keSc6IHtcclxuICAgICAgICAgICAgICAgIHBvcnQ6ICdjbGlwUmVjdFBvcnQnLFxyXG4gICAgICAgICAgICAgICAgZmlsbDogJ3RyYW5zcGFyZW50JyxcclxuICAgICAgICAgICAgICAgICdzdHJva2Utd2lkdGgnOiAwLFxyXG4gICAgICAgICAgICAgICAgcng6IDEwLFxyXG4gICAgICAgICAgICAgICAgcnk6IDEwLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAnLnRxLWxnLWJvZHknOiB7XHJcbiAgICAgICAgICAgICAgICAncmVmLXgnOiAuNSxcclxuICAgICAgICAgICAgICAgICdyZWYteSc6IC41LFxyXG4gICAgICAgICAgICAgICAgJ3gtYWxpZ25tZW50JzogJ21pZGRsZScsXHJcbiAgICAgICAgICAgICAgICAneS1hbGlnbm1lbnQnOiAnbWlkZGxlJyxcclxuICAgICAgICAgICAgICAgIHdpZHRoOiBwYXJhbWV0ZXJzLnRlcm1pbmF0aW9uTm9kZVNpemUud2lkdGggLSAxMCxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogcGFyYW1ldGVycy50ZXJtaW5hdGlvbk5vZGVTaXplLmhlaWdodCAtIDEwLFxyXG4gICAgICAgICAgICAgICAgcmVmOiAnLmJvZHknLFxyXG4gICAgICAgICAgICAgICAgcng6IDIsXHJcbiAgICAgICAgICAgICAgICByeTogMixcclxuICAgICAgICAgICAgICAgIHN0cm9rZTogX3Jlcy5nZXRDb2xvcihvcHRpb25zLm5vZGUubW9kZWwudHlwZUlkKSxcclxuICAgICAgICAgICAgICAgIGZpbGw6ICd3aGl0ZScsXHJcbiAgICAgICAgICAgICAgICBwb3J0OiAnY2xpcFJlY3RQb3J0JyxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgdGV4dDoge1xyXG4gICAgICAgICAgICAgICAgdGV4dDogJ9ChJyxcclxuICAgICAgICAgICAgICAgIGZpbGw6IF9yZXMuZ2V0Q29sb3Iob3B0aW9ucy5ub2RlLm1vZGVsLnR5cGVJZCksXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6IF9yZXMuZ2V0Q29sb3Iob3B0aW9ucy5ub2RlLm1vZGVsLnR5cGVJZCksXHJcbiAgICAgICAgICAgICAgICAncmVmLXgnOiAuNSxcclxuICAgICAgICAgICAgICAgICdyZWYteSc6IC41NSxcclxuICAgICAgICAgICAgICAgIHJlZjogJy5ib2R5JyxcclxuICAgICAgICAgICAgICAgIHRvb2x0aXA6IHNlbGYub3JpZ2luYWxOb2RlLm1vZGVsLmxhYmVsIC8vIHNlZSB0aGUgbGluZSAyMjEgYXQgbGluZWFnZUdyYW0uanNcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgfSxcclxuICAgICAgICB6OiBaX0lOREVYRVMuVEVSTUlOQVRJT05fRUxFTUVOVCxcclxuICAgIH1dKTtcclxuXHJcbiAgICBsZXQgX2lzRHJhZ2dpbmcgPSB0cnVlO1xyXG4gICAgY29uc3Qgb2xkUG9zaXRpb24gPSBzZWxmLnBvc2l0aW9uO1xyXG4gICAgc2VsZi5wb3NpdGlvbiA9IGZ1bmN0aW9uICh4LCB5KSB7XHJcbiAgICAgICAgX2lzRHJhZ2dpbmcgPSBmYWxzZTtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBvbGRQb3NpdGlvbi5jYWxsKHNlbGYsIHgsIHkpO1xyXG4gICAgICAgIF9pc0RyYWdnaW5nID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIHNlbGYub24oJ2NoYW5nZTpwb3NpdGlvbicsICgpID0+IHtcclxuICAgICAgICBpZiAoX2lzRHJhZ2dpbmcpIHNlbGYuc2V0KCdkcmFnZ2VkJywgX2lzRHJhZ2dpbmcpO1xyXG4gICAgfSk7XHJcbiAgICBzZWxmLm9uKCdjaGFuZ2U6ZHJhZ2dlZCcsICgpID0+IHtcclxuICAgICAgICBjb25zdCBvbGRTaXplID0gc2VsZi5zaXplO1xyXG4gICAgICAgIGNvbnN0IG9sZFBvcyA9IHNlbGYucG9zaXRpb24oKTtcclxuXHJcbiAgICAgICAgaWYgKHNlbGYuZ2V0KCdkcmFnZ2VkJykpIHtcclxuICAgICAgICAgICAgc2VsZi5zaXplID0ge1xyXG4gICAgICAgICAgICAgICAgd2lkdGg6IHNlbGYub3JpZ2luYWxOb2RlLnNpemUud2lkdGgsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6ICBzZWxmLm9yaWdpbmFsTm9kZS5zaXplLmhlaWdodCxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgc2VsZi5hdHRyKHtcclxuICAgICAgICAgICAgICAgIHRleHQ6IHtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiAnKycsXHJcbiAgICAgICAgICAgICAgICAgICAgJ3JlZi15JzogLjUxLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICcuYm9keSc6IHtcclxuICAgICAgICAgICAgICAgICAgICByeDogMCxcclxuICAgICAgICAgICAgICAgICAgICByeTogMCxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBzZWxmLnJlc2l6ZShzZWxmLnNpemUud2lkdGgsIHNlbGYuc2l6ZS5oZWlnaHQpO1xyXG4gICAgICAgICAgICBzZWxmLnBvc2l0aW9uKFxyXG4gICAgICAgICAgICAgICAgb2xkUG9zLnggLSAoc2VsZi5zaXplLndpZHRoIC0gb2xkU2l6ZS53aWR0aCkgLyAyLFxyXG4gICAgICAgICAgICAgICAgb2xkUG9zLnkgLSAoc2VsZi5zaXplLmhlaWdodCAtIG9sZFNpemUuaGVpZ2h0KSAvIDIsXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc2VsZi5zaXplID0ge1xyXG4gICAgICAgICAgICAgICAgd2lkdGg6IHBhcmFtZXRlcnMudGVybWluYXRpb25Ob2RlU2l6ZS53aWR0aCxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogcGFyYW1ldGVycy50ZXJtaW5hdGlvbk5vZGVTaXplLmhlaWdodCxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgc2VsZi5hdHRyKHtcclxuICAgICAgICAgICAgICAgIHRleHQ6IHtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiAnQycsXHJcbiAgICAgICAgICAgICAgICAgICAgJ3JlZi15JzogLjU1LFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICcuYm9keSc6IHtcclxuICAgICAgICAgICAgICAgICAgICByeDogMTAsXHJcbiAgICAgICAgICAgICAgICAgICAgcnk6IDEwLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHNlbGYucmVzaXplKHNlbGYuc2l6ZS53aWR0aCwgc2VsZi5zaXplLmhlaWdodCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBzZWxmLnBvc2l0aW9uKFxyXG4gICAgICAgICAgICAgICAgb2xkUG9zLnggKyAoc2VsZi5zaXplLndpZHRoIC0gb2xkU2l6ZS53aWR0aCkgLyAyLFxyXG4gICAgICAgICAgICAgICAgb2xkUG9zLnkgKyAoc2VsZi5zaXplLmhlaWdodCAtIG9sZFNpemUuaGVpZ2h0KSAvIDIsXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIaWdobGlnaHRzIHRoZSBUZXJtaW5hdGlvbk5vZGUuXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9uY2UgLSBCb29sZWFuIGZsYWcgdG8gcHJvdGVjdCBjb2RlIGZyb20gcmVjdXJzaW9uIChvcHRpb25hbClcclxuICAgICAqIEBtZW1iZXJvZiBUZXJtaW5hdGlvbk5vZGVcclxuICAgICAqIEBtZXRob2RcclxuICAgICovXHJcbiAgICBzZWxmLnNlbGVjdCA9IGZ1bmN0aW9uIChvbmNlKSB7XHJcbiAgICAgICAgaWYgKHNlbGYub3JpZ2luYWxOb2RlICYmICFvbmNlKSBzZWxmLm9yaWdpbmFsTm9kZS5zZWxlY3QodHJ1ZSk7XHJcbiAgICAgICAgaWYgKHNlbGYuZ2V0KCdibHVyZWQnKSkgc2VsZi51bmJsdXJlKCk7XHJcbiAgICAgICAgaWYgKHNlbGYuZ2V0KCdoaWRkZW4nKSkgc2VsZi5zaG93KCk7XHJcbiAgICAgICAgc2VsZi5wcm9wKHsgejogWl9JTkRFWEVTLlNFTEVDVEVEX0VMRU1FTlQgfSk7XHJcbiAgICAgICAgc2VsZi5zZXQoJ2hpZ2hsaWdodGVkJywgdHJ1ZSk7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgaGlnaGxpZ2h0aW5nIGZyb20gdGhlIFRlcm1pbmF0aW9uTm9kZS5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gb25jZSAtIEJvb2xlYW4gZmxhZyB0byBwcm90ZWN0IGNvZGUgZnJvbSByZWN1cnNpb24gKG9wdGlvbmFsKVxyXG4gICAgICogQG1lbWJlcm9mIFRlcm1pbmF0aW9uTm9kZVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgKi9cclxuICAgIHNlbGYudW5zZWxlY3QgPSBmdW5jdGlvbiAob25jZSkge1xyXG4gICAgICAgIGlmIChzZWxmLm9yaWdpbmFsTm9kZSAmJiAhb25jZSkgc2VsZi5vcmlnaW5hbE5vZGUudW5zZWxlY3QodHJ1ZSk7XHJcbiAgICAgICAgc2VsZi5wcm9wKHsgejogWl9JTkRFWEVTLlRFUk1JTkFUSU9OX0VMRU1FTlQgfSk7XHJcbiAgICAgICAgc2VsZi5zZXQoJ2hpZ2hsaWdodGVkJywgZmFsc2UpO1xyXG4gICAgfTtcclxuXHJcbiAgIC8qKlxyXG4gICAgICogQmx1cnMgdGhlIFRlcm1pbmF0aW9uTm9kZS5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gb25jZSAtIEJvb2xlYW4gZmxhZyB0byBwcm90ZWN0IGNvZGUgZnJvbSByZWN1cnNpb24gKG9wdGlvbmFsKVxyXG4gICAgICogQG1lbWJlcm9mIFRlcm1pbmF0aW9uTm9kZVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgKi8gICAgXHJcbiAgICBzZWxmLmJsdXJlID0gZnVuY3Rpb24gKG9uY2UpIHtcclxuICAgICAgICBpZiAoc2VsZi5nZXQoJ2hpZ2hsaWdodGVkJykpIHJldHVybjtcclxuICAgICAgICBpZiAoc2VsZi5vcmlnaW5hbE5vZGUgJiYgIW9uY2UpIHNlbGYub3JpZ2luYWxOb2RlLmJsdXJlKHRydWUpO1xyXG4gICAgICAgIHNlbGYucHJvcCh7IHo6IFpfSU5ERVhFUy5CTFVSRURfTk9ERSB9KTsgICAgICAgIFxyXG4gICAgICAgIHNlbGYuc2V0KCdibHVyZWQnLCB0cnVlKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGJsdXIgZnJvbSB0aGUgVGVybWluYXRpb25Ob2RlLlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBvbmNlIC0gQm9vbGVhbiBmbGFnIHRvIHByb3RlY3QgY29kZSBmcm9tIHJlY3Vyc2lvbiAob3B0aW9uYWwpXHJcbiAgICAgKiBAbWVtYmVyb2YgVGVybWluYXRpb25Ob2RlXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAqL1xyXG4gICAgc2VsZi51bmJsdXJlID0gZnVuY3Rpb24gKG9uY2UpIHtcclxuICAgICAgICBpZiAoc2VsZi5vcmlnaW5hbE5vZGUgJiYgIW9uY2UpIHNlbGYub3JpZ2luYWxOb2RlLnVuYmx1cmUodHJ1ZSk7XHJcbiAgICAgICAgc2VsZi5wcm9wKHsgejogWl9JTkRFWEVTLlRFUk1JTkFUSU9OX0VMRU1FTlQgfSk7ICAgICAgICBcclxuICAgICAgICBzZWxmLnNldCgnYmx1cmVkJywgZmFsc2UpO1xyXG4gICAgfTtcclxuXHJcbiAgIC8qKlxyXG4gICAgICogQmx1cnMgdGhlIFRlcm1pbmF0aW9uTm9kZS5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gb25jZSAtIEJvb2xlYW4gZmxhZyB0byBwcm90ZWN0IGNvZGUgZnJvbSByZWN1cnNpb24gKG9wdGlvbmFsKVxyXG4gICAgICogQG1lbWJlcm9mIFRlcm1pbmF0aW9uTm9kZVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgKi8gICAgXHJcbiAgICBzZWxmLmhpZGUgPSBmdW5jdGlvbiAob25jZSkge1xyXG4gICAgICAgIGlmIChzZWxmLm9yaWdpbmFsTm9kZSAmJiAhb25jZSkgc2VsZi5vcmlnaW5hbE5vZGUuaGlkZSh0cnVlKTsgICAgIFxyXG4gICAgICAgIHNlbGYuc2V0KCdoaWRkZW4nLCB0cnVlKTtcclxuICAgIH07XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBibHVyIGZyb20gdGhlIFRlcm1pbmF0aW9uTm9kZS5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gb25jZSAtIEJvb2xlYW4gZmxhZyB0byBwcm90ZWN0IGNvZGUgZnJvbSByZWN1cnNpb24gKG9wdGlvbmFsKVxyXG4gICAgICogQG1lbWJlcm9mIFRlcm1pbmF0aW9uTm9kZVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgKi9cclxuICAgIHNlbGYuc2hvdyA9IGZ1bmN0aW9uIChvbmNlKSB7XHJcbiAgICAgICAgaWYgKHNlbGYub3JpZ2luYWxOb2RlICYmICFvbmNlKSBzZWxmLm9yaWdpbmFsTm9kZS5zaG93KHRydWUpOyAgICBcclxuICAgICAgICBzZWxmLnNldCgnaGlkZGVuJywgZmFsc2UpO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWZyZXNoZXMgaGlnaGxpZ2h0ZXJzIG9mIHRoZSB2aWV3IG9mIHRoaXMgZWxlbWVudC5cclxuICAgICAqIEBtZW1iZXJvZiBMaW5rXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAqL1xyXG4gICAgc2VsZi5yZWZyZXNoSGlnaGxpZ2h0aW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF9zeW5jaHJvbml6ZVdpdGhPcmlnaW4oKTtcclxuICAgICAgICBzZWxmLnRyaWdnZXIoJ3JlZnJlc2gtaGlnaGxpZ2h0aW5nJywgc2VsZik7ICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gX3N5bmNocm9uaXplV2l0aE9yaWdpbiAoKSB7XHJcbiAgICAgICAgaWYgKHNlbGYub3JpZ2luYWxOb2RlLmdldCgnaGlnaGxpZ2h0ZWQnKSkge1xyXG4gICAgICAgICAgICBzZWxmLnNldCgnaGlnaGxpZ2h0ZWQnLCB0cnVlLCB7IHNpbGVudDogdHJ1ZSB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzZWxmLnNldCgnaGlnaGxpZ2h0ZWQnLCBmYWxzZSwgeyBzaWxlbnQ6IHRydWUgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzZWxmLm9yaWdpbmFsTm9kZS5nZXQoJ2JsdXJlZCcpKSB7XHJcbiAgICAgICAgICAgIHNlbGYuc2V0KCdibHVyZWQnLCB0cnVlLCB7IHNpbGVudDogdHJ1ZSB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzZWxmLnNldCgnYmx1cmVkJywgZmFsc2UsIHsgc2lsZW50OiB0cnVlIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBvblJlbW92ZSA9IHNlbGYucmVtb3ZlO1xyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgbm9kZSBmcm9tIHRoZSBwYXBlci5cclxuICAgICAqIEBtZW1iZXJvZiBUZXJtaW5hdGlvbk5vZGVcclxuICAgICAqIEBtZXRob2RcclxuICAgICovXHJcbiAgICBzZWxmLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjb25zdCBpbmRleCA9IHNlbGYub3JpZ2luYWxOb2RlLnRlcm1pbmF0aW9uTm9kZXMuaW5kZXhPZihzZWxmKTtcclxuICAgICAgICBzZWxmLm9yaWdpbmFsTm9kZS50ZXJtaW5hdGlvbk5vZGVzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgb25SZW1vdmUuY2FsbChzZWxmKTtcclxuICAgIH07XHJcblxyXG4gICAgc2VsZi5yZWZyZXNoSGlnaGxpZ2h0aW5nKCk7XHJcbn1cclxuVGVybWluYXRpb25Ob2RlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoam9pbnQuc2hhcGVzLmJhc2ljLlJlY3QucHJvdG90eXBlKTsiLCJpbXBvcnQgKiBhcyBqb2ludCBmcm9tICdyYXBwaWQnO1xyXG5pbXBvcnQgc2F2ZUFzIGZyb20gJ2ZpbGUtc2F2ZXJqcyc7XHJcbmltcG9ydCAqIGFzIF8gZnJvbSAnbG9kYXNoJztcclxuXHJcbmltcG9ydCB7IFZpZXdNYW5hZ2VyLCBGUkFNRV9PVVRfTUFSR0lOLCBESVNUQU5DRV9CRVRXRUVOX0ZSQU1FUyB9IGZyb20gJy4vdmlld01hbmFnZXInO1xyXG5pbXBvcnQgeyBSb3V0aW5nTWFuYWdlciB9IGZyb20gJy4vbGlua1JvdXRpbmdNYW5hZ2VyL3JvdXRpbmdNYW5hZ2VyJztcclxuaW1wb3J0IHsgVmlld0ZyYW1lIH0gZnJvbSAnLi92aWV3RnJhbWUnO1xyXG5pbXBvcnQgeyBOb2RlLCBMaW5rLCBUZXJtaW5hdGlvbk5vZGUsIE5vZGVWaWV3LCBMaW5rVmlldywgQXNwZWN0TGluayB9IGZyb20gJy4vZ3JhcGhFbGVtZW50cy9lbGVtZW50cyc7XHJcbmltcG9ydCBWaWV3RnJhbWVzVUkgZnJvbSAnLi4vaHRtbFVJL3ZpZXdGcmFtZXNVSSc7XHJcbmltcG9ydCBTdWJzY3JpYmFibGUgZnJvbSAnLi4vc3Vic2NyaXB0aW9uQVBJL3N1YnNjcmliZWFibGUnO1xyXG5pbXBvcnQgeyBleHBvcnRUb1NWRywgdG9EYXRhVVJMIH0gZnJvbSAnLi90b1N2Zyc7XHJcbmltcG9ydCB7IGNvbWJpbmVPcGVyYXRpb24gfSBmcm9tICcuLi9sYXlvdXQvbGF5b3V0JztcclxuaW1wb3J0IHtcclxuICAgIGRhdGUyU3RyaW5nLFxyXG4gICAgcG5nMkJsb2IsXHJcbiAgICBnZXRCYXNlRWxlbWVudFxyXG59IGZyb20gJy4uL3V0aWxzL2RhdGFVdGlscyc7XHJcbmltcG9ydCB7XHJcbiAgICBsaW1pdFBvaW50UG9zaXRpb24sXHJcbiAgICBnZXREaXN0LFxyXG4gICAgZ2V0RGlmZixcclxuICAgIGxvY2FsVG9HbG9iYWxQb2ludCxcclxuICAgIGdldEdsb2JhbE5vZGVQb3NpdGlvbixcclxuICAgIGdldEdsb2JhbE5vZGVTaXplLFxyXG4gICAgZ2xvYmFsVG9TY2FsZWRTaXplLFxyXG4gICAgc2NhbGVkVG9HbG9iYWxTaXplLFxyXG59IGZyb20gJy4uL3V0aWxzL3V0aWxzJztcclxuaW1wb3J0IHsgZ2V0UGF0aCwgZ2V0Vmlld0ZyYW1lSWRGb3JOb2RlIH0gZnJvbSAnLi4vdXRpbHMvbGluZWFnZURpYWdyYW1VdGlscyc7XHJcblxyXG5jb25zdCBESVJFQ1RJT04gPSB7XHJcbiAgICBVUDogMzgsXHJcbiAgICBET1dOOiA0MCxcclxuICAgIExFRlQ6IDM3LFxyXG4gICAgUklHSFQ6IDM5LFxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBjbGFzc1xyXG4gKiBNYW5hZ2VzIHRoZSBtYWluIHZpZXcgb2YgYXBwbGljYXRpb24gKFZpZXctMilcclxuICogQWxsIGNoYW5nZXMgZ29lcyB0aHJvdWdoIHRoZSByZW5kZXIgZnVuY3Rpb24uXHJcbiAqXHJcbiAqIENvbnN0cnVjdG9yIHBhcmFtZXRlcnM6XHJcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICogQHBhcmFtIHtcclxuICogIGRhdGFDb250YWluZXI6IERhdGFDb250YWluZXJcclxuICogIGdyYXBoUGxhY2U6IEhUTUxFbGVtZW50XHJcbiAqICB2aWV3RnJhbWVzOiBWaWV3RnJhbWVNb2RlbHNcclxuICogfSBvcHRpb25zXHJcbiAqIEBwYXJhbSB7UGFyYW1ldGVyc30gcGFyYW1ldGVycyAtIHBhcmFtZXRlcnMgc2V0XHJcbiAqXHJcbiAqIFB1YmxpYyBwcm9wZXJ0aWVzOlxyXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAqIHNlbGVjdGVkRWxlbWVudDogTm9kZXxMaW5rXHJcbiAqXHJcbiAqIFB1YmxpYyBtZXRob2RzOlxyXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAqIHJlZHJhdzogKG9wdGlvbnM6IHtcclxuICAgIHZpZXdGcmFtZXM6IFZpZXdGcmFtZVB1YmxpY01vZGVsW107XHJcbiAgICBzZWxlY3RlZEVsZW1lbnQ6IChOb2RlfExpbmspO1xyXG4gICAgcGF0aDogeyBbaWQ6IHN0cmluZ106IChOb2RlfExpbmspIH07XHJcbiAgICBxdWlja1VwZGF0ZTogYm9vbGVhbjtcclxuICAgIHVwZGF0ZUJvdW5kczogYm9vbGVhbjtcclxuICAgIHBhcGVyT3B0aW9uczoge1xyXG4gICAgICAgIG9yaWVudGF0aW9uOiBPcmllbnRhdGlvbjtcclxuICAgICAgICB3aWR0aDogbnVtYmVyO1xyXG4gICAgICAgIGhlaWdodDpudW1iZXI7XHJcbiAgICAgICAgc2NhbGU6IFBvaW50O1xyXG4gICAgfTtcclxuICAgIGVsZW1lbnRPcHRpb25zOiB7XHJcbiAgICAgICAgZWxlbWVudFNpemU6IEVsZW1lbnRTaXplO1xyXG4gKiB9KSA9PiB2b2lkO1xyXG4gKiBkZWxheWVkUmVkcmF3OiAob3B0aW9uczogeyAuLi4gc2VlIHJlZHJhd30pID0+IHZvaWQ7XHJcbiAqIG9wZW5WaWV3RnJhbWU6IChpZDpzdHJpbmcpID0+IHZvaWQ7XHJcbiAqIGNsb3NlVmlld0ZyYW1lOiAoaWQ6c3RyaW5nKSA9PiB2b2lkO1xyXG4gKiBvcGVuT3ZlclZpZXdGcmFtZTogKCkgPT4gdm9pZDtcclxuICogY2xvc2VPdmVyVmlld0ZyYW1lOiAoKSA9PiB2b2lkO1xyXG4gKiB1cGRhdGVOb2Rlc1Bvc2l0aW9uczogKG5vZGVzOiBOb2RlW10pID0+IHZvaWQ7XHJcbiAqIGNvbWJpbmU6ICgpID0+IHZvaWQ7XHJcbiAqIHJlc2V0TGF5b3V0OiAoKSA9PiB2b2lkO1xyXG4gKiByZWZyZXNoOiAoKSA9PiB2b2lkO1xyXG4gKiBnZXRTZWxlY3RlZEVsZW1lbnQ6ICgpID0+IChOb2RlfExpbmspO1xyXG4gKiBnZXRWaXNpYmxlQ2VsbHM6ICgpID0+IChOb2RlfExpbmt8Vmlld0ZyYW1lfFRlcm1pbmF0aW9uTm9kZXxUZXJtaW5hdGlvbkxpbmspO1xyXG4gKiBnZXRWaXNpYmxlTm9kZXM6ICgpID0+IChOb2RlfFZpZXdGcmFtZXxUZXJtaW5hdGlvbk5vZGUpO1xyXG4gKiBnZXRWaXNpYmxlTGlua3M6ICgpID0+IChMaW5rfFRlcm1pbmF0aW9uTGluayk7XHJcbiAqIHNldFNlbGVjdGVkRWxlbWVudDogKGVsZW1lbnQ6IChOb2RlfExpbmt8dW5kZWZpbmVkKSwgZm9jdXNPbjogYm9vbGVhbikgPT4gdm9pZDtcclxuICogcG9zaXRpb25WaWV3UG9ydDogKHZmOiBWaWV3RnJhbWVQdWJsaWNNb2RlbCwgcG9pbnQ6IFBvaW50LCBhbmltYXRpb246IGJvb2xlYW4pID0+IHZvaWQ7XHJcbiAqIGV4cG9ydDogKCkgPT4gdm9pZDtcclxuICogcHJpbnQ6ICgpID0+IHZvaWQ7XHJcbiAqIHNldERhdGE6IChkYXRhQ29udGFpbmVyOiBEYXRhQ29udGFpbmVyLCB2aWV3RnJhbWVzOiBWaWV3RnJhbWVEZWZpbml0aW9uW10pID0+IHZvaWQ7XHJcbiAqIHNjYWxlOiAoc2NhbGU6IFBvaW50KSA9PiB2b2lkOyAtIFNldHMgYW5kIGxpbWl0cyB2YWx1ZSBvZiB0aGUgc2NhbGUgb2YgdGhlIGdyYXBoXHJcbiAqIHpvb21JbjogKCkgPT4gdm9pZDtcclxuICogem9vbU91dDogKCkgPT4gdm9pZDtcclxuICogem9vbVRvRml0OiAoKSA9PiB2b2lkO1xyXG4gKiBzZXRPcmllbnRhdGlvbjogKG9yaWVudGF0aW9uOiBPcmllbnRhdGlvbikgPT4gdm9pZDsgVmFsdWVzOiAnbGVmdC10by1yaWdodCcsICdyaWdodC10by1sZWZ0JywgJ3RvcC10by1ib3R0b20nLCAnYm90dG9tLXRvLXRvcCdcclxuICogZ2V0Vmlld0ZyYW1lczogKCkgPT4gVmlld0ZyYW1lUHVibGljTW9kZWxbXTtcclxuICogdHJhbnNsYXRlVmlld1BvcnQgKHZmOiBWaWV3RnJhbWUsIGR4OiBudW1iZXIsIGR5OiBudW1iZXIsIGFuaW1hdGlvbjogYm9vbGVhbilcclxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiBvbiAoZXZlbnQ6IHN0cmluZywgY2FsbGJhY2s6IGZ1bmN0aW9uKSA9PiB2b2lkXHJcbiAqIHVuc3Vic2NyaWJlIChjYWxsYmFjazogZnVuY3Rpb24pID0+IHZvaWRcclxuICogdHJpZ2dlciAoZXZlbnQ6IHN0cmluZywgcGFyYW1ldGVyczogYW55KSA9PiB2b2lkXHJcbiAqXHJcbiAqIEV2ZW50czpcclxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gKiBAZmlyZXMgc2VsZWN0ZWQtZWxlbWVudC1jaGFuZ2VkIChOb2RlfExpbmspXHJcbiAqIEBmaXJlcyBzY2FsZS1jaGFuZ2VkIChzY2FsZSlcclxuICogQGZpcmVzIHZpZXctZnJhbWVzLXN0YXRlLWNoYW5nZWQgKFZpZXdGcmFtZSwgYm9vbGVhbilcclxuICogQGZpcmVzIHZpZXctZnJhbWVzLXNpemUtb3ItcG9zaXRpb24tY2hhbmdlZCAoVmlld0ZyYW1lLCBib29sZWFuKVxyXG4gKiBAZmlyZXMgY2VsbC1kb3VibGUtY2xpY2sgKGNlbGwpXHJcbiAqIEBmaXJlcyBjZWxsLXNpbmdsZS1jbGljayAoY2VsbClcclxuICogQGZpcmVzIGxpbmstb3B0aW9ucy1jbGljayAoTGluaylcclxuICogQGZpcmVzIG5vZGVzLXBvc2l0aW9uLWNoYW5nZWRcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIExpbmVhZ2VEaWFncmFtIChvcHRpb25zLCBwYXJhbWV0ZXJzKSB7XHJcbiAgICAvLyBJbml0XHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICBTdWJzY3JpYmFibGUuYXBwbHkodGhpcyk7ICAgLy8gbWFrZSB0aGlzIGNsYXNzIFN1YnNjcmliYWJsZVxyXG5cclxuICAgIGNvbnN0IF9iYXNlID0gX2NyZWF0ZUJhc2Uob3B0aW9ucy5ncmFwaFBsYWNlKTtcclxuXHJcbiAgICAvLyBDcmVhdGluZyBhIGpvaW50IGdyYXBoIGFuZCBqb2ludCBwYXBlclxyXG4gICAgY29uc3QgX2dyYXBoID0gbmV3IGpvaW50LmRpYS5HcmFwaCgpO1xyXG4gICAgY29uc3QgX3BhcGVyID0gbmV3IGpvaW50LmRpYS5QYXBlcih7XHJcbiAgICAgICAgZWw6IF9iYXNlLmRpYWdyYW0sXHJcbiAgICAgICAgbW9kZWw6IF9ncmFwaCxcclxuICAgICAgICBlbGVtZW50VmlldzogTm9kZVZpZXcsXHJcbiAgICAgICAgbGlua1ZpZXc6IExpbmtWaWV3LFxyXG4gICAgICAgIGdyaWRTaXplOiAxLFxyXG4gICAgICAgIGludGVyYWN0aXZlOiAoKSA9PiB7IHJldHVybiB7IHZlcnRleEFkZDogZmFsc2UgfTsgfSxcclxuICAgICAgICBwcmV2ZW50Q29udGV4dE1lbnU6IGZhbHNlLFxyXG4gICAgICAgIHdpZHRoOiAnMTAwJScsXHJcbiAgICAgICAgaGVpZ2h0OiAnMTAwJScsXHJcbiAgICB9KTtcclxuXHJcbiAgICBsZXQgX3NjYWxlID0gcGFyYW1ldGVycy5kZWZhdWx0U2NhbGU7XHJcbiAgICBsZXQgX2RhdGFDb250YWluZXI7XHJcblxyXG4gICAgbGV0IF9vcmllbnRhdGlvbiA9IHBhcmFtZXRlcnMuZ3JhcGhPcmllbnRhdGlvbjtcclxuICAgIGxldCBfZnVsbFNjcmVlbk1vZGUgPSBwYXJhbWV0ZXJzLmZ1bGxTY3JlZW5Nb2RlO1xyXG4gICAgbGV0IF9wYXRoID0gbnVsbDsgLy8gaGlnaGxpZ2h0aW5nIHBhdGhcclxuICAgIGxldCBfbWFzayA9IHBhcmFtZXRlcnMubWFzazsgLy8gaGlnaGxpZ2h0aW5nIHBhdGhcclxuICAgIGxldCBfc2VsZWN0ZWRFbGVtZW50ID0gbnVsbDtcclxuICAgIGxldCBfcm91dGluZ01hbmFnZXI7XHJcbiAgICBsZXQgX3ZpZXdGcmFtZXNVSTtcclxuICAgIGxldCBfdmlld01hbmFnZXI7XHJcbiAgICBcclxuXHJcbiAgICBjb25zdCBzZWxmID0gdGhpcztcclxuICAgIGNvbnN0IF9rZXlib2FyZCA9IG5ldyBqb2ludC51aS5LZXlib2FyZCgpO1xyXG4gICAgY29uc3QgX3NjYWxlQm91bmRzID0gXy5jbG9uZShwYXJhbWV0ZXJzLnNjYWxlQm91bmRzKTtcclxuICAgIGNvbnN0IF9vdmVyVmlld1NjYWxlQm91bmRzID0gXy5jbG9uZShwYXJhbWV0ZXJzLm92ZXJWaWV3U2NhbGVCb3VuZHMpO1xyXG4gICAgY29uc3QgX3NjYWxlU3RlcCA9IHBhcmFtZXRlcnMuc2NhbGVTdGVwO1xyXG5cclxuXHJcbiAgICBfc2V0RGF0YShvcHRpb25zLmRhdGFDb250YWluZXIsIG9wdGlvbnMudmlld0ZyYW1lcyk7XHJcbiAgICBfc3Vic2NyaWJlT25FdmVudHMoKTtcclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERyYXdpbmcgb3B0aW9ucyAoZGVwcmVjYXRlZClcclxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IERyYXdpbmdPcHRpb25zXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHF1aWNrVXBkYXRlIC0gZG9uJ3QgdXBkYXRlcyBsaW5rcyBhbmQgcmVtb3ZlIHRoZW0uXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5IG9mIFZpZXdGcmFtZX0gdmlld0ZyYW1lcyAtIHVwZGF0ZSBvbmx5IGxpbWl0dGVkIG51bWJlciBvZiB2aWV3RnJhbWVzLlxyXG4gICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBVcGRhdGVzIHRoZSBncmFwaCdzIHN0YXRlLCAtIEFkZC9yZW1vdmVcclxuICAgICAqIHZpc2libGUgTm9kZXMgYW5kIFRlcm1pbmF0aW9uTm9kZXNcclxuICAgICAqIEBwYXJhbSB7RHJhd2luZ09wdGlvbnN9IG9wdGlvbnNcclxuICAgICAqL1xyXG4gICAgc2VsZi5yZWRyYXcgPSBfcmVkcmF3O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTYW1lIGFzIHJlZHJhdyBidXQgaXQncyBxdWljayB1cGRhdGVcclxuICAgICAqIHdpdGggZGVsYXllZCBmdWxsIHJlZHJhdyAoZGVib3VuY2VyKS5cclxuICAgICAqL1xyXG4gICAgc2VsZi5kZWxheWVkUmVkcmF3ID0gX2RlbGF5ZWRSZWRyYXc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPcGVucyBWaWV3RnJhbWUgd2l0aCBzcGVjaWZpZWQgaWRcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2aWV3RnJhbWVJZFxyXG4gICAgICovXHJcbiAgICBzZWxmLm9wZW5WaWV3RnJhbWUgPSBfb3BlblZpZXdGcmFtZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENsb3NlcyBWaWV3RnJhbWUgd2l0aCBzcGVjaWZpZWQgaWRcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2aWV3RnJhbWVJZFxyXG4gICAgICovXHJcbiAgICBzZWxmLmNsb3NlVmlld0ZyYW1lID0gX2Nsb3NlVmlld0ZyYW1lO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hhbmdlcyBtb2RlIGZ1bGxTY3JlZW4vdmlld0ZyYW1lLlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSB2YWx1ZVxyXG4gICAgKi9cclxuICAgIHNlbGYuc2V0RnVsbFNjcmVlbk1vZGUgPSBfc2V0RnVsbFNjcmVlbk1vZGU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPcGVucyBPdmVyVmlld0ZyYW1lXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmlld0ZyYW1lSWRcclxuICAgICAqL1xyXG4gICAgc2VsZi5vcGVuT3ZlclZpZXdGcmFtZSA9ICgpID0+IF9vcGVuVmlld0ZyYW1lKF92aWV3TWFuYWdlci5nZXRPdmVyVmlld0ZyYW1lKCkuaWQpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2xvc2VzIE92ZXJWaWV3RnJhbWVcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2aWV3RnJhbWVJZFxyXG4gICAgICovXHJcbiAgICBzZWxmLmNsb3NlT3ZlclZpZXdGcmFtZSA9ICgpID0+IF9jbG9zZVZpZXdGcmFtZShfdmlld01hbmFnZXIuZ2V0T3ZlclZpZXdGcmFtZSgpLmlkKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgbGF5b3V0IHBvc2l0aW9ucyBvZiB0aGUgbm9kZXMgdXNpbmcgcGFwZXIgcG9zaXRpb25zXHJcbiAgICAgKiBAcGFyYW0ge05vZGVbXX0gbm9kZXNcclxuICAgICAqL1xyXG4gICAgc2VsZi51cGRhdGVOb2Rlc1Bvc2l0aW9ucyA9IF91cGRhdGVOb2Rlc1Bvc2l0aW9ucztcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdyb3VwcyBub2RlcyBhcm91bmQgc2VsZWN0ZWRcclxuICAgICAqIGFuZCBoaWdobGlnaHRzIG5laWdoYm91cnNcclxuICAgICAqL1xyXG4gICAgc2VsZi5jb21iaW5lID0gX2NvbWJpbmU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXN0b3JlIG5vZGVzIHBvc2l0aW9uc1xyXG4gICAgICovXHJcbiAgICBzZWxmLnJlc2V0TGF5b3V0ID0gX3Jlc2V0TGF5b3V0O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVmcmVzaGVzIGFsbCB2aWV3RnJhbWVzIGJvdW5kcy5cclxuICAgICAqL1xyXG4gICAgc2VsZi5yZWZyZXNoID0gX3JlZnJlc2g7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyB7Tm9kZXxMaW5rfS5cclxuICAgICovXHJcbiAgICBzZWxmLmdldFNlbGVjdGVkRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX3NlbGVjdGVkRWxlbWVudDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyB7KE5vZGV8TGlua3xWaWV3RnJhbWV8VGVybWluYXRpb25Ob2RlfFRlcm1pbmF0aW9uTGluayl9LlxyXG4gICAgKi9cclxuICAgIHNlbGYuZ2V0VmlzaWJsZUNlbGxzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfZ3JhcGguZ2V0Q2VsbHMoKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyB7KE5vZGV8Vmlld0ZyYW1lfFRlcm1pbmF0aW9uTm9kZSl9LlxyXG4gICAgKi9cclxuICAgIHNlbGYuZ2V0VmlzaWJsZU5vZGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfZ3JhcGguZ2V0RWxlbWVudHMoKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyB7KExpbmt8VGVybWluYXRpb25MaW5rKX0uXHJcbiAgICAqL1xyXG4gICAgc2VsZi5nZXRWaXNpYmxlTGlua3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9ncmFwaC5nZXRMaW5rcygpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgc2VsZWN0ZWQgZWxlbWVudFxyXG4gICAgICogQHBhcmFtIHtOb2RlfExpbmt8dW5kZWZpbmVkfS5cclxuICAgICovXHJcbiAgICBzZWxmLnNldFNlbGVjdGVkRWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50LCBmb2N1c09uKSB7XHJcbiAgICAgICAgaWYgKGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgX3NlbGVjdChlbGVtZW50LCBmb2N1c09uKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBfdW5zZWxlY3QoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSXQgc2V0cyBvZmZzZXQgZm9yIGFsbCBlbGVtZW50cyBpbnRvIHRoZSB2aWV3UG9ydC5cclxuICAgICAqIEBwYXJhbSB7Vmlld0ZyYW1lfSB2aWV3RnJhbWVcclxuICAgICAqIEBwYXJhbSB7UG9pbnR9IHBvaW50XHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGFuaW1hdGlvbiAtIGl0J3Mgb3B0aW9uYWxcclxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gaXQncyBjYWxsZWQgYWZ0ZXIgZm9jdXNcclxuICAgICAqIEBmaXJlcyB2aWV3LWZyYW1lcy1zaXplLW9yLXBvc2l0aW9uLWNoYW5nZWRcclxuICAgICovXHJcbiAgICBzZWxmLnBvc2l0aW9uVmlld1BvcnQgPSBmdW5jdGlvbiAodmlld0ZyYW1lUHVibGljTW9kZWwsIHBvaW50LCBhbmltYXRpb24sIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgY29uc3QgcmVsZXZhbnRWaWV3RnJhbWUgPSBfdmlld01hbmFnZXIuZ2V0Vmlld0ZyYW1lQnlJZCh2aWV3RnJhbWVQdWJsaWNNb2RlbC5pZCk7XHJcbiAgICAgICAgX3Bvc2l0aW9uVmlld1BvcnQocmVsZXZhbnRWaWV3RnJhbWUsIHBvaW50LCBhbmltYXRpb24sICgpID0+IHtcclxuICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICAgICAgY29uc3QgY2hhbmdlZFZpZXdGcmFtZSA9IF92aWV3TWFuYWdlci5nZXRWaWV3RnJhbWVCeUlkKHZpZXdGcmFtZVB1YmxpY01vZGVsLmlkKTtcclxuICAgICAgICAgICAgc2VsZi50cmlnZ2VyKCd2aWV3LWZyYW1lcy1zaXplLW9yLXBvc2l0aW9uLWNoYW5nZWQnLCBbW2NoYW5nZWRWaWV3RnJhbWVdXSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRXhwb3J0cyBncmFwaCB0byBwbmcgb3Igc3ZnIGZpbGUuXHJcbiAgICAgKiBAcGFyYW0ge1xyXG4gICAgICogIG5hbWU/OiBzdHJpbmcgLSBmaWxlIG5hbWVcclxuICAgICAqICB0eXBlPzogc3RyaW5nIC0gKHBuZy9zdmcpXHJcbiAgICAgKiB9IG9wdGlvbnNcclxuICAgICovXHJcbiAgICBzZWxmLmV4cG9ydCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XHJcbiAgICAgICAgY29uc3QgZmlsZU5hbWUgPSBvcHRpb25zLm5hbWUgfHwgJ0xHX2xpbmVhZ2VfZGlhZ3JhbV9zbmFwc2hvdF8nICsgZGF0ZTJTdHJpbmcobmV3IERhdGUoKSk7XHJcblxyXG4gICAgICAgIGlmIChvcHRpb25zLnR5cGUgPT09ICdwbmcnKSB7XHJcbiAgICAgICAgICAgIHRvRGF0YVVSTChfcGFwZXIsIHtcclxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3doaXRlJyxcclxuICAgICAgICAgICAgICAgIHN2Z09wdGlvbnM6IHtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50c1RvUmVtb3ZlU2VsZWN0b3I6ICcnLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnZlcnRJbWFnZXNUb0RhdGFVcmlzOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KS50aGVuKGJhc2U2NFVSTCA9PiB7XHJcbiAgICAgICAgICAgICAgICBzYXZlRGF0YShiYXNlNjRVUkwsIGZpbGVOYW1lLCAncG5nJyk7XHJcbiAgICAgICAgICAgIH0pLmNhdGNoKGVycm9yID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZXJyb3IgPT09ICdzdHJpbmcnKSBhbGVydChlcnJvcik7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGFsZXJ0KCdUaGlzIHR5cGUgb2YgZXhwb3J0IGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhlIEludGVybmV0IEV4cGxvcmVyJyk7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZXhwb3J0VG9TVkcoX3BhcGVyLCB7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50c1RvUmVtb3ZlU2VsZWN0b3I6ICcnLFxyXG4gICAgICAgICAgICAgICAgY29udmVydEltYWdlc1RvRGF0YVVyaXM6IHRydWUsXHJcbiAgICAgICAgICAgIH0pLnRoZW4oc3ZnU3RyaW5nID0+IHtcclxuICAgICAgICAgICAgICAgIHNhdmVEYXRhKHN2Z1N0cmluZywgZmlsZU5hbWUsICdzdmcnKTtcclxuICAgICAgICAgICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xyXG4gICAgICAgICAgICAgICAgYWxlcnQoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gc2F2ZURhdGEgKGRhdGEsIGZpbGVOYW1lLCB0eXBlKSB7XHJcbiAgICAgICAgICAgIGxldCBibG9iO1xyXG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ3N2ZycpIHtcclxuICAgICAgICAgICAgICAgIGJsb2IgPSBuZXcgQmxvYihbZGF0YV0sIHsgdHlwZTogdHlwZSB9KTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAncG5nJykge1xyXG4gICAgICAgICAgICAgICAgYmxvYiA9IHBuZzJCbG9iIChkYXRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzYXZlQXMoYmxvYiwgZmlsZU5hbWUgKyAnLicgKyB0eXBlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2hvd3MgcHJpbnQgZGlhbG9nLlxyXG4gICAgKi9cclxuICAgIHNlbGYucHJpbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZXhwb3J0VG9TVkcoX3BhcGVyLCB7XHJcbiAgICAgICAgICAgIHByZXNlcnZlRGltZW5zaW9uczogZmFsc2UsXHJcbiAgICAgICAgICAgIGVsZW1lbnRzVG9SZW1vdmVTZWxlY3RvcjogJycsXHJcbiAgICAgICAgICAgIGNvbnZlcnRJbWFnZXNUb0RhdGFVcmlzOiB0cnVlLFxyXG4gICAgICAgICAgICBwZGZNb2RlOiB0cnVlLFxyXG4gICAgICAgIH0pLnRoZW4oc3ZnU3RyaW5nID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcHJpbnRXaW5kb3cgPSB3aW5kb3cub3BlbignJywgdW5kZWZpbmVkLCAnd2lkdGg9MTI4MCxoZWlnaHQ9NzIwJyk7XHJcbiAgICAgICAgICAgIGlmIChwcmludFdpbmRvdykge1xyXG4gICAgICAgICAgICAgICAgcHJpbnRXaW5kb3cuZG9jdW1lbnQud3JpdGUoc3ZnU3RyaW5nKTtcclxuICAgICAgICAgICAgICAgIHByaW50V2luZG93LmRvY3VtZW50LmNsb3NlKCk7XHJcbiAgICAgICAgICAgICAgICBwcmludFdpbmRvdy5wcmludCgpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYWxlcnQoJ1lvdSBzaG91bGQgdW5ibG9jayBwb3B1cCB3aW5kb3dzIGZvciB0aGUgY3VycmVudCB1cmwgdG8gYmUgYWJsZSB0byBwcmludCB0aGlzIGRpYWdyYW0hJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZpbmUgZGF0YSBjb250YWluZXIgd2l0aCBub2RlcyBhbmQgbGlua3MgZm9yIHRoZSBKb2ludGpzIHZpZXcgKHZpZXctMilcclxuICAgICAqIGFuZCBwYXRoIGl0IHRvIHRoZSBmb3Jtc1xyXG4gICAgICogQHBhcmFtIHtEYXRhQ29udGFpbmVyfSBkYXRhQ29udGFpbmVyIC0gZGF0YSBmb3IgdGhlIGdyYXBoXHJcbiAgICAgKiBAcGFyYW0ge1ZpZXdGcmFtZVB1YmxpY01vZGVsW119IHZpZXdGcmFtZXMgLSB2aWV3IGZyYW1lc1xyXG4gICAgKi9cclxuICAgIHNlbGYuc2V0RGF0YSA9IF9zZXREYXRhO1xyXG5cclxuICAgIHNlbGYuc2V0Um91dGluZyA9IGZ1bmN0aW9uIChyb3V0aW5nSWQpIHtcclxuICAgICAgICBfcm91dGluZ01hbmFnZXIuc2V0Um91dGluZyhyb3V0aW5nSWQpO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLmdldFJvdXRpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9yb3V0aW5nTWFuYWdlci5nZXRSb3V0aW5nKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYuc2NhbGUgPSBmdW5jdGlvbiAoc2NhbGUpIHtcclxuICAgICAgICBpZiAoc2NhbGUpIHtcclxuICAgICAgICAgICAgX3VwZGF0ZVNjYWxlKHNjYWxlKTtcclxuICAgICAgICAgICAgX2xpbWl0Vmlld1BvcnRzUG9zdGlvbnMoX3ZpZXdNYW5hZ2VyLmdldFZpZXdGcmFtZXMoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBfc2NhbGU7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5jcmVhc2VzIHNjYWxlIG9mIHRoZSBncmFwaC5cclxuICAgICAqIEFuZCByZWRyYXcgaXQgYWZ0ZXIgdGhhdC5cclxuICAgICAqL1xyXG4gICAgc2VsZi56b29tSW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgX3VwZGF0ZVNjYWxlKHtcclxuICAgICAgICAgICAgeDogX3NjYWxlLnggKyBfc2NhbGVTdGVwLFxyXG4gICAgICAgICAgICB5OiBfc2NhbGUueSArIF9zY2FsZVN0ZXAsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgX2RlbGF5ZWRSZWRyYXcodW5kZWZpbmVkLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIF9saW1pdFZpZXdQb3J0c1Bvc3Rpb25zKF92aWV3TWFuYWdlci5nZXRWaWV3RnJhbWVzKCkpO1xyXG4gICAgICAgICAgICBzZWxmLnRyaWdnZXIoJ3NjYWxlLWNoYW5nZWQnLCBfc2NhbGUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlY3JlYXNlcyBzY2FsZSBvZiB0aGUgZ3JhcGguXHJcbiAgICAgKiBBbmQgcmVkcmF3IGl0IGFmdGVyIHRoYXQuXHJcbiAgICAgKi9cclxuICAgIHNlbGYuem9vbU91dCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfdXBkYXRlU2NhbGUoe1xyXG4gICAgICAgICAgICB4OiBfc2NhbGUueCAtIF9zY2FsZVN0ZXAsXHJcbiAgICAgICAgICAgIHk6IF9zY2FsZS55IC0gX3NjYWxlU3RlcCxcclxuICAgICAgICB9KTtcclxuICAgICAgICBfZGVsYXllZFJlZHJhdyh1bmRlZmluZWQsICgpID0+IHtcclxuICAgICAgICAgICAgX2xpbWl0Vmlld1BvcnRzUG9zdGlvbnMoX3ZpZXdNYW5hZ2VyLmdldFZpZXdGcmFtZXMoKSk7XHJcbiAgICAgICAgICAgIHNlbGYudHJpZ2dlcignc2NhbGUtY2hhbmdlZCcsIF9zY2FsZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5jcmVhc2VzIHNjYWxlIG9mIHRoZSBncmFwaC5cclxuICAgICAqIEFuZCByZWRyYXcgaXQgYWZ0ZXIgdGhhdC5cclxuICAgICAqL1xyXG4gICAgc2VsZi56b29tVG9GaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY29uc3Qgb3ZlclZpZXdGcmFtZSA9IF92aWV3TWFuYWdlci5nZXRPdmVyVmlld0ZyYW1lKCk7XHJcbiAgICAgICAgY29uc3Qgbm9kZUJvdW5kcyA9IG92ZXJWaWV3RnJhbWUubm9kZUJvdW5kcztcclxuICAgICAgICBjb25zdCB3aWR0aCA9IF9wYXBlci5lbC5jbGllbnRXaWR0aCAtIEZSQU1FX09VVF9NQVJHSU4gKiAyO1xyXG4gICAgICAgIGNvbnN0IGhlaWdodCA9IF9wYXBlci5lbC5jbGllbnRIZWlnaHQgLSBGUkFNRV9PVVRfTUFSR0lOICogMjtcclxuXHJcbiAgICAgICAgY29uc3Qgc2NhbGUgPSBvdmVyVmlld0ZyYW1lLnNjYWxlO1xyXG4gICAgICAgIGNvbnN0IG5lY2Vzc2FyeVNpemUgPSBnbG9iYWxUb1NjYWxlZFNpemUoe1xyXG4gICAgICAgICAgICB3aWR0aDogbm9kZUJvdW5kcy53aWR0aCxcclxuICAgICAgICAgICAgaGVpZ2h0OiBub2RlQm91bmRzLmhlaWdodCxcclxuICAgICAgICB9LCBzY2FsZSk7XHJcbiAgICAgICAgY29uc3QgeFJhdGlvID0gd2lkdGggLyAobmVjZXNzYXJ5U2l6ZS53aWR0aCArIHBhcmFtZXRlcnMuZnJhbWVQYWRkaW5nLnggKiAyKTtcclxuICAgICAgICBjb25zdCB5UmF0aW8gPSBoZWlnaHQgLyAobmVjZXNzYXJ5U2l6ZS5oZWlnaHQgKyBwYXJhbWV0ZXJzLmZyYW1lUGFkZGluZy55ICogMik7XHJcbiAgICAgICAgY29uc3QgbWluUmF0aW8gPSBNYXRoLm1pbih4UmF0aW8sIHlSYXRpbyk7XHJcbiAgICAgICAgX3VwZGF0ZVNjYWxlKHtcclxuICAgICAgICAgICAgeDogX3NjYWxlLnggKiBtaW5SYXRpbyxcclxuICAgICAgICAgICAgeTogX3NjYWxlLnkgKiBtaW5SYXRpbyxcclxuICAgICAgICB9KTtcclxuICAgICAgICBfZGVsYXllZFJlZHJhdyh1bmRlZmluZWQsICgpID0+IHtcclxuICAgICAgICAgICAgX2xpbWl0Vmlld1BvcnRzUG9zdGlvbnMoX3ZpZXdNYW5hZ2VyLmdldFZpZXdGcmFtZXMoKSk7XHJcbiAgICAgICAgICAgIHNlbGYudHJpZ2dlcignc2NhbGUtY2hhbmdlZCcsIF9zY2FsZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIEl0IGNoYW5nZXMgb3JpZW50YXRpb24gb2YgdGhlIGdyYXBoLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9yaWVudGF0aW9uIC0gVmFsdWVzOiAnbGVmdC10by1yaWdodCcsICdyaWdodC10by1sZWZ0JywgJ3RvcC10by1ib3R0b20nLCAnYm90dG9tLXRvLXRvcCdcclxuICAgICAqIEBtZW1iZXJvZiBMaW5lYWdlRGlhZ3JhbVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICovXHJcbiAgICBzZWxmLnNldE9yaWVudGF0aW9uID0gZnVuY3Rpb24gKG9yaWVudGF0aW9uKSB7XHJcbiAgICAgICAgX29yaWVudGF0aW9uID0gb3JpZW50YXRpb247XHJcbiAgICAgICAgX3JlZHJhdygpO1xyXG4gICAgICAgIF92aWV3RnJhbWVzVUkuc2V0T3JpZW50YXRpb24ob3JpZW50YXRpb24pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYWxsIFZpZXdGcmFtZXNcclxuICAgICAqIEBtZW1iZXJvZiBMaW5lYWdlRGlhZ3JhbVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQHJldHVybnMge1ZpZXdGcmFtZVB1YmxpY01vZGVsW119XHJcbiAgICAgKi9cclxuICAgIHNlbGYuZ2V0Vmlld0ZyYW1lcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX3ZpZXdNYW5hZ2VyLmdldFZpZXdGcmFtZXMoKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIG9uZSBWaWV3RnJhbWUgYnkgaWQgXHJcbiAgICAgKiBAbWVtYmVyb2YgTGluZWFnZURpYWdyYW1cclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2aWV3RnJhbWVJZFxyXG4gICAgICogQHJldHVybnMge1ZpZXdGcmFtZVB1YmxpY01vZGVsfVxyXG4gICAgKi9cclxuICAgIHNlbGYuZ2V0Vmlld0ZyYW1lQnlJZCA9IGZ1bmN0aW9uICh2aWV3RnJhbWVJZCkge1xyXG4gICAgICAgIHJldHVybiBfdmlld01hbmFnZXIuZ2V0Vmlld0ZyYW1lQnlJZCh2aWV3RnJhbWVJZCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBvbmUgVmlld0ZyYW1lIGJ5IGlkIFxyXG4gICAgICogQG1lbWJlcm9mIExpbmVhZ2VEaWFncmFtXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAcmV0dXJucyB7Vmlld0ZyYW1lUHVibGljTW9kZWx9XHJcbiAgICAqL1xyXG4gICAgc2VsZi5nZXRPdmVyVmlld0ZyYW1lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfdmlld01hbmFnZXIuZ2V0T3ZlclZpZXdGcmFtZSgpO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLnNldE1hc2sgPSBmdW5jdGlvbiAobWFzaykge1xyXG4gICAgICAgIF9tYXNrID0gbWFzaztcclxuICAgICAgICBfcmVkcmF3KCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYuZ2V0TWFzayA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX21hc2s7XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYuaXNGdWxsU2NyZWVuTW9kZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX3ZpZXdNYW5hZ2VyLmlzRnVsbFNjcmVlbk1vZGUoKTtcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gX3JlZHJhdyAob3B0aW9ucykge1xyXG4gICAgICAgIF9yb3V0aW5nTWFuYWdlci5yZXNldFJvdXRpbmcoKTtcclxuICAgICAgICBfcm91dGluZ01hbmFnZXIuc2V0Qm91bmRzKHtcclxuICAgICAgICAgICAgeDogRlJBTUVfT1VUX01BUkdJTiArIHBhcmFtZXRlcnMuZnJhbWVCb3JkZXJXaWR0aCxcclxuICAgICAgICAgICAgeTogRlJBTUVfT1VUX01BUkdJTiArIHBhcmFtZXRlcnMuZnJhbWVCb3JkZXJXaWR0aCxcclxuICAgICAgICAgICAgd2lkdGg6IF9wYXBlci5lbC5jbGllbnRXaWR0aCAtIChGUkFNRV9PVVRfTUFSR0lOICsgcGFyYW1ldGVycy5mcmFtZUJvcmRlcldpZHRoKSAqIDIsXHJcbiAgICAgICAgICAgIGhlaWdodDogX3BhcGVyLmVsLmNsaWVudEhlaWdodCAtIChGUkFNRV9PVVRfTUFSR0lOICsgcGFyYW1ldGVycy5mcmFtZUJvcmRlcldpZHRoKSAqIDIsXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgICAgIGNvbnN0IHJlbmRlck9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIHZpZXdGcmFtZXM6IG9wdGlvbnMudmlld0ZyYW1lcyxcclxuICAgICAgICAgICAgZnVsbFNjcmVlbk1vZGU6IG9wdGlvbnMuZnVsbFNjcmVlbk1vZGUsXHJcbiAgICAgICAgICAgIHNlbGVjdGVkRWxlbWVudDogX3NlbGVjdGVkRWxlbWVudCxcclxuICAgICAgICAgICAgcGF0aDogX3BhdGgsXHJcbiAgICAgICAgICAgIG1hc2s6IF9tYXNrLFxyXG4gICAgICAgICAgICBxdWlja1VwZGF0ZTogb3B0aW9ucy5xdWlja1VwZGF0ZSxcclxuICAgICAgICAgICAgdXBkYXRlQm91bmRzOiBvcHRpb25zLnVwZGF0ZUJvdW5kcyxcclxuICAgICAgICAgICAgcGFwZXJPcHRpb25zOiB7XHJcbiAgICAgICAgICAgICAgICBvcmllbnRhdGlvbjogX29yaWVudGF0aW9uLFxyXG4gICAgICAgICAgICAgICAgd2lkdGg6IF9wYXBlci5lbC5jbGllbnRXaWR0aCxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogX3BhcGVyLmVsLmNsaWVudEhlaWdodCxcclxuICAgICAgICAgICAgICAgIHNjYWxlOiBfc2NhbGUsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVsZW1lbnRPcHRpb25zOiB7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50U2l6ZTogb3B0aW9ucy5lbGVtZW50U2l6ZSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBpZiAoIXJlbmRlck9wdGlvbnMucXVpY2tVcGRhdGUpIGNsZWFyVGltZW91dChfdGltZW91dFJlZik7XHJcbiAgICAgICAgXHJcbiAgICAgICAgX2dyYXBoLnN0YXJ0QmF0Y2goJ3JlbW92ZScpO1xyXG4gICAgICAgIGlmIChyZW5kZXJPcHRpb25zLnF1aWNrVXBkYXRlKSBfZ3JhcGgucmVtb3ZlQ2VsbHMoX2dyYXBoLmdldExpbmtzKCkpO1xyXG5cclxuICAgICAgICBsZXQgcmVuZGVyRGF0YSA9IF92aWV3TWFuYWdlci5wcmVwYXJlUmVuZGVyRGF0YShyZW5kZXJPcHRpb25zKTtcclxuXHJcbiAgICAgICAgcmVuZGVyRGF0YSA9IF9yZW1vdmVEZXByZWNhdGVkQW5kRXhpc3RpbmdDZWxscyhyZW5kZXJEYXRhKTtcclxuICAgICAgICBfZ3JhcGguc3RvcEJhdGNoKCdyZW1vdmUnKTtcclxuXHJcbiAgICAgICAgX2dyYXBoLnN0YXJ0QmF0Y2goJ2FkZCcpO1xyXG4gICAgICAgIF9ncmFwaC5hZGRDZWxscyhyZW5kZXJEYXRhKTtcclxuICAgICAgICBfZ3JhcGguc3RvcEJhdGNoKCdhZGQnKTtcclxuXHJcbiAgICAgICAgX3VwZGF0ZUhpZ2hsaWdodGluZyhyZW5kZXJEYXRhKTtcclxuICAgICAgICBfdmlld0ZyYW1lc1VJLnJlZnJlc2goKTtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZygnUmVkcmF3JyArIChyZW5kZXJPcHRpb25zLnF1aWNrVXBkYXRlID8gJyAocXVpY2spJyA6ICcnKSk7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IF90aW1lb3V0UmVmID0gMDtcclxuICAgIGxldCBfYmxvY2tNdWx0aXBsZVF1ZXJpZXMgPSBmYWxzZTtcclxuICAgIGZ1bmN0aW9uIF9kZWxheWVkUmVkcmF3IChvcHRpb25zLCBjYWxsYmFjaykge1xyXG4gICAgICAgIGlmIChfYmxvY2tNdWx0aXBsZVF1ZXJpZXMpIHJldHVybjtcclxuICAgICAgICBjbGVhclRpbWVvdXQoX3RpbWVvdXRSZWYpO1xyXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuICAgICAgICBjb25zdCBxdWlja09wdGlvbnMgPSBfLmNsb25lRGVlcChvcHRpb25zKSB8fCB7fTtcclxuICAgICAgICBxdWlja09wdGlvbnMucXVpY2tVcGRhdGUgPSB0cnVlO1xyXG4gICAgICAgIFxyXG4gICAgICAgIF9ibG9ja011bHRpcGxlUXVlcmllcyA9IHRydWU7XHJcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgICAgICAgICAgX2Jsb2NrTXVsdGlwbGVRdWVyaWVzID0gZmFsc2U7IFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIF9yZWRyYXcocXVpY2tPcHRpb25zKTtcclxuXHJcbiAgICAgICAgX3RpbWVvdXRSZWYgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgb3B0aW9ucy5xdWlja1VwZGF0ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhgUmVkcmF3IChkZWxheTpzdGFydC0ke190aW1lb3V0UmVmfSkgPT4gYCk7XHJcbiAgICAgICAgICAgIF9yZWRyYXcob3B0aW9ucyk7XHJcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soKTtcclxuICAgICAgICB9LCAxNTApO1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGBSZWRyYXcgKGRlbGF5OndhaXQtJHtfdGltZW91dFJlZn0pYCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX3JlbW92ZURlcHJlY2F0ZWRBbmRFeGlzdGluZ0NlbGxzIChuZXdDZWxscykge1xyXG4gICAgICAgIGNvbnN0IG9sZENlbGxzID0gX2dyYXBoLmdldENlbGxzKCk7XHJcbiAgICAgICAgY29uc3QgY2VsbE1hcCA9IHt9O1xyXG5cclxuICAgICAgICBuZXdDZWxscy5mb3JFYWNoKGNlbGwgPT4geyBjZWxsTWFwW2NlbGwuaWRdID0gY2VsbDsgfSk7XHJcbiAgICAgICAgb2xkQ2VsbHMuZm9yRWFjaChjZWxsID0+IHtcclxuICAgICAgICAgICAgaWYgKCFjZWxsTWFwW2NlbGwuaWRdKSB7XHJcbiAgICAgICAgICAgICAgICBjZWxsLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIGNlbGxNYXBbY2VsbC5pZF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGNlbGxNYXApLm1hcChrZXkgPT4gY2VsbE1hcFtrZXldKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfdXBkYXRlSGlnaGxpZ2h0aW5nIChjZWxscykge1xyXG4gICAgICAgIGNlbGxzLmZvckVhY2goY2VsbCA9PiB7XHJcbiAgICAgICAgICAgIGlmIChjZWxsLnJlZnJlc2hIaWdobGlnaHRpbmcpIHtcclxuICAgICAgICAgICAgICAgIGNlbGwucmVmcmVzaEhpZ2hsaWdodGluZygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX2NvbWJpbmUgKCkge1xyXG4gICAgICAgIGNvbnN0IHNlbGVjdGVkRWxlbWVudElzTm9kZSA9IF9zZWxlY3RlZEVsZW1lbnQgaW5zdGFuY2VvZiBOb2RlO1xyXG4gICAgICAgIGlmIChzZWxlY3RlZEVsZW1lbnRJc05vZGUpIHtcclxuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWROb2RlID0gX3NlbGVjdGVkRWxlbWVudDtcclxuICAgICAgICAgICAgY29uc3Qgbm9kZU1hcCA9IF9kYXRhQ29udGFpbmVyLm1hcHMubm9kZU1hcDtcclxuICAgICAgICAgICAgY29uc3Qgc291cmNlTWFwID0gX2RhdGFDb250YWluZXIubWFwcy5zb3VyY2VNYXA7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldE1hcCA9IF9kYXRhQ29udGFpbmVyLm1hcHMudGFyZ2V0TWFwO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgcmVsYXRpdmVMaW5rcyA9IChzb3VyY2VNYXBbc2VsZWN0ZWROb2RlLmlkXSB8fCBbXSlcclxuICAgICAgICAgICAgICAgIC5jb25jYXQodGFyZ2V0TWFwW3NlbGVjdGVkTm9kZS5pZF0gfHwgW10pO1xyXG4gICAgICAgICAgICBjb25zdCByZWxhdGl2ZU5vZGVzID0gcmVsYXRpdmVMaW5rcy5tYXAobCA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAobC5tb2RlbC5zb3VyY2UgIT09IHNlbGVjdGVkTm9kZS5pZCkgcmV0dXJuIG5vZGVNYXBbbC5tb2RlbC5zb3VyY2VdOyBlbHNlXHJcbiAgICAgICAgICAgICAgICBpZiAobC5tb2RlbC50YXJnZXQgIT09IHNlbGVjdGVkTm9kZS5pZCkgcmV0dXJuIG5vZGVNYXBbbC5tb2RlbC50YXJnZXRdOyBlbHNlXHJcbiAgICAgICAgICAgICAgICBpZiAobC5tb2RlbC5zb3VyY2UgPT09IGwubW9kZWwudGFyZ2V0KSByZXR1cm4gbm9kZU1hcFtsLm1vZGVsLnNvdXJjZV07XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgbmV3UG9zaXRpb25zID0gY29tYmluZU9wZXJhdGlvbih7XHJcbiAgICAgICAgICAgICAgICBzZWxlY3RlZE5vZGU6IHNlbGVjdGVkTm9kZSxcclxuICAgICAgICAgICAgICAgIHJlbGF0aXZlTGlua3M6IHJlbGF0aXZlTGlua3MsXHJcbiAgICAgICAgICAgICAgICByZWxhdGl2ZU5vZGVzOiByZWxhdGl2ZU5vZGVzLFxyXG4gICAgICAgICAgICAgICAgc2NhbGU6IF9zY2FsZSxcclxuICAgICAgICAgICAgfSwgcGFyYW1ldGVycyk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCB0YXJnZXRWaWV3RnJhbWVJZCA9IGdldFZpZXdGcmFtZUlkRm9yTm9kZShzZWxlY3RlZE5vZGUpO1xyXG4gICAgICAgICAgICBjb25zdCBuZXdQYXRoID0ge307XHJcbiAgICAgICAgICAgIGNvbnN0IGFmZmVjdGVkVmlld0ZyYW1lc01hcCA9IHt9O1xyXG4gICAgICAgICAgICByZWxhdGl2ZU5vZGVzLmZvckVhY2gobm9kZSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJQb3NpdGlvbiA9IGdldEdsb2JhbE5vZGVQb3NpdGlvbihub2RlKTtcclxuICAgICAgICAgICAgICAgIG5vZGUubW9kZWwucG9zaXRpb24gPSBuZXdQb3NpdGlvbnNbbm9kZS5pZF07XHJcbiAgICAgICAgICAgICAgICBfZGF0YUNvbnRhaW5lci51cGRhdGVab25lc0Zvck5vZGUobm9kZSwgY3VyUG9zaXRpb24pO1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHZpZXdGcmFtZSA9IF92aWV3TWFuYWdlci5nZXRWaWV3RnJhbWVGb3JOb2RlKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgYWZmZWN0ZWRWaWV3RnJhbWVzTWFwW3ZpZXdGcmFtZS5pZF0gPSB2aWV3RnJhbWU7XHJcbiAgICAgICAgICAgICAgICBub2RlLnZpZXdGcmFtZU93bmVySWQgPSB0YXJnZXRWaWV3RnJhbWVJZDtcclxuICAgICAgICAgICAgICAgIG5ld1BhdGhbbm9kZS5pZF0gPSBub2RlO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgbmV3UGF0aFtzZWxlY3RlZE5vZGUuaWRdID0gc2VsZWN0ZWROb2RlO1xyXG5cclxuICAgICAgICAgICAgcmVsYXRpdmVMaW5rcy5mb3JFYWNoKGxpbmsgPT4ge1xyXG4gICAgICAgICAgICAgICAgbmV3UGF0aFtsaW5rLmlkXSA9IGxpbms7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgX3BhdGggPSBuZXdQYXRoO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgYWZmZWN0ZWRWaWV3RnJhbWVzID0gT2JqZWN0LmtleXMoYWZmZWN0ZWRWaWV3RnJhbWVzTWFwKS5tYXAoa2V5ID0+IGFmZmVjdGVkVmlld0ZyYW1lc01hcFtrZXldKTtcclxuICAgICAgICAgICAgX3JlZHJhdyh7IHZpZXdGcmFtZXM6IGFmZmVjdGVkVmlld0ZyYW1lcywgdXBkYXRlQm91bmRzOiB0cnVlIH0pO1xyXG4gICAgICAgICAgICBfbGltaXRWaWV3UG9ydHNQb3N0aW9ucyhhZmZlY3RlZFZpZXdGcmFtZXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYWxsIGZyb20gdGhlIHBhcGVyIGJlc2lkZXMgdmlld0ZyYW1lcy5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gX2NsZWFyICgpIHtcclxuICAgICAgICBfdW5zZWxlY3QoKTtcclxuICAgICAgICBfZ3JhcGguY2xlYXIoKTtcclxuICAgICAgICBfdmlld01hbmFnZXIgPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZpbmUgZGF0YSBjb250YWluZXIgd2l0aCBub2RlcyBhbmQgbGlua3MgZm9yIHRoZSBKb2ludGpzIHZpZXcgKHZpZXctMilcclxuICAgICAqIGFuZCBwYXRoIGl0IHRvIHRoZSBmb3Jtc1xyXG4gICAgICogQHBhcmFtIHtEYXRhQ29udGFpbmVyfSBkYXRhQ29udGFpbmVyIC0gZGF0YSBmb3IgdGhlIGdyYXBoXHJcbiAgICAgKiBAcGFyYW0ge1ZpZXdGcmFtZVB1YmxpY01vZGVsW119IHZpZXdGcmFtZXMgLSB2aWV3IGZyYW1lc1xyXG4gICAgKi9cclxuICAgIGZ1bmN0aW9uIF9zZXREYXRhIChkYXRhQ29udGFpbmVyLCB2aWV3RnJhbWVzKSB7XHJcbiAgICAgICAgX2NsZWFyKCk7XHJcblxyXG4gICAgICAgIF9kYXRhQ29udGFpbmVyID0gZGF0YUNvbnRhaW5lcjtcclxuICAgICAgICBfcm91dGluZ01hbmFnZXIgPSBuZXcgUm91dGluZ01hbmFnZXIoe1xyXG4gICAgICAgICAgICBsaW5rczogX2RhdGFDb250YWluZXIubGlua3MsXHJcbiAgICAgICAgICAgIGJvdW5kczoge1xyXG4gICAgICAgICAgICAgICAgeDogRlJBTUVfT1VUX01BUkdJTiArIHBhcmFtZXRlcnMuZnJhbWVCb3JkZXJXaWR0aCxcclxuICAgICAgICAgICAgICAgIHk6IEZSQU1FX09VVF9NQVJHSU4gKyBwYXJhbWV0ZXJzLmZyYW1lQm9yZGVyV2lkdGgsXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogX3BhcGVyLmVsLmNsaWVudFdpZHRoIC0gKEZSQU1FX09VVF9NQVJHSU4gKyBwYXJhbWV0ZXJzLmZyYW1lQm9yZGVyV2lkdGgpICogMixcclxuICAgICAgICAgICAgICAgIGhlaWdodDogX3BhcGVyLmVsLmNsaWVudEhlaWdodCAtIChGUkFNRV9PVVRfTUFSR0lOICsgcGFyYW1ldGVycy5mcmFtZUJvcmRlcldpZHRoKSAqIDIsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfSwgcGFyYW1ldGVycyk7XHJcbiAgICAgICAgX3ZpZXdNYW5hZ2VyID0gbmV3IFZpZXdNYW5hZ2VyKHtcclxuICAgICAgICAgICAgZGF0YUNvbnRhaW5lcjogZGF0YUNvbnRhaW5lcixcclxuICAgICAgICAgICAgdmlld0ZyYW1lczogdmlld0ZyYW1lcyxcclxuICAgICAgICAgICAgZnVsbFNjcmVlbk1vZGU6IF9mdWxsU2NyZWVuTW9kZSxcclxuICAgICAgICB9LCBwYXJhbWV0ZXJzKTtcclxuXHJcbiAgICAgICAgX3ZpZXdGcmFtZXNVSSA9IF9jcmVhdGVWaWV3RnJhbWVzVUkoX3ZpZXdNYW5hZ2VyKTtcclxuXHJcbiAgICAgICAgX3ZpZXdNYW5hZ2VyLm9uKCdjaGFuZ2Utdmlldy1wb3J0LXBvc2l0aW9uJywgdmlld0ZyYW1lID0+IHtcclxuICAgICAgICAgICAgX3JlZHJhdyh7IHZpZXdGcmFtZXM6IFt2aWV3RnJhbWVdLCBxdWlja1VwZGF0ZTogdHJ1ZX0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBfY29ycmVjdFNjYWxlKCk7XHJcbiAgICAgICAgX3JlZHJhdygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZpZXdGcmFtZUlkIFxyXG4gICAgICogQGZpcmVzIHZpZXctZnJhbWVzLXNpemUtb3ItcG9zaXRpb24tY2hhbmdlZFxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBfb3BlblZpZXdGcmFtZSAodmlld0ZyYW1lSWQpIHtcclxuICAgICAgICBjb25zdCB2aWV3RnJhbWUgPSBfdmlld01hbmFnZXIuZ2V0Vmlld0ZyYW1lQnlJZCh2aWV3RnJhbWVJZCk7XHJcbiAgICAgICAgaWYgKCF2aWV3RnJhbWUpIHJldHVybjtcclxuXHJcbiAgICAgICAgdmlld0ZyYW1lLmV4cGFuZGVkID0gdHJ1ZTtcclxuICAgICAgICBjb25zdCB2aWV3RnJhbWVzID0gW3ZpZXdGcmFtZV07XHJcblxyXG4gICAgICAgIF9yZWRyYXcoeyB2aWV3RnJhbWVzOiB2aWV3RnJhbWVzIH0pO1xyXG5cclxuICAgICAgICBzZWxmLnRyaWdnZXIoJ3ZpZXctZnJhbWVzLXN0YXRlLWNoYW5nZWQnLCBbdmlld0ZyYW1lc10pO1xyXG5cclxuICAgICAgICBfbGltaXRWaWV3UG9ydHNQb3N0aW9ucyhfdmlld01hbmFnZXIuZ2V0Vmlld0ZyYW1lcygpLmZpbHRlcih2ZiA9PiB2Zi5hY3RpdmUpKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfY2xvc2VWaWV3RnJhbWUgKHZpZXdGcmFtZUlkKSB7XHJcbiAgICAgICAgY29uc3Qgdmlld0ZyYW1lID0gX3ZpZXdNYW5hZ2VyLmdldFZpZXdGcmFtZUJ5SWQodmlld0ZyYW1lSWQpO1xyXG4gICAgICAgIGlmICghdmlld0ZyYW1lKSByZXR1cm47XHJcblxyXG4gICAgICAgIHZpZXdGcmFtZS5leHBhbmRlZCA9IGZhbHNlO1xyXG4gICAgICAgIGNvbnN0IHZpZXdGcmFtZXMgPSBbdmlld0ZyYW1lXTtcclxuXHJcbiAgICAgICAgX3JlZHJhdyh7IHZpZXdGcmFtZXM6IHZpZXdGcmFtZXMgfSk7XHJcblxyXG4gICAgICAgIHNlbGYudHJpZ2dlcigndmlldy1mcmFtZXMtc3RhdGUtY2hhbmdlZCcsIFt2aWV3RnJhbWVzXSk7XHJcblxyXG4gICAgICAgIF9saW1pdFZpZXdQb3J0c1Bvc3Rpb25zKF92aWV3TWFuYWdlci5nZXRWaWV3RnJhbWVzKCkuZmlsdGVyKHZmID0+IHZmLmFjdGl2ZSkpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIF9zZXRGdWxsU2NyZWVuTW9kZSAodmFsdWUpIHtcclxuICAgICAgICBfZnVsbFNjcmVlbk1vZGUgPSB2YWx1ZTtcclxuXHJcbiAgICAgICAgaWYgKCFfZnVsbFNjcmVlbk1vZGUpIHtcclxuICAgICAgICAgICAgX3NjYWxlID0ge1xyXG4gICAgICAgICAgICAgICAgeDogTWF0aC5tYXgoTWF0aC5taW4oX3NjYWxlLngsIF9zY2FsZUJvdW5kcy5tYXgpLCBfc2NhbGVCb3VuZHMubWluKSxcclxuICAgICAgICAgICAgICAgIHk6IE1hdGgubWF4KE1hdGgubWluKF9zY2FsZS55LCBfc2NhbGVCb3VuZHMubWF4KSwgX3NjYWxlQm91bmRzLm1pbiksXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBfcmVkcmF3KHsgZnVsbFNjcmVlbk1vZGU6IHZhbHVlIH0pO1xyXG5cclxuICAgICAgICBjb25zdCB2aWV3RnJhbWVzID0gX3ZpZXdNYW5hZ2VyLmdldFZpZXdGcmFtZXMoKTtcclxuICAgICAgICBzZWxmLnRyaWdnZXIoJ3ZpZXctZnJhbWVzLXN0YXRlLWNoYW5nZWQnLCBbdmlld0ZyYW1lc10pO1xyXG5cclxuICAgICAgICBpZiAodmFsdWUpIHtcclxuICAgICAgICAgICAgY29uc3Qgb3ZlclZpZXdGcmFtZSA9IF92aWV3TWFuYWdlci5nZXRPdmVyVmlld0ZyYW1lKCk7XHJcbiAgICAgICAgICAgIF9saW1pdFZpZXdQb3J0UG9zdGlvbihvdmVyVmlld0ZyYW1lLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBfcmVkcmF3KCk7XHJcbiAgICAgICAgICAgICAgICBzZWxmLnRyaWdnZXIoJ3ZpZXctZnJhbWVzLXNpemUtb3ItcG9zaXRpb24tY2hhbmdlZCcsIFtbb3ZlclZpZXdGcmFtZV1dKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgX2xpbWl0Vmlld1BvcnRzUG9zdGlvbnModmlld0ZyYW1lcy5maWx0ZXIodmYgPT4gdmYuYWN0aXZlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyBhbmQgbGltaXRzIHZhbHVlIG9mIHRoZSBzY2FsZSBvZiB0aGUgZ3JhcGguXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2NhbGVcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICAgKiA9PT09PT09PT09PT09PT09PVxyXG4gICAgICogQGZpcmVzIHNjYWxlLWNoYW5nZWRcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gX3VwZGF0ZVNjYWxlIChzY2FsZSkge1xyXG4gICAgICAgIGNvbnN0IGZ1bGxTY3JlZW4gPSBfdmlld01hbmFnZXIuaXNGdWxsU2NyZWVuTW9kZSgpO1xyXG5cclxuICAgICAgICBzY2FsZSA9IHNjYWxlIHx8IF9zY2FsZTtcclxuICAgICAgICBpZiAoZnVsbFNjcmVlbikge1xyXG4gICAgICAgICAgICBfc2NhbGUgPSB7XHJcbiAgICAgICAgICAgICAgICB4OiBNYXRoLm1heChNYXRoLm1pbihzY2FsZS54LCBfb3ZlclZpZXdTY2FsZUJvdW5kcy5tYXgpLCBfb3ZlclZpZXdTY2FsZUJvdW5kcy5taW4pLFxyXG4gICAgICAgICAgICAgICAgeTogTWF0aC5tYXgoTWF0aC5taW4oc2NhbGUueSwgX292ZXJWaWV3U2NhbGVCb3VuZHMubWF4KSwgX292ZXJWaWV3U2NhbGVCb3VuZHMubWluKSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBfc2NhbGUgPSB7XHJcbiAgICAgICAgICAgICAgICB4OiBNYXRoLm1heChNYXRoLm1pbihzY2FsZS54LCBfc2NhbGVCb3VuZHMubWF4KSwgX3NjYWxlQm91bmRzLm1pbiksXHJcbiAgICAgICAgICAgICAgICB5OiBNYXRoLm1heChNYXRoLm1pbihzY2FsZS55LCBfc2NhbGVCb3VuZHMubWF4KSwgX3NjYWxlQm91bmRzLm1pbiksXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBfc2NhbGU7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX2NvcnJlY3RTY2FsZSAoKSB7XHJcbiAgICAgICAgY29uc3Qgdmlld0ZyYW1lc051bWJlciA9IF92aWV3TWFuYWdlci5nZXRWaWV3RnJhbWVzKCkubGVuZ3RoO1xyXG4gICAgICAgIGNvbnN0IHdpZHRoID0gX3BhcGVyLmVsLmNsaWVudFdpZHRoIC0gRlJBTUVfT1VUX01BUkdJTiAqIDI7XHJcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gX3BhcGVyLmVsLmNsaWVudEhlaWdodCAtIEZSQU1FX09VVF9NQVJHSU4gKiAyO1xyXG5cclxuICAgICAgICBjb25zdCBjdXRlZFdpZHRoID0gd2lkdGggIC0gRElTVEFOQ0VfQkVUV0VFTl9GUkFNRVMgKiAodmlld0ZyYW1lc051bWJlciAtIDEpO1xyXG4gICAgICAgIGNvbnN0IGN1dGVkSGVpZ2h0ID0gaGVpZ2h0ICAtIERJU1RBTkNFX0JFVFdFRU5fRlJBTUVTICogKHZpZXdGcmFtZXNOdW1iZXIgLSAxKTtcclxuXHJcbiAgICAgICAgY29uc3QgbWluSG9yTnVtID0gNDsgLy8gaXQncyBmb3IgbWF4IHNjYWxlIGJlY2F1c2Ugd2hlbiB3ZSBoYXZlIG1heCBzY2FsZSB3ZSBhbHNvIGhhdmUgbWluaW11bSBub2RlIG51bWJlclxyXG4gICAgICAgIGNvbnN0IG1pblZlcnROdW0gPSAzO1xyXG5cclxuICAgICAgICBjb25zdCBtYXhIb3JOdW0gPSA4OyAvLyBpdCdzIGZvciBtaW4gc2NhbGUgYmVjYXVzZSB3aGVuIHdlIGhhdmUgbWluIHNjYWxlIHdlIGFsc28gaGF2ZSBtYXhpbXVtIG5vZGUgbnVtYmVyXHJcbiAgICAgICAgY29uc3QgbWF4VmVydE51bSA9IDc7XHJcblxyXG4gICAgICAgIGNvbnN0IG5vZGVTaXplID0ge1xyXG4gICAgICAgICAgICB3aWR0aDogcGFyYW1ldGVycy5lbGVtZW50U2l6ZS53aWR0aCxcclxuICAgICAgICAgICAgaGVpZ2h0OiBwYXJhbWV0ZXJzLmVsZW1lbnRTaXplLmhlaWdodCxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IHN0ZXAgPSB7XHJcbiAgICAgICAgICAgIHg6IHBhcmFtZXRlcnMubGF5b3V0U3RlcC54LFxyXG4gICAgICAgICAgICB5OiBwYXJhbWV0ZXJzLmxheW91dFN0ZXAueSxcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBjb25zdCBtaW5TY2FsZSA9IGdldFNjYWxlRm9yTm9kZU51bWJlciAobWF4SG9yTnVtLCBtYXhWZXJ0TnVtKTtcclxuICAgICAgICBjb25zdCBtYXhTY2FsZSA9IGdldFNjYWxlRm9yTm9kZU51bWJlciAobWluSG9yTnVtLCBtaW5WZXJ0TnVtKTtcclxuXHJcbiAgICAgICAgLy8gcGFyYW1ldGVycy5kZWZhdWx0U2NhbGUgPSBzY2FsZTtcclxuICAgICAgICBfc2NhbGVCb3VuZHMubWluID0gTWF0aC5tYXgobWluU2NhbGUueCwgbWluU2NhbGUueSk7XHJcbiAgICAgICAgX3NjYWxlQm91bmRzLm1heCA9IE1hdGgubWluKG1heFNjYWxlLngsIG1heFNjYWxlLnkpO1xyXG4gICAgICAgIC8vIF9zZXRTY2FsZShzY2FsZSk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGdldFNjYWxlRm9yTm9kZU51bWJlciAoaG9yTnVtLCB2ZXJ0TnVtKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1clhWYWx1ZSA9IGhvck51bSAqIG5vZGVTaXplLndpZHRoICsgKGhvck51bSAtIDEpICogc3RlcC54O1xyXG4gICAgICAgICAgICBjb25zdCBjdXJZVmFsdWUgPSB2ZXJ0TnVtICogbm9kZVNpemUuaGVpZ2h0ICsgKGhvck51bSAtIDEpICogc3RlcC55O1xyXG5cclxuICAgICAgICAgICAgbGV0IHNjYWxlO1xyXG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoY3V0ZWRXaWR0aCAtIGN1clhWYWx1ZSkgPj0gTWF0aC5hYnMoY3V0ZWRIZWlnaHQgLSBjdXJZVmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICBzY2FsZSA9IHtcclxuICAgICAgICAgICAgICAgICAgICB4OiBjdXRlZFdpZHRoIC8gY3VyWFZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgIHk6IGN1dGVkV2lkdGggLyBjdXJYVmFsdWUsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc2NhbGUgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeDogY3V0ZWRIZWlnaHQgLyBjdXJZVmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgeTogY3V0ZWRIZWlnaHQgLyBjdXJZVmFsdWUsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gc2NhbGU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIF9maW5kTmV4dE5vZGUgKGRpcmVjdGlvbikge1xyXG4gICAgICAgIGlmICghX3NlbGVjdGVkRWxlbWVudCkgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICBsZXQgY3VyUG9zO1xyXG4gICAgICAgIGlmIChfc2VsZWN0ZWRFbGVtZW50IGluc3RhbmNlb2YgTm9kZSkge1xyXG4gICAgICAgICAgICBjdXJQb3MgPSBnZXRHbG9iYWxOb2RlUG9zaXRpb24oX3NlbGVjdGVkRWxlbWVudCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3Qgc291cmNlID0gX2RhdGFDb250YWluZXIubWFwcy5ub2RlTWFwW19zZWxlY3RlZEVsZW1lbnQubW9kZWwuc291cmNlXTtcclxuICAgICAgICAgICAgY29uc3Qgc291cmNlUG9zID0gc291cmNlLm1vZGVsLnBvc2l0aW9uO1xyXG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSBfZGF0YUNvbnRhaW5lci5tYXBzLm5vZGVNYXBbX3NlbGVjdGVkRWxlbWVudC5tb2RlbC50YXJnZXRdO1xyXG4gICAgICAgICAgICBjb25zdCB0YXJnZXRQb3MgPSB0YXJnZXQubW9kZWwucG9zaXRpb247XHJcbiAgICAgICAgICAgIGlmIChkaXJlY3Rpb24gPT09IERJUkVDVElPTi5VUCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5tb2RlbC55IDwgdGFyZ2V0Lm1vZGVsLnkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc291cmNlO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gRElSRUNUSU9OLkRPV04pIHtcclxuICAgICAgICAgICAgICAgIGlmIChzb3VyY2UubW9kZWwueSA+IHRhcmdldC5tb2RlbC55KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09IERJUkVDVElPTi5MRUZUKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlUG9zLnggPCB0YXJnZXRQb3MueCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzb3VyY2U7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSBESVJFQ1RJT04uUklHSFQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChzb3VyY2VQb3MueCA+IHRhcmdldFBvcy54KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IHByZXZOb2RlcyA9IFtdOyAvLyB0byBicmVhayBjeWNsaW5nXHJcbiAgICAgICAgcmV0dXJuIGdldE5leHROb2RlKGN1clBvcyk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGdldE5leHROb2RlIChjdXJQb3MpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gZGlmZlRvTm9kZSAobm9kZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZVBvc2l0aW9uID0gZ2V0R2xvYmFsTm9kZVBvc2l0aW9uKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICB4OiBjdXJQb3MueCAtIG5vZGVQb3NpdGlvbi54LFxyXG4gICAgICAgICAgICAgICAgICAgIHk6IGN1clBvcy55IC0gbm9kZVBvc2l0aW9uLnksXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjb25zdCBYX1NURVAgPSBwYXJhbWV0ZXJzLmRhdGFab25lU2l6ZS53aWR0aDtcclxuICAgICAgICAgICAgY29uc3QgWV9TVEVQID0gcGFyYW1ldGVycy5kYXRhWm9uZVNpemUuaGVpZ2h0O1xyXG4gICAgICAgICAgICBjb25zdCByZWN0ID0ge1xyXG4gICAgICAgICAgICAgICAgeDogY3VyUG9zLnggLSBYX1NURVAgLyAyLFxyXG4gICAgICAgICAgICAgICAgeTogY3VyUG9zLnkgLSBZX1NURVAgLyAyLFxyXG4gICAgICAgICAgICAgICAgd2lkdGg6IFhfU1RFUCxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogWV9TVEVQLFxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgY29uc3Qgbm9kZXMgPSBfZGF0YUNvbnRhaW5lci5nZXRFbGVtZW50c0ZvclJlY3RhbmdsZShyZWN0KS5ub2Rlc1xyXG4gICAgICAgICAgICAgICAgLmZpbHRlcihuID0+IHByZXZOb2Rlcy5pbmRleE9mKG4pID09PSAtMSk7XHJcbiAgICAgICAgICAgIGlmIChub2Rlcy5sZW5ndGggPT09IDApIHJldHVybiBfc2VsZWN0ZWRFbGVtZW50O1xyXG4gICAgICAgICAgICBwcmV2Tm9kZXMgPSBub2RlcztcclxuXHJcbiAgICAgICAgICAgIGxldCBuZXh0RWxlbWVudHM7XHJcbiAgICAgICAgICAgIGlmIChkaXJlY3Rpb24gPT09IERJUkVDVElPTi5VUCkge1xyXG4gICAgICAgICAgICAgICAgbmV4dEVsZW1lbnRzID0gbm9kZXMuZmlsdGVyKG4gPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpc3QgPSBkaWZmVG9Ob2RlKG4pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoZGlzdC55ID4gMCkgJiYgKE1hdGguYWJzKGRpc3QueSkgPiBNYXRoLmFicyhkaXN0LngpKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5leHRFbGVtZW50cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0TmV4dE5vZGUoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBjdXJQb3MueCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeTogY3VyUG9zLnkgLSBZX1NURVAsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSBESVJFQ1RJT04uRE9XTikge1xyXG4gICAgICAgICAgICAgICAgbmV4dEVsZW1lbnRzID0gbm9kZXMuZmlsdGVyKG4gPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpc3QgPSBkaWZmVG9Ob2RlKG4pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoZGlzdC55IDwgMCkgJiYgKE1hdGguYWJzKGRpc3QueSkgPiBNYXRoLmFicyhkaXN0LngpKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5leHRFbGVtZW50cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0TmV4dE5vZGUoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBjdXJQb3MueCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeTogY3VyUG9zLnkgKyBZX1NURVAsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSBESVJFQ1RJT04uTEVGVCkge1xyXG4gICAgICAgICAgICAgICAgbmV4dEVsZW1lbnRzID0gbm9kZXMuZmlsdGVyKG4gPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpc3QgPSBkaWZmVG9Ob2RlKG4pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoZGlzdC54ID4gMCkgJiYgKE1hdGguYWJzKGRpc3QueSkgPCBNYXRoLmFicyhkaXN0LngpKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5leHRFbGVtZW50cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0TmV4dE5vZGUoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBjdXJQb3MueCAtIFhfU1RFUCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeTogY3VyUG9zLnksXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSBESVJFQ1RJT04uUklHSFQpIHtcclxuICAgICAgICAgICAgICAgIG5leHRFbGVtZW50cyA9IG5vZGVzLmZpbHRlcihuID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkaXN0ID0gZGlmZlRvTm9kZShuKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGRpc3QueCA8IDApICYmIChNYXRoLmFicyhkaXN0LnkpIDwgTWF0aC5hYnMoZGlzdC54KSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGlmIChuZXh0RWxlbWVudHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldE5leHROb2RlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeDogY3VyUG9zLnggKyBYX1NURVAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IGN1clBvcy55LFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG5leHRFbGVtZW50cy5zb3J0KChhLGIpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFQb3MgPSBnZXRHbG9iYWxOb2RlUG9zaXRpb24oYSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBiUG9zID0gZ2V0R2xvYmFsTm9kZVBvc2l0aW9uKGIpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYURpc3QgPSBnZXREaXN0KGFQb3MsIGN1clBvcyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBiRGlzdCA9IGdldERpc3QoYlBvcywgY3VyUG9zKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoYURpc3QgPiBiRGlzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhRGlzdCA8IGJEaXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXh0RWxlbWVudHNbMF07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3Vic2NyaWJlcyBvbiBwYXBlciBhbmQgS2V5Ym9hcmQgZXZlbnRzLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBfc3Vic2NyaWJlT25FdmVudHMgKCkge1xyXG4gICAgICAgIGxldCBxdWVyeUFuaW1hdGlvbkZyYW1lO1xyXG5cclxuICAgICAgICBfcGFwZXIub24oJ2xpbms6b3B0aW9ucycsIChjZWxsVmlldywgZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbGlua1R5cGUgPSBldmVudC50YXJnZXQucGFyZW50Tm9kZS5nZXRBdHRyaWJ1dGUoJ2xpbmtUeXBlJyk7XHJcbiAgICAgICAgICAgIHNlbGYudHJpZ2dlcignbGluay1vcHRpb25zLWNsaWNrJywge1xyXG4gICAgICAgICAgICAgICAgbGluazogY2VsbFZpZXcubW9kZWwsXHJcbiAgICAgICAgICAgICAgICBsaW5rVHlwZTogbGlua1R5cGUsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBfa2V5Ym9hcmQub24oe1xyXG4gICAgICAgICAgICAndXAgZG93biBsZWZ0IHJpZ2h0JzogKGV2dCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUocXVlcnlBbmltYXRpb25GcmFtZSk7XHJcbiAgICAgICAgICAgICAgICBxdWVyeUFuaW1hdGlvbkZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBfc2VsZWN0KF9maW5kTmV4dE5vZGUoZXZ0LmtleUNvZGUpLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBsZXQgX2NsaWNrQ291bnRlciA9IDA7XHJcbiAgICAgICAgX3BhcGVyLm9uKCdjZWxsOnBvaW50ZXJ1cCcsIChjZWxsVmlldywgZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgaXNWaWV3RnJhbWUgPSBjZWxsVmlldy5tb2RlbCBpbnN0YW5jZW9mIFZpZXdGcmFtZTtcclxuICAgICAgICAgICAgaWYgKGlzVmlld0ZyYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBvblNpbmdsZUNsaWNrKGNlbGxWaWV3LCBldmVudCk7XHJcbiAgICAgICAgICAgICAgICBfY2xpY2tDb3VudGVyID0gMDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChfY2xpY2tDb3VudGVyID4gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9uRG91YmxlQ2xpY2soY2VsbFZpZXcsIGV2ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICBfY2xpY2tDb3VudGVyID0gMDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfY2xpY2tDb3VudGVyID09PSAxKSBvblNpbmdsZUNsaWNrKGNlbGxWaWV3LCBldmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jbGlja0NvdW50ZXIgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sIDIwMCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIG9uU2luZ2xlQ2xpY2sgKGNlbGxWaWV3LCBldmVudCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaXNEcmFnZ2luZyA9IE1hdGguYWJzKF9tb3VzZURvd25Qb3NpdGlvbi54IC0gZXZlbnQucGFnZVgpID4gNSB8fCBNYXRoLmFicyhfbW91c2VEb3duUG9zaXRpb24ueSAtIGV2ZW50LnBhZ2VZKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNlbGwgPSBjZWxsVmlldy5tb2RlbDtcclxuICAgICAgICAgICAgICAgIGlmIChjZWxsIGluc3RhbmNlb2YgVmlld0ZyYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgdmlld0ZyYW1lID0gX3ZpZXdNYW5hZ2VyLmdldFZpZXdGcmFtZUJ5SWQoY2VsbC5pZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVmlld0ZyYW1lIGNsaWNrXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzRHJhZ2dpbmcpIF91bnNlbGVjdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF9saW1pdFZpZXdQb3J0UG9zdGlvbih2aWV3RnJhbWUsICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3JlZHJhdygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnRyaWdnZXIoJ3ZpZXctZnJhbWVzLXNpemUtb3ItcG9zaXRpb24tY2hhbmdlZCcsIFtbX3ZpZXdNYW5hZ2VyLmdldFZpZXdGcmFtZUJ5SWQoY2VsbC5pZCldXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTm9kZS9MaW5rIGNsaWNrXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkcmFnZ2luZ05vZGUgPSBpc0RyYWdnaW5nICYmIChjZWxsIGluc3RhbmNlb2YgTm9kZSB8fCBjZWxsIGluc3RhbmNlb2YgVGVybWluYXRpb25Ob2RlKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjbGlja1Rlcm1pbmF0aW9uTm9kZSA9IGNlbGwgaW5zdGFuY2VvZiBUZXJtaW5hdGlvbk5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2xpY2tPbk5vZGVPckxpbmsgPSAhKGNlbGwgaW5zdGFuY2VvZiBBc3BlY3RMaW5rKTsgLy8gRXhjbHVkZSBBc3BlY3RMaW5rXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRyYWdnaW5nTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdXBkYXRlTm9kZXNQb3NpdGlvbnMoW2NlbGxdKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNsaWNrVGVybWluYXRpb25Ob2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zZWxlY3QoY2VsbCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjbGlja09uTm9kZU9yTGluaykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfc2VsZWN0KGNlbGwpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc2VsZi50cmlnZ2VyKCdjZWxsLXNpbmdsZS1jbGljaycsIGNlbGxWaWV3Lm1vZGVsKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gb25Eb3VibGVDbGljayAoY2VsbFZpZXcpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBjZWxsVmlldy5tb2RlbDtcclxuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50IGluc3RhbmNlb2YgTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc2V0KCdleHBhbmRlZCcsICFjZWxsVmlldy5tb2RlbC5nZXQoJ2V4cGFuZGVkJykpO1xyXG4gICAgICAgICAgICAgICAgICAgIF91cGRhdGVOb2Rlc1Bvc2l0aW9ucyhbZWxlbWVudF0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc2VsZi50cmlnZ2VyKCdjZWxsLWRvdWJsZS1jbGljaycsIGNlbGxWaWV3Lm1vZGVsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBsZXQgX21vdXNlRG93blBvc2l0aW9uID0geyB4OiAwLCB5OiAwIH07XHJcbiAgICAgICAgX3BhcGVyLm9uKCdjZWxsOnBvaW50ZXJkb3duJywgKGNlbGwsIGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIF9tb3VzZURvd25Qb3NpdGlvbiA9IHsgeDogZXZlbnQucGFnZVgsIHk6IGV2ZW50LnBhZ2VZIH07XHJcbiAgICAgICAgICAgIF9jbGlja0NvdW50ZXIrKztcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgX3BhcGVyLm9uKCdjZWxsOm1vdXNld2hlZWwnLCAoY2VsbCwgZXZ0LCB4LCB5LCBkZWx0YSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBTQ1JPTExfU1RFUCA9IDEwMDtcclxuICAgICAgICAgICAgbGV0IHZpZXdGcmFtZSA9IF92aWV3TWFuYWdlci5nZXRWaWVGcmFtZUJ5U2NyZWVuUG9pbnQoeyB4OiB4LCB5OiB5IH0pO1xyXG5cclxuICAgICAgICAgICAgaWYgKHZpZXdGcmFtZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGV2dC5zaGlmdEtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZpZXdGcmFtZS52aWV3UG9ydFBvc2l0aW9uLnggKz0gKGRlbHRhIDwgMCA/IDEgOiAtMSkgKiBTQ1JPTExfU1RFUDtcclxuICAgICAgICAgICAgICAgICAgICB2aWV3RnJhbWUudmlld1BvcnRQb3NpdGlvbiA9IGxpbWl0UG9pbnRQb3NpdGlvbih2aWV3RnJhbWUudmlld1BvcnRQb3NpdGlvbiwgdmlld0ZyYW1lLnZpZXdQb3J0UG9zaXRpb25Cb3VuZHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIF9kZWxheWVkUmVkcmF3KHsgdmlld0ZyYW1lczogW3ZpZXdGcmFtZV0gfSwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnRyaWdnZXIoJ3ZpZXctZnJhbWVzLXNpemUtb3ItcG9zaXRpb24tY2hhbmdlZCcsIFtbdmlld0ZyYW1lXV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChldnQuY3RybEtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpZmYgPSAoZGVsdGEgPiAwID8gX3NjYWxlU3RlcCA6IC1fc2NhbGVTdGVwKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzY2FsZSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeDogX3NjYWxlLnggKyBkaWZmLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBfc2NhbGUueSArIGRpZmYsXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICBfdXBkYXRlU2NhbGUoc2NhbGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIF9kZWxheWVkUmVkcmF3KHVuZGVmaW5lZCwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfbGltaXRWaWV3UG9ydHNQb3N0aW9ucyhfdmlld01hbmFnZXIuZ2V0Vmlld0ZyYW1lcygpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi50cmlnZ2VyKCdzY2FsZS1jaGFuZ2VkJywgc2NhbGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2aWV3RnJhbWUudmlld1BvcnRQb3NpdGlvbi55ICs9IChkZWx0YSA8IDAgPyAxIDogLTEpICogU0NST0xMX1NURVA7XHJcbiAgICAgICAgICAgICAgICAgICAgdmlld0ZyYW1lLnZpZXdQb3J0UG9zaXRpb24gPSBsaW1pdFBvaW50UG9zaXRpb24odmlld0ZyYW1lLnZpZXdQb3J0UG9zaXRpb24sIHZpZXdGcmFtZS52aWV3UG9ydFBvc2l0aW9uQm91bmRzKTtcclxuICAgICAgICAgICAgICAgICAgICBfZGVsYXllZFJlZHJhdyh7IHZpZXdGcmFtZXM6IFt2aWV3RnJhbWVdIH0sICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi50cmlnZ2VyKCd2aWV3LWZyYW1lcy1zaXplLW9yLXBvc2l0aW9uLWNoYW5nZWQnLCBbW3ZpZXdGcmFtZV1dKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHdpbmRvdy5vbnJlc2l6ZSA9ICgpID0+IHtcclxuICAgICAgICAgICAgX2NvcnJlY3RTY2FsZSgpO1xyXG4gICAgICAgICAgICBfZGVsYXllZFJlZHJhdyh1bmRlZmluZWQsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHNlbGYudHJpZ2dlcignc2NhbGUtY2hhbmdlZCcpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIF91cGRhdGVOb2Rlc1Bvc2l0aW9ucyAobm9kZXMpIHtcclxuICAgICAgICBjb25zdCBjaGFuZ2VkVmlld0ZyYW1lcyA9IFtdO1xyXG4gICAgICAgIGNvbnN0IG92ZXJWaWV3RnJhbWUgPSBfdmlld01hbmFnZXIuZ2V0T3ZlclZpZXdGcmFtZSgpO1xyXG5cclxuICAgICAgICBub2Rlcy5mb3JFYWNoKG4gPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBub2RlID0gZ2V0QmFzZUVsZW1lbnQobik7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzVGVybWluYXRpb25Ob2RlID0gbiBpbnN0YW5jZW9mIFRlcm1pbmF0aW9uTm9kZTtcclxuICAgICAgICAgICAgY29uc3Qgdmlld0ZyYW1lQnlQb3NpdGlvbiA9IF92aWV3TWFuYWdlci5nZXRWaWVGcmFtZUZvck5vZGVCeVBvc2l0aW9uKG4pO1xyXG5cclxuICAgICAgICAgICAgbGV0IHByZXZPd25lckZyYW1lID0gX3ZpZXdNYW5hZ2VyLmdldFZpZXdGcmFtZU93bmVyKG5vZGUpIHx8IG92ZXJWaWV3RnJhbWU7XHJcbiAgICAgICAgICAgIGxldCB2aWV3RnJhbWU7XHJcblxyXG4gICAgICAgICAgICB2aWV3RnJhbWUgPSB2aWV3RnJhbWVCeVBvc2l0aW9uIHx8IHByZXZPd25lckZyYW1lO1xyXG4gICAgICAgICAgICBjb25zdCBkcmFnZ2VkRWxlbWVudFBvc2l0aW9uID0gbi5wb3NpdGlvbigpOyAvLyBjb3VsZCBiZSB0ZXJtaW5hdGlvbiBub2RlXHJcblxyXG4gICAgICAgICAgICBpZiAoaXNUZXJtaW5hdGlvbk5vZGUpIHtcclxuICAgICAgICAgICAgICAgIGRyYWdnZWRFbGVtZW50UG9zaXRpb24ueCAtPSAobm9kZS5zaXplLndpZHRoIC0gbi5zaXplLndpZHRoKSAvIDI7XHJcbiAgICAgICAgICAgICAgICBkcmFnZ2VkRWxlbWVudFBvc2l0aW9uLnkgLT0gKG5vZGUuc2l6ZS5oZWlnaHQgLSBuLnNpemUuaGVpZ2h0KSAvIDI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbnN0IG5ld0dsb2JhbFBvc2l0aW9uID0gbG9jYWxUb0dsb2JhbFBvaW50KFxyXG4gICAgICAgICAgICAgICAgZHJhZ2dlZEVsZW1lbnRQb3NpdGlvbixcclxuICAgICAgICAgICAgICAgIF9mdWxsU2NyZWVuTW9kZSA/IG92ZXJWaWV3RnJhbWUuc2NhbGUgOiB2aWV3RnJhbWUuc2NhbGUsXHJcbiAgICAgICAgICAgICAgICBfZnVsbFNjcmVlbk1vZGUgPyBvdmVyVmlld0ZyYW1lIDogdmlld0ZyYW1lLFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBjb25zdCBvbGRHbG9iYWxQb3NpdGlvbiA9IGdldEdsb2JhbE5vZGVQb3NpdGlvbihub2RlKTtcclxuXHJcbiAgICAgICAgICAgIG5vZGUubW9kZWwucG9zaXRpb24gPSBuZXdHbG9iYWxQb3NpdGlvbjtcclxuICAgICAgICAgICAgbm9kZS52aWV3RnJhbWVPd25lcklkID0gdmlld0ZyYW1lLmlkO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgX2RhdGFDb250YWluZXIudXBkYXRlWm9uZXNGb3JOb2RlKG5vZGUsIG9sZEdsb2JhbFBvc2l0aW9uKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGFkZGVkRnJhbWVJZHMgPSBjaGFuZ2VkVmlld0ZyYW1lcy5tYXAodmYgPT4gdmYuaWQpO1xyXG4gICAgICAgICAgICBjb25zdCBwcmV2T3duZXJOb3RBZGRlZEluTGlzdCA9IGFkZGVkRnJhbWVJZHMuaW5kZXhPZihwcmV2T3duZXJGcmFtZS5pZCkgPT09IC0xO1xyXG4gICAgICAgICAgICBjb25zdCB2aWV3RnJhbWVOb3RBZGRlZEluTGlzdCA9IGFkZGVkRnJhbWVJZHMuaW5kZXhPZih2aWV3RnJhbWUuaWQpID09PSAtMTtcclxuICAgICAgICAgICAgaWYgKHByZXZPd25lck5vdEFkZGVkSW5MaXN0ICYmIHByZXZPd25lckZyYW1lLmFjdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgcHJldk93bmVyRnJhbWUudXBkYXRlQm91bmRzID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGNoYW5nZWRWaWV3RnJhbWVzLnB1c2gocHJldk93bmVyRnJhbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh2aWV3RnJhbWVOb3RBZGRlZEluTGlzdCAmJiB2aWV3RnJhbWUuYWN0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICB2aWV3RnJhbWUudXBkYXRlQm91bmRzID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGNoYW5nZWRWaWV3RnJhbWVzLnB1c2godmlld0ZyYW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpZiAoX2Z1bGxTY3JlZW5Nb2RlKSB7XHJcbiAgICAgICAgICAgIG92ZXJWaWV3RnJhbWUudXBkYXRlQm91bmRzID0gdHJ1ZTtcclxuICAgICAgICAgICAgY2hhbmdlZFZpZXdGcmFtZXMucHVzaChvdmVyVmlld0ZyYW1lKTtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICBfcmVkcmF3KHsgdmlld0ZyYW1lczogY2hhbmdlZFZpZXdGcmFtZXMgfSk7XHJcbiAgICAgICAgX2xpbWl0Vmlld1BvcnRzUG9zdGlvbnMoY2hhbmdlZFZpZXdGcmFtZXMsICgpID0+IHtcclxuICAgICAgICAgICAgc2VsZi50cmlnZ2VyKCdub2Rlcy1wb3NpdGlvbi1jaGFuZ2VkJywgW25vZGVzXSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIHVpIGZvciBWaWV3RnJhbWVzLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBfY3JlYXRlVmlld0ZyYW1lc1VJICh2aWV3TWFuYWdlcikge1xyXG4gICAgICAgIGlmIChfYmFzZS51aSkge1xyXG4gICAgICAgICAgICBjb25zdCB2aWV3RnJhbWVzVUkgPSBuZXcgVmlld0ZyYW1lc1VJKHtcclxuICAgICAgICAgICAgICAgIHJvb3RFbDogX2Jhc2UudWksXHJcbiAgICAgICAgICAgICAgICB2aWV3TWFuYWdlcjogdmlld01hbmFnZXIsXHJcbiAgICAgICAgICAgIH0sIHBhcmFtZXRlcnMpO1xyXG5cclxuICAgICAgICAgICAgdmlld0ZyYW1lc1VJLm9uKCdzcGxpdHRlci1wb3NpdGlvbi1jaGFuZ2VkJywgKHMsIGRpZmZPYmopID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGlzSG9yaXpvbnRhbE9yaWVudGF0ZWQgPSBfb3JpZW50YXRpb24gPT09ICdsZWZ0LXRvLXJpZ2h0JyB8fCBfb3JpZW50YXRpb24gPT09ICdyaWdodC10by1sZWZ0JztcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRpZmYgPSBkaWZmT2JqLmRpZmY7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2ZkEgPSBzLm1vZGVsLnZpZXdGcmFtZUE7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2ZkIgPSBzLm1vZGVsLnZpZXdGcmFtZUI7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0aGVyZUlzRGlmZmVyZW5jZSA9IGRpZmYgIT09IHVuZGVmaW5lZCAmJiBkaWZmICE9PSBudWxsO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoZXJlSXNEaWZmZXJlbmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzSG9yaXpvbnRhbE9yaWVudGF0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmZBLnNpemUud2lkdGggKz0gZGlmZjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmZCLnNpemUud2lkdGggLT0gZGlmZjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmZCLnBvc2l0aW9uLnggKz0gZGlmZjtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZkEuc2l6ZS5oZWlnaHQgKz0gZGlmZjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmZCLnNpemUuaGVpZ2h0IC09IGRpZmY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZmQi5wb3NpdGlvbi55ICs9IGRpZmY7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZmQS5jdXN0b21lU2l6ZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmZCLmN1c3RvbWVTaXplZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChkaWZmT2JqLmxhc3RDaGFuZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBfcmVkcmF3KHsgdmlld0ZyYW1lczogW3ZmQSwgdmZCXSwgcXVpY2tVcGRhdGU6IGZhbHNlIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIF9saW1pdFZpZXdQb3J0c1Bvc3Rpb25zKFt2ZkEsIHZmQl0pO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGVyZUlzRGlmZmVyZW5jZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIF9yZWRyYXcoeyB2aWV3RnJhbWVzOiBbdmZBLCB2ZkJdLCBxdWlja1VwZGF0ZTogdHJ1ZSB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICB2aWV3RnJhbWVzVUkub24oJ3ZpZXctcG9ydC1wb3NpdGlvbi1jaGFuZ2VkJywgKHZpZXdGcmFtZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVsZXZhbnRWaWV3RnJhbWUgPSBfdmlld01hbmFnZXIuZ2V0Vmlld0ZyYW1lQnlJZCh2aWV3RnJhbWUuaWQpO1xyXG4gICAgICAgICAgICAgICAgX3Bvc2l0aW9uVmlld1BvcnQocmVsZXZhbnRWaWV3RnJhbWUsIHZpZXdGcmFtZS52aWV3UG9ydFBvc2l0aW9uLCBwYXJhbWV0ZXJzLmFuaW1hdGlvbiwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoYW5nZWRWaWV3RnJhbWUgPSBfdmlld01hbmFnZXIuZ2V0Vmlld0ZyYW1lQnlJZCh2aWV3RnJhbWUuaWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYudHJpZ2dlcigndmlldy1mcmFtZXMtc2l6ZS1vci1wb3NpdGlvbi1jaGFuZ2VkJywgW1tjaGFuZ2VkVmlld0ZyYW1lXV0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgdmlld0ZyYW1lc1VJLm9uKCd2aWV3LWZyYW1lLWNvbGxhcHNlZCcsIHZpZXdGcmFtZSA9PiB7XHJcbiAgICAgICAgICAgICAgICB2aWV3RnJhbWUuZXhwYW5kZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIF9jbG9zZVZpZXdGcmFtZSh2aWV3RnJhbWUuaWQpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB2aWV3RnJhbWVzVUk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgICAvKipcclxuICAgICAqIENyZWF0ZXMgaHRtbCBiYXNlIGZvciBkaWFncmFtLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBfY3JlYXRlQmFzZSAoYmFzZURpdikge1xyXG4gICAgICAgIGJhc2VEaXYuaW5uZXJIVE1MID0gJyc7XHJcblxyXG4gICAgICAgIGNvbnN0IGRpYWdyYW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTtcclxuICAgICAgICBkaWFncmFtLmNsYXNzTmFtZSA9ICd0cS1sZy1saW5lYWdlLWRpYWdyYW0nO1xyXG4gICAgICAgIGRpYWdyYW0uaWQgPSAndHFfbGluZWFnZS1ncmFwaCc7XHJcbiAgICAgICAgYmFzZURpdi5hcHBlbmRDaGlsZChkaWFncmFtKTtcclxuXHJcbiAgICAgICAgY29uc3QgdWkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTtcclxuICAgICAgICB1aS5jbGFzc05hbWUgPSAndHEtbGctbGluZWFnZS11aSc7XHJcbiAgICAgICAgYmFzZURpdi5hcHBlbmRDaGlsZCh1aSk7XHJcblxyXG4gICAgICAgIHJldHVybiB7IHVpLCBkaWFncmFtIH07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhcnMgc2VsZWN0ZWQgb2JqZWN0LlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBzaWxlbnQgLSBibG9ja3MgdGhyb3dpbmcgb2YgZXZlbnRcclxuICAgICAqIEBmaXJlcyBzZWxlY3RlZC1lbGVtZW50LWNoYW5nZWRcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gX3Vuc2VsZWN0IChzaWxlbnQpIHtcclxuICAgICAgICBpZiAoX3NlbGVjdGVkRWxlbWVudCkge1xyXG4gICAgICAgICAgICBfcGF0aCA9IG51bGw7XHJcbiAgICAgICAgICAgIF9zZWxlY3RlZEVsZW1lbnQudW5zZWxlY3QoKTtcclxuICAgICAgICAgICAgX3NlbGVjdGVkRWxlbWVudCA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICBpZiAoIXNpbGVudCkge1xyXG4gICAgICAgICAgICAgICAgX3JlZHJhdygpO1xyXG4gICAgICAgICAgICAgICAgc2VsZi50cmlnZ2VyKCdzZWxlY3RlZC1lbGVtZW50LWNoYW5nZWQnLCBudWxsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgc2VsZWN0ZWQgb2JqZWN0IGFuZCBjaGFuZ2VzIHZpZXdQb3J0IHBvc2l0aW9uIGlmIGl0J3MgbmVlZGVkLlxyXG4gICAgICogQHBhcmFtIHtOb2RlfExpbmt9IGVsZW1lbnRcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZm9jdXNPblxyXG4gICAgICogPT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAgKiBAZmlyZXMgc2VsZWN0ZWQtZWxlbWVudC1jaGFuZ2VkXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIF9zZWxlY3QgKGVsZW1lbnQsIGZvY3VzT24pIHtcclxuICAgICAgICBjb25zdCBzZWxlY3RlZEVsZW1lbnQgPSBnZXRCYXNlRWxlbWVudChlbGVtZW50KTtcclxuXHJcbiAgICAgICAgaWYgKHNlbGVjdGVkRWxlbWVudCAhPT0gX3NlbGVjdGVkRWxlbWVudCkge1xyXG4gICAgICAgICAgICBpZiAoX3NlbGVjdGVkRWxlbWVudCkgX3NlbGVjdGVkRWxlbWVudC51bnNlbGVjdCgpO1xyXG4gICAgICAgICAgICBfc2VsZWN0ZWRFbGVtZW50ID0gc2VsZWN0ZWRFbGVtZW50O1xyXG4gICAgICAgICAgICBfc2VsZWN0ZWRFbGVtZW50LnNlbGVjdCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGZvY3VzT24pIHtcclxuICAgICAgICAgICAgX2ZvY3VzT25FbGVtZW50KF9zZWxlY3RlZEVsZW1lbnQsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIF9wYXRoID0gZ2V0UGF0aChfc2VsZWN0ZWRFbGVtZW50LCBfZGF0YUNvbnRhaW5lcik7XHJcbiAgICAgICAgICAgICAgICBfcmVkcmF3KCk7XHJcbiAgICAgICAgICAgICAgICBzZWxmLnRyaWdnZXIoJ3NlbGVjdGVkLWVsZW1lbnQtY2hhbmdlZCcsIGVsZW1lbnQpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIF9wYXRoID0gZ2V0UGF0aChfc2VsZWN0ZWRFbGVtZW50LCBfZGF0YUNvbnRhaW5lcik7XHJcbiAgICAgICAgICAgICAgICBfcmVkcmF3KCk7XHJcbiAgICAgICAgICAgICAgICBzZWxmLnRyaWdnZXIoJ3NlbGVjdGVkLWVsZW1lbnQtY2hhbmdlZCcsIGVsZW1lbnQpO1xyXG4gICAgICAgICAgICB9LCAwKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJdCBtb3ZlcyBwb3NpdGlvbiBvZiB0aGUgdmlld1BvcnQgc28gdGhhdFxyXG4gICAgICogdGhlIHNlbGVjdGVkIGVsZW1lbnQgYXBwZWFycyBpbiB0aGUgc2VudGVyIG9mIHRoZSB2aWV3UG9ydFxyXG4gICAgICogQHBhcmFtIHtOb2RlfExpbmt9IGVsZW1lbnRcclxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gX2ZvY3VzT25FbGVtZW50IGNhbiBiZSBhc3luY2hyb25vdXMgZGVwZW5kcyBvbiBhbmltYXRpb24gbW9kZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBfZm9jdXNPbkVsZW1lbnQgKGVsZW1lbnQsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgbGV0IGZvY3VzTm9kZSA9IG51bGw7XHJcbiAgICAgICAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBMaW5rKSB7XHJcbiAgICAgICAgICAgIGZvY3VzTm9kZSA9IF9kYXRhQ29udGFpbmVyLm1hcHMubm9kZU1hcFtlbGVtZW50Lm1vZGVsLnNvdXJjZV07XHJcbiAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50IGluc3RhbmNlb2YgTm9kZSkge1xyXG4gICAgICAgICAgICBmb2N1c05vZGUgPSBlbGVtZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZm9jdXNOb2RlKSB7XHJcbiAgICAgICAgICAgIGxldCB2aWV3RnJhbWUgPSBfdmlld01hbmFnZXIuZ2V0Vmlld0ZyYW1lRm9yTm9kZShmb2N1c05vZGUpO1xyXG4gICAgICAgICAgICBpZiAoIXZpZXdGcmFtZS5hY3RpdmUpIHtcclxuICAgICAgICAgICAgICAgIF9yZWRyYXcoeyB2aWV3RnJhbWVzOiBbeyBpZDogdmlld0ZyYW1lLmlkLCBleHBhbmRlZDogdHJ1ZSB9XSwgcXVpY2tVcGRhdGU6IHRydWUgfSk7XHJcbiAgICAgICAgICAgICAgICB2aWV3RnJhbWUgPSBfdmlld01hbmFnZXIuZ2V0Vmlld0ZyYW1lQnlJZCh2aWV3RnJhbWUuaWQpO1xyXG4gICAgICAgICAgICAgICAgc2VsZi50cmlnZ2VyKCd2aWV3LWZyYW1lcy1zdGF0ZS1jaGFuZ2VkJywgW1t2aWV3RnJhbWVdXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3Qgbm9kZVNpemUgPSBnZXRHbG9iYWxOb2RlU2l6ZShmb2N1c05vZGUsIHZpZXdGcmFtZS5zY2FsZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vZGVQb3NpdGlvbiA9IGdldEdsb2JhbE5vZGVQb3NpdGlvbihmb2N1c05vZGUpO1xyXG4gICAgICAgICAgICBjb25zdCB2aWV3UG9ydFNpemUgPSBzY2FsZWRUb0dsb2JhbFNpemUodmlld0ZyYW1lLnNpemUsIHZpZXdGcmFtZS5zY2FsZSk7XHJcblxyXG4gICAgICAgICAgICBsZXQgdGFyZ2V0UG9zaXRpb24gPSB7IC8vIEdsb2JhbFxyXG4gICAgICAgICAgICAgICAgeDogbm9kZVBvc2l0aW9uLnggKyAobm9kZVNpemUud2lkdGggLSB2aWV3UG9ydFNpemUud2lkdGgpIC8gMixcclxuICAgICAgICAgICAgICAgIHk6IG5vZGVQb3NpdGlvbi55ICsgKG5vZGVTaXplLmhlaWdodCAtIHZpZXdQb3J0U2l6ZS5oZWlnaHQpIC8gMixcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIF9wb3NpdGlvblZpZXdQb3J0KHZpZXdGcmFtZSwgdGFyZ2V0UG9zaXRpb24sIHBhcmFtZXRlcnMuYW5pbWF0aW9uLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2hhbmdlZFZpZXdGcmFtZSA9IF92aWV3TWFuYWdlci5nZXRWaWV3RnJhbWVCeUlkKHZpZXdGcmFtZS5pZCk7XHJcbiAgICAgICAgICAgICAgICBzZWxmLnRyaWdnZXIoJ3ZpZXctZnJhbWVzLXNpemUtb3ItcG9zaXRpb24tY2hhbmdlZCcsIFtbY2hhbmdlZFZpZXdGcmFtZV1dKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWxsIHZpZXdQb3J0IHBvc2l0aW9uIGNoYW5nZXMgc2hvdWxkIGJlIHBlcmZvcm1lZCB0aHJvdWdoIHRoaXMgbWV0aG9kcy5cclxuICAgICAqIF9wb3NpdGlvblZpZXdQb3J0IChleGNsdWRlIHNjYWxlKVxyXG4gICAgICogSXQncyBuZWVkZWQgdG8gc3RvcCBhbmltYXRpb24gaW4gY2FzZSBvZiBhbmltYXRpb24gaGF2ZW4ndCBiZWVuIGRvbmUuXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEl0IHNldHMgb2Zmc2V0IGZvciBhbGwgZWxlbWVudHMgaW50byB0aGUgdmlld1BvcnQuXHJcbiAgICAgKiBAcGFyYW0ge1ZpZXdGcmFtZX0gdmlld0ZyYW1lXHJcbiAgICAgKiBAcGFyYW0ge1BvaW50fSBwb2ludFxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBhbmltYXRpb24gLSBpdCdzIG9wdGlvbmFsXHJcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAtIGl0J3MgY2FsbGVkIGFmdGVyIGZvY3VzXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIF9wb3NpdGlvblZpZXdQb3J0ICh2aWV3RnJhbWUsIHBvaW50LCBhbmltYXRpb24sIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgY29uc3QgcmVsZXZhdG5WaWV3RnJhbWUgPSBfdmlld01hbmFnZXIuZ2V0Vmlld0ZyYW1lQnlJZCh2aWV3RnJhbWUuaWQpO1xyXG4gICAgICAgIGNvbnN0IHRhcmdldFBvcyA9IGxpbWl0UG9pbnRQb3NpdGlvbihwb2ludCwgcmVsZXZhdG5WaWV3RnJhbWUudmlld1BvcnRQb3NpdGlvbkJvdW5kcyk7XHJcbiAgICAgICAgY29uc3Qgdmlld1BvcnRQb3NpdGlvbiA9IHJlbGV2YXRuVmlld0ZyYW1lLnZpZXdQb3J0UG9zaXRpb247XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0SXNSZWFjaGVkID0gdmlld1BvcnRQb3NpdGlvbi54ID09PSB0YXJnZXRQb3MueCAmJiB2aWV3UG9ydFBvc2l0aW9uLnkgPT09IHRhcmdldFBvcy55O1xyXG5cclxuICAgICAgICBpZiAoKCFhbmltYXRpb24pIHx8IHRhcmdldElzUmVhY2hlZCB8fCAoIXZpZXdGcmFtZS5hY3RpdmUpKSB7XHJcbiAgICAgICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKF9hbmltYXRpb25JZCk7XHJcbiAgICAgICAgICAgIHZpZXdGcmFtZS52aWV3UG9ydFBvc2l0aW9uID0gdGFyZ2V0UG9zO1xyXG4gICAgICAgICAgICBfcmVkcmF3KHsgdmlld0ZyYW1lczogW3ZpZXdGcmFtZV0sIHF1aWNrVXBkYXRlOiB0cnVlIH0pO1xyXG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgX2FuaW1hdGVkVmlld1BvcnRDaGFuZ2luZyhyZWxldmF0blZpZXdGcmFtZSwgdGFyZ2V0UG9zLCBjYWxsYmFjayk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIF9saW1pdFZpZXdQb3J0c1Bvc3Rpb25zICh2aWV3RnJhbWVzLCBjYWxsYmFjaykge1xyXG4gICAgICAgIHJlY3Vyc2l2ZUNhbGwoMCk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHJlY3Vyc2l2ZUNhbGwgKGluZGV4KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHZpZXdGcmFtZSA9IHZpZXdGcmFtZXNbaW5kZXhdO1xyXG4gICAgICAgICAgICBpZiAoIXZpZXdGcmFtZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjb25zdCB0YXJnZXRWaWV3RnJhbWUgPSBfdmlld01hbmFnZXIuZ2V0Vmlld0ZyYW1lQnlJZCh2aWV3RnJhbWUuaWQpO1xyXG4gICAgICAgICAgICBpZiAoIXRhcmdldFZpZXdGcmFtZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBfbGltaXRWaWV3UG9ydFBvc3Rpb24odGFyZ2V0Vmlld0ZyYW1lLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCB2aWV3RnJhbWVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlY3Vyc2l2ZUNhbGwoaW5kZXggKyAxKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hhbmdlZFZpZXdGcmFtZXNNb2RlbHMgPSB2aWV3RnJhbWVzLm1hcCh2ZiA9PiBfdmlld01hbmFnZXIuZ2V0Vmlld0ZyYW1lQnlJZCh2Zi5pZCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYudHJpZ2dlcigndmlldy1mcmFtZXMtc2l6ZS1vci1wb3NpdGlvbi1jaGFuZ2VkJywgW2NoYW5nZWRWaWV3RnJhbWVzTW9kZWxzXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX2xpbWl0Vmlld1BvcnRQb3N0aW9uICh2aWV3RnJhbWUsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgY29uc3QgbGltaXR0ZWRQb3NpdGlvbiA9IGxpbWl0UG9pbnRQb3NpdGlvbih2aWV3RnJhbWUudmlld1BvcnRQb3NpdGlvbiwgdmlld0ZyYW1lLnZpZXdQb3J0UG9zaXRpb25Cb3VuZHMpO1xyXG4gICAgICAgIGNvbnN0IHBvc2l0aW9uSXNJbmNvcnJlY3QgPSBsaW1pdHRlZFBvc2l0aW9uLnggIT09IHZpZXdGcmFtZS52aWV3UG9ydFBvc2l0aW9uLnggfHwgbGltaXR0ZWRQb3NpdGlvbi55ICE9PSB2aWV3RnJhbWUudmlld1BvcnRQb3NpdGlvbi55O1xyXG4gICAgICAgIGlmIChwb3NpdGlvbklzSW5jb3JyZWN0KSB7XHJcbiAgICAgICAgICAgIF9wb3NpdGlvblZpZXdQb3J0KHZpZXdGcmFtZSwgbGltaXR0ZWRQb3NpdGlvbiwgcGFyYW1ldGVycy5hbmltYXRpb24sIGNhbGxiYWNrKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hhZ2VzIHZpZXdQb3J0IHBvc2l0aW9uIHNtb290aGx5IGZyb20gY3VycmVudCBwb3NpdGlvbiB0byB0YXJnZXQuXHJcbiAgICAgKiBAcGFyYW0ge1ZpZXdGcmFtZX0gdmZcclxuICAgICAqIEBwYXJhbSB7UG9pbnR9IHRhcmdldFBvc1xyXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcclxuICAgICAqL1xyXG4gICAgbGV0IF9hbmltYXRpb25JZCA9IHVuZGVmaW5lZDtcclxuICAgIGZ1bmN0aW9uIF9hbmltYXRlZFZpZXdQb3J0Q2hhbmdpbmcgKHZpZXdGcmFtZSwgdGFyZ2V0UG9zLCBjYWxsYmFjaykge1xyXG4gICAgICAgIGNvbnN0IHN0YXJ0UG9zID0gdmlld0ZyYW1lLnZpZXdQb3J0UG9zaXRpb247XHJcblxyXG4gICAgICAgIGNvbnN0IGRpZmZYID0gZ2V0RGlmZihzdGFydFBvcy54LCB0YXJnZXRQb3MueCk7XHJcbiAgICAgICAgY29uc3QgZGlmZlkgPSBnZXREaWZmKHN0YXJ0UG9zLnksIHRhcmdldFBvcy55KTtcclxuICAgICAgICBjb25zdCBzY2FsZSA9IHZpZXdGcmFtZS5zY2FsZSB8fCBfc2NhbGU7XHJcbiAgICAgICAgY29uc3QgZGVmYXVsdFN0ZXBYID0gcGFyYW1ldGVycy5hbmltYXRpb25TdGVwIC8gc2NhbGUueDtcclxuICAgICAgICBjb25zdCBkZWZhdWx0U3RlcFkgPSBwYXJhbWV0ZXJzLmFuaW1hdGlvblN0ZXAgLyBzY2FsZS55O1xyXG5cclxuICAgICAgICBsZXQgc3RlcFgsIHN0ZXBZO1xyXG4gICAgICAgIGlmIChkaWZmWCA+IGRpZmZZKSB7XHJcbiAgICAgICAgICAgIHN0ZXBYID0gZGVmYXVsdFN0ZXBYO1xyXG4gICAgICAgICAgICBzdGVwWSA9IGRlZmF1bHRTdGVwWCAqIChkaWZmWSAvIGRpZmZYKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzdGVwWCA9IGRlZmF1bHRTdGVwWSAqIChkaWZmWCAvIGRpZmZZKTtcclxuICAgICAgICAgICAgc3RlcFkgPSBkZWZhdWx0U3RlcFk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBzdGFydERpc3RhbmNlID0gZ2V0RGlzdCh2aWV3RnJhbWUudmlld1BvcnRQb3NpdGlvbiwgdGFyZ2V0UG9zKTtcclxuXHJcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoX2FuaW1hdGlvbklkKTtcclxuXHJcbiAgICAgICAgbGV0IHRpbWU7XHJcbiAgICAgICAgcmVxdXJzaXZlQW5pbWF0aW9uKCk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHJlcXVyc2l2ZUFuaW1hdGlvbiAob2xkUG9zKSB7XHJcbiAgICAgICAgICAgIF9hbmltYXRpb25JZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRpbWVSYXRlID0gMTAwMCAvIChub3cgLSB0aW1lKSB8fCBwYXJhbWV0ZXJzLm1pbkZyYW1lUmF0ZTtcclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgdE1vZGlmaWVyID0gMTtcclxuICAgICAgICAgICAgICAgIGlmIChwYXJhbWV0ZXJzLm1pbkZyYW1lUmF0ZSA+IHRpbWVSYXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdE1vZGlmaWVyID0gcGFyYW1ldGVycy5taW5GcmFtZVJhdGUgLyB0aW1lUmF0ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0aW1lUmF0ZSA+IHBhcmFtZXRlcnMubWF4RnJhbWVSYXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdE1vZGlmaWVyID0gcGFyYW1ldGVycy5tYXhGcmFtZVJhdGUgLyB0aW1lUmF0ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRpbWUgPSBub3c7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgY3VyUG9zID0gdmlld0ZyYW1lLnZpZXdQb3J0UG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRJc1JlYWNoZWQgPSBjdXJQb3MueCA9PT0gdGFyZ2V0UG9zLnggJiYgY3VyUG9zLnkgPT09IHRhcmdldFBvcy55O1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgd2VBcmVOb3RNb3ZpbmcgPSBvbGRQb3MgJiYgY3VyUG9zLnggPT09IG9sZFBvcy54ICYmIGN1clBvcy55ID09PSBvbGRQb3MueTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0SXNSZWFjaGVkIHx8IHdlQXJlTm90TW92aW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX2RlbGF5ZWRSZWRyYXcoeyB2aWV3RnJhbWVzOiBbdmlld0ZyYW1lXSB9KTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBfcmVkcmF3KHsgdmlld0ZyYW1lczogW3ZpZXdGcmFtZV0sIHF1aWNrVXBkYXRlOiBmYWxzZSB9KTtcclxuICAgICAgICAgICAgICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShfYW5pbWF0aW9uSWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpZmZYID0gZ2V0RGlmZihjdXJQb3MueCwgdGFyZ2V0UG9zLngpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpZmZZID0gZ2V0RGlmZihjdXJQb3MueSwgdGFyZ2V0UG9zLnkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdQb3MgPSB7IHg6IGN1clBvcy54LCB5OiBjdXJQb3MueSB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJEaXN0YW5jZSA9IGdldERpc3QoY3VyUG9zLCB0YXJnZXRQb3MpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGsgPSAxIC0gTWF0aC5jb3MoTWF0aC5QSSAqIChzdGFydERpc3RhbmNlIC0gY3VyRGlzdGFuY2UpIC8gc3RhcnREaXN0YW5jZSkgKiAwLjM7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbmFsU3RlcFggPSBzdGVwWDtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaW5hbFN0ZXBZID0gc3RlcFk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdQb3MueCAhPT0gdGFyZ2V0UG9zLngpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZCA9IE1hdGgubWluKGRpZmZYLCBmaW5hbFN0ZXBYICogayAqIHRNb2RpZmllcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Bvcy54ICs9IGN1clBvcy54IDwgdGFyZ2V0UG9zLnggPyBkIDogLWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdQb3MueSAhPT0gdGFyZ2V0UG9zLnkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZCA9IE1hdGgubWluKE1hdGguYWJzKGRpZmZZKSwgZmluYWxTdGVwWSAqIGsgKiB0TW9kaWZpZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdQb3MueSArPSBjdXJQb3MueSA8IHRhcmdldFBvcy55ID8gZCA6IC1kO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2aWV3RnJhbWUudmlld1BvcnRQb3NpdGlvbiA9IG5ld1BvcztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgX3JlZHJhdyh7IHZpZXdGcmFtZXM6IFt2aWV3RnJhbWVdLCBxdWlja1VwZGF0ZTogdHJ1ZSB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmVxdXJzaXZlQW5pbWF0aW9uKGN1clBvcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZnJlc2hlcyBhbGwgdmlld0ZyYW1lcyBib3VuZHMuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIF9yZWZyZXNoICh2aWV3RnJhbWVzKSB7XHJcbiAgICAgICAgdmlld0ZyYW1lcyA9IHZpZXdGcmFtZXMgfHwgX3ZpZXdNYW5hZ2VyLmdldFZpZXdGcmFtZXMoKTtcclxuICAgICAgICBfcmVkcmF3KHsgdmlld0ZyYW1lczogdmlld0ZyYW1lcywgdXBkYXRlQm91bmRzOiB0cnVlIH0pO1xyXG4gICAgICAgIF9saW1pdFZpZXdQb3J0c1Bvc3Rpb25zKHZpZXdGcmFtZXMpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIF9yZXNldExheW91dCAoKSB7XHJcbiAgICAgICAgY29uc3Qgdmlld0ZyYW1lQWZmZWN0ZWRJZHMgPSB7fTtcclxuICAgICAgICBjb25zdCBvdmVyVmlld0ZyYW1lSWQgPSBfdmlld01hbmFnZXIuZ2V0T3ZlclZpZXdGcmFtZSgpLmlkO1xyXG5cclxuICAgICAgICBfZGF0YUNvbnRhaW5lci5ub2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xyXG4gICAgICAgICAgICBpZiAobm9kZS5tb2RlbC5kZWZhdWx0UG9zaXRpb24pIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGN1clBvcyA9IGdldEdsb2JhbE5vZGVQb3NpdGlvbihub2RlKTtcclxuICAgICAgICAgICAgICAgIG5vZGUubW9kZWwucG9zaXRpb24gPSBub2RlLm1vZGVsLmRlZmF1bHRQb3NpdGlvbjtcclxuICAgICAgICAgICAgICAgIF9kYXRhQ29udGFpbmVyLnVwZGF0ZVpvbmVzRm9yTm9kZShub2RlLCBjdXJQb3MpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUudmlld0ZyYW1lT3duZXJJZCkgdmlld0ZyYW1lQWZmZWN0ZWRJZHNbbm9kZS52aWV3RnJhbWVPd25lcklkXSA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgaXNGdWxsU2NyZWVuTW9kZSA9IF92aWV3TWFuYWdlci5pc0Z1bGxTY3JlZW5Nb2RlKCk7XHJcbiAgICAgICAgICAgICAgICB2aWV3RnJhbWVBZmZlY3RlZElkc1tpc0Z1bGxTY3JlZW5Nb2RlID8gb3ZlclZpZXdGcmFtZUlkIDogbm9kZS5tb2RlbC52aWV3RnJhbWVdID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBub2RlLnZpZXdGcmFtZU93bmVySWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCB2aWV3RnJhbWVzID0gT2JqZWN0LmtleXModmlld0ZyYW1lQWZmZWN0ZWRJZHMpXHJcbiAgICAgICAgICAgIC5tYXAoa2V5ID0+ICh7IGlkOiBrZXksIHVwZGF0ZUJvdW5kczogdHJ1ZSB9KSk7XHJcbiAgICAgICAgX3JlZHJhdyh7IHZpZXdGcmFtZXM6IHZpZXdGcmFtZXMgfSk7XHJcbiAgICAgICAgX2xpbWl0Vmlld1BvcnRzUG9zdGlvbnModmlld0ZyYW1lcyk7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0ICogYXMgXyBmcm9tICdsb2Rhc2gnO1xyXG5pbXBvcnQgKiBhcyBqb2ludCBmcm9tICdyYXBwaWQnO1xyXG5cclxuY29uc3QgZyA9IGpvaW50Lmc7XHJcbmNvbnN0IExJTktfT0ZGU0VUID0gNztcclxuXHJcbmV4cG9ydCBjb25zdCBFTkFCTEVfUk9VVElOR1MgPSBbICdtZXRybycsICdub3JtYWwnLCAnbWFuaGF0dGFuJywgJ29ydGhvZ29uYWwnLCAnbGdyb3V0ZXInIF07XHJcblxyXG4vKipcclxuICogUm91dGluZ01hbmFnZXJcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtsaW5rUm91dGluZywgbGlua3MsIGJvdW5kc30gb3B0aW9ucyBcclxuICogQHBhcmFtIHsqfSBwYXJhbWV0ZXJzIFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIFJvdXRpbmdNYW5hZ2VyIChvcHRpb25zLCBwYXJhbWV0ZXJzKSB7XHJcbiAgICBjb25zdCBzZWxmID0gdGhpcztcclxuXHJcbiAgICBsZXQgX2xpbmtzO1xyXG4gICAgbGV0IF9yb3V0aW5nID0gb3B0aW9ucy5saW5rUm91dGluZyB8fCBwYXJhbWV0ZXJzLmxpbmtSb3V0aW5nO1xyXG5cclxuICAgIGxldCBfdmVydGV4TWFwID0ge307XHJcbiAgICBsZXQgX2lkVG9WZXJ0ZXggPSB7fTtcclxuICAgIGxldCBfYm91bmRzID0gb3B0aW9ucy5ib3VuZHM7XHJcblxyXG4gICAgc2VsZi5zZXREYXRhID0gX3NldERhdGE7XHJcbiAgICBzZWxmLnNldFJvdXRpbmcgPSBfc2V0Um91dGluZztcclxuICAgIHNlbGYucmVzZXRSb3V0aW5nID0gX3Jlc2V0Um91dGluZztcclxuICAgIHNlbGYuc2V0Qm91bmRzID0gX3NldEJvdW5kcztcclxuXHJcbiAgICBzZWxmLmdldFJvdXRpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9yb3V0aW5nO1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBfaW5pdCAoKSB7XHJcbiAgICAgICAgX3NldERhdGEob3B0aW9ucy5saW5rcyk7XHJcbiAgICAgICAgam9pbnQucm91dGVycy5sZ3JvdXRlciA9IGxncm91dGVyO1xyXG4gICAgICAgIGpvaW50LnJvdXRlcnMubWV0cm8gPSBuZXdNZXRybztcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfc2V0Qm91bmRzIChib3VuZHMpIHtcclxuICAgICAgICBfYm91bmRzID0gYm91bmRzO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIF9zZXREYXRhIChsaW5rcykge1xyXG4gICAgICAgIF9saW5rcyA9IGxpbmtzO1xyXG4gICAgICAgIF91cGRhdGVMaW5rUm91dGluZygpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIF9zZXRSb3V0aW5nIChyb3V0aW5nKSB7XHJcbiAgICAgICAgY29uc3QgaXNVbmtub3duUm91dGluZ0lkID0gRU5BQkxFX1JPVVRJTkdTLmluZGV4T2Yocm91dGluZykgPT09IC0xO1xyXG4gICAgICAgIGlmIChpc1Vua25vd25Sb3V0aW5nSWQpIHtcclxuICAgICAgICAgICAgcm91dGluZyA9ICdtZXRybyc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyb3V0aW5nICE9PSBfcm91dGluZykge1xyXG4gICAgICAgICAgICBfcm91dGluZyA9IHJvdXRpbmc7XHJcbiAgICAgICAgICAgIF91cGRhdGVMaW5rUm91dGluZygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfdXBkYXRlTGlua1JvdXRpbmcgKCkge1xyXG4gICAgICAgIF92ZXJ0ZXhNYXAgPSB7fTtcclxuICAgICAgICBfaWRUb1ZlcnRleCA9IHt9O1xyXG4gICAgICAgIF9saW5rcy5mb3JFYWNoKGxpbmsgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCByb3V0ZXIgPSB7XHJcbiAgICAgICAgICAgICAgICBuYW1lOiBfcm91dGluZyxcclxuICAgICAgICAgICAgICAgIGFyZ3M6IGxpbmsuZ2V0KCdyb3V0ZXInKS5hcmdzLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBsaW5rLnNldCgncm91dGVyJywgcm91dGVyLCBsaW5rLmlzT25UaGVHcmFwaCgpID8ge30gOiB7IHNpbGVudDogdHJ1ZSB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfcmVzZXRSb3V0aW5nICgpIHtcclxuICAgICAgICBfdmVydGV4TWFwID0ge307XHJcbiAgICAgICAgX2lkVG9WZXJ0ZXggPSB7fTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBSb3V0ZXJzXHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuICAgIGNvbnN0IGxncm91dGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG1hbnVhbFZlcnRpY2VzLCBvcHRzLCBsaW5rVmlldykge1xyXG4gICAgICAgICAgICBjb25zdCBkZWZhdWx0Q29maWcgPSB7XHJcbiAgICAgICAgICAgICAgICBzdGVwOiAxMCxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgbGV0IHZlcnRpY2VzID0gam9pbnQucm91dGVycy5tYW5oYXR0YW4obWFudWFsVmVydGljZXMsIF8uZXh0ZW5kKHt9LCBkZWZhdWx0Q29maWcsIG9wdHMpLCBsaW5rVmlldyk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLl9maW5kQ29ubmVjdGlvblBvaW50cyh2ZXJ0aWNlcyk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBhbGxWZXJ0aWNlcyA9IGZpbmRJbnRlcm1lZGlhdGVWZXJ0aWNlcyhcclxuICAgICAgICAgICAgICAgIFt0aGlzLnNvdXJjZVBvaW50XS5jb25jYXQodmVydGljZXMpLmNvbmNhdChbdGhpcy50YXJnZXRQb2ludF0pLFxyXG4gICAgICAgICAgICAgICAgLy8gdmVydGljZXMubGVuZ3RoID4gMCA/IHZlcnRpY2VzIDogW3RoaXMuc291cmNlQkJveC5jZW50ZXIoKSwgdGhpcy50YXJnZXRCQm94LmNlbnRlcigpXSxcclxuICAgICAgICAgICAgICAgIGRlZmF1bHRDb2ZpZy5zdGVwLFxyXG4gICAgICAgICAgICApO1xyXG4gICAgXHJcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zbGF0ZWRWZXJ0aWNlcyA9IFtdO1xyXG4gICAgICAgICAgICBjbGVhclZlcnRpY2VzKGxpbmtWaWV3KTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGxldCBtYXhPZmZzZXQgPSB7IHg6IDAsIHk6IDAgfTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbGxWZXJ0aWNlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcHJldlZlcnRleCA9IGFsbFZlcnRpY2VzW2kgLSAxXTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHZlcnRleCA9IGFsbFZlcnRpY2VzW2ldO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dFZlcnRleCA9IGFsbFZlcnRpY2VzW2kgKyAxXTtcclxuICAgICAgICAgICAgICAgIHZlcnRleC50eXBlID0gZ2V0UG9zaXRpb25UeXBlKHByZXZWZXJ0ZXgsIHZlcnRleCwgbmV4dFZlcnRleCk7XHJcbiAgICAgICAgICAgICAgICBtYXhPZmZzZXQgPSBnZXRPZmZzZXQodmVydGV4LCBtYXhPZmZzZXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICBcclxuICAgICAgICAgICAgYWxsVmVydGljZXMuZm9yRWFjaCh2ZXJ0ZXggPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3VmVydGV4ID0gc3RvcmVWZWVydGV4KHZlcnRleCwgbWF4T2Zmc2V0LCBsaW5rVmlldyk7XHJcbiAgICAgICAgICAgICAgICBpZiAodmVydGljZXMuaW5kZXhPZih2ZXJ0ZXgpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZWRWZXJ0aWNlcy5wdXNoKG5ld1ZlcnRleCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgXHJcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2xhdGVkVmVydGljZXMubWFwKHZlcnRleCA9PiAoe1xyXG4gICAgICAgICAgICAgICAgeDogTWF0aC5taW4oTWF0aC5tYXgodmVydGV4LngsIF9ib3VuZHMueCApLCBfYm91bmRzLnggKyBfYm91bmRzLndpZHRoKSxcclxuICAgICAgICAgICAgICAgIHk6IE1hdGgubWluKE1hdGgubWF4KHZlcnRleC55LCBfYm91bmRzLnkgKSwgX2JvdW5kcy55ICsgX2JvdW5kcy5oZWlnaHQpLFxyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgfTtcclxuICAgIH0pKCk7XHJcblxyXG4gICAgY29uc3QgbmV3TWV0cm8gPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBjb25maWcgPSB7XHJcbiAgICAgICAgICAgIC8vIGNvc3Qgb2YgYSBkaWFnb25hbCBzdGVwIChjYWxjdWxhdGVkIGlmIG5vdCBkZWZpbmVkKS5cclxuICAgICAgICAgICAgZGlhZ29uYWxDb3N0OiBudWxsLFxyXG4gICAgICAgICAgICAvLyBhbiBhcnJheSBvZiBkaXJlY3Rpb25zIHRvIGZpbmQgbmV4dCBwb2ludHMgb24gdGhlIHJvdXRlXHJcbiAgICAgICAgICAgIGRpcmVjdGlvbnM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzdGVwID0gdGhpcy5zdGVwO1xyXG4gICAgICAgICAgICAgICAgdmFyIGRpYWdvbmFsQ29zdCA9IHRoaXMuZGlhZ29uYWxDb3N0IHx8IE1hdGguY2VpbChNYXRoLnNxcnQoc3RlcCAqIHN0ZXAgPDwgMSkpO1xyXG4gICAgXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAgICAgICAgIHsgb2Zmc2V0WDogc3RlcCAgLCBvZmZzZXRZOiAwICAgICAsIGNvc3Q6IHN0ZXAgfSxcclxuICAgICAgICAgICAgICAgICAgICB7IG9mZnNldFg6IHN0ZXAgICwgb2Zmc2V0WTogc3RlcCAgLCBjb3N0OiBkaWFnb25hbENvc3QgfSxcclxuICAgICAgICAgICAgICAgICAgICB7IG9mZnNldFg6IDAgICAgICwgb2Zmc2V0WTogc3RlcCAgLCBjb3N0OiBzdGVwIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgeyBvZmZzZXRYOiAtc3RlcCAsIG9mZnNldFk6IHN0ZXAgICwgY29zdDogZGlhZ29uYWxDb3N0IH0sXHJcbiAgICAgICAgICAgICAgICAgICAgeyBvZmZzZXRYOiAtc3RlcCAsIG9mZnNldFk6IDAgICAgICwgY29zdDogc3RlcCB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHsgb2Zmc2V0WDogLXN0ZXAgLCBvZmZzZXRZOiAtc3RlcCAsIGNvc3Q6IGRpYWdvbmFsQ29zdCB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHsgb2Zmc2V0WDogMCAgICAgLCBvZmZzZXRZOiAtc3RlcCAsIGNvc3Q6IHN0ZXAgfSxcclxuICAgICAgICAgICAgICAgICAgICB7IG9mZnNldFg6IHN0ZXAgICwgb2Zmc2V0WTogLXN0ZXAgLCBjb3N0OiBkaWFnb25hbENvc3QgfVxyXG4gICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbWF4QWxsb3dlZERpcmVjdGlvbkNoYW5nZTogNDUsXHJcbiAgICAgICAgICAgIC8vIGEgc2ltcGxlIHJvdXRlIHVzZWQgaW4gc2l0dWF0aW9ucywgd2hlbiBtYWluIHJvdXRpbmcgbWV0aG9kIGZhaWxzXHJcbiAgICAgICAgICAgIC8vIChleGNlZWQgbG9vcHMsIGluYWNjZXNzaWJsZSkuXHJcbiAgICAgICAgICAgIGZhbGxiYWNrUm91dGU6IGZ1bmN0aW9uIChmcm9tLCB0bykge1xyXG4gICAgICAgICAgICAgICAgLy8gRmluZCBhIHJvdXRlIHdoaWNoIGJyZWFrcyBieSA0NSBkZWdyZWVzIGlnbm9yaW5nIGFsbCBvYnN0YWNsZXMuXHJcbiAgICAgICAgICAgICAgICBjb25zdCB0aGV0YSA9IGZyb20udGhldGEodG8pO1xyXG4gICAgXHJcbiAgICAgICAgICAgICAgICBsZXQgYSA9IHsgeDogdG8ueCwgeTogZnJvbS55IH07XHJcbiAgICAgICAgICAgICAgICBsZXQgYiA9IHsgeDogZnJvbS54LCB5OiB0by55IH07XHJcbiAgICBcclxuICAgICAgICAgICAgICAgIGlmICh0aGV0YSAlIDE4MCA+IDkwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBhO1xyXG4gICAgICAgICAgICAgICAgICAgIGEgPSBiO1xyXG4gICAgICAgICAgICAgICAgICAgIGIgPSB0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgXHJcbiAgICAgICAgICAgICAgICBjb25zdCBwMSA9ICh0aGV0YSAlIDkwKSA8IDQ1ID8gYSA6IGI7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsMSA9IGcubGluZShmcm9tLCBwMSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhbHBoYSA9IDkwICogTWF0aC5jZWlsKHRoZXRhIC8gOTApO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcDIgPSBnLnBvaW50LmZyb21Qb2xhcihsMS5zcXVhcmVkTGVuZ3RoKCksIGcudG9SYWQoYWxwaGEgKyAxMzUpLCBwMSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsMiA9IGcubGluZSh0bywgcDIpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcG9pbnQgPSBsMS5pbnRlcnNlY3Rpb24obDIpO1xyXG4gICAgXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9pbnQgPyBbcG9pbnQucm91bmQoKSwgdG9dIDogW3RvXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICBcclxuICAgICAgICAvLyBwdWJsaWMgZnVuY3Rpb25cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZlcnRpY2VzLCBvcHRzLCBsaW5rVmlldykge1xyXG4gICAgICAgICAgICByZXR1cm4gbGdyb3V0ZXIuY2FsbCh0aGlzLCB2ZXJ0aWNlcywgXy5leHRlbmQoe30sIGNvbmZpZywgb3B0cyksIGxpbmtWaWV3KTtcclxuICAgICAgICB9O1xyXG4gICAgfSkoKTtcclxuICAgIFxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRQb3NpdGlvblR5cGUgKHByZXZWZXJ0ZXgsIHZlcnRleCwgbmV4dFZlcnRleCkge1xyXG4gICAgICAgIGlmIChwcmV2VmVydGV4IHx8IG5leHRWZXJ0ZXgpIHtcclxuICAgICAgICAgICAgY29uc3QgeCA9IE1hdGgucm91bmQodmVydGV4LngpO1xyXG4gICAgICAgICAgICBjb25zdCB5ID0gTWF0aC5yb3VuZCh2ZXJ0ZXgueSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGVxdWFsWCA9ICgoIXByZXZWZXJ0ZXgpIHx8IE1hdGgucm91bmQocHJldlZlcnRleC54KSA9PT0geCkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKCghbmV4dFZlcnRleCkgfHwgTWF0aC5yb3VuZChuZXh0VmVydGV4LngpID09PSB4KTtcclxuICAgICAgICAgICAgY29uc3QgZXF1YWxZID0gKCghcHJldlZlcnRleCkgfHwgTWF0aC5yb3VuZChwcmV2VmVydGV4LnkpID09PSB5KSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAoKCFuZXh0VmVydGV4KSB8fCBNYXRoLnJvdW5kKG5leHRWZXJ0ZXgueSkgPT09IHkpO1xyXG4gICAgICAgICAgICBpZiAoZXF1YWxYKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3ZlcnRpY2FsJztcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChlcXVhbFkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnaG9yaXpvbnRhbCc7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3BvaW50JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAncG9pbnQnO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhcHBseU9mZnNldCAodmVydGV4LCBvZmZzZXQpIHtcclxuICAgICAgICBjb25zdCBpc0hvcml6b250YWwgPSB2ZXJ0ZXgudHlwZSA9PT0gJ2hvcml6b250YWwnOyBcclxuICAgICAgICBjb25zdCBpc1ZlcmljYWwgPSB2ZXJ0ZXgudHlwZSA9PT0gJ3ZlcnRpY2FsJzsgXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgeDogdmVydGV4LnggKyAoaXNIb3Jpem9udGFsID8gMCA6IG9mZnNldC54KSxcclxuICAgICAgICAgICAgeTogdmVydGV4LnkgKyAoaXNWZXJpY2FsID8gMDogb2Zmc2V0LnkpLFxyXG4gICAgICAgICAgICB0eXBlOiB2ZXJ0ZXgudHlwZSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldElkICh2ZXJ0ZXgpIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCh2ZXJ0ZXgueCkgKyAnQCcgKyBNYXRoLnJvdW5kKHZlcnRleC55KSArICc6JyArIHZlcnRleC50eXBlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGZ1bmN0aW9uIGdldE9mZnNldCAodmVydGV4LCBkZWZhdWx0T2Zmc2V0KSB7XHJcbiAgICAvLyAgICAgY29uc3QgY3VyVmVydGV4ID0gYXBwbHlPZmZzZXQodmVydGV4LCBkZWZhdWx0T2Zmc2V0KTtcclxuICAgIC8vICAgICBjb25zdCB2SWQgPSBnZXRJZChjdXJWZXJ0ZXgpO1xyXG5cclxuICAgIC8vICAgICBpZiAoX3ZlcnRleE1hcFt2SWRdKSB7XHJcbiAgICAvLyAgICAgICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IHZlcnRleC50eXBlID09PSAnaG9yaXpvbnRhbCc7IFxyXG4gICAgLy8gICAgICAgICBjb25zdCBpc1ZlcmljYWwgPSB2ZXJ0ZXgudHlwZSA9PT0gJ3ZlcnRpY2FsJztcclxuICAgIC8vICAgICAgICAgcmV0dXJuIGdldE9mZnNldCAodmVydGV4LCB7XHJcbiAgICAvLyAgICAgICAgICAgICB4OiBkZWZhdWx0T2Zmc2V0LnggKyAoaXNIb3Jpem9udGFsID8gMCA6IC1MSU5LX09GRlNFVCksXHJcbiAgICAvLyAgICAgICAgICAgICB5OiBkZWZhdWx0T2Zmc2V0LnkgKyAoaXNWZXJpY2FsID8gMCA6IExJTktfT0ZGU0VUKSxcclxuICAgIC8vICAgICAgICAgfSk7XHJcbiAgICAvLyAgICAgfSBlbHNlIHtcclxuICAgIC8vICAgICAgICAgcmV0dXJuIGRlZmF1bHRPZmZzZXQ7XHJcbiAgICAvLyAgICAgfVxyXG4gICAgLy8gfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldE9mZnNldCAodmVydGV4LCBkZWZhdWx0T2Zmc2V0KSB7XHJcbiAgICAgICAgY29uc3QgaXNIb3Jpem9udGFsID0gdmVydGV4LnR5cGUgPT09ICdob3Jpem9udGFsJzsgXHJcbiAgICAgICAgY29uc3QgaXNWZXJpY2FsID0gdmVydGV4LnR5cGUgPT09ICd2ZXJ0aWNhbCc7XHJcblxyXG4gICAgICAgIGxldCBjdXJPZmZzZXQgPSBkZWZhdWx0T2Zmc2V0O1xyXG4gICAgICAgIGxldCBjdXJWZXJ0ZXggPSBhcHBseU9mZnNldCh2ZXJ0ZXgsIGRlZmF1bHRPZmZzZXQpO1xyXG4gICAgICAgIGxldCBjdXJJZCA9IGdldElkKGN1clZlcnRleCk7XHJcblxyXG4gICAgICAgIGNvbnN0IHhUeXBlID0gZGVmYXVsdE9mZnNldC54ID09PSAwID8gJ3RyaWdnZXInIDogZGVmYXVsdE9mZnNldC54ID4gMCA/ICdyaXNlJyA6ICdmYWxsJztcclxuICAgICAgICBjb25zdCB5VHlwZSA9IGRlZmF1bHRPZmZzZXQueSA9PT0gMCA/ICd0cmlnZ2VyJyA6IGRlZmF1bHRPZmZzZXQueSA+IDAgPyAncmlzZScgOiAnZmFsbCc7XHJcbiAgICAgICAgbGV0IHhUcmlnZ2VyID0gMTtcclxuICAgICAgICBsZXQgeVRyaWdnZXIgPSAxO1xyXG4gICAgICAgIGxldCB4U3RlcCA9IDA7XHJcbiAgICAgICAgbGV0IHlTdGVwID0gMDtcclxuICAgICAgICB3aGlsZSAoX3ZlcnRleE1hcFtjdXJJZF0pIHtcclxuICAgICAgICAgICAgY3VyT2Zmc2V0ID0geyB4OiBkZWZhdWx0T2Zmc2V0LngsIHk6IGRlZmF1bHRPZmZzZXQueSB9O1xyXG4gICAgICAgICAgICBpZiAoeFR5cGUgPT09ICd0cmlnZ2VyJykge1xyXG4gICAgICAgICAgICAgICAgeFRyaWdnZXIgPSAteFRyaWdnZXI7XHJcbiAgICAgICAgICAgICAgICBpZiAoeFRyaWdnZXIgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeFN0ZXArKztcclxuICAgICAgICAgICAgICAgIH0gICAgXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoeFR5cGUgPT09ICdyaXNlJykge1xyXG4gICAgICAgICAgICAgICAgeFN0ZXArKztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHhTdGVwLS07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHlUeXBlID09PSAndHJpZ2dlcicpIHtcclxuICAgICAgICAgICAgICAgIHlUcmlnZ2VyID0gLXlUcmlnZ2VyO1xyXG4gICAgICAgICAgICAgICAgaWYgKHlUcmlnZ2VyIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHlTdGVwKys7XHJcbiAgICAgICAgICAgICAgICB9ICAgIFxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHlUeXBlID09PSAncmlzZScpIHtcclxuICAgICAgICAgICAgICAgIHlTdGVwKys7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB5U3RlcC0tO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN1ck9mZnNldCA9IHtcclxuICAgICAgICAgICAgICAgIHg6IGRlZmF1bHRPZmZzZXQueCArIChpc0hvcml6b250YWwgPyAwIDogeFN0ZXAgKiBMSU5LX09GRlNFVCAqIHhUcmlnZ2VyKSxcclxuICAgICAgICAgICAgICAgIHk6IGRlZmF1bHRPZmZzZXQueSArIChpc1ZlcmljYWwgPyAwIDogeVN0ZXAgKiBMSU5LX09GRlNFVCAqIHlUcmlnZ2VyKSxcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGN1clZlcnRleCA9IGFwcGx5T2Zmc2V0KHZlcnRleCwgY3VyT2Zmc2V0KTtcclxuICAgICAgICAgICAgY3VySWQgPSBnZXRJZChjdXJWZXJ0ZXgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGN1ck9mZnNldDtcclxuICAgIH1cclxuICAgIFxyXG4gICAgZnVuY3Rpb24gY2xlYXJWZXJ0aWNlcyAobGlua1ZpZXcpIHtcclxuICAgICAgICBpZiAoX2lkVG9WZXJ0ZXhbbGlua1ZpZXcubW9kZWwuaWRdKSB7XHJcbiAgICAgICAgICAgIF9pZFRvVmVydGV4W2xpbmtWaWV3Lm1vZGVsLmlkXS5mb3JFYWNoKHZlcnRleElkID0+IHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBfdmVydGV4TWFwW3ZlcnRleElkXTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBfaWRUb1ZlcnRleFtsaW5rVmlldy5tb2RlbC5pZF07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBzdG9yZVZlZXJ0ZXggKHZlcnRleCwgb2Zmc2V0LCBsaW5rVmlldywpIHtcclxuICAgICAgICBjb25zdCBuZXdWZXJ0ZXggPSBhcHBseU9mZnNldCh2ZXJ0ZXgsIG9mZnNldCk7XHJcblxyXG4gICAgICAgIGNvbnN0IHZlcnRleElkID0gZ2V0SWQobmV3VmVydGV4KTtcclxuICAgICAgICBfdmVydGV4TWFwW3ZlcnRleElkXSA9IG5ld1ZlcnRleDtcclxuICAgIFxyXG4gICAgICAgIGlmICghX2lkVG9WZXJ0ZXhbbGlua1ZpZXcubW9kZWwuaWRdKSB7XHJcbiAgICAgICAgICAgIF9pZFRvVmVydGV4W2xpbmtWaWV3Lm1vZGVsLmlkXSA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfaWRUb1ZlcnRleFtsaW5rVmlldy5tb2RlbC5pZF0ucHVzaCh2ZXJ0ZXhJZCk7XHJcbiAgICAgICAgcmV0dXJuIG5ld1ZlcnRleDtcclxuICAgIH1cclxuICAgIFxyXG4gICAgZnVuY3Rpb24gZmluZEludGVybWVkaWF0ZVZlcnRpY2VzICh2ZXJ0aWNlcywgc3RlcCkge1xyXG4gICAgICAgIGNvbnN0IGFsbFZlcnRpY2VzID0gW107XHJcbiAgICAgICAgbGV0IHByZXYgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdmVydGljZXMuZm9yRWFjaCh2ZXJ0ZXggPT4ge1xyXG4gICAgICAgICAgICBpZiAocHJldiAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpc1ZlcnRpY2FsID0gcHJldi54ID09PSB2ZXJ0ZXgueDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IHByZXYueSA9PT0gdmVydGV4Lnk7XHJcbiAgICBcclxuICAgICAgICAgICAgICAgIGlmIChpc1ZlcnRpY2FsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXYueSA8IHZlcnRleC55KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHkgPSBwcmV2LnkgKyBzdGVwOyB5IDwgdmVydGV4Lnk7IHkgKz0gc3RlcCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsVmVydGljZXMucHVzaCh7IHg6IHZlcnRleC54LCB5OiB5IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgeSA9IHByZXYueSAtIHN0ZXA7IHkgPiB2ZXJ0ZXgueTsgeSAtPSBzdGVwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxWZXJ0aWNlcy5wdXNoKHsgeDogdmVydGV4LngsIHk6IHkgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzSG9yaXpvbnRhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmV2LnggPCB2ZXJ0ZXgueCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB4ID0gcHJldi54ICsgc3RlcDsgeCA8IHZlcnRleC54OyB4ICs9IHN0ZXApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbFZlcnRpY2VzLnB1c2goeyB4OiB4LCB5OiB2ZXJ0ZXgueSB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHggPSBwcmV2LnggLSBzdGVwOyB4ID4gdmVydGV4Lng7IHggLT0gc3RlcCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsVmVydGljZXMucHVzaCh7IHg6IHgsIHk6IHZlcnRleC55IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFsbFZlcnRpY2VzLnB1c2godmVydGV4KTtcclxuICAgICAgICAgICAgcHJldiA9IHZlcnRleDtcclxuICAgICAgICB9KTtcclxuICAgIFxyXG4gICAgICAgIHJldHVybiBhbGxWZXJ0aWNlcztcclxuICAgIH1cclxuXHJcbiAgICBfaW5pdCgpO1xyXG59IiwiaW1wb3J0ICogYXMgXyBmcm9tICdsb2Rhc2gnO1xyXG5pbXBvcnQgKiBhcyBqb2ludCBmcm9tICdyYXBwaWQnO1xyXG5cclxuaW1wb3J0IHsgTEFCRUxfTEVGVF9SSUdIVF9QQURESU5HIH0gZnJvbSAnLi9ncmFwaEVsZW1lbnRzL2VsZW1lbnRzJztcclxuXHJcbmV4cG9ydCBjb25zdCBGT1JFSUdOX09CSkVDVF9QQURESU5HID0gMjsgLy8gaW4gcHhcclxuZXhwb3J0IGNvbnN0IFBOR19DT05URU5UX1BBRERJTkcgPSAxOyAvLyBpbiBweFxyXG5leHBvcnQgY29uc3QgRVhDTFVERURfRUxFTUVOVFMgPSBbXHJcbiAgICAnLmRuLWFycm93JyxcclxuICAgICdpbWcnLFxyXG4gICAgJy5kZXJpdmF0aW9uLW5vZGVfYm9keS1zY3JvbGxlcicsXHJcbl07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZXhwb3J0VG9TVkcgKHBhcGVyLCBwcm9wcykge1xyXG4gICAgcHJvcHMgPSBwcm9wcyB8fCB7fTtcclxuXHJcbiAgICBjb25zdCB2cFRyYW5zZm9ybSA9IHBhcGVyLnZpZXdwb3J0LmdldEF0dHJpYnV0ZSgndHJhbnNmb3JtJyk7XHJcbiAgICBwYXBlci52aWV3cG9ydC5yZW1vdmVBdHRyaWJ1dGUoJ3RyYW5zZm9ybScpO1xyXG5cclxuICAgIC8vIGNvbnN0IHBhcGVyQm91bmRpbmdCb3ggPSBwYXBlci52aWV3cG9ydC5nZXRCQm94KCk7XHJcbiAgICBjb25zdCBwYXBlckJvdW5kaW5nQm94ID0gcGFwZXIuZ2V0Q29udGVudEJCb3goKTtcclxuICAgIGNvbnN0IHN2Z0NvcHkgPSBwcm9wcy5jb252ZXJ0SHRtbCA/IGNyZWF0ZVNWR0NvcHkocGFwZXIpIDogc2ltcGxlQ2xvbmUocGFwZXIpO1xyXG5cclxuICAgIHBhcGVyLnZpZXdwb3J0LnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywgdnBUcmFuc2Zvcm0gfHwgJycpO1xyXG5cclxuICAgIGlmIChwcm9wcy5wZGZNb2RlKSB7XHJcbiAgICAgICAgc3ZnQ29weS5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJyk7XHJcbiAgICAgICAgc3ZnQ29weS5zZXRBdHRyaWJ1dGUoJ3ByZXNlcnZlQXNwZWN0UmF0aW8nLCAneE1pZFlNaWQgbWVldCcpO1xyXG4gICAgICAgIHN2Z0NvcHkucmVtb3ZlQXR0cmlidXRlKCdoZWlnaHQnKTtcclxuICAgICAgICBpZiAocHJvcHMucHJlc2VydmVEaW1lbnNpb25zKSB7XHJcbiAgICAgICAgICAgIHN2Z0NvcHkuc2V0QXR0cmlidXRlKCd3aWR0aCcsIHBhcGVyQm91bmRpbmdCb3gud2lkdGgudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc3ZnQ29weS5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgJzEwMCUnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IFBBRERJTkcgPSA0MDtcclxuICAgICAgICBzdmdDb3B5LnNldEF0dHJpYnV0ZSgndmlld0JveCcsIFtcclxuICAgICAgICAgICAgcGFwZXJCb3VuZGluZ0JveC54IC0gUEFERElORyxcclxuICAgICAgICAgICAgcGFwZXJCb3VuZGluZ0JveC55IC0gUEFERElORyxcclxuICAgICAgICAgICAgcGFwZXJCb3VuZGluZ0JveC54ICsgcGFwZXJCb3VuZGluZ0JveC53aWR0aCArIFBBRERJTkcsXHJcbiAgICAgICAgICAgIHBhcGVyQm91bmRpbmdCb3gueSArIHBhcGVyQm91bmRpbmdCb3guaGVpZ2h0ICsgUEFERElORyxcclxuICAgICAgICBdLmpvaW4oJyAnKSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHN2Z0NvcHkucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xyXG4gICAgICAgIGlmIChwcm9wcy5wcmVzZXJ2ZURpbWVuc2lvbnMpIHtcclxuICAgICAgICAgICAgc3ZnQ29weS5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgcGFwZXJCb3VuZGluZ0JveC53aWR0aC50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgc3ZnQ29weS5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHBhcGVyQm91bmRpbmdCb3guaGVpZ2h0LnRvU3RyaW5nKCkpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHN2Z0NvcHkuc2V0QXR0cmlidXRlKCd3aWR0aCcsICcxMDAlJyk7XHJcbiAgICAgICAgICAgIHN2Z0NvcHkuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCAnMTAwJScpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3ZnQ29weS5zZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnLCAnJyArXHJcbiAgICAgICAgcGFwZXJCb3VuZGluZ0JveC54ICsgJyAnICtcclxuICAgICAgICBwYXBlckJvdW5kaW5nQm94LnkgKyAnICcgK1xyXG4gICAgICAgIHBhcGVyQm91bmRpbmdCb3gud2lkdGggKyAnICcgK1xyXG4gICAgICAgIHBhcGVyQm91bmRpbmdCb3guaGVpZ2h0KTtcclxuICAgIH1cclxuXHJcblxyXG5cclxuICAgIGNvbnN0IGlzSUUgPSAhKHdpbmRvdy5BY3RpdmVYT2JqZWN0KSAmJiAnQWN0aXZlWE9iamVjdCcgaW4gd2luZG93O1xyXG5cclxuICAgIGlmKGlzSUUpe1xyXG4gICAgICBhbGlnblRleHQoc3ZnQ29weS5xdWVyeVNlbGVjdG9yQWxsKCd0ZXh0JykpO1xyXG5cclxuICAgICAgLy9TaGltIFNWR0VsZW1lbnQgY2xhc3NMaXN0XHJcbiAgICAgIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihTVkdFbGVtZW50LnByb3RvdHlwZSwnY2xhc3NMaXN0Jykpe1xyXG4gICAgICAgICAgaWYgKEhUTUxFbGVtZW50ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoSFRNTEVsZW1lbnQucHJvdG90eXBlLCdjbGFzc0xpc3QnKSl7XHJcbiAgICAgICAgICAgIHZhciBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihIVE1MRWxlbWVudC5wcm90b3R5cGUsICdjbGFzc0xpc3QnKTtcclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNWR0VsZW1lbnQucHJvdG90eXBlLCdjbGFzc0xpc3QnLCBkZXNjcmlwdG9yKTtcclxuICAgICAgICAgIH1cclxuICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyB3b3JrYXJvdW5kIHRvIGluY2x1ZGUgb25seSBvbnRvZGlhLXJlbGF0ZWQgc3R5bGVzaGVldHNcclxuICAgIGNvbnN0IGNzc1N0cmluZ3MgPSBleHRyYWN0Q1NTRnJvbVBhcGVyKHN2Z0NvcHkpO1xyXG5cclxuICAgIGNvbnN0IGRlZnMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgJ2RlZnMnKTtcclxuICAgIGRlZnMuaWQgPSAnZXh0cmFjdGVkLXN0eWxlcyc7IC8vIEZvciBJRS1FREdFXHJcbiAgICBjc3NTdHJpbmdzLmZvckVhY2goKGNzc1N0cmluZywgaW5kZXgpID0+IHtcclxuICAgICAgICBjb25zdCBtb2NEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTtcclxuICAgICAgICBtb2NEaXYuaWQgPSAnZXh0cmFjdGVkLWZpbGUtJyArIGluZGV4O1xyXG4gICAgICAgIG1vY0Rpdi5pbm5lckhUTUwgPSAnPHN0eWxlPicgKyBjc3NTdHJpbmdzICsgJzwvc3R5bGU+JztcclxuICAgICAgICBkZWZzLmFwcGVuZENoaWxkKG1vY0Rpdi5maXJzdENoaWxkKTtcclxuICAgIH0pO1xyXG4gICAgc3ZnQ29weS5pbnNlcnRCZWZvcmUoZGVmcywgc3ZnQ29weS5maXJzdENoaWxkKTtcclxuXHJcblxyXG4gICAgaWYgKHByb3BzLmVsZW1lbnRzVG9SZW1vdmVTZWxlY3Rvcikge1xyXG4gICAgICAgIHByb2Nlc3NOb2RlcyhzdmdDb3B5LnF1ZXJ5U2VsZWN0b3JBbGwocHJvcHMuZWxlbWVudHNUb1JlbW92ZVNlbGVjdG9yKSxcclxuICAgICAgICAgICAgbm9kZSA9PiBub2RlLnJlbW92ZSgpKTtcclxuICAgIH1cclxuICAgIHJldHVybiBjb252ZXJ0SW1hZ2VzKHN2Z0NvcHkucXVlcnlTZWxlY3RvckFsbCgnaW1hZ2UnKSkudGhlbigoKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBYTUxTZXJpYWxpemVyKCkuc2VyaWFsaXplVG9TdHJpbmcoc3ZnQ29weSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gYWxpZ25UZXh0ICh0ZXh0QmxvY2tzKSB7XHJcbiAgICBwcm9jZXNzTm9kZXModGV4dEJsb2NrcywgKHRleHQpID0+IHtcclxuICAgICAgICBjb25zdCBhbmNob3IgPSB0ZXh0LmdldEF0dHJpYnV0ZSgndGV4dC1hbmNob3InKTtcclxuICAgICAgICBjb25zdCB0cmFuc2Zvcm0gPSB0ZXh0LmdldEF0dHJpYnV0ZSgndHJhbnNmb3JtJyk7XHJcbiAgICAgICAgaWYgKGFuY2hvciA9PT0gJ21pZGRsZScgJiYgdHJhbnNmb3JtLmluZGV4T2YoJ3RyYW5zbGF0ZScpKSB7XHJcbiAgICAgICAgICAgIHRleHQucmVtb3ZlQXR0cmlidXRlKCd0ZXh0LWFuY2hvcicpO1xyXG4gICAgICAgICAgICBjb25zdCB5ID0gdHJhbnNmb3JtLm1hdGNoKC8sKFtcXGQsLl0rKVxcKS8pWzFdO1xyXG4gICAgICAgICAgICB0ZXh0LnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgke0xBQkVMX0xFRlRfUklHSFRfUEFERElOR30sICR7eX0pYCk7XHJcblxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb252ZXJ0SW1hZ2VzIChpbWFnZXMpIHtcclxuICAgIGNvbnN0IHByb21pc2VzID0gW107XHJcbiAgICBwcm9jZXNzTm9kZXMoaW1hZ2VzLCAoaW1hZ2UpID0+IHtcclxuICAgICAgICBwcm9taXNlcy5wdXNoKG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghaW1hZ2UpIHJlc29sdmUoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEZpcmVmb3ggdXNlcyBgaHJlZmAsIGFsbCB0aGUgb3RoZXJzICd4bGluazpocmVmJ1xyXG4gICAgICAgICAgICB2YXIgdXJsID0gaW1hZ2UuZ2V0QXR0cmlidXRlKCd4bGluazpocmVmJykgfHwgaW1hZ2UuZ2V0QXR0cmlidXRlKCdocmVmJyk7XHJcblxyXG4gICAgICAgICAgICBqb2ludC51dGlsLmltYWdlVG9EYXRhVXJpKHVybCwgKGVyciwgZGF0YVVyaSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaW1hZ2Uuc2V0QXR0cmlidXRlKCd4bGluazpocmVmJywgZGF0YVVyaSk7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcclxufVxyXG5cclxuY29uc3QgRVhDTFVERURfU0VMRUNUT1JTID0gWyAnYm9keScgXTtcclxuZnVuY3Rpb24gZXh0cmFjdENTU0Zyb21QYXBlciAocGFwZXIpIHtcclxuICAgIGNvbnN0IGNzc1RleHRzID0gW107XHJcbiAgICBjb25zdCBhbGxFbGVtZW50cyA9IHBhcGVyLnF1ZXJ5U2VsZWN0b3JBbGwoJyonKTtcclxuXHJcbiAgICBjb25zdCBhbGxvd2VkQ3NzQ2xhc3NlcyA9IFtdO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbGxFbGVtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBhbGxFbGVtZW50c1tpXTtcclxuXHJcbiAgICAgICAgY29uc3QgY2xhc3Nlc0xpc3QgPSBlbGVtZW50LmNsYXNzTGlzdDtcclxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNsYXNzZXNMaXN0Lmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgIGFsbG93ZWRDc3NDbGFzc2VzLnB1c2goY2xhc3Nlc0xpc3Rbal0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkb2N1bWVudC5zdHlsZVNoZWV0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGxldCBjc3NDbGFzc2VzO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNzc0ZpbGUgPSBkb2N1bWVudC5zdHlsZVNoZWV0c1tpXTtcclxuICAgICAgICAgICAgY3NzQ2xhc3NlcyA9IGNzc0ZpbGUuY3NzUnVsZXMgfHwgY3NzRmlsZS5ydWxlcztcclxuICAgICAgICAgICAgaWYgKCFjc3NDbGFzc2VzKSB7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBjb250aW51ZTsgfVxyXG5cclxuICAgICAgICBjb25zdCBjc3NDbGFzc1RleHQgPSBbXTtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjc3NDbGFzc2VzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJ1bGUgPSBjc3NDbGFzc2VzW2pdO1xyXG4gICAgICAgICAgICBjb25zdCBkb2VzQ29udGFpbkFsbG93ZWRDbGFzcyA9IGNvbnRhaW5zQWxsb3dlZENsYXNzKHJ1bGUuc2VsZWN0b3JUZXh0LCBhbGxvd2VkQ3NzQ2xhc3Nlcyk7XHJcbiAgICAgICAgICAgIGNvbnN0IGFsbG93ZWRTZWxlY3RvciA9IEVYQ0xVREVEX1NFTEVDVE9SUy5pbmRleE9mKHJ1bGUuc2VsZWN0b3JUZXh0KSA9PT0gLTEgJiYgZG9lc0NvbnRhaW5BbGxvd2VkQ2xhc3M7XHJcbiAgICAgICAgICAgIGlmIChydWxlIGluc3RhbmNlb2YgQ1NTU3R5bGVSdWxlICYmIGFsbG93ZWRTZWxlY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgY3NzQ2xhc3NUZXh0LnB1c2gocnVsZS5jc3NUZXh0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY3NzVGV4dHMucHVzaChjc3NDbGFzc1RleHQuam9pbignXFxuJykpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNvbnRhaW5zQWxsb3dlZENsYXNzIChjc3NTZWxlY3RvciwgYWxsb3dlZENzc0NsYXNzZXMpIHtcclxuICAgICAgICBpZiAoIWNzc1NlbGVjdG9yKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFsbG93ZWRDc3NDbGFzc2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChjc3NTZWxlY3Rvci5pbmRleE9mKGFsbG93ZWRDc3NDbGFzc2VzW2ldKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gY3NzVGV4dHM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNpbXBsZUNsb25lIChwYXBlcikge1xyXG4gICAgY29uc3Qgc3ZnQ2xvbmUgPSBwYXBlci5zdmcuY2xvbmVOb2RlKHRydWUpO1xyXG4gICAgcmV0dXJuIHN2Z0Nsb25lO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVTVkdDb3B5IChwYXBlcikge1xyXG4gICAgY29uc3Qgc3ZnQ2xvbmUgPSBwYXBlci5zdmcuY2xvbmVOb2RlKHRydWUpO1xyXG4gICAgY29uc3QgY2VsbHMgPSBwYXBlci5tb2RlbC5nZXQoJ2NlbGxzJyk7XHJcbiAgICBwcm9jZXNzTm9kZXMoc3ZnQ2xvbmUucXVlcnlTZWxlY3RvckFsbCgnZy5lbGVtZW50JyksIGNlbGxWaWV3ID0+IHtcclxuICAgICAgICBjb25zdCBpZCA9IGNlbGxWaWV3LmdldEF0dHJpYnV0ZSgnbW9kZWwtaWQnKTtcclxuICAgICAgICBjb25zdCBodG1sVmlldyA9IHBhcGVyLmVsLnF1ZXJ5U2VsZWN0b3IoYC5kZXJpdmF0aW9uLW5vZGVbaWQ9JyR7aWR9J11gKTtcclxuICAgICAgICBpZiAoIWh0bWxWaWV3KSB7IHJldHVybjsgfVxyXG5cclxuICAgICAgICBsZXQgY29udGVudDtcclxuICAgICAgICBjb25zdCBpc0l0SUUxMSA9IEJvb2xlYW4obmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvVHJpZGVudC4qcnZcXDoxMVxcLi8pKTtcclxuICAgICAgICBpZiAoaXNJdElFMTEpIHtcclxuICAgICAgICAgICAgY29udGVudCA9IHByb2Nlc3NIVE1MKGh0bWxWaWV3LCBFWENMVURFRF9FTEVNRU5UUyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCAnZm9yZWlnbk9iamVjdCcpO1xyXG4gICAgICAgICAgICBjb25zdCBjZWxsID0gY2VsbHMuZ2V0KGlkKTtcclxuICAgICAgICAgICAgY29uc3QgY2VsbFNpemUgPSBjZWxsLmdldCgnc2l6ZScpO1xyXG5cclxuICAgICAgICAgICAgY29udGVudC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgY2VsbFNpemUud2lkdGggKyBGT1JFSUdOX09CSkVDVF9QQURESU5HKTtcclxuICAgICAgICAgICAgY29udGVudC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIGNlbGxTaXplLmhlaWdodCArIEZPUkVJR05fT0JKRUNUX1BBRERJTkcpO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgaHRtbENvbnRlbnQgPSBodG1sVmlldy5jbG9uZU5vZGUodHJ1ZSk7XHJcbiAgICAgICAgICAgIGh0bWxDb250ZW50LnN0eWxlLnRyYW5zZm9ybSA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBib2R5ID0gaHRtbFZpZXcucXVlcnlTZWxlY3RvcignLmRlcml2YXRpb24tbm9kZV9ib2R5Jyk7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld0JvZGllcyA9IGh0bWxDb250ZW50LnF1ZXJ5U2VsZWN0b3IoJy5kZXJpdmF0aW9uLW5vZGVfYm9keScpO1xyXG4gICAgICAgICAgICBpZiAoYm9keS5zY3JvbGxUb3AgIT09IDApIHtcclxuICAgICAgICAgICAgICAgIG5ld0JvZGllcy5maXJzdENoaWxkLnN0eWxlLm1hcmdpblRvcCA9ICgtYm9keS5zY3JvbGxUb3ApICsgJ3B4JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb250ZW50LmFwcGVuZENoaWxkKGh0bWxDb250ZW50KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNlbGxWaWV3LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjZWxsVmlldy5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykpO1xyXG5cclxuICAgICAgICBjb25zdCBhbmNob3IgPSBjZWxsVmlldy5xdWVyeVNlbGVjdG9yKCcuZXhwb3J0LWFuY2hvcicpO1xyXG4gICAgICAgIGFuY2hvci5yZW1vdmVBdHRyaWJ1dGUoJ3RyYW5zZm9ybScpO1xyXG5cclxuICAgICAgICBjb25zdCByb290ID0gY2VsbFZpZXcucXVlcnlTZWxlY3RvcignLmJvZHknKTtcclxuICAgICAgICBhbmNob3IucmVtb3ZlQ2hpbGQocm9vdCk7XHJcbiAgICAgICAgYW5jaG9yLmFwcGVuZENoaWxkKGNvbnRlbnQpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHN2Z0Nsb25lO1xyXG59XHJcblxyXG5cclxuXHJcbmZ1bmN0aW9uIHByb2Nlc3NIVE1MIChodG1sVmlldywgZXhjbHVkZWRFbGVtZW50cykge1xyXG4gICAgY29uc3QgZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCAnZycpO1xyXG5cclxuICAgIGZ1bmN0aW9uIHJlY3Vyc2lvbiAoaHRtbFJvb3QpIHtcclxuICAgICAgICBpZiAoaHRtbFJvb3QgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xyXG4gICAgICAgICAgICBpZiAoY2hlY2tFbGVtZW50KGh0bWxSb290KSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCAncmVjdCcpO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0VG9wID0gZ2V0T2Zmc2V0VG9wKGh0bWxSb290KTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldExlZnQgPSBnZXRPZmZzZXRMZWZ0KGh0bWxSb290KTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoaHRtbFJvb3QpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIHN2Z1JlY3Quc2V0QXR0cmlidXRlKCdjbGFzc05hbWUnLCBodG1sUm9vdC5jbGFzc05hbWUpO1xyXG4gICAgICAgICAgICAgICAgcmVjdC5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCBzdHlsZS5iYWNrZ3JvdW5kQ29sb3IpO1xyXG4gICAgICAgICAgICAgICAgcmVjdC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZScsIHN0eWxlLmJvcmRlckNvbG9yKTtcclxuICAgICAgICAgICAgICAgIHJlY3Quc2V0QXR0cmlidXRlKCdzdHJva2Utd2lkdGgnLCBzdHlsZS5ib3JkZXJXaWR0aCk7XHJcbiAgICAgICAgICAgICAgICByZWN0LnNldEF0dHJpYnV0ZSgneCcsIG9mZnNldExlZnQpO1xyXG4gICAgICAgICAgICAgICAgcmVjdC5zZXRBdHRyaWJ1dGUoJ3knLCBvZmZzZXRUb3ApO1xyXG4gICAgICAgICAgICAgICAgcmVjdC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgc3R5bGUud2lkdGgpO1xyXG4gICAgICAgICAgICAgICAgcmVjdC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHN0eWxlLmhlaWdodCk7XHJcblxyXG4gICAgICAgICAgICAgICAgZy5hcHBlbmRDaGlsZChyZWN0KTtcclxuICAgICAgICAgICAgICAgIHByb2Nlc3NOb2RlcyhodG1sUm9vdC5jaGlsZE5vZGVzLCBjaGlsZCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVjdXJzaW9uKGNoaWxkLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChodG1sUm9vdCBpbnN0YW5jZW9mIFRleHQpIHtcclxuICAgICAgICAgICAgY29uc3QgdGV4dENvbnRlbnQgPSBodG1sUm9vdC50ZXh0Q29udGVudC50cmltKCk7XHJcbiAgICAgICAgICAgIGlmICh0ZXh0Q29udGVudC5sZW5ndGggPT09IDApIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHRleHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgJ3RleHQnKTtcclxuICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gaHRtbFJvb3QucGFyZW50Tm9kZTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldFRvcCA9IGdldE9mZnNldFRvcChwYXJlbnQpO1xyXG4gICAgICAgICAgICBjb25zdCBvZmZzZXRMZWZ0ID0gZ2V0T2Zmc2V0TGVmdChwYXJlbnQpO1xyXG4gICAgICAgICAgICBjb25zdCBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHBhcmVudCk7XHJcblxyXG4gICAgICAgICAgICB0ZXh0LnNldEF0dHJpYnV0ZSgnZmlsbCcsIHN0eWxlLmNvbG9yKTtcclxuICAgICAgICAgICAgdGV4dC5zZXRBdHRyaWJ1dGUoJ2FsaWdubWVudC1iYXNlbGluZScsICdoYW5naW5nJyk7XHJcbiAgICAgICAgICAgIHRleHQuc2V0QXR0cmlidXRlKCd4Jywgb2Zmc2V0TGVmdCk7XHJcbiAgICAgICAgICAgIHRleHQuc2V0QXR0cmlidXRlKCd5Jywgb2Zmc2V0VG9wKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IG1heENoYXJOdW1iZXIgPSBnZXRNYXhDaGFyTnVtYmVyKFxyXG4gICAgICAgICAgICAgICAgdGV4dENvbnRlbnQsXHJcbiAgICAgICAgICAgICAgICArc3R5bGUud2lkdGguc3Vic3RyaW5nKDAsIHN0eWxlLndpZHRoLmxlbmd0aCAtIDIpLFxyXG4gICAgICAgICAgICAgICAgc3R5bGUuZm9udFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBpZiAobWF4Q2hhck51bWJlciA9PT0gdGV4dENvbnRlbnQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0LnRleHRDb250ZW50ID0gdGV4dENvbnRlbnQ7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBFTElQU0lTX0xFTkdUSCA9IDI7XHJcbiAgICAgICAgICAgICAgICB0ZXh0LnRleHRDb250ZW50ID0gdGV4dENvbnRlbnQuc3Vic3RyaW5nKDAsIG1heENoYXJOdW1iZXIgLSBFTElQU0lTX0xFTkdUSCkgKyAnLi4uJztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZy5hcHBlbmRDaGlsZCh0ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY2hlY2tFbGVtZW50IChlbGVtZW50KSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBleGNsdWRlZEVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIC8vIElFMTEgZml4XHJcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoZXMgPSBlbGVtZW50Lm1hdGNoZXMgPyBlbGVtZW50Lm1hdGNoZXMgOiBlbGVtZW50Lm1zTWF0Y2hlc1NlbGVjdG9yO1xyXG4gICAgICAgICAgICBpZiAobWF0Y2hlcy5hcHBseShlbGVtZW50LCBbZXhjbHVkZWRFbGVtZW50c1tpXV0pKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0T2Zmc2V0VG9wIChlbGVtZW50KSB7XHJcbiAgICAgICAgaWYoZWxlbWVudC5jbGFzc05hbWUgIT09ICdkZXJpdmF0aW9uLW5vZGUnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50Lm9mZnNldFRvcCArIGVsZW1lbnQuY2xpZW50VG9wICsgKGVsZW1lbnQub2Zmc2V0UGFyZW50ID8gZ2V0T2Zmc2V0VG9wKGVsZW1lbnQub2Zmc2V0UGFyZW50KSA6IDApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRPZmZzZXRMZWZ0IChlbGVtZW50KSB7XHJcbiAgICAgICAgaWYoZWxlbWVudC5jbGFzc05hbWUgIT09ICdkZXJpdmF0aW9uLW5vZGUnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50Lm9mZnNldExlZnQgKyBlbGVtZW50LmNsaWVudExlZnQgKyAoZWxlbWVudC5vZmZzZXRQYXJlbnQgPyBnZXRPZmZzZXRMZWZ0KGVsZW1lbnQub2Zmc2V0UGFyZW50KSA6IDApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRNYXhDaGFyTnVtYmVyICh0ZXh0LCBtYXhXaWR0aCwgZm9udCkge1xyXG4gICAgICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgICAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICAgICAgY3R4LmZvbnQgPSBmb250O1xyXG5cclxuICAgICAgICBjb25zdCB0ZXh0V2lkdGggPSBjdHgubWVhc3VyZVRleHQodGV4dCkud2lkdGg7XHJcbiAgICAgICAgaWYgKHRleHRXaWR0aCA8PSBtYXhXaWR0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGV4dC5sZW5ndGg7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgRklUX0NPUlJFQ1RJT04gPSAwLjg1O1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcih0ZXh0Lmxlbmd0aCAqIChtYXhXaWR0aCAvIHRleHRXaWR0aCkgKiBGSVRfQ09SUkVDVElPTik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJlY3Vyc2lvbihodG1sVmlldyk7XHJcblxyXG4gICAgcmV0dXJuIGc7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHByb2Nlc3NOb2RlcyAobm9kZXMsIGNhbGxiYWNrKSB7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY2FsbGJhY2sobm9kZXNbaV0pO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdG9EYXRhVVJMIChwYXBlciwgb3B0aW9ucykge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XHJcbiAgICAgICAgY29uc3Qgc3ZnT3B0aW9ucyA9IF8uY2xvbmUob3B0aW9ucy5zdmdPcHRpb25zKTtcclxuXHJcbiAgICAgICAgY29uc3Qgb2xkVG9TdmcgPSBwYXBlci50b1NWRztcclxuICAgICAgICBwYXBlci50b1NWRyA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgICAgICAgICBleHBvcnRUb1NWRyAocGFwZXIsIHN2Z09wdGlvbnMpLnRoZW4oKHN2Z1N0cmluZykgPT4ge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soc3ZnU3RyaW5nKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBwYXBlci50b1BORyhmdW5jdGlvbiAoaW1hZ2UpIHtcclxuICAgICAgICAgICAgcmVzb2x2ZShpbWFnZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcGFwZXIudG9TVkcgPSBvbGRUb1N2ZztcclxuICAgIH0pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZml0UmVjdEtlZXBpbmdBc3BlY3RSYXRpbyAoc291cmNlV2lkdGgsIHNvdXJjZUhlaWdodCwgdGFyZ2V0V2lkdGgsIHRhcmdldEhlaWdodCkge1xyXG4gICAgaWYgKCF0YXJnZXRXaWR0aCAmJiAhdGFyZ2V0SGVpZ2h0KSB7XHJcbiAgICAgICAgcmV0dXJuIHsgd2lkdGg6IHNvdXJjZVdpZHRoLCBoZWlnaHQ6IHNvdXJjZUhlaWdodCB9O1xyXG4gICAgfVxyXG4gICAgY29uc3QgcmF0aW8gPSBzb3VyY2VXaWR0aCAvIHNvdXJjZUhlaWdodDtcclxuICAgIHRhcmdldFdpZHRoID0gdGFyZ2V0V2lkdGggfHwgKHRhcmdldEhlaWdodCAqIHJhdGlvKTtcclxuICAgIHRhcmdldEhlaWdodCA9IHRhcmdldEhlaWdodCB8fCAodGFyZ2V0V2lkdGggLyByYXRpbyk7XHJcblxyXG4gICAgaWYgKHRhcmdldEhlaWdodCAqIHJhdGlvIDw9IHRhcmdldFdpZHRoKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgd2lkdGg6IHRhcmdldEhlaWdodCAqIHJhdGlvLCBoZWlnaHQ6IHRhcmdldEhlaWdodCB9O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4geyB3aWR0aDogdGFyZ2V0V2lkdGgsIGhlaWdodDogdGFyZ2V0V2lkdGggLyByYXRpbyB9O1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBleHBvcnRUb1NWRztcclxuIiwiaW1wb3J0ICogYXMgam9pbnQgZnJvbSAncmFwcGlkJztcclxuaW1wb3J0IHtcclxuICAgIGxpbWl0UG9pbnRQb3NpdGlvbixcclxuICAgIGV4dGVuZEJvdW5kcyxcclxuICAgIGdsb2JhbFRvU2NhbGVkQm91bmRzLFxyXG4gICAgZ2xvYmFsVG9TY2FsZWRTaXplLFxyXG4gICAgc2NhbGVkVG9HbG9iYWxTaXplLFxyXG4gICAgZ2V0R2xvYmFsTm9kZVBvc2l0aW9uLFxyXG4gICAgZ2V0U2NhbGVkTm9kZVBvc2l0aW9uLFxyXG4gICAgZ2V0TG9jYWxOb2RlUG9zaXRpb24sXHJcbiAgICBzY2FsZWRUb0dsb2JhbFBvaW50LFxyXG4gICAgZ2xvYmFsVG9TY2FsZWRQb2ludCxcclxuICAgIGxvY2FsVG9HbG9iYWxQb2ludCxcclxuICAgIGdldEVsZW1lbnRTaXplLFxyXG59IGZyb20gJy4uL3V0aWxzL3V0aWxzJztcclxuaW1wb3J0IHsgWl9JTkRFWEVTIH0gZnJvbSAnLi9ncmFwaEVsZW1lbnRzL2VsZW1lbnRzJztcclxuXHJcbmNvbnN0IEhPUl9MQUJFTF9QQURESU5HID0gODtcclxuY29uc3QgVkVSVF9MQUJFTF9QQURESU5HID0gNjtcclxuY29uc3QgRk9OVF9TSVpFID0gMTE7XHJcbmNvbnN0IERFRkFVTFRfRlJBTUVfU0laRSA9IHsgd2lkdGg6IDUwLCBoZWlnaHQ6IDUwIH07XHJcblxyXG4vKipcclxuICogQm91bmRzXHJcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEJvdW5kc1xyXG4gKiBAcHJvcGVydHkge251bWJlcn0gbWF4WFxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gbWluWFxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gbWF4WVxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gbWluWVxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gd2lkdGhcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IGhlaWdodFxyXG4qL1xyXG5cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBjbGFzc1xyXG4gKiBWaWV3RnJhbWUgb2YgdGhlIG1haW4gdmlldyAoVmlldy0yKS5cclxuICogUHJvdmlkZXMgdmlzaWJsZSBlbGVtZW50cyB0byB0aGUgTGluZWFnZURpYWdyYW0uXHJcbiAqIEJhc2VkIG9uIGpvaW50LnNoYXBlcy5iYXNpYy5SZWN0LlxyXG4gKlxyXG4gKiBDb25zdHJ1Y3RvciBwYXJhbWV0ZXJzOlxyXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAqIEBwYXJhbSB7XHJcbiAqICBkYXRhQ29udGFpbmVyOiBEYXRhQ29udGFpbmVyXHJcbiAqICBpZDogc3RyaW5nXHJcbiAqICBiYWNrZ3JvdW5kQ29sb3I6IHN0cmluZ1xyXG4gKiAgYm9yZGVyQ29sb3I6IHN0cmluZ1xyXG4gKiAgc3BhY2VTaGFyZTogbnVtYmVyXHJcbiAqIH0gb3B0aW9uc1xyXG4gKiBAcGFyYW0ge1BhcmFtZXRlcnN9IHBhcmFtZXRlcnMgLSBwYXJhbWV0ZXJzIHNldFxyXG4gKlxyXG4gKiBQdWJsaWMgcHJvcGVydGllczpcclxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gKiBpZDogc3RyaW5nXHJcbiAqIG1vZGVsOiBAcGFyYW0gb3B0aW9uc1xyXG4gKiBjb25zdFBvc2l0aW9uOiBQb2ludFxyXG4gKiBzaXplOiBTaXplICh3aWR0aCwgaGVpZ2h0KVxyXG4gKiBtb3ZpbmdCeUl0c2VsZjogYm9vbGVuYSAtIGl0J3MgZmxhZyB0byBibG9jayBhIG1vdmluZ1xyXG4gKlxyXG4gKiBQdWJsaWMgbWV0aG9kczpcclxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gKiByZWZyZXNoTm9kZVN0YXRlOiAobm9kZTogTm9kZSkgPT4gdm9pZDtcclxuICogZ2V0Tm9kZXM6ICgpID0+IE5vZGVbXTtcclxuICogdXBkYXRlQm91bmRzOiAoKSA9PiB2b2lkO1xyXG4gKiBjbGVhcjogKCkgPT4gdm9pZDtcclxuICogZ2V0Tm9kZUJvdW5kczogKCkgPT4gQm91bmRzO1xyXG4gKiBnZXRWaWV3UG9ydEJvdW5kczogKCkgPT4gQm91bmRzO1xyXG4gKiBzZXREYXRhOiAoZGF0YUNvbnRhaW5lcjogRGF0YUNvbnRhaW5lcikgPT4gdm9pZFxyXG4gKiBnZXRWaXNpYmxlQ2VsbHM6ICgpID0+IHsgbm9kZXM6IE5vZGVbXSwgbGluazogTGlua1tdIH07XHJcbiAqIGNhbGN1bGF0ZVZpc2libGVDZWxsczogKCkgPT4gdm9pZDtcclxuICogc2V0UG9zaXRpb246IChwb3M6IFBvaW50KSA9PiB2b2lkO1xyXG4gKiBzZXRTaXplOiAoc2l6ZTogU2l6ZSkgPT4gdm9pZDtcclxuICogcG9zaXRpb25WaWV3UG9ydDogKHg6IG51bWJlciwgeTogbnVtYmVyKSA9PiBQb2ludDtcclxuICogcmVzZXRTaXplOiAoKSA9PiB2b2lkO1xyXG4gKiBoaXRTY2FsZWRQb2ludFRlc3QgKHBvaW50OiBQb2ludCkgPT4gYm9vbGVhbjtcclxuICogaGl0VGVzdCAobm9kZTogTm9kZSwgcGFydGlhbEhpdDogYm9vbGVhbikgPT4gYm9vbGVhbjtcclxuICogb3duZXJUZXN0IChub2RlOiBOb2RlKSA9PiBib29sZWFuO1xyXG4gKiBzZXRTY2FsZTogKHNjYWxlOiBQb2ludCkgPT4gdm9pZDtcclxuICogZ2V0U2NhbGU6ICgpID0+IFBvaW50O1xyXG4gKiBzZXRFbGVtZW50U2l6ZTogKHNpemU6IEVsZW1lbnRTaXplKSA9PiB2b2lkO1xyXG4gKiBnZXRFbGVtZW50U2l6ZTogKCkgPT4gRWxlbWVudFNpemU7XHJcbiAqIGxpbWl0Tm9kZVBvc2l0aW9uOiAobm9kZTogTm9kZSkgPT4gdm9pZDtcclxuICpcclxuICogRXZlbnRzXHJcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICogQGZpcmVzIGNoYW5nZTpjb3JyZWN0UG9zdGlvbiAobGltaXR0ZWRQb2ludDogUG9pbnQpXHJcbiAqIEBmaXJlcyBjaGFuZ2Utdmlldy1wb3J0LXBvc2l0aW9uIChuZXdQb3NpdGlvbjogUG9pbnQpXHJcbiAqXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gVmlld0ZyYW1lIChvcHRpb25zLCBwYXJhbWV0ZXJzKSB7XHJcbiAgICAvLyBJbml0XHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XHJcbiAgICBzZWxmLmlkID0gb3B0aW9ucy5pZDtcclxuICAgIHNlbGYubW9kZWwgPSBvcHRpb25zO1xyXG4gICAgc2VsZi5jb25zdFBvc2l0aW9uID0geyB4OiAwLCB5OiAwfTtcclxuXHJcbiAgICBzZWxmLnNpemUgPSBERUZBVUxUX0ZSQU1FX1NJWkU7XHJcbiAgICBzZWxmLm1vdmluZ0J5SXRzZWxmID0gZmFsc2U7XHJcblxyXG4gICAgaWYgKG9wdGlvbnMuc2luZ2xlTW9kZSkge1xyXG4gICAgICAgIG9wdGlvbnMuZGF0YUNvbnRhaW5lci5ub2Rlcy5mb3JFYWNoKG4gPT4gbi52aWV3RnJhbWVPd25lcklkID0gc2VsZi5pZCk7XHJcbiAgICB9XHJcblxyXG4gICAgc2VsZi5zZWxlY3RlZEVsZW1lbnQ7XHJcblxyXG4gICAgbGV0IF9jYWNoZWRSZXN1bHQ7XHJcbiAgICBsZXQgX25vZGVCb3VuZHM7XHJcbiAgICBsZXQgX3ZpZXdQb3J0UG9zaXRpb25Cb3VuZHM7XHJcbiAgICBsZXQgX2RhdGFDb250YWluZXIgPSBvcHRpb25zLmRhdGFDb250YWluZXI7XHJcbiAgICBsZXQgX3NjYWxlO1xyXG4gICAgbGV0IF92aWV3UG9ydFBvc2l0aW9uID0geyB4OiAwLCB5OiAwIH07IC8vIGdsb2JhbCBjb29yZGluYXRlc1xyXG4gICAgbGV0IF9kZWZhdWx0RWxlbWVudFNpemUgPSBwYXJhbWV0ZXJzLmVsZW1lbnRTaXplO1xyXG4gICAgbGV0IF9yZWZlcmVuY2VTaXplID0gX2RlZmF1bHRFbGVtZW50U2l6ZTtcclxuICAgIGxldCBfdmlld1BvcnRCb3VuZHM7XHJcblxyXG4gICAgY29uc3QgX2ZyYW1lUGFkZGluZyA9IHBhcmFtZXRlcnMuZnJhbWVQYWRkaW5nO1xyXG4gICAgY29uc3QgbGFiZWwgPSBqb2ludC51dGlsLmJyZWFrVGV4dChvcHRpb25zLmxhYmVsLCB7XHJcbiAgICAgICAgd2lkdGg6IHNlbGYuc2l6ZS53aWR0aCAtIEhPUl9MQUJFTF9QQURESU5HICogMlxyXG4gICAgfSk7XHJcblxyXG4gICAgam9pbnQuc2hhcGVzLmJhc2ljLlJlY3QuYXBwbHkoc2VsZiwgW3tcclxuICAgICAgICBpZDogb3B0aW9ucy5pZCxcclxuICAgICAgICB0eXBlOiAndmlld0ZyYW1lJyxcclxuICAgICAgICBwb3NpdGlvbjogeyB4OiAwLCB5OiAwIH0sXHJcbiAgICAgICAgc2l6ZTogc2VsZi5zaXplLFxyXG4gICAgICAgIGF0dHJzOiB7XHJcbiAgICAgICAgICAgIHJlY3Q6IHtcclxuICAgICAgICAgICAgICAgIGZpbGw6IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yLFxyXG5cclxuICAgICAgICAgICAgICAgIHN0cm9rZTogb3B0aW9ucy5ib3JkZXJDb2xvcixcclxuICAgICAgICAgICAgICAgIGNsYXNzOiAnYm9keSB2aWV3LWZyYW1lJyxcclxuICAgICAgICAgICAgICAgIHdpZHRoOiBzZWxmLnNpemUud2lkdGgsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHNlbGYuc2l6ZS5oZWlnaHQsXHJcbiAgICAgICAgICAgICAgICAnc3Ryb2tlLXdpZHRoJzogcGFyYW1ldGVycy5mcmFtZUJvcmRlcldpZHRoLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB0ZXh0OiB7XHJcbiAgICAgICAgICAgICAgICAneC1hbGlnbm1lbnQnOiAnbGVmdCcsXHJcbiAgICAgICAgICAgICAgICAndGV4dC1hbmNob3InOiAnbGVmdCcsXHJcbiAgICAgICAgICAgICAgICAnZm9udC13ZWlnaHQnOiAnYm9sZCcsXHJcbiAgICAgICAgICAgICAgICByZWY6ICdyZWN0JyxcclxuICAgICAgICAgICAgICAgICdyZWYteCc6IEhPUl9MQUJFTF9QQURESU5HLFxyXG4gICAgICAgICAgICAgICAgJ3JlZi15JzogVkVSVF9MQUJFTF9QQURESU5HICsgRk9OVF9TSVpFLFxyXG4gICAgICAgICAgICAgICAgdGV4dDogbGFiZWwuaW5kZXhPZignXFxuJykgPT09IC0xID8gbGFiZWwgOiBsYWJlbC5zdWJzdHJpbmcoMCwgbGFiZWwuaW5kZXhPZignXFxuJykpICsgJy4uLicsXHJcbiAgICAgICAgICAgICAgICBmaWxsOiBvcHRpb25zLmJvcmRlckNvbG9yXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHo6IFpfSU5ERVhFUy5WSUVXX0ZSQU1FLFxyXG4gICAgfV0pO1xyXG5cclxuICAgIGlmIChzZWxmLm1vZGVsLndpZHRoKSBzZWxmLm1vZGVsLndpZHRoID0gTWF0aC5hYnMoTWF0aC5tYXgoc2VsZi5tb2RlbC53aWR0aCwgcGFyYW1ldGVycy5mcmFtZVBhZGRpbmcueCAqIDIgKyAxKSk7XHJcbiAgICBpZiAoc2VsZi5tb2RlbC5oZWlnaHQpIHNlbGYubW9kZWwuaGVpZ2h0ID0gTWF0aC5hYnMoTWF0aC5tYXgoc2VsZi5tb2RlbC5oZWlnaHQsIHBhcmFtZXRlcnMuZnJhbWVQYWRkaW5nLnkgKiAyICsgMSkpO1xyXG5cclxuICAgIHNlbGYub24oJ2NoYW5nZTpwb3NpdGlvbicsIChjZWxsLCBwb3NpdGlvbikgPT4ge1xyXG4gICAgICAgIGlmICghc2VsZi5tb3ZpbmdCeUl0c2VsZikge1xyXG4gICAgICAgICAgICBzZWxmLm1vdmluZ0J5SXRzZWxmID0gdHJ1ZTtcclxuICAgICAgICAgICAgc2VsZi5wb3NpdGlvbihzZWxmLmNvbnN0UG9zaXRpb24ueCwgc2VsZi5jb25zdFBvc2l0aW9uLnkpO1xyXG4gICAgICAgICAgICBzZWxmLm1vdmluZ0J5SXRzZWxmID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBzY2FsZWRPZmZzZXQgPSB7XHJcbiAgICAgICAgICAgICAgICB4OiBzZWxmLmNvbnN0UG9zaXRpb24ueCAtIHBvc2l0aW9uLngsXHJcbiAgICAgICAgICAgICAgICB5OiBzZWxmLmNvbnN0UG9zaXRpb24ueSAtIHBvc2l0aW9uLnksXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNvbnN0IGdsb2JhbE9mZnNldCA9IHNjYWxlZFRvR2xvYmFsUG9pbnQoc2NhbGVkT2Zmc2V0LCBfc2NhbGUpO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgbmV3Vmlld1BvcnRQb3NpdGlvbiA9IHtcclxuICAgICAgICAgICAgICAgIHg6IF92aWV3UG9ydFBvc2l0aW9uLnggKyBnbG9iYWxPZmZzZXQueCxcclxuICAgICAgICAgICAgICAgIHk6IF92aWV3UG9ydFBvc2l0aW9uLnkgKyBnbG9iYWxPZmZzZXQueSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgc2VsZi50cmlnZ2VyKCdjaGFuZ2Utdmlldy1wb3J0LXBvc2l0aW9uJywgbmV3Vmlld1BvcnRQb3NpdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgX2luaXQob3B0aW9ucywgcGFyYW1ldGVycyk7XHJcblxyXG4gICAgc2VsZi5zZXQoJ2NvcnJlY3RQb3N0aW9uJywgbnVsbCk7XHJcblxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgXHJcbiAgICAvLyBDYWxsQmFjayB0byBvdmVycmlkZVxyXG4gICAgLy8gc2VsZi5fb25DaGFuZ2VCb3VuZHMgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGUgcG9zaXRpb24gYW5kIHNpemUgb2YgdGhlIG5vZGUuXHJcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcclxuICAgICovXHJcbiAgICBzZWxmLnJlZnJlc2hOb2RlU3RhdGUgPSBfcmVmcmVzaE5vZGVTdGF0ZTtcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGxpc3Qgb2Ygbm9kZXMgd2hpY2ggdmlld0ZyYW1lIG93bnMuXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkgb2YgTm9kZX1cclxuICAgICovXHJcbiAgICBzZWxmLmdldE5vZGVzID0gX2dldE5vZGVzOyBcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlY2FjbHVsYXRlIHZpZXdQb3J0IGJvdW5kc1xyXG4gICAgKi9cclxuICAgIHNlbGYudXBkYXRlQm91bmRzID0gX3VwZGF0ZUJvdW5kcztcclxuXHJcbiAgICAvKipcclxuICAgICAqIENsZWFyIGNhY2hlcy5cclxuICAgICovXHJcbiAgICBzZWxmLmNsZWFyID0gX2NsZWFyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVmlld0ZyYW1lIHB1YmxpYyBtb2RlbFxyXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gQm91bmRzXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbWluWFxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG1heFhcclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtaW5ZXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbWF4WVxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHdpZHRoXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gaGVpZ2h0XHJcbiAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBib3VuZHMgb2Ygdmlld0ZyYW1lIGluIHBhcGVyIGNvb3JkaW5hdGVzIHdpdGhvdXQgcGFkZGluZy5cclxuICAgICAqIEByZXR1cm5zIHtCb3VuZHN9XHJcbiAgICAqL1xyXG4gICAgc2VsZi5nZXROb2RlQm91bmRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfbm9kZUJvdW5kcztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGJvdW5kcyBvZiB2aWV3RnJhbWUgaW4gcGFwZXIgY29vcmRpbmF0ZXMuXHJcbiAgICAqL1xyXG4gICAgc2VsZi5nZXRWaWV3UG9ydEJvdW5kcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX3ZpZXdQb3J0Qm91bmRzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYm91bmRzIG9mIHZpZXdGcmFtZSBpbiBwYXBlciBjb29yZGluYXRlcy5cclxuICAgICovXHJcbiAgICBzZWxmLmdldFZpZXdQb3J0UG9zaXRpb25Cb3VuZHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF92aWV3UG9ydFBvc2l0aW9uQm91bmRzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYWxsIHZpc2libGUgaW4gdGhpcyB2aWV3cG9ydCBjZWxscyAoTGlua3N8Tm9kZXMgZS50LmMuKVxyXG4gICAgICogQHJldHVybnMge1xyXG4gICAgICogIG5vZGVzOiBOb2RlW10sXHJcbiAgICAgKiAgbGlua3M6IExpbmtbXSxcclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgc2VsZi5nZXRWaXNpYmxlQ2VsbHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCFfY2FjaGVkUmVzdWx0KSBzZWxmLmNhbGN1bGF0ZVZpc2libGVDZWxscygpO1xyXG4gICAgICAgIHJldHVybiBfY2FjaGVkUmVzdWx0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZSBsaXN0IG9mIGFsbCB2aXNpYmxlIGluIHRoaXMgdmlld3BvcnQgY2VsbHNcclxuICAgICAqIEBwYXJhbSB7Vmlld0ZyYW1lUmVuZGVyT3B0aW9uc30gb3B0aW9uc1xyXG4gICAgICovXHJcbiAgICBzZWxmLmNhbGN1bGF0ZVZpc2libGVDZWxscyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICAgICAgX3JlZmVyZW5jZVNpemUgPSBfY2FsY3VsYXRlUmVmZXJlbmNlTm9kZVNpemUob3B0aW9ucy5lbGVtZW50U2l6ZSB8fCBfZGVmYXVsdEVsZW1lbnRTaXplKTtcclxuICAgICAgICBfdmlld1BvcnRCb3VuZHMgPSBfZ2V0Vmlld1BvcnRCb3VuZHMoKTtcclxuXHJcbiAgICAgICAgY29uc3QgZ2xvYmFsU2l6ZSA9IHNjYWxlZFRvR2xvYmFsU2l6ZShzZWxmLnNpemUsIF9zY2FsZSk7XHJcbiAgICAgICAgY29uc3QgZ2xvYmFsUmVjdGFuZ2xlID0ge1xyXG4gICAgICAgICAgICB4OiBfdmlld1BvcnRQb3NpdGlvbi54LFxyXG4gICAgICAgICAgICB5OiBfdmlld1BvcnRQb3NpdGlvbi55LFxyXG4gICAgICAgICAgICB3aWR0aDogZ2xvYmFsU2l6ZS53aWR0aCxcclxuICAgICAgICAgICAgaGVpZ2h0OiBnbG9iYWxTaXplLmhlaWdodCxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IGFjdGl2ZUVsZW1lbnRzID0gX2RhdGFDb250YWluZXIuZ2V0RWxlbWVudHNGb3JSZWN0YW5nbGUoZ2xvYmFsUmVjdGFuZ2xlKTtcclxuXHJcbiAgICAgICAgY29uc3QgdmlzaWJsZU5vZGVNYXAgPSB7fTtcclxuICAgICAgICBjb25zdCB2aXNpYmxlTm9kZXMgPSBhY3RpdmVFbGVtZW50cy5ub2Rlcy5maWx0ZXIobm9kZSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzTm9kZVZpc2libGUgPSBfb3duZXJUZXN0KG5vZGUpICYmIF9oaXRUZXN0QnlHbG9iYWxQb3NpdGlvbihub2RlKTtcclxuICAgICAgICAgICAgaWYgKGlzTm9kZVZpc2libGUpIHZpc2libGVOb2RlTWFwW25vZGUuaWRdID0gbm9kZTtcclxuICAgICAgICAgICAgcmV0dXJuIGlzTm9kZVZpc2libGU7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHZpc2libGVOb2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xyXG4gICAgICAgICAgICBfcmVmcmVzaE5vZGVTdGF0ZShub2RlKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgX2NhY2hlZFJlc3VsdCA9IHtcclxuICAgICAgICAgICAgbm9kZXM6IHZpc2libGVOb2RlcyxcclxuICAgICAgICAgICAgbGlua3M6IGFjdGl2ZUVsZW1lbnRzLmxpbmtzLFxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyBwb3NpdGlvbiBvZiB0aGUgdmlld0ZyYW1lIG9uIHRoZSBwYXBlclxyXG4gICAgICogQHJldHVybnMge1xyXG4gICAgICogIG5vZGVzOiBOb2RlW10sXHJcbiAgICAgKiAgbGlua3M6IExpbmtbXSxcclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgc2VsZi5zZXRQb3NpdGlvbiA9IGZ1bmN0aW9uIChwb3MpIHtcclxuICAgICAgICBzZWxmLm1vdmluZ0J5SXRzZWxmID0gdHJ1ZTtcclxuICAgICAgICBzZWxmLmNvbnN0UG9zaXRpb24gPSBwb3M7XHJcbiAgICAgICAgc2VsZi5wb3NpdGlvbihzZWxmLmNvbnN0UG9zaXRpb24ueCwgc2VsZi5jb25zdFBvc2l0aW9uLnkpO1xyXG4gICAgICAgIHNlbGYubW92aW5nQnlJdHNlbGYgPSBmYWxzZTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGFuZ2VzIHNpemUgb2YgdGhlIHZpZXctcG9ydC1qb2ludGpzIGVsZW1lbnQuXHJcbiAgICAgKiBAcGFyYW0ge1NpemV9IHNpemVcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVtZW1iZXJcclxuICAgICAqL1xyXG4gICAgc2VsZi5zZXRTaXplID0gX3NldFNpemU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJdCBzZXRzIG9mZnNldCBmb3IgYWxsIGVsZW1lbnRzIGludG8gdGhlIHZpZXdQb3J0LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZvcmNlIC0gZGlzYWJsZXMgdGhlIGxpbWl0XHJcbiAgICAgKiBAcmV0dXJucyB7UG9pbnR9XHJcbiAgICAgKi9cclxuICAgIHNlbGYucG9zaXRpb25WaWV3UG9ydCA9IF9wb3NpdGlvblZpZXdQb3J0O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVzZXRzIHNpemUuXHJcbiAgICAgKi9cclxuICAgIHNlbGYucmVzZXRTaXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHNlbGYubW9kZWwud2lkdGggPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgc2VsZi5tb2RlbC5oZWlnaHQgPSB1bmRlZmluZWQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVsbHMgdXMgd2hldGhlciB0aGVcclxuICAgICAqIHBvaW50IGlzIGluIHRoZSB2aWV3UG9ydCBvZiBWaWV3RnJhbWUgb3Igbm90XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2NhbGVcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgKi9cclxuICAgIHNlbGYuaGl0U2NhbGVkUG9pbnRUZXN0ID0gX2hpdFNjYWxlZFBvaW50VGVzdDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlbGxzIHVzIHdoZXRoZXIgdGhlXHJcbiAgICAgKiBub2RlIGlzIGluIHRoZSB2aWV3UG9ydCBvZiBWaWV3RnJhbWUgb3Igbm90XHJcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgKi9cclxuICAgIHNlbGYuaGl0VGVzdEJ5U2NhbGVkUG9zaXRpb24gPSBfaGl0VGVzdEJ5U2NhbGVkUG9zaXRpb247XHJcblxyXG4gICAgc2VsZi5oaXRUZXN0QnlHbG9iYWxQb3NpdGlvbiA9IF9oaXRBcmVhVGVzdEJ5R2xvYmFsUG9zaXRpb247XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZWxscyB1cyB3aGV0aGVyIHRoZVxyXG4gICAgICogVmlld0ZyYW1lIGlzIG93bmVyIG9mIHRoZSBwYXNzZWQgbm9kZSBvciBub3RcclxuICAgICAqIGZ1bmN0aW9uIGZvciBvdmVycmlkaW5nXHJcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgKi9cclxuICAgIC8vIHNlbGYuX293bmVyVGVzdCAtIHRvIG92ZXJyaWRlXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBzY2FsZSBvZiB0aGUgdmlld0ZyYW1lLlxyXG4gICAgICogQHBhcmFtIHtQb2ludH0gc2NhbGVcclxuICAgICovXHJcbiAgICBzZWxmLnNldFNjYWxlID0gX3NldFNjYWxlO1xyXG4gICAgLy8gc2VsZi5fc2NhbGVXaWxsQXBwbGllZDsgLSB0byBvdmVycmlkZVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgc2NhbGUgb2YgdGhlIHZpZXdGcmFtZS5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICAqL1xyXG4gICAgc2VsZi5nZXRTY2FsZSA9IF9nZXRTY2FsZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGRlZmF1bHQgZWxlbWVudCBzaXplLlxyXG4gICAgICogQHBhcmFtIHtFbGVtZW50U2l6ZX0gZWxlbWVudFNpemVcclxuICAgICovXHJcbiAgICBzZWxmLnNldEVsZW1lbnRTaXplID0gZnVuY3Rpb24gKGVsZW1lbnRTaXplKSB7XHJcbiAgICAgICAgX2RlZmF1bHRFbGVtZW50U2l6ZSA9IGVsZW1lbnRTaXplO1xyXG4gICAgICAgIF91cGRhdGVCb3VuZHMoKTtcclxuICAgICAgICBfbGltaXRWaWV3UG9ydFBvc2l0aW9uKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgZGVmYXVsdCBlbGVtZW50IHNpemUuXHJcbiAgICAqL1xyXG4gICAgc2VsZi5nZXRFbGVtZW50U2l6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX2RlZmF1bHRFbGVtZW50U2l6ZTtcclxuICAgIH07XHJcblxyXG4gICAgc2VsZi5saW1pdE5vZGVQb3NpdGlvbiA9IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgY29uc3Qgbm9kZVNjYWxlZFNpemUgPSBub2RlLmNhbGN1bGF0ZVNpemUoX3JlZmVyZW5jZVNpemUpOyAvLyBzY2FsZWRcclxuICAgICAgICBjb25zdCBzY2FsZWRWaWV3UG9ydEJvdW5kcyA9IGdsb2JhbFRvU2NhbGVkQm91bmRzKF92aWV3UG9ydFBvc2l0aW9uQm91bmRzKTtcclxuICAgICAgICBjb25zdCBub2RlTWluU2NhbGVkUG9zaXRpb24gPSBnZXRTY2FsZWROb2RlUG9zaXRpb24obm9kZSwgX3NjYWxlKTtcclxuICAgICAgICBcclxuICAgICAgICBjb25zdCBsaW1pdEJ5TWluID0gbGltaXRQb2ludFBvc2l0aW9uKG5vZGVNaW5TY2FsZWRQb3NpdGlvbiwgc2NhbGVkVmlld1BvcnRCb3VuZHMpO1xyXG4gICAgICAgIGNvbnN0IG5vZGVNYXhTY2FsZWRQb3NpdGlvbiA9IHtcclxuICAgICAgICAgICAgeDogbGltaXRCeU1pbi54ICsgbm9kZVNjYWxlZFNpemUud2lkdGgsXHJcbiAgICAgICAgICAgIHk6IGxpbWl0QnlNaW4ueSArIG5vZGVTY2FsZWRTaXplLmhlaWdodCxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IGxpbWl0QnlNYXggPSBsaW1pdFBvaW50UG9zaXRpb24obm9kZU1heFNjYWxlZFBvc2l0aW9uLCBzY2FsZWRWaWV3UG9ydEJvdW5kcyk7XHJcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSBzY2FsZWRUb0dsb2JhbFBvaW50KGxpbWl0QnlNYXgsIF9zY2FsZSk7XHJcblxyXG4gICAgICAgIG5vZGUubW9kZWwucG9zaXRpb24gPSBwb3NpdGlvbjtcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gX2luaXQgKG9wdGlvbnMpIHtcclxuICAgICAgICBpZiAob3B0aW9ucy5zY2FsZSkge1xyXG4gICAgICAgICAgICBfc2NhbGUgPSBvcHRpb25zLnNjYWxlO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoc2VsZi5fc2NhbGVXaWxsQXBwbGllZCkge1xyXG4gICAgICAgICAgICBfc2NhbGUgPSBzZWxmLl9zY2FsZVdpbGxBcHBsaWVkKHBhcmFtZXRlcnMuZGVmYXVsdFNjYWxlKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBfc2NhbGUgPSBwYXJhbWV0ZXJzLmRlZmF1bHRTY2FsZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9wdGlvbnMubm9kZUJvdW5kcykge1xyXG4gICAgICAgICAgICBfbm9kZUJvdW5kcyA9IG9wdGlvbnMubm9kZUJvdW5kcztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBfbm9kZUJvdW5kcyA9IF9jYWxjdWxhdGVCb3VuZHMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9wdGlvbnMudmlld1BvcnRQb3NpdGlvbikge1xyXG4gICAgICAgICAgICBfdmlld1BvcnRQb3NpdGlvbiA9IG9wdGlvbnMudmlld1BvcnRQb3NpdGlvbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9wdGlvbnMudmlld1BvcnRQb3NpdGlvbkJvdW5kcykge1xyXG4gICAgICAgICAgICBfdmlld1BvcnRQb3NpdGlvbkJvdW5kcyA9IG9wdGlvbnMudmlld1BvcnRQb3NpdGlvbkJvdW5kcztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBfdmlld1BvcnRQb3NpdGlvbkJvdW5kcyA9IF9jYWxjdWxhdGVWaWV3UG9ydFBvc2l0aW9uQm91bmRzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF92aWV3UG9ydEJvdW5kcyA9IF9nZXRWaWV3UG9ydEJvdW5kcygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgc2NhbGUgb2YgdGhlIHZpZXdGcmFtZS5cclxuICAgICAqIEBwYXJhbSB7UG9pbnR9IHNjYWxlXHJcbiAgICAqL1xyXG4gICAgZnVuY3Rpb24gX3NldFNjYWxlIChzY2FsZSkge1xyXG4gICAgICAgIGlmIChzZWxmLl9zY2FsZVdpbGxBcHBsaWVkKSB7XHJcbiAgICAgICAgICAgIF9zY2FsZSA9IHNlbGYuX3NjYWxlV2lsbEFwcGxpZWQoc2NhbGUpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIF9zY2FsZSA9IHNjYWxlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfdXBkYXRlQm91bmRzKCk7XHJcbiAgICAgICAgX2xpbWl0Vmlld1BvcnRQb3NpdGlvbigpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgc2NhbGUgb2YgdGhlIHZpZXdGcmFtZS5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICAqL1xyXG4gICAgZnVuY3Rpb24gX2dldFNjYWxlICgpIHtcclxuICAgICAgICByZXR1cm4gX3NjYWxlO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIF9jbGVhciAoKSB7XHJcbiAgICAgICAgX2NhY2hlZFJlc3VsdCA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEl0IHNldHMgb2Zmc2V0IGZvciBhbGwgZWxlbWVudHMgaW50byB0aGUgdmlld1BvcnQuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZm9yY2UgLSBkaXNhYmxlcyB0aGUgbGltaXRcclxuICAgICAqIEByZXR1cm5zIHtQb2ludH1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gX3Bvc2l0aW9uVmlld1BvcnQgKHgsIHkpIHtcclxuICAgICAgICBpZiAoeCAhPT0gdW5kZWZpbmVkKSBfdmlld1BvcnRQb3NpdGlvbi54ID0geDtcclxuICAgICAgICBpZiAoeSAhPT0gdW5kZWZpbmVkKSBfdmlld1BvcnRQb3NpdGlvbi55ID0geTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHsgeDogX3ZpZXdQb3J0UG9zaXRpb24ueCwgeTogX3ZpZXdQb3J0UG9zaXRpb24ueSB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBsaXN0IG9mIG5vZGVzIHdoaWNoIHZpZXdGcmFtZSBvd25zLlxyXG4gICAgICogQHJldHVybnMge0FycmF5IG9mIE5vZGV9XHJcbiAgICAqL1xyXG4gICAgZnVuY3Rpb24gX2dldE5vZGVzICgpIHtcclxuICAgICAgICByZXR1cm4gX2RhdGFDb250YWluZXIubm9kZXMuZmlsdGVyKG4gPT4gX293bmVyVGVzdChuKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGFuZ2VzIHNpemUgb2YgdGhlIHZpZXctcG9ydC1qb2ludGpzIGVsZW1lbnQuXHJcbiAgICAgKiBAcGFyYW0ge1NpemV9IHNpemVcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVtZW1iZXJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gX3NldFNpemUgKHNpemUpIHtcclxuICAgICAgICBzZWxmLm1vdmluZ0J5SXRzZWxmID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgLy8gaXQncyBiZXN0IHNvbHV0aW9uIHRvIGZpeCB0aGUgc3ZnIGV4cG9ydGluZ1xyXG4gICAgICAgIC8vIGFuZCBmb3IgYmV0dGVyIGNvbXBhdGliaWxpdHkgSUUxMVxyXG4gICAgICAgIHNlbGYuYXR0cih7XHJcbiAgICAgICAgICAgICdyZWN0Jzoge1xyXG4gICAgICAgICAgICAgICAgd2lkdGg6IHNpemUud2lkdGgsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHNpemUuaGVpZ2h0LFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAgICAgc2VsZi5yZXNpemUoc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQpO1xyXG4gICAgICAgIHNlbGYuc2l6ZSA9IHNpemU7XHJcbiAgICAgICAgc2VsZi5tb2RlbC53aWR0aCA9IHNpemUud2lkdGg7XHJcbiAgICAgICAgc2VsZi5tb2RlbC5oZWlnaHQgPSBzaXplLmhlaWdodDtcclxuXHJcbiAgICAgICAgc2VsZi5tb3ZpbmdCeUl0c2VsZiA9IGZhbHNlO1xyXG5cclxuICAgICAgICBjb25zdCBsYWJlbCA9IGpvaW50LnV0aWwuYnJlYWtUZXh0KG9wdGlvbnMubGFiZWwsIHtcclxuICAgICAgICAgICAgd2lkdGg6IHNlbGYuc2l6ZS53aWR0aCAtIEhPUl9MQUJFTF9QQURESU5HICogMlxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnN0IGNvbXBsZXRlTGFiZWwgPSBsYWJlbC5pbmRleE9mKCdcXG4nKSA9PT0gLTEgPyBsYWJlbCA6IGxhYmVsLnN1YnN0cmluZygwLCBsYWJlbC5pbmRleE9mKCdcXG4nKSkgKyAnLi4uJztcclxuICAgICAgICBzZWxmLmF0dHIoJ3RleHQvdGV4dCcsIGNvbXBsZXRlTGFiZWwpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlIHBvc2l0aW9uIGFuZCBzaXplIG9mIHRoZSBub2RlLlxyXG4gICAgKi9cclxuICAgIGZ1bmN0aW9uIF9yZWZyZXNoTm9kZVN0YXRlIChub2RlKSB7XHJcbiAgICAgICAgY29uc3Qgbm9kZVBvc2l0aW9uID0gZ2V0TG9jYWxOb2RlUG9zaXRpb24obm9kZSwgX3NjYWxlLCBzZWxmKTtcclxuICAgICAgICBub2RlLnBvc2l0aW9uKG5vZGVQb3NpdGlvbi54LCBub2RlUG9zaXRpb24ueSk7XHJcbiAgICAgICAgbm9kZS5zZXRTaXplKF9yZWZlcmVuY2VTaXplKTtcclxuICAgICAgICBpZiAocGFyYW1ldGVycy5jbGlwTm9kZXMpIHtcclxuICAgICAgICAgICAgX2NsaXBOb2RlKG5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfdXBkYXRlQm91bmRzICgpIHtcclxuICAgICAgICBfbm9kZUJvdW5kcyA9IF9jYWxjdWxhdGVCb3VuZHMoKTtcclxuICAgICAgICBfdmlld1BvcnRQb3NpdGlvbkJvdW5kcyA9IF9jYWxjdWxhdGVWaWV3UG9ydFBvc2l0aW9uQm91bmRzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWNhbGN1bGF0ZSBib3VuZHMgb2YgdmlldyBwb3J0LlxyXG4gICAgKi9cclxuICAgIGZ1bmN0aW9uIF9jYWxjdWxhdGVCb3VuZHMgKCkge1xyXG4gICAgICAgIGNvbnN0IGJvdW5kcyA9IHtcclxuICAgICAgICAgICAgbWluWDogSW5maW5pdHksXHJcbiAgICAgICAgICAgIG1heFg6IC1JbmZpbml0eSxcclxuICAgICAgICAgICAgbWluWTogSW5maW5pdHksXHJcbiAgICAgICAgICAgIG1heFk6IC1JbmZpbml0eSxcclxuICAgICAgICAgICAgd2lkdGg6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgaGVpZ2h0OiB1bmRlZmluZWQsXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgY29uc3Qgbm9kZXMgPSBfZ2V0Tm9kZXMoKTtcclxuICAgICAgICBpZiAobm9kZXMubGVuZ3RoICE9PSAwKSB7XHJcblxyXG4gICAgICAgICAgICBub2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcG9zID0gZ2V0R2xvYmFsTm9kZVBvc2l0aW9uKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IHNjYWxlZFRvR2xvYmFsU2l6ZShub2RlLmNhbGN1bGF0ZVNpemUoX3JlZmVyZW5jZVNpemUpLCBfc2NhbGUpO1xyXG5cclxuICAgICAgICAgICAgICAgIGJvdW5kcy5taW5YID0gTWF0aC5taW4oYm91bmRzLm1pblgsIHBvcy54KTtcclxuICAgICAgICAgICAgICAgIGlmIChib3VuZHMubWluWCA9PT0gcG9zLngpIGJvdW5kcy5taW5YTm9kZSA9IG5vZGU7XHJcblxyXG4gICAgICAgICAgICAgICAgYm91bmRzLm1heFggPSAgTWF0aC5tYXgoYm91bmRzLm1heFgsIHBvcy54ICsgc2l6ZS53aWR0aCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYm91bmRzLm1heFggPT09IHBvcy54ICsgc2l6ZS53aWR0aCkgYm91bmRzLm1heFhOb2RlID0gbm9kZTtcclxuXHJcbiAgICAgICAgICAgICAgICBib3VuZHMubWluWSA9IE1hdGgubWluKGJvdW5kcy5taW5ZLCBwb3MueSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYm91bmRzLm1pblkgPT09IHBvcy55KSBib3VuZHMubWluWU5vZGUgPSBub2RlO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBib3VuZHMubWF4WSA9IE1hdGgubWF4KGJvdW5kcy5tYXhZLCBwb3MueSArIHNpemUuaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIGlmIChib3VuZHMubWF4WSA9PT0gcG9zLnkgKyBzaXplLmhlaWdodCkgYm91bmRzLm1heFlOb2RlID0gbm9kZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgICAgIGJvdW5kcy53aWR0aCA9IGJvdW5kcy5tYXhYIC0gYm91bmRzLm1pblg7XHJcbiAgICAgICAgICAgIGJvdW5kcy5oZWlnaHQgPSBib3VuZHMubWF4WSAtIGJvdW5kcy5taW5ZO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGJvdW5kcy5taW5YID0gMDtcclxuICAgICAgICAgICAgYm91bmRzLm1pblkgPSAwO1xyXG4gICAgICAgICAgICBib3VuZHMubWF4WCA9IDA7XHJcbiAgICAgICAgICAgIGJvdW5kcy5tYXhZID0gMDtcclxuICAgICAgICAgICAgYm91bmRzLndpZHRoID0gMDtcclxuICAgICAgICAgICAgYm91bmRzLmhlaWdodCA9IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gYm91bmRzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBib3VuZHMgb2YgdmlldyBwb3J0LlxyXG4gICAgICogQHJldHVybnMge1xyXG4gICAgICogIG1heFg6IG51bWJlclxyXG4gICAgICogIG1pblg6IG51bWJlclxyXG4gICAgICogIG1heFk6IG51bWJlclxyXG4gICAgICogIG1pblk6IG51bWJlclxyXG4gICAgICogfVxyXG4gICAgKi9cclxuICAgIGZ1bmN0aW9uIF9jYWxjdWxhdGVWaWV3UG9ydFBvc2l0aW9uQm91bmRzICgpIHtcclxuICAgICAgICBpZiAoIV9ub2RlQm91bmRzKSByZXR1cm4gbnVsbDtcclxuICAgICAgICAvLyBfYm91bmRzIC0gZ2xvYmFsIGNvb3JkXHJcbiAgICAgICAgY29uc3Qgdmlld0ZyYW1lR2xvYmFsU2l6ZSA9IHNjYWxlZFRvR2xvYmFsU2l6ZShzZWxmLnNpemUsIF9zY2FsZSk7XHJcbiAgICAgICAgY29uc3QgYm91bmRzV2l0aFBhZGRpbmcgPSBleHRlbmRCb3VuZHMoX25vZGVCb3VuZHMsIF9mcmFtZVBhZGRpbmcpO1xyXG5cclxuICAgICAgICBjb25zdCB2aWV3UG9ydEJvdW5kcyA9IHtcclxuICAgICAgICAgICAgbWluWDogYm91bmRzV2l0aFBhZGRpbmcubWluWCxcclxuICAgICAgICAgICAgbWF4WDogYm91bmRzV2l0aFBhZGRpbmcubWF4WCAtIHZpZXdGcmFtZUdsb2JhbFNpemUud2lkdGgsXHJcbiAgICAgICAgICAgIG1pblk6IGJvdW5kc1dpdGhQYWRkaW5nLm1pblksXHJcbiAgICAgICAgICAgIG1heFk6IGJvdW5kc1dpdGhQYWRkaW5nLm1heFkgLSB2aWV3RnJhbWVHbG9iYWxTaXplLmhlaWdodCxcclxuICAgICAgICAgICAgd2lkdGg6IGJvdW5kc1dpdGhQYWRkaW5nLm1heFggLSB2aWV3RnJhbWVHbG9iYWxTaXplLndpZHRoIC0gYm91bmRzV2l0aFBhZGRpbmcubWluWCxcclxuICAgICAgICAgICAgaGVpZ2h0OiBib3VuZHNXaXRoUGFkZGluZy5tYXhZIC0gdmlld0ZyYW1lR2xvYmFsU2l6ZS5oZWlnaHQgLSBib3VuZHNXaXRoUGFkZGluZy5taW5ZLFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGlmICh2aWV3UG9ydEJvdW5kcy53aWR0aCA8IDApIHtcclxuICAgICAgICAgICAgY29uc3QgZGlmZlggPSAodmlld0ZyYW1lR2xvYmFsU2l6ZS53aWR0aCAtIGJvdW5kc1dpdGhQYWRkaW5nLndpZHRoKSAvIDI7XHJcbiAgICAgICAgICAgIHZpZXdQb3J0Qm91bmRzLm1pblggPSBib3VuZHNXaXRoUGFkZGluZy5taW5YIC0gZGlmZlg7XHJcbiAgICAgICAgICAgIHZpZXdQb3J0Qm91bmRzLm1heFggPSB2aWV3UG9ydEJvdW5kcy5taW5YO1xyXG4gICAgICAgICAgICB2aWV3UG9ydEJvdW5kcy53aWR0aCA9IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodmlld1BvcnRCb3VuZHMuaGVpZ2h0IDwgMCkge1xyXG4gICAgICAgICAgICBjb25zdCBkaWZmWSA9ICh2aWV3RnJhbWVHbG9iYWxTaXplLmhlaWdodCAtIGJvdW5kc1dpdGhQYWRkaW5nLmhlaWdodCkgLyAyO1xyXG4gICAgICAgICAgICB2aWV3UG9ydEJvdW5kcy5taW5ZID0gYm91bmRzV2l0aFBhZGRpbmcubWluWSAtIGRpZmZZO1xyXG4gICAgICAgICAgICB2aWV3UG9ydEJvdW5kcy5tYXhZID0gdmlld1BvcnRCb3VuZHMubWluWTtcclxuICAgICAgICAgICAgdmlld1BvcnRCb3VuZHMuaGVpZ2h0ID0gMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB2aWV3UG9ydEJvdW5kcztcclxuICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGJvdW5kcyBvZiB2aWV3IHBvcnQuXHJcbiAgICAgKiBAcmV0dXJucyB7XHJcbiAgICAgKiAgbWF4WDogbnVtYmVyXHJcbiAgICAgKiAgbWluWDogbnVtYmVyXHJcbiAgICAgKiAgbWF4WTogbnVtYmVyXHJcbiAgICAgKiAgbWluWTogbnVtYmVyXHJcbiAgICAgKiB9XHJcbiAgICAqL1xyXG4gICAgZnVuY3Rpb24gX2dldFZpZXdQb3J0Qm91bmRzICgpIHtcclxuICAgICAgICBjb25zdCBnbG9iYWxWaWV3UG9ydFNpemUgPSBzY2FsZWRUb0dsb2JhbFNpemUoc2VsZi5zaXplLCBfc2NhbGUpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIG1pblg6IF92aWV3UG9ydFBvc2l0aW9uLngsXHJcbiAgICAgICAgICAgIG1heFg6IF92aWV3UG9ydFBvc2l0aW9uLnggKyBnbG9iYWxWaWV3UG9ydFNpemUud2lkdGgsXHJcbiAgICAgICAgICAgIG1pblk6IF92aWV3UG9ydFBvc2l0aW9uLnksXHJcbiAgICAgICAgICAgIG1heFk6IF92aWV3UG9ydFBvc2l0aW9uLnkgKyBnbG9iYWxWaWV3UG9ydFNpemUuaGVpZ2h0LFxyXG4gICAgICAgICAgICB3aWR0aDogX3ZpZXdQb3J0UG9zaXRpb24ueCArIGdsb2JhbFZpZXdQb3J0U2l6ZS53aWR0aCAtIF92aWV3UG9ydFBvc2l0aW9uLngsXHJcbiAgICAgICAgICAgIGhlaWdodDogX3ZpZXdQb3J0UG9zaXRpb24ueSArIGdsb2JhbFZpZXdQb3J0U2l6ZS5oZWlnaHQgLSBfdmlld1BvcnRQb3NpdGlvbi55LFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMaW1pdHMgcG9zaXRpb24gb2YgdGhlIHZpZXcgcG9ydC5cclxuICAgICAqIEByZXR1cm5zIHtQb2ludH1cclxuICAgICovXHJcbiAgICBmdW5jdGlvbiBfbGltaXRWaWV3UG9ydFBvc2l0aW9uICgpIHtcclxuICAgICAgICBfdmlld1BvcnRQb3NpdGlvbiA9IGxpbWl0UG9pbnRQb3NpdGlvbihfdmlld1BvcnRQb3NpdGlvbiwgX3ZpZXdQb3J0UG9zaXRpb25Cb3VuZHMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVsbHMgdXMgd2hldGhlciBhIE5vZGUgZmFsbCBpbnRvIHRoZSB2aWV3cG9ydCBvciBuby5cclxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBwYXJ0aWFsSGl0XHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICovXHJcbiAgICBmdW5jdGlvbiBfaGl0VGVzdEJ5R2xvYmFsUG9zaXRpb24gKG5vZGUsIHBhcnRpYWxIaXQpIHtcclxuICAgICAgICBjb25zdCBub2RlUG9zaXRpb24gPSBnZXRHbG9iYWxOb2RlUG9zaXRpb24obm9kZSk7XHJcblxyXG4gICAgICAgIGNvbnN0IG5vZGVTY2FsZWRTaXplID0gbm9kZS5jYWxjdWxhdGVTaXplKF9yZWZlcmVuY2VTaXplKTtcclxuICAgICAgICBjb25zdCBub2RlU2l6ZSA9IHNjYWxlZFRvR2xvYmFsU2l6ZShub2RlU2NhbGVkU2l6ZSwgX3NjYWxlKTtcclxuXHJcbiAgICAgICAgY29uc3QgcDEgPSBub2RlUG9zaXRpb247XHJcbiAgICAgICAgY29uc3QgcDIgPSB7IHg6IG5vZGVQb3NpdGlvbi54ICsgbm9kZVNpemUud2lkdGgsIHk6IG5vZGVQb3NpdGlvbi55IH07XHJcbiAgICAgICAgY29uc3QgcDMgPSB7IHg6IG5vZGVQb3NpdGlvbi54LCB5OiBub2RlUG9zaXRpb24ueSArIG5vZGVTaXplLmhlaWdodCB9O1xyXG4gICAgICAgIGNvbnN0IHA0ID0geyB4OiBub2RlUG9zaXRpb24ueCArIG5vZGVTaXplLndpZHRoLCB5OiBub2RlUG9zaXRpb24ueSArIG5vZGVTaXplLmhlaWdodCB9O1xyXG5cclxuICAgICAgICBjb25zdCBoaXRQMSA9IF9oaXRHbG9iYWxQb2ludFRlc3QocDEpO1xyXG4gICAgICAgIGNvbnN0IGhpdFAyID0gX2hpdEdsb2JhbFBvaW50VGVzdChwMik7XHJcbiAgICAgICAgY29uc3QgaGl0UDMgPSBfaGl0R2xvYmFsUG9pbnRUZXN0KHAzKTtcclxuICAgICAgICBjb25zdCBoaXRQNCA9IF9oaXRHbG9iYWxQb2ludFRlc3QocDQpO1xyXG5cclxuICAgICAgICBjb25zdCBmdWxsSGl0ID0gaGl0UDEgJiYgaGl0UDIgJiYgaGl0UDMgJiYgaGl0UDQ7XHJcbiAgICAgICAgY29uc3QgYm9yZGVySGl0ID0gaGl0UDEgfHwgaGl0UDIgfHwgaGl0UDMgfHwgaGl0UDQ7XHJcblxyXG4gICAgICAgIGlmIChwYXJhbWV0ZXJzLmNsaXBOb2Rlcykge1xyXG4gICAgICAgICAgICByZXR1cm4gYm9yZGVySGl0O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAocGFydGlhbEhpdCAmJiBib3JkZXJIaXQpIHx8ICghcGFydGlhbEhpdCAmJiBmdWxsSGl0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX2hpdEFyZWFUZXN0QnlHbG9iYWxQb3NpdGlvbiAobm9kZSwgdmlld0ZyYW1lKSB7XHJcbiAgICAgICAgY29uc3Qgc2NhbGVkUG9zaXRpb24gPSBub2RlLnBvc2l0aW9uKCk7XHJcbiAgICAgICAgY29uc3Qgbm9kZVBvc2l0aW9uID0gbG9jYWxUb0dsb2JhbFBvaW50KHNjYWxlZFBvc2l0aW9uLCBfc2NhbGUsIHZpZXdGcmFtZSB8fCBzZWxmKTtcclxuXHJcbiAgICAgICAgY29uc3Qgbm9kZVNjYWxlZFNpemUgPSBub2RlLmNhbGN1bGF0ZVNpemUoX3JlZmVyZW5jZVNpemUpO1xyXG4gICAgICAgIGNvbnN0IG5vZGVTaXplID0gc2NhbGVkVG9HbG9iYWxTaXplKG5vZGVTY2FsZWRTaXplLCBfc2NhbGUpO1xyXG5cclxuICAgICAgICBjb25zdCBwMSA9IG5vZGVQb3NpdGlvbjtcclxuICAgICAgICBjb25zdCBwMiA9IHsgeDogbm9kZVBvc2l0aW9uLnggKyBub2RlU2l6ZS53aWR0aCwgeTogbm9kZVBvc2l0aW9uLnkgfTtcclxuICAgICAgICBjb25zdCBwMyA9IHsgeDogbm9kZVBvc2l0aW9uLngsIHk6IG5vZGVQb3NpdGlvbi55ICsgbm9kZVNpemUuaGVpZ2h0IH07XHJcbiAgICAgICAgY29uc3QgcDQgPSB7IHg6IG5vZGVQb3NpdGlvbi54ICsgbm9kZVNpemUud2lkdGgsIHk6IG5vZGVQb3NpdGlvbi55ICsgbm9kZVNpemUuaGVpZ2h0IH07XHJcblxyXG4gICAgICAgIGNvbnN0IGhpdFAxID0gX2hpdEFyZWFHbG9iYWxQb2ludFRlc3QocDEpO1xyXG4gICAgICAgIGNvbnN0IGhpdFAyID0gX2hpdEFyZWFHbG9iYWxQb2ludFRlc3QocDIpO1xyXG4gICAgICAgIGNvbnN0IGhpdFAzID0gX2hpdEFyZWFHbG9iYWxQb2ludFRlc3QocDMpO1xyXG4gICAgICAgIGNvbnN0IGhpdFA0ID0gX2hpdEFyZWFHbG9iYWxQb2ludFRlc3QocDQpO1xyXG5cclxuICAgICAgICBjb25zdCBib3JkZXJIaXQgPSBoaXRQMSB8fCBoaXRQMiB8fCBoaXRQMyB8fCBoaXRQNDtcclxuXHJcbiAgICAgICAgcmV0dXJuIGJvcmRlckhpdDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfaGl0VGVzdEJ5U2NhbGVkUG9zaXRpb24gKG5vZGUpIHtcclxuICAgICAgICBjb25zdCBzY2FsZWRQb3NpdGlvbiA9IG5vZGUucG9zaXRpb24oKTtcclxuICAgICAgICBcclxuICAgICAgICBjb25zdCBwMSA9IHNjYWxlZFBvc2l0aW9uO1xyXG4gICAgICAgIGNvbnN0IHAyID0geyB4OiBzY2FsZWRQb3NpdGlvbi54ICtub2RlLnNpemUud2lkdGgsIHk6IHNjYWxlZFBvc2l0aW9uLnkgfTtcclxuICAgICAgICBjb25zdCBwMyA9IHsgeDogc2NhbGVkUG9zaXRpb24ueCwgeTogc2NhbGVkUG9zaXRpb24ueSArIG5vZGUuc2l6ZS5oZWlnaHQgfTtcclxuICAgICAgICBjb25zdCBwNCA9IHsgeDogc2NhbGVkUG9zaXRpb24ueCArIG5vZGUuc2l6ZS53aWR0aCwgeTogc2NhbGVkUG9zaXRpb24ueSArIG5vZGUuc2l6ZS5oZWlnaHQgfTtcclxuXHJcbiAgICAgICAgY29uc3QgaGl0UDEgPSBfaGl0U2NhbGVkUG9pbnRUZXN0KHAxKTtcclxuICAgICAgICBjb25zdCBoaXRQMiA9IF9oaXRTY2FsZWRQb2ludFRlc3QocDIpO1xyXG4gICAgICAgIGNvbnN0IGhpdFAzID0gX2hpdFNjYWxlZFBvaW50VGVzdChwMyk7XHJcbiAgICAgICAgY29uc3QgaGl0UDQgPSBfaGl0U2NhbGVkUG9pbnRUZXN0KHA0KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIChoaXRQMSB8fCBoaXRQMiB8fCBoaXRQMyB8fCBoaXRQNCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX2hpdEdsb2JhbFBvaW50VGVzdCAocCkge1xyXG4gICAgICAgIHJldHVybiBfdmlld1BvcnRCb3VuZHMubWluWCA8PSBwLnggJiYgcC54IDw9IF92aWV3UG9ydEJvdW5kcy5tYXhYICAmJlxyXG4gICAgICAgICAgICAgICBfdmlld1BvcnRCb3VuZHMubWluWSA8PSBwLnkgJiYgcC55IDw9IF92aWV3UG9ydEJvdW5kcy5tYXhZO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIF9oaXRBcmVhR2xvYmFsUG9pbnRUZXN0IChwKSB7XHJcbiAgICAgICAgcmV0dXJuIF9ub2RlQm91bmRzLm1pblggPD0gcC54ICYmIHAueCA8PSBfbm9kZUJvdW5kcy5tYXhYICAmJlxyXG4gICAgICAgICAgICAgICBfbm9kZUJvdW5kcy5taW5ZIDw9IHAueSAmJiBwLnkgPD0gX25vZGVCb3VuZHMubWF4WTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfaGl0U2NhbGVkUG9pbnRUZXN0IChwKSB7XHJcbiAgICAgICAgcmV0dXJuIHNlbGYuY29uc3RQb3NpdGlvbi54IDw9IHAueCAmJlxyXG4gICAgICAgICAgICBzZWxmLmNvbnN0UG9zaXRpb24ueCArIHNlbGYuc2l6ZS53aWR0aCA+PSBwLnggJiZcclxuICAgICAgICAgICAgc2VsZi5jb25zdFBvc2l0aW9uLnkgPD0gcC55ICYmXHJcbiAgICAgICAgICAgIHNlbGYuY29uc3RQb3NpdGlvbi55ICsgc2VsZi5zaXplLmhlaWdodCA+PSBwLnk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX293bmVyVGVzdCAobm9kZSkge1xyXG4gICAgICAgIGlmIChzZWxmLl9vd25lclRlc3QpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuX293bmVyVGVzdChub2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgY3VzdG9tZU93bmVyID0gbm9kZS52aWV3RnJhbWVPd25lcklkO1xyXG4gICAgICAgIGNvbnN0IG93bmVySXNNZSA9IG5vZGUudmlld0ZyYW1lT3duZXJJZCA9PT0gc2VsZi5pZDtcclxuICAgICAgICBjb25zdCBtZUlzTmF0aXZlT3duZXIgPSBzZWxmLmlkID09PSBub2RlLm1vZGVsLnZpZXdGcmFtZTtcclxuICAgICAgICByZXR1cm4gKGN1c3RvbWVPd25lciAmJiBvd25lcklzTWUpIHx8IChtZUlzTmF0aXZlT3duZXIgJiYgIWN1c3RvbWVPd25lcik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGUgdGhlIGNsaXAgcG9pbnQsIHdoaWNoXHJcbiAgICAgKiB0ZWxscyB1cyBob3cgZmFyIHRoZSBub2RlIGdvIG91dCBvZiB0aGUgYm9yZGVyIG9mIHZpZXdGcmFtZS5cclxuICAgICAqIEFuZCBhZnRlciBjYWxjdWxhdGlvbiB0aGUgZnVuY3Rpb24gcGFzcyB0aGlzIHBvaW50IGludG8gdGhlIG5vZGUuXHJcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcclxuICAgICovXHJcbiAgICBmdW5jdGlvbiBfY2xpcE5vZGUgKG5vZGUpIHtcclxuICAgICAgICBjb25zdCBub2RlUG9zaXRpb24gPSBnZXRHbG9iYWxOb2RlUG9zaXRpb24obm9kZSk7XHJcbiAgICAgICAgY29uc3Qgbm9kZVNjYWxlZFNpemUgPSBub2RlLmNhbGN1bGF0ZVNpemUoX3JlZmVyZW5jZVNpemUpO1xyXG4gICAgICAgIGNvbnN0IG5vZGVTaXplID0gc2NhbGVkVG9HbG9iYWxTaXplKG5vZGVTY2FsZWRTaXplLCBfc2NhbGUpO1xyXG5cclxuICAgICAgICBjb25zdCBwMSA9IG5vZGVQb3NpdGlvbjtcclxuICAgICAgICBjb25zdCBwMiA9IHsgeDogbm9kZVBvc2l0aW9uLnggKyBub2RlU2l6ZS53aWR0aCwgeTogbm9kZVBvc2l0aW9uLnkgfTtcclxuICAgICAgICBjb25zdCBwMyA9IHsgeDogbm9kZVBvc2l0aW9uLngsIHk6IG5vZGVQb3NpdGlvbi55ICsgbm9kZVNpemUuaGVpZ2h0IH07XHJcbiAgICAgICAgY29uc3QgcDQgPSB7IHg6IG5vZGVQb3NpdGlvbi54ICsgbm9kZVNpemUud2lkdGgsIHk6IG5vZGVQb3NpdGlvbi55ICsgbm9kZVNpemUuaGVpZ2h0IH07XHJcblxyXG4gICAgICAgIGNvbnN0IGdsb2JhbE9mZnNldCA9IHsgeDogMCwgeTogMCB9O1xyXG5cclxuICAgICAgICBsZXQgbyA9IGdldFBvaW50T2Zmc2V0KHAxKTtcclxuICAgICAgICBnbG9iYWxPZmZzZXQueCA9IE1hdGguYWJzKG8ueCkgPiBNYXRoLmFicyhnbG9iYWxPZmZzZXQueCkgPyBvLnggOiBnbG9iYWxPZmZzZXQueDtcclxuICAgICAgICBnbG9iYWxPZmZzZXQueSA9IE1hdGguYWJzKG8ueSkgPiBNYXRoLmFicyhnbG9iYWxPZmZzZXQueSkgPyBvLnkgOiBnbG9iYWxPZmZzZXQueTtcclxuXHJcbiAgICAgICAgbyA9IGdldFBvaW50T2Zmc2V0KHAyKTtcclxuICAgICAgICBnbG9iYWxPZmZzZXQueCA9IE1hdGguYWJzKG8ueCkgPiBNYXRoLmFicyhnbG9iYWxPZmZzZXQueCkgPyBvLnggOiBnbG9iYWxPZmZzZXQueDtcclxuICAgICAgICBnbG9iYWxPZmZzZXQueSA9IE1hdGguYWJzKG8ueSkgPiBNYXRoLmFicyhnbG9iYWxPZmZzZXQueSkgPyBvLnkgOiBnbG9iYWxPZmZzZXQueTtcclxuXHJcbiAgICAgICAgbyA9IGdldFBvaW50T2Zmc2V0KHAzKTtcclxuICAgICAgICBnbG9iYWxPZmZzZXQueCA9IE1hdGguYWJzKG8ueCkgPiBNYXRoLmFicyhnbG9iYWxPZmZzZXQueCkgPyBvLnggOiBnbG9iYWxPZmZzZXQueDtcclxuICAgICAgICBnbG9iYWxPZmZzZXQueSA9IE1hdGguYWJzKG8ueSkgPiBNYXRoLmFicyhnbG9iYWxPZmZzZXQueSkgPyBvLnkgOiBnbG9iYWxPZmZzZXQueTtcclxuXHJcbiAgICAgICAgbyA9IGdldFBvaW50T2Zmc2V0KHA0KTtcclxuICAgICAgICBnbG9iYWxPZmZzZXQueCA9IE1hdGguYWJzKG8ueCkgPiBNYXRoLmFicyhnbG9iYWxPZmZzZXQueCkgPyBvLnggOiBnbG9iYWxPZmZzZXQueDtcclxuICAgICAgICBnbG9iYWxPZmZzZXQueSA9IE1hdGguYWJzKG8ueSkgPiBNYXRoLmFicyhnbG9iYWxPZmZzZXQueSkgPyBvLnkgOiBnbG9iYWxPZmZzZXQueTtcclxuXHJcbiAgICAgICAgY29uc3Qgc2NhbGVkT2Zmc2V0ID0gZ2xvYmFsVG9TY2FsZWRQb2ludChnbG9iYWxPZmZzZXQsIF9zY2FsZSk7XHJcbiAgICAgICAgbm9kZS5zZXRDbGlwcGluZyhzY2FsZWRPZmZzZXQpO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBnZXRQb2ludE9mZnNldCAocCkge1xyXG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB7IHg6IDAsIHk6IDAgfTtcclxuICAgICAgICAgICAgaWYgKF92aWV3UG9ydEJvdW5kcy5taW5YID4gcC54KSB7XHJcbiAgICAgICAgICAgICAgICBvZmZzZXQueCA9IF92aWV3UG9ydEJvdW5kcy5taW5YIC0gcC54O1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKF92aWV3UG9ydEJvdW5kcy5tYXhYIDwgcC54KSB7XHJcbiAgICAgICAgICAgICAgICBvZmZzZXQueCA9IF92aWV3UG9ydEJvdW5kcy5tYXhYIC0gcC54O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChfdmlld1BvcnRCb3VuZHMubWluWSA+IHAueSkge1xyXG4gICAgICAgICAgICAgICAgb2Zmc2V0LnkgPSBfdmlld1BvcnRCb3VuZHMubWluWSAtIHAueTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChfdmlld1BvcnRCb3VuZHMubWF4WSA8IHAueSkge1xyXG4gICAgICAgICAgICAgICAgb2Zmc2V0LnkgPSBfdmlld1BvcnRCb3VuZHMubWF4WSAtIHAueTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gb2Zmc2V0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgY3VycmVudCBzaXplIGZvciBub2RlIHdpdGggY29uc2lkZXJpbmcgc2NhbGUuXHJcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcclxuICAgICAqIEByZXR1cm5zIHtTaXplfVxyXG4gICAgKi9cclxuICAgIGZ1bmN0aW9uIF9jYWxjdWxhdGVSZWZlcmVuY2VOb2RlU2l6ZSAoZWxlbWVudFNpemUpIHtcclxuICAgICAgICBjb25zdCBtaW5TY2FsZSA9IE1hdGgubWluKF9zY2FsZS54LCBfc2NhbGUueSk7XHJcbiAgICAgICAgY29uc3Qgc2NhbGVkRWxlbWVudFNpemUgPSBnbG9iYWxUb1NjYWxlZFNpemUoZWxlbWVudFNpemUsIHtcclxuICAgICAgICAgICAgeDogbWluU2NhbGUsIHk6IG1pblNjYWxlLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIGNvbnN0IHNjYWxlZEVsZW1lbnRTaXplID0gZ2xvYmFsVG9TY2FsZWRTaXplKGVsZW1lbnRTaXplLCBfc2NhbGUpO1xyXG5cclxuICAgICAgICBjb25zdCBtYXhCb3VuZGVkV2lkdGggPSBzZWxmLnNpemUud2lkdGggLSBwYXJhbWV0ZXJzLmZyYW1lUGFkZGluZy54O1xyXG4gICAgICAgIGNvbnN0IG1heFdpZHRoID0gKG1heEJvdW5kZWRXaWR0aCA+PSBlbGVtZW50U2l6ZS5taW5XaWR0aCAvIDMgPyBtYXhCb3VuZGVkV2lkdGggOiBzZWxmLnNpemUud2lkdGgpO1xyXG5cclxuICAgICAgICBjb25zdCBtYXhCb3VuZGVkSGVpZ2h0ID0gc2VsZi5zaXplLmhlaWdodCAtIHBhcmFtZXRlcnMuZnJhbWVQYWRkaW5nLnk7XHJcbiAgICAgICAgY29uc3QgbWF4SGVpZ2h0ID0gKG1heEJvdW5kZWRIZWlnaHQgPj0gZWxlbWVudFNpemUubWluSGVpZ2h0ID8gbWF4Qm91bmRlZEhlaWdodCA6IHNlbGYuc2l6ZS5oZWlnaHQpO1xyXG5cclxuICAgICAgICBjb25zdCByZWZlcmVuY2VTaXplID0ge1xyXG4gICAgICAgICAgICB3aWR0aDogTWF0aC5taW4oXHJcbiAgICAgICAgICAgICAgICBNYXRoLm1heChcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50U2l6ZS5taW5XaWR0aCxcclxuICAgICAgICAgICAgICAgICAgICBNYXRoLm1pbihzY2FsZWRFbGVtZW50U2l6ZS53aWR0aCwgZWxlbWVudFNpemUubWF4V2lkdGgpLFxyXG4gICAgICAgICAgICAgICAgKSxcclxuICAgICAgICAgICAgICAgIG1heFdpZHRoLFxyXG4gICAgICAgICAgICApLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IE1hdGgubWluKFxyXG4gICAgICAgICAgICAgICAgTWF0aC5tYXgoXHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudFNpemUubWluSGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgIE1hdGgubWluKHNjYWxlZEVsZW1lbnRTaXplLmhlaWdodCwgZWxlbWVudFNpemUubWF4SGVpZ2h0KSxcclxuICAgICAgICAgICAgICAgICksXHJcbiAgICAgICAgICAgICAgICBtYXhIZWlnaHQsXHJcbiAgICAgICAgICAgICksXHJcbiAgICAgICAgICAgIG1heFdpZHRoOiBtYXhXaWR0aCxcclxuICAgICAgICAgICAgbWF4SGVpZ2h0OiBtYXhIZWlnaHQsXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHJlZmVyZW5jZVNpemU7XHJcbiAgICB9XHJcbn1cclxuVmlld0ZyYW1lLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoam9pbnQuc2hhcGVzLmJhc2ljLlJlY3QucHJvdG90eXBlKTtcclxuZXhwb3J0IGRlZmF1bHQgVmlld0ZyYW1lO1xyXG5cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBjbGFzc1xyXG4gKiBJdCdzIHNwZWNpYWwgdmlld0ZyYW1lIHRvIHNob3cgYWxsIE5vZGVzIHNlbGVjdGVkIG5vZGVzLlxyXG4gKiBBbGwgbm9kZXMgYXJlIHBhc3NlZCB3aXRoIG9wdGlvbnMgZm9yIHBhcmVudCBjbGFzcy5cclxuICogQGF1Z21lbnRzIFZpZXdGcmFtZS5cclxuICogQW5kIHRoaXMgY2xhc3MgaGFzIHRoZSBzYW1lIG1ldGhvZHMsIGZpZWxkcyBhbmQgcGFyYW1ldGVycyBhcyBWaWV3RnJhbWUuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gT3ZlclZpZXdGcmFtZSAob3B0aW9ucywgcGFyYW1ldGVycykge1xyXG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XHJcbiAgICBsZXQgX3JhdGlvTW9kaWZ5ZXIgPSAxO1xyXG5cclxuICAgIHNlbGYuX293bmVyVGVzdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcblxyXG4gICAgc2VsZi5fc2NhbGVXaWxsQXBwbGllZCA9IGZ1bmN0aW9uIChzY2FsZSkge1xyXG4gICAgICAgIGlmIChfcmF0aW9Nb2RpZnllciA+IDEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHg6IHNjYWxlLngsXHJcbiAgICAgICAgICAgICAgICB5OiBzY2FsZS54ICogX3JhdGlvTW9kaWZ5ZXIsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHg6IHNjYWxlLnkgLyBfcmF0aW9Nb2RpZnllcixcclxuICAgICAgICAgICAgICAgIHk6IHNjYWxlLnksXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBWaWV3RnJhbWUuYXBwbHkoc2VsZiwgW29wdGlvbnMsIHBhcmFtZXRlcnNdKTtcclxuICAgIF9pbml0KCk7XHJcblxyXG4gICAgZnVuY3Rpb24gX2luaXQgKCkge1xyXG4gICAgICAgIGNvbnN0IHBhcGVyU2l6ZSA9IGdldEVsZW1lbnRTaXplKHBhcmFtZXRlcnMuZ3JhcGhQbGFjZSk7XHJcbiAgICAgICAgY29uc3Qgbm9kZUJvdW5kcyA9IHNlbGYuZ2V0Tm9kZUJvdW5kcygpO1xyXG5cclxuICAgICAgICBjb25zdCB3aWR0aElzU2NhbGFibGUgPSBub2RlQm91bmRzLndpZHRoICYmIG5vZGVCb3VuZHMubWluWE5vZGUgIT09IG5vZGVCb3VuZHMubWF4WE5vZGU7XHJcbiAgICAgICAgY29uc3QgaGVpZ2h0SXNTY2FsYWJsZSA9IG5vZGVCb3VuZHMuaGVpZ2h0ICYmIG5vZGVCb3VuZHMubWluWU5vZGUgIT09IG5vZGVCb3VuZHMubWF4WU5vZGU7XHJcbiAgICAgICAgaWYgKHdpZHRoSXNTY2FsYWJsZSAmJiBoZWlnaHRJc1NjYWxhYmxlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHhSYXRpbyA9IHBhcGVyU2l6ZS53aWR0aCAvIChub2RlQm91bmRzLndpZHRoKTtcclxuICAgICAgICAgICAgY29uc3QgeVJhdGlvID0gcGFwZXJTaXplLmhlaWdodCAvIChub2RlQm91bmRzLmhlaWdodCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoeFJhdGlvICE9PSB5UmF0aW8pIHtcclxuICAgICAgICAgICAgICAgIF9yYXRpb01vZGlmeWVyID0geVJhdGlvIC8geFJhdGlvO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbk92ZXJWaWV3RnJhbWUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShWaWV3RnJhbWUucHJvdG90eXBlKTsiLCJpbXBvcnQgKiBhcyBfIGZyb20gJ2xvZGFzaCc7XHJcblxyXG5pbXBvcnQgeyBWaWV3RnJhbWUsIE92ZXJWaWV3RnJhbWUgfSBmcm9tICcuL3ZpZXdGcmFtZSc7XHJcbmltcG9ydCB7IE5vZGUsIFRlcm1pbmF0aW9uTm9kZSwgVGVybWluYXRpb25MaW5rLCBBc3BlY3RMaW5rLCBMaW5rIH0gZnJvbSAnLi9ncmFwaEVsZW1lbnRzL2VsZW1lbnRzJztcclxuaW1wb3J0IFN1YnNjcmliYWJsZSBmcm9tICcuLi9zdWJzY3JpcHRpb25BUEkvc3Vic2NyaWJlYWJsZSc7XHJcbmltcG9ydCB7XHJcbiAgICBnZXRDcm9zUG9pbnQsIGdldFZpZXdGcmFtZUlkRm9yTm9kZSxcclxufSBmcm9tICcuLi91dGlscy9saW5lYWdlRGlhZ3JhbVV0aWxzJztcclxuaW1wb3J0IHsgYXJyYXlUb01hcCwgbGltaXRQb2ludFBvc2l0aW9uLCBnZXRTY2FsZWROb2RlUG9zaXRpb24sIGdldExvY2FsTm9kZVBvc2l0aW9uLCBzY2FsZWRUb0dsb2JhbFNpemUgfSBmcm9tICcuLi91dGlscy91dGlscyc7XHJcbmltcG9ydCB7IGdldEJhc2VFbGVtZW50IH0gZnJvbSAnLi4vdXRpbHMvZGF0YVV0aWxzJztcclxuXHJcbmV4cG9ydCBjb25zdCBESVNUQU5DRV9CRVRXRUVOX0ZSQU1FUyA9IDIwO1xyXG5leHBvcnQgY29uc3QgRlJBTUVfT1VUX01BUkdJTiA9IDIwO1xyXG5cclxuLyoqXHJcbiAqIFZpZXdNYW5hZ2VyIG9wdGlvbnMuXHJcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFZpZXdNYW5nZXJPcHRpb25zXHJcbiAqIEBwcm9wZXJ0eSB7RGF0YUNvbnRhaW5lcn0gZGF0YUNvbnRhaW5lclxyXG4gKiBAcHJvcGVydHkge1ZpZXdGcmFtZVB1YmxpY01vZGVsW119IHZpZXdGcmFtZXNcclxuKi9cclxuXHJcbi8qKlxyXG4gKiBNYW5hZ2UgVmlld0ZyYW1lcyBhbmQgY29sbGVjdCBkYXRhXHJcbiAqIGZyb20gdGhlbSB0byByZXR1cm4gdG8gdGhlIGxpbmVhZ2VEaWFncmFtIHJlbmRlclxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0ge1ZpZXdNYW5nZXJPcHRpb25zfSBvcHRpb25zIFxyXG4gKiBAcGFyYW0ge1BhcmFtZXRlcnN9IHBhcmFtZXRlcnMgXHJcbiAqIEBmaXJlcyBjaGFuZ2Utdmlldy1wb3J0LXBvc2l0aW9uXHJcbiAqIFB1YmxpYyBtZXRob2RzOlxyXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAqIHByZXBhcmVSZW5kZXJEYXRhOiAocmVuZGVyT3B0aW9ucykgPT4gKE5vZGV8TGlua3xWaWV3RnJhbWUpW11cclxuICogZ2V0Vmlld0ZyYW1lRm9yTm9kZTogKCkgPT4gVmlld0ZyYW1lUHVibGljTW9kZWw7XHJcbiAqIGdldFZpZUZyYW1lRm9yTm9kZUJ5UG9zaXRpb246IChub2RlKSA9PiBWaWV3RnJhbWVQdWJsaWNNb2RlbDtcclxuICogZ2V0Vmlld0ZyYW1lQnlJZDogKCkgPT4gVmlld0ZyYW1lUHVibGljTW9kZWw7XHJcbiAqIGdldE92ZXJWaWV3RnJhbWU6ICgpID0+IFZpZXdGcmFtZVB1YmxpY01vZGVsO1xyXG4gKiBmdWxsU2NyZWVuTW9kZTogKCkgPT4gYm9vbGVhbjtcclxuICogZ2V0Vmlld0ZyYW1lczogKCkgPT4gVmlld0ZyYW1lUHVibGljTW9kZWxbXTtcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBWaWV3TWFuYWdlciAob3B0aW9ucywgcGFyYW1ldGVycykge1xyXG4gICAgU3Vic2NyaWJhYmxlLmFwcGx5KHRoaXMpOyAgIC8vIG1ha2UgdGhpcyBjbGFzcyBTdWJzY3JpYmFibGVcclxuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xyXG4gICAgXHJcbiAgICBjb25zdCBfdGVybWluYXRpb25Ob2RlU2l6ZSA9IHBhcmFtZXRlcnMudGVybWluYXRpb25Ob2RlU2l6ZTtcclxuXHJcbiAgICBsZXQgX3Rlcm1pbmF0aW9uQ2VsbENhY2hlID0ge307XHJcbiAgICBsZXQgX2FzcGVjdExpbmtzQ2FoZSA9IHt9O1xyXG4gICAgbGV0IF9yZW5kZXJPcHRpb25zID0ge307XHJcbiAgICBsZXQgX3ZpZXdGcmFtZXNNYXAgPSB7fTtcclxuICAgIGxldCBfc3RhdGUgPSB7fTtcclxuICAgIGxldCBfZGF0YUNvbnRhaW5lcjtcclxuICAgIGxldCBfb3ZlclZpZXdGcmFtZTtcclxuICAgIGxldCBfdmlld0ZyYW1lcztcclxuICAgIGxldCBfYWxsRnJhbWVzO1xyXG5cclxuICAgIGxldCBfZnVsbFNjcmVlbk1vZGU7ICAvLyBjaGFuZ2VhYmxlXHJcblxyXG4gICAgX2luaXQob3B0aW9ucywgcGFyYW1ldGVycyk7XHJcbiAgICBcclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFBhcGVyIHJlbmRlciBvcHRpb25zLlxyXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUGFwZXJSZW5kZXJPcHRpb25zXHJcbiAgICAgKiBAcHJvcGVydHkgb3JpZW50YXRpb246IF9vcmllbnRhdGlvbixcclxuICAgICAqIEBwcm9wZXJ0eSB3aWR0aDogX3BhcGVyLmVsLmNsaWVudFdpZHRoLFxyXG4gICAgICogQHByb3BlcnR5IGhlaWdodDogX3BhcGVyLmVsLmNsaWVudEhlaWdodCxcclxuICAgICAqIEBwcm9wZXJ0eSBzY2FsZTogX3NjYWxlLFxyXG4gICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEVsZW1lbnQgcmVuZGVyIG9wdGlvbnMuXHJcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBFbGVtZW50UmVuZGVyT3B0aW9uc1xyXG4gICAgICogQHByb3BlcnR5IHtFbGVtZW50U2l6ZX0gZWxlbWVudFNpemVcclxuICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW5kZXIgb3B0aW9ucy5cclxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFJlbmRlck9wdGlvbnNcclxuICAgICAqIEBwcm9wZXJ0eSB7Vmlld0ZyYW1lUHVibGljTW9kZWxbXX0gdmlld0ZyYW1lc1xyXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBmdWxsU2NyZWVuTW9kZVxyXG4gICAgICogQHByb3BlcnR5IHtPYmplY3QuPHN0cmluZywgKE5vZGV8TGluayk+fSBwYXRoXHJcbiAgICAgKiBAcHJvcGVydHkge09iamVjdC48c3RyaW5nLCAoTm9kZXxMaW5rKT59IG1hc2tcclxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gdXBkYXRlQm91bmRzXHJcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IHF1aWNrVXBkYXRlXHJcbiAgICAgKiBAcHJvcGVydHkge1BhcGVyUmVuZGVyT3B0aW9uc30gcGFwZXJPcHRpb25zXHJcbiAgICAgKiBAcHJvcGVydHkge0VsZW1lbnRSZW5kZXJPcHRpb25zfSBlbGVtZW50T3B0aW9uc1xyXG4gICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIDEuIFRha2VzIHJlbmRlciBkYXRhIGZyb20gdGhlIFZpZXdGcmFtZXMsXHJcbiAgICAgKiAyLiBVcGRhdGVzIFZpZXdGcmFtZXMgc3RhdGVcclxuICAgICAqIDMuIENoYW5nZXMgc2l6ZSBhbmQgc2NhbGUgb2Ygdmlld0ZyYW1lc1xyXG4gICAgICogNC4gVXBkYXRlcyBoaWdobGlnaHRpbmdcclxuICAgICAqIEBwYXJhbSB7UmVuZGVyT3B0aW9uc30gcmVuZGVyT3B0aW9uc1xyXG4gICAgICogQHJldHVybnMgeyhOb2RlfExpbmt8Vmlld0ZyYW1lKVtdfVxyXG4gICAgICovXHJcbiAgICBzZWxmLnByZXBhcmVSZW5kZXJEYXRhID0gZnVuY3Rpb24gKHJlbmRlck9wdGlvbnMpIHtcclxuICAgICAgICBfdXBkYXRlVmlld0ZyYW1lcyhyZW5kZXJPcHRpb25zKTtcclxuICAgICAgICBcclxuICAgICAgICBjb25zdCB2aXNpYmxlVmlld0ZyYW1lcyA9IF9nZXRWaXNpYmxlVmlld0ZyYW1lcygpO1xyXG4gICAgICAgIGNvbnN0IHZpZXdGcmFtZVJlc3VsdHMgPSB2aXNpYmxlVmlld0ZyYW1lcy5tYXAodmYgPT4gdmYuZ2V0VmlzaWJsZUNlbGxzKCkpO1xyXG4gICAgICAgIGNvbnN0IHJlbmRlclJlc3VsdHMgPSBfY2FsY3VsYXRlUmVuZGVyRGF0YSh2aWV3RnJhbWVSZXN1bHRzLCByZW5kZXJPcHRpb25zKTtcclxuICAgICAgICBfc2V0SGlnaGxpZ2h0aW5nKHJlbmRlclJlc3VsdHMsIHJlbmRlck9wdGlvbnMpO1xyXG5cclxuICAgICAgICByZXR1cm4gdmlzaWJsZVZpZXdGcmFtZXMuY29uY2F0KHJlbmRlclJlc3VsdHMpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgVmlld0ZyYW1lIGZvciB0aGUgbm9kZSB3aGljaCBjdXJyZW50bHkgcmVuZGVycyB0aGlzIG5vZGUuXHJcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcclxuICAgICAqIEByZXR1cm5zIHtWaWV3RnJhbWVQdWJsaWNNb2RlbH1cclxuICAgICovXHJcbiAgICBzZWxmLmdldFZpZXdGcmFtZUZvck5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgIHJldHVybiBfZ2V0Vmlld0ZyYW1lUHVibGljTW9kZWwoX2dldFZpZXdGcmFtZUZvck5vZGUobm9kZSkpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgVmlld0ZyYW1lIHdoaWNoIGN1cnJlbnRseSBvd25zIHRoaXMgbm9kZS5cclxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxyXG4gICAgICogQHJldHVybnMge1ZpZXdGcmFtZVB1YmxpY01vZGVsfVxyXG4gICAgKi9cclxuICAgIHNlbGYuZ2V0Vmlld0ZyYW1lT3duZXIgPSBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgIGNvbnN0IHZpZXdGcmFtZUlkID0gZ2V0Vmlld0ZyYW1lSWRGb3JOb2RlKG5vZGUpO1xyXG4gICAgICAgIHJldHVybiBfZ2V0Vmlld0ZyYW1lUHVibGljTW9kZWwoX3ZpZXdGcmFtZXNNYXBbdmlld0ZyYW1lSWRdKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIFZpZXdGcmFtZSBmb3IgdGhlIG5vZGUgYnkgaGlzIHBvc2l0aW9uLlxyXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlXHJcbiAgICAgKiBAcmV0dXJucyB7Vmlld0ZyYW1lUHVibGljTW9kZWwgfCB1bmRlZmluZWR9XHJcbiAgICAqL1xyXG4gICAgc2VsZi5nZXRWaWVGcmFtZUZvck5vZGVCeVBvc2l0aW9uID0gZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICBpZiAoX2Z1bGxTY3JlZW5Nb2RlKSByZXR1cm4gdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICBjb25zdCB2aXNpYmxlRnJhbWVzID0gX2dldFZpc2libGVWaWV3RnJhbWVzKCk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2aXNpYmxlRnJhbWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHZmID0gdmlzaWJsZUZyYW1lc1tpXTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmICh2Zi5oaXRUZXN0QnlTY2FsZWRQb3NpdGlvbihub2RlKSkgcmV0dXJuIF9nZXRWaWV3RnJhbWVQdWJsaWNNb2RlbCh2Zik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBWaWV3RnJhbWUgZm9yIHRoZSBub2RlIGJ5IGhpcyBwb3NpdGlvbi5cclxuICAgICAqIEBwYXJhbSB7UG9pbnR9IHBvaW50XHJcbiAgICAgKiBAcmV0dXJucyB7Vmlld0ZyYW1lUHVibGljTW9kZWx9XHJcbiAgICAqL1xyXG4gICAgc2VsZi5nZXRWaWVGcmFtZUJ5U2NyZWVuUG9pbnQgPSBmdW5jdGlvbiAocG9pbnQpIHtcclxuICAgICAgICBjb25zdCB2aXNpYmxlRnJhbWVzID0gX2dldFZpc2libGVWaWV3RnJhbWVzKCk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2aXNpYmxlRnJhbWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHZmID0gdmlzaWJsZUZyYW1lc1tpXTtcclxuICAgICAgICAgICAgaWYgKHZmLmhpdFNjYWxlZFBvaW50VGVzdChwb2ludCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfZ2V0Vmlld0ZyYW1lUHVibGljTW9kZWwodmYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVzdG9yZXMgZGVmYXVsdCBzaXplIG9mIFZpZXdGcmFtZXNcclxuICAgICAqL1xyXG4gICAgc2VsZi5yZXNldEZyYW1lTGF5b3V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF92aWV3RnJhbWVzLmZvckVhY2godmYgPT4ge1xyXG4gICAgICAgICAgICB2Zi5yZXNldFNpemUoKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIFZpZXdGcmFtZSBieSBpZFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkXHJcbiAgICAgKiBAcmV0dXJucyB7Vmlld0ZyYW1lUHVibGljTW9kZWwgfCB1bmRlZmluZWR9XHJcbiAgICAgKi9cclxuICAgIHNlbGYuZ2V0Vmlld0ZyYW1lQnlJZCA9IGZ1bmN0aW9uICh2aWV3RnJhbWVJZCkge1xyXG4gICAgICAgIHJldHVybiBfZ2V0Vmlld0ZyYW1lUHVibGljTW9kZWwoX3ZpZXdGcmFtZXNNYXBbdmlld0ZyYW1lSWRdKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIE92ZXJWaWV3RnJhbWVcclxuICAgICAqIEByZXR1cm5zIHtWaWV3RnJhbWVQdWJsaWNNb2RlbH1cclxuICAgICAqL1xyXG4gICAgc2VsZi5nZXRPdmVyVmlld0ZyYW1lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfZ2V0Vmlld0ZyYW1lUHVibGljTW9kZWwoX292ZXJWaWV3RnJhbWUpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlbGxzIHVzIHdoZXRoZXIgb3ZlclZpZXcgaXMgYWN0aXZlIG9yIG5vdFxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIHNlbGYuaXNGdWxsU2NyZWVuTW9kZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX2Z1bGxTY3JlZW5Nb2RlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYWxsIFZpZXdGcmFtZXNcclxuICAgICAqIEByZXR1cm5zIHtWaWV3RnJhbWVQdWJsaWNNb2RlbFtdfVxyXG4gICAgKi9cclxuICAgIHNlbGYuZ2V0Vmlld0ZyYW1lcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX2FsbEZyYW1lcy5tYXAodmYgPT4gX2dldFZpZXdGcmFtZVB1YmxpY01vZGVsKHZmKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVmlld0ZyYW1lIHB1YmxpYyBtb2RlbFxyXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gVmlld0ZyYW1lUHVibGljTW9kZWxcclxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBpZCAtIElkZW50aWZ5ZXJcclxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBsYWJlbCAtIExhYmVsIGluIHRoZSB0b3AtcmlnaHQgY29ybmVyXHJcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gYmFja2dyb3VuZENvbG9yIC0gQmFjZ3JvdW5kIGNvbG9yXHJcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gYm9yZGVyQ29sb3IgLSBCb3JkZXIgY29sb3JcclxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gYWN0aXZlIC0gSXMgb24gdGhlIHNjcmVlblxyXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBleHBhbmRlZCAtIElzIGV4cGFuZGVkXHJcbiAgICAgKiBAcHJvcGVydHkge1BvaW50fSBwb3NpdGlvbiAtIFJlYWwgcG9zaXRpb24gb24gdGhlIHBhcGVyXHJcbiAgICAgKiBAcHJvcGVydHkge1BvaW50fSB2aWV3UG9ydFBvc2l0aW9uIC0gUG9zaXRpb24gb2YgdGhlIHZpZXdQb3J0XHJcbiAgICAgKiBAcHJvcGVydHkge0JvdW5kc30gYm91bmRzIC0gUmVhbCB2aXN1YWwgYm91bmRzIG9mIGFjdGl2ZSB6b25lIG9mIHZpZXdGcmFtZSAoWm9uZSBhcm91bmQgbm9kZXMpXHJcbiAgICAgKiBAcHJvcGVydHkge1NpemV9IHNpemUgLSBSZWFsIHNpemUgb2Ygdmlld0ZyYW1lXHJcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGN1c3RvbWVTaXplZCAtIFRlbGxzIHVzIHdoZXRoZXIgc2l6ZSB3YXMgY2hhbmdlZCBieSB1c2VyIG9yIG5vdFxyXG4gICAgICogQHByb3BlcnR5IHtCb3VuZHN9IHZpZXdQb3J0UG9zaXRpb25Cb3VuZHMgLSBNaW4gbWF4IHZhbHVlcyBvZiB0aGUgcG9zaXRpb24gb2YgdGhlIHZpZXdQb3J0XHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gc3BhY2VTaGFyZSAtIHJlbGF0aXZlIHNpemUgb2YgdmlldyBmcmFtZSAoaG9yaXpvbnRhbC92ZXJ0aWNhbCBkZXBlbmRzIG9uIG9yaWVudGF0aW9uKVxyXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSB1cGRhdGVCb3VuZHMgLSBGbGFnIHRvIHBhc3MgaW50byB0aGUgcmVuZGVyIHBpcGxpbmVcclxuICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtWaWV3RnJhbWV9IHZpZXdGcmFtZVxyXG4gICAgICogQHJldHVybnMge1ZpZXdGcmFtZVB1YmxpY01vZGVsfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBfZ2V0Vmlld0ZyYW1lUHVibGljTW9kZWwgKHZpZXdGcmFtZSkge1xyXG4gICAgICAgIGlmICghdmlld0ZyYW1lKSByZXR1cm47XHJcbiAgICAgICAgY29uc3QgY3VzdG9tZVNpemVkID0gdmlld0ZyYW1lLm1vZGVsLndpZHRoIHx8IHZpZXdGcmFtZS5tb2RlbC5oZWlnaHQ7XHJcblxyXG4gICAgICAgIGNvbnN0IGlzQWN0aXZlID0gdmlld0ZyYW1lID09PSBfb3ZlclZpZXdGcmFtZSA/XHJcbiAgICAgICAgICAgIF9mdWxsU2NyZWVuTW9kZSA6IF9mdWxsU2NyZWVuTW9kZSA/XHJcbiAgICAgICAgICAgIGZhbHNlIDogX3N0YXRlW3ZpZXdGcmFtZS5tb2RlbC5pZF07XHJcblxyXG4gICAgICAgIGNvbnN0IGlzRXhwYW5kZWQgPSB2aWV3RnJhbWUgPT09IF9vdmVyVmlld0ZyYW1lID9cclxuICAgICAgICAgICAgX2Z1bGxTY3JlZW5Nb2RlIDogX3N0YXRlW3ZpZXdGcmFtZS5tb2RlbC5pZF07XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGlkOiB2aWV3RnJhbWUubW9kZWwuaWQsXHJcbiAgICAgICAgICAgIGxhYmVsOiB2aWV3RnJhbWUubW9kZWwubGFiZWwsXHJcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogdmlld0ZyYW1lLm1vZGVsLmJhY2tncm91bmRDb2xvcixcclxuICAgICAgICAgICAgYm9yZGVyQ29sb3I6IHZpZXdGcmFtZS5tb2RlbC5ib3JkZXJDb2xvcixcclxuICAgICAgICAgICAgYWN0aXZlOiBpc0FjdGl2ZSxcclxuICAgICAgICAgICAgZXhwYW5kZWQ6IGlzRXhwYW5kZWQsXHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiB2aWV3RnJhbWUucG9zaXRpb24oKSwgLy8gbG9jYWxcclxuICAgICAgICAgICAgdmlld1BvcnRQb3NpdGlvbjogdmlld0ZyYW1lLnBvc2l0aW9uVmlld1BvcnQoKSwgLy8gZ2xvYmFsXHJcbiAgICAgICAgICAgIHZpZXdQb3J0UG9zaXRpb25Cb3VuZHM6IHZpZXdGcmFtZS5nZXRWaWV3UG9ydFBvc2l0aW9uQm91bmRzKCksIC8vIGdsb2JhbFxyXG4gICAgICAgICAgICB2aWV3UG9ydEJvdW5kczogdmlld0ZyYW1lLmdldFZpZXdQb3J0Qm91bmRzKCksIC8vIGdsb2JhbFxyXG4gICAgICAgICAgICBub2RlQm91bmRzOiB2aWV3RnJhbWUuZ2V0Tm9kZUJvdW5kcygpLCAvLyBnbG9iYWxcclxuICAgICAgICAgICAgc2l6ZTogeyB3aWR0aDogdmlld0ZyYW1lLnNpemUud2lkdGgsIGhlaWdodDogdmlld0ZyYW1lLnNpemUuaGVpZ2h0IH0sIC8vIGxvY2FsXHJcbiAgICAgICAgICAgIGN1c3RvbWVTaXplZDogY3VzdG9tZVNpemVkLFxyXG4gICAgICAgICAgICBzcGFjZVNoYXJlOiB2aWV3RnJhbWUubW9kZWwuc3BhY2VTaGFyZSxcclxuICAgICAgICAgICAgdXBkYXRlQm91bmRzOiBmYWxzZSxcclxuICAgICAgICAgICAgaXNPdmVyVmlldzogdmlld0ZyYW1lID09PSBfb3ZlclZpZXdGcmFtZSxcclxuICAgICAgICAgICAgc2NhbGU6IHZpZXdGcmFtZS5nZXRTY2FsZSgpLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIGRhdGEgbW9kZWxcclxuICAgICAqIEBwYXJhbSB7RGF0YUNvbnRhaW5lcn0gZGF0YUNvbnRhaW5lciAtIGRhdGEgZm9yIHRoZSBncmFwaFxyXG4gICAgKi9cclxuICAgIGZ1bmN0aW9uIF9pbml0IChvcHRpb25zLCBwYXJhbWV0ZXJzKSB7XHJcbiAgICAgICAgX2RhdGFDb250YWluZXIgPSBvcHRpb25zLmRhdGFDb250YWluZXI7XHJcbiAgICAgICAgY29uc3QgbWFwID0ge307XHJcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB7fTtcclxuXHJcbiAgICAgICAgLy8gQ3JlYXRlIE92ZXJWaWV3IGZyYW1lXHJcbiAgICAgICAgX292ZXJWaWV3RnJhbWUgPSBuZXcgT3ZlclZpZXdGcmFtZSh7XHJcbiAgICAgICAgICAgIGlkOiAnb3ZlclZpZXdGcmFtZScsXHJcbiAgICAgICAgICAgIGxhYmVsOiAnT3ZlcnZpZXcnLFxyXG4gICAgICAgICAgICBkYXRhQ29udGFpbmVyOiBfZGF0YUNvbnRhaW5lcixcclxuICAgICAgICAgICAgcmVzdXJyZWN0RWxlbWVudHM6IHRydWUsXHJcbiAgICAgICAgICAgIGJvcmRlckNvbG9yOiAnIzIzYjBmNCcsXHJcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJyNmNGY0ZmYnLFxyXG4gICAgICAgICAgICBzcGFjZVNoYXJlOiAxLFxyXG4gICAgICAgIH0sIHBhcmFtZXRlcnMpO1xyXG4gICAgICAgIG1hcFtfb3ZlclZpZXdGcmFtZS5pZF0gPSBfb3ZlclZpZXdGcmFtZTtcclxuXHJcbiAgICAgICAgLy8gQ3JlYXRlIGxpc3Qgb2YgVmlld0ZyYW1lc1xyXG4gICAgICAgIF92aWV3RnJhbWVzID0gb3B0aW9ucy52aWV3RnJhbWVzLm1hcChtb2RlbCA9PiB7XHJcbiAgICAgICAgICAgIHN0YXRlW21vZGVsLmlkXSA9IG1vZGVsLmV4cGFuZGVkO1xyXG4gICAgICAgICAgICBjb25zdCB2aWV3RnJhbWVPcHRpb25zID0gXy5jbG9uZURlZXAobW9kZWwpO1xyXG4gICAgICAgICAgICB2aWV3RnJhbWVPcHRpb25zLmRhdGFDb250YWluZXIgPSBvcHRpb25zLmRhdGFDb250YWluZXI7XHJcbiAgICAgICAgICAgIGNvbnN0IHZpZXdGcmFtZSA9IG5ldyBWaWV3RnJhbWUodmlld0ZyYW1lT3B0aW9ucywgcGFyYW1ldGVycyk7XHJcbiAgICAgICAgICAgIG1hcFt2aWV3RnJhbWUuaWRdID0gdmlld0ZyYW1lO1xyXG4gICAgICAgICAgICByZXR1cm4gdmlld0ZyYW1lO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIF9hbGxGcmFtZXMgPSBfdmlld0ZyYW1lcy5jb25jYXQoX292ZXJWaWV3RnJhbWUpO1xyXG5cclxuICAgICAgICBfc3RhdGUgPSBzdGF0ZTtcclxuICAgICAgICBfdmlld0ZyYW1lc01hcCA9IG1hcDtcclxuICAgICAgICBfZnVsbFNjcmVlbk1vZGUgPSBvcHRpb25zLmZ1bGxTY3JlZW5Nb2RlO1xyXG5cclxuICAgICAgICBfc3Vic2NyaWJlT25WaWV3RnJhbWVFdmVudHMoX2FsbEZyYW1lcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHN0YXRlcyBvZiB2aWV3RnJhbWVzIHVzaW5nIHJlbmRlck9wdGlvbnNcclxuICAgICAqIEBwYXJhbSB7UmVuZGVyT3B0aW9uc30gcmVuZGVyT3B0aW9uc1xyXG4gICAgKi9cclxuICAgIGZ1bmN0aW9uIF91cGRhdGVWaWV3RnJhbWVzIChyZW5kZXJPcHRpb25zKSB7XHJcbiAgICAgICAgY29uc3QgbmV3UGFwZXJPcHRpb25zID0gcmVuZGVyT3B0aW9ucy5wYXBlck9wdGlvbnM7XHJcbiAgICAgICAgY29uc3QgcHJldmlvdXNQYXBlck9wdGlvbnMgPSBfcmVuZGVyT3B0aW9ucy5wYXBlck9wdGlvbnMgfHwge307XHJcbiAgICAgICAgY29uc3Qgdmlld0ZyYW1lT3B0aW9ucyA9IGFycmF5VG9NYXAocmVuZGVyT3B0aW9ucy52aWV3RnJhbWVzIHx8IFtdKTtcclxuXHJcbiAgICAgICAgY29uc3QgaXNTY2FsZUNoYW5nZWQgPSAoIXByZXZpb3VzUGFwZXJPcHRpb25zLnNjYWxlKSB8fCBwcmV2aW91c1BhcGVyT3B0aW9ucy5zY2FsZS54ICE9PSBuZXdQYXBlck9wdGlvbnMuc2NhbGUueCB8fFxyXG4gICAgICAgICAgICBwcmV2aW91c1BhcGVyT3B0aW9ucy5zY2FsZS55ICE9PSBuZXdQYXBlck9wdGlvbnMuc2NhbGUueTtcclxuICAgICAgICBjb25zdCBpc1BhcGVyU2l6ZUNoYW5nZWQgPSBwcmV2aW91c1BhcGVyT3B0aW9ucy53aWR0aCAhPT0gbmV3UGFwZXJPcHRpb25zLndpZHRoIHx8XHJcbiAgICAgICAgICAgIHByZXZpb3VzUGFwZXJPcHRpb25zLmhlaWdodCAhPT0gbmV3UGFwZXJPcHRpb25zLmhlaWdodDtcclxuICAgICAgICBjb25zdCBpc09yaWVudGF0aW9uQ2hhbmdlZCA9IHByZXZpb3VzUGFwZXJPcHRpb25zLm9yaWVudGF0aW9uICE9PSBuZXdQYXBlck9wdGlvbnMub3JpZW50YXRpb247XHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uc3Qgb2xkRWxlbWVudFNpemUgPSAoX3JlbmRlck9wdGlvbnMuZWxlbWVudE9wdGlvbnMgfHwge30pLmVsZW1lbnRTaXplO1xyXG4gICAgICAgIGNvbnN0IGVsZW1lbnRTaXplID0gcmVuZGVyT3B0aW9ucy5lbGVtZW50T3B0aW9ucy5lbGVtZW50U2l6ZTtcclxuICAgICAgICBjb25zdCBpc0VsZW1lbnRTaXplQ2hhbmdlZCA9IGVsZW1lbnRTaXplICYmIChcclxuICAgICAgICAgICAgKCFvbGRFbGVtZW50U2l6ZSkgfHxcclxuICAgICAgICAgICAgZWxlbWVudFNpemUud2lkdGggIT09IG9sZEVsZW1lbnRTaXplLndpZHRoIHx8XHJcbiAgICAgICAgICAgIGVsZW1lbnRTaXplLmhlaWdodCAhPT0gb2xkRWxlbWVudFNpemUuaGVpZ2h0IHx8XHJcbiAgICAgICAgICAgIGVsZW1lbnRTaXplLm1pbldpZHRoICE9PSBvbGRFbGVtZW50U2l6ZS5taW5XaWR0aCB8fFxyXG4gICAgICAgICAgICBlbGVtZW50U2l6ZS5taW5IZWlnaHQgIT09IG9sZEVsZW1lbnRTaXplLm1pbkhlaWdodCB8fFxyXG4gICAgICAgICAgICBlbGVtZW50U2l6ZS5tYXhXaWR0aCAhPT0gb2xkRWxlbWVudFNpemUubWF4V2lkdGggfHxcclxuICAgICAgICAgICAgZWxlbWVudFNpemUubWF4SGVpZ2h0ICE9PSBvbGRFbGVtZW50U2l6ZS5tYXhIZWlnaHRcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICBjb25zdCBmdWxsU2NyZWVuTW9kZUNoYW5nZWQgPSByZW5kZXJPcHRpb25zLmZ1bGxTY3JlZW5Nb2RlICE9PSB1bmRlZmluZWQgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJPcHRpb25zLmZ1bGxTY3JlZW5Nb2RlICE9PSBfZnVsbFNjcmVlbk1vZGU7XHJcbiAgICAgICAgY29uc3Qgdmlld0ZyYW1lc1N0YXRlQ2hhbmdlZCA9IF91cGRhdGVWaWV3RnJhbWVWaXNpYmlsaXR5KHZpZXdGcmFtZU9wdGlvbnMpICYmICghX2Z1bGxTY3JlZW5Nb2RlKSB8fCBmdWxsU2NyZWVuTW9kZUNoYW5nZWQ7XHJcblxyXG5cclxuICAgICAgICBpZiAoZnVsbFNjcmVlbk1vZGVDaGFuZ2VkKSB7XHJcbiAgICAgICAgICAgIF9mdWxsU2NyZWVuTW9kZSA9IHJlbmRlck9wdGlvbnMuZnVsbFNjcmVlbk1vZGU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBwYXBlck9wdGlvbnNDaGFuZ2VkID1cclxuICAgICAgICAgICAgcmVuZGVyT3B0aW9ucy51cGRhdGVCb3VuZHMgfHxcclxuICAgICAgICAgICAgaXNQYXBlclNpemVDaGFuZ2VkIHx8XHJcbiAgICAgICAgICAgIGlzT3JpZW50YXRpb25DaGFuZ2VkIHx8XHJcbiAgICAgICAgICAgIGlzU2NhbGVDaGFuZ2VkIHx8XHJcbiAgICAgICAgICAgIHZpZXdGcmFtZXNTdGF0ZUNoYW5nZWQ7XHJcbiAgICAgICAgY29uc3QgcmVzaXplVmlld0ZyYW1lcyA9IGlzUGFwZXJTaXplQ2hhbmdlZCB8fCBpc09yaWVudGF0aW9uQ2hhbmdlZCB8fCB2aWV3RnJhbWVzU3RhdGVDaGFuZ2VkO1xyXG5cclxuICAgICAgICBpZiAoaXNFbGVtZW50U2l6ZUNoYW5nZWQpIHtcclxuICAgICAgICAgICAgX3NldEVsZW1lbnRzU2l6ZShlbGVtZW50U2l6ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZXNpemVWaWV3RnJhbWVzKSB7XHJcbiAgICAgICAgICAgIF9yZXNpemVWaWV3RnJhbWVzKG5ld1BhcGVyT3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc1NjYWxlQ2hhbmdlZCkge1xyXG4gICAgICAgICAgICBfc2NhbGVWaWV3RnJhbWVzKG5ld1BhcGVyT3B0aW9ucy5zY2FsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwYXBlck9wdGlvbnNDaGFuZ2VkIHx8IGlzRWxlbWVudFNpemVDaGFuZ2VkIHx8IGlzU2NhbGVDaGFuZ2VkKSB7XHJcbiAgICAgICAgICAgIF9yZWZyZXNoVmlld0ZyYW1lc0JvdW5kcygpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgX2FsbEZyYW1lcy5mb3JFYWNoKHZpZXdGcmFtZSA9PiB7XHJcbiAgICAgICAgICAgIGxldCByZWNhbGN1bGF0ZVZpc2libGVFbGVtZW50cyA9IGZhbHNlO1xyXG4gICAgICAgICAgICBjb25zdCBuZXdWaWV3RnJhbWVEYXRhID0gdmlld0ZyYW1lT3B0aW9uc1t2aWV3RnJhbWUuaWRdO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKG5ld1ZpZXdGcmFtZURhdGEpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG9sZFZpZXdGcmFtZURhdGEgPSBfZ2V0Vmlld0ZyYW1lUHVibGljTW9kZWwodmlld0ZyYW1lKTtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCB1cGRhdGVCb3VuZHMgPSBuZXdWaWV3RnJhbWVEYXRhLnVwZGF0ZUJvdW5kcztcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBvcnRQb3NpdGlvbkNoYW5nZWQgPSBuZXdWaWV3RnJhbWVEYXRhLnZpZXdQb3J0UG9zaXRpb24gJiYgKFxyXG4gICAgICAgICAgICAgICAgICAgIG5ld1ZpZXdGcmFtZURhdGEudmlld1BvcnRQb3NpdGlvbi54ICE9PSBvbGRWaWV3RnJhbWVEYXRhLnZpZXdQb3J0UG9zaXRpb24ueCB8fFxyXG4gICAgICAgICAgICAgICAgICAgIG5ld1ZpZXdGcmFtZURhdGEudmlld1BvcnRQb3NpdGlvbi55ICE9PSBvbGRWaWV3RnJhbWVEYXRhLnZpZXdQb3J0UG9zaXRpb24ueVxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNpemVDaGFuZ2VkID0gbmV3Vmlld0ZyYW1lRGF0YS5zaXplICYmIChcclxuICAgICAgICAgICAgICAgICAgICBuZXdWaWV3RnJhbWVEYXRhLnNpemUud2lkdGggIT09IG9sZFZpZXdGcmFtZURhdGEuc2l6ZS53aWR0aCB8fFxyXG4gICAgICAgICAgICAgICAgICAgIG5ld1ZpZXdGcmFtZURhdGEuc2l6ZS5oZWlnaHQgIT09IG9sZFZpZXdGcmFtZURhdGEuc2l6ZS5oZWlnaHRcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwb3NpdGlvbkNoYW5nZWQgPSBuZXdWaWV3RnJhbWVEYXRhLnBvc2l0aW9uICYmIChcclxuICAgICAgICAgICAgICAgICAgICBuZXdWaWV3RnJhbWVEYXRhLnBvc2l0aW9uLnggIT09IG9sZFZpZXdGcmFtZURhdGEucG9zaXRpb24ueCB8fFxyXG4gICAgICAgICAgICAgICAgICAgIG5ld1ZpZXdGcmFtZURhdGEucG9zaXRpb24ueSAhPT0gb2xkVmlld0ZyYW1lRGF0YS5wb3NpdGlvbi55XHJcbiAgICAgICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChzaXplQ2hhbmdlZCAmJiAhcmVzaXplVmlld0ZyYW1lcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZpZXdGcmFtZS5zZXRTaXplKG5ld1ZpZXdGcmFtZURhdGEuc2l6ZSwgbmV3Vmlld0ZyYW1lRGF0YS5jdXN0b21lU2l6ZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlY2FsY3VsYXRlVmlzaWJsZUVsZW1lbnRzID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAocG9zaXRpb25DaGFuZ2VkICYmICFyZXNpemVWaWV3RnJhbWVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmlld0ZyYW1lLnNldFBvc2l0aW9uKG5ld1ZpZXdGcmFtZURhdGEucG9zaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICh1cGRhdGVCb3VuZHMgfHwgc2l6ZUNoYW5nZWQgJiYgIXJlc2l6ZVZpZXdGcmFtZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2aWV3RnJhbWUudXBkYXRlQm91bmRzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVjYWxjdWxhdGVWaXNpYmxlRWxlbWVudHMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChwb3J0UG9zaXRpb25DaGFuZ2VkICYmICFyZXNpemVWaWV3RnJhbWVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmlld0ZyYW1lLnBvc2l0aW9uVmlld1BvcnQoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1ZpZXdGcmFtZURhdGEudmlld1BvcnRQb3NpdGlvbi54LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdWaWV3RnJhbWVEYXRhLnZpZXdQb3J0UG9zaXRpb24ueSxcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlY2FsY3VsYXRlVmlzaWJsZUVsZW1lbnRzID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBpc0V4cGFuZGVkID0gX3N0YXRlW3ZpZXdGcmFtZS5pZF0gfHwgdmlld0ZyYW1lID09PSBfb3ZlclZpZXdGcmFtZSAmJiBfZnVsbFNjcmVlbk1vZGU7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlY2FsY3VsYXRlQ29udGVudCA9IGlzRXhwYW5kZWQgJiYgKFxyXG4gICAgICAgICAgICAgICAgcmVjYWxjdWxhdGVWaXNpYmxlRWxlbWVudHMgfHwgcGFwZXJPcHRpb25zQ2hhbmdlZCB8fCBpc0VsZW1lbnRTaXplQ2hhbmdlZFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBpZiAocmVjYWxjdWxhdGVDb250ZW50KSB7XHJcbiAgICAgICAgICAgICAgICB2aWV3RnJhbWUuY2FsY3VsYXRlVmlzaWJsZUNlbGxzKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgX3JlbmRlck9wdGlvbnMgPSByZW5kZXJPcHRpb25zO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyBzdGF0ZSBvZiB2aWV3RnJhbWVzICh2aXNpYmxlL2ludmlzaWJsZSlcclxuICAgICAqIEBwYXJhbSB7Vmlld0ZyYW1lUHVibGljTW9kZWxbXX0gdmlld0ZyYW1lT3B0aW9uc1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBfdXBkYXRlVmlld0ZyYW1lVmlzaWJpbGl0eSAodmlld0ZyYW1lT3B0aW9ucykge1xyXG4gICAgICAgIGxldCBhdExlYXN0T25lVmlzaWJpbGl0eUNoYW5nZWQgPSBmYWxzZTtcclxuICAgICAgICBfdmlld0ZyYW1lcy5mb3JFYWNoKHZpZXdGcmFtZSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld1ZpZXdGcmFtZURhdGEgPSB2aWV3RnJhbWVPcHRpb25zW3ZpZXdGcmFtZS5pZF07XHJcbiAgICAgICAgICAgIGlmIChuZXdWaWV3RnJhbWVEYXRhICYmIG5ld1ZpZXdGcmFtZURhdGEuZXhwYW5kZWQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdmlzaWJpbGl0aUNoYW5nZWQgPSBuZXdWaWV3RnJhbWVEYXRhLmV4cGFuZGVkICE9PSBfc3RhdGVbdmlld0ZyYW1lLmlkXTtcclxuICAgICAgICAgICAgICAgIF9zdGF0ZVt2aWV3RnJhbWUuaWRdID0gbmV3Vmlld0ZyYW1lRGF0YS5leHBhbmRlZDtcclxuICAgICAgICAgICAgICAgIGF0TGVhc3RPbmVWaXNpYmlsaXR5Q2hhbmdlZCA9IGF0TGVhc3RPbmVWaXNpYmlsaXR5Q2hhbmdlZCB8fCB2aXNpYmlsaXRpQ2hhbmdlZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBhdExlYXN0T25lVmlzaWJpbGl0eUNoYW5nZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGFuZ2VzIGRlZmF1bHQgZWxlbWVudCBzaXplIGZvciBhbGwgVmlld0ZyYW1lc1xyXG4gICAgICogQHBhcmFtIHtFbGVtZW50U2l6ZX0gZWxlbWVudFNpemUgXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIF9zZXRFbGVtZW50c1NpemUgKGVsZW1lbnRTaXplKSB7XHJcbiAgICAgICAgX2FsbEZyYW1lcy5mb3JFYWNoKHZmID0+IHtcclxuICAgICAgICAgICAgdmYuc2V0RWxlbWVudFNpemUoZWxlbWVudFNpemUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVjYWxjdWxhdGVzIGJvdW5kcyBmb3IgYWxsIFZpZXdGcmFtZXNcclxuICAgICAqIGFuZCBhbGxpZ24gVmlld0ZyYW1lc1xyXG4gICAgKi9cclxuICAgIGZ1bmN0aW9uIF9yZWZyZXNoVmlld0ZyYW1lc0JvdW5kcyAoKSB7XHJcbiAgICAgICAgX2FsbEZyYW1lcy5mb3JFYWNoKHZmID0+IHtcclxuICAgICAgICAgICAgdmYudXBkYXRlQm91bmRzKCk7XHJcbiAgICAgICAgICAgIHZmLnBvc2l0aW9uVmlld1BvcnQoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgYW5kIGxpbWl0cyB2YWx1ZSBvZiB0aGUgc2NhbGUgZm9yIHRoZSBncmFwaC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBfc2NhbGVWaWV3RnJhbWVzIChzY2FsZSkge1xyXG4gICAgICAgIGlmIChzY2FsZSkge1xyXG4gICAgICAgICAgICBfYWxsRnJhbWVzLmZvckVhY2godmYgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgb2xkU2NhbGUgPSB2Zi5nZXRTY2FsZSgpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcG9zID0gdmYucG9zaXRpb25WaWV3UG9ydCgpO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICB2Zi5zZXRTY2FsZShzY2FsZSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdTY2FsZSA9IHZmLmdldFNjYWxlKCk7IC8vIG92ZXJWaWV3RnJhbWUgY2hhbmdlcyBzY2FsZSBiZWZvcmUgYXBwbHlcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBzY2FsZWRTaXplID0gdmYuZ2V0KCdzaXplJyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvbGRTaXplID0gc2NhbGVkVG9HbG9iYWxTaXplKHNjYWxlZFNpemUsIG9sZFNjYWxlKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1NpemUgPSBzY2FsZWRUb0dsb2JhbFNpemUoc2NhbGVkU2l6ZSwgbmV3U2NhbGUpO1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IGN1ckNlbnRlciA9IHtcclxuICAgICAgICAgICAgICAgICAgICB4OiBwb3MueCArIG9sZFNpemUud2lkdGggLyAyLFxyXG4gICAgICAgICAgICAgICAgICAgIHk6IHBvcy55ICsgb2xkU2l6ZS5oZWlnaHQgLyAyLFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICB2Zi5wb3NpdGlvblZpZXdQb3J0KFxyXG4gICAgICAgICAgICAgICAgICAgIGN1ckNlbnRlci54IC0gbmV3U2l6ZS53aWR0aCAvIDIsXHJcbiAgICAgICAgICAgICAgICAgICAgY3VyQ2VudGVyLnkgLSBuZXdTaXplLmhlaWdodCAvIDIsXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWZyZXNoIFZpZXdGcmFtZXM6XHJcbiAgICAgKiBBZGp1c3Qgdmlld0ZyYW1lcyBzaXplIHRvIGEgcGFwZXJcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gdXBkYXRlU2NhbGVcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gX3Jlc2l6ZVZpZXdGcmFtZXMgKG9wdGlvbnMpIHtcclxuICAgICAgICBjb25zdCB2aXNpYmxlRnJhbWVzID0gX2dldFZpc2libGVWaWV3RnJhbWVzKCk7XHJcbiAgICAgICAgY29uc3QgdmZOdW1iZXIgPSB2aXNpYmxlRnJhbWVzLmxlbmd0aDtcclxuICAgICAgICBjb25zdCBpc0hvcml6b250YWxPcmllbnRhdGVkID1cclxuICAgICAgICAgICAgb3B0aW9ucy5vcmllbnRhdGlvbiA9PT0gJ2xlZnQtdG8tcmlnaHQnIHx8IG9wdGlvbnMub3JpZW50YXRpb24gPT09ICdyaWdodC10by1sZWZ0JztcclxuXHJcbiAgICAgICAgaWYgKG9wdGlvbnMud2lkdGggPT09IDAgfHwgb3B0aW9ucy5oZWlnaHQgPT09IDAgfHwgdmZOdW1iZXIgPD0gMCkgcmV0dXJuO1xyXG4gICAgICAgIGxldCB0b3RhbFNoYXJlID0gMDtcclxuICAgICAgICB2aXNpYmxlRnJhbWVzLmZvckVhY2ggKHZmID0+IHtcclxuICAgICAgICAgICAgdG90YWxTaGFyZSArPSB2Zi5tb2RlbC5zcGFjZVNoYXJlO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBjb25zdCB3aWR0aCA9IG9wdGlvbnMud2lkdGggLSBGUkFNRV9PVVRfTUFSR0lOICogMjtcclxuICAgICAgICBjb25zdCBoZWlnaHQgPSBvcHRpb25zLmhlaWdodCAtIEZSQU1FX09VVF9NQVJHSU4gKiAyO1xyXG5cclxuICAgICAgICBjb25zdCBjdXRlZFdpZHRoID0gd2lkdGggIC0gRElTVEFOQ0VfQkVUV0VFTl9GUkFNRVMgKiAodmZOdW1iZXIgLSAxKTtcclxuICAgICAgICBjb25zdCBjdXRlZEhlaWdodCA9IGhlaWdodCAgLSBESVNUQU5DRV9CRVRXRUVOX0ZSQU1FUyAqICh2Zk51bWJlciAtIDEpO1xyXG5cclxuICAgICAgICBjb25zdCBzZWdtZW50V2lkdGggID0gY3V0ZWRXaWR0aCAgLyB0b3RhbFNoYXJlO1xyXG4gICAgICAgIGNvbnN0IHNlZ21lbnRIZWlnaHQgPSBjdXRlZEhlaWdodCAvIHRvdGFsU2hhcmU7XHJcblxyXG4gICAgICAgIGxldCBzY2FsZSA9IDE7XHJcbiAgICAgICAgbGV0IGxlbmd0aCA9IDA7XHJcbiAgICAgICAgbGV0IGZyZWVMZW5ndGggPSAwO1xyXG4gICAgICAgIHZpc2libGVGcmFtZXMuZm9yRWFjaCAodmlld0ZyYW1lID0+IHtcclxuICAgICAgICAgICAgaWYgKGlzSG9yaXpvbnRhbE9yaWVudGF0ZWQpIHtcclxuICAgICAgICAgICAgICAgIGlmICh2aWV3RnJhbWUubW9kZWwud2lkdGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZW5ndGggKz0gdmlld0ZyYW1lLm1vZGVsLndpZHRoO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBmcmVlTGVuZ3RoICs9IHNlZ21lbnRXaWR0aCAqICh2aWV3RnJhbWUubW9kZWwuc3BhY2VTaGFyZSB8fCAxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmICh2aWV3RnJhbWUubW9kZWwuaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoICs9IHZpZXdGcmFtZS5tb2RlbC5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGZyZWVMZW5ndGggKz0gc2VnbWVudEhlaWdodCAqICh2aWV3RnJhbWUubW9kZWwuc3BhY2VTaGFyZSB8fCAxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChpc0hvcml6b250YWxPcmllbnRhdGVkKSB7XHJcbiAgICAgICAgICAgIHNjYWxlID0gKGN1dGVkV2lkdGggLSBmcmVlTGVuZ3RoKSAvIGxlbmd0aDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzY2FsZSA9IChjdXRlZEhlaWdodCAtIGZyZWVMZW5ndGgpIC8gbGVuZ3RoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGN1clBvaW50ID0geyB4OiBGUkFNRV9PVVRfTUFSR0lOLCB5OiBGUkFNRV9PVVRfTUFSR0lOIH07XHJcblxyXG4gICAgICAgIGlmIChvcHRpb25zLm9yaWVudGF0aW9uID09PSAndG9wLXRvLWJvdHRvbScpIHtcclxuXHJcbiAgICAgICAgICAgIHZpc2libGVGcmFtZXMuZm9yRWFjaCAodmYgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHZmLm1vZGVsLndpZHRoKSB2Zi5tb2RlbC53aWR0aCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIGlmICh2Zi5tb2RlbC5oZWlnaHQpIHZmLm1vZGVsLmhlaWdodCAqPSBzY2FsZTtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBNSU5JTUFMX1ZGX1NJWkUgPSB7IHdpZHRoOiAxLCBoZWlnaHQ6IDEgfTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNpemUgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IE1hdGgubWF4KHdpZHRoLCBNSU5JTUFMX1ZGX1NJWkUud2lkdGgpLFxyXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogTWF0aC5tYXgoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZmLm1vZGVsLmhlaWdodCA/IHZmLm1vZGVsLmhlaWdodCA6IHNlZ21lbnRIZWlnaHQgKiAodmYubW9kZWwuc3BhY2VTaGFyZSB8fCAxKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgTUlOSU1BTF9WRl9TSVpFLmhlaWdodCxcclxuICAgICAgICAgICAgICAgICAgICApLFxyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICB2Zi5zZXRQb3NpdGlvbihjdXJQb2ludCk7XHJcbiAgICAgICAgICAgICAgICB2Zi5zZXRTaXplKHNpemUpO1xyXG5cclxuICAgICAgICAgICAgICAgIGN1clBvaW50ID0geyB4OiBGUkFNRV9PVVRfTUFSR0lOLCB5OiBjdXJQb2ludC55ICsgc2l6ZS5oZWlnaHQgKyBESVNUQU5DRV9CRVRXRUVOX0ZSQU1FUyB9O1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLm9yaWVudGF0aW9uID09PSAnYm90dG9tLXRvLXRvcCcpIHtcclxuXHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB2aXNpYmxlRnJhbWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2ZiA9IHZpc2libGVGcmFtZXNbaV07XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHZmLm1vZGVsLndpZHRoKSB2Zi5tb2RlbC53aWR0aCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIGlmICh2Zi5tb2RlbC5oZWlnaHQpIHZmLm1vZGVsLmhlaWdodCAqPSBzY2FsZTtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBzaXplID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcclxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHZmLm1vZGVsLmhlaWdodCA/IHZmLm1vZGVsLmhlaWdodCA6IHNlZ21lbnRIZWlnaHQgKiAodmYubW9kZWwuc3BhY2VTaGFyZSB8fCAxKVxyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICB2Zi5zZXRQb3NpdGlvbihjdXJQb2ludCk7XHJcbiAgICAgICAgICAgICAgICB2Zi5zZXRTaXplKHNpemUpO1xyXG5cclxuICAgICAgICAgICAgICAgIGN1clBvaW50ID0geyB4OiBGUkFNRV9PVVRfTUFSR0lOLCB5OiBjdXJQb2ludC55ICsgc2l6ZS5oZWlnaHQgKyBESVNUQU5DRV9CRVRXRUVOX0ZSQU1FUyB9O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5vcmllbnRhdGlvbiA9PT0gJ3JpZ2h0LXRvLWxlZnQnKSB7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdmlzaWJsZUZyYW1lcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdmYgPSB2aXNpYmxlRnJhbWVzW2ldO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh2Zi5tb2RlbC53aWR0aCkgdmYubW9kZWwud2lkdGggKj0gc2NhbGU7XHJcbiAgICAgICAgICAgICAgICBpZiAodmYubW9kZWwuaGVpZ2h0KSB2Zi5tb2RlbC5oZWlnaHQgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IHtcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogdmYubW9kZWwud2lkdGggPyB2Zi5tb2RlbC53aWR0aCA6IHNlZ21lbnRXaWR0aCAqICh2Zi5tb2RlbC5zcGFjZVNoYXJlIHx8IDEpLFxyXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIHZmLnNldFBvc2l0aW9uKGN1clBvaW50KTtcclxuICAgICAgICAgICAgICAgIHZmLnNldFNpemUoc2l6ZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgY3VyUG9pbnQgPSB7IHg6IGN1clBvaW50LnggKyBzaXplLndpZHRoICsgRElTVEFOQ0VfQkVUV0VFTl9GUkFNRVMsIHk6IEZSQU1FX09VVF9NQVJHSU4gfTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9IGVsc2UgeyAvLyBob3Jpem9udGFsXHJcblxyXG4gICAgICAgICAgICB2aXNpYmxlRnJhbWVzLmZvckVhY2ggKHZmID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh2Zi5tb2RlbC53aWR0aCkgdmYubW9kZWwud2lkdGggKj0gc2NhbGU7XHJcbiAgICAgICAgICAgICAgICBpZiAodmYubW9kZWwuaGVpZ2h0KSB2Zi5tb2RlbC5oZWlnaHQgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IHtcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogdmYubW9kZWwud2lkdGggPyB2Zi5tb2RlbC53aWR0aCA6IHNlZ21lbnRXaWR0aCAqICh2Zi5tb2RlbC5zcGFjZVNoYXJlIHx8IDEpLFxyXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIHZmLnNldFBvc2l0aW9uKGN1clBvaW50KTtcclxuICAgICAgICAgICAgICAgIHZmLnNldFNpemUoc2l6ZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgY3VyUG9pbnQgPSB7IHg6IGN1clBvaW50LnggKyBzaXplLndpZHRoICsgRElTVEFOQ0VfQkVUV0VFTl9GUkFNRVMsIHk6IEZSQU1FX09VVF9NQVJHSU4gfTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB2aXNpYmxlRnJhbWVzLmZvckVhY2godmlld0ZyYW1lID0+IHtcclxuICAgICAgICAgICAgdmlld0ZyYW1lLnVwZGF0ZUJvdW5kcygpO1xyXG4gICAgICAgICAgICAvLyBXZSB3YW50IG5vdCB0byBiZSBpbiB0aGUgZW1wdHkgc3BhY2UgYWZ0ZXIgcmVzaXppbmcgYnV0IHNvbXdoZXJlIG5lYXIgdGhlIG5vZGVzLlxyXG4gICAgICAgICAgICBjb25zdCB2aWV3UG9ydFBvc2l0aW9uQm91bmRzID0gdmlld0ZyYW1lLmdldFZpZXdQb3J0UG9zaXRpb25Cb3VuZHMoKTtcclxuICAgICAgICAgICAgY29uc3QgdmlzaWJsZUNlbGxzID0gdmlld0ZyYW1lLmdldFZpc2libGVDZWxscygpO1xyXG4gICAgICAgICAgICBpZiAoIXZpc2libGVDZWxscyB8fCB2aXNpYmxlQ2VsbHMubm9kZXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgbm9kZXMgPSAgdmlld0ZyYW1lLmdldE5vZGVzKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVUb0ZvY3VzID0gbm9kZXNbTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogKG5vZGVzLmxlbmd0aCAtIDEpKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm9kZVNjYWxlZFBvcyA9IGdldFNjYWxlZE5vZGVQb3NpdGlvbihub2RlVG9Gb2N1cywgb3B0aW9ucy5zY2FsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3UG9zaXRpb24gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IG5vZGVTY2FsZWRQb3MueCAtICh2aWV3RnJhbWUuc2l6ZS53aWR0aCAtIG5vZGVUb0ZvY3VzLnNpemUud2lkdGgpIC8gMixcclxuICAgICAgICAgICAgICAgICAgICAgICAgeTogbm9kZVNjYWxlZFBvcy55IC0gKHZpZXdGcmFtZS5zaXplLmhlaWdodCAtIG5vZGVUb0ZvY3VzLnNpemUuaGVpZ2h0KSAvIDIsXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsaW1pdGVkUG9pbnQgPSBsaW1pdFBvaW50UG9zaXRpb24obmV3UG9zaXRpb24sIHZpZXdQb3J0UG9zaXRpb25Cb3VuZHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZpZXdGcmFtZS5wb3NpdGlvblZpZXdQb3J0KGxpbWl0ZWRQb2ludC54LCBsaW1pdGVkUG9pbnQueSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgbGltaXRlZFBvaW50ID0gbGltaXRQb2ludFBvc2l0aW9uKHZpZXdGcmFtZS5wb3NpdGlvblZpZXdQb3J0KCksIHZpZXdQb3J0UG9zaXRpb25Cb3VuZHMpO1xyXG4gICAgICAgICAgICB2aWV3RnJhbWUucG9zaXRpb25WaWV3UG9ydChsaW1pdGVkUG9pbnQueCwgbGltaXRlZFBvaW50LnkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IGRhdGEgKENlbGxzKSBmcm9tIFZpZXdGcmFtZXMsXHJcbiAgICAgKiBwcm9jZXNzZXMgaXQgKGFkZCB0ZXJtaW5hdGlvbiBhbmQgYXNwZWN0IGVsZW1lbnRzKVxyXG4gICAgICogYW5kIHJldHVybnMgdG8gdGhlIHJlbmRlciBwaXBsaW5lXHJcbiAgICAgKiBAcmV0dXJucyB7KExpbmt8Tm9kZXxUZXJtaW5hdGlvbk5vZGV8VGVybWluYXRpb25MaW5rfEFzcGVjdExpbmspW119XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIF9jYWxjdWxhdGVSZW5kZXJEYXRhICh2aWV3RnJhbWVSZXN1bHRzLCByZW5kZXJPcHRpb25zKSB7XHJcbiAgICAgICAgY29uc3Qgbm9kZXMgPSBbXTtcclxuICAgICAgICBjb25zdCBsaW5rcyA9IFtdO1xyXG4gICAgICAgIGNvbnN0IGJhZExpbmtzID0gW107XHJcbiAgICAgICAgY29uc3QgdmlzaWJsZU5vZGVNYXAgPSB7fTsgICAgICAgXHJcblxyXG4gICAgICAgIHZpZXdGcmFtZVJlc3VsdHMuZm9yRWFjaChyZXN1bHQgPT4gcmVzdWx0Lm5vZGVzLmZvckVhY2gobm9kZSA9PiB7XHJcbiAgICAgICAgICAgIHZpc2libGVOb2RlTWFwW25vZGUuaWRdID0gbm9kZTtcclxuICAgICAgICAgICAgbm9kZXMucHVzaChub2RlKTtcclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmlld0ZyYW1lUmVzdWx0cy5mb3JFYWNoKHJlc3VsdCA9PiByZXN1bHQubGlua3MuZm9yRWFjaChsaW5rID0+IHtcclxuICAgICAgICAgICAgaWYgKHZpc2libGVOb2RlTWFwW2xpbmsubW9kZWwuc291cmNlXSAmJiB2aXNpYmxlTm9kZU1hcFtsaW5rLm1vZGVsLnRhcmdldF0pIHtcclxuICAgICAgICAgICAgICAgIGlmICghcmVuZGVyT3B0aW9ucy5xdWlja1VwZGF0ZSkgbGlua3MucHVzaChsaW5rKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh2aXNpYmxlTm9kZU1hcFtsaW5rLm1vZGVsLnNvdXJjZV0gfHwgdmlzaWJsZU5vZGVNYXBbbGluay5tb2RlbC50YXJnZXRdKSB7XHJcbiAgICAgICAgICAgICAgICBiYWRMaW5rcy5wdXNoKGxpbmspO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSkpO1xyXG5cclxuICAgICAgICBjb25zdCB0ZXJtaW5hdGlvbkNlbGxNYXAgPSB7fTtcclxuICAgICAgICBjb25zdCB0ZXJtaW5hdGlvbk5vZGVzID0gW107XHJcbiAgICAgICAgY29uc3QgdGVybWluYXRpb25MaW5rcyA9IFtdO1xyXG4gICAgICAgIGlmIChyZW5kZXJPcHRpb25zLnNlbGVjdGVkRWxlbWVudCkge1xyXG4gICAgICAgICAgICBjb25zdCBzZWxlY3RlZE5vZGVzID0gX2dldFNlbGVjdGVkTm9kZXMocmVuZGVyT3B0aW9ucy5zZWxlY3RlZEVsZW1lbnQpO1xyXG4gICAgICAgICAgICBzZWxlY3RlZE5vZGVzLmZvckVhY2goc2VsZWN0ZWROb2RlID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRlcm1pbmF0aW9uT3JpZ2lucyA9IF9nZXRUZXJtaW5hdGlvbk9yaWdpbnMoc2VsZWN0ZWROb2RlLCB2aXNpYmxlTm9kZU1hcCwgYmFkTGlua3MpO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgdmlld0ZyYW1lID0gX2dldFZpZXdGcmFtZUZvck5vZGUoc2VsZWN0ZWROb2RlKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodmlld0ZyYW1lICYmIChfc3RhdGVbdmlld0ZyYW1lLmlkXSB8fCBfZnVsbFNjcmVlbk1vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVybWluYXRpb25PcmlnaW5zLm5vZGVzLmZvckVhY2gobm9kZSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVDYWNoZUlkID0gbm9kZS5pZCArICdfYXRfJyArIHZpZXdGcmFtZS5pZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRlcm1pbmF0aW9uTm9kZSA9IF90ZXJtaW5hdGlvbkNlbGxDYWNoZVtub2RlQ2FjaGVJZF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ZXJtaW5hdGlvbk5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlcm1pbmF0aW9uTm9kZS5zZXQoJ2RyYWdnZWQnLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXJtaW5hdGlvbk5vZGUgPSBuZXcgVGVybWluYXRpb25Ob2RlICh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZTogbm9kZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHBhcmFtZXRlcnMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlcm1pbmF0aW9uQ2VsbE1hcFtub2RlQ2FjaGVJZF0gPSB0ZXJtaW5hdGlvbk5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uID0gX2dldFRlcm1pbmF0aW9uTm9kZVBvc2l0aW9uKHRlcm1pbmF0aW9uTm9kZSwgdmlld0ZyYW1lLCByZW5kZXJPcHRpb25zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGVybWluYXRpb25Ob2RlLnBvc2l0aW9uKHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXJtaW5hdGlvbk5vZGVzLnB1c2godGVybWluYXRpb25Ob2RlKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlbmRlck9wdGlvbnMucXVpY2tVcGRhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGVybWluYXRpb25PcmlnaW5zLmxpbmtzLmZvckVhY2gobGluayA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsaW5rQ2FjaGVJZCA9IGxpbmsuaWQgKyAnX2F0XycgKyB2aWV3RnJhbWUuaWQ7ICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZUNhY2hlSWQgPSBsaW5rLm1vZGVsLnNvdXJjZSArICdfYXRfJyArIHZpZXdGcmFtZS5pZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldENhY2hlSWQgPSBsaW5rLm1vZGVsLnRhcmdldCArICdfYXRfJyArIHZpZXdGcmFtZS5pZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0ZXJtaW5hdGlvbkxpbmsgPSBfdGVybWluYXRpb25DZWxsQ2FjaGVbbGlua0NhY2hlSWRdIHx8IG5ldyBUZXJtaW5hdGlvbkxpbmsgKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rOiBsaW5rLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogdGVybWluYXRpb25DZWxsTWFwW3NvdXJjZUNhY2hlSWRdIHx8IHZpc2libGVOb2RlTWFwW2xpbmsubW9kZWwuc291cmNlXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IHRlcm1pbmF0aW9uQ2VsbE1hcFt0YXJnZXRDYWNoZUlkXSB8fCB2aXNpYmxlTm9kZU1hcFtsaW5rLm1vZGVsLnRhcmdldF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBwYXJhbWV0ZXJzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlcm1pbmF0aW9uQ2VsbE1hcFtsaW5rQ2FjaGVJZF0gPSB0ZXJtaW5hdGlvbkxpbms7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXJtaW5hdGlvbkxpbmtzLnB1c2godGVybWluYXRpb25MaW5rKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGxpbmsgPSByZW5kZXJPcHRpb25zLnNlbGVjdGVkRWxlbWVudDtcclxuICAgICAgICAgICAgY29uc3QgYWRkVGVybWluYXRpb25MaW5rcyA9IGxpbmsgaW5zdGFuY2VvZiBMaW5rICYmIChcclxuICAgICAgICAgICAgICAgICEodmlzaWJsZU5vZGVNYXBbbGluay5tb2RlbC5zb3VyY2VdIHx8IHZpc2libGVOb2RlTWFwW2xpbmsubW9kZWwudGFyZ2V0XSkgfHxcclxuICAgICAgICAgICAgICAgIHJlbmRlck9wdGlvbnMucXVpY2tVcGRhdGVcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgaWYgKGFkZFRlcm1pbmF0aW9uTGlua3MpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVNYXAgPSBfZGF0YUNvbnRhaW5lci5tYXBzLm5vZGVNYXA7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZVZpZXdGcmFtZSA9IF9nZXRWaWV3RnJhbWVGb3JOb2RlKG5vZGVNYXBbbGluay5tb2RlbC5zb3VyY2VdKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldFZpZXdGcmFtZSA9IF9nZXRWaWV3RnJhbWVGb3JOb2RlKG5vZGVNYXBbbGluay5tb2RlbC50YXJnZXRdKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlVmlld0ZyYW1lICYmIHRhcmdldFZpZXdGcmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZVZpZXdGcmFtZUlkID0gc291cmNlVmlld0ZyYW1lLmlkO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldFZpZXdGcmFtZUlkID0gdGFyZ2V0Vmlld0ZyYW1lLmlkO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzb3VyY2VDYWNoZUlkID0gbGluay5tb2RlbC5zb3VyY2UgKyAnX2F0XycgKyBzb3VyY2VWaWV3RnJhbWVJZDtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRDYWNoZUlkID0gbGluay5tb2RlbC50YXJnZXQgKyAnX2F0XycgKyB0YXJnZXRWaWV3RnJhbWVJZDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc291cmNlID0gdGVybWluYXRpb25DZWxsTWFwW3NvdXJjZUNhY2hlSWRdIHx8IHZpc2libGVOb2RlTWFwW2xpbmsubW9kZWwuc291cmNlXTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXQgPSB0ZXJtaW5hdGlvbkNlbGxNYXBbdGFyZ2V0Q2FjaGVJZF0gfHwgdmlzaWJsZU5vZGVNYXBbbGluay5tb2RlbC50YXJnZXRdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsaW5rQ2FjaGVJZCA9IHNvdXJjZS5pZCArICd+I34nICsgdGFyZ2V0LmlkOyAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRlcm1pbmF0aW9uTGluayA9IF90ZXJtaW5hdGlvbkNlbGxDYWNoZVtsaW5rQ2FjaGVJZF0gfHwgbmV3IFRlcm1pbmF0aW9uTGluayAoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rOiBsaW5rLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgfSwgcGFyYW1ldGVycyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVybWluYXRpb25DZWxsTWFwW2xpbmtDYWNoZUlkXSA9IHRlcm1pbmF0aW9uTGluaztcclxuICAgICAgICAgICAgICAgICAgICB0ZXJtaW5hdGlvbkxpbmtzLnB1c2godGVybWluYXRpb25MaW5rKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBfdGVybWluYXRpb25DZWxsQ2FjaGUgPSB0ZXJtaW5hdGlvbkNlbGxNYXA7XHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uc3QgdmlzaWJsZU5vZGVzID0gbm9kZXMuY29uY2F0KHRlcm1pbmF0aW9uTm9kZXMpO1xyXG4gICAgICAgIGNvbnN0IGFzcGVjdExpbmtzID0gcmVuZGVyT3B0aW9ucy5xdWlja1VwZGF0ZSA/IFtdIDogX2NhbGN1bGF0ZUFzcGVjdExpbmtzKHZpc2libGVOb2Rlcyk7XHJcbiAgICAgICAgY29uc3QgdmlzaWJsZUxpbmtzID0gbGlua3MuY29uY2F0KHRlcm1pbmF0aW9uTGlua3MpLmNvbmNhdChhc3BlY3RMaW5rcyk7XHJcblxyXG4gICAgICAgIHJldHVybiB2aXNpYmxlTm9kZXMuY29uY2F0KHZpc2libGVMaW5rcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJZiB0aGUgTGluayBpcyBzZWxlY3RlZCB0aGVuIHdlIHJlcHJlc2VudFxyXG4gICAgICogaXQgYXMgdHdvIHNlbGVjdGVkIG5vZGVzXHJcbiAgICAgKiBAcGFyYW0ge05vZGV8TGlua30gc2VsZWN0ZWRFbGVtZW50XHJcbiAgICAgKiBAcmV0dXJucyB7Tm9kZVtdfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBfZ2V0U2VsZWN0ZWROb2RlcyAoc2VsZWN0ZWRFbGVtZW50KSB7XHJcbiAgICAgICAgY29uc3Qgbm9kZU1hcCA9IF9kYXRhQ29udGFpbmVyLm1hcHMubm9kZU1hcDtcclxuICAgICAgICBjb25zdCBpc05vZGUgPSBzZWxlY3RlZEVsZW1lbnQgaW5zdGFuY2VvZiBOb2RlO1xyXG4gICAgICAgIHJldHVybiBpc05vZGUgPyBbc2VsZWN0ZWRFbGVtZW50XSA6IFtcclxuICAgICAgICAgICAgbm9kZU1hcFtzZWxlY3RlZEVsZW1lbnQubW9kZWwuc291cmNlXSxcclxuICAgICAgICAgICAgbm9kZU1hcFtzZWxlY3RlZEVsZW1lbnQubW9kZWwudGFyZ2V0XSxcclxuICAgICAgICBdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSWYgdGhlIExpbmsgaXMgc2VsZWN0ZWQgdGhlbiB3ZSByZXByZXNlbnRcclxuICAgICAqIGl0IGFzIHR3byBzZWxlY3RlZCBub2Rlc1xyXG4gICAgICogQHBhcmFtIHtOb2RlfSBzZWxlY3RlZE5vZGVcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsIE5vZGU+fSB2aXNpYmxlTm9kZU1hcCAtIFZpc2libGUgbm9kZXNcclxuICAgICAqIEBwYXJhbSB7TGlua1tdfSBiYWRMaW5rcyAtIExpbmtzIHdoaWNoIGhhdmUgZWl0aGVyIHNvdXJjZSBlaXRoZXIgdGFyZ2V0IGlzIG5vdCB2aXNpYmxlXHJcbiAgICAgKiBAcmV0dXJucyB7Tm9kZVtdLCBMaW5rW119XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIF9nZXRUZXJtaW5hdGlvbk9yaWdpbnMgKHNlbGVjdGVkTm9kZSwgdmlzaWJsZU5vZGVNYXAsIGJhZExpbmtzKSB7XHJcbiAgICAgICAgY29uc3QgdGVybWluYXRpb25PcmlnaW5Ob2RlcyA9IFtdO1xyXG4gICAgICAgIGNvbnN0IHRlcm1pbmF0aW9uT3JpZ2luTGlua3MgPSBbXTtcclxuICAgICAgICBjb25zdCBwcm9jZXNzZWRDZWxsSWRzID0ge307XHJcbiAgICAgICAgY29uc3Qgbm9kZU1hcCA9IF9kYXRhQ29udGFpbmVyLm1hcHMubm9kZU1hcDtcclxuXHJcbiAgICAgICAgY29uc3QgaXNTZWxlY3RlZE5vZGVWaXNpYmxlID0gdmlzaWJsZU5vZGVNYXBbc2VsZWN0ZWROb2RlLmlkXTtcclxuICAgICAgICBpZiAoaXNTZWxlY3RlZE5vZGVWaXNpYmxlKSB7XHJcbiAgICAgICAgICAgIGJhZExpbmtzLmZvckVhY2gobGluayA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXByb2Nlc3NlZENlbGxJZHNbbGluay5pZF0pIHtcclxuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzZWRDZWxsSWRzW2xpbmsuaWRdID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0xpbmtDb25uZWN0ZWRUb1NlbGVjdGVkTm9kZSA9IGxpbmsubW9kZWwuc291cmNlID09PSBzZWxlY3RlZE5vZGUuaWQgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmsubW9kZWwudGFyZ2V0ID09PSBzZWxlY3RlZE5vZGUuaWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGVybWluYXRpb25zSGF2ZVZpZXdGcmFtZXMgPSBsaW5rLm1vZGVsLnNvdXJjZSA9PT0gc2VsZWN0ZWROb2RlLmlkID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9nZXRWaWV3RnJhbWVGb3JOb2RlKG5vZGVNYXBbbGluay5tb2RlbC50YXJnZXRdKSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZ2V0Vmlld0ZyYW1lRm9yTm9kZShub2RlTWFwW2xpbmsubW9kZWwuc291cmNlXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTGlua0Nvbm5lY3RlZFRvU2VsZWN0ZWROb2RlICYmIHRlcm1pbmF0aW9uc0hhdmVWaWV3RnJhbWVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlcm1pbmF0aW9uT3JpZ2luTGlua3MucHVzaChsaW5rKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZUlzbnRWaXNpYmxlID0gIXZpc2libGVOb2RlTWFwW2xpbmsubW9kZWwuc291cmNlXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZUlzbnRWaXNpYmxlICYmICFwcm9jZXNzZWRDZWxsSWRzW2xpbmsubW9kZWwuc291cmNlXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc2VkQ2VsbElkc1tsaW5rLm1vZGVsLnNvdXJjZV0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVybWluYXRpb25PcmlnaW5Ob2Rlcy5wdXNoKG5vZGVNYXBbbGluay5tb2RlbC5zb3VyY2VdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0SXNudFZpc2libGUgPSAhdmlzaWJsZU5vZGVNYXBbbGluay5tb2RlbC50YXJnZXRdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0SXNudFZpc2libGUgJiYgIXByb2Nlc3NlZENlbGxJZHNbbGluay5tb2RlbC50YXJnZXRdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzZWRDZWxsSWRzW2xpbmsubW9kZWwudGFyZ2V0XSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXJtaW5hdGlvbk9yaWdpbk5vZGVzLnB1c2gobm9kZU1hcFtsaW5rLm1vZGVsLnRhcmdldF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0ZXJtaW5hdGlvbk9yaWdpbk5vZGVzLnB1c2goc2VsZWN0ZWROb2RlKTtcclxuICAgICAgICAgICAgYmFkTGlua3MuZm9yRWFjaChsaW5rID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICghcHJvY2Vzc2VkQ2VsbElkc1tsaW5rLmlkXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NlZENlbGxJZHNbbGluay5pZF0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzTGlua0Nvbm5lY3RlZFRvU2VsZWN0ZWROb2RlID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbGluay5tb2RlbC5zb3VyY2UgPT09IHNlbGVjdGVkTm9kZS5pZCB8fCBsaW5rLm1vZGVsLnRhcmdldCA9PT0gc2VsZWN0ZWROb2RlLmlkO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0xpbmtDb25uZWN0ZWRUb1NlbGVjdGVkTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXJtaW5hdGlvbk9yaWdpbkxpbmtzLnB1c2gobGluayk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIG5vZGVzOiB0ZXJtaW5hdGlvbk9yaWdpbk5vZGVzLFxyXG4gICAgICAgICAgICBsaW5rczogdGVybWluYXRpb25PcmlnaW5MaW5rcyxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBwb3NpdGlvbiBmb3IgdGhlIHRlcm1pbmF0aW9uIG5vZGUuXHJcbiAgICAgKiBAcGFyYW0ge1Rlcm1pbmF0aW9uTm9kZX0gdGVybWluYXRpb25Ob2RlXHJcbiAgICAgKiBAcGFyYW0ge1ZpZXdGcmFtZX0gdmlld0ZyYW1lXHJcbiAgICAgKiBAcGFyYW0ge1JlbmRlck9wdGlvbn0gcmVuZGVyT3B0aW9uc1xyXG4gICAgICogQHJldHVybnMge1BvaW50fVxyXG4gICAgKi9cclxuICAgIGZ1bmN0aW9uIF9nZXRUZXJtaW5hdGlvbk5vZGVQb3NpdGlvbiAodGVybWluYXRpb25Ob2RlLCB2aWV3RnJhbWUsIHJlbmRlck9wdGlvbnMpIHtcclxuICAgICAgICBjb25zdCBvcmlnaW5hbE5vZGUgPSB0ZXJtaW5hdGlvbk5vZGUub3JpZ2luYWxOb2RlO1xyXG4gICAgICAgIGNvbnN0IHZpZXdGcmFtZVNpemUgPSB2aWV3RnJhbWUuc2l6ZTsgLy8gbG9jYWwgc2l6ZVxyXG4gICAgICAgIGNvbnN0IHZpZXdGcmFtZVBvc2l0aW9uID0gdmlld0ZyYW1lLnBvc2l0aW9uKCk7IC8vIGxvY2FsIHBvc2l0aW9uXHJcbiAgICAgICAgY29uc3Qgbm9kZVNpemUgPSBvcmlnaW5hbE5vZGUuc2l6ZTsgLy8gbG9jYWwgc2l6ZVxyXG5cclxuICAgICAgICBjb25zdCB0b3BMZWZ0ID0gdmlld0ZyYW1lUG9zaXRpb247XHJcbiAgICAgICAgY29uc3QgdG9wUmlnaHQgPSB7IHg6IHZpZXdGcmFtZVBvc2l0aW9uLnggKyB2aWV3RnJhbWVTaXplLndpZHRoLCB5OiB2aWV3RnJhbWVQb3NpdGlvbi55IH07XHJcbiAgICAgICAgY29uc3QgYm90dG9tTGVmdCA9IHsgeDogdmlld0ZyYW1lUG9zaXRpb24ueCwgeTogdmlld0ZyYW1lUG9zaXRpb24ueSArIHZpZXdGcmFtZVNpemUuaGVpZ2h0IH07XHJcbiAgICAgICAgY29uc3QgYm90dG9tUmlnaHQgPSB7IHg6IHZpZXdGcmFtZVBvc2l0aW9uLnggKyB2aWV3RnJhbWVTaXplLndpZHRoLCB5OiB2aWV3RnJhbWVQb3NpdGlvbi55ICsgdmlld0ZyYW1lU2l6ZS5oZWlnaHQgfTtcclxuXHJcbiAgICAgICAgY29uc3QgY2FsY3VsYXRpb25Qb2ludHMgPSBnZXRDYWxjdWxhdGlvblBvaW50cygpO1xyXG4gICAgICAgIGNvbnN0IHNvdXJjZVBvaW50ID0gY2FsY3VsYXRpb25Qb2ludHMuc291cmNlUG9pbnQ7XHJcbiAgICAgICAgY29uc3QgdGVybWluYXRpb25Qb2ludCA9IGNhbGN1bGF0aW9uUG9pbnRzLnRlcm1pbmF0aW9uUG9pbnQ7XHJcblxyXG4gICAgICAgIC8vIGNob29zZSBhIHNpZGUgZm9yIHRlcm1pbmF0aW9uIG5vZGVcclxuXHJcbiAgICAgICAgbGV0IGNyb3NzUG9pbnQgPSBnZXRDcm9zUG9pbnQoc291cmNlUG9pbnQsIHRlcm1pbmF0aW9uUG9pbnQsIHRvcExlZnQsIGJvdHRvbUxlZnQpOyAvLyBsZWZ0XHJcbiAgICBcclxuICAgICAgICBpZiAoIWNyb3NzUG9pbnQpIHtcclxuICAgICAgICAgICAgY3Jvc3NQb2ludCA9IGdldENyb3NQb2ludChzb3VyY2VQb2ludCwgdGVybWluYXRpb25Qb2ludCwgdG9wTGVmdCwgdG9wUmlnaHQpOyAvLyB0b3BcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFjcm9zc1BvaW50KSB7XHJcbiAgICAgICAgICAgIGNyb3NzUG9pbnQgPSBnZXRDcm9zUG9pbnQoc291cmNlUG9pbnQsIHRlcm1pbmF0aW9uUG9pbnQsIHRvcFJpZ2h0LCBib3R0b21SaWdodCk7IC8vIHJpZ2h0XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghY3Jvc3NQb2ludCkge1xyXG4gICAgICAgICAgICBjcm9zc1BvaW50ID0gZ2V0Q3Jvc1BvaW50KHNvdXJjZVBvaW50LCB0ZXJtaW5hdGlvblBvaW50LCBib3R0b21MZWZ0LCBib3R0b21SaWdodCk7IC8vIGJvdHRvbVxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBpZiAoY3Jvc3NQb2ludCkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgeDogY3Jvc3NQb2ludC54IC0gX3Rlcm1pbmF0aW9uTm9kZVNpemUud2lkdGggLyAyLFxyXG4gICAgICAgICAgICAgICAgeTogY3Jvc3NQb2ludC55IC0gX3Rlcm1pbmF0aW9uTm9kZVNpemUuaGVpZ2h0IC8gMixcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgeDogTWF0aC5taW4oXHJcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5tYXgodGVybWluYXRpb25Qb2ludC54ICsgbm9kZVNpemUud2lkdGggLyAyLCB2aWV3RnJhbWVQb3NpdGlvbi54KSxcclxuICAgICAgICAgICAgICAgICAgICB2aWV3RnJhbWVQb3NpdGlvbi54ICsgdmlld0ZyYW1lU2l6ZS53aWR0aFxyXG4gICAgICAgICAgICAgICAgKSxcclxuICAgICAgICAgICAgICAgIHk6IE1hdGgubWluKFxyXG4gICAgICAgICAgICAgICAgICAgIE1hdGgubWF4KHRlcm1pbmF0aW9uUG9pbnQueSArIG5vZGVTaXplLmhlaWdodCAvIDIsIHZpZXdGcmFtZVBvc2l0aW9uLnkpLFxyXG4gICAgICAgICAgICAgICAgICAgIHZpZXdGcmFtZVBvc2l0aW9uLnkgKyB2aWV3RnJhbWVTaXplLmhlaWdodFxyXG4gICAgICAgICAgICAgICAgKSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGdldENhbGN1bGF0aW9uUG9pbnRzICgpIHtcclxuICAgICAgICAgICAgY29uc3Qgc291cmNlUG9pbnQgPSB7XHJcbiAgICAgICAgICAgICAgICB4OiB2aWV3RnJhbWVQb3NpdGlvbi54ICsgdmlld0ZyYW1lU2l6ZS53aWR0aCAvIDIsXHJcbiAgICAgICAgICAgICAgICB5OiB2aWV3RnJhbWVQb3NpdGlvbi55ICsgdmlld0ZyYW1lU2l6ZS5oZWlnaHQgLyAyLFxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgY29uc3Qgb3duZXJWaWV3RnJhbWUgPSBfZ2V0Vmlld0ZyYW1lRm9yTm9kZShvcmlnaW5hbE5vZGUpO1xyXG4gICAgICAgICAgICBjb25zdCBzY2FsZSA9IG93bmVyVmlld0ZyYW1lLmdldFNjYWxlKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vZGVQb3NpdGlvbiA9IGdldExvY2FsTm9kZVBvc2l0aW9uKG9yaWdpbmFsTm9kZSwgc2NhbGUsIG93bmVyVmlld0ZyYW1lKTtcclxuICAgICAgICAgICAgY29uc3QgdGVybWluYXRpb25Qb2ludCA9IHtcclxuICAgICAgICAgICAgICAgIHg6IG5vZGVQb3NpdGlvbi54ICsgbm9kZVNpemUud2lkdGggLyAyLFxyXG4gICAgICAgICAgICAgICAgeTogbm9kZVBvc2l0aW9uLnkgKyBub2RlU2l6ZS5oZWlnaHQgLyAyLFxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgY29uc3QgcG9pbnRJc0luVGhlRnJhbWUgPSB2aWV3RnJhbWUuaGl0U2NhbGVkUG9pbnRUZXN0KHRlcm1pbmF0aW9uUG9pbnQpO1xyXG4gICAgICAgICAgICBpZiAocG9pbnRJc0luVGhlRnJhbWUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRpc3RUb0xlZnQgPSB0ZXJtaW5hdGlvblBvaW50LnggLSB2aWV3RnJhbWVQb3NpdGlvbi54O1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZGlzdFRvVG9wID0gdGVybWluYXRpb25Qb2ludC55IC0gdmlld0ZyYW1lUG9zaXRpb24ueTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRpc3RUb1JpZ2h0ID0gdmlld0ZyYW1lUG9zaXRpb24ueCArIHZpZXdGcmFtZVNpemUud2lkdGggLSB0ZXJtaW5hdGlvblBvaW50Lng7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkaXN0VG9Cb3R0b20gPSB2aWV3RnJhbWVQb3NpdGlvbi55ICsgdmlld0ZyYW1lU2l6ZS5oZWlnaHQgLSB0ZXJtaW5hdGlvblBvaW50Lnk7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGxldCBtaW4gPSBJbmZpbml0eTtcclxuICAgICAgICAgICAgICAgIFtkaXN0VG9MZWZ0LCBkaXN0VG9Ub3AsIGRpc3RUb1JpZ2h0LCBkaXN0VG9Cb3R0b21dLmZvckVhY2goZGlzdCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWluID0gTWF0aC5taW4obWluLCBkaXN0KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChtaW4gPT09IGRpc3RUb0xlZnQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0ZXJtaW5hdGlvblBvaW50LnggLT0gbWluOyBcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobWluID09PSBkaXN0VG9SaWdodCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRlcm1pbmF0aW9uUG9pbnQueCArPSBtaW47IFxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtaW4gPT09IGRpc3RUb1RvcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRlcm1pbmF0aW9uUG9pbnQueSAtPSBtaW47IFxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0ZXJtaW5hdGlvblBvaW50LnkgKz0gbWluOyBcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gU29tZXRpbWUgaXQncyBjb25mdXNpbmcgZm9yIHVzZXJzIHdoZW5cclxuICAgICAgICAgICAgLy8gbm9kZXMgYXJlIGluIHRoZSBsZWZ0Vmlld0ZyYW1lIGJ1dCB0ZXJtaW5hdGlvbiBub2RlcyBnb2VzIHRvIHRoZSByaWdodFxyXG4gICAgICAgICAgICBpZiAob3duZXJWaWV3RnJhbWUuaWQgIT09IHZpZXdGcmFtZS5pZCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaWRzID0gX2FsbEZyYW1lcy5tYXAodmYgPT4gdmYuaWQpO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgdmlld0ZyYW1lSW5kZXggPSBpZHMuaW5kZXhPZih2aWV3RnJhbWUuaWQpO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgb3duZXJWaWV3RnJhbWVJbmRleCA9IGlkcy5pbmRleE9mKG93bmVyVmlld0ZyYW1lLmlkKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG9yaWVudGF0aW9uID0gcmVuZGVyT3B0aW9ucy5wYXBlck9wdGlvbnMub3JpZW50YXRpb247XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpc0hvcml6b250YWxPcmllbnRhdGVkID0gb3JpZW50YXRpb24gPT09ICdsZWZ0LXRvLXJpZ2h0JyB8fCBvcmllbnRhdGlvbiA9PT0gJ3JpZ2h0LXRvLWxlZnQnO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZpZXdGcmFtZUluZGV4IDwgb3duZXJWaWV3RnJhbWVJbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0hvcml6b250YWxPcmllbnRhdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlcm1pbmF0aW9uUG9pbnQueCA9IGJvdHRvbVJpZ2h0Lng7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGVybWluYXRpb25Qb2ludC55ID0gYm90dG9tUmlnaHQueTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0hvcml6b250YWxPcmllbnRhdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlcm1pbmF0aW9uUG9pbnQueCA9IHRvcExlZnQueDtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXJtaW5hdGlvblBvaW50LnkgPSB0b3BMZWZ0Lnk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgc291cmNlUG9pbnQ6IHNvdXJjZVBvaW50LFxyXG4gICAgICAgICAgICAgICAgdGVybWluYXRpb25Qb2ludDogdGVybWluYXRpb25Qb2ludCxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIChvciBnZXQgZnJvbSBjYWNoZSkgYXNwZWN0IGxpbmtzXHJcbiAgICAgKiBAcGFyYW0ge05vZGVbXX0gbm9kZXMgLSB2aXNpYmxlIG5vZGVzXHJcbiAgICAgKiBAcmV0dXJucyB7QXNwZWN0TGlua1tdfVxyXG4gICAgKi9cclxuICAgIGZ1bmN0aW9uIF9jYWxjdWxhdGVBc3BlY3RMaW5rcyAobm9kZXMpIHtcclxuICAgICAgICBjb25zdCBhc3BlY3RMaW5rc0NhY2hlID0ge307XHJcbiAgICAgICAgY29uc3Qgbm9kZU1hcCA9IGFycmF5VG9NYXAobm9kZXMpO1xyXG4gICAgICAgIG5vZGVzLmZvckVhY2gobm9kZSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGFzcGVjdHMgPSBnZXRCYXNlRWxlbWVudChub2RlKS5hc3BlY3RzO1xyXG4gICAgICAgICAgICBhc3BlY3RzLmZvckVhY2goYXNwZWN0ID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHZpc2libGVUZXJtaW5hdGlvbnMgPSBhc3BlY3QudGVybWluYXRpb25Ob2Rlcy5maWx0ZXIodG4gPT4gbm9kZU1hcFt0bi5pZF0pO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYXRMZWFzdE9uZVRlcm1pbmF0aW9uID0gdmlzaWJsZVRlcm1pbmF0aW9ucy5sZW5ndGggPiAwO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYXNwZWN0V2lsbE9uVGhlUGFwZXIgPSAgbm9kZU1hcFthc3BlY3QuaWRdIHx8IGF0TGVhc3RPbmVUZXJtaW5hdGlvbjtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHZpZXdGcmFtZU93bmVyID0gX2dldFZpZXdGcmFtZUZvck5vZGUoYXNwZWN0KTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHZpZXdGcmFtZU93bmVySXNWaXNpYmxlID0gX3N0YXRlW3ZpZXdGcmFtZU93bmVyLmlkXSB8fCBfZnVsbFNjcmVlbk1vZGU7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXNwZWN0V2lsbE9uVGhlUGFwZXIgJiYgdmlld0ZyYW1lT3duZXJJc1Zpc2libGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhc3BlY3RJbnN0YW5jZXMgPSBub2RlTWFwW2FzcGVjdC5pZF0gP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFthc3BlY3RdIDogdmlzaWJsZVRlcm1pbmF0aW9ucztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYXNwZWN0SW5zdGFuY2VzLmZvckVhY2goYXNwZWN0SW5zdGFuY2UgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWNoZWRMaW5rID0gZ2V0RnJvbUNhaGUobm9kZSwgYXNwZWN0SW5zdGFuY2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhc3BlY3RMaW5rID0gY2FjaGVkTGluayB8fCBjcmVhdGVBc3BlY3RMaW5rKG5vZGUsIGFzcGVjdEluc3RhbmNlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzcGVjdExpbmtzQ2FjaGVbYXNwZWN0TGluay5pZF0gPSBhc3BlY3RMaW5rO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBfYXNwZWN0TGlua3NDYWhlID0gYXNwZWN0TGlua3NDYWNoZTtcclxuICAgICAgICBjb25zdCBhc3BlY3RMaW5rcyA9IE9iamVjdC5rZXlzKGFzcGVjdExpbmtzQ2FjaGUpLm1hcChpZCA9PiBfYXNwZWN0TGlua3NDYWhlW2lkXSk7XHJcbiAgICAgICAgcmV0dXJuIGFzcGVjdExpbmtzO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVBc3BlY3RMaW5rIChub2RlLCBhc3BlY3QpIHtcclxuICAgICAgICAgICAgY29uc3QgaWQgPSBub2RlLmlkICsgJ34jficgKyBhc3BlY3QuaWQ7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEFzcGVjdExpbmsoe1xyXG4gICAgICAgICAgICAgICAgaWQ6IGlkLFxyXG4gICAgICAgICAgICAgICAgc291cmNlOiBub2RlLFxyXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBhc3BlY3QsXHJcbiAgICAgICAgICAgIH0sIHBhcmFtZXRlcnMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gZ2V0RnJvbUNhaGUgKG5vZGUsIGFzcGVjdCkge1xyXG4gICAgICAgICAgICBjb25zdCBpZCA9IG5vZGUuaWQgKyAnfiN+JyArIGFzcGVjdC5pZDtcclxuICAgICAgICAgICAgY29uc3QgcmV2ZXJzZUlkID0gYXNwZWN0LmlkICsgJ34jficgKyBub2RlLmlkO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgbGlua0Zyb21Mb2NhbCA9IGFzcGVjdExpbmtzQ2FjaGVbaWRdIHx8IGFzcGVjdExpbmtzQ2FjaGVbcmV2ZXJzZUlkXTtcclxuICAgICAgICAgICAgY29uc3QgbGlua0Zyb21HbG9iYWwgPSBfYXNwZWN0TGlua3NDYWhlW2lkXSB8fCBfYXNwZWN0TGlua3NDYWhlW3JldmVyc2VJZF07XHJcbiAgICAgICAgICAgIHJldHVybiBsaW5rRnJvbUxvY2FsIHx8IGxpbmtGcm9tR2xvYmFsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENoYW5nZXMgaGlnaGxpZ2h0aW5nIG9mIHRoZSBlbGVtZW50c1xyXG4gICAgICogQHBhcmFtIHsoTm9kZXxMaW5rfFRlcm1pbmF0aW9uTm9kZXxUZXJtaW5hdGlvbkxpbmspW119IGNlbGxzXHJcbiAgICAgKiBAcGFyYW0ge1JlbmRlck9wdGlvbn0gcmVuZGVyT3B0aW9uc1xyXG4gICAgKi9cclxuICAgIGZ1bmN0aW9uIF9zZXRIaWdobGlnaHRpbmcgKGNlbGxzLCByZW5kZXJPcHRpb25zKSB7XHJcbiAgICAgICAgY29uc3QgcGF0aCA9IHJlbmRlck9wdGlvbnMucGF0aDtcclxuICAgICAgICBjb25zdCBtYXNrID0gcmVuZGVyT3B0aW9ucy5tYXNrO1xyXG5cclxuICAgICAgICBjZWxscy5mb3JFYWNoKGNlbGwgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBiYXNlQ2VsbCA9IGdldEJhc2VFbGVtZW50KGNlbGwpO1xyXG4gICAgICAgICAgICBpZiAobWFzayAmJiBiYXNlQ2VsbCAhPT0gcmVuZGVyT3B0aW9ucy5zZWxlY3RlZEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChtYXNrW2Jhc2VDZWxsLmlkXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJhc2VDZWxsLmhpZGUoKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmFzZUNlbGwuc2hvdygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChiYXNlQ2VsbCA9PT0gcmVuZGVyT3B0aW9ucy5zZWxlY3RlZEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIGJhc2VDZWxsLnNlbGVjdCgpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhdGggJiYgIXBhdGhbYmFzZUNlbGwuaWRdKSB7XHJcbiAgICAgICAgICAgICAgICBiYXNlQ2VsbC5ibHVyZSgpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYmFzZUNlbGwudW5ibHVyZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGxpc3Qgb2YgdmlzaWJsZSB2aWV3RnJhbWVzXHJcbiAgICAgKiBAcmV0dXJucyB7Vmlld0ZyYW1lW119XHJcbiAgICAqL1xyXG4gICAgZnVuY3Rpb24gX2dldFZpc2libGVWaWV3RnJhbWVzICgpIHtcclxuICAgICAgICByZXR1cm4gX2Z1bGxTY3JlZW5Nb2RlID8gW19vdmVyVmlld0ZyYW1lXSA6IF92aWV3RnJhbWVzLmZpbHRlcih2ZiA9PiBfc3RhdGVbdmYuaWRdKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdmlld0ZyYW1lIGZvciB0aGUgbm9kZS5cclxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxyXG4gICAgICogQHJldHVybnMge1ZpZXdGcmFtZSB8IHVuZGVmaW5lZH1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gX2dldFZpZXdGcmFtZUZvck5vZGUgKG5vZGUpIHtcclxuICAgICAgICBpZiAoX2Z1bGxTY3JlZW5Nb2RlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfb3ZlclZpZXdGcmFtZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCB2aWV3RnJhbWVJZCA9IGdldFZpZXdGcmFtZUlkRm9yTm9kZShub2RlKTtcclxuICAgICAgICAgICAgcmV0dXJuIF92aWV3RnJhbWVzTWFwW3ZpZXdGcmFtZUlkXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdWJzY3JpYmVzIG9uIHZpZXdGcmFtZSBldmVudHNcclxuICAgICovXHJcbiAgICBmdW5jdGlvbiBfc3Vic2NyaWJlT25WaWV3RnJhbWVFdmVudHMgKCkge1xyXG4gICAgICAgIF9hbGxGcmFtZXMuZm9yRWFjaCh2aWV3RnJhbWUgPT4ge1xyXG4gICAgICAgICAgICB2aWV3RnJhbWUub24oJ2NoYW5nZS12aWV3LXBvcnQtcG9zaXRpb24nLCAobmV3Vmlld1BvcnRQb3NpdGlvbikgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHZpZXdGcmFtZS5tb3ZpbmdCeUl0c2VsZikgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHZpZXdGcmFtZVB1YmxpY01vZGVsID0gX2dldFZpZXdGcmFtZVB1YmxpY01vZGVsKHZpZXdGcmFtZSk7XHJcbiAgICAgICAgICAgICAgICB2aWV3RnJhbWVQdWJsaWNNb2RlbC52aWV3UG9ydFBvc2l0aW9uID0gbmV3Vmlld1BvcnRQb3NpdGlvbjtcclxuXHJcbiAgICAgICAgICAgICAgICBzZWxmLnRyaWdnZXIoJ2NoYW5nZS12aWV3LXBvcnQtcG9zaXRpb24nLCB2aWV3RnJhbWVQdWJsaWNNb2RlbCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBWaWV3TWFuYWdlcjtcclxuIiwiaW1wb3J0ICogYXMgY29sYSBmcm9tICd3ZWJjb2xhJztcclxuaW1wb3J0ICogYXMgXyBmcm9tICdsb2Rhc2gnO1xyXG5pbXBvcnQgU2Fua2V5IGZyb20gJy4vc2Fua2V5JztcclxuaW1wb3J0IHsgYXJyYXlUb01hcCwgZ2V0RWxlbWVudFNpemUsIGdldEdsb2JhbE5vZGVQb3NpdGlvbiB9IGZyb20gJy4uL3V0aWxzL3V0aWxzJztcclxuaW1wb3J0IHtcclxuICAgIGNvbnZlcnROYXRpdmVUb0xheW91dE1vZGVscyxcclxuICAgIGNvbnZlcnRMR0VsZW1lbnRzVG9MYXlvdXRNb2RlbHMsXHJcbn0gZnJvbSAnLi4vdXRpbHMvbGF5b3V0VXRpbHMnO1xyXG5cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7e1xyXG4gKiAgc2VsZWN0ZWROb2RlOiBOb2RlLFxyXG4gKiAgcmVsYXRpdmVMaW5rczogTGlua1tdLFxyXG4gKiAgcmVsYXRpdmVOb2RlczogTm9kZVtdLFxyXG4gKiB9fSBvcHRpb25zIFxyXG4gKiBAcGFyYW0ge1BhcmFtZXRlcnN9IHBhcmFtZXRlcnMgLSBwYXJhbWV0ZXJzIHNldFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbWJpbmVPcGVyYXRpb24gKG9wdGlvbnMsIHBhcmFtZXRlcnMpIHtcclxuICAgIGNvbnN0IHNjYWxlID0gb3B0aW9ucy5zY2FsZTtcclxuXHJcbiAgICBjb25zdCBzdGFydFBvc2l0aW9uID0gZ2V0R2xvYmFsTm9kZVBvc2l0aW9uKG9wdGlvbnMuc2VsZWN0ZWROb2RlKTtcclxuICAgIGNvbnN0IGNvbWJpbmVkTm9kZXMgPSBbb3B0aW9ucy5zZWxlY3RlZE5vZGVdLmNvbmNhdChvcHRpb25zLnJlbGF0aXZlTm9kZXMpO1xyXG5cclxuICAgIGNvbnN0IGVsZW1lbnRzID0gY29udmVydExHRWxlbWVudHNUb0xheW91dE1vZGVscyhjb21iaW5lZE5vZGVzLCBvcHRpb25zLnJlbGF0aXZlTGlua3MsIHtcclxuICAgICAgICBzY2FsZTogc2NhbGUsXHJcbiAgICB9KTtcclxuICAgIGNvbnN0IG5vZGVzID0gZWxlbWVudHMubm9kZXM7XHJcbiAgICBjb25zdCBsaW5rcyA9IGVsZW1lbnRzLmxpbmtzO1xyXG4gICAgY29uc3Qgc2VsZWN0ZWRMYXlvdXROb2RlID0gbm9kZXNbMF07XHJcblxyXG4gICAgY29uc3QgbGF5b3V0T3B0aW9ucyA9IHtcclxuICAgICAgICBub2Rlczogbm9kZXMsXHJcbiAgICAgICAgbGlua3M6IGxpbmtzLFxyXG4gICAgICAgIHN0ZXA6IHBhcmFtZXRlcnMubGF5b3V0U3RlcCxcclxuICAgICAgICBlbGVtZW50OiBwYXJhbWV0ZXJzLmVsZW1lbnRTaXplLFxyXG4gICAgICAgIGl0ZXJhdGlvbnM6IHBhcmFtZXRlcnMubGF5b3V0SXRlcmF0aW9ucyxcclxuICAgIH07XHJcbiAgICB0cUZvcmNlTGF5b3V0KGxheW91dE9wdGlvbnMpO1xyXG5cclxuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xyXG4gICAgbm9kZXMuZm9yRWFjaChsYXlvdXROb2RlID0+IHtcclxuICAgICAgICBpZiAobGF5b3V0Tm9kZSAhPT0gc2VsZWN0ZWRMYXlvdXROb2RlKSB7XHJcbiAgICAgICAgICAgIGxheW91dE5vZGUueCA9IHN0YXJ0UG9zaXRpb24ueCArIChsYXlvdXROb2RlLnggLSBzZWxlY3RlZExheW91dE5vZGUueCk7XHJcbiAgICAgICAgICAgIGxheW91dE5vZGUueSA9IHN0YXJ0UG9zaXRpb24ueSArIChsYXlvdXROb2RlLnkgLSBzZWxlY3RlZExheW91dE5vZGUueSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc3VsdFtsYXlvdXROb2RlLm9yaWdpbmFsTm9kZS5pZF0gPSB7XHJcbiAgICAgICAgICAgIHg6IGxheW91dE5vZGUueCxcclxuICAgICAgICAgICAgeTogbGF5b3V0Tm9kZS55LFxyXG4gICAgICAgIH07XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG4vKipcclxuICogQHByaXZhdGUgXHJcbiAqIFxyXG4gKiBDYWxjdWxhdGVzIHBvc2l0aW9ucyBmb3Igbm9kZXMuXHJcbiAqIEBwYXJhbSB7QXJyYXl9IG5vZGVNb2RlbHMgLSBsaXN0IG9mIHRoZSBuYXRpdmUgbm9kZXNcclxuICogQHBhcmFtIHtBcnJheX0gbmF0aXZlTGlua3MgLSBsaXN0IG9mIHRoZSBuYXRpdmUgbGlua3NcclxuICogQHBhcmFtIHtQYXJhbWV0ZXJzfSBwYXJhbWV0ZXJzIC0gcGFyYW1ldGVycyBzZXRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBkb0xheW91dCAobm9kZU1vZGVscywgbGlua01vZGVscywgdmlld0ZyYW1lcywgcGFyYW1ldGVycykge1xyXG4gICAgaWYgKCFwYXJhbWV0ZXJzKSByZXR1cm47XHJcblxyXG4gICAgY29uc3QgZWxlbWVudHMgPSBjb252ZXJ0TmF0aXZlVG9MYXlvdXRNb2RlbHMobm9kZU1vZGVscywgbGlua01vZGVscywgcGFyYW1ldGVycyk7XHJcbiAgICBjb25zdCBub2RlcyA9IGVsZW1lbnRzLm5vZGVzO1xyXG4gICAgY29uc3QgbGlua3MgPSBlbGVtZW50cy5saW5rcztcclxuICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IHBhcmFtZXRlcnMuZ3JhcGhPcmllbnRhdGlvbiA9PT0gJ3JpZ2h0LXRvLWxlZnQnIHx8IHBhcmFtZXRlcnMuZ3JhcGhPcmllbnRhdGlvbiA9PT0gJ2xlZnQtdG8tcmlnaHQnO1xyXG4gICAgXHJcbiAgICByZW1vdmVDeWNsZXMobm9kZXMsIGxpbmtzKTtcclxuICAgIFxyXG4gICAgY29uc3QgZ3JvdXBzID0gYnJlYWtCeUdyb3Vwcyhub2RlcywgbGlua3MsIHZpZXdGcmFtZXMsIHBhcmFtZXRlcnMpO1xyXG5cclxuICAgIGNvbnN0IGxheW91dE9wdGlvbnMgPSB7XHJcbiAgICAgICAgZ3JvdXBzOiBncm91cHMsXHJcbiAgICAgICAgbm9kZXM6IG5vZGVzLFxyXG4gICAgICAgIGxpbmtzOiBsaW5rcyxcclxuICAgICAgICBpc0hvcml6b250YWw6IGlzSG9yaXpvbnRhbCxcclxuICAgICAgICBzdGVwOiBwYXJhbWV0ZXJzLmxheW91dFN0ZXAsXHJcbiAgICAgICAgZWxlbWVudDogcGFyYW1ldGVycy5lbGVtZW50U2l6ZSxcclxuICAgICAgICBpdGVyYXRpb25zOiBwYXJhbWV0ZXJzLmxheW91dEl0ZXJhdGlvbnMsXHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBpZiAocGFyYW1ldGVycy5sYXlvdXRBbGdvcml0aG0gPT09ICdmbG93LWRpcmVjdGVkJykge1xyXG4gICAgICAgIHRxRmxvd0xheW91dChsYXlvdXRPcHRpb25zKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdHFTYW5rZXlMYXlvdXQobGF5b3V0T3B0aW9ucyk7XHJcbiAgICB9XHJcbiAgICBhcHBseUxheW91dCgpO1xyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBhcHBseUxheW91dCAoKSB7XHJcbiAgICAgICAgLy8gQ2FsY3VsYXRpbmcgbWluIHBvaW50c1xyXG4gICAgICAgIGxldCBtaW5YID0gSW5maW5pdHksIG1pblkgPSBJbmZpbml0eTtcclxuICAgICAgICBub2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xyXG4gICAgICAgICAgICBtaW5YID0gTWF0aC5taW4obWluWCwgbm9kZS54KTtcclxuICAgICAgICAgICAgbWluWSA9IE1hdGgubWluKG1pblksIG5vZGUueSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGxldCBtYXhYID0gbm9kZXMubGVuZ3RoID4gMCA/IC1JbmZpbml0eSA6IDA7XHJcbiAgICAgICAgY29uc3QgY2FudmFzUGFkZGluZyA9IFxyXG4gICAgICAgICAgICBNYXRoLm1heChwYXJhbWV0ZXJzLmVsZW1lbnRTaXplLndpZHRoLCBwYXJhbWV0ZXJzLmVsZW1lbnRTaXplLmhlaWdodCkgKiAyICogcGFyYW1ldGVycy5zY2FsZUJvdW5kcy5tYXg7XHJcbiAgICAgICAgbm9kZXMuZm9yRWFjaChub2RlID0+IHtcclxuICAgICAgICAgICAgbm9kZS5vcmlnaW5hbE5vZGUucG9zaXRpb24ueCA9IG5vZGUueCAtIG1pblggKyBjYW52YXNQYWRkaW5nO1xyXG4gICAgICAgICAgICBub2RlLm9yaWdpbmFsTm9kZS5wb3NpdGlvbi55ID0gbm9kZS55IC0gbWluWSArIGNhbnZhc1BhZGRpbmc7XHJcbiAgICAgICAgICAgIG1heFggPSBNYXRoLm1heChtYXhYLCBub2RlLm9yaWdpbmFsTm9kZS5wb3NpdGlvbi54KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaWYgKHBhcmFtZXRlcnMuZ3JhcGhPcmllbnRhdGlvbiA9PT0gJ3JpZ2h0LXRvLWxlZnQnIHx8IHBhcmFtZXRlcnMuZ3JhcGhPcmllbnRhdGlvbiA9PT0gJ2JvdHRvbS10by10b3AnKSB7XHJcbiAgICAgICAgICAgIG5vZGVNb2RlbHMuZm9yRWFjaChub2RlID0+IHtcclxuICAgICAgICAgICAgICAgIG5vZGUucG9zaXRpb24ueCA9IG1heFggLSBub2RlLnBvc2l0aW9uLng7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFpc0hvcml6b250YWwpIHtcclxuICAgICAgICAgICAgbm9kZU1vZGVscy5mb3JFYWNoKG5vZGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IG5vZGUucG9zaXRpb24ueDtcclxuICAgICAgICAgICAgICAgIG5vZGUucG9zaXRpb24ueCA9IG5vZGUucG9zaXRpb24ueTtcclxuICAgICAgICAgICAgICAgIG5vZGUucG9zaXRpb24ueSA9IHg7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbm9kZU1vZGVscy5mb3JFYWNoKG5vZGUgPT4ge1xyXG4gICAgICAgICAgICBub2RlLmRlZmF1bHRQb3NpdGlvbiA9IF8uY2xvbmUobm9kZS5wb3NpdGlvbik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVDeWNsZXMgKG5vZGVzLCBsaW5rcykge1xyXG4gICAgbm9kZXMuZm9yRWFjaChuID0+IHtcclxuICAgICAgICBjb25zdCByZXBlYXRNYXAgPSB7fTtcclxuICAgICAgICBjb25zdCBsaW5rc1RvUmVtb3ZlID0gW107XHJcblxyXG4gICAgICAgIHJlY3Vyc2lvbihuKTtcclxuXHJcbiAgICAgICAgbGlua3NUb1JlbW92ZS5mb3JFYWNoKGxpbmsgPT4ge1xyXG4gICAgICAgICAgICBsaW5rcy5zcGxpY2UobGlua3MuaW5kZXhPZihsaW5rKSwgMSk7XHJcbiAgICAgICAgICAgIGxpbmsudGFyZ2V0LnNvdXJjZUxpbmtzLnNwbGljZShsaW5rLnRhcmdldC5zb3VyY2VMaW5rcy5pbmRleE9mKGxpbmspLCAxKTtcclxuICAgICAgICAgICAgbGluay5zb3VyY2UudGFyZ2V0TGlua3Muc3BsaWNlKGxpbmsuc291cmNlLnRhcmdldExpbmtzLmluZGV4T2YobGluayksIDEpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiByZWN1cnNpb24gKG5vZGUpIHtcclxuICAgICAgICAgICAgcmVwZWF0TWFwW25vZGUuaWRdID0gdHJ1ZTtcclxuICAgICAgICAgICAgbm9kZS50YXJnZXRMaW5rcy5mb3JFYWNoKGxpbmsgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFyZXBlYXRNYXBbbGluay50YXJnZXQuaWRdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVjdXJzaW9uIChsaW5rLnRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGxpbmtzVG9SZW1vdmUucHVzaChsaW5rKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJlcGVhdE1hcFtub2RlLmlkXSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBicmVha0J5R3JvdXBzIChub2RlcywgbGlua3MsIHZpZXdGcmFtZXMsIHBhcmFtZXRlcnMpIHtcclxuICAgIGNvbnN0IG5vZGVNYXAgPSBhcnJheVRvTWFwKG5vZGVzKTtcclxuICAgIGNvbnN0IGdyb3VwcyA9IHt9O1xyXG4gICAgY29uc3QgcGFwZXJTaXplID0gZ2V0RWxlbWVudFNpemUocGFyYW1ldGVycy5ncmFwaFBsYWNlKTtcclxuICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IHBhcmFtZXRlcnMuZ3JhcGhPcmllbnRhdGlvbiA9PT0gJ2xlZnQtdG8tcmlnaHQnIHx8IHBhcmFtZXRlcnMuZ3JhcGhPcmllbnRhdGlvbiA9PT0gJ3JpZ2h0LXRvLWxlZnQnO1xyXG4gICAgY29uc3QgdG90YWxTaGFyZSA9IHZpZXdGcmFtZXMucmVkdWNlKChhY2N1bXVsYXRvciwgdmlld0ZyYW1lKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yICsgdmlld0ZyYW1lLnNwYWNlU2hhcmU7XHJcbiAgICB9LCAwKTtcclxuICAgIHZpZXdGcmFtZXMuZm9yRWFjaCh2aWV3RnJhbWUgPT4ge1xyXG4gICAgICAgIGlmICghZ3JvdXBzW3ZpZXdGcmFtZS5pZF0pIGdyb3Vwc1t2aWV3RnJhbWUuaWRdID0ge1xyXG4gICAgICAgICAgICBpZDogdmlld0ZyYW1lLmlkLFxyXG4gICAgICAgICAgICBwcmVmZmVyZWRTaXplOiB7XHJcbiAgICAgICAgICAgICAgICB3aWR0aDogaXNIb3Jpem9udGFsID9cclxuICAgICAgICAgICAgICAgICAgICAocGFwZXJTaXplLndpZHRoIC8gdG90YWxTaGFyZSkgKiB2aWV3RnJhbWUuc3BhY2VTaGFyZSA6XHJcbiAgICAgICAgICAgICAgICAgICAgKHBhcGVyU2l6ZS5oZWlnaHQgLyB0b3RhbFNoYXJlKSAqIHZpZXdGcmFtZS5zcGFjZVNoYXJlLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBpc0hvcml6b250YWwgPyBwYXBlclNpemUuaGVpZ2h0IDogcGFwZXJTaXplLndpZHRoLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBub2RlczogW10sXHJcbiAgICAgICAgICAgIGxpbmtzOiBbXSxcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBjb25zdCBsYXN0Tm9kZXMgPSBbXTtcclxuICAgICAgICBub2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xyXG4gICAgICAgICAgICBpZiAobm9kZS52aWV3RnJhbWUgPT09IHZpZXdGcmFtZS5pZCkge1xyXG4gICAgICAgICAgICAgICAgZ3JvdXBzW3ZpZXdGcmFtZS5pZF0ubm9kZXMucHVzaChub2RlKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGxhc3ROb2Rlcy5wdXNoKG5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgbm9kZXMgPSBsYXN0Tm9kZXM7XHJcblxyXG4gICAgICAgIGNvbnN0IGxhc3RMaW5rcyA9IFtdO1xyXG4gICAgICAgIGxpbmtzLmZvckVhY2gobCA9PiB7XHJcbiAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgIG5vZGVNYXBbbC5zb3VyY2UuaWRdLnZpZXdGcmFtZSA9PT0gdmlld0ZyYW1lLmlkICYmXHJcbiAgICAgICAgICAgICAgICBub2RlTWFwW2wudGFyZ2V0LmlkXS52aWV3RnJhbWUgPT09IHZpZXdGcmFtZS5pZFxyXG4gICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgIGdyb3Vwc1t2aWV3RnJhbWUuaWRdLmxpbmtzLnB1c2gobCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXHJcbiAgICAgICAgICAgICAgICBub2RlTWFwW2wuc291cmNlLmlkXS52aWV3RnJhbWUgIT09IHZpZXdGcmFtZS5pZCAmJlxyXG4gICAgICAgICAgICAgICAgbm9kZU1hcFtsLnRhcmdldC5pZF0udmlld0ZyYW1lICE9PSB2aWV3RnJhbWUuaWRcclxuICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICBsYXN0TGlua3MucHVzaChsKTsgXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBsaW5rcyA9IGxhc3RMaW5rcztcclxuICAgIH0pO1xyXG4gICAgZ3JvdXBzWyd1bmtub3duJ10gPSB7IGlkOiAndW5rbm93bicsIG5vZGVzOiBub2RlcywgbGlua3M6IGxpbmtzIH07XHJcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoZ3JvdXBzKS5tYXAoa2V5ID0+IGdyb3Vwc1trZXldKTtcclxufVxyXG5cclxuZnVuY3Rpb24gdHFTYW5rZXlMYXlvdXQgKG9wdGlvbnMpIHtcclxuICAgIGNvbnN0IHN0ZXAgPSAoXHJcbiAgICAgICAgb3B0aW9ucy5pc0hvcml6b250YWwgP1xyXG4gICAgICAgIFtvcHRpb25zLnN0ZXAueCB8fCAxMDAsIG9wdGlvbnMuc3RlcC55IHx8IDE1XSA6XHJcbiAgICAgICAgW29wdGlvbnMuc3RlcC55IHx8IDE1LCBvcHRpb25zLnN0ZXAueCB8fCAxMDBdXHJcbiAgICApO1xyXG4gICAgb3B0aW9ucy5zdGVwID0gb3B0aW9ucy5zdGVwIHx8IHt9O1xyXG4gICAgU2Fua2V5KCkuc3RlcChzdGVwKVxyXG4gICAgLm5vZGVXaWR0aChvcHRpb25zLmVsZW1lbnQud2lkdGgpXHJcbiAgICAubm9kZUhlaWdodChvcHRpb25zLmVsZW1lbnQuaGVpZ2h0KVxyXG4gICAgLm5vZGVzKG9wdGlvbnMubm9kZXMpXHJcbiAgICAubGlua3Mob3B0aW9ucy5saW5rcylcclxuICAgIC5ncm91cHMob3B0aW9ucy5ncm91cHMpXHJcbiAgICAubGF5b3V0KG9wdGlvbnMuaXRlcmF0aW9ucyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHRxRmxvd0xheW91dCAob3B0aW9ucykge1xyXG4gICAgdHFTYW5rZXlMYXlvdXQob3B0aW9ucyk7XHJcblxyXG4gICAgY29uc3QgbGF5b3V0ID0gbmV3IGNvbGEuTGF5b3V0KClcclxuICAgICAgICAubm9kZXMob3B0aW9ucy5ub2RlcylcclxuICAgICAgICAubGlua3Mob3B0aW9ucy5saW5rcylcclxuICAgICAgICAuY29udmVyZ2VuY2VUaHJlc2hvbGQoMWUtOSlcclxuICAgICAgICAuamFjY2FyZExpbmtMZW5ndGhzKG9wdGlvbnMuc3RlcC54ICogMiB8fCA0MDApXHJcbiAgICAgICAgLmZsb3dMYXlvdXQoJ3gnLCBvcHRpb25zLnN0ZXAueCAqIDJ8fCA0MDApXHJcbiAgICAgICAgLmF2b2lkT3ZlcmxhcHModHJ1ZSlcclxuICAgICAgICAuaGFuZGxlRGlzY29ubmVjdGVkKHRydWUpO1xyXG4gICAgbGF5b3V0LnN0YXJ0KDEwMCwgMCwgNTAsIHVuZGVmaW5lZCwgZmFsc2UpO1xyXG59XHJcblxyXG5mdW5jdGlvbiB0cUZvcmNlTGF5b3V0IChvcHRpb25zKSB7XHJcbiAgICBjb25zdCBsYXlvdXQgPSBuZXcgY29sYS5MYXlvdXQoKVxyXG4gICAgICAgIC5ub2RlcyhvcHRpb25zLm5vZGVzKVxyXG4gICAgICAgIC5saW5rcyhvcHRpb25zLmxpbmtzKVxyXG4gICAgICAgIC5jb252ZXJnZW5jZVRocmVzaG9sZCgxZS05KVxyXG4gICAgICAgIC5qYWNjYXJkTGlua0xlbmd0aHMob3B0aW9ucy5zdGVwLnggKiAxLjUgfHwgMzUwKVxyXG4gICAgICAgIC5hdm9pZE92ZXJsYXBzKHRydWUpXHJcbiAgICAgICAgLmhhbmRsZURpc2Nvbm5lY3RlZCh0cnVlKTtcclxuICAgIGxheW91dC5zdGFydCgxMDAsIDAsIDUwLCB1bmRlZmluZWQsIGZhbHNlKTtcclxufVxyXG4iLCJpbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuLi91dGlscy9sYXlvdXRVdGlscyc7XHJcbmltcG9ydCB7IGFycmF5VG9NYXAgfSBmcm9tICcuLi91dGlscy91dGlscyc7XHJcblxyXG52YXIgU2Fua2V5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHNhbmtleSA9IHt9LFxyXG4gICAgICAgIG5vZGVXaWR0aCA9IDI0LFxyXG4gICAgICAgIG5vZGVIZWlnaHQgPSA4LFxyXG4gICAgICAgIHNpemUgPSBbMSwgMV0sXHJcbiAgICAgICAgc3RlcCA9IFsxMDAsIDMwXSxcclxuICAgICAgICBub2RlcyA9IFtdLFxyXG4gICAgICAgIGdyb3VwcyA9IFtdLFxyXG4gICAgICAgIHNhdmVPcmRlciA9IGZhbHNlLFxyXG4gICAgICAgIGxpbmtzID0gW107XHJcblxyXG4gICAgc2Fua2V5Lm5vZGVXaWR0aCA9IGZ1bmN0aW9uIChfKSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbm9kZVdpZHRoO1xyXG4gICAgICAgIG5vZGVXaWR0aCA9ICtfO1xyXG4gICAgICAgIHJldHVybiBzYW5rZXk7XHJcbiAgICB9O1xyXG5cclxuICAgIHNhbmtleS5ub2RlSGVpZ2h0ID0gZnVuY3Rpb24gKF8pIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBub2RlSGVpZ2h0O1xyXG4gICAgICAgIG5vZGVIZWlnaHQgPSArXztcclxuICAgICAgICByZXR1cm4gc2Fua2V5O1xyXG4gICAgfTtcclxuXHJcbiAgICBzYW5rZXkubm9kZXMgPSBmdW5jdGlvbiAoXykge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG5vZGVzO1xyXG4gICAgICAgIG5vZGVzID0gXztcclxuICAgICAgICByZXR1cm4gc2Fua2V5O1xyXG4gICAgfTtcclxuXHJcbiAgICBzYW5rZXkuc2F2ZU9yZGVyID0gZnVuY3Rpb24gKF8pIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzYXZlT3JkZXI7XHJcbiAgICAgICAgc2F2ZU9yZGVyID0gXztcclxuICAgICAgICByZXR1cm4gc2Fua2V5O1xyXG4gICAgfTtcclxuXHJcbiAgICBzYW5rZXkuZ3JvdXBzID0gZnVuY3Rpb24gKF8pIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBncm91cHM7XHJcbiAgICAgICAgZ3JvdXBzID0gXztcclxuICAgICAgICByZXR1cm4gc2Fua2V5O1xyXG4gICAgfTtcclxuXHJcbiAgICBzYW5rZXkubGlua3MgPSBmdW5jdGlvbiAoXykge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGxpbmtzO1xyXG4gICAgICAgIGxpbmtzID0gXztcclxuICAgICAgICByZXR1cm4gc2Fua2V5O1xyXG4gICAgfTtcclxuXHJcbiAgICBzYW5rZXkuc3RlcCA9IGZ1bmN0aW9uIChfKSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc3RlcDtcclxuICAgICAgICBzdGVwID0gXztcclxuICAgICAgICByZXR1cm4gc2Fua2V5O1xyXG4gICAgfTtcclxuXHJcbiAgICBzYW5rZXkuY29tcHV0ZU5vZGVCcmVhZHRocyA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICBzYW5rZXkubGF5b3V0ID0gZnVuY3Rpb24gKGl0ZXJhdGlvbnMpIHtcclxuICAgICAgICBjb21wdXRlTm9kZUxpbmtzKCk7XHJcbiAgICAgICAgY29tcHV0ZU5vZGVWYWx1ZXMoKTtcclxuXHJcbiAgICAgICAgaWYgKHNhbmtleS5jb21wdXRlTm9kZUJyZWFkdGhzKVxyXG4gICAgICAgICAgICBzYW5rZXkuY29tcHV0ZU5vZGVCcmVhZHRocyhub2RlcywgbGlua3MsIGdyb3Vwcyk7XHJcbiAgICAgICAgZWxzZSBjb21wdXRlTm9kZUJyZWFkdGhzKCk7XHJcblxyXG4gICAgICAgIGNvbXB1dGVOb2RlRGVwdGhzKGl0ZXJhdGlvbnMpO1xyXG4gICAgICAgIGNvbXB1dGVMaW5rRGVwdGhzKCk7XHJcbiAgICAgICAgcmV0dXJuIHNhbmtleTtcclxuICAgIH07XHJcblxyXG4gICAgc2Fua2V5LnJlbGF5b3V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNvbXB1dGVMaW5rRGVwdGhzKCk7XHJcbiAgICAgICAgcmV0dXJuIHNhbmtleTtcclxuICAgIH07XHJcblxyXG4gICAgc2Fua2V5LmxpbmsgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGN1cnZhdHVyZSA9IC41O1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBsaW5rIChkKSB7XHJcbiAgICAgICAgICAgIHZhciB4MCA9IGQuc291cmNlLnggKyBkLnNvdXJjZS5keCxcclxuICAgICAgICAgICAgICAgIHgxID0gZC50YXJnZXQueCxcclxuICAgICAgICAgICAgICAgIHhpID0gdXRpbHMuaW50ZXJwb2xhdGVOdW1iZXIoeDAsIHgxKSxcclxuICAgICAgICAgICAgICAgIHgyID0geGkoY3VydmF0dXJlKSxcclxuICAgICAgICAgICAgICAgIHgzID0geGkoMSAtIGN1cnZhdHVyZSksXHJcbiAgICAgICAgICAgICAgICB5MCA9IGQuc291cmNlLnkgKyBkLnN5ICsgZC5keSAvIDIsXHJcbiAgICAgICAgICAgICAgICB5MSA9IGQudGFyZ2V0LnkgKyBkLnR5ICsgZC5keSAvIDI7XHJcbiAgICAgICAgICAgIHJldHVybiAnTScgKyB4MCArICcsJyArIHkwICtcclxuICAgICAgICAgICAgICAgICdDJyArIHgyICsgJywnICsgeTAgK1xyXG4gICAgICAgICAgICAgICAgJyAnICsgeDMgKyAnLCcgKyB5MSArXHJcbiAgICAgICAgICAgICAgICAnICcgKyB4MSArICcsJyArIHkxO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGluay5jdXJ2YXR1cmUgPSBmdW5jdGlvbiAoXykge1xyXG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBjdXJ2YXR1cmU7XHJcbiAgICAgICAgICAgIGN1cnZhdHVyZSA9ICtfO1xyXG4gICAgICAgICAgICByZXR1cm4gbGluaztcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICByZXR1cm4gbGluaztcclxuICAgIH07XHJcblxyXG4gICAgLy8gUG9wdWxhdGUgdGhlIHNvdXJjZUxpbmtzIGFuZCB0YXJnZXRMaW5rcyBmb3IgZWFjaCBub2RlLlxyXG4gICAgLy8gQWxzbywgaWYgdGhlIHNvdXJjZSBhbmQgdGFyZ2V0IGFyZSBub3Qgb2JqZWN0cywgYXNzdW1lIHRoZXkgYXJlIGluZGljZXMuXHJcbiAgICBmdW5jdGlvbiBjb21wdXRlTm9kZUxpbmtzICgpIHtcclxuICAgICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgICAgIG5vZGUuc291cmNlTGlua3MgPSBbXTtcclxuICAgICAgICAgICAgbm9kZS50YXJnZXRMaW5rcyA9IFtdO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGxpbmtzLmZvckVhY2goZnVuY3Rpb24gKGxpbmspIHtcclxuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGxpbmsuc291cmNlLFxyXG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gbGluay50YXJnZXQ7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc291cmNlID09PSAnbnVtYmVyJykgc291cmNlID0gbGluay5zb3VyY2UgPSBub2Rlc1tsaW5rLnNvdXJjZV07XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnbnVtYmVyJykgdGFyZ2V0ID0gbGluay50YXJnZXQgPSBub2Rlc1tsaW5rLnRhcmdldF07XHJcbiAgICAgICAgICAgIHNvdXJjZS5zb3VyY2VMaW5rcy5wdXNoKGxpbmspO1xyXG4gICAgICAgICAgICB0YXJnZXQudGFyZ2V0TGlua3MucHVzaChsaW5rKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDb21wdXRlIHRoZSB2YWx1ZSAoc2l6ZSkgb2YgZWFjaCBub2RlIGJ5IHN1bW1pbmcgdGhlIGFzc29jaWF0ZWQgbGlua3MuXHJcbiAgICBmdW5jdGlvbiBjb21wdXRlTm9kZVZhbHVlcyAoKSB7XHJcbiAgICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgICAgICBub2RlLnZhbHVlID0gTWF0aC5tYXgoXHJcbiAgICAgICAgICAgICAgICB1dGlscy5zdW0obm9kZS5zb3VyY2VMaW5rcywgdmFsdWUpLFxyXG4gICAgICAgICAgICAgICAgdXRpbHMuc3VtKG5vZGUudGFyZ2V0TGlua3MsIHZhbHVlKVxyXG4gICAgICAgICAgICApIHx8IDE7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSXRlcmF0aXZlbHkgYXNzaWduIHRoZSBicmVhZHRoICh4LXBvc2l0aW9uKSBmb3IgZWFjaCBub2RlLlxyXG4gICAgLy8gTm9kZXMgYXJlIGFzc2lnbmVkIHRoZSBtYXhpbXVtIGJyZWFkdGggb2YgaW5jb21pbmcgbmVpZ2hib3JzIHBsdXMgb25lO1xyXG4gICAgLy8gbm9kZXMgd2l0aCBubyBpbmNvbWluZyBsaW5rcyBhcmUgYXNzaWduZWQgYnJlYWR0aCB6ZXJvLCB3aGlsZVxyXG4gICAgLy8gbm9kZXMgd2l0aCBubyBvdXRnb2luZyBsaW5rcyBhcmUgYXNzaWduZWQgdGhlIG1heGltdW0gYnJlYWR0aC5cclxuXHJcbiAgICBmdW5jdGlvbiBjb21wdXRlTm9kZUJyZWFkdGhzICgpIHtcclxuICAgICAgICBncm91cHMuZm9yRWFjaChncm91cCA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vZGVzT2ZHcnBvdXAgPSBhcnJheVRvTWFwKGdyb3VwLm5vZGVzKTtcclxuICAgICAgICAgICAgbGV0IHJlbWFpbmluZ05vZGVzID0gZ3JvdXAubm9kZXM7XHJcbiAgICAgICAgICAgIGxldCBuZXh0Tm9kZXM7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICByZW1haW5pbmdOb2Rlcy5zb3J0KChuMSwgbjIpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGdldExpbmtzKG4yLnNvdXJjZUxpbmtzKS5sZW5ndGggLSBnZXRMaW5rcyhuMS5zb3VyY2VMaW5rcykubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRMaW5rcyhuMi50YXJnZXRMaW5rcykubGVuZ3RoIC0gZ2V0TGlua3MobjEudGFyZ2V0TGlua3MpLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBsZXQgeCA9IDA7XHJcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0WCA9IHg7XHJcbiAgICAgICAgICAgIHdoaWxlIChyZW1haW5pbmdOb2Rlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBuZXh0Tm9kZXMgPSBbXTtcclxuICAgICAgICAgICAgICAgIHJlbWFpbmluZ05vZGVzLmZvckVhY2goKG5vZGUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlLnggPSB4O1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuZHggPSBub2RlV2lkdGg7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEhlcmUgd2UgYXJlIGdvaW5nIHRvIHVzZSBpdmVyc2UgZGlyZWN0aW9uIHRvIG1ha2Ugbm9kZXMgY2xvc2VyIHRvIHRoZWlyIHRhcmdldHNcclxuICAgICAgICAgICAgICAgICAgICAvLyBzbyB3ZSBwYXNzIHRhcmdldExpbmtzIGluc3RlYWQgb2Ygc291cmNlTGlua3NcclxuICAgICAgICAgICAgICAgICAgICBnZXRMaW5rcyhub2RlLnRhcmdldExpbmtzKS5mb3JFYWNoKChsaW5rKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0Tm9kZXMuaW5kZXhPZihsaW5rLnNvdXJjZSkgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZXMucHVzaChsaW5rLnNvdXJjZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmVtYWluaW5nTm9kZXMgPSBuZXh0Tm9kZXM7XHJcbiAgICAgICAgICAgICAgICArK3g7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZ3JvdXAuYnJlYWR0aCA9IHggLSBzdGFydFg7XHJcblxyXG4gICAgICAgICAgICAvLyBSZXZlcnQgZGlyZWN0aW9uIGJhY2tcclxuICAgICAgICAgICAgZ3JvdXAubm9kZXMuZm9yRWFjaChub2RlID0+IHtcclxuICAgICAgICAgICAgICAgIG5vZGUueCA9IHN0YXJ0WCArICh4IC0gMSkgLSBub2RlLng7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0TGlua3MgKGxpbmtzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbGlua3MuZmlsdGVyKGwgPT4gbm9kZXNPZkdycG91cFtsLnNvdXJjZS5pZF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgbGV0IGN1clhQb3NpdGlvbiA9IDA7XHJcbiAgICAgICAgZ3JvdXBzLmZvckVhY2goZ3JvdXAgPT4ge1xyXG4gICAgICAgICAgICBsZXQgZ3JvdXBTaXplID0gY2FsY3VsYXRlR3JvdXBXaWR0aChncm91cCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAoZ3JvdXAucHJlZmZlcmVkU2l6ZSAmJiBncm91cC5icmVhZHRoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgZ3JvdXBTaXplID0gTWF0aC5tYXgoZ3JvdXBTaXplLCBncm91cC5wcmVmZmVyZWRTaXplLndpZHRoIC8qICogbWF4SyAqLyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3Qga3ggPSBncm91cC5icmVhZHRoID4gMSA/IGdyb3VwU2l6ZSAvIChncm91cC5icmVhZHRoIC0gMSkgOiAwO1xyXG4gICAgICAgICAgICBncm91cC5ub2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgbm9kZS54ID0gY3VyWFBvc2l0aW9uICsgbm9kZS54ICoga3g7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjdXJYUG9zaXRpb24gKz0gZ3JvdXBTaXplICsgc3RlcFswXSArIG5vZGVXaWR0aDtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gY2FsY3VsYXRlR3JvdXBXaWR0aCAoZ3JvdXApIHtcclxuICAgICAgICAgICAgcmV0dXJuIChncm91cC5icmVhZHRoIC0gMSkgKiAoc3RlcFswXSArIG5vZGVXaWR0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNvbXB1dGVIZWlnaHQgKG5vZGVzQnlCcmVhZHRoKSB7XHJcbiAgICAgICAgdmFyIG1heENvbHVtbkhlaWdodCA9IDA7XHJcbiAgICAgICAgbm9kZXNCeUJyZWFkdGguZm9yRWFjaChmdW5jdGlvbiAobm9kZXMpIHtcclxuICAgICAgICAgICAgbWF4Q29sdW1uSGVpZ2h0ID0gTWF0aC5tYXgobWF4Q29sdW1uSGVpZ2h0LCBub2Rlcy5sZW5ndGgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHNpemVbMV0gPSAobWF4Q29sdW1uSGVpZ2h0KSAqIG5vZGVIZWlnaHQgKyAobWF4Q29sdW1uSGVpZ2h0IC0gMSkgKiBzdGVwWzFdO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNvbXB1dGVOb2RlRGVwdGhzIChpdGVyYXRpb25zKSB7XHJcbiAgICAgICAgdmFyIG5vZGVzQnlCcmVhZHRoID0gdXRpbHMubmVzdCgpXHJcbiAgICAgICAgICAgIC5rZXkoZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkLng7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5zb3J0S2V5cyhmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiBhID49IGIgPyAwIDogTmFOO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuZW50cmllcyhub2RlcylcclxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGQudmFsdWVzO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgY29tcHV0ZUhlaWdodChub2Rlc0J5QnJlYWR0aCk7XHJcblxyXG4gICAgICAgIGluaXRpYWxpemVOb2RlRGVwdGgoKTtcclxuICAgICAgICByZXNvbHZlQ29sbGlzaW9ucygpO1xyXG4gICAgICAgIGZvciAodmFyIGFscGhhID0gMTsgaXRlcmF0aW9ucyA+IDA7IC0taXRlcmF0aW9ucykge1xyXG4gICAgICAgICAgICByZWxheFJpZ2h0VG9MZWZ0KGFscGhhICo9IC45OSk7XHJcbiAgICAgICAgICAgIHJlc29sdmVDb2xsaXNpb25zKCk7XHJcbiAgICAgICAgICAgIHJlbGF4TGVmdFRvUmlnaHQoYWxwaGEpO1xyXG4gICAgICAgICAgICByZXNvbHZlQ29sbGlzaW9ucygpO1xyXG4gICAgICAgICAgICBpZiAoc2F2ZU9yZGVyKSByZXN0b3JlT3JkZXIoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmxvb3JUb01vZHVsZSgpO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBpbml0aWFsaXplTm9kZURlcHRoICgpIHtcclxuICAgICAgICAgICAgdmFyIGt5ID0gdXRpbHMubWluKG5vZGVzQnlCcmVhZHRoLCBmdW5jdGlvbiAobm9kZXMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoc2l6ZVsxXSAtIChub2Rlcy5sZW5ndGggLSAxKSAqIG5vZGVIZWlnaHQpIC8gdXRpbHMuc3VtKG5vZGVzLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgbm9kZXNCeUJyZWFkdGguZm9yRWFjaChmdW5jdGlvbiAobm9kZXMpIHtcclxuICAgICAgICAgICAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUsIGkpIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlLnkgPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuZHkgPSBub2RlLnZhbHVlICoga3k7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBsaW5rcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5rKSB7XHJcbiAgICAgICAgICAgICAgICBsaW5rLmR5ID0gbGluay52YWx1ZSAqIGt5O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHJlbGF4TGVmdFRvUmlnaHQgKGFscGhhKSB7XHJcbiAgICAgICAgICAgIG5vZGVzQnlCcmVhZHRoLmZvckVhY2goZnVuY3Rpb24gKG5vZGVzKSB7XHJcbiAgICAgICAgICAgICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUudGFyZ2V0TGlua3MubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB5ID0gdXRpbHMuc3VtKG5vZGUudGFyZ2V0TGlua3MsIHdlaWdodGVkU291cmNlKSAvIHV0aWxzLnN1bShub2RlLnRhcmdldExpbmtzLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUueSArPSAoeSAtIGNlbnRlcihub2RlKSkgKiBhbHBoYTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiB3ZWlnaHRlZFNvdXJjZSAobGluaykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNlbnRlcihsaW5rLnNvdXJjZSkgKiBsaW5rLnZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiByZWxheFJpZ2h0VG9MZWZ0IChhbHBoYSkge1xyXG4gICAgICAgICAgICBub2Rlc0J5QnJlYWR0aC5zbGljZSgpLnJldmVyc2UoKS5mb3JFYWNoKGZ1bmN0aW9uIChub2Rlcykge1xyXG4gICAgICAgICAgICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLnNvdXJjZUxpbmtzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeSA9IHV0aWxzLnN1bShub2RlLnNvdXJjZUxpbmtzLCB3ZWlnaHRlZFRhcmdldCkgLyB1dGlscy5zdW0obm9kZS5zb3VyY2VMaW5rcywgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnkgKz0gKHkgLSBjZW50ZXIobm9kZSkpICogYWxwaGE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gd2VpZ2h0ZWRUYXJnZXQgKGxpbmspIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjZW50ZXIobGluay50YXJnZXQpICogbGluay52YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gZmxvb3JUb01vZHVsZSAoKSB7XHJcbiAgICAgICAgICAgIG5vZGVzQnlCcmVhZHRoLmZvckVhY2goZnVuY3Rpb24gKG5vZGVzKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwbGFjZU1hcCA9IHt9O1xyXG4gICAgICAgICAgICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZ1bGxTdGVwID0gKHN0ZXBbMV0gKyBub2RlSGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgeSA9IG5vZGUueSAtIG5vZGUueSAlIChmdWxsU3RlcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHBsYWNlTWFwW3ldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgKz0gZnVsbFN0ZXA7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUueSA9IHk7XHJcbiAgICAgICAgICAgICAgICAgICAgcGxhY2VNYXBbeV0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcmVzdG9yZU9yZGVyICgpIHtcclxuICAgICAgICAgICAgbm9kZXNCeUJyZWFkdGguZm9yRWFjaChmdW5jdGlvbiAobm9kZXMpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZUEgPSBub2Rlc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gaTsgaiA8IG5vZGVzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub2RlQiA9IG5vZGVzW2pdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZUEub3JkZXIgPCBub2RlQi5vcmRlciAmJiBub2RlQS55ID4gbm9kZUIueSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRlbXBZID0gbm9kZUEueTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVBLnkgPSBub2RlQi55O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZUIueSA9IHRlbXBZO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHJlc29sdmVDb2xsaXNpb25zICgpIHtcclxuICAgICAgICAgICAgbm9kZXNCeUJyZWFkdGguZm9yRWFjaChmdW5jdGlvbiAobm9kZXMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBub2RlLFxyXG4gICAgICAgICAgICAgICAgICAgIGR5LFxyXG4gICAgICAgICAgICAgICAgICAgIHkwID0gMCxcclxuICAgICAgICAgICAgICAgICAgICBuID0gbm9kZXMubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgICAgIGk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUHVzaCBhbnkgb3ZlcmxhcHBpbmcgbm9kZXMgZG93bi5cclxuICAgICAgICAgICAgICAgIG5vZGVzLnNvcnQoYXNjZW5kaW5nRGVwdGgpO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2Rlc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBkeSA9IHkwIC0gbm9kZS55O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkeSA+IDApIG5vZGUueSArPSBkeTtcclxuICAgICAgICAgICAgICAgICAgICB5MCA9IG5vZGUueSArIG5vZGUuZHkgKyBub2RlSGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBib3R0b21tb3N0IG5vZGUgZ29lcyBvdXRzaWRlIHRoZSBib3VuZHMsIHB1c2ggaXQgYmFjayB1cC5cclxuICAgICAgICAgICAgICAgIGR5ID0geTAgLSBub2RlSGVpZ2h0IC0gc2l6ZVsxXTtcclxuICAgICAgICAgICAgICAgIGlmIChkeSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB5MCA9IG5vZGUueSAtPSBkeTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUHVzaCBhbnkgb3ZlcmxhcHBpbmcgbm9kZXMgYmFjayB1cC5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSBuIC0gMjsgaSA+PSAwOyAtLWkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGVzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkeSA9IG5vZGUueSArIG5vZGUuZHkgKyBub2RlSGVpZ2h0IC0geTA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkeSA+IDApIG5vZGUueSAtPSBkeTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeTAgPSBub2RlLnk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGFzY2VuZGluZ0RlcHRoIChhLCBiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhLnkgLSBiLnk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNvbXB1dGVMaW5rRGVwdGhzICgpIHtcclxuICAgICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgICAgIG5vZGUuc291cmNlTGlua3Muc29ydChhc2NlbmRpbmdUYXJnZXREZXB0aCk7XHJcbiAgICAgICAgICAgIG5vZGUudGFyZ2V0TGlua3Muc29ydChhc2NlbmRpbmdTb3VyY2VEZXB0aCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgICAgICB2YXIgc3kgPSAwLFxyXG4gICAgICAgICAgICAgICAgdHkgPSAwO1xyXG4gICAgICAgICAgICBub2RlLnNvdXJjZUxpbmtzLmZvckVhY2goZnVuY3Rpb24gKGxpbmspIHtcclxuICAgICAgICAgICAgICAgIGxpbmsuc3kgPSBzeTtcclxuICAgICAgICAgICAgICAgIHN5ICs9IGxpbmsuZHk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBub2RlLnRhcmdldExpbmtzLmZvckVhY2goZnVuY3Rpb24gKGxpbmspIHtcclxuICAgICAgICAgICAgICAgIGxpbmsudHkgPSB0eTtcclxuICAgICAgICAgICAgICAgIHR5ICs9IGxpbmsuZHk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBhc2NlbmRpbmdTb3VyY2VEZXB0aCAoYSwgYikge1xyXG4gICAgICAgICAgICByZXR1cm4gYS5zb3VyY2UueSAtIGIuc291cmNlLnk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBhc2NlbmRpbmdUYXJnZXREZXB0aCAoYSwgYikge1xyXG4gICAgICAgICAgICByZXR1cm4gYS50YXJnZXQueSAtIGIudGFyZ2V0Lnk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNlbnRlciAobm9kZSkge1xyXG4gICAgICAgIHJldHVybiBub2RlLnkgKyBub2RlLmR5IC8gMjtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB2YWx1ZSAobGluaykge1xyXG4gICAgICAgIHJldHVybiBsaW5rLnZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBzYW5rZXk7XHJcbn07XHJcbm1vZHVsZS5leHBvcnRzID0gU2Fua2V5OyIsImltcG9ydCBUUUdyYW1VSSBmcm9tICd2aXN1YWxpemF0aW9ucy1saWJyYXJ5JztcclxuaW1wb3J0ICogYXMgam9pbnQgZnJvbSAncmFwcGlkJztcclxuaW1wb3J0ICogYXMgbGF5b3V0IGZyb20gJy4vbGF5b3V0L2xheW91dCc7XHJcbmltcG9ydCAqIGFzIGdyYXBoRWxlbWVudHMgZnJvbSAnLi9qb2ludFZpZXdzL2dyYXBoRWxlbWVudHMvZWxlbWVudHMnO1xyXG5pbXBvcnQgKiBhcyBfIGZyb20gJ2xvZGFzaCc7XHJcbmltcG9ydCBMaW5lYWdlRGlhZ3JhbSBmcm9tICcuL2pvaW50Vmlld3MvbGluZWFnZURpYWdyYW0nO1xyXG5pbXBvcnQgRGVyaXZhdGlvbk1hcCBmcm9tICcuL2pvaW50Vmlld3MvZGVyaXZhdGlvbk1hcC9kZXJpdmF0aW9uTWFwJztcclxuaW1wb3J0IEdyYXBoTWFwIGZyb20gJy4vc2lnbWFWaWV3cy9ncmFwaE1hcCc7XHJcbmltcG9ydCBCaXJkRXllIGZyb20gJy4vc2lnbWFWaWV3cy9iaXJkRXllJztcclxuaW1wb3J0IERhdGFDb250YWluZXIgZnJvbSAnLi9kYXRhL2RhdGFDb250YWluZXInO1xyXG5pbXBvcnQgU3RhdGVTdG9yYWdlIGZyb20gJy4vc3RhdGVTdG9yYWdlJztcclxuaW1wb3J0IFN1YnNjcmliYWJsZSBmcm9tICcuL3N1YnNjcmlwdGlvbkFQSS9zdWJzY3JpYmVhYmxlJztcclxuaW1wb3J0IHtcclxuICAgIERFRkFVTFRfTElOS19TVFlMRSxcclxuICAgIEZFRURfUElQRV9MSU5LX1NUWUxFLFxyXG4gICAgREVGQVVMVF9HUk9VUF9MSU5LX1NUWUxFLFxyXG59IGZyb20gJy4vZGF0YS9yZXNvdXJjZVByb3ZpZGVyJztcclxuaW1wb3J0IHtcclxuICAgIGNyZWF0ZUpvaW50Tm9kZXMsXHJcbiAgICBjcmVhdGVKb2ludExpbmtzLFxyXG4gICAgZ2V0QmFzZUVsZW1lbnQsXHJcbiAgICBjaGVja0xnUmF3RGF0YSxcclxuICAgIGRlZmVuaXRpb25Ub1B1YmxpY01vZGVsLFxyXG59IGZyb20gJy4vdXRpbHMvZGF0YVV0aWxzJztcclxuaW1wb3J0IHsgcHJvY2Vzc0RhdGEsIGNyZWF0ZUFzcGVjdFJlbGF0aW9ucyB9IGZyb20gJy4vZGF0YS9kYXRhUHJvY2Vzc2luZyc7XHJcbmltcG9ydCB7IGdldERlZmF1bHRQYXJhbWV0ZXJzU2V0IGFzIGdldERlcml2YXRpb25NYXBQYXJhbWV0ZXJTZXQgfSBmcm9tICcuL2pvaW50Vmlld3MvZGVyaXZhdGlvbk1hcC9kZXJpdmF0aW9uTWFwJztcclxuXHJcbi8qKlxyXG4gKiBDbGFzcyB3aGljaCBwcm92aWRlcyBkYXRhIGZvciB0aGUgTGluZWFnZUdyYW0uXHJcbiAqIEBpbnRlcmZhY2UgRGF0YVByb3ZpZGVyXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFRoZSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIG5vZGVzIGFuZCBsaW5rIG1vZGVscyBmb3IgdGhlIGdyYXBoLlxyXG4gKiBAZnVuY3Rpb25cclxuICogQG5hbWUgRGF0YVByb3ZpZGVyI2ZldGNoRGF0YVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFyZ2V0Tm9kZUlkXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB2aWV3RnJhbWVcclxuICogQHBhcmFtIHtzdHJpbmd9IGxpbmVhZ2VHcmFtVmlld0NsYXNzXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBkaWFncmFtVHlwZVxyXG4gICBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHtQcm9taXNlPFNlcnZlckRhdGE+fSBQcm9taXNlIHdoaWNoIHByb3ZpZGVzIGdyYXBoIGRhdGEuXHJcbiAqL1xyXG5cclxuIC8qKlxyXG4gKiBUaGUgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBub2RlcyBhbmQgbGluayBtb2RlbHMgZm9yIHRoZSBncmFwaC5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBuYW1lIERhdGFQcm92aWRlciNnZXRWaWV3RnJhbWVzXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSByZXNvdXJjZVxyXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxWaWV3RnJhbWVEZWZpbml0aW9uW10+fSBQcm9taXNlIHdoaWNoIHByb3ZpZGVzIGdyYXBoIGRhdGEuXHJcbiAqL1xyXG5cclxuIC8qKlxyXG4gKiBUaGUgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBub2RlcyBhbmQgbGluayBtb2RlbHMgZm9yIHRoZSBncmFwaC5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBuYW1lIERhdGFQcm92aWRlciNnZXRWaWV3Q2xhc3NGb3JSZXNvdXJjZVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVzb3VyY2VcclxuICogQHJldHVybnMge1Byb21pc2U8e2RhdGFQcm92aWRlcjogc3RyaW5nfT59IFByb21pc2Ugd2hpY2ggcHJvdmlkZXMgZ3JhcGggZGF0YS5cclxuICovXHJcblxyXG4gLyoqXHJcbiAqIFRoZSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIG5vZGVzIGFuZCBsaW5rIG1vZGVscyBmb3IgdGhlIGdyYXBoLlxyXG4gKiBAZnVuY3Rpb25cclxuICogQG5hbWUgRGF0YVByb3ZpZGVyI3JlbGF0aW9uSW5mb1xyXG4gKiBAcGFyYW0ge0xpbmt9IHJlbGF0aW9uXHJcbiAqIEByZXR1cm5zIHtQcm9taXNlPERlcml2YXRpb25NYXBEYXRhPn0gUHJvbWlzZSB3aGljaCBwcm92aWRlcyBncmFwaCBkYXRhLlxyXG4gKi9cclxuXHJcbiAvKipcclxuICogUmVwcmVzZW50cyBhIG5vZGUgbW9kZWwgd2hpY2ggaXMgZXh0ZW5kZWQgYnkgZGlhZ3JhbVR5cGUgZmllbGRcclxuICogQHR5cGVkZWYge09iamVjdH0gUHVibGljTm9kZU1vZGVsXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBpZFxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbGFiZWxcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHJlc291cmNlXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSByZXNvdXJjZVR5cGVcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGRpYWdyYW1UeXBlXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0eXBlSWRcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHZpZXdGcmFtZVxyXG4gKiBAcHJvcGVydHkge2FueX0gZGF0YVxyXG4qL1xyXG5cclxuIC8qKlxyXG4gKiBSZXByZXNlbnRzIGEgbGluayBtb2RlbCB3aGljaCBpcyBleHRlbmRlZCBieSBkaWFncmFtVHlwZSBmaWVsZFxyXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBQdWJsaWNMaW5rTW9kZWxcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGlkXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzb3VyY2VcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHRhcmdldFxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZGlhZ3JhbVR5cGVcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGxpbmtUeXBlXHJcbiAqIEBwcm9wZXJ0eSB7YW55fSBkYXRhXHJcbiovXHJcblxyXG4vKipcclxuICogUmVwcmVzZW50cyBhIGRhdGFQcm92aWRlciByZXNwb25zZSB3aGljaCBpbmNsdWRlc1xyXG4gKiBsaW5rcyBhbmQgbm9kZXMgZm9yIHRoZSBMaW5lYWdlR3JhbVxyXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTZXJ2ZXJEYXRhXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBkaWFncmFtVHlwZVxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZm9jdXNOb2RlIC0gSVJJIG9mIGZvY3VzTm9kZVxyXG4gKiBAcHJvcGVydHkge0xpbmtNb2RlbFtdfSBsaW5rcyAtIExpbmsgbW9kZWxzXHJcbiAqIEBwcm9wZXJ0eSB7Tm9kZU1vZGVsW119IG5vZGVzIC0gTm9kZSBtb2RlbHNcclxuKi9cclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgc3RhdGVcclxuICogQHR5cGVkZWYge09iamVjdH0gSGlzdG9yeVN0YXRlXHJcbiAqIEBwcm9wZXJ0eSB7TGlua1tdfSBsaW5rcyAtIExpbmtzXHJcbiAqIEBwcm9wZXJ0eSB7Tm9kZVtdfSBub2RlcyAtIE5vZGVzXHJcbiAqIEBwcm9wZXJ0eSB7Vmlld0ZyYW1lRGVmaW5pdGlvbltdfSB2aWV3RnJhbWVzXHJcbiAqIEBwcm9wZXJ0eSB7Tm9kZX0gZm9jdXNOb2RlIC0gRm9jdXMgbm9kZSBmb3IgdGhlIHN0YXRlXHJcbiovXHJcblxyXG4vKipcclxuICogU2l6ZVxyXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTaXplXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB3aWR0aCAtIFdpZHRoXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBoZWlnaHQgLSBIZWlnaHRcclxuKi9cclxuXHJcbi8qKlxyXG4gKiBQb2ludFxyXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBQb2ludFxyXG4gKiBAcHJvcGVydHkge251bWJlcn0geCAtIFhcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IHkgLSBZXHJcbiovXHJcblxyXG4vKipcclxuICogVmlldyBmcmFtZSBkZWZpbml0aW9uLFxyXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBWaWV3RnJhbWVEZWZpbml0aW9uXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBpZCAtIFZpZXcgZnJhbWUgaWRlbnRpZnllclxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbGFiZWwgLSBUaXRsZSBvZiB0aGUgdmlldyBmcmFtZSxcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGJvcmRlckNvbG9yIC0gQ29sb3Igb2YgdGhlIGJvcmRlclxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gYmFja2dyb3VuZENvbG9yIC0gQ29sb3Igb2YgdGhlIGJhY2tncm91bmRcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNwYWNlU2hhcmUgLSBIb3cgbXVjaCB0aGUgdmlldyBmcmFtZSB3aWxsIHRha2VcclxuICogQHByb3BlcnR5IHtib29sZWFufSBjb2xsYXBzZWQgLSBEZWZpbmUgZGVmYXVsdCBzdGF0ZVxyXG4gKiBmcm9tIHdob2xlIHNwYWNlIG9mIHRoZSBncmFwaCAoWW91IGNhbiB0YWtlIGl0IGFzIHBlcnNlbnRzIG9yIGZsZXggZ3JvdylcclxuKi9cclxuXHJcbi8qKlxyXG4gKiBMaW5rIHRvb2wgYnV0dG9uIGRlZmluaXRpb25cclxuICogQHR5cGVkZWYge09iamVjdH0gTGlua1Rvb2xCdXR0b25cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGltYWdlIC0gcGF0aCB0byBpbWFnZVxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gd2lkdGhcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IGhlaWdodFxyXG4qL1xyXG5cclxuLyoqXHJcbiAqIExpbmsgc3R5bGUgZGVmaW5pdGlvblxyXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBMaW5rU3R5bGVEZWZpbml0aW9uXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjc3NDbGFzcyAtIENTUyBjbGFzcyB3aGljaCB3aWxsIGJlIGF0dGFjaGVkIHRvIHRoZSBzdmcgY29tcG9uZW50XHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBsaW5lVHlwZSAtICdzb2xpZCcgb3IgJ2Rhc2hlZCdcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGNvbG9yIC0gQ29sb3Igb2YgdGhlIGxpbmVcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IHRoaWNrbmVzc1xyXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGhhc0Fycm93IC0gVGVsbHMgdXMgd2hldGhlciBsaW5lIGhhcyBhIHRlcm1pbmF0aW9uIGFycm93IG9yIG5vdFxyXG4gKiBAcHJvcGVydHkge0xpbmtUb29sQnV0dG9ufSB0b29sQnV0dG9uXHJcbiovXHJcblxyXG4vKipcclxuICogU2l6ZSBvZiB0aGUgbm9kZXMgb2YgdGhlIGdyYXBoIChtYXhpbXVtLCBtaW5pbXVtLCBkZWZhdWx0KVxyXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBFbGVtZW50U2l6ZVxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gd2lkdGggLSBEZWZhdWx0IHdpZHRoIG9mIHRoZSBub2Rlc1xyXG4gKiBAcHJvcGVydHkge251bWJlcn0gaGVpZ2h0IC0gRGVmYXVsdCBoZWlnaHQgb2YgdGhlIG5vZGVzXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtaW5XaWR0aCAtIE1pbmltdW0gd2lkdGggb2YgdGhlIG5vZGVzXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtYXhXaWR0aCAtIE1heGltdW0gd2lkdGggb2YgdGhlIG5vZGVzXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtaW5IZWlnaHQgLSBNaW5pbXVtIGhlaWdodCBvZiB0aGUgbm9kZXNcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IG1heEhlaWdodCAtIE1heGltdW0gaGVpZ2h0IG9mIHRoZSBub2Rlc1xyXG4qL1xyXG5cclxuLyoqXHJcbiAqIFNjYWxlIGJvdW5kcy5cclxuICogQHR5cGVkZWYge09iamVjdH0gU2NhbGVCb3VuZHNcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IG1pblxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gbWF4XHJcbiovXHJcblxyXG4vKipcclxuICogSW4gZmFjdCB0aGUgb2JqZWN0IGlzIGEgbWFwIGJldHdlZW4gY29sb3JzIGFuZCBrZXlzIChpZHMpIG9mIGVsZW1lbnRzLFxyXG4gKiBidXQgdGhlcmUgYXJlIG51bWJlciBvZiBkZWZhdWx0IGNvbG9yIGtleXMuXHJcbiAqIEB0eXBlZGVmIHtPYmplY3QuPHN0cmluZywgc3RyaW5nPn0gQ29sb3JzXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0ZXJtaW5hdGlvblRleHQgLSBDb2xvciBvZiB0aGUgdGV4dCBvbiB0ZXJtaW5hdGlvbiBub2Rlc1xyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdGV4dCAtIENvbG9yIG9mIHRoZSB0ZXh0IG9uIHRoZSBncmFwaCdzIG5vZGVzLFxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdW5rbm93biAtIENvbG9yIGZvciBub2RlcyB3aG9zZSBpZCBpcyB1bmtub3duXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBkZWZhdWx0IC0gRGVmYXVsdCBjb2xvciBmb3Igbm9kZXNcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHNlbGVjdGVkIC0gQ29sb3Igb2YgZWxlbWVudHMgd2hpY2ggYXJlIHNlbGVjdGVkXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBibHVyZWQgLSBDb2xvciBmb3IgYmx1cmVkIGVsZW1lbnRzXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBsaW5rIC0gQ29sb3IgZm9yIGxpbmtzXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0ZXJtaW5hdGlvbkxpbmsgLSBDb2xvciBmb3IgdGVybWluYXRpb24gbGlua3NcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGFzcGVjdExpbmsgLSBDb2xvciBmb3IgYXNwZWN0IGxpbmtzXHJcbiovXHJcblxyXG4vKipcclxuICogVG9vbCBidXR0b24uXHJcbiAqIEB0eXBlZGVmIHtPYmplY3R9IExpbmtUb29sQnV0dG9uXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBpbWFnZSAtIHNyYyBvciB4aHJlZiBmb3IgdG9vbCBidXR0b25cclxuICogQHByb3BlcnR5IHtudW1iZXJ9IHdpZHRoIC0gYnV0dG9uIHdpZHRoXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBoZWlnaHQgLSBidXR0b24gaGVpZ2h0XHJcbiovXHJcblxyXG4vKipcclxuICogRGVmYXVsdCBwYXJhbWV0ZXJzIHNldCBmb3IgTGluZWFnZUdyYW0uIFlvdSBjYW4gcGFzcyBhbnkgb2YgdGhlc2UgcGFyYW1ldGVycyBpbnRvIHRoZSBjb25zdHJ1Y3RvciBkdXJpbmcgdGhlIExpbmVhZ2VHcmFtIGluaXRpYWxpemF0aW9uLlxyXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBQYXJhbWV0ZXJzXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfEhUTUxFbGVtZW50fSBncmFwaFBsYWNlIC0gSWRlbnRpZmllciBvZiB0aGUgcm9vdCBodG1sIGVsZW1lbnQgZm9yIGJpbmRpbmcgZ3JhcGggb3IganVzdCByb290IEhUTUxFbGVtZW50XHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfEhUTUxFbGVtZW50fSBtYXBSb290SHRtbCAtIElkZW50aWZpZXIgb2YgdGhlIHJvb3QgaHRtbCBlbGVtZW50IGZvciBiaW5kaW5nIG1hcCBvciBqdXN0IHJvb3QgaHRtbCBlbGVtZW50XHJcbiAqIEBwcm9wZXJ0eSB7RGF0YVByb3ZpZGVyfSBkYXRhUHJvdmlkZXIgLSBGdW5jdGlvbiB0aGF0IHJlc2lldmVzIGFuZCByZXR1cm5zIGRhdGEgZm9yIHRoZSBncmFwaFxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZm9jdXNOb2RlIC0gRm9jdXMgbm9kZSBpZFxyXG4gKlxyXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBsYXVuY2hFeHRlcm5hbCAtIEl0IGNhbiBiZSBjYWxsZWQgaW4gb3JkZXIgdG8gZ2V0IG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgc29tZSBlbGVtZW50IGluIGRlcml2YXRpb24gbWFwIGFuZCBpbiBtYWluIGNsYXNzLlxyXG4gKlxyXG4gKiBAcHJvcGVydHkge0VsZW1lbnRTaXplfSBlbGVtZW50U2l6ZSAtIFNpemUgb2YgdGhlIG5vZGVzIG9mIHRoZSBncmFwaFxyXG4gKiBAcHJvcGVydHkge0VsZW1lbnRTaXplfSBvdmVyVmlld0VsZW1lbnRTaXplIC0gU2l6ZSBvZiB0aGUgbm9kZXMgb2YgdGhlIGdyYXBoIGluIE92ZXJWaWV3RnJhbWVcclxuICpcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IGxheW91dFN0ZXAgLSBEaXN0YW5jZSBiZXR3ZWVuIGVsZW1lbnRzIG9mIHRoZSBncmFwaFxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gbGF5b3V0SXRlcmF0aW9ucyAtIEhvdyBtdWNoIGl0ZXJhdGlvbnMgd2lsbCBiZSBkb25lIGR1cmluZyB0aGUgbGF5b3V0IGFsZ29yaXRobVxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gb2Zmc2V0QmV0d2Vlbkdyb3VwcyAtIEFkZGl0aW9uYWwgb2Zmc2V0IGJldHdlZW4gZ3JvdXBzIG9mIG5vZGVzICh2aWV3RnJhbWUgZ3JvdXBzKVxyXG4gKlxyXG4gKiBAcHJvcGVydHkge0NvbG9yc30gY29sb3JzIC0gQ29sb3IgbWFwXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gYW5pbWF0aW9uIC0gSWYgaXQncyB0cnVlLCB0aGUgYW5pbWF0aW9uIGlzIGFsbG93ZWQuIEJ5IGRlZmF1bHQgLSB0cnVlXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtYXhGcmFtZVJhdGUgLSBNYXhpbXVtIHNwZWVkIG9mIGFuaW1hdGlvbi4gQnkgZGVmYXVsIC0gNTAgZnJhbWVzIHBlciBzZWNvbmRcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IG1pbkZyYW1lUmF0ZSAtIE1pbmltdW0gc3BlZWQgb2YgYW5pbWF0aW9uLiBCeSBkZWZhdWwgLSAxMCBmcmFtZXMgcGVyIHNlY29uZFxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gYW5pbWF0aW9uU3RlcCAtIEhvdyBmYXIgdmlld0ZyYW1lIHBvc2l0aW9uIGlzIGNoYW5naW5nIHBlciBhbmltYXRpb24gZnJhbWVcclxuICpcclxuICogQHByb3BlcnR5IHtWaWV3RnJhbWVEZWZpbml0aW9uW119IC0gVmlldyBmcmFtZXMgZGVmaW5pdGlvblxyXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGZ1bGxTY3JlZW5Nb2RlIC0gRGVmaW5lcyB3aGV0aGVyIHdlIHdhbnQgdG8gb3BlbiBMRyBpbiBmdWxsLXNjcmVlbi1tb2RlIG9yIGluIHRoZSByZWd1bGFyIG1vZGVcclxuICpcclxuICogQHByb3BlcnR5IHtPYmplY3QuPHN0cmluZywgc3RyaW5nPn0gaW1hZ2VzIC0gTWFwIGJldHdlZW4gbm9kZSB0eXBlcyBhbmQgaW1hZ2UgdXJscy5cclxuICogQHByb3BlcnR5IHtPYmplY3QuPHN0cmluZywgc3RyaW5nPn0gaWNvbnMgLSBNYXAgYmV0d2VlbiBub2RlIHR5cGVzIGFuZCBpY29ucyAoY3NzKS5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHJlc291cmNlUGF0aCAtIFByZWZpeCBmb3IgcmVzb3VyY2VzIGxpa2UgaW1hZ2VzIChvcHRpb25hbClcclxuICogQHByb3BlcnR5IHtib29sZWFufSB1c2VQT1NURXhlY3V0b3IgLSB0byBtYWtlIGFibGUgdXNlIHBvc3QgcmVxdWVzdHMgZm9yIHNwYXJxbFByb3ZpZGVyXHJcbiAqIEBwcm9wZXJ0eSB7UG9pbnR9IGZyYW1lUGFkZGluZyAtIFZpZXdQb3J0cyBlbmFibGVkIGFyZWEgZXhwYW5kZWQgYnkgdGhpcyB2YWx1ZVxyXG4gKlxyXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGNsaXBOb2RlcyAtIFRlbGxzIHVzIGRvIG9yIG5vdCBjbGlwcGluZyBub2RlcyBieSB2aWV3RnJhbWVzXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBmcmFtZUJvcmRlcldpZHRoIC0gV2lkdGggb2YgdGhlIGZyYW1lIGJvcmRlclxyXG4gKlxyXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHNob3dDb2xsYXBzZWRGcmFtZXMgLSBUZWxscyB3aGV0aGVyIGhpZGUgb3Igc2hvdyBjb2xsYXBzZWQgdmlld0ZybWFlcyBpbiB0aGUgYm90dG9tIG9mIHRoZSBncmFwaC5cclxuICpcclxuICogQHByb3BlcnR5IHtQb2ludH0gZGVmYXVsdFNjYWxlXHJcbiAqIEBwcm9wZXJ0eSB7U2NhbGVCb3VuZHN9IHNjYWxlQm91bmRzIC0gQ29udGFpbnMgbWluaW1hbChtaW4pIGFuZCBtYXhpbXVtKG1heCkgdmFsdWVzIG9mIHRoZSBzY2FsZS5cclxuICogQHByb3BlcnR5IHtTY2FsZUJvdW5kc30gb3ZlclZpZXdTY2FsZUJvdW5kcyAtIENvbnRhaW5zIG1pbmltYWwobWluKSBhbmQgbWF4aW11bShtYXgpIHZhbHVlcyBvZiB0aGUgc2NhbGUgZm9yIE92ZXJWaWV3RnJhbWUuXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzY2FsZVN0ZXAgLSBIb3cgbXVjaCBzY2FsZSBjaGFuZ2VzIHBlciBzdGVwLlxyXG4gKlxyXG4gKiBAcHJvcGVydHkge1NpemV9IHRlcm1pbmF0aW9uTm9kZVNpemUgLSBTaXplIG9mIHRoZSB0ZXJtaW5hdGlvbiBub2Rlc1xyXG4gKiBAcHJvcGVydHkge1NpemV9IGRhdGFab25lU2l6ZSAtIFNpemUgb2Ygem9uZXMgaW4gZGF0YSBjb250YWluZXIuIFpvbmVzIGFyZSBncm91cGluZyBhbmQgc29ydGluZyBpbiBzcGVjaWFsIGFyZWFzIHRvIGltcGxlbWVudCBiaW5hcnkgc2VhcmNoaW5nXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB6b25lc0luR3JvdXAgLSBHcm91cGluZyBkYXRhIHpvbmVzIGluIGJpZ2dlciBncm91cHMgYnkgZ3JvdXBzIG9mIChmb3IgZXhhbXBsZSkgZm91clxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbGlua1JvdXRpbmcgLSBMaW5rcyByb3V0aW5nIChiYXNlZCBvbiBqb2ludGpzIHJvdXRpbmdzOiBtZXRyby9ub3JtYWwvbWFuaGF0dGFuL29ydGhvZ29uYWwpXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsIExpbmtTdHlsZURlZmluaXRpb24+fSBsaW5rU3R5bGVzIC0gTWFwIGJldHdlZW4gdGhlIGxpbmtUeXBlcyBhbmQgTGlua1N0eWxlcy5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGdyYXBoT3JpZW50YXRpb24gLSBPcmllbnRhdGlvbiBvZiB0aGUgZ3JhcGguIENhbiBiZTogJ2xlZnQtdG8tcmlnaHQnLCAncmlnaHQtdG8tbGVmdCcsICd0b3AtdG8tYm90dG9tJywgJ2JvdHRvbS10by10b3AnXHJcbiAqIEBwcm9wZXJ0eSB7RGVyaXZhdGlvbk1hcFBhcmFtZXRlcnN9IGRlcml2YXRpb25NYXAgLSBwYXJhbWV0ZXJzIHNldCBmb3IgRGVyaXZhdGlvbk1hcFxyXG4gKiBAcHJvcGVydHkge09iamVjdC48c3RyaW5nLCBib29sZWFuPn0gbWFzayAtIG1hcCBvZiBlbGVtZW50cy4gRWxlbWVudHMgaW4gdGhlIG1hc2sgd2lsbCBiZSBoaWRkZW5cclxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gZXJyb3JDYWxsQmFjayAtIGl0IGlzIGNhbGxlZCBpbiByZXNwb25zZSB0byB3YXJuaW5ncyBhbmQgZXJyb3JzXHJcbiovXHJcblxyXG4vKipcclxuICogUmV0dXJucyBkZWZhdWx0IHNldCBvZiBwYXJhbWV0ZXJzXHJcbiAqIEByZXR1cm5zIHtQYXJhbWV0ZXJzfVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldERlZmF1bHRQYXJhbWV0ZXJzU2V0ICgpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgLy8gaW5pdGlhbGl6YXRpb25cclxuICAgICAgICBncmFwaFBsYWNlOiB1bmRlZmluZWQsIC8vIElkZW50aWZpZXIgb2YgdGhlIHJvb3QgaHRtbCBlbGVtZW50IGZvciBiaW5kaW5nIGdyYXBoXHJcbiAgICAgICAgbWFwUm9vdEh0bWw6IHVuZGVmaW5lZCwgICAgIC8vIElkZW50aWZpZXIgb2YgdGhlIHJvb3QgaHRtbCBlbGVtZW50IGZvciBiaW5kaW5nIG1hcCBvciBqdXN0IHJvb3QgSFRNTEVsZW1lbnRcclxuICAgICAgICBkYXRhUHJvdmlkZXI6IHVuZGVmaW5lZCxcclxuICAgICAgICBmb2N1c05vZGU6IHVuZGVmaW5lZCxcclxuXHJcbiAgICAgICAgLy8gRWxlbWVudHNcclxuICAgICAgICBlbGVtZW50U2l6ZTogeyB3aWR0aDogMTIwLCBoZWlnaHQ6IDEyMCwgbWluV2lkdGg6IDQ1LCBtYXhXaWR0aDogNTUwLCBtaW5IZWlnaHQ6IDQ1LCBtYXhIZWlnaHQ6IDU1MCB9LCAvLyBkZWZhdWx0IGVsZW1lbnQgc2l6ZVxyXG4gICAgICAgIG92ZXJWaWV3RWxlbWVudFNpemU6IHsgd2lkdGg6IDEyMCwgaGVpZ2h0OiAxMjAsIG1pbldpZHRoOiA1LCBtYXhXaWR0aDogNTUwLCBtaW5IZWlnaHQ6IDUsIG1heEhlaWdodDogNTUwIH0sIC8vIGRlZmF1bHQgZWxlbWVudCBzaXplIGZvciB0aGUgT3ZlclZpZXdGcmFtZVxyXG5cclxuICAgICAgICAvLyBMYXlvdXRcclxuICAgICAgICBsYXlvdXRTdGVwOiB7IHg6IDIwMCwgeTogMTAwIH0sIC8vIERpc3RhbmNlIGJldHdlZW4gZWxlbWVudHMgb2YgdGhlIGdyYXBoXHJcbiAgICAgICAgbGF5b3V0SXRlcmF0aW9uczogMzIsIC8vIEhvdyBtdWNoIGl0ZXJhdGlvbnMgd2lsbCBoYXZlIGJlZW4gZG9uZSBkdXJpbmcgdGhlIGxheW91dCBhbGdvcml0aG1cclxuICAgICAgICBvZmZzZXRCZXR3ZWVuR3JvdXBzOiAxNTAsIC8vIEFkZGl0aW9uYWwgb2Zmc2V0IGJldHdlZW4gZ3JvdXBzIG9mIG5vZGVzICh2aWV3RnJhbWUgZ3JvdXBzKVxyXG5cclxuICAgICAgICAvLyBDb2xvciBzY2hlbWVcclxuICAgICAgICBjb2xvcnM6IHsgLy8gY29sb3IgbWFwXHJcbiAgICAgICAgICAgICdlZGc6RGF0YWJhc2VDb2x1bW4nOiAnIzIzYjBmNCcsXHJcbiAgICAgICAgICAgICdlZGc6U29mdHdhcmVQcm9ncmFtJzogJ2dyZWVuJyxcclxuICAgICAgICAgICAgJ2h0dHA6Ly9lZGcudG9wYnJhaWQuc29sdXRpb25zL21vZGVsL1NvZnR3YXJlUHJvZ3JhbSc6ICdncmVlbicsXHJcbiAgICAgICAgICAgICdodHRwOi8vZWRnLnRvcGJyYWlkLnNvbHV0aW9ucy9tb2RlbC9SZXBvcnQnOiAnIzIzYjBmNCcsXHJcbiAgICAgICAgICAgICdodHRwOi8vZWRnLnRvcGJyYWlkLnNvbHV0aW9ucy9tb2RlbC9SZXBvcnRDb2x1bW4nOiAnI2ZmNzQxMCcsXHJcblxyXG4gICAgICAgICAgICAndGVybWluYXRpb25UZXh0JzogJ3doaXRlJyxcclxuICAgICAgICAgICAgJ3RleHQnOiAnYmxhY2snLFxyXG4gICAgICAgICAgICAndW5rbm93bic6ICdibGFjaycsXHJcbiAgICAgICAgICAgICdkZWZhdWx0JzogJ2JsYWNrJyxcclxuICAgICAgICAgICAgJ3NlbGVjdGVkJzogJ3JlZCcsXHJcbiAgICAgICAgICAgICdibHVyZWQnOiAncmdiYSgxMDAsIDEwMCwgMTAwLCAwLjMpJyxcclxuICAgICAgICAgICAgJ3Rlcm1pbmF0aW9uTGluayc6ICcjOTA5NGE4JyxcclxuICAgICAgICAgICAgJ2FzcGVjdExpbmsnOiAncmdiYSgwLCAyNTUsIDAsIDAuNSknLFxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8vIEFuaW1hdGlvblxyXG4gICAgICAgIGFuaW1hdGlvbjogdHJ1ZSwgLy8gc3dpdGhjIG9mZi9vbiB0aGUgYW5pbWF0aW9uXHJcbiAgICAgICAgbWF4RnJhbWVSYXRlOiA1MCxcclxuICAgICAgICBtaW5GcmFtZVJhdGU6IDEwLFxyXG4gICAgICAgIGFuaW1hdGlvblN0ZXA6IDYwLFxyXG5cclxuICAgICAgICAvLyBWaWV3IGZyYW1lcyBkZWZpbml0aW9uXHJcbiAgICAgICAgZnVsbFNjcmVlbk1vZGU6IHRydWUsIC8vIERlZmluZXMgd2hldGhlciB3ZSB3YW50IHRvIG9wZW4gTEcgaW4gZnVsbC1zY3JlZW4tbW9kZSBvciBpbiB0aGUgcmVndWxhciBtb2RlXHJcbiAgICAgICAgdmlld0ZyYW1lczogW1xyXG4gICAgICAgICAgICAvLyB7XHJcbiAgICAgICAgICAgIC8vICAgICBpZDogJ2Z1bGxQYW5lbCcsIC8vIGlkZW50aWZpZXIgb2YgdGhlIGZyYW1lIG11c3QgYmUgdW5pcXVlXHJcbiAgICAgICAgICAgIC8vICAgICBsYWJlbDogJ0FsbCcsICAgLy8gbGFiZWwgaW4gdGhlIHJpZ2h0LXRvcCBjb3JuZXJcclxuICAgICAgICAgICAgLy8gICAgIGJvcmRlckNvbG9yOiAnIzIzYjBmNCcsXHJcbiAgICAgICAgICAgIC8vICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjZjRmNGZmJyxcclxuICAgICAgICAgICAgLy8gICAgIC8vIEl0IHRlbGxzIGhvdyBtdWNoIHNwYWNlIHdpbGwgdGFrZXMgdGhpcyBmcmFtZSBvbiB0aGUgcGFwZXIuXHJcbiAgICAgICAgICAgIC8vICAgICAvLyB8WzFdWyAyIF1bICAzICAgXXwgb3JcclxuICAgICAgICAgICAgLy8gICAgIC8vIHxbICA1MCAgXVsgIDUwICBdfCBvclxyXG4gICAgICAgICAgICAvLyAgICAgLy8gfFsxMF1bMTBdWzEwXVsxMF18XHJcbiAgICAgICAgICAgIC8vICAgICBzcGFjZVNoYXJlOiAxLFxyXG4gICAgICAgICAgICAvLyB9XHJcbiAgICAgICAgXSxcclxuXHJcbiAgICAgICAgLy8gSW1hZ2VzIGZvciB0eXBlc1xyXG4gICAgICAgIGltYWdlczogeyAgIC8vIG1hcCBvZiBpbWFnZXMgZm9yIHR5cGVzIG9mIGVsZW1lbnRzXHJcbiAgICAgICAgICAgICdlZGc6RGF0YWJhc2VDb2x1bW4nOiAnc3JjL3Jlc291cmNlcy9pbWFnZXMvdGFibGUucG5nJyxcclxuICAgICAgICAgICAgJ2VkZzpUYWJsZSc6ICdzcmMvcmVzb3VyY2VzL2ltYWdlcy90YWJsZS5wbmcnLFxyXG4gICAgICAgICAgICAnZWRnOlNvZnR3YXJlUHJvZ3JhbSc6ICdzcmMvcmVzb3VyY2VzL2ltYWdlcy9hcHAucG5nJyxcclxuICAgICAgICAgICAgJ2h0dHA6Ly9lZGcudG9wYnJhaWQuc29sdXRpb25zL21vZGVsL1NvZnR3YXJlUHJvZ3JhbSc6ICdzcmMvcmVzb3VyY2VzL2ltYWdlcy9hcHAucG5nJyxcclxuICAgICAgICAgICAgJ2VkZzpMaW5lYWdlTW9kZWwnOiAnc3JjL3Jlc291cmNlcy9pbWFnZXMvZm9ybS5wbmcnLFxyXG4gICAgICAgICAgICAnZWRnOlNjaGVkdWxlJzogJ3NyYy9yZXNvdXJjZXMvaW1hZ2VzL2NvbHVtbi5wbmcnLFxyXG4gICAgICAgICAgICAvLyAnbGluay1vcHRpb25zJzogJ3NyYy9yZXNvdXJjZXMvaW1hZ2VzL2Rlcml2YXRpb24tbWFwLnBuZycsXHJcbiAgICAgICAgICAgIC8vICdmZWVkLXBpcGUnOiAnc3JjL3Jlc291cmNlcy9pbWFnZXMvZmVlZC1waXBlLnBuZycsXHJcbiAgICAgICAgICAgICd1bmtub3duJzogJ3NyYy9yZXNvdXJjZXMvaW1hZ2VzL3Vua25vd24ucG5nJywgLy8gSXQgd2lsbCB3b3JrIG9ubHkgZm9yIHVua25vd24gdHlwZXNcclxuICAgICAgICB9LCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgeW91IHdhbnQgY2hhbmdlIGl0IGZvciBsb3N0IGltYWdlcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8geW91IHNob3VsZCBjaGFuZ2UgaXQgaW4gdGhlIGJvdHRvbSBvZiAnLi9qb2ludFZpZXdzL2dyYXBoRWxlbWVudHMuanMnXHJcblxyXG4gICAgICAgIHJlc291cmNlUGF0aDogJycsIC8vIHByZWZpeCBmb3IgcmVzb3VyY2VzIGxpa2UgaW1hZ2VzIChvcHRpb25hbClcclxuICAgICAgICBsYXVuY2hFeHRlcm5hbDogbnVsbCwgLy9vcHRpb25hbFxyXG4gICAgICAgIHVzZVBPU1RFeGVjdXRvcjogZmFsc2UsIC8vIHRvIG1ha2UgYWJsZSB1c2UgcG9zdCByZXF1ZXN0cyBmb3Igc3BhcnFsUHJvdmlkZXJcclxuXHJcbiAgICAgICAgLy8gQmUgY2FyZWZ1bCEgSWYgeW91IHdhbnQgdG8gY2hhbmdlIGl0LCB5b3Ugc2hvdWxkIHJlbWVtYmVyIGFib3V0IGNzcyAoLnRxX2xpbmVhZ2VfdWkgZS50LmMuKVxyXG4gICAgICAgIGZyYW1lUGFkZGluZzogeyB4OiA1NSwgeTogNTUgfSwgLy8gdmlld1BvcnRzIGVuYWJsZWQgYXJlYSBleHBhbmRlZCBieSB0aGlzIHZhbHVlXHJcblxyXG4gICAgICAgIGNsaXBOb2RlczogZmFsc2UsIC8vIHRlbGxzIHVzIGRvIG9yIG5vdCBjbGlwcGluZyBub2RlcyBieSB2aWV3RnJhbWVzLlxyXG4gICAgICAgIGZyYW1lQm9yZGVyV2lkdGg6IDMsIC8vIHN0eWxpbmdcclxuXHJcbiAgICAgICAgc2hvd0NvbGxhcHNlZEZyYW1lczogZmFsc2UsXHJcblxyXG4gICAgICAgIGRlZmF1bHRTY2FsZTogeyB4OiAxLjAsIHk6IDEuMCB9LCAvLyBJdCdzIG5lY2Vzc2FyeSBmb3IgY2FsY3VsYXRpb25zXHJcbiAgICAgICAgc2NhbGVCb3VuZHM6IHsgbWluOiAwLjcsIG1heDogMS41IH0sXHJcbiAgICAgICAgb3ZlclZpZXdTY2FsZUJvdW5kczogeyBtaW46IDAuMDEsIG1heDogMiB9LCAvLyBzY2FsZSBib3VuZHMgZm9yIG92ZXJWaWV3IGZyYW1lXHJcbiAgICAgICAgc2NhbGVTdGVwOiAwLjEsIC8vIHN0ZXAgb2Ygc2NhbGUgY2hhbmdpbmdcclxuXHJcbiAgICAgICAgdGVybWluYXRpb25Ob2RlU2l6ZTogeyB3aWR0aDogMzAsIGhlaWdodDogMzAgfSwgLy8gc2l6ZSBvZiB0aGUgdGVybWluYXRpb24gbm9kZXNcclxuICAgICAgICBkYXRhWm9uZVNpemU6IHsgd2lkdGg6IDgwMCwgaGVpZ2h0OiA2MDAgfSwgICAgICAvLyBzaXplIG9mIHpvbmVzIGluIGRhdGEgY29udGFpbmVyLiBab25lcyBhcmUgZ3JvdXBpbmcgYW5kIHNvcnRpbmcgaW4gc3BlY2lhbCBhcmVhcyB0byBpbXBsZW1lbnQgYmluYXJ5IHNlYXJjaGluZ1xyXG4gICAgICAgIHpvbmVzSW5Hcm91cDogNCwgIC8vIGdyb3VwaW5nIGRhdGEgem9uZXMgaW4gYmlnZ2VyIGdyb3VwcyBieSBncm91cHMgb2YgKGZvciBleGFtcGxlKSBmb3VyXHJcbiAgICAgICAgbGlua1JvdXRpbmc6ICdtZXRybycsIC8vIGxpbmtzIHJvdXRpbmcgKGJhc2VkIG9uIGpvaW50anMgcm91dGluZ3M6IG1ldHJvL25vcm1hbC9tYW5oYXR0YW4vb3J0aG9nb25hbClcclxuXHJcbiAgICAgICAgbGlua1N0eWxlczoge1xyXG4gICAgICAgICAgICAnZGVmYXVsdC1saW5rLXN0eWxlJzogREVGQVVMVF9MSU5LX1NUWUxFLFxyXG4gICAgICAgICAgICAnZmVlZHBpcGUnOiBGRUVEX1BJUEVfTElOS19TVFlMRSxcclxuICAgICAgICAgICAgJ3RxLWxnLWdyb3VwJzogREVGQVVMVF9HUk9VUF9MSU5LX1NUWUxFLFxyXG4gICAgICAgICAgICAvLyBFeGFtcGxlOlxyXG4gICAgICAgICAgICAvLyAnZmVlZHBpcGUnOiB7XHJcbiAgICAgICAgICAgIC8vICAgICBjc3NDbGFzczogJ2xpbmVhZ2UtZ3JhbS1mZWVkLXBpcGUtbGluaycsXHJcbiAgICAgICAgICAgIC8vICAgICBsaW5lVHlwZTogJ3NvbGlkJywgLy8gJ2Rhc2hlZCdcclxuICAgICAgICAgICAgLy8gICAgIGNvbG9yOiAnIzNjNDI2MCcsXHJcbiAgICAgICAgICAgIC8vICAgICB0b29sQnV0dG9uOiB7XHJcbiAgICAgICAgICAgIC8vICAgICAgICAgaW1hZ2U6ICdzcmMvcmVzb3VyY2VzL2ltYWdlcy9mZWVkLXBpcGUucG5nJyxcclxuICAgICAgICAgICAgLy8gICAgICAgICB3aWR0aDogMzAsXHJcbiAgICAgICAgICAgIC8vICAgICAgICAgaGVpZ2h0OiAzMCxcclxuICAgICAgICAgICAgLy8gICAgICAgICBhbHdheXNWaXNpYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAvLyAgICAgfSxcclxuICAgICAgICAgICAgLy8gICAgIHRoaWNrbmVzczogMyxcclxuICAgICAgICAgICAgLy8gICAgIGhhc0Fycm93OiB0cnVlLFxyXG4gICAgICAgICAgICAvLyB9LFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGlhZ3JhbVR5cGU6IHVuZGVmaW5lZCxcclxuICAgICAgICBncmFwaE9yaWVudGF0aW9uOiAnbGVmdC10by1yaWdodCcsIC8vIENhbiBiZTogJ2xlZnQtdG8tcmlnaHQnLCAncmlnaHQtdG8tbGVmdCcsICd0b3AtdG8tYm90dG9tJywgJ2JvdHRvbS10by10b3AnXHJcbiAgICAgICAgbGF5b3V0QWxnb3JpdGhtOiAnc2Fua2V5JywgLy8gQ2FuIGJlOiAnc2Fua2V5JywgJ2Zsb3ctZGlyZWN0ZWQnXHJcbiAgICAgICAgZGVyaXZhdGlvbk1hcDogZ2V0RGVyaXZhdGlvbk1hcFBhcmFtZXRlclNldCgpLFxyXG4gICAgICAgIG1hc2s6IHVuZGVmaW5lZCwgLy8gTWFwIG9mIGVsZW1lbnRzLiBFbGVtZW50cyBpbiB0aGUgbWFzayB3aWxsIGJlIGhpZGRlblxyXG5cclxuICAgICAgICBlcnJvckNhbGxCYWNrOiB1bmRlZmluZWQsIC8vIEl0IGlzIGNhbGxlZCBpbiByZXNwb25zZSB0byB3YXJuaW5ncyBhbmQgZXJyb3JzXHJcbiAgICB9O1xyXG59XHJcblxyXG4vKipcclxuICogVGhlIG1haW4gY2xhc3Mgb2YgdGhlIGxpYnJhcnksIHRoYXQgbWFuYWdlIGFsbCB2aWV3cyBhbmQgZGF0YS5cclxuICogQ3JlYXRlcyB0d28gdmlldyBvbiB0aGUgaW5pdGlhbGl6YXRpb24gc3RhZ2UuIFRoZSBmaXJzdCB2aWV3IGlzIGEgTGluZWFnZSBkaWFncmFtIHZpZXcuXHJcbiAqIFRoZSBzZWNvbmQgdmlldyBpcyBhIEJpcmQgRXllIHZpZXcuIEFsc28gdGhlIG1hcCBjYW4gYmUgcGxhY2VkIG9uIHRoZSBwYWdlIGlmIHRoZSBtYXBSb290SHRtbElkXHJcbiAqIHdhcyBzcGVjaWZpZWQgaW4gdGhlIHBhc3NlZCBwYXJhbWV0ZXJzLlxyXG4gKiBAY2xhc3NcclxuICogQGF1Z21lbnRzIFN1YnNjcmliYWJsZVxyXG4gKiBAcGFyYW0ge1BhcmFtZXRlcnN9IHBhcmFtZXRlcnMgLSBQYXJhbWV0ZXJzIHNldFxyXG4gKlxyXG4gKiBAZmlyZXMgc2VsZWN0ZWQtZWxlbWVudC1jaGFuZ2VkXHJcbiAqIEBmaXJlcyBoaXN0b3J5LXN0YXRlLWNoYW5nZWRcclxuICogQGZpcmVzIGZvY3VzLW5vZGUtY2hhbmdlZFxyXG4gKiBAZmlyZXMgY3VycmVudC12aWV3LWNoYW5nZWRcclxuICogQGZpcmVzIHNjYWxlLXZhbHVlLWNoYW5nZWRcclxuICogQGZpcmVzIGRpYWdyYW0tc3RhdGUtY2hhbmdlZFxyXG4gKiBAZmlyZXMgdmlldy1mcmFtZS1zdGF0ZS1jaGFuZ2VkXHJcbiAqIEBmaXJlcyBkZXJpdmF0aW9uLW1hcC1zdGF0ZS1jaGFuZ2VkXHJcbiAqIEBmaXJlcyBkZXJpdmF0aW9uLW1hcC1zdGF0ZS1pbml0XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gTGluZWFnZUdyYW0gKHBhcmFtZXRlcnMpIHtcclxuICAgIC8vIEV2ZW50c1xyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRWxlbWVudCBzZWxlY3RlZCBldmVudCAtIGZpcmVzIHdoZW4gb2JqZWN0IGNoYW5nZXMgZWxlbWVudCBzZWxlY3Rpb25cclxuICAgICAqIFNlbGVjdGVkIGVsZW1lbnQgaXMgcmV0dXJuZWQgYXMgYSBwYXJhbWV0ZXIgb2YgdGhlIGV2ZW50LlxyXG4gICAgICogQGV2ZW50IHNlbGVjdGVkLWVsZW1lbnQtY2hhbmdlZFxyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqIEBwcm9wZXJ0eSB7UHVibGljTm9kZU1vZGVsfFB1YmxpY0xpbmtNb2RlbHx1bmRlZmluZWR9IGVsZW1lbnQgLSBTZWxlY3RlZEVsZW1lbnRcclxuICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJdCBmaXJlcyB3aGVuIG5ldyBlbGVtZW50IGlzIHNlbGVjdGVkIGFzIGZvY3VzTm9kZS5cclxuICAgICAqIEBldmVudCBmb2N1cy1ub2RlLWNoYW5nZWRcclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKiBAcHJvcGVydHkge1B1YmxpY05vZGVNb2RlbH0gZWxlbWVudCAtIEZvY3VzTm9kZSBtb2RlbFxyXG4gICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIFZpZXcgc3dpdGNoZWQgZXZlbnQgLSBmaXJlcyB3aGVuIGN1cnJlbnQgdmlldyBpcyBjaGFuZ2VkXHJcbiAgICAgKiBWaWV3IGlkIGlzIHJldHVybmVkIGFzIGEgcGFyYW1ldGVyIG9mIHRoZSBldmVudFxyXG4gICAgICogQGV2ZW50IGN1cnJlbnQtdmlldy1jaGFuZ2VkXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IHZpZXdJZCAtIFNlbGVjdGVkVmlldyBjYW4gdGFrZSB0aGUgZm9sbG93aW5nIHZhbHVlczogJ2xpbmVhZ2VEaWFncmFtJywgJ2JpcmRFeWUnIG9yICdub25lJ1xyXG4gICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNjYWxlIGNoYW5nZWQgZXZlbnQgLSBmaXJlcyB3aGVuIHNjYWxlIHZhbHVlIG9mIHRoZSBMaW5lYWdlIERpYWdyYW0gdmlldyBpcyBjaGFuZ2VkLlxyXG4gICAgICogW05ldyBzY2FsZSB2YWx1ZV17QGxpbmsgU2NhbGV9IGlzIHJldHVybmVkIGFzIGEgcGFyYW1ldGVyIG9mIHRoZSBldmVudFxyXG4gICAgICogQGV2ZW50IHNjYWxlLXZhbHVlLWNoYW5nZWRcclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKiBAcHJvcGVydHkge1NjYWxlfSBzY2FsZSAtIE5ldyBzY2FsZSBvYmplY3QuXHJcbiAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3RhdGUgY2hhbmdlZCBldmVudCAtIGZpcmVzIHdoZW4gTGluZWFnZUdyYW0gc3RhdGUgaXMgY2hhbmdlZC5cclxuICAgICAqIEUuZy4gZnJvbSBhIGZldGNoaW5nIHN0YXRlIHRvIGEgcmVuZGVyaW5nIHN0YXRlLlxyXG4gICAgICogVGhlIHN0YXRlIHN0cmluZyBpZGVudGlmaWVyIGlzIHJldHVybmVkIGFzIGEgcGFyYW1ldGVyIG9mIHRoZSBldmVudFxyXG4gICAgICogQGV2ZW50IGRpYWdyYW0tc3RhdGUtY2hhbmdlZFxyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzdGF0ZSAtIFBhcmFtZXRlciBjYW4gdGFrZSB0aGUgZm9sbG93aW5nIHZhbHVlczogJ2ZldGNoaW5nJyB8ICdyZW5kZXJpbmcnIHwgJ2NvbXBsZXRlZCcgfCAnZXJyb3InXHJcbiAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSXQgZmlyZXMgd2hlbiB1c2VyIGlzIG5hdmlnYXRpbmcgYWxvbmcgdGhlIGhpc3RvcnkuXHJcbiAgICAgKiBAZXZlbnQgaGlzdG9yeS1zdGF0ZS1jaGFuZ2VkXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICogQHByb3BlcnR5IHtIaXN0b3J5U3RhdGVbXX0gc3RhdGVzIC0gTGlzdCBvZiBzdGF0ZXNcclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjdXJyZW50SW5kZXggLSBvcmRlciBudW1iZXIgb2YgdGhlIGN1cnJlbnQgc3RhdGUgaW4gdGhlIGxpc3RcclxuICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBWaWV3IGZyYW1lIHN0YXRlIGNoYW5nZWQgLSBmaXJlcyB3aGVuIHRoZSBWaWV3IGZyYW1lIGlzIGJlaW5nIGNvbGxhcHNlZCBvciBleHBhbmRlZC5cclxuICAgICAqIEBldmVudCB2aWV3LWZyYW1lLXN0YXRlLWNoYW5nZWRcclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gaWQgLSBpZCBvZiB0aGUgY2hhbmdlZCBWaWV3RnJhbWVcclxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gdmFsdWUgLSB0cnVlIC0gZXhwYW5kZWQsIGZhbHNlIC0gY29sbGFwc2VkXHJcbiAgICAqL1xyXG5cclxuICAgIC8vIEluaXRcclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIFN1YnNjcmliYWJsZS5hcHBseSh0aGlzKTsgICAvLyBtYWtlIHRoaXMgY2xhc3MgU3Vic2NyaWJhYmxlXHJcblxyXG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7IC8vIFNhdmUgcG9pbnRlciB0byBhIGNvbnRleHRcclxuXHJcbiAgICBsZXQgX3N0YXRlID0gJ2luaXRpYWwnO1xyXG4gICAgbGV0IF9zZWxlY3RlZEVsZW1lbnQgPSBudWxsO1xyXG4gICAgbGV0IF9mb2N1c0VsZW1lbnQ7XHJcbiAgICBsZXQgX2N1cnJlbnRWaWV3ID0gJ2xpbmVhZ2VEaWFncmFtJzsgICAgLy8gU2V0IHRoZSBsaW5lYWdlRGlhZ3JhbSB2aWV3IGFzIGEgY3VycmVudCB2aWV3XHJcblxyXG5cclxuICAgIGNvbnN0IGRlZmF1bHRQYXJhbWV0ZXJTZXQgPSBnZXREZWZhdWx0UGFyYW1ldGVyc1NldCgpOyAvLyBHZXRpbmcgZGVmYXVsdCBwYXJhbWV0ZXJzIHNldFxyXG4gICAgLy8gSWYgdGhlIHBhcmFtZXRlciBzZXQgaW5jbHVkZXMgdmlld0ZyYW1lcyBkZWZpbml0aW9uLCBjbGVhciB0aGUgdmlld0ZyYW1lcyBkZWZpbml0aW9uIGluIHRoZSBkZWZhdWx0IHNldCBmb3IgYSBjb3JyZWN0IG1lcmdpbmdcclxuICAgIC8vIChXZSBkb24ndCB3YW50IHRvIGdldCBleHRyYSB2aWV3RnJhbWVzIGZyb20gdGhlIGRlZmF1bHQgc2V0LilcclxuICAgIGlmIChwYXJhbWV0ZXJzICYmIHBhcmFtZXRlcnMudmlld0ZyYW1lcyAmJiBwYXJhbWV0ZXJzLnZpZXdGcmFtZXMubGVuZ3RoID4gMCkgZGVmYXVsdFBhcmFtZXRlclNldC52aWV3RnJhbWVzID0gdW5kZWZpbmVkO1xyXG4gICAgLy8gTWVyZ2luZyBkZWZhdWx0IHBhcmFtZXRlcnMgc2V0IGFuZCBjdXN0b21lIHBhcmFtZXRlcnMgc2V0XHJcbiAgICBjb25zdCBfcGFyYW1ldGVycyA9ICBfLm1lcmdlKGRlZmF1bHRQYXJhbWV0ZXJTZXQsIHBhcmFtZXRlcnMpO1xyXG5cclxuICAgIGNvbnN0IF9lcnJvckNhbGxiYWNrID0gKGUpID0+IHtcclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgIF9wYXJhbWV0ZXJzLmVycm9yQ2FsbGJhY2sgJiZcclxuICAgICAgICAgICAgX3BhcmFtZXRlcnMuZXJyb3JDYWxsYmFjayBpbnN0YW5jZW9mIEZ1bmN0aW9uXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gdHlwZW9mIGUgPT09ICdzdHJpbmcnID8gbmV3IEVycm9yKGUpIDogZTtcclxuICAgICAgICAgICAgX3BhcmFtZXRlcnMuZXJyb3JDYWxsYmFjay5jYWxsKHRoaXMsIGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIElmIHRoZSBncmFwaFBsYWNlIGlzIHVuZGVmaW5lZCB3ZSBzdG9wIHRoZSB3b3JraW5nIHByb2Nlc3MuXHJcbiAgICBpZiAoIXBhcmFtZXRlcnMuZ3JhcGhQbGFjZSkgdGhyb3cgbmV3IEVycm9yKCdUaGUgZ3JhcGggcGxhY2UgaXNuXFwndCBzcGVjaWZpZWQnKTtcclxuICAgIGxldCBncmFwaFBsYWNlSHRtbDtcclxuICAgIGlmICh0eXBlb2YgcGFyYW1ldGVycy5ncmFwaFBsYWNlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIGdyYXBoUGxhY2VIdG1sID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQocGFyYW1ldGVycy5ncmFwaFBsYWNlKTtcclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHBhcmFtZXRlcnMuZ3JhcGhQbGFjZSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICBncmFwaFBsYWNlSHRtbCA9IHBhcmFtZXRlcnMuZ3JhcGhQbGFjZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgZ3JhcGggcGxhY2UgaXNuXFwndCBzcGVjaWZpZWQgb3Igc3BlY2lkZWQgaW5jb3JyZWN0bHknKTtcclxuICAgIH1cclxuICAgIC8vIENyZWF0aW5nIGh0bWwgbWFya3VwLlxyXG4gICAgY29uc3QgX2Jhc2UgPSBfY3JlYXRlQmFzZShncmFwaFBsYWNlSHRtbCk7XHJcbiAgICBjb25zdCBfZGF0YVByb3ZpZGVyID0gX3BhcmFtZXRlcnMuZGF0YVByb3ZpZGVyO1xyXG4gICAgY29uc3QgX3N0YXRlU3RvcmFnZSA9IG5ldyBTdGF0ZVN0b3JhZ2UoX3BhcmFtZXRlcnMpO1xyXG4gICAgY29uc3QgX3Byb2dyZXNzU2NyZWVuID0gbmV3IFRRR3JhbVVJLlByb2dyZXNzU2NyZWVuKHtcclxuICAgICAgICBiYXNlRWxlbWVudDogX2Jhc2UuY29udGFpbmVyLFxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gQ3JlYXRpbmcgdGhlIGRhdGEgY29udGFpbmVyLlxyXG4gICAgbGV0IF9kYXRhQ29udGFpbmVyO1xyXG5cclxuICAgIGxldCBfbGluZWFnZURpYWdyYW07IC8vIExpbmVhZ2UgZGlhZ3JhbSB2aWV3XHJcbiAgICBsZXQgX2JpcmRFeWU7IC8vIEJpcmRFeWUgYmlld1xyXG4gICAgbGV0IF9kZXJpdmF0aW9uTWFwO1xyXG4gICAgbGV0IF9ncmFwaE1hcDsgLy8gZGVmaW5lIHZhcmlhYmxlXHJcbiAgICBsZXQgX2Rlcml2YXRpb25NYXBQYW5lbDtcclxuXHJcbiAgICBsZXQgX2RpYWdyYW1UeXBlID0gX3BhcmFtZXRlcnMuZGlhZ3JhbVR5cGU7XHJcblxyXG4gICAgc2VsZi5sYXVuY2hFeHRlcm5hbCA9IF9wYXJhbWV0ZXJzLmxhdW5jaEV4dGVybmFsO1xyXG5cclxuICAgIF9jcmVhdGVDb21wb25lbnRzKCk7XHJcblxyXG4gICAgX2ZldGNoRGlhZ3JhbSh7XHJcbiAgICAgICAgZm9jdXNOb2RlSWQ6IF9wYXJhbWV0ZXJzLmZvY3VzTm9kZSxcclxuICAgICAgICB2aWV3RnJhbWVzOiBfcGFyYW1ldGVycy52aWV3RnJhbWVzLFxyXG4gICAgICAgIGxpbmVhZ2VHcmFtVmlld0NsYXNzOiBfcGFyYW1ldGVycy5saW5lYWdlR3JhbVZpZXdDbGFzcyxcclxuICAgICAgICBkaWFncmFtVHlwZTogX2RpYWdyYW1UeXBlLFxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVjb3ZlcnMgbm9kZXMgcG9zaXRpb25zIHRvIHRoZSBpbml0aWFsLlxyXG4gICAgICogQG1lbWJlcm9mIExpbmVhZ2VHcmFtXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKi9cclxuICAgIHNlbGYucmVzZXRMYXlvdXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKF9zdGF0ZSAhPT0gJ2NvbXBsZXRlZCcpIHJldHVybjtcclxuICAgICAgICBfbGluZWFnZURpYWdyYW0ucmVzZXRMYXlvdXQoKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBTY2FsZVxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG1pbiAtIFRoZSBtaW5pbXVtIHZhbHVlXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbWF4IC0gVGhlIG1heGltdW0gdmFsdWVcclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjdXIgLSBUaGUgY3VycmVudCB2YWx1ZVxyXG4gICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIENoYW5nZXMgc2NhbGUgb2YgdGhlIG1haW4gdmlldyBieSB0aGUgc3RlcCAoZGVmYXVsOiArKzAuMSkuXHJcbiAgICAgKiBAcmV0dXJucyB7U2NhbGV9XHJcbiAgICAgKiBAbWVtYmVyb2YgTGluZWFnZUdyYW1cclxuICAgICAqIEBtZXRob2RcclxuICAgICAqL1xyXG4gICAgc2VsZi56b29tSW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKF9zdGF0ZSA9PT0gJ2NvbXBsZXRlZCcpIHtcclxuICAgICAgICAgICAgX2xpbmVhZ2VEaWFncmFtLnpvb21JbigpO1xyXG4gICAgICAgICAgICBpZiAoX2dyYXBoTWFwKSBfZ3JhcGhNYXAucmVkcmF3KHsgdmlld0ZyYW1lczogX2xpbmVhZ2VEaWFncmFtLmdldFZpZXdGcmFtZXMoKSB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgbWluOiBfcGFyYW1ldGVycy5zY2FsZUJvdW5kcy5taW4sXHJcbiAgICAgICAgICAgIG1heDogX3BhcmFtZXRlcnMuc2NhbGVCb3VuZHMubWF4LFxyXG4gICAgICAgICAgICBjdXI6IF9zdGF0ZSA9PT0gJ2NvbXBsZXRlZCcgPyBfbGluZWFnZURpYWdyYW0uc2NhbGUoKSA6IF9wYXJhbWV0ZXJzLmRlZmF1bHRTY2FsZSxcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENoYW5nZXMgc2NhbGUgb2YgdGhlIG1haW4gdmlldyB0byBiZSBhYmxlIHRvIGZpdCB3aG9sZSBkaWFncmFtIGluIHRoZSBzY3JlZW4uXHJcbiAgICAgKiBAcmV0dXJucyB7U2NhbGV9XHJcbiAgICAgKiBAbWVtYmVyb2YgTGluZWFnZUdyYW1cclxuICAgICAqIEBtZXRob2RcclxuICAgICAqL1xyXG4gICAgc2VsZi56b29tVG9GaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKF9zdGF0ZSA9PT0gJ2NvbXBsZXRlZCcpIHtcclxuICAgICAgICAgICAgX3pvb21Ub0ZpdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBtaW46IF9wYXJhbWV0ZXJzLnNjYWxlQm91bmRzLm1pbixcclxuICAgICAgICAgICAgbWF4OiBfcGFyYW1ldGVycy5zY2FsZUJvdW5kcy5tYXgsXHJcbiAgICAgICAgICAgIGN1cjogX3N0YXRlID09PSAnY29tcGxldGVkJyA/IF9saW5lYWdlRGlhZ3JhbS5zY2FsZSgpIDogX3BhcmFtZXRlcnMuZGVmYXVsdFNjYWxlLFxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBjdXJyZW50IHZpZXcgaWRcclxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gY3VycmVudFZpZXdJZCAtJ2xpbmVhZ2VEaWFncmFtJyB8ICdiaXJkRXllJyB8ICdub25lJ1xyXG4gICAgICogQG1lbWJlcm9mIExpbmVhZ2VHcmFtXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKi9cclxuICAgIHNlbGYuZ2V0Q3VycmVudFZpZXcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9jdXJyZW50VmlldztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGN1cnJlbnQgc3RhdGVcclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHN0YXRlIC0gJ2ZldGNoaW5nJyB8ICdhY3RpdmUnIHwgJ2NvbXBsZXRlZCcgfCAnZXJyb3InXHJcbiAgICAgKiBAbWVtYmVyb2YgTGluZWFnZUdyYW1cclxuICAgICAqIEBtZXRob2RcclxuICAgICAqL1xyXG4gICAgc2VsZi5nZXRTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX3N0YXRlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENoYW5nZXMgc2NhbGUgb2YgdGhlIG1haW4gdmlldyBieSB0aGUgc3RlcCAoZGVmYXVsOiAtLTAuMSkuXHJcbiAgICAgKiBAcmV0dXJucyB7U2NhbGV9XHJcbiAgICAgKiBAbWVtYmVyb2YgTGluZWFnZUdyYW1cclxuICAgICAqIEBtZXRob2RcclxuICAgICAqL1xyXG4gICAgc2VsZi56b29tT3V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChfc3RhdGUgPT09ICdjb21wbGV0ZWQnKSB7XHJcbiAgICAgICAgICAgIF9saW5lYWdlRGlhZ3JhbS56b29tT3V0KCk7XHJcbiAgICAgICAgICAgIGlmIChfZ3JhcGhNYXApIF9ncmFwaE1hcC5yZWRyYXcoeyB2aWV3RnJhbWVzOiBfbGluZWFnZURpYWdyYW0uZ2V0Vmlld0ZyYW1lcygpIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBtaW46IF9wYXJhbWV0ZXJzLnNjYWxlQm91bmRzLm1pbixcclxuICAgICAgICAgICAgbWF4OiBfcGFyYW1ldGVycy5zY2FsZUJvdW5kcy5tYXgsXHJcbiAgICAgICAgICAgIGN1cjogX3N0YXRlID09PSAnY29tcGxldGVkJyA/IF9saW5lYWdlRGlhZ3JhbS5zY2FsZSgpIDogX3BhcmFtZXRlcnMuZGVmYXVsdFNjYWxlLFxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hhbmdlcyBzY2FsZSBvZiB0aGUgbWFpbiBMaW5lYWdlIERpYWdyYW0gdmlldy5cclxuICAgICAqIEBwYXJhbSB7UG9pbnR9IHNjYWxlXHJcbiAgICAgKiBAcmV0dXJucyB7U2NhbGV9XHJcbiAgICAgKiBAbWVtYmVyb2YgTGluZWFnZUdyYW1cclxuICAgICAqIEBtZXRob2RcclxuICAgICAqL1xyXG4gICAgc2VsZi56b29tID0gZnVuY3Rpb24gem9vbSAoc2NhbGUpIHtcclxuICAgICAgICBpZiAoX3N0YXRlID09PSAnY29tcGxldGVkJykge1xyXG4gICAgICAgICAgICBpZiAoc2NhbGUpIHtcclxuICAgICAgICAgICAgICAgIF9saW5lYWdlRGlhZ3JhbS5zY2FsZShzY2FsZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgX2xpbmVhZ2VEaWFncmFtLnJlZHJhdygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBtaW46IF9wYXJhbWV0ZXJzLnNjYWxlQm91bmRzLm1pbixcclxuICAgICAgICAgICAgbWF4OiBfcGFyYW1ldGVycy5zY2FsZUJvdW5kcy5tYXgsXHJcbiAgICAgICAgICAgIGN1cjogX3N0YXRlID09PSAnY29tcGxldGVkJyA/IF9saW5lYWdlRGlhZ3JhbS5zY2FsZSgpIDogX3BhcmFtZXRlcnMuZGVmYXVsdFNjYWxlLFxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogT2JqZWN0IHdoaWNoIHBhc3NlZCBpbnRvIHRoZSBleHBvcnQgZnVuY3Rpb24gaW4gTGluZWFnZUdyYW1cclxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IEV4cG9ydFBhcmFtc1xyXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWUgLSBUaGUgZmlsZSBuYW1lXHJcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gdHlwZSAtIChwbmcvc3ZnKVxyXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IHZpZXcgLSBCaXJkRXllIC8gbGluZWFnZUdyYW1cclxuICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFeHBvcnRzIHRoZSBncmFwaCBpbiBhIHBuZyBvciBzdmcgZmlsZS5cclxuICAgICAqIEBwYXJhbSB7RXhwb3J0UGFyYW1zfSBvcHRpb25zXHJcbiAgICAgKiBAbWVtYmVyb2YgTGluZWFnZUdyYW1cclxuICAgICAqIEBtZXRob2RcclxuICAgICovXHJcbiAgICBzZWxmLmV4cG9ydCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKF9zdGF0ZSAhPT0gJ2NvbXBsZXRlZCcpIHJldHVybjtcclxuXHJcbiAgICAgICAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XHJcbiAgICAgICAgb3B0aW9ucy52aWV3ID0gb3B0aW9ucy52aWV3IHx8IF9jdXJyZW50VmlldztcclxuICAgICAgICBpZiAob3B0aW9ucy52aWV3ID09PSAnbGluZWFnZURpYWdyYW0nKSB7XHJcbiAgICAgICAgICAgIF9saW5lYWdlRGlhZ3JhbS5leHBvcnQoe1xyXG4gICAgICAgICAgICAgICAgbmFtZTogb3B0aW9ucy5uYW1lLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogb3B0aW9ucy50eXBlLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMudmlldyA9PT0gJ2JpcmRFeWUnKSB7XHJcbiAgICAgICAgICAgIF9iaXJkRXllLmV4cG9ydCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTaG93cyBwcmludCBkaWFsb2cuXHJcbiAgICAgKiBAbWVtYmVyb2YgTGluZWFnZUdyYW1cclxuICAgICAqIEBtZXRob2RcclxuICAgICovXHJcbiAgICBzZWxmLnByaW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChfY3VycmVudFZpZXcgPT09ICdsaW5lYWdlRGlhZ3JhbScpIHtcclxuICAgICAgICAgICAgX2xpbmVhZ2VEaWFncmFtLnByaW50KCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChfY3VycmVudFZpZXcgPT09ICdiaXJkRXllJykge1xyXG4gICAgICAgICAgICBfYmlyZEV5ZS5wcmludCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFeHBhbmRzIGFsbCBub2Rlc1xyXG4gICAgICogQG1lbWJlcm9mIExpbmVhZ2VHcmFtXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAqL1xyXG4gICAgc2VsZi5leHBhbmRBbGxOb2RlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjb25zdCBub2RlcyA9IF9kYXRhQ29udGFpbmVyLm5vZGVzO1xyXG4gICAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICAgICAgbm9kZS5zZXQoJ2V4cGFuZGVkJywgdHJ1ZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKF9jdXJyZW50VmlldyA9PT0gJ2xpbmVhZ2VEaWFncmFtJykge1xyXG4gICAgICAgICAgICBfbGluZWFnZURpYWdyYW0ucmVmcmVzaCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb2xsYXBzZXMgYWxsIG5vZGVzXHJcbiAgICAgKiBAbWVtYmVyb2YgTGluZWFnZUdyYW1cclxuICAgICAqIEBtZXRob2RcclxuICAgICovXHJcbiAgICBzZWxmLmNvbGxhcHNlQWxsTm9kZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY29uc3Qgbm9kZXMgPSBfZGF0YUNvbnRhaW5lci5ub2RlcztcclxuICAgICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgICAgIG5vZGUuc2V0KCdleHBhbmRlZCcsIGZhbHNlKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoX2N1cnJlbnRWaWV3ID09PSAnbGluZWFnZURpYWdyYW0nKSB7XHJcbiAgICAgICAgICAgIF9saW5lYWdlRGlhZ3JhbS5yZWZyZXNoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgZnVuY3Rpb24gY3JlYXRlcyBtYXAsIHVzaW5nIGh0bWwgZWxlbWVudCB3aXRoIHNwZWNpZmllZCBJRCBhcyBhIHJvb3QgZWxlbWVudC5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfEhUTUxFbGVtZW50fSBtYXBSb290SHRtbCAtIElEIG9mIHJvb3QgZWxlbWVudCBvciBIVE1MRWxlbWVudFxyXG4gICAgICogQG1lbWJlcm9mIExpbmVhZ2VHcmFtXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKi9cclxuICAgIHNlbGYuc2V0Um9vdEh0bWxGb3JNYXAgPSBmdW5jdGlvbiAobWFwUm9vdEh0bWwpIHtcclxuICAgICAgICBjb25zdCBtYXBIVE1MRWxlbWVudCA9IF9nZXRNYXBIVE1MKG1hcFJvb3RIdG1sKTtcclxuICAgICAgICBfcGFyYW1ldGVycy5tYXBSb290SHRtbCA9IG1hcFJvb3RIdG1sO1xyXG4gICAgICAgIF9iYXNlLm1hcEhUTUxFbGVtZW50ID0gbWFwSFRNTEVsZW1lbnQ7XHJcblxyXG4gICAgICAgIGlmIChfc3RhdGUgIT09ICdjb21wbGV0ZWQnKSByZXR1cm47XHJcblxyXG4gICAgICAgIF91cGRhdGVNYXAoX2RhdGFDb250YWluZXIsIF9saW5lYWdlRGlhZ3JhbS5nZXRWaWV3RnJhbWVzKCkpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEl0IGNoYW5nZXMgbGF5b3V0IGFsZ29yaXRobSBmb3IgdGhlIGdyYXBoLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9yaWVudGF0aW9uIC0gVmFsdWVzOiAnc2Fua2V5JywgJ2Zsb3ctZGlyZWN0ZWQnXHJcbiAgICAgKiBAbWVtYmVyb2YgTGluZWFnZUdyYW1cclxuICAgICAqIEBtZXRob2RcclxuICAgICAqL1xyXG4gICAgc2VsZi5zZXRMYXlvdXRBbGdvcml0aG0gPSBmdW5jdGlvbiAoYWxnb3JpdGhtSWQpIHtcclxuICAgICAgICBpZiAoYWxnb3JpdGhtSWQgPT09ICdzYW5rZXknIHx8IGFsZ29yaXRobUlkID09PSAnZmxvdy1kaXJlY3RlZCcpIHtcclxuICAgICAgICAgICAgX3BhcmFtZXRlcnMubGF5b3V0QWxnb3JpdGhtID0gYWxnb3JpdGhtSWQ7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBub2RlcyA9IF9kYXRhQ29udGFpbmVyLm5vZGVzLm1hcChuID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1vZGVsID0gbi5tb2RlbDtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBtb2RlbC5kZWZhdWx0UG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICBtb2RlbC52aWV3RnJhbWVPd25lcklkID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBtb2RlbDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGxpbmtzID0gX2RhdGFDb250YWluZXIubGlua3MubWFwKGwgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBpZDogbC5tb2RlbC5pZCxcclxuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IGwubW9kZWwuc291cmNlVHlwZSxcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IGwubW9kZWwudGFyZ2V0VHlwZSxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgY29uc3Qgdmlld0ZyYW1lcyA9IF9saW5lYWdlRGlhZ3JhbS5nZXRWaWV3RnJhbWVzKCk7XHJcblxyXG4gICAgICAgICAgICBsYXlvdXQuZG9MYXlvdXQoXHJcbiAgICAgICAgICAgICAgICBub2RlcyxcclxuICAgICAgICAgICAgICAgIGxpbmtzLFxyXG4gICAgICAgICAgICAgICAgdmlld0ZyYW1lcyxcclxuICAgICAgICAgICAgICAgIF9wYXJhbWV0ZXJzLFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBfZGF0YUNvbnRhaW5lci5yZWZyZXNoKCk7XHJcbiAgICAgICAgICAgIF9saW5lYWdlRGlhZ3JhbS5yZWZyZXNoKCk7XHJcbiAgICAgICAgICAgIF9iaXJkRXllLnJlZnJlc2goKTtcclxuICAgICAgICAgICAgaWYgKF9ncmFwaE1hcCkgX2dyYXBoTWFwLnJlZHJhdyh7XHJcbiAgICAgICAgICAgICAgICB2aWV3RnJhbWVzOiBfbGluZWFnZURpYWdyYW0uZ2V0Vmlld0ZyYW1lcygpLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBsYXlvdXQgYWxnb3JpdGhtIHdoaWNoIGlzIGN1cnJlbnRseSB1c2VkIGZvciBkaWFncmFtLlxyXG4gICAgICogQG1lbWJlcm9mIExpbmVhZ2VHcmFtXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSByb3V0aW5nOiBtZXRyby9ub3JtYWwvbWFuaGF0dGFuXHJcbiAgICAgKi9cclxuICAgIHNlbGYuZ2V0TGF5b3V0QWxnb3JpdGhtID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfcGFyYW1ldGVycy5sYXlvdXRBbGdvcml0aG07XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSXQgY2hhbmdlcyBvcmllbnRhdGlvbiBvZiB0aGUgZ3JhcGhcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcmllbnRhdGlvbiAtIFZhbHVlczogJ2xlZnQtdG8tcmlnaHQnLCAncmlnaHQtdG8tbGVmdCcsICd0b3AtdG8tYm90dG9tJywgJ2JvdHRvbS10by10b3AnXHJcbiAgICAgKiBAbWVtYmVyb2YgTGluZWFnZUdyYW1cclxuICAgICAqIEBtZXRob2RcclxuICAgICAqL1xyXG4gICAgc2VsZi5zZXRPcmllbnRhdGlvbiA9IGZ1bmN0aW9uIChvcmllbnRhdGlvbikge1xyXG4gICAgICAgIGlmIChfc3RhdGUgIT09ICdjb21wbGV0ZWQnKSByZXR1cm47XHJcblxyXG4gICAgICAgIGlmIChvcmllbnRhdGlvbiAmJiAoXHJcbiAgICAgICAgICAgIG9yaWVudGF0aW9uID09PSAnbGVmdC10by1yaWdodCcgfHxcclxuICAgICAgICAgICAgb3JpZW50YXRpb24gPT09ICdyaWdodC10by1sZWZ0JyB8fFxyXG4gICAgICAgICAgICBvcmllbnRhdGlvbiA9PT0gJ3RvcC10by1ib3R0b20nIHx8XHJcbiAgICAgICAgICAgIG9yaWVudGF0aW9uID09PSAnYm90dG9tLXRvLXRvcCdcclxuICAgICAgICApKSB7XHJcbiAgICAgICAgICAgIF9wYXJhbWV0ZXJzLmdyYXBoT3JpZW50YXRpb24gPSBvcmllbnRhdGlvbjtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IG5vZGVzID0gX2RhdGFDb250YWluZXIubm9kZXMubWFwKG4gPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbW9kZWwgPSBuLm1vZGVsO1xyXG4gICAgICAgICAgICAgICAgbW9kZWwuZGVmYXVsdF94ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgbW9kZWwuZGVmYXVsdF95ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgbW9kZWwudmlld0ZyYW1lT3duZXJJZCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBuLnNldE9yaWVudGF0aW9uKG9yaWVudGF0aW9uKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBtb2RlbDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGxpbmtzID0gX2RhdGFDb250YWluZXIubGlua3MubWFwKGxpbmsgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBpZDogbGluay5tb2RlbC5pZCxcclxuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IGxpbmsubW9kZWwuc291cmNlVHlwZSxcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IGxpbmsubW9kZWwudGFyZ2V0VHlwZSxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgY29uc3Qgdmlld0ZyYW1lcyA9IF9saW5lYWdlRGlhZ3JhbS5nZXRWaWV3RnJhbWVzKCk7XHJcblxyXG4gICAgICAgICAgICBsYXlvdXQuZG9MYXlvdXQoXHJcbiAgICAgICAgICAgICAgICBub2RlcyxcclxuICAgICAgICAgICAgICAgIGxpbmtzLFxyXG4gICAgICAgICAgICAgICAgdmlld0ZyYW1lcyxcclxuICAgICAgICAgICAgICAgIF9wYXJhbWV0ZXJzLFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBfZGF0YUNvbnRhaW5lci5yZWZyZXNoKCk7XHJcbiAgICAgICAgICAgIF9saW5lYWdlRGlhZ3JhbS5zZXRPcmllbnRhdGlvbihvcmllbnRhdGlvbik7XHJcbiAgICAgICAgICAgIF9iaXJkRXllLnJlZnJlc2goKTtcclxuICAgICAgICAgICAgaWYgKF9ncmFwaE1hcCkgX2dyYXBoTWFwLnJlZnJlc2goe1xyXG4gICAgICAgICAgICAgICAgdmlld0ZyYW1lczogX2xpbmVhZ2VEaWFncmFtLmdldFZpZXdGcmFtZXMoKSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEl0IHJldHVybnMgb3JpZW50YXRpb24gb2YgdGhlIGdyYXBoXHJcbiAgICAgKiBAbWVtYmVyb2YgTGluZWFnZUdyYW1cclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IG9yZWludGF0aW9uIC0gVmFsdWVzOiAnbGVmdC10by1yaWdodCcsICdyaWdodC10by1sZWZ0JywgJ3RvcC10by1ib3R0b20nLCAnYm90dG9tLXRvLXRvcCdcclxuICAgICAqL1xyXG4gICAgc2VsZi5nZXRPcmllbnRhdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX3BhcmFtZXRlcnMuZ3JhcGhPcmllbnRhdGlvbjtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWZyZXNoZXMgTGluZWFnZUdyYW0gLSByZWZyZXNoZXMgYWxsIHZpZXdzIGFuZCBhZGp1c3Qgc2l6ZSBvZiB0aGUgY2FudmFzLlxyXG4gICAgICogQG1lbWJlcm9mIExpbmVhZ2VHcmFtXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFyZ2V0IC0gJ2xpbmVhZ2VEaWFncmFtJyB8ICdiaXJkRXllJyB8ICdncmFwaE1hcCdcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqL1xyXG4gICAgc2VsZi5yZWZyZXNoID0gZnVuY3Rpb24gKHRhcmdldCkge1xyXG4gICAgICAgIGlmIChfc3RhdGUgIT09ICdjb21wbGV0ZWQnKSByZXR1cm47XHJcblxyXG4gICAgICAgIGlmIChfY3VycmVudFZpZXcgPT09ICdsaW5lYWdlRGlhZ3JhbScpIHtcclxuICAgICAgICAgICAgaWYgKCF0YXJnZXQgfHwgdGFyZ2V0ID09PSAnbGluZWFnZURpYWdyYW0nKSBfbGluZWFnZURpYWdyYW0ucmVkcmF3KCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKCF0YXJnZXQgfHwgdGFyZ2V0ID09PSAnYmlyZEV5ZScpIF9iaXJkRXllLnJlZnJlc2goKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKF9ncmFwaE1hcCAmJiAoIXRhcmdldCB8fCB0YXJnZXQgPT09ICdncmFwaE1hcCcpKSBfZ3JhcGhNYXAucmVmcmVzaCh7XHJcbiAgICAgICAgICAgIHZpZXdGcmFtZXM6IF9saW5lYWdlRGlhZ3JhbS5nZXRWaWV3RnJhbWVzKCksXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVmlld0ZybWFlcyBwdWJsaWMgZGF0YVxyXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gVmlld0ZyYW1lUHVibGljTW9kZWxcclxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBpZCAtIElkZW50aWZpZXJcclxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBsYWJlbCAtIFRleHQgbGFiZWxcclxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBib3JkZXJDb2xvciAtIENTUyBib3JkZXIgY29sb3JcclxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBiYWNrZ3JvdW5kQ29sb3IgLSBDU1MgYmFjZ3JvdW5kIGNvbG9yXHJcbiAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IFZpZXdGcmFtZXMgc3RhdGVzLlxyXG4gICAgICogQHJldHVybnMge1ZpZXdGcmFtZVB1YmxpY01vZGVsW119IHN0YXRlcyAtIGtleSAtPiBpZCwgdmFsdWUgLT4gdHJ1ZSAtIGV4cGFuZGVkLCBmYWxzZSAtIGNvbGxhcHNlZFxyXG4gICAgICogQG1lbWJlcm9mIExpbmVhZ2VHcmFtXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKi9cclxuICAgIHNlbGYuZ2V0Vmlld0ZyYW1lcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoX3N0YXRlICE9PSAnY29tcGxldGVkJykgcmV0dXJuIFtdO1xyXG5cclxuICAgICAgICByZXR1cm4gX2xpbmVhZ2VEaWFncmFtLmdldFZpZXdGcmFtZXMoKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIG9uZSBWaWV3RnJhbWUgYnkgaWRcclxuICAgICAqIEBtZW1iZXJvZiBMaW5lYWdlR3JhbVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZpZXdGcmFtZUlkXHJcbiAgICAgKiBAcmV0dXJucyB7Vmlld0ZyYW1lUHVibGljTW9kZWx9XHJcbiAgICAqL1xyXG4gICAgc2VsZi5nZXRWaWV3RnJhbWVCeUlkID0gZnVuY3Rpb24gKHZpZXdGcmFtZUlkKSB7XHJcbiAgICAgICAgaWYgKF9zdGF0ZSAhPT0gJ2NvbXBsZXRlZCcpIHJldHVybiB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgIHJldHVybiBfbGluZWFnZURpYWdyYW0uZ2V0Vmlld0ZyYW1lQnlJZCh2aWV3RnJhbWVJZCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBvbmUgVmlld0ZyYW1lIGJ5IGlkXHJcbiAgICAgKiBAbWVtYmVyb2YgTGluZWFnZUdyYW1cclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEByZXR1cm5zIHtWaWV3RnJhbWVQdWJsaWNNb2RlbH1cclxuICAgICovXHJcbiAgICBzZWxmLmdldE92ZXJWaWV3RnJhbWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKF9zdGF0ZSAhPT0gJ2NvbXBsZXRlZCcpIHJldHVybiB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgIHJldHVybiBfbGluZWFnZURpYWdyYW0uZ2V0T3ZlclZpZXdGcmFtZSgpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbGxhcHNlIHRoZSBWaWV3RnJhbWUgd2l0aCBzcGVjaWZpZWQgSWQuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmlld0ZyYW1lSWQgLSBpZCBvZiB0aGUgdGFyZ2V0IFZpZXdGcmFtZVxyXG4gICAgICogQG1lbWJlcm9mIExpbmVhZ2VHcmFtXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKi9cclxuICAgIHNlbGYuY29sbGFwc2VWaWV3RnJhbWUgPSBmdW5jdGlvbiAodmlld0ZyYW1lSWQpIHtcclxuICAgICAgICBpZiAoX3N0YXRlICE9PSAnY29tcGxldGVkJykgcmV0dXJuO1xyXG4gICAgICAgIF9saW5lYWdlRGlhZ3JhbS5jbG9zZVZpZXdGcmFtZSh2aWV3RnJhbWVJZCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRXhwYW5kIFZpZXdGcmFtZSB3aXRoIHNwZWNpZmllZCBJZC5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2aWV3RnJhbWVJZCAtIGlkIG9mIHRoZSB0YXJnZXQgVmlld0ZyYW1lXHJcbiAgICAgKiBAbWVtYmVyb2YgTGluZWFnZUdyYW1cclxuICAgICAqIEBtZXRob2RcclxuICAgICAqL1xyXG4gICAgc2VsZi5leHBhbmRWaWV3RnJhbWUgPSBmdW5jdGlvbiAodmlld0ZyYW1lSWQpIHtcclxuICAgICAgICBpZiAoX3N0YXRlICE9PSAnY29tcGxldGVkJykgcmV0dXJuO1xyXG4gICAgICAgIF9saW5lYWdlRGlhZ3JhbS5vcGVuVmlld0ZyYW1lKHZpZXdGcmFtZUlkKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb2xsYXBzZXMvRXhwYW5kcyBPdmVyVmlld0ZyYW1lLlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSB2YWx1ZVxyXG4gICAgICogQG1lbWJlcm9mIExpbmVhZ2VHcmFtXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAqL1xyXG4gICAgc2VsZi5zZXRGdWxsU2NyZWVuTW9kZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIGlmIChfc3RhdGUgIT09ICdjb21wbGV0ZWQnKSByZXR1cm47XHJcbiAgICAgICAgX2xpbmVhZ2VEaWFncmFtLnNldEZ1bGxTY3JlZW5Nb2RlKHZhbHVlKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb2xsYXBzZXMvRXhwYW5kcyBPdmVyVmlld0ZyYW1lLlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSB2YWx1ZVxyXG4gICAgICogQG1lbWJlcm9mIExpbmVhZ2VHcmFtXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAqL1xyXG4gICAgc2VsZi5pc0Z1bGxTY3JlZW5Nb2RlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChfc3RhdGUgIT09ICdjb21wbGV0ZWQnKSByZXR1cm4gX3BhcmFtZXRlcnMuZnVsbFNjcmVlbk1vZGU7XHJcbiAgICAgICAgcmV0dXJuIF9saW5lYWdlRGlhZ3JhbS5pc0Z1bGxTY3JlZW5Nb2RlKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR3JvdXBzIHJlbGF0aXZlIHRvIHNlbGVjdGVkIG5vZGVcclxuICAgICAqIG5vZGVzIGFyb3VuZCAgdGhlIHNlbGVjdGVkIG5vZGUgYW5kIGhpZ2hsaWdodCB0aGVtLlxyXG4gICAgICogQG1lbWJlcm9mIExpbmVhZ2VHcmFtXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAqL1xyXG4gICAgc2VsZi5jb21iaW5lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF9saW5lYWdlRGlhZ3JhbS5jb21iaW5lKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmluZHMgZWxlbWVudHMgYnkgaWQocykgYW5kIHNldHMgaXQgYXMgc2VsZWN0ZWQuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudWxsfSBpZDEgLSBTZWxlY3RlZCBlbGVtZW50IGlkIG9yIHNvdXJjZSBlbGVtZW50IGlkIG9mIHRoZSBsaW5rXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQyIC0gVGFyZ2V0IGVsZW1lbnQgaWRcclxuICAgICAqIEByZXR1cm5zIHtOb2RlfExpbmt9IC0gU2VsZWN0ZWQgZWxlbWVudFxyXG4gICAgICogQG1lbWJlcm9mIExpbmVhZ2VHcmFtXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKi9cclxuICAgIHNlbGYuc2V0U2VsZWN0ZWRFbGVtZW50ID0gZnVuY3Rpb24gKGlkMSwgaWQyKSB7XHJcbiAgICAgICAgaWYgKGlkMSA9PT0gdW5kZWZpbmVkKSByZXR1cm47XHJcblxyXG4gICAgICAgIGlmIChpZDEgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWRFbGVtZW50ID0gX2dldEVsZW1lbnRCeUlkKGlkMSwgaWQyKTtcclxuICAgICAgICAgICAgX3NldFNlbGVjdGVkRWxlbWVudChzZWxlY3RlZEVsZW1lbnQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIF9zZXRTZWxlY3RlZEVsZW1lbnQobnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYnVpbGRzIGRpYWdyYW1tIHdpdGggbmV3IGZvY3VzIG5vZGVcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmb2N1c05vZGUgLSBGb2N1cyBub2RlIGlkXHJcbiAgICAgKiBAbWVtYmVyb2YgTGluZWFnZUdyYW1cclxuICAgICAqIEBtZXRob2RcclxuICAgICAqL1xyXG4gICAgc2VsZi5zZXRGb2N1c05vZGUgPSBmdW5jdGlvbiAoZm9jdXNOb2RlSWQpIHtcclxuICAgICAgICBjb25zdCBmb2N1c05vZGUgPSBfZ2V0RWxlbWVudEJ5SWQoZm9jdXNOb2RlSWQpO1xyXG5cclxuICAgICAgICBpZiAoIShmb2N1c05vZGUgaW5zdGFuY2VvZiBncmFwaEVsZW1lbnRzLk5vZGUpKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0luY29ycmVjdCB2YWx1ZSBvZiBlbGVtZW50Jyk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIF9zdGF0ZVN0b3JhZ2UudXBkYXRlU3RhdGUoX2dldEhpc3RvcnlTdGF0ZSgpKTtcclxuICAgICAgICBfc2V0RGlhZ3JhbVN0YXRlKCdmZXRjaGluZycpO1xyXG5cclxuICAgICAgICBsZXQgZm9jdXNSZXNvdXJjZSA9IGZvY3VzTm9kZS5tb2RlbC5yZXNvdXJjZTtcclxuXHJcbiAgICAgICAgaWYoZm9jdXNOb2RlLm1vZGVsLmhhc093blByb3BlcnR5KCdhY3RpdmVSZXNvdXJjZScpKXtcclxuICAgICAgICAgICAgZm9jdXNSZXNvdXJjZSA9IGZvY3VzTm9kZS5tb2RlbC5hY3RpdmVSZXNvdXJjZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIF9mZXRjaERpYWdyYW0oe1xyXG4gICAgICAgICAgICBmb2N1c05vZGVJZDogZm9jdXNSZXNvdXJjZSxcclxuICAgICAgICAgICAgdmlld0ZyYW1lOiBmb2N1c05vZGUubW9kZWwudmlld0ZyYW1lLFxyXG4gICAgICAgICAgICBvZmZzZXQ6IChmb2N1c05vZGUubW9kZWwuaGFzT3duUHJvcGVydHkoJ29mZnNldCcpID8gZm9jdXNOb2RlLm1vZGVsLm9mZnNldCA6IG51bGwpLFxyXG4gICAgICAgICAgICBkaWFncmFtVHlwZTogX2RpYWdyYW1UeXBlLFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRvIHByZXZpb3VzIHNlbGVjdGVkIG5vZGUgKFJlc3RvcmVzIHByZXZpb3VzIGRpYWdyYW0pXHJcbiAgICAgKiBAbWVtYmVyb2YgTGluZWFnZUdyYW1cclxuICAgICAqIEBtZXRob2RcclxuICAgICAqL1xyXG4gICAgc2VsZi51bmRvU3RhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgX3N0YXRlU3RvcmFnZS51cGRhdGVTdGF0ZShfZ2V0SGlzdG9yeVN0YXRlKCkpO1xyXG4gICAgICAgIGNvbnN0IHByZXZpb3VzU3RhdGUgPSBfc3RhdGVTdG9yYWdlLnVuZG9TdGF0ZSgpO1xyXG4gICAgICAgIGlmIChwcmV2aW91c1N0YXRlKSBfbG9hZFN0YXRlKHByZXZpb3VzU3RhdGUpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdG8gbmV4dCBzZWxlY3RlZCBub2RlXHJcbiAgICAgKiAoTm9kZSB3aGljaCBoYWQgYmVlbiBzZWxlY3RlZCBiZWZvcmUgdGhlIHN0YXRlIHdhcyByZXN0b3JlZClcclxuICAgICAqIEBtZW1iZXJvZiBMaW5lYWdlR3JhbVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICovXHJcbiAgICBzZWxmLnJlZG9TdGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfc3RhdGVTdG9yYWdlLnVwZGF0ZVN0YXRlKF9nZXRIaXN0b3J5U3RhdGUoKSk7XHJcbiAgICAgICAgY29uc3QgbmV4dFN0YXRlID0gX3N0YXRlU3RvcmFnZS5yZWRvU3RhdGUoKTtcclxuICAgICAgICBpZiAobmV4dFN0YXRlKSBfbG9hZFN0YXRlKG5leHRTdGF0ZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBwdWJsaWMgbW9kZWwgb2Ygc2VsZWN0ZWQgZWxlbWVudFxyXG4gICAgICogQHJldHVybnMge1B1YmxpY0xpbmtNb2RlbHxQdWJsaWNOb2RlTW9kZWx9IHNlbGVjdGVkRWxlbWVudFxyXG4gICAgICogQG1lbWJlcm9mIExpbmVhZ2VHcmFtXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKi9cclxuICAgIHNlbGYuZ2V0U2VsZWN0ZWRFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfZ2V0TW9kZWwoX3NlbGVjdGVkRWxlbWVudCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBwdWJsaWMgbW9kZWwgb2YgZm9jdXMgZWxlbWVudC5cclxuICAgICAqIEVsZW1lbnQgd2hpY2ggd2FzIHVzZWQgdG8gYnVpbGQgZGlhZ3JhbSBhcm91bmRcclxuICAgICAqIEByZXR1cm5zIHtQdWJsaWNMaW5rTW9kZWx8UHVibGljTm9kZU1vZGVsfSBmb2N1c0VsZW1lbnRcclxuICAgICAqIEBtZW1iZXJvZiBMaW5lYWdlR3JhbVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICovXHJcbiAgICBzZWxmLmdldEZvY3VzRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX2dldE1vZGVsKF9mb2N1c0VsZW1lbnQpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICogUmV0dXJucyB0aGUgY3VycmVudCBkZXJpdmF0aW9uIG1hcC5cclxuICAgICogQHJldHVybnMge0Rlcml2YXRpb25NYXB9IGRlcnZpYXRpb25NYXBcclxuICAgICogQG1lbWJlcm9mIGxpbmVhZ2VHcmFtXHJcbiAgICAqIEBtZXRob2RcclxuICAgICovXHJcbiAgICBzZWxmLmdldERlcml2YXRpb25NYXAgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKF9zdGF0ZSA9PT0gJ2NvbXBsZXRlZCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9kZXJpdmF0aW9uTWFwO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLmdldE5vZGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChfc3RhdGUgIT09ICdjb21wbGV0ZWQnKSByZXR1cm4gW107XHJcbiAgICAgICAgcmV0dXJuIF9kYXRhQ29udGFpbmVyLm5vZGVzLm1hcChuID0+IF9nZXRNb2RlbChuKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYuZ2V0TGlua3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKF9zdGF0ZSAhPT0gJ2NvbXBsZXRlZCcpIHJldHVybiBbXTtcclxuICAgICAgICByZXR1cm4gX2RhdGFDb250YWluZXIubGlua3MubWFwKGwgPT4gX2dldE1vZGVsKGwpKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHcmFwaHMgcHVibGljIG1hcHNcclxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFB1YmxpY0dyYXBoTWFwc1xyXG4gICAgICogQHByb3BlcnR5IHtPYmplY3QuPHN0cmluZywgUHVibGljTm9kZU1vZGVsPn0gbm9kZU1hcFxyXG4gICAgICogQHByb3BlcnR5IHtPYmplY3QuPHN0cmluZywgUHVibGljTGlua01vZGVsPn0gbGlua01hcFxyXG4gICAgICogQHByb3BlcnR5IHtPYmplY3QuPHN0cmluZywgUHVibGljTGlua01vZGVsPn0gc291cmNlTWFwXHJcbiAgICAgKiBAcHJvcGVydHkge09iamVjdC48c3RyaW5nLCBQdWJsaWNMaW5rTW9kZWw+fSB0YXJnZXRNYXBcclxuICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHcmFwaCBtb2RlbFxyXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHVibGljR3JhcGhNb2RlbFxyXG4gICAgICogQHByb3BlcnR5IHtQdWJsaWNOb2RlTW9kZWxbXX0gbm9kZXNcclxuICAgICAqIEBwcm9wZXJ0eSB7UHVibGljTGlua01vZGVsW119IGxpbmtzXHJcbiAgICAgKiBAcHJvcGVydHkge1B1YmxpY0dyYXBoTWFwc30gbWFwc1xyXG4gICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBkYXRhIG1vZGVsIG9mIExpbmVhZ0dyYW0uXHJcbiAgICAgKiBAcmV0dXJucyB7UHVibGljR3JhcGhNb2RlbH1cclxuICAgICAqIEBtZW1iZXJvZiBMaW5lYWdlR3JhbVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICovXHJcbiAgICBzZWxmLmdldEdyYXBoTW9kZWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKF9zdGF0ZSAhPT0gJ2NvbXBsZXRlZCcpIHJldHVybiB7fTtcclxuXHJcbiAgICAgICAgY29uc3QgZ3JhcGhNb2RlbCA9IHtcclxuICAgICAgICAgICAgbm9kZXM6IF9kYXRhQ29udGFpbmVyLm5vZGVzLm1hcChuID0+IF9nZXRNb2RlbChuKSksXHJcbiAgICAgICAgICAgIGxpbmtzOiBfZGF0YUNvbnRhaW5lci5saW5rcy5tYXAobCA9PiBfZ2V0TW9kZWwobCkpLFxyXG4gICAgICAgICAgICBtYXBzOiB7XHJcbiAgICAgICAgICAgICAgICBub2RlTWFwOiB7fSxcclxuICAgICAgICAgICAgICAgIGxpbmtNYXA6IHt9LFxyXG4gICAgICAgICAgICAgICAgc291cmNlTWFwOiB7fSxcclxuICAgICAgICAgICAgICAgIHRhcmdldE1hcDoge30sXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBncmFwaE1vZGVsLm5vZGVzLmZvckVhY2gobm9kZU1vZGVsID0+IHtcclxuICAgICAgICAgICAgZ3JhcGhNb2RlbC5tYXBzLm5vZGVNYXBbbm9kZU1vZGVsLmlkXSA9IG5vZGVNb2RlbDtcclxuICAgICAgICB9KTtcclxuICAgICAgICBncmFwaE1vZGVsLmxpbmtzLmZvckVhY2gobGlua01vZGVsID0+IHtcclxuICAgICAgICAgICAgZ3JhcGhNb2RlbC5tYXBzLmxpbmtNYXBbbGlua01vZGVsLmlkXSA9IGxpbmtNb2RlbDtcclxuXHJcbiAgICAgICAgICAgIGlmICghZ3JhcGhNb2RlbC5tYXBzLnNvdXJjZU1hcFtsaW5rTW9kZWwudGFyZ2V0XSkge1xyXG4gICAgICAgICAgICAgICAgZ3JhcGhNb2RlbC5tYXBzLnNvdXJjZU1hcFtsaW5rTW9kZWwudGFyZ2V0XSA9IFtdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghZ3JhcGhNb2RlbC5tYXBzLnRhcmdldE1hcFtsaW5rTW9kZWwuc291cmNlXSkge1xyXG4gICAgICAgICAgICAgICAgZ3JhcGhNb2RlbC5tYXBzLnRhcmdldE1hcFtsaW5rTW9kZWwuc291cmNlXSA9IFtdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBncmFwaE1vZGVsLm1hcHMuc291cmNlTWFwW2xpbmtNb2RlbC50YXJnZXRdLnB1c2gobGlua01vZGVsKTtcclxuICAgICAgICAgICAgZ3JhcGhNb2RlbC5tYXBzLnRhcmdldE1hcFtsaW5rTW9kZWwuc291cmNlXS5wdXNoKGxpbmtNb2RlbCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiBncmFwaE1vZGVsO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgY3VycmVudCB2aWV3LiBNZXRob2QgdGFrZXMgc3RyaW5nIGlkZW50aWZpZXIgb2YgdGhlIHZpZXcgYXMgYSBwYXJhbWV0ZXJcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSAtIHZpZXdJZCBjYW4gYmUgJ2xpbmVhZ2VEaWFncmFtJyBvciAnYmlyZEV5ZScgb3IgJ25vbmUnXHJcbiAgICAgKiBAbWVtYmVyb2YgTGluZWFnZUdyYW1cclxuICAgICAqIEBtZXRob2RcclxuICAgICAqL1xyXG4gICAgc2VsZi5zZXRDdXJyZW50VmlldyA9IGZ1bmN0aW9uICh2aWV3SWQpIHtcclxuICAgICAgICBpZiAodmlld0lkID09PSAnbGluZWFnZURpYWdyYW0nKSB7XHJcbiAgICAgICAgICAgIF9zaG93Sm9pbnRHcmFwaCgpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodmlld0lkID09PSAnYmlyZEV5ZScpIHtcclxuICAgICAgICAgICAgX3Nob3dTaWdtYUdyYXBoKCk7XHJcbiAgICAgICAgfSBlbHNlIGlmICh2aWV3SWQgPT09ICdub25lJykgIHtcclxuICAgICAgICAgICAgX2hpZGVWaWV3cygpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBzZWxmLnNldEN1cnJlbnRWaWV3KF9jdXJyZW50Vmlldyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIGxpbmtzIHJvdXRpbmcgd2hpY2ggaXMgYmFzZWRcclxuICAgICAqIG9uIGpvaW50anMgcm91dGluZ3M6IG1ldHJvIHwgbm9ybWFsIHwgbWFuaGF0dGFuIHwgb3J0aG9nb25hbFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHJvdXRpbmdJZCAtIG1ldHJvIHwgbm9ybWFsIHwgbWFuaGF0dGFuIHwgb3J0aG9nb25hbFxyXG4gICAgICogQG1lbWJlcm9mIExpbmVhZ2VHcmFtXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKi9cclxuICAgIHNlbGYuc2V0Um91dGluZyA9IGZ1bmN0aW9uIChyb3V0aW5nSWQpIHtcclxuICAgICAgICBpZiAoX3N0YXRlID09PSAnY29tcGxldGVkJykge1xyXG4gICAgICAgICAgICBfbGluZWFnZURpYWdyYW0uc2V0Um91dGluZyhyb3V0aW5nSWQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHJvdXRpbmcgd2hpY2ggaXMgY3VycmVudGx5IGFwcGxpZWQgZm9yIGFsbCBsaW5rcy5cclxuICAgICAqIEBtZW1iZXJvZiBMaW5lYWdlR3JhbVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQHJldHVybnMge3N0cmluZ30gcm91dGluZzogbWV0cm8gfCBub3JtYWwgfCBtYW5oYXR0YW4gfCBvcnRob2dvbmFsXHJcbiAgICAgKi9cclxuICAgIHNlbGYuZ2V0Um91dGluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoX3N0YXRlID09PSAnY29tcGxldGVkJykge1xyXG4gICAgICAgICAgICByZXR1cm4gX2xpbmVhZ2VEaWFncmFtLmdldFJvdXRpbmcoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gcGFyYW1ldGVycy5saW5rUm91dGluZztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB2YWx1ZSBvZiB0aGUgcGFyYW1ldGVyIHdoaWNoIHRlbGxzIHVzIHdoZXRlciB3ZSBzaG91bGRcclxuICAgICAqIHRyaW0gbm9kZXMgYnkgdGhlIGJvcmRlcnMgb3Igbm90LlxyXG4gICAgICogQG1lbWJlcm9mIExpbmVhZ2VHcmFtXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNsaXBwaW5nXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKi9cclxuICAgIHNlbGYuc2V0Q2xpcHBpbmcgPSBmdW5jdGlvbiAoY2xpcHBpbmcpIHtcclxuICAgICAgICBfcGFyYW1ldGVycy5jbGlwTm9kZXMgPSBjbGlwcGluZztcclxuICAgICAgICBpZiAoX3N0YXRlID09PSAnY29tcGxldGVkJykge1xyXG4gICAgICAgICAgICBfbGluZWFnZURpYWdyYW0ucmVkcmF3KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdmFsdWUgb2YgdGhlIHBhcmFtZXRlciB3aGljaCB0ZWxscyB1cyB3aGV0ZXIgd2VcclxuICAgICAqIHRyaW0gbm9kZXMgYnkgdGhlIGJvcmRlcnMgb3Igbm90LlxyXG4gICAgICogQG1lbWJlcm9mIExpbmVhZ2VHcmFtXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gY2xpcHBpbmdcclxuICAgICAqL1xyXG4gICAgc2VsZi5nZXRDbGlwcGluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX3BhcmFtZXRlcnMuY2xpcE5vZGVzO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLnNldE1hc2sgPSBmdW5jdGlvbiAocHVibGljTWFzaykge1xyXG4gICAgICAgIGNvbnN0IGlkTWFwID0gX2RhdGFDb250YWluZXIubWFwcy5pZE1hcDtcclxuICAgICAgICBjb25zdCBtYXNrID0ge307XHJcbiAgICAgICAgT2JqZWN0LmtleXMocHVibGljTWFzaykuZm9yRWFjaChpZCA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRpYWdyYW1JZCA9IGlkTWFwW2lkXTtcclxuICAgICAgICAgICAgbWFza1tkaWFncmFtSWRdID0gcHVibGljTWFza1tpZF07XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgX2xpbmVhZ2VEaWFncmFtLnNldE1hc2sobWFzayk7XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYuZ2V0TWFzayA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjb25zdCBtYXNrID0gX2xpbmVhZ2VEaWFncmFtLmdldE1hc2soKTtcclxuICAgICAgICBjb25zdCBub2RlTWFwID0gX2RhdGFDb250YWluZXIubWFwcy5ub2RlTWFwO1xyXG4gICAgICAgIGNvbnN0IGxpbmtNYXAgPSBfZGF0YUNvbnRhaW5lci5tYXBzLmxpbmtNYXA7XHJcbiAgICAgICAgY29uc3QgcHVibGljTWFzayA9IHt9O1xyXG4gICAgICAgIGlmIChtYXNrKSB7XHJcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKG1hc2spLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChtYXNrW2tleV0pIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gX2dldE1vZGVsKG5vZGVNYXBba2V5XSB8fCBsaW5rTWFwW2tleV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1YmxpY01hc2tbZWxlbWVudC5pZF0gPSBlbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwdWJsaWNNYXNrO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZldGNoZXMgZGlhZ3JhbSB1c2luZyBwYXNzZWQgb3B0aW9uc1xyXG4gICAgICogQHBhcmFtIHt7XHJcbiAgICAgKiAgICAgIGZvY3VzTm9kZUlkOiBzdHJpbmcsXHJcbiAgICAgKiAgICAgIHZpZXdGcmFtZXM6IFZpZXdGcmFtZURlZmluaXRpb25bXSxcclxuICAgICAqICAgICAgdmlld0ZyYW1lOiBzdHJpbmdcclxuICAgICAqICAgICAgbGluZWFnZUdyYW1WaWV3Q2xhc3M6IHN0cmluZyxcclxuICAgICAqICAgICAgZGlhZ3JhbVR5cGU6IHN0cmluZyxcclxuICAgICAqIH19XHJcbiAgICAgKiBAbWVtYmVyb2YgTGluZWFnZUdyYW1cclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIF9mZXRjaERpYWdyYW0gKG9wdGlvbnMpIHtcclxuICAgICAgICBjb25zdCB0YXJnZXROb2RlSWQgPSBvcHRpb25zLmZvY3VzTm9kZUlkO1xyXG4gICAgICAgIGNvbnN0IHZpZXdGcmFtZSA9IG9wdGlvbnMudmlld0ZyYW1lO1xyXG4gICAgICAgIGNvbnN0IGRpYWdyYW1UeXBlID0gb3B0aW9ucy5kaWFncmFtVHlwZTtcclxuICAgICAgICBjb25zdCBvZmZzZXQgPSAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnb2Zmc2V0JykgPyAgb3B0aW9ucy5vZmZzZXQgOiBudWxsKTtcclxuXHJcbiAgICAgICAgLy8gU3dpdGNoIHRoZSBsb2FkaW5nIGluZGljYXRvciBpbiBzdGF0ZSAnZmV0Y2hpbmcnXHJcbiAgICAgICAgLy8gUmVxdWVzdCBkYXRhIHRocm91Z2ggZGF0YSBwcm92aWRlclxyXG4gICAgICAgIF9zZXREaWFncmFtU3RhdGUoJ2ZldGNoaW5nJyk7XHJcbiAgICAgICAgaWYgKCFfZGF0YVByb3ZpZGVyKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9ICdEYXRhIHByb3ZpZGVyIGlzIG5vdCBzcGVjaWZpZWQhJztcclxuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcclxuICAgICAgICAgICAgX3NldERpYWdyYW1TdGF0ZSgnZXJyb3InLCBlcnJvck1lc3NhZ2UpO1xyXG4gICAgICAgICAgICBfZXJyb3JDYWxsYmFjayhlcnJvcik7XHJcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIV9kYXRhUHJvdmlkZXIuZmV0Y2hEYXRhKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9ICdEYXRhIHByb3ZpZGVyIGhhcyBpbmNvcnJlY3QgaW50ZXJmYWNlISAoVGhlcmUgaXMgbm8gXFwnZmV0Y2hEYXRhXFwnIG1ldGhvZCknO1xyXG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpO1xyXG4gICAgICAgICAgICBfc2V0RGlhZ3JhbVN0YXRlKCdlcnJvcicsIGVycm9yTWVzc2FnZSk7XHJcbiAgICAgICAgICAgIF9lcnJvckNhbGxiYWNrKGVycm9yKTtcclxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCB2aWV3RnJhbWVzUHJvbWlzZSA9IG9wdGlvbnMudmlld0ZyYW1lcyAmJiBvcHRpb25zLnZpZXdGcmFtZXMubGVuZ3RoID4gMCA/XHJcbiAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZSh7IGZyYW1lczogb3B0aW9ucy52aWV3RnJhbWVzIH0pIDpcclxuICAgICAgICAgICAgX2RhdGFQcm92aWRlci5nZXRWaWV3RnJhbWVzKHRhcmdldE5vZGVJZCk7XHJcbiAgICAgICAgY29uc3Qgdmlld0NsYXNzUHJvbWlzZSA9IG9wdGlvbnMubGluZWFnZUdyYW1WaWV3Q2xhc3MgP1xyXG4gICAgICAgICAgICBQcm9taXNlLnJlc29sdmUob3B0aW9ucy5saW5lYWdlR3JhbVZpZXdDbGFzcykgOlxyXG4gICAgICAgICAgICBfZGF0YVByb3ZpZGVyLmdldFZpZXdDbGFzc0ZvclJlc291cmNlKHRhcmdldE5vZGVJZCk7XHJcblxyXG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbdmlld0ZyYW1lc1Byb21pc2UsIHZpZXdDbGFzc1Byb21pc2VdKS50aGVuKHZhbHVlcyA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHZpZXdGcmFtZXMgPSB2YWx1ZXNbMF0uZnJhbWVzO1xyXG4gICAgICAgICAgICBjb25zdCB2aWV3Q2xhc3MgPSB2YWx1ZXNbMV0uZGF0YVByb3ZpZGVyO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIF9kYXRhUHJvdmlkZXIuZmV0Y2hEYXRhKHtcclxuICAgICAgICAgICAgICAgIHRhcmdldE5vZGVJZDogdGFyZ2V0Tm9kZUlkLFxyXG4gICAgICAgICAgICAgICAgdmlld0ZyYW1lOiB2aWV3RnJhbWUsXHJcbiAgICAgICAgICAgICAgICBsaW5lYWdlR3JhbVZpZXdDbGFzczogdmlld0NsYXNzLFxyXG4gICAgICAgICAgICAgICAgZGlhZ3JhbVR5cGU6IGRpYWdyYW1UeXBlLFxyXG4gICAgICAgICAgICAgICAgb2Zmc2V0Om9mZnNldFxyXG4gICAgICAgICAgICB9KS50aGVuKHJhd0RhdGEgPT4ge1xyXG4gICAgICAgICAgICAgICAgX3NldERpYWdyYW1TdGF0ZSgncmVuZGVyaW5nJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgY2hlY2tMZ1Jhd0RhdGEocmF3RGF0YSk7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YUNvbnRhaW5lciA9IF9jcmVhdGVEYXRhQ29udGFpbmVyKHJhd0RhdGEsIHZpZXdGcmFtZXMpO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgdmlld0ZyYW1lRGVmaW5pdGlvbnMgPSBmaWx0ZXJWaWV3RnJhbWVMaXN0KHZpZXdGcmFtZXMsIGRhdGFDb250YWluZXIpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcHVibGljVmlld0ZyYW1lTW9kZWxzID0gdmlld0ZyYW1lRGVmaW5pdGlvbnMubWFwKGQgPT5cclxuICAgICAgICAgICAgICAgICAgICBkZWZlbml0aW9uVG9QdWJsaWNNb2RlbChkLCBfbGluZWFnZURpYWdyYW0uaXNGdWxsU2NyZWVuTW9kZSgpKVxyXG4gICAgICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgICAgICBfdXBkYXRlQ29tcG9uZW50cyhkYXRhQ29udGFpbmVyLCBwdWJsaWNWaWV3RnJhbWVNb2RlbHMpO1xyXG5cclxuICAgICAgICAgICAgICAgIF9kaWFncmFtVHlwZSA9IHJhd0RhdGEuZGlhZ3JhbVR5cGU7XHJcbiAgICAgICAgICAgICAgICBfZGF0YUNvbnRhaW5lciA9IGRhdGFDb250YWluZXI7XHJcbiAgICAgICAgICAgICAgICBfc3RhdGVTdG9yYWdlLnB1c2hTdGF0ZShfZ2V0SGlzdG9yeVN0YXRlKCkpO1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IGZvY3VzTm9kZUlkID0gcmF3RGF0YS5mb2N1c05vZGUgfHwgKHJhd0RhdGEubm9kZXNbMF0gPyByYXdEYXRhLm5vZGVzWzBdLmlkIDogZm9jdXNOb2RlSWQpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZm9jdXNFbGVtZW50ID0gX2dldEVsZW1lbnRCeUlkKGZvY3VzTm9kZUlkKTtcclxuICAgICAgICAgICAgICAgIF9mb2N1c0VsZW1lbnQgPSBmb2N1c0VsZW1lbnQ7XHJcblxyXG4gICAgICAgICAgICAgICAgX3NldFNlbGVjdGVkRWxlbWVudChmb2N1c0VsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgX3NldERpYWdyYW1TdGF0ZSgnY29tcGxldGVkJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgc2VsZi50cmlnZ2VyKCdmb2N1cy1ub2RlLWNoYW5nZWQnLCBfZ2V0TW9kZWwoZm9jdXNFbGVtZW50KSk7XHJcbiAgICAgICAgICAgICAgICBzZWxmLnRyaWdnZXIoJ2hpc3Rvcnktc3RhdGUtY2hhbmdlZCcsIF9zdGF0ZVN0b3JhZ2UuZ2V0SGlzdG9yeSgpKTtcclxuXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pLmNhdGNoKGUgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IHR5cGVvZiBlID09PSAnc3RyaW5nJyA/IG5ldyBFcnJvcihlKSA6IGU7XHJcblxyXG4gICAgICAgICAgICBfc2V0RGlhZ3JhbVN0YXRlKCdlcnJvcicsIGVycm9yLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICBfZXJyb3JDYWxsYmFjayhlcnJvcik7XHJcblxyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yLnN0YWNrKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVtb3ZlcyBlbXB0eSB2aWV3RnJhbWVzXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKiBAcGFyYW0ge1ZpZXdGcmFtZURlZmluaXRpb25bXX0gdmlld0ZyYW1lc1xyXG4gICAgICAgICAqIEBwYXJhbSB7RGF0YUNvbnRhaW5lcn0gZGF0YUNvbnRhaW5lclxyXG4gICAgICAgICAqIEByZXR1cm5zIHtWaWV3RnJhbWVbXX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBmaWx0ZXJWaWV3RnJhbWVMaXN0ICh2aWV3RnJhbWVzLCBkYXRhQ29udGFpbmVyKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGFjdGl2ZVZpZXdGcmFtZXMgPSB7fTtcclxuICAgICAgICAgICAgZGF0YUNvbnRhaW5lci5ub2Rlcy5mb3JFYWNoKG4gPT4ge1xyXG4gICAgICAgICAgICAgICAgYWN0aXZlVmlld0ZyYW1lc1tuLm1vZGVsLnZpZXdGcmFtZV0gPSB0cnVlO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdmlld0ZyYW1lcy5maWx0ZXIodmYgPT4gYWN0aXZlVmlld0ZyYW1lc1t2Zi5pZF0pO1xyXG4gICAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogRmluZHMgZWxlbWVudHMgYnkgaWQocykuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQxIC0gU2VsZWN0ZWQgZWxlbWVudCBpZCBvciBzb3VyY2UgZWxlbWVudCBpZCBvZiB0aGUgbGlua1xyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkMiAtIFRhcmdldCBlbGVtZW50IGlkXHJcbiAgICAgKiBAcmV0dXJucyB7Tm9kZXxMaW5rfSAtIFNlbGVjdGVkIGVsZW1lbnRcclxuICAgICovXHJcbiAgICBmdW5jdGlvbiBfZ2V0RWxlbWVudEJ5SWQgKGlkMSwgaWQyKSB7XHJcbiAgICAgICAgaWYgKCFpZDIpIHtcclxuICAgICAgICAgICAgY29uc3QgZWxlbWVudHMgPSBfZGF0YUNvbnRhaW5lci5ub2Rlcy5jb25jYXQoX2RhdGFDb250YWluZXIubGlua3MpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudHNbaV0ubW9kZWwucmVzb3VyY2UgPT09IGlkMSB8fCBlbGVtZW50c1tpXS5tb2RlbC5pZCA9PT0gaWQxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnRzW2ldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3Qgbm9kZU1hcCA9IF9kYXRhQ29udGFpbmVyLm1hcHMubm9kZU1hcDtcclxuICAgICAgICAgICAgY29uc3QgbGlua3MgPSBfZGF0YUNvbnRhaW5lci5saW5rcztcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5rcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc291cmNlID0gbm9kZU1hcFtsaW5rc1tpXS5tb2RlbC5zb3VyY2VdO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gbm9kZU1hcFtsaW5rc1tpXS5tb2RlbC50YXJnZXRdO1xyXG4gICAgICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZS5yZXNvdXJjZSA9PT0gaWQxICYmIHRhcmdldC5yZXNvdXJjZSA9PT0gaWQyIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgc291cmNlLnJlc291cmNlID09PSBpZDIgJiYgdGFyZ2V0LnJlc291cmNlID09PSBpZDEgfHxcclxuICAgICAgICAgICAgICAgICAgICBzb3VyY2UuaWQgPT09IGlkMSAmJiB0YXJnZXQuaWQgPT09IGlkMiB8fFxyXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZS5pZCA9PT0gaWQyICYmIHRhcmdldC5pZCA9PT0gaWQxXHJcbiAgICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGlua3NbaV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBDaGVja3MgcGFzc2VkIGVsZW1lbnQgYW5kIHNldCBpdCBhcyBhIHNlbGVjdGVkLiBSZWZyZXNoZXMgdGhpcyB2YWx1ZSBmb3IgdGhlIHZpZXdzLlxyXG4gICAgICogQHBhcmFtIHtOb2RlfExpbmt9IC0gU2VsZWN0ZWQgZWxlbWVudFxyXG4gICAgKi9cclxuICAgIGZ1bmN0aW9uIF9zZXRTZWxlY3RlZEVsZW1lbnQgKHNlbGVjdGVkRWxlbWVudCkge1xyXG4gICAgICAgIC8vIEl0IHNob3VkbG4ndCBiZSB1bmRlZmluZWQsIGJ1dCBpdCBjYW4gYmUgbnVsbFxyXG4gICAgICAgIGlmIChzZWxlY3RlZEVsZW1lbnQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcignSW5jb3JyZWN0IHZhbHVlIG9mIHNlbGVjdGVkIGVsZW1lbnQnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChfZ3JhcGhNYXApIF9ncmFwaE1hcC5zZXRTZWxlY3RlZEVsZW1lbnQoc2VsZWN0ZWRFbGVtZW50KTtcclxuICAgICAgICBpZiAoX2N1cnJlbnRWaWV3ID09PSAnbGluZWFnZURpYWdyYW0nKSBfbGluZWFnZURpYWdyYW0uc2V0U2VsZWN0ZWRFbGVtZW50KHNlbGVjdGVkRWxlbWVudCwgdHJ1ZSk7XHJcbiAgICAgICAgaWYgKF9jdXJyZW50VmlldyA9PT0gJ2JpcmRFeWUnKSBfYmlyZEV5ZS5zZXRTZWxlY3RlZEVsZW1lbnQoc2VsZWN0ZWRFbGVtZW50KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBSZXR1cm5zIGN1cnJlbnQgc3RhdGUuXHJcbiAgICAgKiBAcmV0dXJucyB7SGlzdG9yeVN0YXRlfSBjdXJyZW50IHN0YXRlXHJcbiAgICAqL1xyXG4gICAgZnVuY3Rpb24gX2dldEhpc3RvcnlTdGF0ZSAoKSB7XHJcbiAgICAgICAgY29uc3Qgb3ZlclZpZXdGcmFtZSA9IF9saW5lYWdlRGlhZ3JhbS5nZXRPdmVyVmlld0ZyYW1lKCk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgbm9kZXM6IF9kYXRhQ29udGFpbmVyLm5vZGVzLFxyXG4gICAgICAgICAgICBsaW5rczogX2RhdGFDb250YWluZXIubGlua3MsXHJcbiAgICAgICAgICAgIGZvY3VzRWxlbWVudDogX2ZvY3VzRWxlbWVudCxcclxuICAgICAgICAgICAgdmlld0ZyYW1lczogX2xpbmVhZ2VEaWFncmFtLmdldFZpZXdGcmFtZXMoKS5maWx0ZXIodmYgPT4gdmYuaWQgIT09IG92ZXJWaWV3RnJhbWUuaWQpLFxyXG4gICAgICAgICAgICBzZWxlY3RlZEVsZW1lbnQ6IF9zZWxlY3RlZEVsZW1lbnQsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBSZXN0b3JlcyBkaWFncmFtIHVzaW5nIHRoZSBwYXNzZWQgc3RhdGUuXHJcbiAgICAgKiBAcGFyYW0ge0hpc3RvcnlTdGF0ZX0gc3RhdGUgLSB0YXJnZXQgc3RhdGVcclxuICAgICovXHJcbiAgICBmdW5jdGlvbiBfbG9hZFN0YXRlIChzdGF0ZSkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIF9zZXREaWFncmFtU3RhdGUoJ3JlbmRlcmluZycpO1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFDb250YWluZXIgPSBuZXcgRGF0YUNvbnRhaW5lcih7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZXM6IHN0YXRlLm5vZGVzLFxyXG4gICAgICAgICAgICAgICAgICAgIGxpbmtzOiBzdGF0ZS5saW5rcyxcclxuICAgICAgICAgICAgICAgIH0sIF9wYXJhbWV0ZXJzKTtcclxuXHJcbiAgICAgICAgICAgICAgICBfdXBkYXRlQ29tcG9uZW50cyhkYXRhQ29udGFpbmVyLCBzdGF0ZS52aWV3RnJhbWVzKTtcclxuXHJcbiAgICAgICAgICAgICAgICBfZGF0YUNvbnRhaW5lciA9IGRhdGFDb250YWluZXI7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgZWxlbWVudFRvU2VsZWN0ID0gc3RhdGUuc2VsZWN0ZWRFbGVtZW50ID09PSB1bmRlZmluZWQgP1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmZvY3VzRWxlbWVudCA6IHN0YXRlLnNlbGVjdGVkRWxlbWVudDtcclxuICAgICAgICAgICAgICAgIF9mb2N1c0VsZW1lbnQgPSBzdGF0ZS5mb2N1c0VsZW1lbnQ7XHJcblxyXG4gICAgICAgICAgICAgICAgX3NlbGVjdGVkRWxlbWVudCA9IGVsZW1lbnRUb1NlbGVjdDtcclxuICAgICAgICAgICAgICAgIF9zZXRTZWxlY3RlZEVsZW1lbnQoZWxlbWVudFRvU2VsZWN0KTtcclxuICAgICAgICAgICAgICAgIF9zZXREaWFncmFtU3RhdGUoJ2NvbXBsZXRlZCcpO1xyXG5cclxuICAgICAgICAgICAgICAgIHNlbGYudHJpZ2dlcignZm9jdXMtbm9kZS1jaGFuZ2VkJywgX2dldE1vZGVsKHN0YXRlLmZvY3VzRWxlbWVudCkpO1xyXG4gICAgICAgICAgICAgICAgc2VsZi50cmlnZ2VyKCdoaXN0b3J5LXN0YXRlLWNoYW5nZWQnLCBfc3RhdGVTdG9yYWdlLmdldEhpc3RvcnkoKSk7XHJcbiAgICAgICAgICAgIH0sIDApO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIF9zZXREaWFncmFtU3RhdGUoJ2Vycm9yJyk7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXJyb3IgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IubWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yLnN0YWNrKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBDaGFuZ2VzIHNjYWxlIG9mIHRoZSBtYWluIHZpZXcgdG8gYmUgYWJsZSB0byBmaXQgd2hvbGUgZGlhZ3JhbSBpbiB0aGUgc2NyZWVuLlxyXG4gICAgKi9cclxuICAgIGZ1bmN0aW9uIF96b29tVG9GaXQgKCkge1xyXG4gICAgICAgIF9saW5lYWdlRGlhZ3JhbS56b29tVG9GaXQoKTtcclxuICAgICAgICBpZiAoX2dyYXBoTWFwKSBfZ3JhcGhNYXAucmVkcmF3KHtcclxuICAgICAgICAgICAgdmlld0ZyYW1lczogX2xpbmVhZ2VEaWFncmFtLmdldFZpZXdGcmFtZXMoKSxcclxuICAgICAgICAgICAgc2NhbGU6IF9saW5lYWdlRGlhZ3JhbS5zY2FsZSgpLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIENyZWF0ZXMgZGF0YUNvbnRhaW5lciAoZGlhZ3JhbSBtb2RlbCkgdXNpbmcgcGFzc2VkIHJhdyBkYXRhLlxyXG4gICAgICogQHBhcmFtIHtTZXJ2ZXJEYXRhfSByYXdEYXRhIC0gZGF0YVxyXG4gICAgICogQHBhcmFtIHtWaWV3RnJhbWVEZWZpbml0aW9uW119IHZpZXdGcmFtZXMgLSBWaWV3IGZyYW1lIGRlZmVuaXRpb25zXHJcbiAgICAqL1xyXG4gICAgZnVuY3Rpb24gX2NyZWF0ZURhdGFDb250YWluZXIgKHJhd0RhdGEsIHZpZXdGcmFtZXMpIHtcclxuICAgICAgICAvLyBpZiB3ZSBkb24ndCBnZXQgYW55IGRhdGEsIHdlIGNyZWF0ZSBhbiBlbXB0eSBkYXRhdFxyXG4gICAgICAgIGlmICghcmF3RGF0YSkgcmF3RGF0YSA9IHsgbm9kZXM6IFtdLCBsaW5rczogW10gfTtcclxuICAgICAgICBpZiAoIXJhd0RhdGEubm9kZXMpIHJhd0RhdGEubm9kZXMgPSBbXTtcclxuICAgICAgICBpZiAoIXJhd0RhdGEubGlua3MpIHJhd0RhdGEubGlua3MgPSBbXTtcclxuXHJcbiAgICAgICAgLy8gVGhlIGZ1bmN0aW9uIGZpbHRlcnMgdGhlIGRhdGEsIHNldHMgYXV0aG9yaXRpZXMgYW5kIGNvbGxhcHNlcyBsaW5rcy5cclxuICAgICAgICBjb25zdCBkYXRhID0gcHJvY2Vzc0RhdGEocmF3RGF0YSk7XHJcbiAgICAgICAgLy8gRmluZCBhbmQgc2V0IHBsYWNlIGZvciBlYWNoIGVsZW1lbnQgb2YgdGhlIGRhdGEgc2V0XHJcbiAgICAgICAgbGF5b3V0LmRvTGF5b3V0KFxyXG4gICAgICAgICAgICBkYXRhLm5vZGVzLFxyXG4gICAgICAgICAgICBkYXRhLmxpbmtzLFxyXG4gICAgICAgICAgICB2aWV3RnJhbWVzLFxyXG4gICAgICAgICAgICBfcGFyYW1ldGVycyxcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICAvLyBUaGlzIHR3byBsaW5lcyBjcmVhdGUgbm9kZXMgYW5kIGxpbmtzIGZyb20gZGF0YSBtb2RlbHNcclxuICAgICAgICBjb25zdCBqb2ludE5vZGVzID0gY3JlYXRlSm9pbnROb2RlcyhkYXRhLm5vZGVzLCBfcGFyYW1ldGVycyk7XHJcbiAgICAgICAgY29uc3Qgam9pbnRMaW5rcyA9IGNyZWF0ZUpvaW50TGlua3MoZGF0YS5saW5rcywgam9pbnROb2RlcywgIF9wYXJhbWV0ZXJzKTtcclxuXHJcbiAgICAgICAgY3JlYXRlQXNwZWN0UmVsYXRpb25zKGpvaW50Tm9kZXMpO1xyXG5cclxuICAgICAgICAvLyBVcGRhdGUgZGF0YSBjb250YWluZXIgYnkgbmV3IG5vZGVzIGFuZCBsaW5rc1xyXG4gICAgICAgIHJldHVybiBuZXcgRGF0YUNvbnRhaW5lcih7XHJcbiAgICAgICAgICAgIG5vZGVzOiBqb2ludE5vZGVzLFxyXG4gICAgICAgICAgICBsaW5rczogam9pbnRMaW5rcyxcclxuICAgICAgICB9LCBfcGFyYW1ldGVycyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsaXplcyAob3IgcmVmcmVzaGVzIGlmIG5vdCB0aGUgZmlyc3QgdGltZSlcclxuICAgICAqIHRoZSBMaW5lYWdlR3JhbSAtIENyZWF0ZXMgKFJlZnJlc2hlcykgdGhlIG1haW4gdmlld3MuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBfY3JlYXRlQ29tcG9uZW50cyAoKSB7XHJcbiAgICAgICAgY29uc3QgZW1wdHlEYXRhQ29udGFpbmVyID0gbmV3IERhdGFDb250YWluZXIgKHtcclxuICAgICAgICAgICAgbm9kZXM6IFtdLFxyXG4gICAgICAgICAgICBsaW5rczogW10sXHJcbiAgICAgICAgfSwgX3BhcmFtZXRlcnMpO1xyXG4gICAgICAgIGNvbnN0IGVtcHR5TGlzdCA9IFtdO1xyXG4gICAgICAgIC8vIENyZWF0ZXMgdGhlIGZpcnN0IHZpZXcgLSBMaW5lYWdlRGlhZ3JhbVxyXG4gICAgICAgIF9jcmVhdGVMaW5lYWdlRGlhZ3JhbShlbXB0eURhdGFDb250YWluZXIsIGVtcHR5TGlzdCk7XHJcbiAgICAgICAgLy8gQ3JlYXRlcyBhIHNpZ21hIGdyYXBoIG1hcCBvbiB0aGUgcHJpdmF0ZSByb290LlxyXG4gICAgICAgIC8vIF9jcmVhdGVNYXAoZW1wdHlEYXRhQ29udGFpbmVyLCBlbXB0eUxpc3QpO1xyXG4gICAgICAgIC8vIENyZWF0ZXMgdGhlIHNlY29uZCB2aWV3IC0gQmlyZEV5ZSAoSGlzdG9yaWNhbGx5IC0gU2lnbWFQYXRoVmlldylcclxuICAgICAgICBfY3JlYXRlQmlyZEV5ZShlbXB0eURhdGFDb250YWluZXIpO1xyXG4gICAgICAgIF9jcmVhdGVEZXJpdmF0aW9uTWFwKF9kYXRhUHJvdmlkZXIpO1xyXG5cclxuICAgICAgICBfYWRkSG92ZXJIYW5kbGVyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIChvciByZWZyZXNoZXMgaWYgbm90IHRoZSBmaXJzdCB0aW1lKVxyXG4gICAgICogdGhlIExpbmVhZ2VHcmFtIC0gQ3JlYXRlcyAoUmVmcmVzaGVzKSB0aGUgbWFpbiB2aWV3cy5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIF91cGRhdGVDb21wb25lbnRzIChkYXRhQ29udGFpbmVyLCB2aWV3RnJhbWVzKSB7XHJcbiAgICAgICAgLy8gVXBkYXRlcyB0aGUgZmlyc3QgdmlldyAtIExpbmVhZ2VEaWFncmFtXHJcbiAgICAgICAgX3VwZGF0ZUxpbmVhZ2VEaWFncmFtKGRhdGFDb250YWluZXIsIHZpZXdGcmFtZXMpO1xyXG4gICAgICAgIC8vIFVwZGF0ZXMgYSBzaWdtYSBncmFwaCBtYXAgb24gdGhlIHByaXZhdGUgcm9vdC5cclxuICAgICAgICBfdXBkYXRlTWFwKGRhdGFDb250YWluZXIsIF9saW5lYWdlRGlhZ3JhbS5nZXRWaWV3RnJhbWVzKCkpO1xyXG4gICAgICAgIC8vIFVwZGF0ZXMgdGhlIHNlY29uZCB2aWV3IC0gQmlyZEV5ZSAoSGlzdG9yaWNhbGx5IC0gU2lnbWFQYXRoVmlldylcclxuICAgICAgICBfdXBkYXRlQmlyZEV5ZShkYXRhQ29udGFpbmVyKTtcclxuXHJcbiAgICAgICAgX3pvb21Ub0ZpdCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIElubmVyIGZ1bmN0aW9uc1xyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgZnVuY3Rpb24gX2NyZWF0ZUxpbmVhZ2VEaWFncmFtIChkYXRhQ29udGFpbmVyLCB2aWV3RnJhbWVzKSB7XHJcbiAgICAgICAgX2xpbmVhZ2VEaWFncmFtID0gbmV3IExpbmVhZ2VEaWFncmFtKHtcclxuICAgICAgICAgICAgZ3JhcGhQbGFjZTogX2Jhc2UubGluZWFnZURpYWdyYW0sXHJcbiAgICAgICAgICAgIGRhdGFDb250YWluZXI6IGRhdGFDb250YWluZXIsXHJcbiAgICAgICAgICAgIHZpZXdGcmFtZXM6IHZpZXdGcmFtZXMsXHJcbiAgICAgICAgICAgIGZ1bGxTY3JlZW5Nb2RlOiBfcGFyYW1ldGVycy5mdWxsU2NyZWVuTW9kZSxcclxuICAgICAgICB9LCBfcGFyYW1ldGVycyk7XHJcblxyXG4gICAgICAgIF9saW5lYWdlRGlhZ3JhbS5vbignc2VsZWN0ZWQtZWxlbWVudC1jaGFuZ2VkJywgKGV2ZW50T2JqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChfc3RhdGUgIT09ICdjb21wbGV0ZWQnKSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICBpZiAoX2N1cnJlbnRWaWV3ID09PSAnbGluZWFnZURpYWdyYW0nICYmIF9zdGF0ZSA9PT0gJ2NvbXBsZXRlZCcpIHtcclxuICAgICAgICAgICAgICAgIGlmIChfZ3JhcGhNYXApIF9ncmFwaE1hcC5zZXRTZWxlY3RlZEVsZW1lbnQoZXZlbnRPYmplY3QpO1xyXG4gICAgICAgICAgICAgICAgX3NlbGVjdGVkRWxlbWVudCA9IGdldEJhc2VFbGVtZW50KGV2ZW50T2JqZWN0KTtcclxuICAgICAgICAgICAgICAgIHNlbGYudHJpZ2dlcignc2VsZWN0ZWQtZWxlbWVudC1jaGFuZ2VkJywgX2dldE1vZGVsKF9zZWxlY3RlZEVsZW1lbnQpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBfbGluZWFnZURpYWdyYW0ub24oJ3NjYWxlLWNoYW5nZWQnLCAobmV3U2NhbGUpID0+IHtcclxuICAgICAgICAgICAgaWYgKF9zdGF0ZSAhPT0gJ2NvbXBsZXRlZCcpIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIGlmIChfZ3JhcGhNYXApIF9ncmFwaE1hcC5yZWRyYXcoe1xyXG4gICAgICAgICAgICAgICAgdmlld0ZyYW1lczogX2xpbmVhZ2VEaWFncmFtLmdldFZpZXdGcmFtZXMoKSxcclxuICAgICAgICAgICAgICAgIHNjYWxlOiBuZXdTY2FsZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgc2VsZi50cmlnZ2VyKCdzY2FsZS12YWx1ZS1jaGFuZ2VkJywge1xyXG4gICAgICAgICAgICAgICAgbWluOiBfcGFyYW1ldGVycy5zY2FsZUJvdW5kcy5taW4sXHJcbiAgICAgICAgICAgICAgICBtYXg6IF9wYXJhbWV0ZXJzLnNjYWxlQm91bmRzLm1heCxcclxuICAgICAgICAgICAgICAgIGN1cjogX2xpbmVhZ2VEaWFncmFtLnNjYWxlKCksXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBfbGluZWFnZURpYWdyYW0ub24oJ3ZpZXctZnJhbWVzLXN0YXRlLWNoYW5nZWQnLCAodmlld0ZyYW1lcykgPT4ge1xyXG4gICAgICAgICAgICBpZiAoX3N0YXRlICE9PSAnY29tcGxldGVkJykgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgaWYgKF9ncmFwaE1hcCkge1xyXG4gICAgICAgICAgICAgICAgX2dyYXBoTWFwLnJlZHJhdyh7IHZpZXdGcmFtZXM6IHZpZXdGcmFtZXMgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2VsZi50cmlnZ2VyKCd2aWV3LWZyYW1lLXN0YXRlLWNoYW5nZWQnLCB2aWV3RnJhbWVzKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgX2xpbmVhZ2VEaWFncmFtLm9uKCd2aWV3LWZyYW1lcy1zaXplLW9yLXBvc2l0aW9uLWNoYW5nZWQnLCAodmlld0ZyYW1lcykgPT4ge1xyXG4gICAgICAgICAgICBpZiAoX3N0YXRlICE9PSAnY29tcGxldGVkJykgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgaWYgKF9ncmFwaE1hcCkge1xyXG4gICAgICAgICAgICAgICAgX2dyYXBoTWFwLnJlZHJhdyh7IHZpZXdGcmFtZXM6IHZpZXdGcmFtZXMgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgX2xpbmVhZ2VEaWFncmFtLm9uKCdub2Rlcy1wb3NpdGlvbi1jaGFuZ2VkJywgKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoX3N0YXRlICE9PSAnY29tcGxldGVkJykgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgaWYgKF9ncmFwaE1hcCkge1xyXG4gICAgICAgICAgICAgICAgX2dyYXBoTWFwLnJlZHJhdygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF9iaXJkRXllLnJlZHJhdygpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuXHJcblxyXG4gICAgICAgIF9saW5lYWdlRGlhZ3JhbS5vbignY2VsbC1kb3VibGUtY2xpY2snLCAoZXZlbnRPYmplY3QpID0+IHtcclxuICAgICAgICAgICAgaWYgKF9zdGF0ZSAhPT0gJ2NvbXBsZXRlZCcpIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIGlmIChfY3VycmVudFZpZXcgPT09ICdsaW5lYWdlRGlhZ3JhbScpIHtcclxuICAgICAgICAgICAgICAgIGlmIChldmVudE9iamVjdCBpbnN0YW5jZW9mIGdyYXBoRWxlbWVudHMuTGluayB8fCBldmVudE9iamVjdCBpbnN0YW5jZW9mIGdyYXBoRWxlbWVudHMuVGVybWluYXRpb25MaW5rKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX2xpbmVhZ2VEaWFncmFtLnNldFNlbGVjdGVkRWxlbWVudChldmVudE9iamVjdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGluayA9IGV2ZW50T2JqZWN0Lm9yaWdpbmFsTGluayB8fCBldmVudE9iamVjdDtcclxuICAgICAgICAgICAgICAgICAgICBfc2hvd0Rlcml2YXRpb25NYXAobGluayk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgX2xpbmVhZ2VEaWFncmFtLm9uKCdsaW5rLW9wdGlvbnMtY2xpY2snLCAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgaWYgKF9zdGF0ZSAhPT0gJ2NvbXBsZXRlZCcpIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGxpbmsgPSBldmVudC5saW5rO1xyXG4gICAgICAgICAgICBjb25zdCBsaW5rVHlwZSA9IGV2ZW50LmxpbmtUeXBlO1xyXG4gICAgICAgICAgICBpZiAoX2N1cnJlbnRWaWV3ID09PSAnbGluZWFnZURpYWdyYW0nKSB7XHJcbiAgICAgICAgICAgICAgICBfc2hvd0Rlcml2YXRpb25NYXAobGluaywgbGlua1R5cGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX3VwZGF0ZUxpbmVhZ2VEaWFncmFtIChkYXRhQ29udGFpbmVyLCB2aWV3RnJhbWVzKSB7XHJcbiAgICAgICAgX2xpbmVhZ2VEaWFncmFtLnNldERhdGEoZGF0YUNvbnRhaW5lciwgdmlld0ZyYW1lcyk7XHJcbiAgICAgICAgX2xpbmVhZ2VEaWFncmFtLnNjYWxlKF9wYXJhbWV0ZXJzLmRlZmF1bHRTY2FsZSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX2FkZEhvdmVySGFuZGxlciAoKSB7XHJcbiAgICAgICAgLy8gSW5pdCB0aGUgdG9vbHRpcCB0b29sIGZvciB0ZXJtaW50YXRpb24gbm9kZXMuXHJcbiAgICAgICAgbmV3IGpvaW50LnVpLlRvb2x0aXAoe1xyXG4gICAgICAgICAgICByb290VGFyZ2V0OiBkb2N1bWVudC5ib2R5LFxyXG4gICAgICAgICAgICB0YXJnZXQ6ICcudGVybWluYXRpb24tbm9kZScsXHJcbiAgICAgICAgICAgIGRpcmVjdGlvbjogJ2F1dG8nLFxyXG4gICAgICAgICAgICBwYWRkaW5nOiAxNSxcclxuICAgICAgICAgICAgY29udGVudDogKGNlbGwgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNlbGwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3RleHQnKVswXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cmlidXRlcy50b29sdGlwLnZhbHVlO1xyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgbmV3IGpvaW50LnVpLlRvb2x0aXAoe1xyXG4gICAgICAgICAgICByb290VGFyZ2V0OiBkb2N1bWVudC5ib2R5LFxyXG4gICAgICAgICAgICB0YXJnZXQ6ICcudHEtbGctc2hvcnQtbGFiZWwnLFxyXG4gICAgICAgICAgICBkaXJlY3Rpb246ICdhdXRvJyxcclxuICAgICAgICAgICAgcGFkZGluZzogMTUsXHJcbiAgICAgICAgICAgIGNvbnRlbnQ6IChjZWxsID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjZWxsLmdldEVsZW1lbnRzQnlUYWdOYW1lKCd0ZXh0JylbMF1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHJpYnV0ZXMudG9vbHRpcC52YWx1ZTtcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX2NyZWF0ZURlcml2YXRpb25NYXAgKGRhdGFQcm92aWRlcikge1xyXG4gICAgICAgIF9kZXJpdmF0aW9uTWFwUGFuZWwgPSBuZXcgVFFHcmFtVUkuRmx5aW5nUGFuZWwoe1xyXG4gICAgICAgICAgICBiYXNlRWxlbWVudDogX2Jhc2UuZGVyaXZhdGlvbk1hcCxcclxuICAgICAgICAgICAgYWN0aXZlOiBmYWxzZSxcclxuICAgICAgICAgICAgaGVhZGVyOiAnRGVyaXZhdGlvbiBNYXAnLFxyXG4gICAgICAgICAgICBlbXB0eUJvZHk6IGZhbHNlLFxyXG4gICAgICAgICAgICBzaXplOiB7IHdpZHRoOiAnY2FsYygxMDAlIC0gMjAwcHgpJywgaGVpZ2h0OiAnY2FsYygxMDAlIC0gMjAwcHgpJ30sXHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiB7IHg6ICcxMDBweCcsIHk6ICcxMDBweCd9LFxyXG4gICAgICAgICAgICBib2R5OiAnJyxcclxuICAgICAgICAgICAgcmVzaXphYmxlOiB0cnVlLFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBfZGVyaXZhdGlvbk1hcFBhbmVsLm9uKCdzaXplLWNoYW5nZWQnLCAoKSA9PiBfZGVyaXZhdGlvbk1hcC5yZXNldEZvY3VzKCkpO1xyXG5cclxuICAgICAgICBfZGVyaXZhdGlvbk1hcCA9IG5ldyBEZXJpdmF0aW9uTWFwKHtcclxuICAgICAgICAgICAgcm9vdEVsZW1lbnQ6IF9kZXJpdmF0aW9uTWFwUGFuZWwucm9vdEh0bWwucXVlcnlTZWxlY3RvcignLnRxLXVpLWJvZHlfY29udGFpbmVyJyksXHJcbiAgICAgICAgICAgIGRhdGFQcm92aWRlcjogZGF0YVByb3ZpZGVyXHJcbiAgICAgICAgfSwgX3BhcmFtZXRlcnMuZGVyaXZhdGlvbk1hcCk7XHJcblxyXG4gICAgICAgIHNlbGYudHJpZ2dlcignZGVyaXZhdGlvbi1tYXAtc3RhdGUtY2hhbmdlZCcpO1xyXG4gICAgICAgIHNlbGYudHJpZ2dlcignZGVyaXZhdGlvbi1tYXAtc3RhdGUtaW5pdCcsX2Rlcml2YXRpb25NYXApO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIF9jcmVhdGVCaXJkRXllIChkYXRhQ29udGFpbmVyKSB7XHJcbiAgICAgICAgX2JpcmRFeWUgPSBuZXcgQmlyZEV5ZSh7XHJcbiAgICAgICAgICAgIGVsOiBfYmFzZS5zaWdtYUdyYXBoLFxyXG4gICAgICAgICAgICBzY2FsZTogX2xpbmVhZ2VEaWFncmFtLnNjYWxlKCksXHJcbiAgICAgICAgICAgIGRhdGFDb250YWluZXI6IGRhdGFDb250YWluZXIsXHJcbiAgICAgICAgfSwgX3BhcmFtZXRlcnMpO1xyXG5cclxuICAgICAgICBfYmlyZEV5ZS5vbignc2VsZWN0ZWQtZWxlbWVudC1jaGFuZ2VkJywgKGV2ZW50T2JqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChfc3RhdGUgIT09ICdjb21wbGV0ZWQnKSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICBpZiAoX2N1cnJlbnRWaWV3ID09PSAnYmlyZEV5ZScpIHtcclxuICAgICAgICAgICAgICAgIGlmIChfZ3JhcGhNYXApIF9ncmFwaE1hcC5zZXRTZWxlY3RlZEVsZW1lbnQoZXZlbnRPYmplY3QpO1xyXG4gICAgICAgICAgICAgICAgX3NlbGVjdGVkRWxlbWVudCA9IGdldEJhc2VFbGVtZW50KGV2ZW50T2JqZWN0KTtcclxuICAgICAgICAgICAgICAgIHNlbGYudHJpZ2dlcignc2VsZWN0ZWQtZWxlbWVudC1jaGFuZ2VkJywgX2dldE1vZGVsKF9zZWxlY3RlZEVsZW1lbnQpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBfYmlyZEV5ZS5vbignY2VsbC1kb3VibGUtY2xpY2snLCAoZXZlbnRPYmplY3QpID0+IHtcclxuICAgICAgICAgICAgaWYgKF9zdGF0ZSAhPT0gJ2NvbXBsZXRlZCcpIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIGlmIChfY3VycmVudFZpZXcgPT09ICdiaXJkRXllJykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50T2JqZWN0IGluc3RhbmNlb2YgZ3JhcGhFbGVtZW50cy5MaW5rIHx8IGV2ZW50T2JqZWN0IGluc3RhbmNlb2YgZ3JhcGhFbGVtZW50cy5UZXJtaW5hdGlvbkxpbmspIHtcclxuICAgICAgICAgICAgICAgICAgICBfYmlyZEV5ZS5zZXRTZWxlY3RlZEVsZW1lbnQoZXZlbnRPYmplY3QpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxpbmtzID0gZXZlbnRPYmplY3Qub3JpZ2luYWxMaW5rIHx8IGV2ZW50T2JqZWN0O1xyXG4gICAgICAgICAgICAgICAgICAgIF9zaG93RGVyaXZhdGlvbk1hcChsaW5rcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfdXBkYXRlQmlyZEV5ZSAoZGF0YUNvbnRhaW5lcikge1xyXG4gICAgICAgIF9iaXJkRXllLnNldERhdGEoZGF0YUNvbnRhaW5lcik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIHRoZSBtYXAgSWYgbm90IGNyZWF0ZWQuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtEYXRhQ29udGFpbmVyfSBkYXRhQ29udGFpbmVyXHJcbiAgICAgKiBAcGFyYW0ge1ZpZXdGcmFtZVB1YmxpY01vZGVsW119IHZpZXdGcmFtZXNcclxuICAgICAqIEByZXR1cm5zIHtWaWV3RnJhbWVbXX1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gX2NyZWF0ZU1hcCAoZGF0YUNvbnRhaW5lciwgdmlld0ZyYW1lcykge1xyXG4gICAgICAgIGlmIChfYmFzZS5tYXBIVE1MRWxlbWVudCkge1xyXG4gICAgICAgICAgICBfZ3JhcGhNYXAgPSAgbmV3IEdyYXBoTWFwKHtcclxuICAgICAgICAgICAgICAgIGVsOiBfYmFzZS5tYXBIVE1MRWxlbWVudCxcclxuICAgICAgICAgICAgICAgIHNjYWxlOiBfbGluZWFnZURpYWdyYW0uc2NhbGUoKSxcclxuICAgICAgICAgICAgICAgIHZpZXdGcmFtZXM6IHZpZXdGcmFtZXMsXHJcbiAgICAgICAgICAgICAgICBkYXRhQ29udGFpbmVyOiBkYXRhQ29udGFpbmVyLFxyXG4gICAgICAgICAgICB9LCBfcGFyYW1ldGVycyk7XHJcblxyXG4gICAgICAgICAgICBfZ3JhcGhNYXAub24oJ3NlbGVjdGVkLWVsZW1lbnQtY2hhbmdlZCcsIChub2RlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoX3N0YXRlICE9PSAnY29tcGxldGVkJykgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChfY3VycmVudFZpZXcgPT09ICdsaW5lYWdlRGlhZ3JhbScpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBub2RlSXNJbnZpc2libGUgPSBfbGluZWFnZURpYWdyYW0uZ2V0VmlzaWJsZU5vZGVzKCkuaW5kZXhPZihub2RlKSA9PT0gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgX2xpbmVhZ2VEaWFncmFtLnNldFNlbGVjdGVkRWxlbWVudChub2RlLCBub2RlSXNJbnZpc2libGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKF9jdXJyZW50VmlldyA9PT0gJ2JpcmRFeWUnKSBfYmlyZEV5ZS5zZXRTZWxlY3RlZEVsZW1lbnQobm9kZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgX3NlbGVjdGVkRWxlbWVudCA9IGdldEJhc2VFbGVtZW50KG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgc2VsZi50cmlnZ2VyKCdzZWxlY3RlZC1lbGVtZW50LWNoYW5nZWQnLCBfZ2V0TW9kZWwoX3NlbGVjdGVkRWxlbWVudCkpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIF9ncmFwaE1hcC5vbigndmlldy1mcmFtZXMtcG9zaXRpb24tY2hhbmdlZCcsICh2aWV3RnJhbWVzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoX3N0YXRlICE9PSAnY29tcGxldGVkJykgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh2aWV3RnJhbWVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgbGV0IGluZGV4ID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgICByZWN1cnNpb24odmlld0ZyYW1lc1tpbmRleCsrXSk7XHJcblxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gcmVjdXJzaW9uICh2aWV3RnJhbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBfbGluZWFnZURpYWdyYW0ucG9zaXRpb25WaWV3UG9ydChcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmlld0ZyYW1lLCB2aWV3RnJhbWUudmlld1BvcnRQb3NpdGlvbiwgX3BhcmFtZXRlcnMuYW5pbWF0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmlld0ZyYW1lW2luZGV4XSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY3Vyc2lvbih2aWV3RnJhbWVzW2luZGV4KytdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIF9ncmFwaE1hcDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhlIG1hcC5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge0RhdGFDb250YWluZXJ9IGRhdGFDb250YWluZXJcclxuICAgICAqIEBwYXJhbSB7Vmlld0ZyYW1lUHVibGljTW9kZWxbXX0gdmlld0ZyYW1lc1xyXG4gICAgICogQHJldHVybnMge1ZpZXdGcmFtZVtdfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBfdXBkYXRlTWFwIChkYXRhQ29udGFpbmVyLCB2aWV3RnJhbWVzKSB7XHJcbiAgICAgICAgaWYgKF9ncmFwaE1hcCkge1xyXG4gICAgICAgICAgICBfZ3JhcGhNYXAuc2V0RGF0YShkYXRhQ29udGFpbmVyLCB2aWV3RnJhbWVzKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBfY3JlYXRlTWFwKGRhdGFDb250YWluZXIsIHZpZXdGcmFtZXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0xpbmt8Tm9kZXxUZXJtaW5hdGlvbkxpbmt8VGVybWluYXRpb25Ob2RlfSBlbGVtZW50XHJcbiAgICAgKiBAcmV0dXJucyB7UHVibGljTm9kZU1vZGVsfFB1YmxpY0xpbmtNb2RlbH1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gX2dldE1vZGVsIChlbGVtZW50KSB7XHJcbiAgICAgICAgaWYgKCFlbGVtZW50KSByZXR1cm47XHJcblxyXG4gICAgICAgIGNvbnN0IGVsZW1lbnRNb2RlbCA9IF8uY2xvbmVEZWVwKGVsZW1lbnQubW9kZWwpO1xyXG4gICAgICAgIGVsZW1lbnRNb2RlbC5ibHVyZWQgPSBCb29sZWFuKGVsZW1lbnQuZ2V0KCdibHVyZWQnKSk7XHJcbiAgICAgICAgZWxlbWVudE1vZGVsLmhpZ2hsaWdodGVkID0gQm9vbGVhbihlbGVtZW50LmdldCgnaGlnaGxpZ2h0ZWQnKSk7XHJcblxyXG4gICAgICAgIGlmIChlbGVtZW50IGluc3RhbmNlb2YgZ3JhcGhFbGVtZW50cy5Ob2RlKSB7XHJcbiAgICAgICAgICAgIGVsZW1lbnRNb2RlbC5kaWFncmFtVHlwZSA9ICdub2RlJztcclxuICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBncmFwaEVsZW1lbnRzLkxpbmspIHtcclxuICAgICAgICAgICAgZWxlbWVudE1vZGVsLnNvdXJjZSA9IGVsZW1lbnRNb2RlbC5zb3VyY2VUeXBlO1xyXG4gICAgICAgICAgICBlbGVtZW50TW9kZWwudGFyZ2V0ID0gZWxlbWVudE1vZGVsLnRhcmdldFR5cGU7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBlbGVtZW50TW9kZWwuc291cmNlVHlwZTtcclxuICAgICAgICAgICAgZGVsZXRlIGVsZW1lbnRNb2RlbC50YXJnZXRUeXBlO1xyXG4gICAgICAgICAgICBlbGVtZW50TW9kZWwuZGlhZ3JhbVR5cGUgPSAnbGluayc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBlbGVtZW50TW9kZWw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPcGVucyBkZXJpdmF0aW9uIG1hcCB3aW5kb3cuXHJcbiAgICAgKiBAcGFyYW0ge0xpbmt9IGxpbmtcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsaW5rVHlwZVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gX3Nob3dEZXJpdmF0aW9uTWFwIChsaW5rLCBsaW5rVHlwZSkge1xyXG4gICAgICAgIGlmIChsaW5rIGluc3RhbmNlb2YgZ3JhcGhFbGVtZW50cy5MaW5rKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vZGVNYXAgPSBfZGF0YUNvbnRhaW5lci5tYXBzLm5vZGVNYXA7XHJcbiAgICAgICAgICAgIF9kZXJpdmF0aW9uTWFwLm9wZW5XaXRoUmVsYXRpb24oe1xyXG4gICAgICAgICAgICAgICAgc291cmNlOiBub2RlTWFwW2xpbmsubW9kZWwuc291cmNlXS5tb2RlbCxcclxuICAgICAgICAgICAgICAgIHRhcmdldDogbm9kZU1hcFtsaW5rLm1vZGVsLnRhcmdldF0ubW9kZWwsXHJcbiAgICAgICAgICAgICAgICBsaW5rVHlwZTogbGlua1R5cGUsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBfZGVyaXZhdGlvbk1hcFBhbmVsLnNob3coKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHN0YXRlIG9mIGluZGljYXRvclxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdGF0ZSAtIGZldGNoaW5nIHwgcmVuZGVyaW5nIHwgY29tcGxldGVkIHwgZXJyb3JcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIC0gQ3VzdG9tIG1lc3NhZ2VcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gX3NldERpYWdyYW1TdGF0ZSAoc3RhdGUsIG1lc3NhZ2UpIHtcclxuICAgICAgICBfc3RhdGUgPSBzdGF0ZTtcclxuXHJcbiAgICAgICAgaWYgKHN0YXRlID09PSAnZmV0Y2hpbmcnKSB7XHJcbiAgICAgICAgICAgIF9wcm9ncmVzc1NjcmVlbi5zZXRTdGF0ZSgnYWN0aXZlJywgbWVzc2FnZSB8fCAnRmV0Y2hpbmcgZGF0YScpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09ICdyZW5kZXJpbmcnKSB7XHJcbiAgICAgICAgICAgIF9wcm9ncmVzc1NjcmVlbi5zZXRTdGF0ZSgnYWN0aXZlJywgbWVzc2FnZSB8fCAnUmVuZGVyaW5nIGdyYXBoJyk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gJ2NvbXBsZXRlZCcpIHtcclxuICAgICAgICAgICAgX3Byb2dyZXNzU2NyZWVuLnNldFN0YXRlKCdjb21wbGV0ZWQnKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSAnZXJyb3InKSB7XHJcbiAgICAgICAgICAgIF9wcm9ncmVzc1NjcmVlbi5zZXRTdGF0ZSgnZXJyb3InLCBtZXNzYWdlIHx8ICdFcnJvciBoYXMgb2NjdXJyZWQhJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNlbGYudHJpZ2dlcignZGlhZ3JhbS1zdGF0ZS1jaGFuZ2VkJywgc3RhdGUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBodG1sIG1hcmt1cC5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBodG1sTm9kZSAtIFJvb3Qgbm9kZSBmb3IgbWFya3VwXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsIEhUTUxFbGVtZW50Pn0gLSBNYXAgb2YgaHRtbCBlbGVtZW50c1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBfY3JlYXRlQmFzZSAoaHRtbE5vZGUpIHtcclxuICAgICAgICBodG1sTm9kZS5pbm5lckhUTUwgPSAnJztcclxuICAgICAgICBodG1sTm9kZS50YWJJbmRleCA9IDE7XHJcblxyXG4gICAgICAgIGNvbnN0IGJhc2VEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTtcclxuICAgICAgICBiYXNlRGl2LmNsYXNzTmFtZSA9ICd0cV9saW5lYWdlJztcclxuICAgICAgICBiYXNlRGl2LmlkID0gJ3RxX2xpbmVhZ2UnO1xyXG4gICAgICAgIGh0bWxOb2RlLmFwcGVuZENoaWxkKGJhc2VEaXYpO1xyXG5cclxuICAgICAgICBjb25zdCBsaW5lYWdlRGlhZ3JhbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO1xyXG4gICAgICAgIGxpbmVhZ2VEaWFncmFtLmNsYXNzTmFtZSA9ICd0cV9saW5lYWdlX19ncmFwaCc7XHJcbiAgICAgICAgbGluZWFnZURpYWdyYW0uaWQgPSAndHFfbGluZWFnZS1ncmFwaCc7XHJcbiAgICAgICAgYmFzZURpdi5hcHBlbmRDaGlsZChsaW5lYWdlRGlhZ3JhbSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHNpZ21hR3JhcGggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTtcclxuICAgICAgICBzaWdtYUdyYXBoLmNsYXNzTmFtZSA9ICd0cV9saW5lYWdlX19zaWdtYV9ncmFwaCc7XHJcbiAgICAgICAgc2lnbWFHcmFwaC5pZCA9ICd0cV9saW5lYWdlLXNpZ21hLWdyYXBoJztcclxuICAgICAgICBiYXNlRGl2LmFwcGVuZENoaWxkKHNpZ21hR3JhcGgpO1xyXG5cclxuICAgICAgICBjb25zdCBkZXJpdmF0aW9uTWFwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7XHJcbiAgICAgICAgYmFzZURpdi5hcHBlbmRDaGlsZChkZXJpdmF0aW9uTWFwKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgY29udGFpbmVyOiBodG1sTm9kZSxcclxuICAgICAgICAgICAgYmFzZURpdjogYmFzZURpdixcclxuICAgICAgICAgICAgbGluZWFnZURpYWdyYW06IGxpbmVhZ2VEaWFncmFtLFxyXG4gICAgICAgICAgICBzaWdtYUdyYXBoOiBzaWdtYUdyYXBoLFxyXG4gICAgICAgICAgICBkZXJpdmF0aW9uTWFwOiBkZXJpdmF0aW9uTWFwLFxyXG4gICAgICAgICAgICBtYXBIVE1MRWxlbWVudDogX2dldE1hcEhUTUwoX3BhcmFtZXRlcnMubWFwUm9vdEh0bWwpLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQ3JlYXRlcyBodG1sIG1hcmt1cCBmb3IgbWFwLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd8SFRNTEVsZW1lbnR9IG1hcFJvb3RIdG1sIC0gSUQgb2Ygcm9vdCBlbGVtZW50IG9yIEhUTUxFbGVtZW50XHJcbiAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIF9nZXRNYXBIVE1MIChtYXBSb290SHRtbCkge1xyXG4gICAgICAgIGxldCBtYXBSb290SHRtbEh0bWw7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBtYXBSb290SHRtbCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgbWFwUm9vdEh0bWxIdG1sID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobWFwUm9vdEh0bWwpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG1hcFJvb3RIdG1sID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICBtYXBSb290SHRtbEh0bWwgPSBtYXBSb290SHRtbDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4ge307XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgbWFwSFRNTEVsZW1lbnQ7XHJcbiAgICAgICAgaWYgKG1hcFJvb3RIdG1sSHRtbCkgeyAvLyBjaGVjayBlbGVtZW50XHJcbiAgICAgICAgICAgIC8vIENsZWFyIGEgY29udGVudCBvZiB0aGUgbWFwIHJvb3QgaHRtbCBlbGVtZW50XHJcbiAgICAgICAgICAgIG1hcFJvb3RIdG1sSHRtbC5pbm5lckhUTUwgPSAnJztcclxuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgcHJpdmF0ZSByb290IGZvciBtYXAgaW50byB0aGUgcHVibGljIHJvb3QuXHJcbiAgICAgICAgICAgIC8vIChVc2VyIGNhbiBjaGFuZ2Ugc3R5bGUgb2YgcHVibGljIHJvb3QpXHJcbiAgICAgICAgICAgIG1hcEhUTUxFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7XHJcbiAgICAgICAgICAgIG1hcEhUTUxFbGVtZW50LmNsYXNzTmFtZSA9ICd0cS1sZ19fbWFwJztcclxuICAgICAgICAgICAgbWFwUm9vdEh0bWxIdG1sLmFwcGVuZENoaWxkKG1hcEhUTUxFbGVtZW50KTsgLy8gYWRkaW5nIHRoZSBwcml2YXRlIHJvb3QgaW50byB0aGUgcHVibGljXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtYXBIVE1MRWxlbWVudDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBNYWtlcyB0aGUgdmlldy0xIHZpc2libGUgYW5kIHRoZSB2aWV3LTIgaW52aXNpYmxlLlxyXG4gICAgICogQGZpcmVzIGN1cnJlbnQtdmlldy1jaGFuZ2VkXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIF9zaG93U2lnbWFHcmFwaCAoKSB7XHJcbiAgICAgICAgX2Jhc2Uuc2lnbWFHcmFwaC5zdHlsZS5vcGFjaXR5ID0gMTtcclxuICAgICAgICBfYmFzZS5zaWdtYUdyYXBoLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnYXV0byc7XHJcblxyXG4gICAgICAgIF9iYXNlLmxpbmVhZ2VEaWFncmFtLnN0eWxlLm9wYWNpdHkgPSAwO1xyXG4gICAgICAgIF9iYXNlLmxpbmVhZ2VEaWFncmFtLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XHJcblxyXG4gICAgICAgIGlmIChfc3RhdGUgPT09ICdjb21wbGV0ZWQnKSB7XHJcbiAgICAgICAgICAgIGlmIChfY3VycmVudFZpZXcgIT09ICdub25lJykge1xyXG4gICAgICAgICAgICAgICAgX2JpcmRFeWUuc2V0U2VsZWN0ZWRFbGVtZW50KF9saW5lYWdlRGlhZ3JhbS5nZXRTZWxlY3RlZEVsZW1lbnQoKSk7XHJcbiAgICAgICAgICAgICAgICBfYmlyZEV5ZS5yZWZyZXNoKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBfbGluZWFnZURpYWdyYW0ucmVzaXplKCk7XHJcbiAgICAgICAgICAgICAgICBfYmlyZEV5ZS5zaWdtYUdyYXBoLnJlZnJlc2goKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgX2N1cnJlbnRWaWV3ID0gJ2JpcmRFeWUnO1xyXG4gICAgICAgIHNlbGYudHJpZ2dlcignY3VycmVudC12aWV3LWNoYW5nZWQnLCBfY3VycmVudFZpZXcpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIE1ha2VzIHRoZSB2aWV3LTIgdmlzaWJsZSBhbmQgdGhlIHZpZXctMSBpbnZpc2libGUuXHJcbiAgICAgKiBAZmlyZXMgY3VycmVudC12aWV3LWNoYW5nZWRcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gX3Nob3dKb2ludEdyYXBoICgpIHtcclxuICAgICAgICBfYmFzZS5zaWdtYUdyYXBoLnN0eWxlLm9wYWNpdHkgPSAwO1xyXG4gICAgICAgIF9iYXNlLnNpZ21hR3JhcGguc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcclxuXHJcbiAgICAgICAgX2Jhc2UubGluZWFnZURpYWdyYW0uc3R5bGUub3BhY2l0eSA9IDE7XHJcbiAgICAgICAgX2Jhc2UubGluZWFnZURpYWdyYW0uc3R5bGUucG9pbnRlckV2ZW50cyA9ICdhdXRvJztcclxuXHJcbiAgICAgICAgaWYgKF9zdGF0ZSA9PT0gJ2NvbXBsZXRlZCcpIHtcclxuICAgICAgICAgICAgaWYgKF9jdXJyZW50VmlldyAhPT0gJ25vbmUnKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoX2JpcmRFeWUuc2VsZWN0ZWRFbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmlzaWJsZU5vZGVzID0gX2xpbmVhZ2VEaWFncmFtLmdldFZpc2libGVOb2RlcygpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzU2VsZWN0ZWROb2RlID0gX2JpcmRFeWUuc2VsZWN0ZWRFbGVtZW50IGluc3RhbmNlb2YgZ3JhcGhFbGVtZW50cy5Ob2RlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVJc0ludmlzaWJsZSA9IHZpc2libGVOb2Rlcy5pbmRleE9mKF9iaXJkRXllLnNlbGVjdGVkRWxlbWVudCkgPT09IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzU2VsZWN0ZWRMaW5rID0gX2JpcmRFeWUuc2VsZWN0ZWRFbGVtZW50IGluc3RhbmNlb2YgZ3JhcGhFbGVtZW50cy5MaW5rO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFsbE9mVGhlRW5kc0lzSW52aXNpYmxlID0gdmlzaWJsZU5vZGVzLmluZGV4T2YoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9kYXRhQ29udGFpbmVyLm1hcHMubm9kZU1hcFtfYmlyZEV5ZS5zZWxlY3RlZEVsZW1lbnQubW9kZWwuc291cmNlXVxyXG4gICAgICAgICAgICAgICAgICAgICkgPT09IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZvY3VzT24gPSBpc1NlbGVjdGVkTm9kZSAmJiBub2RlSXNJbnZpc2libGUgfHwgaXNTZWxlY3RlZExpbmsgJiYgYWxsT2ZUaGVFbmRzSXNJbnZpc2libGU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIF9saW5lYWdlRGlhZ3JhbS5zZXRTZWxlY3RlZEVsZW1lbnQoX2JpcmRFeWUuc2VsZWN0ZWRFbGVtZW50LCBmb2N1c09uKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX2xpbmVhZ2VEaWFncmFtLnJlZHJhdygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgX2xpbmVhZ2VEaWFncmFtLnJlc2l6ZSgpO1xyXG4gICAgICAgICAgICAgICAgX2xpbmVhZ2VEaWFncmFtLnJlZHJhdygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBfY3VycmVudFZpZXcgPSAnbGluZWFnZURpYWdyYW0nO1xyXG4gICAgICAgIHNlbGYudHJpZ2dlcignY3VycmVudC12aWV3LWNoYW5nZWQnLCBfY3VycmVudFZpZXcpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIE1ha2VzIHRoZSB2aWV3LTIgYW5kIHRoZSB2aWV3LTEgaW52aXNpYmxlLlxyXG4gICAgICogQGZpcmVzIGN1cnJlbnQtdmlldy1jaGFuZ2VkXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIF9oaWRlVmlld3MgKCkge1xyXG4gICAgICAgIC8vIF9iYXNlLmNvbnRhaW5lci5jbGFzc05hbWUgPSAndHFfbGluZWFnZV9kaXNhYmxlJztcclxuICAgICAgICBfYmFzZS5zaWdtYUdyYXBoLnN0eWxlLm9wYWNpdHkgPSAwO1xyXG4gICAgICAgIF9iYXNlLnNpZ21hR3JhcGguc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcclxuICAgICAgICBfYmFzZS5saW5lYWdlRGlhZ3JhbS5zdHlsZS5vcGFjaXR5ID0gMDtcclxuICAgICAgICBfYmFzZS5saW5lYWdlRGlhZ3JhbS5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xyXG5cclxuICAgICAgICBfY3VycmVudFZpZXcgPSAnbm9uZSc7XHJcbiAgICAgICAgc2VsZi50cmlnZ2VyKCdjdXJyZW50LXZpZXctY2hhbmdlZCcsIF9jdXJyZW50Vmlldyk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGRlZmF1bHQgTGluZWFnZUdyYW07XHJcbiIsIid1c2Ugc3RyaWN0JztcclxuaW1wb3J0ICogYXMgTGluZWFnZUdyYW0gZnJvbSAnLi9saW5lYWdlR3JhbSc7XHJcbmltcG9ydCBEZWZhdWx0RGF0YVByb3ZpZGVyIGZyb20gJy4vZGF0YS9kZWZhdWx0RGF0YVByb3ZpZGVyJztcclxuaW1wb3J0IEluZm9QYW5lbCBmcm9tICcuL2h0bWxVSS9pbmZvUGFuZWwnO1xyXG5pbXBvcnQgT3B0aW9uc1BhbmVsIGZyb20gJy4vaHRtbFVJL29wdGlvbnNQYW5lbCc7XHJcbmltcG9ydCBNYXAgZnJvbSAnLi9odG1sVUkvbWFwJztcclxuaW1wb3J0IERlZmF1bHRVSSBmcm9tICcuL2h0bWxVSS9kZWZhdWx0VUknO1xyXG5pbXBvcnQgeyBEZXJpdmF0aW9uTWFwIH0gZnJvbSAnLi9qb2ludFZpZXdzL2Rlcml2YXRpb25NYXAvZGVyaXZhdGlvbk1hcCc7XHJcbnJlcXVpcmUoJ2VzNi1wcm9taXNlJykuUHJvbWlzZTtcclxucmVxdWlyZSgnd2hhdHdnLWZldGNoJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIExpbmVhZ2VHcmFtOiBMaW5lYWdlR3JhbS5MaW5lYWdlR3JhbSxcclxuICAgIGdldERlZmF1bHRQYXJhbWV0ZXJzU2V0OiBMaW5lYWdlR3JhbS5nZXREZWZhdWx0UGFyYW1ldGVyc1NldCxcclxuICAgIERlZmF1bHREYXRhUHJvdmlkZXI6IERlZmF1bHREYXRhUHJvdmlkZXIsXHJcbiAgICBEZXJpdmF0aW9uTWFwOiBEZXJpdmF0aW9uTWFwLFxyXG4gICAgdWlVdGlsczoge1xyXG4gICAgICAgIERlZmF1bHRVSTogRGVmYXVsdFVJLFxyXG4gICAgICAgIE1hcDogTWFwLFxyXG4gICAgICAgIEluZm9QYW5lbDogSW5mb1BhbmVsLFxyXG4gICAgICAgIE9wdGlvbnNQYW5lbDogT3B0aW9uc1BhbmVsLFxyXG4gICAgfSxcclxufTsiLCJpbXBvcnQgU2lnbWFCYXNlIGZyb20gJy4vc2lnbWFCYXNlJztcclxuaW1wb3J0ICogYXMgZ3JhcGhFbGVtZW50cyBmcm9tICcuLi9qb2ludFZpZXdzL2dyYXBoRWxlbWVudHMvZWxlbWVudHMnO1xyXG5pbXBvcnQgeyBnZXRQYXRoIH0gZnJvbSAnLi4vdXRpbHMvbGluZWFnZURpYWdyYW1VdGlscyc7XHJcblxyXG4vKiogXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBjbGFzc1xyXG4gKiBNaW5pIG1hcCBpbiB0aGUgcmlnaHQtYm90dG9tIGNvcm5lcixcclxuICogd2hpY2ggc2hvd3MgdGhlIGZ1bGwgZ3JhcGggd2l0aCB2aWV3RnJhbWUncyBwb3NpdGlvbnMgd2l0aG91dCBsaW5rc1xyXG4gKiBAYXVnbWVudHMgU2lnbWFCYXNlXHJcbiovXHJcbmV4cG9ydCBmdW5jdGlvbiBCaXJkRXllIChvcHRpb25zLCBwYXJhbWV0ZXJzKSB7XHJcbiAgICBjb25zdCBzZWxmID0gdGhpcztcclxuICAgIGNvbnN0IF9jb2xvcnMgPSBwYXJhbWV0ZXJzLmNvbG9ycztcclxuICAgIGxldCBfcGF0aCA9IG51bGw7XHJcblxyXG4gICAgU2lnbWFCYXNlLmFwcGx5KHNlbGYsIFtvcHRpb25zLCBwYXJhbWV0ZXJzXSk7XHJcblxyXG4gICAgY29uc3Qgb2xkU2V0U2VsZWN0ZWRFbGVtZW50ID0gc2VsZi5zZXRTZWxlY3RlZEVsZW1lbnQ7XHJcbiAgICBzZWxmLnNldFNlbGVjdGVkRWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcbiAgICAgICAgbGV0IHNlbGVjdGVkRWxlbWVudDtcclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgIGVsZW1lbnQgaW5zdGFuY2VvZiBncmFwaEVsZW1lbnRzLk5vZGUgfHxcclxuICAgICAgICAgICAgZWxlbWVudCBpbnN0YW5jZW9mIGdyYXBoRWxlbWVudHMuVGVybWluYXRpb25Ob2RlXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIHNlbGVjdGVkRWxlbWVudCA9IGVsZW1lbnQub3JpZ2luYWxOb2RlIHx8IGVsZW1lbnQ7XHJcbiAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50IGluc3RhbmNlb2YgZ3JhcGhFbGVtZW50cy5MaW5rKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxpbmsgPSBlbGVtZW50Lm9yaWdpbmFsTGluayB8fCBlbGVtZW50O1xyXG4gICAgICAgICAgICBzZWxlY3RlZEVsZW1lbnQgPSBsaW5rO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHNlbGVjdGVkRWxlbWVudCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoc2VsZi5zZWxlY3RlZEVsZW1lbnQgIT09IHNlbGVjdGVkRWxlbWVudCkge1xyXG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWRFbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICBfcGF0aCA9IGdldFBhdGgoc2VsZWN0ZWRFbGVtZW50LCBzZWxmLl9kYXRhQ29udGFpbmVyKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIF9wYXRoID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBvbGRTZXRTZWxlY3RlZEVsZW1lbnQuY2FsbChzZWxmLCBzZWxlY3RlZEVsZW1lbnQpO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLl9yZWZyZXNoTm9kZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY29uc3Qgbm9kZU1hcCA9IHNlbGYuX2RhdGFDb250YWluZXIubWFwcy5ub2RlTWFwO1xyXG5cclxuICAgICAgICBzZWxmLnNpZ21hR3JhcGguZ3JhcGgubm9kZXMoKS5mb3JFYWNoKHNpZ21hTm9kZSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChub2RlTWFwW3NpZ21hTm9kZS5pZF0pIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBub2RlTWFwW3NpZ21hTm9kZS5pZF07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBtb2RlbCA9IG5vZGUubW9kZWw7XHJcbiAgICAgICAgICAgICAgICBzaWdtYU5vZGUueCA9IG1vZGVsLnBvc2l0aW9uLng7XHJcbiAgICAgICAgICAgICAgICBzaWdtYU5vZGUueSA9IG1vZGVsLnBvc2l0aW9uLnk7XHJcblxyXG4gICAgICAgICAgICAgICAgc2lnbWFOb2RlLmNvbG9yID0gc2VsZi5zZWxlY3RlZEVsZW1lbnQgJiYgKFxyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuaWQgPT09IHNlbGYuc2VsZWN0ZWRFbGVtZW50LmlkIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zZWxlY3RlZEVsZW1lbnQuYXNwZWN0cyAmJlxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2VsZWN0ZWRFbGVtZW50LmFzcGVjdHMuZmlsdGVyKGEgPT4gYS5pZCA9PT0gbm9kZS5pZCkubGVuZ3RoID4gMFxyXG4gICAgICAgICAgICAgICAgKSA/IFxyXG4gICAgICAgICAgICAgICAgICAgIF9jb2xvcnNbJ3NlbGVjdGVkJ10gOlxyXG4gICAgICAgICAgICAgICAgICAgICghX3BhdGh8fCBfcGF0aFtub2RlLmlkXSA/IF9jb2xvcnNbbW9kZWwudHlwZUlkXSA6IF9jb2xvcnNbJ2JsdXJlZCddKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLl9yZWZyZXNoVmlld0ZyYW1lcyA9IGZ1bmN0aW9uICgpIHt9O1xyXG5cclxuICAgIHNlbGYuX3JlZnJlc2hMaW5rcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBzZWxmLnNpZ21hR3JhcGguZ3JhcGguZWRnZXMoKS5mb3JFYWNoKGwgPT4ge1xyXG4gICAgICAgICAgICBsLnNpemUgPSBzZWxmLnNlbGVjdGVkRWxlbWVudCAmJiBsLmlkID09PSBzZWxmLnNlbGVjdGVkRWxlbWVudC5pZCA/IDUgOiAxLFxyXG4gICAgICAgICAgICBsLmNvbG9yID0gXHJcbiAgICAgICAgICAgICAgICAhX3BhdGggfHwgX3BhdGhbbC5pZF0gPyBcclxuICAgICAgICAgICAgICAgICAgICAoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuc2VsZWN0ZWRFbGVtZW50ICYmIGwuaWQgPT09IHNlbGYuc2VsZWN0ZWRFbGVtZW50LmlkID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb2xvcnNbJ3NlbGVjdGVkJ10gOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2FzcGVjdExpbmtzW2wuaWRdID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbG9yc1snYXNwZWN0TGluayddIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbG9yc1snbGluayddXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICAgICAgKSA6XHJcbiAgICAgICAgICAgICAgICAgICAgX2NvbG9yc1snYmx1cmVkJ107XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBzZWxmLl9pbml0aWFsaXplKCk7XHJcbn1cclxuXHJcbkJpcmRFeWUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTaWdtYUJhc2UucHJvdG90eXBlKTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IEJpcmRFeWU7XHJcbiIsImltcG9ydCBTaWdtYUJhc2UgZnJvbSAnLi9zaWdtYUJhc2UnO1xyXG5pbXBvcnQgKiBhcyBncmFwaEVsZW1lbnRzIGZyb20gJy4uL2pvaW50Vmlld3MvZ3JhcGhFbGVtZW50cy9lbGVtZW50cyc7XHJcblxyXG4vKiogXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBjbGFzc1xyXG4gKiBNaW5pIG1hcCBpbiB0aGUgcmlnaHQtYm90dG9tIGNvcm5lcixcclxuICogd2hpY2ggc2hvd3MgdGhlIGZ1bGwgZ3JhcGggd2l0aCB2aWV3RnJhbWUncyBwb3NpdGlvbnMgd2l0aG91dCBsaW5rc1xyXG4gKiBAYXVnbWVudHMgU2lnbWFCYXNlXHJcbiAqIEBmaXJlcyB2aWV3LWZyYW1lcy1wb3NpdGlvbi1jaGFuZ2VkIChwYXJhbXM6IFZpZXdGcmFtZVB1YmxpY01vZGVsW10pXHJcbiovXHJcbmV4cG9ydCBmdW5jdGlvbiBHcmFwaE1hcCAob3B0aW9ucywgcGFyYW1ldGVycykge1xyXG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XHJcbiAgICBsZXQgX3ZpZXdGcmFtZXNNYXAgPSB7fTtcclxuICAgIG9wdGlvbnMudmlld0ZyYW1lcy5mb3JFYWNoKHZmID0+IF92aWV3RnJhbWVzTWFwW3ZmLmlkXSA9IHZmKTtcclxuXHJcbiAgICBTaWdtYUJhc2UuYXBwbHkoc2VsZiwgW29wdGlvbnMsIHBhcmFtZXRlcnNdKTtcclxuXHJcbiAgICBzZWxmLl9nZXREYXRhID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB7IG5vZGVzOiBzZWxmLl9kYXRhQ29udGFpbmVyLm5vZGVzLCBsaW5rczogW10gfTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWRlZmluaXRpb25cclxuICAgICAqL1xyXG4gICAgY29uc3Qgb2xkU2V0U2VsZWN0ZWRFbGVtZW50ID0gc2VsZi5zZXRTZWxlY3RlZEVsZW1lbnQ7XHJcbiAgICBzZWxmLnNldFNlbGVjdGVkRWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcbiAgICAgICAgbGV0IHNlbGVjdGVkRWxlbWVudDtcclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgIGVsZW1lbnQgaW5zdGFuY2VvZiBncmFwaEVsZW1lbnRzLk5vZGUgfHxcclxuICAgICAgICAgICAgZWxlbWVudCBpbnN0YW5jZW9mIGdyYXBoRWxlbWVudHMuVGVybWluYXRpb25Ob2RlXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIHNlbGVjdGVkRWxlbWVudCA9IGVsZW1lbnQub3JpZ2luYWxOb2RlIHx8IGVsZW1lbnQ7XHJcbiAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50IGluc3RhbmNlb2YgZ3JhcGhFbGVtZW50cy5MaW5rKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxpbmsgPSBlbGVtZW50Lm9yaWdpbmFsTGluayB8fCBlbGVtZW50O1xyXG4gICAgICAgICAgICBzZWxlY3RlZEVsZW1lbnQgPSBsaW5rO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHNlbGVjdGVkRWxlbWVudCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBncmFwaCA9IHNlbGYuc2lnbWFHcmFwaC5ncmFwaDtcclxuICAgICAgICBpZiAoc2VsZi5zZWxlY3RlZEVsZW1lbnQgaW5zdGFuY2VvZiBncmFwaEVsZW1lbnRzLkxpbmspIHtcclxuICAgICAgICAgICAgZ3JhcGguZHJvcEVkZ2Uoc2VsZi5zZWxlY3RlZEVsZW1lbnQuaWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2VsZWN0ZWRFbGVtZW50IGluc3RhbmNlb2YgZ3JhcGhFbGVtZW50cy5MaW5rKSB7XHJcbiAgICAgICAgICAgIGdyYXBoLmFkZEVkZ2Uoc2VsZi5fY3JlYXRlTGluayhzZWxlY3RlZEVsZW1lbnQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgb2xkU2V0U2VsZWN0ZWRFbGVtZW50LmNhbGwoc2VsZiwgc2VsZWN0ZWRFbGVtZW50KTtcclxuICAgIH07XHJcblxyXG4gICAgY29uc3Qgb3ZlcnJpZGVSZWRyYXcgPSBzZWxmLnJlZHJhdztcclxuICAgIHNlbGYucmVkcmF3ID0gZnVuY3Rpb24gKHJlbmRlck9wdGlvbnMpIHtcclxuICAgICAgICBvdmVycmlkZVJlZHJhdyhyZW5kZXJPcHRpb25zKTtcclxuICAgICAgICByZW5kZXJPcHRpb25zID0gcmVuZGVyT3B0aW9ucyB8fCB7fTtcclxuICAgICAgICBpZiAocmVuZGVyT3B0aW9ucy52aWV3RnJhbWVzKSByZW5kZXJPcHRpb25zLnZpZXdGcmFtZXMuZm9yRWFjaCh2ZiA9PiBfdmlld0ZyYW1lc01hcFt2Zi5pZF0gPSB2Zik7XHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IG92ZXJyaWRlZFNldERhdGEgPSBzZWxmLnNldERhdGE7XHJcbiAgICBzZWxmLnNldERhdGEgPSBmdW5jdGlvbiAoZGF0YUNvbnRhaW5lciwgdmlld0ZyYW1lcykge1xyXG4gICAgICAgIG92ZXJyaWRlZFNldERhdGEoZGF0YUNvbnRhaW5lciwgdmlld0ZyYW1lcyk7XHJcbiAgICAgICAgX3ZpZXdGcmFtZXNNYXAgPSB7fTtcclxuICAgICAgICB2aWV3RnJhbWVzLmZvckVhY2godmYgPT4gX3ZpZXdGcmFtZXNNYXBbdmYuaWRdID0gdmYpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHZpZXdGcmFtZXMgc3RhdGUuIFxyXG4gICAgICogQHBhcmFtIHtWaWV3RnJhbWVQdWJsaWNNb2RlbH0gdmlld0ZyYW1lc1xyXG4gICAgICovXHJcbiAgICBjb25zdCBfb2xkSW1wbGVtZW50YXRpb24gPSBzZWxmLl9yZWZyZXNoVmlld0ZyYW1lcztcclxuICAgIHNlbGYuX3JlZnJlc2hWaWV3RnJhbWVzID0gZnVuY3Rpb24gKHZpZXdGcmFtZXMpIHtcclxuICAgICAgICBfb2xkSW1wbGVtZW50YXRpb24odmlld0ZyYW1lcyk7XHJcbiAgICAgICAgdmlld0ZyYW1lcy5mb3JFYWNoKHZmID0+IF92aWV3RnJhbWVzTWFwW3ZmLmlkXSA9IHZmKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVkZWZpbml0aW9uLlxyXG4gICAgICovXHJcbiAgICBzZWxmLl9zdWJzY3JpYmVPbkV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBzZWxmLnNpZ21hR3JhcGguYmluZCgnY2xpY2tTdGFnZScsIChlKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGdsb2JhbENsaWNrUG9pbnQgPSBfY29ubnZlcnRQb2ludChlKTtcclxuICAgICAgICAgICAgY29uc3Qgdmlld0ZyYW1lcyA9IE9iamVjdC5rZXlzKF92aWV3RnJhbWVzTWFwKS5tYXAoa2V5ID0+IF92aWV3RnJhbWVzTWFwW2tleV0pO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZpZXdGcmFtZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHZpZXdGcmFtZSA9IHZpZXdGcmFtZXNbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAoIXZpZXdGcmFtZS5hY3RpdmUpIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IGJvdW5kcyA9IHtcclxuICAgICAgICAgICAgICAgICAgICBtaW5YOiB2aWV3RnJhbWUudmlld1BvcnRQb3NpdGlvbkJvdW5kcy5taW5YLFxyXG4gICAgICAgICAgICAgICAgICAgIG1pblk6IHZpZXdGcmFtZS52aWV3UG9ydFBvc2l0aW9uQm91bmRzLm1pblksXHJcbiAgICAgICAgICAgICAgICAgICAgbWF4WDogdmlld0ZyYW1lLnZpZXdQb3J0UG9zaXRpb25Cb3VuZHMubWF4WCArIHZpZXdGcmFtZS52aWV3UG9ydEJvdW5kcy53aWR0aCxcclxuICAgICAgICAgICAgICAgICAgICBtYXhZOiB2aWV3RnJhbWUudmlld1BvcnRQb3NpdGlvbkJvdW5kcy5tYXhZICsgdmlld0ZyYW1lLnZpZXdQb3J0Qm91bmRzLmhlaWdodCxcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgcG9pbnRIaXRzVGhlQm91bmRzID0gYm91bmRzLm1pblggPD0gZ2xvYmFsQ2xpY2tQb2ludC54ICYmIGdsb2JhbENsaWNrUG9pbnQueCA8PSBib3VuZHMubWF4WCAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm91bmRzLm1pblkgPD0gZ2xvYmFsQ2xpY2tQb2ludC55ICYmIGdsb2JhbENsaWNrUG9pbnQueSA8PSBib3VuZHMubWF4WTtcclxuICAgICAgICAgICAgICAgIGlmIChwb2ludEhpdHNUaGVCb3VuZHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2aWV3RnJhbWVPcHRpb25zID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogdmlld0ZyYW1lLmlkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3UG9ydFBvc2l0aW9uOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBnbG9iYWxDbGlja1BvaW50LnggLSB2aWV3RnJhbWUuc2l6ZS53aWR0aCAvIDIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBnbG9iYWxDbGlja1BvaW50LnkgLSB2aWV3RnJhbWUuc2l6ZS5oZWlnaHQgLyAyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLnRyaWdnZXIoJ3ZpZXctZnJhbWVzLXBvc2l0aW9uLWNoYW5nZWQnLCBbW3ZpZXdGcmFtZU9wdGlvbnNdXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgc2VsZi5zaWdtYUdyYXBoLmJpbmQoJ2NsaWNrTm9kZScsIChldnQpID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IGV2dC5kYXRhLm5vZGUgPyBzZWxmLl9kYXRhQ29udGFpbmVyLm1hcHMubm9kZU1hcFtldnQuZGF0YS5ub2RlLmlkXSA6IG51bGw7XHJcbiAgICAgICAgICAgIHNlbGYuc2V0U2VsZWN0ZWRFbGVtZW50KG5vZGUpO1xyXG4gICAgICAgICAgICBzZWxmLnRyaWdnZXIoJ3NlbGVjdGVkLWVsZW1lbnQtY2hhbmdlZCcsIG5vZGUpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBzZWxmLnNpZ21hR3JhcGguYmluZCgnY2xpY2tFZGdlJywgKGV2dCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBsaW5rID0gZXZ0LmRhdGEuZWRnZSA/IHNlbGYuX2RhdGFDb250YWluZXIubWFwcy5saW5rTWFwW2V2dC5kYXRhLmVkZ2UuaWRdIDogbnVsbDtcclxuICAgICAgICAgICAgc2VsZi5zZXRTZWxlY3RlZEVsZW1lbnQobGluayk7XHJcbiAgICAgICAgICAgIHNlbGYudHJpZ2dlcignc2VsZWN0ZWQtZWxlbWVudC1jaGFuZ2VkJywgbGluayk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIENhbGN1bGF0ZXMgc2lnbWEgcGFwZXIgcG9pbnQgdG8gam9pbnQgcGFwZXIgcG9pbnQuXHJcbiAgICAgKiBAcGFyYW0ge1xyXG4gICAgICogIGRhdGE6IHtcclxuICAgICAqICAgICAgY3B0b3I6IHtcclxuICAgICAqICAgICAgICAgIGNsaWVudFgsXHJcbiAgICAgKiAgICAgICAgICBjbGllbnRZXHJcbiAgICAgKiAgICAgIH1cclxuICAgICAqICB9XHJcbiAgICAgKiB9IGV2ZW50XHJcbiAgICAqL1xyXG4gICAgZnVuY3Rpb24gX2Nvbm52ZXJ0UG9pbnQgKGV2ZW50KSB7XHJcbiAgICAgICAgY29uc3QgcmVuZGVyZXIgPSBzZWxmLnNpZ21hR3JhcGgucmVuZGVyZXJzWzBdO1xyXG4gICAgICAgIGNvbnN0IF9wcmVmaXggPSByZW5kZXJlci5vcHRpb25zLnByZWZpeDtcclxuICAgICAgICByZXR1cm4gZXhlY3V0ZU5vZGVNb3VzZU1vdmUoKTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gZXhlY3V0ZU5vZGVNb3VzZU1vdmUgKCkge1xyXG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gX2NhbGN1bGF0ZU9mZnNldChyZW5kZXJlci5jb250YWluZXIpLFxyXG4gICAgICAgICAgICAgICAgeCA9IGV2ZW50LmRhdGEuY2FwdG9yLmNsaWVudFggLSBvZmZzZXQubGVmdCxcclxuICAgICAgICAgICAgICAgIHkgPSBldmVudC5kYXRhLmNhcHRvci5jbGllbnRZIC0gb2Zmc2V0LnRvcCxcclxuICAgICAgICAgICAgICAgIGNvcyA9IE1hdGguY29zKHNlbGYuc2lnbWFHcmFwaC5jYW1lcmEuYW5nbGUpLFxyXG4gICAgICAgICAgICAgICAgc2luID0gTWF0aC5zaW4oc2VsZi5zaWdtYUdyYXBoLmNhbWVyYS5hbmdsZSksXHJcbiAgICAgICAgICAgICAgICBub2RlcyA9IHNlbGYuc2lnbWFHcmFwaC5ncmFwaC5ub2RlcygpLFxyXG4gICAgICAgICAgICAgICAgcmVmID0gW107XHJcblxyXG4gICAgICAgICAgICAvLyBHZXR0aW5nIGFuZCBkZXJvdGF0aW5nIHRoZSByZWZlcmVuY2UgY29vcmRpbmF0ZXMuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbiA9IG5vZGVzW2ldO1xyXG4gICAgICAgICAgICAgICAgdmFyIGF1eCA9IHtcclxuICAgICAgICAgICAgICAgICAgICB4OiBuLnggKiBjb3MgKyBuLnkgKiBzaW4sXHJcbiAgICAgICAgICAgICAgICAgICAgeTogbi55ICogY29zIC0gbi54ICogc2luLFxyXG4gICAgICAgICAgICAgICAgICAgIHJlblg6IG5bX3ByZWZpeCArICd4J10sXHJcbiAgICAgICAgICAgICAgICAgICAgcmVuWTogbltfcHJlZml4ICsgJ3knXSxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICByZWYucHVzaChhdXgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBBcHBseWluZyBsaW5lYXIgaW50ZXJwb2xhdGlvbi5cclxuICAgICAgICAgICAgLy8gaWYgdGhlIG5vZGVzIGFyZSBvbiB0b3Agb2YgZWFjaCBvdGhlciwgd2UgdXNlIHRoZSBjYW1lcmEgcmF0aW8gdG8gaW50ZXJwb2xhdGVcclxuICAgICAgICAgICAgaWYgKHJlZlswXS54ID09PSByZWZbMV0ueCAmJiByZWZbMF0ueSA9PT0gcmVmWzFdLnkpIHtcclxuICAgICAgICAgICAgICAgIHZhciB4UmF0aW8gPSAocmVmWzBdLnJlblggPT09IDApID8gMSA6IHJlZlswXS5yZW5YO1xyXG4gICAgICAgICAgICAgICAgdmFyIHlSYXRpbyA9IChyZWZbMF0ucmVuWSA9PT0gMCkgPyAxIDogcmVmWzBdLnJlblk7XHJcbiAgICAgICAgICAgICAgICB4ID0gKHJlZlswXS54IC8geFJhdGlvKSAqICh4IC0gcmVmWzBdLnJlblgpICsgcmVmWzBdLng7XHJcbiAgICAgICAgICAgICAgICB5ID0gKHJlZlswXS55IC8geVJhdGlvKSAqICh5IC0gcmVmWzBdLnJlblkpICsgcmVmWzBdLnk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB4UmF0aW8gPSAocmVmWzFdLnJlblggLSByZWZbMF0ucmVuWCkgLyAocmVmWzFdLnggLSByZWZbMF0ueCk7XHJcbiAgICAgICAgICAgICAgICB5UmF0aW8gPSAocmVmWzFdLnJlblkgLSByZWZbMF0ucmVuWSkgLyAocmVmWzFdLnkgLSByZWZbMF0ueSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIGNvb3JkaW5hdGVzIGFyZSB0aGUgc2FtZSwgd2UgdXNlIHRoZSBvdGhlciByYXRpbyB0byBpbnRlcnBvbGF0ZVxyXG4gICAgICAgICAgICAgICAgaWYgKHJlZlsxXS54ID09PSByZWZbMF0ueCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHhSYXRpbyA9IHlSYXRpbztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAocmVmWzFdLnkgPT09IHJlZlswXS55KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeVJhdGlvID0geFJhdGlvO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHggPSAoeCAtIHJlZlswXS5yZW5YKSAvIHhSYXRpbyArIHJlZlswXS54O1xyXG4gICAgICAgICAgICAgICAgeSA9ICh5IC0gcmVmWzBdLnJlblkpIC8geVJhdGlvICsgcmVmWzBdLnk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB7IHg6ICh4ICogY29zIC0geSAqIHNpbiksIHk6ICh5ICogY29zICsgeCAqIHNpbikgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlcyB0aGUgZ2xvYmFsIG9mZnNldCBvZiB0aGUgZ2l2ZW4gZWxlbWVudCBtb3JlIGFjY3VyYXRlbHkgdGhhblxyXG4gICAgLy8gZWxlbWVudC5vZmZzZXRUb3AgYW5kIGVsZW1lbnQub2Zmc2V0TGVmdC5cclxuICAgIGZ1bmN0aW9uIF9jYWxjdWxhdGVPZmZzZXQgKGVsZW1lbnQpIHtcclxuICAgICAgICB2YXIgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcclxuICAgICAgICB2YXIgZ2V0Q3NzUHJvcGVydHkgPSBmdW5jdGlvbiAocHJvcCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShwcm9wKS5yZXBsYWNlKCdweCcsICcnKSkgfHwgMDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGxlZnQ6IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCArIGdldENzc1Byb3BlcnR5KCdwYWRkaW5nLWxlZnQnKSxcclxuICAgICAgICAgICAgdG9wOiBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCArIGdldENzc1Byb3BlcnR5KCdwYWRkaW5nLXRvcCcpXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBzZWxmLl9pbml0aWFsaXplKCk7XHJcbn1cclxuR3JhcGhNYXAucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTaWdtYUJhc2UucHJvdG90eXBlKTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IEdyYXBoTWFwO1xyXG4iLCJpbXBvcnQgU2lnbWEgZnJvbSAnc2lnbWEnO1xyXG5pbXBvcnQgKiBhcyBTaWdtYVNuYXBzaG90UGx1Z2luIGZyb20gJy4vc2lnbWFQbGFnaW5zL3NpZ21hLnJlbmRlcmVycy5zbmFwc2hvdC9zaWdtYS5yZW5kZXJlcnMuc25hcHNob3QnO1xyXG5pbXBvcnQgU3Vic2NyaWJhYmxlIGZyb20gJy4uL3N1YnNjcmlwdGlvbkFQSS9zdWJzY3JpYmVhYmxlJztcclxuaW1wb3J0ICogYXMgZ3JhcGhFbGVtZW50cyBmcm9tICcuLi9qb2ludFZpZXdzL2dyYXBoRWxlbWVudHMvZWxlbWVudHMnO1xyXG5pbXBvcnQgc2F2ZUFzIGZyb20gJ2ZpbGUtc2F2ZXJqcyc7XHJcbmltcG9ydCB7IGRhdGUyU3RyaW5nLCBwbmcyQmxvYiB9IGZyb20gJy4uL3V0aWxzL2RhdGFVdGlscyc7XHJcbmltcG9ydCB7IGdldEdsb2JhbE5vZGVQb3NpdGlvbiB9IGZyb20gJy4uL3V0aWxzL3V0aWxzJztcclxuXHJcblNpZ21hU25hcHNob3RQbHVnaW4udXNlUGx1Z2luKFNpZ21hKTtcclxuXHJcbi8qKiBcclxuICogQHByaXZhdGVcclxuICogQGNsYXNzXHJcbiAqIEl0J3MgdGhlIGJhc2UgY2xhc3MgZm9yIHNpZ21hIHZpZXdzLlxyXG4gKiBcclxuICogQ29uc3RydWN0b3IgcGFyYW1ldGVyczpcclxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gKiBAcGFyYW0ge1xyXG4gKiAgZGF0YUNvbnRhaW5lcjogRGF0YUNvbnRhaW5lclxyXG4gKiAgdmlld0ZyYW1lczogVmlld0ZyYW1lUHVibGljTW9kZWxbXVxyXG4gKiAgZWw6IEhUTUxFbGVtZW50XHJcbiAqICBzZWxlY3RlZEVsZW1lbnQ6IE5vZGV8TGlua1xyXG4gKiAgc2NhbGU6bnVtYmVyXHJcbiAqIH0gb3B0aW9uc1xyXG4gKiBAcGFyYW0ge1BhcmFtZXRlcnN9IHBhcmFtZXRlcnMgLSBwYXJhbWV0ZXJzIHNldFxyXG4gKiBcclxuICogUHVibGljIHByb3BlcnRpZXM6XHJcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICogc2VsZWN0ZWRFbGVtZW50OiBOb2RlfExpbmtcclxuICogXHJcbiAqIFB1YmxpYyBtZXRob2RzOlxyXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAqIHNldFNlbGVjdGVkRWxlbWVudDogKGVsZW1lbnQ6IE5vZGV8TGluaykgPT4gdm9pZFxyXG4gKiBzZXREYXRhOiAoZGF0YUNvbnRhaW5lcjogRGF0YUNvbnRhaW5lciwgdmlld0ZyYW1lczogVmlld0ZyYW1lW10pID0+IHZvaWRcclxuICogc2V0U2NhbGU6IChzY2FsZTogbnVtYmVyKSA9PiB2b2lkXHJcbiAqIHJlZnJlc2g6ICgpID0+IHZvaWRcclxuICogZXhwb3J0OiAobmFtZT86IHN0cmluZykgPT4gdm9pZFxyXG4gKiBwcmludDogKCkgPT4gdm9pZFxyXG4gKiByZWRyYXc6ICgpID0+IHZvaWRcclxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiBvbiAoZXZlbnQ6IHN0cmluZywgY2FsbGJhY2s6IGZ1bmN0aW9uKTogdm9pZFxyXG4gKiB1bnN1YnNjcmliZSAoY2FsbGJhY2s6IGZ1bmN0aW9uKTogdm9pZFxyXG4gKiB0cmlnZ2VyIChldmVudDogc3RyaW5nLCBwYXJhbWV0ZXJzOiBhbnkpOiB2b2lkXHJcbiAqIFxyXG4gKiBFdmVudHM6XHJcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICogQGZpcmVzIHNlbGVjdGVkLWVsZW1lbnQtY2hhbmdlZCAocGFyYW1zOiBOb2RlfExpbmspXHJcbiAqIEBmaXJlcyBjZWxsLWRvdWJsZS1jbGljayAocGFyYW1zOiBOb2RlfExpbmspXHJcbiovXHJcbmV4cG9ydCBmdW5jdGlvbiBTaWdtYUJhc2UgKG9wdGlvbnMsIHBhcmFtZXRlcnMpIHtcclxuXHJcbiAgICBTdWJzY3JpYmFibGUuYXBwbHkodGhpcyk7ICAgLy8gbWFrZSB0aGlzIGNsYXNzIFN1YnNjcmliYWJsZVxyXG5cclxuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xyXG4gICAgY29uc3QgX2NvbG9ycyA9IHBhcmFtZXRlcnMuY29sb3JzO1xyXG5cclxuICAgIGxldCBfbWF4Tm9kZVNpemUgPSAwO1xyXG4gICAgbGV0IF9yb290RWxlbWVudDtcclxuICAgIGxldCBfc2lnbWFGcmFtZXMgPSB7fTtcclxuXHJcbiAgICBzZWxmLl9hc3BlY3RMaW5rcyA9IHt9O1xyXG4gICAgc2VsZi5zZWxlY3RlZEVsZW1lbnQ7XHJcbiAgICBzZWxmLl9kYXRhQ29udGFpbmVyOyAgICAvLyB0byBvdmVycmlkZVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJ1bnMgaW5pdGlhbGl6YXRpb24uIEl0J3MgZXhlY3V0ZWQgYWZ0ZXIgY3JlYXRpb24gYnkgZGVzY2VuZGFudFxyXG4gICAgICovXHJcbiAgICBzZWxmLl9pbml0aWFsaXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF9pbml0aWFsaXplKFxyXG4gICAgICAgICAgICBvcHRpb25zLmRhdGFDb250YWluZXIsXHJcbiAgICAgICAgICAgIG9wdGlvbnMudmlld0ZyYW1lcyxcclxuICAgICAgICAgICAgb3B0aW9ucy5lbCxcclxuICAgICAgICAgICAgb3B0aW9ucy5zZWxlY3RlZEVsZW1lbnQsXHJcbiAgICAgICAgICAgIG9wdGlvbnMuc2NhbGVcclxuICAgICAgICApO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEl0J3Mga2luZCBvZiBjb25zdHJ1Y3Rvciwgd2hpY2ggY2FsbGVkIGFmdGVyIGNyZWF0aW9uIHRoZSBvYmplY3QuXHJcbiAgICAgKiBAcGFyYW0ge0RhdGFDb250YWluZXJ9IGRhdGFDb250YWluZXJcclxuICAgICAqIEBwYXJhbSB7QXJyYXkgb2YgVmlld0ZyYW1lfSB2aWV3RnJhbWVzXHJcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSByb290RWxlbWVudFxyXG4gICAgICogQHBhcmFtIHtOb2RlfExpbmt9IHNlbGVjdGVkRWxlbWVudFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNjYWxlXHJcbiAgICAqL1xyXG4gICAgZnVuY3Rpb24gX2luaXRpYWxpemUgKFxyXG4gICAgICAgIGRhdGFDb250YWluZXIsXHJcbiAgICAgICAgdmlld0ZyYW1lcyxcclxuICAgICAgICByb290RWxlbWVudCxcclxuICAgICAgICBzZWxlY3RlZEVsZW1lbnQsXHJcbiAgICApIHtcclxuICAgICAgICBfcm9vdEVsZW1lbnQgPSByb290RWxlbWVudDtcclxuICAgICAgICBzZWxmLnNlbGVjdGVkRWxlbWVudCA9IHNlbGVjdGVkRWxlbWVudDtcclxuICAgICAgICB2aWV3RnJhbWVzID0gdmlld0ZyYW1lcyB8fCBbXTtcclxuICAgICAgICBzZWxmLl9kYXRhQ29udGFpbmVyID0gZGF0YUNvbnRhaW5lcjtcclxuXHJcblxyXG4gICAgICAgIGNvbnN0IGRhdGEgPSBzZWxmLl9nZXREYXRhKCk7XHJcbiAgICAgICAgY29uc3QgZyA9IHtcclxuICAgICAgICAgICAgbm9kZXM6IFtdLFxyXG4gICAgICAgICAgICBlZGdlczogW10sXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgZGF0YS5ub2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBuZXdOb2RlID0gc2VsZi5fY3JlYXRlTm9kZShub2RlKTtcclxuICAgICAgICAgICAgZy5ub2Rlcy5wdXNoKG5ld05vZGUpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBkYXRhLmxpbmtzLmZvckVhY2gobGluayA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld0xpbmsgPSBzZWxmLl9jcmVhdGVMaW5rKGxpbmspO1xyXG4gICAgICAgICAgICBnLmVkZ2VzLnB1c2gobmV3TGluayk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGNvbnN0IGFzcGVjdExpbmtzID0gX2NyZWF0ZUFzcGVjdExpbmtzKGRhdGEubm9kZXMpO1xyXG4gICAgICAgIGFzcGVjdExpbmtzLmZvckVhY2goYWwgPT4ge1xyXG4gICAgICAgICAgICBnLmVkZ2VzLnB1c2goYWwpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBfbWF4Tm9kZVNpemUgPSBfZ2V0Tm9kZVNpemUoKTtcclxuXHJcbiAgICAgICAgc2VsZi5zaWdtYUdyYXBoID0gbmV3IFNpZ21hKHtcclxuICAgICAgICAgICAgZ3JhcGg6IGcsXHJcbiAgICAgICAgICAgIGNvbnRhaW5lcjogX3Jvb3RFbGVtZW50LFxyXG4gICAgICAgICAgICBzZXR0aW5nczoge1xyXG4gICAgICAgICAgICAgICAgbWluTm9kZVNpemU6IDAsXHJcbiAgICAgICAgICAgICAgICBtYXhOb2RlU2l6ZTogX21heE5vZGVTaXplLFxyXG4gICAgICAgICAgICAgICAgbm9kZXNQb3dSYXRpbzogMSxcclxuICAgICAgICAgICAgICAgIGVuYWJsZUVkZ2VIb3ZlcmluZzogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGVkZ2VIb3ZlckNvbG9yOiAnZWRnZScsXHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0RWRnZUhvdmVyQ29sb3I6ICcjMDAwJyxcclxuICAgICAgICAgICAgICAgIGVkZ2VIb3ZlclNpemVSYXRpbzogNCxcclxuICAgICAgICAgICAgICAgIGVkZ2VIb3ZlckV4dHJlbWl0aWVzOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgYXV0b1Jlc2l6ZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBjbG9uZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBkb3VibGVDbGlja1pvb21pbmdSYXRpbzogMSxcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHNlbGYuX3N1YnNjcmliZU9uRXZlbnRzKCk7XHJcbiAgICAgICAgX21heE5vZGVTaXplID0gX2dldE5vZGVTaXplKCk7XHJcbiAgICAgICAgc2VsZi5zaWdtYUdyYXBoLnNldHRpbmdzKCdtYXhOb2RlU2l6ZScsIF9tYXhOb2RlU2l6ZSk7XHJcblxyXG4gICAgICAgIHZpZXdGcmFtZXMuZm9yRWFjaCh2aWV3RnJhbWUgPT4ge1xyXG4gICAgICAgICAgICBpZiAodmlld0ZyYW1lLmFjdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgX2FkZFZpZXdGcmFtZSh2aWV3RnJhbWUpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgX3NpZ21hRnJhbWVzW3ZpZXdGcmFtZS5pZF0gPSBfY3JlYXRlU2lnbWFGcmFtZSh2aWV3RnJhbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHNlbGYuc2lnbWFHcmFwaC5yZWZyZXNoKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFeHBvcnRzIGdyYXBoIHRvIHBuZyBmaWxlXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGlhZ3JhbU5hbWVcclxuICAgICovXHJcbiAgICBzZWxmLmV4cG9ydCA9IGZ1bmN0aW9uIChkaWFncmFtTmFtZSkge1xyXG4gICAgICAgIGNvbnN0IGZpbGVOYW1lID0gZGlhZ3JhbU5hbWUgfHwgJ0xHX2JpcmRfZXllX3NuYXBzaG90XycgKyBkYXRlMlN0cmluZyhuZXcgRGF0ZSgpKTtcclxuICAgICAgICBjb25zdCBkYXRhID0gc2VsZi5zaWdtYUdyYXBoLnJlbmRlcmVyc1swXS5zbmFwc2hvdCh7XHJcbiAgICAgICAgICAgIGZvcm1hdDogJ3BuZycsXHJcbiAgICAgICAgICAgIGRvd25sb2FkOiBmYWxzZSxcclxuICAgICAgICAgICAgYmFja2dyb3VuZDogJ3RyYW5zcGFyZW50JyxcclxuICAgICAgICAgICAgbGFiZWxzOiB0cnVlLFxyXG4gICAgICAgICAgICBmaWxlbmFtZTogZmlsZU5hbWUsXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHNhdmVBcyhwbmcyQmxvYihkYXRhKSwgZmlsZU5hbWUgKyAnLnBuZycpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEV4cG9ydHMgZ3JhcGggdG8gcGRmIGZpbGVcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkaWFncmFtTmFtZVxyXG4gICAgKi9cclxuICAgIHNlbGYucHJpbnQgPSBmdW5jdGlvbiAoZGlhZ3JhbU5hbWUpIHtcclxuICAgICAgICBjb25zdCBmaWxlTmFtZSA9IGRpYWdyYW1OYW1lIHx8ICdMR19iaXJkX2V5ZV9zbmFwc2hvdF8nICsgZGF0ZTJTdHJpbmcobmV3IERhdGUoKSk7XHJcbiAgICAgICAgY29uc3QgZGF0YSA9IHNlbGYuc2lnbWFHcmFwaC5yZW5kZXJlcnNbMF0uc25hcHNob3Qoe1xyXG4gICAgICAgICAgICBmb3JtYXQ6ICdwbmcnLFxyXG4gICAgICAgICAgICBkb3dubG9hZDogZmFsc2UsXHJcbiAgICAgICAgICAgIGJhY2tncm91bmQ6ICd0cmFuc3BhcmVudCcsXHJcbiAgICAgICAgICAgIGxhYmVsczogdHJ1ZSxcclxuICAgICAgICAgICAgZmlsZW5hbWU6IGZpbGVOYW1lLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnN0IHByaW50V2luZG93ID0gd2luZG93Lm9wZW4oJycsIHVuZGVmaW5lZCwgJ3dpZHRoPTEyODAsaGVpZ2h0PTcyMCcpO1xyXG4gICAgICAgIGlmIChwcmludFdpbmRvdykge1xyXG4gICAgICAgICAgICBwcmludFdpbmRvdy5kb2N1bWVudC53cml0ZShgXHJcbiAgICAgICAgICAgICAgICA8aHRtbD5cclxuICAgICAgICAgICAgICAgICAgICA8Ym9keT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGltZyBzcmM9XCIke2RhdGF9XCIvPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvYm9keT5cclxuICAgICAgICAgICAgICAgIDwvaHRtbD5cclxuICAgICAgICAgICAgYCk7XHJcbiAgICAgICAgICAgIHByaW50V2luZG93LmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2ltZycpLm9ubG9hZCA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHByaW50V2luZG93LmRvY3VtZW50LmNsb3NlKCk7XHJcbiAgICAgICAgICAgICAgICBwcmludFdpbmRvdy5wcmludCgpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGFsZXJ0KCdZb3Ugc2hvdWxkIHVuYmxvY2sgcG9wdXAgd2luZG93cyBmb3IgdGhlIGN1cnJlbnQgdXJsIHRvIGJlIGFibGUgdG8gcHJpbnQgdGhpcyBkaWFncmFtIScpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHNlbGVjdGVkIGVsZW1lbnQuXHJcbiAgICAgKiBAcGFyYW0ge05vZGV8TGlua30gZWxlbWVudFxyXG4gICAgKi9cclxuICAgIHNlbGYuc2V0U2VsZWN0ZWRFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICAgICAgICBsZXQgc2VsZWN0ZWRFbGVtZW50O1xyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgICAgZWxlbWVudCBpbnN0YW5jZW9mIGdyYXBoRWxlbWVudHMuTm9kZSB8fFxyXG4gICAgICAgICAgICBlbGVtZW50IGluc3RhbmNlb2YgZ3JhcGhFbGVtZW50cy5UZXJtaW5hdGlvbk5vZGVcclxuICAgICAgICApIHtcclxuICAgICAgICAgICAgc2VsZWN0ZWRFbGVtZW50ID0gZWxlbWVudC5vcmlnaW5hbE5vZGUgfHwgZWxlbWVudDtcclxuICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBncmFwaEVsZW1lbnRzLkxpbmspIHtcclxuICAgICAgICAgICAgY29uc3QgbGluayA9IGVsZW1lbnQub3JpZ2luYWxMaW5rIHx8IGVsZW1lbnQ7XHJcbiAgICAgICAgICAgIHNlbGVjdGVkRWxlbWVudCA9IGxpbms7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc2VsZWN0ZWRFbGVtZW50ID0gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHJlZnJlc2ggPSBzZWxmLnNlbGVjdGVkRWxlbWVudCAhPT0gc2VsZWN0ZWRFbGVtZW50O1xyXG4gICAgICAgIHNlbGYuc2VsZWN0ZWRFbGVtZW50ID0gc2VsZWN0ZWRFbGVtZW50O1xyXG4gICAgICAgIGlmIChyZWZyZXNoKSBzZWxmLnJlZHJhdygpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgbmV3IGRhdGEgY29udGFpbmVyXHJcbiAgICAgKiBAcGFyYW0ge0RhdGFDb250YWluZXJ9IGRhdGFDb250YWluZXJcclxuICAgICAqIEBwYXJhbSB7Vmlld0ZyYW1lUHVibGljTW9kZWxbXX0gdmlld0ZyYW1lc1xyXG4gICAgKi9cclxuICAgIHNlbGYuc2V0RGF0YSA9IGZ1bmN0aW9uIChkYXRhQ29udGFpbmVyLCB2aWV3RnJhbWVzKSB7XHJcbiAgICAgICAgc2VsZi5zZWxlY3RlZEVsZW1lbnQgPSBudWxsO1xyXG4gICAgICAgIHNlbGYuX2RhdGFDb250YWluZXIgPSBkYXRhQ29udGFpbmVyO1xyXG4gICAgICAgIHZpZXdGcmFtZXMgPSB2aWV3RnJhbWVzIHx8IFtdO1xyXG5cclxuICAgICAgICBjb25zdCBkYXRhID0gc2VsZi5fZ2V0RGF0YSgpO1xyXG5cclxuICAgICAgICBzZWxmLnNpZ21hR3JhcGguZ3JhcGguY2xlYXIoKTtcclxuICAgICAgICBfbWF4Tm9kZVNpemUgPSBfZ2V0Tm9kZVNpemUoKTtcclxuICAgICAgICBzZWxmLnNpZ21hR3JhcGguc2V0dGluZ3MoJ21heE5vZGVTaXplJywgX21heE5vZGVTaXplKTtcclxuXHJcbiAgICAgICAgZGF0YS5ub2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBuZXdOb2RlID0gc2VsZi5fY3JlYXRlTm9kZShub2RlKTtcclxuICAgICAgICAgICAgc2VsZi5zaWdtYUdyYXBoLmdyYXBoLmFkZE5vZGUobmV3Tm9kZSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHZpZXdGcmFtZXMuZm9yRWFjaCh2aWV3RnJhbWUgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBmcmFtZSA9IF9jcmVhdGVTaWdtYUZyYW1lKHZpZXdGcmFtZSk7XHJcbiAgICAgICAgICAgIF9zaWdtYUZyYW1lc1t2aWV3RnJhbWUuaWRdID0gZnJhbWU7XHJcbiAgICAgICAgICAgIGlmICh2aWV3RnJhbWUuYWN0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICBfYWRkVmlld0ZyYW1lKHZpZXdGcmFtZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBfc2lnbWFGcmFtZXNbdmlld0ZyYW1lLmlkXSA9IF9jcmVhdGVTaWdtYUZyYW1lKHZpZXdGcmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgY29uc3QgYXNwZWN0TGlua3MgPSBfY3JlYXRlQXNwZWN0TGlua3MoZGF0YS5ub2Rlcyk7XHJcbiAgICAgICAgYXNwZWN0TGlua3MuZm9yRWFjaChhbCA9PiB7XHJcbiAgICAgICAgICAgIHNlbGYuc2lnbWFHcmFwaC5ncmFwaC5hZGRFZGdlKGFsKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgZGF0YS5saW5rcy5mb3JFYWNoKGxpbmsgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBuZXdMaW5rID0gc2VsZi5fY3JlYXRlTGluayhsaW5rKTtcclxuICAgICAgICAgICAgc2VsZi5zaWdtYUdyYXBoLmdyYXBoLmFkZEVkZ2UobmV3TGluayk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHNlbGYuc2lnbWFHcmFwaC5yZWZyZXNoKCk7XHJcbiAgICAgICAgc2VsZi5yZWRyYXcoKTtcclxuICAgIH07XHJcblxyXG4gICAgbGV0IGRlYm91bmNlcjtcclxuICAgIC8qKlxyXG4gICAgICogUmVkcmF3cyBhbGwgZ3JhcGguIE1haW5seSAtIHVwZGF0ZXMgY29sb3JzIG9mIGVsZW1lbnRzXHJcbiAgICAgKiBAcGFyYW0ge3ZpZXdGcmFtZXMsIHNjYWxlLCBub2RlcywgZnVsbFNjcmVlbk1vZGV9IG9wdGlvbnNcclxuICAgICAqL1xyXG4gICAgc2VsZi5yZWRyYXcgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgICAgIFxyXG4gICAgICAgIF9tYXhOb2RlU2l6ZSA9IF9nZXROb2RlU2l6ZSgpO1xyXG4gICAgICAgIHNlbGYuc2lnbWFHcmFwaC5zZXR0aW5ncygnbWF4Tm9kZVNpemUnLCBfbWF4Tm9kZVNpemUpO1xyXG5cclxuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShkZWJvdW5jZXIpO1xyXG4gICAgICAgIGRlYm91bmNlciA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgICAgICAgIHNlbGYuX3JlZnJlc2hOb2RlcygpO1xyXG4gICAgICAgICAgICBzZWxmLl9yZWZyZXNoTGlua3MoKTtcclxuICAgIFxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy52aWV3RnJhbWVzKSB7XHJcbiAgICAgICAgICAgICAgICBzZWxmLl9yZWZyZXNoVmlld0ZyYW1lcyhvcHRpb25zLnZpZXdGcmFtZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICBcclxuICAgICAgICAgICAgc2VsZi5zaWdtYUdyYXBoLnJlZnJlc2goKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gY2FuIGJlIG92ZXJyaWRlZFxyXG4gICAgc2VsZi5yZWZyZXNoID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHNlbGYucmVkcmF3KCk7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgbGlua3Mgc3RhdGVzLiBcclxuICAgICAqL1xyXG4gICAgc2VsZi5fcmVmcmVzaExpbmtzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNvbnN0IGVkZ2VzID0gc2VsZi5zaWdtYUdyYXBoLmdyYXBoLmVkZ2VzKCk7XHJcbiAgICAgICAgZWRnZXMuZm9yRWFjaChsID0+IHtcclxuICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgICAgbC5pZC5pbmRleE9mKCdfX3RvcCcpID09PSAtMSAmJlxyXG4gICAgICAgICAgICAgICAgbC5pZC5pbmRleE9mKCdfX2JvdHRvbScpID09PSAtMSAmJlxyXG4gICAgICAgICAgICAgICAgbC5pZC5pbmRleE9mKCdfX2xlZnQnKSA9PT0gLTEgJiZcclxuICAgICAgICAgICAgICAgIGwuaWQuaW5kZXhPZignX19yaWdodCcpID09PSAtMVxyXG4gICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgIGwuc2l6ZSA9IHNlbGYuc2VsZWN0ZWRFbGVtZW50ICYmIGwuaWQgPT09IHNlbGYuc2VsZWN0ZWRFbGVtZW50LmlkID8gNSA6IDEsXHJcbiAgICAgICAgICAgICAgICAgICAgbC5jb2xvciA9IHNlbGYuc2VsZWN0ZWRFbGVtZW50ICYmIGwuaWQgPT09IHNlbGYuc2VsZWN0ZWRFbGVtZW50LmlkID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgX2NvbG9yc1snc2VsZWN0ZWQnXSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChzZWxmLl9hc3BlY3RMaW5rc1tsLmlkXSA/IF9jb2xvcnNbJ2FzcGVjdExpbmsnXSA6IF9jb2xvcnNbJ2xpbmsnXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyBub2RlcyBzdGF0ZXMuIFxyXG4gICAgICovXHJcbiAgICBzZWxmLl9yZWZyZXNoTm9kZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY29uc3Qgbm9kZU1hcCA9IHNlbGYuX2RhdGFDb250YWluZXIubWFwcy5ub2RlTWFwO1xyXG4gICAgICAgIGNvbnN0IG5vZGVzID0gc2VsZi5zaWdtYUdyYXBoLmdyYXBoLm5vZGVzKCk7XHJcbiAgICAgICAgbm9kZXMuZm9yRWFjaChzaWdtYU5vZGUgPT4ge1xyXG4gICAgICAgICAgICBpZiAobm9kZU1hcFtzaWdtYU5vZGUuaWRdKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBub2RlID0gbm9kZU1hcFtzaWdtYU5vZGUuaWRdO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRHbG9iYWxOb2RlUG9zaXRpb24obm9kZSk7XHJcbiAgICAgICAgICAgICAgICBzaWdtYU5vZGUueCA9IHBvc2l0aW9uLng7XHJcbiAgICAgICAgICAgICAgICBzaWdtYU5vZGUueSA9IHBvc2l0aW9uLnk7XHJcbiAgICAgICAgICAgICAgICBzaWdtYU5vZGUuY29sb3IgPSBzZWxmLnNlbGVjdGVkRWxlbWVudCAmJiAoXHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zZWxlY3RlZEVsZW1lbnQuaWQgPT09IHNpZ21hTm9kZS5pZCB8fFxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2VsZWN0ZWRFbGVtZW50LmFzcGVjdHMgJiYgc2VsZi5zZWxlY3RlZEVsZW1lbnQuYXNwZWN0cy5maWx0ZXIoYSA9PiBhLmlkID09PSBzaWdtYU5vZGUuaWQpLmxlbmd0aCA+IDBcclxuICAgICAgICAgICAgICAgICkgPyBfY29sb3JzWydzZWxlY3RlZCddIDogX2NvbG9yc1tub2RlLm1vZGVsLnR5cGVJZF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHZpZXdGcmFtZXMgc3RhdGUuIFxyXG4gICAgICogQHBhcmFtIHtWaWV3RnJhbWVQdWJsaWNNb2RlbFtdfSB2aWV3RnJhbWVzXHJcbiAgICAgKi9cclxuICAgIHNlbGYuX3JlZnJlc2hWaWV3RnJhbWVzID0gZnVuY3Rpb24gKHZpZXdGcmFtZXMpIHtcclxuICAgICAgICB2aWV3RnJhbWVzLmZvckVhY2godmlld0ZyYW1lID0+IHtcclxuICAgICAgICAgICAgaWYgKHZpZXdGcmFtZS5hY3RpdmUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZyYW1lID0gX3NpZ21hRnJhbWVzW3ZpZXdGcmFtZS5pZF07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwb2ludHMgPSBfZ2V0RnJhbWVzUG9pbnRzKHZpZXdGcmFtZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgZnJhbWUucDEueCA9IHBvaW50cy5wMS54O1xyXG4gICAgICAgICAgICAgICAgZnJhbWUucDEueSA9IHBvaW50cy5wMS55O1xyXG5cclxuICAgICAgICAgICAgICAgIGZyYW1lLnAyLnggPSBwb2ludHMucDIueDtcclxuICAgICAgICAgICAgICAgIGZyYW1lLnAyLnkgPSBwb2ludHMucDIueTtcclxuXHJcbiAgICAgICAgICAgICAgICBmcmFtZS5wMy54ID0gcG9pbnRzLnAzLng7XHJcbiAgICAgICAgICAgICAgICBmcmFtZS5wMy55ID0gcG9pbnRzLnAzLnk7XHJcblxyXG4gICAgICAgICAgICAgICAgZnJhbWUucDQueCA9IHBvaW50cy5wNC54O1xyXG4gICAgICAgICAgICAgICAgZnJhbWUucDQueSA9IHBvaW50cy5wNC55O1xyXG5cclxuICAgICAgICAgICAgICAgIF9hZGRWaWV3RnJhbWUodmlld0ZyYW1lKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIF9yZW1vdmVWaWV3RnJhbWUodmlld0ZyYW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgdmlld0ZyYW1lIG9uIHRoZSBzaWdtYSBncmFwaC5cclxuICAgICAqIEBwYXJhbSB7Vmlld0ZyYW1lUHVibGljTW9kZWx9IHZpZXdGcmFtZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBfYWRkVmlld0ZyYW1lICh2aWV3RnJhbWUpIHtcclxuICAgICAgICBjb25zdCBmcmFtZSA9IF9zaWdtYUZyYW1lc1t2aWV3RnJhbWUuaWRdID1cclxuICAgICAgICAgICAgX3NpZ21hRnJhbWVzW3ZpZXdGcmFtZS5pZF0gfHwgX2NyZWF0ZVNpZ21hRnJhbWUodmlld0ZyYW1lKTtcclxuICAgICAgICBpZiAoIXZpZXdGcmFtZSB8fCBmcmFtZS5hY3RpdmUpIHJldHVybjsgICAgICAgIFxyXG5cclxuICAgICAgICBzZWxmLnNpZ21hR3JhcGguZ3JhcGguYWRkTm9kZShmcmFtZS5wMSk7XHJcbiAgICAgICAgc2VsZi5zaWdtYUdyYXBoLmdyYXBoLmFkZE5vZGUoZnJhbWUucDIpO1xyXG4gICAgICAgIHNlbGYuc2lnbWFHcmFwaC5ncmFwaC5hZGROb2RlKGZyYW1lLnAzKTtcclxuICAgICAgICBzZWxmLnNpZ21hR3JhcGguZ3JhcGguYWRkTm9kZShmcmFtZS5wNCk7XHJcblxyXG4gICAgICAgIHNlbGYuc2lnbWFHcmFwaC5ncmFwaC5hZGRFZGdlKGZyYW1lLnRvcCk7XHJcbiAgICAgICAgc2VsZi5zaWdtYUdyYXBoLmdyYXBoLmFkZEVkZ2UoZnJhbWUuYm90dG9tKTtcclxuICAgICAgICBzZWxmLnNpZ21hR3JhcGguZ3JhcGguYWRkRWRnZShmcmFtZS5sZWZ0KTtcclxuICAgICAgICBzZWxmLnNpZ21hR3JhcGguZ3JhcGguYWRkRWRnZShmcmFtZS5yaWdodCk7XHJcblxyXG4gICAgICAgIGZyYW1lLmFjdGl2ZSA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIHZpZXdGcmFtZSBmcm9tIHRoZSBzaWdtYSBncmFwaC5cclxuICAgICAqIEBwYXJhbSB7Vmlld0ZyYW1lUHVibGljTW9kZWx9IHZpZXdGcmFtZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBfcmVtb3ZlVmlld0ZyYW1lICh2aWV3RnJhbWUpIHtcclxuICAgICAgICBpZiAoIXZpZXdGcmFtZSB8fCAhX3NpZ21hRnJhbWVzW3ZpZXdGcmFtZS5pZF0uYWN0aXZlKSByZXR1cm47XHJcblxyXG4gICAgICAgIHNlbGYuc2lnbWFHcmFwaC5ncmFwaC5kcm9wRWRnZSh2aWV3RnJhbWUuaWQgKyAnX190b3AnKTtcclxuICAgICAgICBzZWxmLnNpZ21hR3JhcGguZ3JhcGguZHJvcEVkZ2Uodmlld0ZyYW1lLmlkICsgJ19fYm90dG9tJyk7XHJcbiAgICAgICAgc2VsZi5zaWdtYUdyYXBoLmdyYXBoLmRyb3BFZGdlKHZpZXdGcmFtZS5pZCArICdfX2xlZnQnKTtcclxuICAgICAgICBzZWxmLnNpZ21hR3JhcGguZ3JhcGguZHJvcEVkZ2Uodmlld0ZyYW1lLmlkICsgJ19fcmlnaHQnKTtcclxuXHJcbiAgICAgICAgc2VsZi5zaWdtYUdyYXBoLmdyYXBoLmRyb3BOb2RlKHZpZXdGcmFtZS5pZCArICdfX1RMJyk7XHJcbiAgICAgICAgc2VsZi5zaWdtYUdyYXBoLmdyYXBoLmRyb3BOb2RlKHZpZXdGcmFtZS5pZCArICdfX0JMJyk7XHJcbiAgICAgICAgc2VsZi5zaWdtYUdyYXBoLmdyYXBoLmRyb3BOb2RlKHZpZXdGcmFtZS5pZCArICdfX1RSJyk7XHJcbiAgICAgICAgc2VsZi5zaWdtYUdyYXBoLmdyYXBoLmRyb3BOb2RlKHZpZXdGcmFtZS5pZCArICdfX0JSJyk7XHJcblxyXG4gICAgICAgIF9zaWdtYUZyYW1lc1t2aWV3RnJhbWUuaWRdLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBsaW5rcyBhbmQgbm9kZXMuXHJcbiAgICAgKiBAcmV0dXJucyB7e05vZGVbXSwgTGlua1tdfX1cclxuICAgICAqL1xyXG4gICAgc2VsZi5fZ2V0RGF0YSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4geyBub2Rlczogc2VsZi5fZGF0YUNvbnRhaW5lci5ub2RlcywgbGlua3M6IHNlbGYuX2RhdGFDb250YWluZXIubGlua3MgfTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIHNpZ21hIG5vZGUgZnJvbSBqb2ludGpzIG5vZGUuXHJcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgXHJcbiAgICAgKi9cclxuICAgIHNlbGYuX2NyZWF0ZU5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0R2xvYmFsTm9kZVBvc2l0aW9uKG5vZGUpO1xyXG4gICAgICAgIGNvbnN0IG1vZGVsID0gbm9kZS5tb2RlbDtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBpZDogbm9kZS5pZCxcclxuICAgICAgICAgICAgbGFiZWw6IG1vZGVsLmxhYmVsLFxyXG4gICAgICAgICAgICB4OiBwb3NpdGlvbi54LFxyXG4gICAgICAgICAgICB5OiBwb3NpdGlvbi55LFxyXG4gICAgICAgICAgICBzaXplOiAxLFxyXG4gICAgICAgICAgICBjb2xvcjogbm9kZSA9PT0gc2VsZi5zZWxlY3RlZEVsZW1lbnQgfHwgKHNlbGYuc2VsZWN0ZWRFbGVtZW50ICYmXHJcbiAgICAgICAgICAgICAgICBzZWxmLnNlbGVjdGVkRWxlbWVudC5hc3BlY3RzICYmXHJcbiAgICAgICAgICAgICAgICBzZWxmLnNlbGVjdGVkRWxlbWVudC5hc3BlY3RzLmZpbHRlcihhID0+IGEuaWQgPT09IG5vZGUuaWQpLmxlbmd0aCA+IDBcclxuICAgICAgICAgICAgKSA/IF9jb2xvcnNbJ3NlbGVjdGVkJ10gOiBfY29sb3JzW21vZGVsLnR5cGVJZF0sXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIHNpZ21hIGVkZ2UgZnJvbSBqb2ludGpzIGxpbmsuXHJcbiAgICAgKiBAcGFyYW0ge0xpbmt9IGxpbmsgXHJcbiAgICAgKi9cclxuICAgIHNlbGYuX2NyZWF0ZUxpbmsgPSBmdW5jdGlvbiAobGluaykge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGlkOiBsaW5rLmlkLFxyXG4gICAgICAgICAgICBzb3VyY2U6IGxpbmsubW9kZWwuc291cmNlLFxyXG4gICAgICAgICAgICB0YXJnZXQ6IGxpbmsubW9kZWwudGFyZ2V0LFxyXG4gICAgICAgICAgICBzaXplOiBsaW5rID09PSBzZWxmLnNlbGVjdGVkRWxlbWVudCA/IDUgOiAxLFxyXG4gICAgICAgICAgICBjb2xvcjogbGluayA9PT0gc2VsZi5zZWxlY3RlZEVsZW1lbnQgPyBfY29sb3JzWydzZWxlY3RlZCddIDogJ2JsYWNrJyxcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFN1YnNjcmliZXMgb24gZXZlbnRzLlxyXG4gICAgICogQGZpcmVzOiBzZWxlY3RlZC1lbGVtZW50LWNoYW5nZWQgKHBhcmFtczogTm9kZXxMaW5rKVxyXG4gICAgICogQGZpcmVzOiBjZWxsLWRvdWJsZS1jbGljayAocGFyYW1zOiBOb2RlfExpbmspXHJcbiAgICAgKi9cclxuICAgIHNlbGYuX3N1YnNjcmliZU9uRXZlbnRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHNlbGYuc2lnbWFHcmFwaC5iaW5kKCdjbGlja05vZGUgY2xpY2tTdGFnZScsIGUgPT4gX29uQ2xpY2soZSwgXHJcbiAgICAgICAgICAgIChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IGV2ZW50LmRhdGEubm9kZSA/IHNlbGYuX2RhdGFDb250YWluZXIubWFwcy5ub2RlTWFwW2V2ZW50LmRhdGEubm9kZS5pZF0gOiBudWxsO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUgfHwgIWV2ZW50LmRhdGEuY2FwdG9yLmlzRHJhZ2dpbmcgJiYgIW5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLnNldFNlbGVjdGVkRWxlbWVudChub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLnRyaWdnZXIoJ3NlbGVjdGVkLWVsZW1lbnQtY2hhbmdlZCcsIG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBldmVudC5kYXRhLmVkZ2UgPyBzZWxmLl9kYXRhQ29udGFpbmVyLm1hcHMubGlua01hcFtldmVudC5kYXRhLmVkZ2UuaWRdIDogbnVsbDtcclxuICAgICAgICAgICAgICAgIHNlbGYudHJpZ2dlcignY2VsbC1kb3VibGUtY2xpY2snLCBlbGVtZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICkpO1xyXG5cclxuICAgICAgICBzZWxmLnNpZ21hR3JhcGguYmluZCgnY2xpY2tFZGdlJywgZSA9PiBfb25DbGljayhlLCBcclxuICAgICAgICAgICAgKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsaW5rID0gZXZlbnQuZGF0YS5lZGdlID8gc2VsZi5fZGF0YUNvbnRhaW5lci5tYXBzLmxpbmtNYXBbZXZlbnQuZGF0YS5lZGdlLmlkXSA6IG51bGw7XHJcbiAgICAgICAgICAgICAgICBzZWxmLnNldFNlbGVjdGVkRWxlbWVudChsaW5rKTtcclxuICAgICAgICAgICAgICAgIHNlbGYudHJpZ2dlcignc2VsZWN0ZWQtZWxlbWVudC1jaGFuZ2VkJywgbGluayk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGV2ZW50LmRhdGEuZWRnZSA/IHNlbGYuX2RhdGFDb250YWluZXIubWFwcy5saW5rTWFwW2V2ZW50LmRhdGEuZWRnZS5pZF0gOiBudWxsO1xyXG4gICAgICAgICAgICAgICAgc2VsZi50cmlnZ2VyKCdjZWxsLWRvdWJsZS1jbGljaycsIGVsZW1lbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBkZWZhdWx0IHNpemUgZm9yIG5vZGVzLiBcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gX2dldE5vZGVTaXplICgpIHtcclxuICAgICAgICBsZXQgcmVzdWx0O1xyXG4gICAgICAgIGlmIChzZWxmLl9kYXRhQ29udGFpbmVyLm5vZGVzLmxlbmd0aCA8PSAwKSByZXR1cm4gMDtcclxuICAgICAgICBpZiAoc2VsZi5zaWdtYUdyYXBoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlbmRlcmVyID0gc2VsZi5zaWdtYUdyYXBoLnJlbmRlcmVyc1swXSB8fCB7IHdpZHRoOiBfcm9vdEVsZW1lbnQuY2xpZW50V2lkdGgsIGhlaWdodDogX3Jvb3RFbGVtZW50LmNsaWVudEhlaWdodCwgfTtcclxuICAgICAgICAgICAgaWYgKHBhcmFtZXRlcnMuZWxlbWVudFNpemUud2lkdGggPiBwYXJhbWV0ZXJzLmVsZW1lbnRTaXplLmhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVuZGVyZXIud2lkdGggLyAocGFyYW1ldGVycy5lbGVtZW50U2l6ZS53aWR0aCArIHBhcmFtZXRlcnMubGF5b3V0U3RlcC54KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlbmRlcmVyLmhlaWdodCAvIChwYXJhbWV0ZXJzLmVsZW1lbnRTaXplLmhlaWdodCArIHBhcmFtZXRlcnMubGF5b3V0U3RlcC55KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IDU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzZWxmLl9nZXROb2RlU2l6ZSkgcmV0dXJuIHNlbGYuX2dldE5vZGVTaXplKHJlc3VsdCk7XHJcbiAgICAgICAgZWxzZSByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhc3BlY3QgbGlua3MuXHJcbiAgICAgKiBAcGFyYW0ge05vZGVbXX0gbm9kZXNcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gX2NyZWF0ZUFzcGVjdExpbmtzIChub2Rlcykge1xyXG4gICAgICAgIHNlbGYuX2FzcGVjdExpbmtzID0ge307XHJcbiAgICAgICAgY29uc3QgbGlua3NUb1JldHVybiA9IFtdO1xyXG4gICAgICAgIG5vZGVzLmZvckVhY2gobm9kZSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBhc3BlY3RzID0gbm9kZS5hc3BlY3RzO1xyXG5cclxuICAgICAgICAgICAgYXNwZWN0cy5mb3JFYWNoKGFzcGVjdCA9PiB7XHJcbiAgICAgICAgICAgICAgICBhZGRMaW5rKG5vZGUsIGFzcGVjdCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBhZGRMaW5rIChub2RlLCBhc3BlY3QpIHtcclxuICAgICAgICAgICAgY29uc3QgaWQxID0gbm9kZS5pZCArICd+I3RxTGdBc3BlY3RMaW5rI34nICsgYXNwZWN0LmlkO1xyXG4gICAgICAgICAgICBjb25zdCBpZDIgPSBhc3BlY3QuaWQgKyAnfiN0cUxnQXNwZWN0TGluayN+JyArIG5vZGUuaWQ7XHJcblxyXG4gICAgICAgICAgICBpZiAoIXNlbGYuX2FzcGVjdExpbmtzW2lkMV0gJiYgIXNlbGYuX2FzcGVjdExpbmtzW2lkMl0pIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFsID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlkOiBpZDEsXHJcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOiBub2RlLmlkLFxyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogYXNwZWN0LmlkLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiBfY29sb3JzWydhc3BlY3RMaW5rJ10sXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgc2VsZi5fYXNwZWN0TGlua3NbaWQxXSA9IGFsO1xyXG4gICAgICAgICAgICAgICAgbGlua3NUb1JldHVybi5wdXNoKGFsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGxpbmtzVG9SZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIHNpZ21hIG5vdGF0aW9uIG9mIHRoZSBqb2ludCB2aWV3RnJhbWUgYW5kIHBsYWNlcyBvbiB0aGUgc2lnbWEgZ3JhcGguXHJcbiAgICAgKiBAcGFyYW0ge1ZpZXdGcmFtZVB1YmxpY01vZGVsfSB2aWV3RnJhbWVcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gX2NyZWF0ZVNpZ21hRnJhbWUgKHZpZXdGcmFtZSkge1xyXG4gICAgICAgIGNvbnN0IHBvaW50cyA9IF9nZXRGcmFtZXNQb2ludHModmlld0ZyYW1lKTtcclxuICAgICAgICBjb25zdCBjb2xvciA9IHZpZXdGcmFtZS5ib3JkZXJDb2xvcjtcclxuXHJcbiAgICAgICAgLy8gbm9kZXNcclxuXHJcbiAgICAgICAgY29uc3QgcDEgPSB7XHJcbiAgICAgICAgICAgIGlkOiB2aWV3RnJhbWUuaWQgKyAnX19UTCcsXHJcbiAgICAgICAgICAgIGxhYmVsOiB2aWV3RnJhbWUuaWQsXHJcbiAgICAgICAgICAgIHg6IHBvaW50cy5wMS54LFxyXG4gICAgICAgICAgICB5OiBwb2ludHMucDEueSxcclxuICAgICAgICAgICAgc2l6ZTogMC4zLFxyXG4gICAgICAgICAgICBjb2xvcjogY29sb3IsXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgY29uc3QgcDIgPSB7XHJcbiAgICAgICAgICAgIGlkOiB2aWV3RnJhbWUuaWQgKyAnX19CTCcsXHJcbiAgICAgICAgICAgIGxhYmVsOiB2aWV3RnJhbWUuaWQsXHJcbiAgICAgICAgICAgIHg6IHBvaW50cy5wMy54LFxyXG4gICAgICAgICAgICB5OiBwb2ludHMucDMueSxcclxuICAgICAgICAgICAgc2l6ZTogMC4zLFxyXG4gICAgICAgICAgICBjb2xvcjogY29sb3IsXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgY29uc3QgcDMgPSB7XHJcbiAgICAgICAgICAgIGlkOiB2aWV3RnJhbWUuaWQgKyAnX19UUicsXHJcbiAgICAgICAgICAgIGxhYmVsOiB2aWV3RnJhbWUuaWQsXHJcbiAgICAgICAgICAgIHg6IHBvaW50cy5wMi54LFxyXG4gICAgICAgICAgICB5OiBwb2ludHMucDIueSxcclxuICAgICAgICAgICAgc2l6ZTogMC4zLFxyXG4gICAgICAgICAgICBjb2xvcjogY29sb3IsXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgY29uc3QgcDQgPSB7XHJcbiAgICAgICAgICAgIGlkOiB2aWV3RnJhbWUuaWQgKyAnX19CUicsXHJcbiAgICAgICAgICAgIGxhYmVsOiB2aWV3RnJhbWUuaWQsXHJcbiAgICAgICAgICAgIHg6IHBvaW50cy5wNC54LFxyXG4gICAgICAgICAgICB5OiBwb2ludHMucDQueSxcclxuICAgICAgICAgICAgc2l6ZTogMC4zLFxyXG4gICAgICAgICAgICBjb2xvcjogY29sb3IsXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gRWRnZXNcclxuXHJcbiAgICAgICAgY29uc3QgdG9wID0ge1xyXG4gICAgICAgICAgICBpZDogdmlld0ZyYW1lLmlkICsgJ19fdG9wJyxcclxuICAgICAgICAgICAgc291cmNlOiB2aWV3RnJhbWUuaWQgKyAnX19UTCcsXHJcbiAgICAgICAgICAgIHRhcmdldDogdmlld0ZyYW1lLmlkICsgJ19fVFInLFxyXG4gICAgICAgICAgICBzaXplOiAxMCxcclxuICAgICAgICAgICAgY29sb3I6IGNvbG9yXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgY29uc3QgYm90dG9tID0ge1xyXG4gICAgICAgICAgICBpZDogdmlld0ZyYW1lLmlkICsgJ19fYm90dG9tJyxcclxuICAgICAgICAgICAgc291cmNlOiB2aWV3RnJhbWUuaWQgKyAnX19CTCcsXHJcbiAgICAgICAgICAgIHRhcmdldDogdmlld0ZyYW1lLmlkICsgJ19fQlInLFxyXG4gICAgICAgICAgICBzaXplOiAxMCxcclxuICAgICAgICAgICAgY29sb3I6IGNvbG9yXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgY29uc3QgbGVmdCA9IHtcclxuICAgICAgICAgICAgaWQ6IHZpZXdGcmFtZS5pZCArICdfX2xlZnQnLFxyXG4gICAgICAgICAgICBzb3VyY2U6IHZpZXdGcmFtZS5pZCArICdfX1RMJyxcclxuICAgICAgICAgICAgdGFyZ2V0OiB2aWV3RnJhbWUuaWQgKyAnX19CTCcsXHJcbiAgICAgICAgICAgIHNpemU6IDEwLFxyXG4gICAgICAgICAgICBjb2xvcjogY29sb3JcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBjb25zdCByaWdodCA9IHtcclxuICAgICAgICAgICAgaWQ6IHZpZXdGcmFtZS5pZCArICdfX3JpZ2h0JyxcclxuICAgICAgICAgICAgc291cmNlOiB2aWV3RnJhbWUuaWQgKyAnX19UUicsXHJcbiAgICAgICAgICAgIHRhcmdldDogdmlld0ZyYW1lLmlkICsgJ19fQlInLFxyXG4gICAgICAgICAgICBzaXplOiAxMCxcclxuICAgICAgICAgICAgY29sb3I6IGNvbG9yXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcDE6IHAxLFxyXG4gICAgICAgICAgICBwMjogcDIsXHJcbiAgICAgICAgICAgIHAzOiBwMyxcclxuICAgICAgICAgICAgcDQ6IHA0LFxyXG5cclxuICAgICAgICAgICAgdG9wOiB0b3AsXHJcbiAgICAgICAgICAgIGJvdHRvbTogYm90dG9tLFxyXG4gICAgICAgICAgICBsZWZ0OiBsZWZ0LFxyXG4gICAgICAgICAgICByaWdodDogcmlnaHQsXHJcblxyXG4gICAgICAgICAgICBhY3RpdmU6IGZhbHNlLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX2dldEZyYW1lc1BvaW50cyAodmlld0ZyYW1lKSB7XHJcbiAgICAgICAgY29uc3QgcDEgPSB7XHJcbiAgICAgICAgICAgIHg6IHZpZXdGcmFtZS52aWV3UG9ydEJvdW5kcy5taW5YLFxyXG4gICAgICAgICAgICB5OiB2aWV3RnJhbWUudmlld1BvcnRCb3VuZHMubWluWSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IHAyID0geyB4OiBwMS54ICsgdmlld0ZyYW1lLnZpZXdQb3J0Qm91bmRzLndpZHRoLCB5OiBwMS55IH07XHJcbiAgICAgICAgY29uc3QgcDMgPSB7IHg6IHAxLngsIHk6IHAxLnkgKyB2aWV3RnJhbWUudmlld1BvcnRCb3VuZHMuaGVpZ2h0IH07XHJcbiAgICAgICAgY29uc3QgcDQgPSB7IHg6IHAxLnggKyB2aWV3RnJhbWUudmlld1BvcnRCb3VuZHMud2lkdGgsIHk6IHAxLnkgKyB2aWV3RnJhbWUudmlld1BvcnRCb3VuZHMuaGVpZ2h0IH07XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHAxOiBwMSxcclxuICAgICAgICAgICAgcDI6IHAyLFxyXG4gICAgICAgICAgICBwMzogcDMsXHJcbiAgICAgICAgICAgIHA0OiBwNCxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEZpeGluZyB0aGUgc2lnbWEgYnVnIHdpdGggaG9yaXpvbnRhbC92ZXJ0aWNhbCBsaW5lcyBob3ZlcmluZy5cclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgU2lnbWEudXRpbHMuaXNQb2ludE9uU2VnbWVudCA9IGZ1bmN0aW9uICh4LCB5LCB4MSwgeTEsIHgyLCB5MiwgZXBzaWxvbikge1xyXG4gICAgICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzMyODEyMlxyXG4gICAgICAgIHZhciBjcm9zc1Byb2R1Y3QgPSBNYXRoLmFicygoeSAtIHkxKSAqICh4MiAtIHgxKSAtICh4IC0geDEpICogKHkyIC0geTEpKSxcclxuICAgICAgICAgICAgZCA9IFNpZ21hLnV0aWxzLmdldERpc3RhbmNlKHgxLCB5MSwgeDIsIHkyKSxcclxuICAgICAgICAgICAgbkNyb3NzUHJvZHVjdCA9IGNyb3NzUHJvZHVjdCAvIGQ7IC8vIG5vcm1hbGl6ZWQgY3Jvc3MgcHJvZHVjdFxyXG5cclxuICAgICAgICByZXR1cm4gKG5Dcm9zc1Byb2R1Y3QgPCBlcHNpbG9uICYmXHJcbiAgICAgICAgICAgIE1hdGgubWluKHgxLCB4MikgLSBlcHNpbG9uIDw9IHggJiYgeCA8PSBNYXRoLm1heCh4MSwgeDIpICsgZXBzaWxvbiAmJlxyXG4gICAgICAgICAgICBNYXRoLm1pbih5MSwgeTIpIC0gZXBzaWxvbiA8PSB5ICYmIHkgPD0gTWF0aC5tYXgoeTEsIHkyKSArIGVwc2lsb24pO1xyXG4gICAgfTtcclxuXHJcbiAgICBsZXQgX2NsaWNrcyA9IDA7XHJcbiAgICBmdW5jdGlvbiBfb25DbGljayAoZXZlbnQsIGNsaWNrQ2FsbGJhY2ssIGRvdWJsZUNsaWNrQ2FsbGJhY2spIHtcclxuICAgICAgICBfY2xpY2tzKys7XHJcblxyXG4gICAgICAgIGlmIChfY2xpY2tzID49IDIpIHtcclxuICAgICAgICAgICAgX2NsaWNrcyA9IDA7XHJcbiAgICAgICAgICAgIGRvdWJsZUNsaWNrQ2FsbGJhY2soZXZlbnQpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoX2NsaWNrcyA9PT0gMSkge1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChfY2xpY2tzID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xpY2tDYWxsYmFjayhldmVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBfY2xpY2tzID0gMDtcclxuICAgICAgICAgICAgfSwgMjUwKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGRlZmF1bHQgU2lnbWFCYXNlO1xyXG4iLCJleHBvcnQgZnVuY3Rpb24gdXNlUGx1Z2luIChzaWdtYSkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2lnbWEgUmVuZGVyZXIgU25hcHNob3QgVXRpbGl0eVxyXG4gICAgICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgICAqXHJcbiAgICAgKiBUaGUgYWltIG9mIHRoaXMgcGx1Z2luIGlzIHRvIGVuYWJsZSB1c2VycyB0byByZXRyaWV2ZSBhIHN0YXRpYyBpbWFnZVxyXG4gICAgICogb2YgdGhlIGdyYXBoIGJlaW5nIHJlbmRlcmVkLlxyXG4gICAgICpcclxuICAgICAqIEF1dGhvcjogR3VpbGxhdW1lIFBsaXF1ZSAoWW9tZ3VpdGhlcmVhbClcclxuICAgICAqIFZlcnNpb246IDAuMC4xXHJcbiAgICAgKi9cclxuXHJcbiAgICAvLyBUZXJtaW5hdGluZyBpZiBzaWdtYSB3ZXJlIG5vdCB0byBiZSBmb3VuZFxyXG4gICAgaWYgKHR5cGVvZiBzaWdtYSA9PT0gJ3VuZGVmaW5lZCcpXHJcbiAgICAgICAgdGhyb3cgJ3NpZ21hLnJlbmRlcmVycy5zbmFwc2hvdDogc2lnbWEgbm90IGluIHNjb3BlLic7XHJcblxyXG4gICAgLy8gQ29uc3RhbnRzXHJcbiAgICB2YXIgQ09OVEVYVFMgPSBbJ3NjZW5lJywgJ2VkZ2VzJywgJ25vZGVzJywgJ2xhYmVscyddLFxyXG4gICAgICAgIFRZUEVTID0ge1xyXG4gICAgICAgICAgICBwbmc6ICdpbWFnZS9wbmcnLFxyXG4gICAgICAgICAgICBqcGc6ICdpbWFnZS9qcGVnJyxcclxuICAgICAgICAgICAgZ2lmOiAnaW1hZ2UvZ2lmJyxcclxuICAgICAgICAgICAgdGlmZjogJ2ltYWdlL3RpZmYnXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAvLyBVdGlsaXRpZXNcclxuICAgIGZ1bmN0aW9uIGRvd25sb2FkIChkYXRhVXJsLCBleHRlbnNpb24sIGZpbGVuYW1lKSB7XHJcblxyXG4gICAgICAgIC8vIEFuY2hvclxyXG4gICAgICAgIHZhciBhbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XHJcbiAgICAgICAgYW5jaG9yLnNldEF0dHJpYnV0ZSgnaHJlZicsIGRhdGFVcmwpO1xyXG4gICAgICAgIGFuY2hvci5zZXRBdHRyaWJ1dGUoJ2Rvd25sb2FkJywgZmlsZW5hbWUgfHwgJ2dyYXBoLicgKyBleHRlbnNpb24pO1xyXG5cclxuICAgICAgICAvLyBDbGljayBldmVudFxyXG4gICAgICAgIHZhciBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdNb3VzZUV2ZW50Jyk7XHJcbiAgICAgICAgZXZlbnQuaW5pdE1vdXNlRXZlbnQoJ2NsaWNrJywgdHJ1ZSwgZmFsc2UsIHdpbmRvdywgMCwgMCwgMCwgMCwgMCxcclxuICAgICAgICAgICAgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIDAsIG51bGwpO1xyXG5cclxuICAgICAgICBhbmNob3IuZGlzcGF0Y2hFdmVudChldmVudCk7XHJcbiAgICAgICAgYW5jaG9yID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIE1haW4gZnVuY3Rpb25cclxuICAgIGZ1bmN0aW9uIHNuYXBzaG90IChwYXJhbXMpIHtcclxuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgfHwge307XHJcblxyXG4gICAgICAgIC8vIEVuZm9yY2luZ1xyXG4gICAgICAgIGlmIChwYXJhbXMuZm9ybWF0ICYmICEocGFyYW1zLmZvcm1hdCBpbiBUWVBFUykpXHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdzaWdtYS5yZW5kZXJlcnMuc25hcGhvdDogdW5zdXBwb3J0ZWQgZm9ybWF0IFwiJyArXHJcbiAgICAgICAgICAgICAgICBwYXJhbXMuZm9ybWF0ICsgJ1wiLicpO1xyXG5cclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXHJcbiAgICAgICAgICAgIHdlYmdsID0gdGhpcyBpbnN0YW5jZW9mIHNpZ21hLnJlbmRlcmVycy53ZWJnbCxcclxuICAgICAgICAgICAgZG9uZUNvbnRleHRzID0gW107XHJcblxyXG4gICAgICAgIC8vIENyZWF0aW5nIGEgZmFsc2UgY2FudmFzIHdoZXJlIHdlJ2xsIG1lcmdlIHRoZSBvdGhlclxyXG4gICAgICAgIHZhciBtZXJnZWQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKSxcclxuICAgICAgICAgICAgbWVyZ2VkQ29udGV4dCA9IG1lcmdlZC5nZXRDb250ZXh0KCcyZCcpLFxyXG4gICAgICAgICAgICBzaXplZCA9IGZhbHNlO1xyXG5cclxuICAgICAgICAvLyBJdGVyYXRpbmcgdGhyb3VnaCBjb250ZXh0XHJcbiAgICAgICAgQ09OVEVYVFMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgICAgICBpZiAoIXNlbGYuY29udGV4dHNbbmFtZV0pXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICBpZiAocGFyYW1zLmxhYmVscyA9PT0gZmFsc2UgJiYgbmFtZSA9PT0gJ2xhYmVscycpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICB2YXIgY2FudmFzID0gc2VsZi5kb21FbGVtZW50c1tuYW1lXSB8fCBzZWxmLmRvbUVsZW1lbnRzWydzY2VuZSddLFxyXG4gICAgICAgICAgICAgICAgY29udGV4dCA9IHNlbGYuY29udGV4dHNbbmFtZV07XHJcblxyXG4gICAgICAgICAgICBpZiAofmRvbmVDb250ZXh0cy5pbmRleE9mKGNvbnRleHQpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFzaXplZCkge1xyXG4gICAgICAgICAgICAgICAgbWVyZ2VkLndpZHRoID0gd2ViZ2wgJiYgY29udGV4dCBpbnN0YW5jZW9mIFdlYkdMUmVuZGVyaW5nQ29udGV4dCA/XHJcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzLndpZHRoIC8gMiA6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzLndpZHRoO1xyXG4gICAgICAgICAgICAgICAgbWVyZ2VkLmhlaWdodCA9IHdlYmdsICYmIGNvbnRleHQgaW5zdGFuY2VvZiBXZWJHTFJlbmRlcmluZ0NvbnRleHQgP1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgLyAyIDpcclxuICAgICAgICAgICAgICAgICAgICBjYW52YXMuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgc2l6ZWQgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIERvIHdlIHdhbnQgYSBiYWNrZ3JvdW5kIGNvbG9yP1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5iYWNrZ3JvdW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VkQ29udGV4dC5yZWN0KDAsIDAsIG1lcmdlZC53aWR0aCwgbWVyZ2VkLmhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VkQ29udGV4dC5maWxsU3R5bGUgPSBwYXJhbXMuYmFja2dyb3VuZDtcclxuICAgICAgICAgICAgICAgICAgICBtZXJnZWRDb250ZXh0LmZpbGwoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGNvbnRleHQgaW5zdGFuY2VvZiBXZWJHTFJlbmRlcmluZ0NvbnRleHQpXHJcbiAgICAgICAgICAgICAgICBtZXJnZWRDb250ZXh0LmRyYXdJbWFnZShjYW52YXMsIDAsIDAsXHJcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzLndpZHRoIC8gMiwgY2FudmFzLmhlaWdodCAvIDIpO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICBtZXJnZWRDb250ZXh0LmRyYXdJbWFnZShjYW52YXMsIDAsIDApO1xyXG5cclxuICAgICAgICAgICAgZG9uZUNvbnRleHRzLnB1c2goY29udGV4dCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHZhciBkYXRhVXJsID0gbWVyZ2VkLnRvRGF0YVVSTChUWVBFU1twYXJhbXMuZm9ybWF0IHx8ICdwbmcnXSk7XHJcblxyXG4gICAgICAgIGlmIChwYXJhbXMuZG93bmxvYWQpXHJcbiAgICAgICAgICAgIGRvd25sb2FkKFxyXG4gICAgICAgICAgICAgICAgZGF0YVVybCxcclxuICAgICAgICAgICAgICAgIHBhcmFtcy5mb3JtYXQgfHwgJ3BuZycsXHJcbiAgICAgICAgICAgICAgICBwYXJhbXMuZmlsZW5hbWVcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgLy8gQ2xlYW5pbmdcclxuICAgICAgICBtZXJnZWRDb250ZXh0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIG1lcmdlZCA9IHVuZGVmaW5lZDtcclxuICAgICAgICBkb25lQ29udGV4dHMgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgIHJldHVybiBkYXRhVXJsO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEV4dGVuZGluZyBjYW52YXMgYW5kIHdlYmwgcmVuZGVyZXJzXHJcbiAgICBzaWdtYS5yZW5kZXJlcnMuY2FudmFzLnByb3RvdHlwZS5zbmFwc2hvdCA9IHNuYXBzaG90O1xyXG4gICAgc2lnbWEucmVuZGVyZXJzLndlYmdsLnByb3RvdHlwZS5zbmFwc2hvdCA9IHNuYXBzaG90O1xyXG59XHJcbmV4cG9ydCBkZWZhdWx0IHVzZVBsdWdpbjsiLCIndXNlIHN0cmljdCc7XHJcbmltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XHJcblxyXG5jb25zdCBERUZBVUxUX0RFQ0tfTEVOR1RIID0gNDtcclxuXHJcbi8qKlxyXG4gKiBTdG9yZSBzdGF0ZXMgb2YgTEcuIFN0YXRlcyBpcyBhIERpYWdyYW1zIHJlbmRlcmVkIGFyb3VuZCBmb2N1c05vZGUuXHJcbiAqIEBjbGFzc1xyXG4gKiBAcHJpdmF0ZVxyXG4gKiBDb25zdHJ1Y3RvciBwYXJhbWV0ZXJzXHJcbiAqICBAcGFyYW0ge1BhcmFtZXRlcnN9IHBhcmFtZXRlcnNcclxuXHJcbiAqIFB1YmxpYyBtZXRob2RzOlxyXG4gKiBwdXNoU3RhdGU6ICgpID0+IHZvaWRcclxuICogZ2V0SGlzdG9yeTogKCkgPT4ge1xyXG4gKiAgc3RhdGVzOiB7IG5vZGVzOiBOb2RlW10sIGxpbmtzOiBMaW5rW10sIGZvY3VzTm9kZTogTm9kZSB9W10sXHJcbiAqICBjdXJyZW50SW5kZXg6IG51bWJlcixcclxuICogfVxyXG4gKiB1bmRvU3RhdGU6ICgpID0+IHZvaWRcclxuICogcmVkb1N0YXRlOiAoKSA9PiB2b2lkXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gU3RhdGVTdG9yYWdlIChwYXJhbWV0ZXJzKSB7XHJcbiAgICBjb25zdCBzZWxmID0gdGhpcztcclxuICAgIGlmICghcGFyYW1ldGVycykgcGFyYW1ldGVycyA9IHt9O1xyXG5cclxuICAgIGNvbnN0IF9zdGF0ZURlY2sgPSBbXTtcclxuICAgIGNvbnN0IF9tYXhEZWNrTGVuZ3RoID0gcGFyYW1ldGVycy5kZWNrTGVuZ3RoIHx8IERFRkFVTFRfREVDS19MRU5HVEg7XHJcbiAgICBsZXQgX2N1cnJlbnRJbmRleCA9IC0xO1xyXG5cclxuICAgIHNlbGYucHVzaFN0YXRlID0gZnVuY3Rpb24gKHN0YXRlKSB7XHJcbiAgICAgICAgaWYgKF9zdGF0ZURlY2subGVuZ3RoIC0gMSA+IF9jdXJyZW50SW5kZXgpIHtcclxuICAgICAgICAgICAgX3N0YXRlRGVjay5zcGxpY2UoX2N1cnJlbnRJbmRleCArIDEsIF9zdGF0ZURlY2subGVuZ3RoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX3N0YXRlRGVjay5wdXNoKHN0YXRlKTtcclxuICAgICAgICBfY2hlY2soKTtcclxuICAgICAgICBfY3VycmVudEluZGV4ID0gX3N0YXRlRGVjay5sZW5ndGggLSAxO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLnVwZGF0ZVN0YXRlID0gZnVuY3Rpb24gKHN0YXRlKSB7XHJcbiAgICAgICAgX3N0YXRlRGVja1tfY3VycmVudEluZGV4XSA9IHN0YXRlO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLmdldEhpc3RvcnkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgc3RhdGVzOiBjbG9uZURlZXAoX3N0YXRlRGVjayksXHJcbiAgICAgICAgICAgIGN1cnJlbnRJbmRleDogX2N1cnJlbnRJbmRleCxcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLnVuZG9TdGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoX2N1cnJlbnRJbmRleCA+IDApIHtcclxuICAgICAgICAgICAgX2N1cnJlbnRJbmRleC0tO1xyXG4gICAgICAgICAgICByZXR1cm4gX3JldHVyblN0YXRlKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLnJlZG9TdGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoX2N1cnJlbnRJbmRleCArIDEgPCBfc3RhdGVEZWNrLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBfY3VycmVudEluZGV4Kys7XHJcbiAgICAgICAgICAgIHJldHVybiBfcmV0dXJuU3RhdGUoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBfcmV0dXJuU3RhdGUgKCkge1xyXG4gICAgICAgIHJldHVybiBfc3RhdGVEZWNrW19jdXJyZW50SW5kZXhdO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIF9jaGVjayAoKSB7XHJcbiAgICAgICAgaWYgKF9zdGF0ZURlY2subGVuZ3RoID4gX21heERlY2tMZW5ndGgpIF9zdGF0ZURlY2suc2hpZnQoKTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgU3RhdGVTdG9yYWdlO1xyXG5cclxuIiwiaW1wb3J0ICogYXMgXyBmcm9tICdsb2Rhc2gnO1xuXG4vKiogXG4gKiBJdCdzIGJhc2UgY2xhc3Mgd2hpY2ggcHJvdmlkZXMgc3Vic2NyaXB0aW9uIEFQSSBmb3Igc3VjY2Vzc29ycy5cbiAqIEBjbGFzc1xuKi9cbmV4cG9ydCBmdW5jdGlvbiBTdWJzY3JpYmFibGUgKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHNlbGYuX3N1YnNjcmlidGlvbnMgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCBhbGxvd3MgdG8gc3Vic2NyaWJlIG9uIGEgc29tZSBzcGVjaWZpYyBldmVudC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQgLSBldmVudCBpZFxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gZXZlbnQgaGFuZGxlclxuICAgICAqIEBtZW1iZXJvZiBTdWJzY3JpYmFibGVcbiAgICAgKiBAbWV0aG9kXG4gICAgKi9cbiAgICBzZWxmLm9uID0gZnVuY3Rpb24gKGV2ZW50LCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoIXNlbGYuX3N1YnNjcmlidGlvbnNbZXZlbnRdKSBzZWxmLl9zdWJzY3JpYnRpb25zW2V2ZW50XSA9IFtdO1xuICAgICAgICBpZiAoY2FsbGJhY2sgJiYgY2FsbGJhY2sgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgICAgICAgc2VsZi5fc3Vic2NyaWJ0aW9uc1tldmVudF0ucHVzaChjYWxsYmFjayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgdHlwZSBvZiBjYWxsYmFjayEnKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgYWxsb3dzIHRvIHVuc3Vic2NyaWJlIGZyb20gYSBzb21lIHNwZWNpZmljIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gZXZlbnQgaGFuZGxlclxuICAgICAqIEBtZW1iZXJvZiBTdWJzY3JpYmFibGVcbiAgICAgKiBAbWV0aG9kXG4gICAgKi9cbiAgICBzZWxmLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIF8udmFsdWVzKHNlbGYuX3N1YnNjcmlidGlvbnMpLmZvckVhY2goc3Vic2NyaWJlcnMgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBzdWJzY3JpYmVycy5pbmRleE9mKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHN1YnNjcmliZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2Qgd2hpY2ggZmlyZXMgdGhlIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudCAtIGV2ZW50IGlkXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gcGFyYW1ldGVyc1xuICAgICAqIEBtZW1iZXJvZiBTdWJzY3JpYmFibGVcbiAgICAgKiBAbWV0aG9kXG4gICAgKi9cbiAgICBzZWxmLnRyaWdnZXIgPSBmdW5jdGlvbiAoZXZlbnQsIHBhcmFtZXRlcnMpIHtcbiAgICAgICAgaWYgKCEocGFyYW1ldGVycyBpbnN0YW5jZW9mIEFycmF5KSkgcGFyYW1ldGVycyA9IFtwYXJhbWV0ZXJzXTtcbiAgICAgICAgaWYgKHNlbGYuX3N1YnNjcmlidGlvbnMgJiYgc2VsZi5fc3Vic2NyaWJ0aW9uc1tldmVudF0pIHtcbiAgICAgICAgICAgIHNlbGYuX3N1YnNjcmlidGlvbnNbZXZlbnRdLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICAgICAgYy5hcHBseSh0aGlzLCBwYXJhbWV0ZXJzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmV4cG9ydCBkZWZhdWx0IFN1YnNjcmliYWJsZTtcbiIsImltcG9ydCAqIGFzIF8gZnJvbSAnbG9kYXNoJztcclxuaW1wb3J0ICogYXMgZ3JhcGhFbGVtZW50cyBmcm9tICcuLi9qb2ludFZpZXdzL2dyYXBoRWxlbWVudHMvZWxlbWVudHMnO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldEJhc2VFbGVtZW50IChlbGVtZW50KSB7XHJcbiAgICBpZiAoIWVsZW1lbnQpIHJldHVybiBudWxsO1xyXG4gICAgcmV0dXJuIGVsZW1lbnQub3JpZ2luYWxMaW5rIHx8IGVsZW1lbnQub3JpZ2luYWxOb2RlIHx8IGVsZW1lbnQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjaGVja0xnUmF3RGF0YSAoZGF0YSkge1xyXG4gICAgaWYgKCghZGF0YS5saW5rcykgJiYgKCFkYXRhLm5vZGVzKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlcmUgaXMgbm8gZGF0YSB0byBzaG93IScpO1xyXG4gICAgfVxyXG4gICAgaWYgKGRhdGEubm9kZXMpIHtcclxuICAgICAgICBpZiAoIShkYXRhLm5vZGVzIGluc3RhbmNlb2YgQXJyYXkpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignXFwnbm9kZXNcXCcgc2hvdWxkIGJlIGFuIEFycmF5LCBidXQgaXQgaXMgb2JqZWN0IScpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YS5ub2Rlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGVyZSBpcyBubyBkYXRhIHRvIHNob3chJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZXJlIGlzIG5vIG5vZGVzIGluZm9ybWF0aW9uIGluIHRoZSBkYXRhLCBzbyB3ZSBoYXZlIG5vdGhpbmcgdG8gc2hvdyEnKTtcclxuICAgIH1cclxuICAgIGlmIChkYXRhLmxpbmtzICYmICEoZGF0YS5saW5rcyBpbnN0YW5jZW9mIEFycmF5KSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignXFwnbGlua3NcXCcgc2hvdWxkIGJlIGFuIEFycmF5LCBidXQgaXQgaXMgb2JqZWN0IScpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjaGVja0RtUmF3RGF0YSAoZGF0YSkge1xyXG4gICAgaWYgKCghZGF0YS5lZGdlcykgJiYgKCFkYXRhLm5vZGVzKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlcmUgaXMgbm8gZGF0YSB0byBzaG93IScpO1xyXG4gICAgfVxyXG4gICAgaWYgKGRhdGEubm9kZXMpIHtcclxuICAgICAgICBpZiAoIShkYXRhLm5vZGVzIGluc3RhbmNlb2YgQXJyYXkpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignXFwnbm9kZXNcXCcgc2hvdWxkIGJlIGFuIEFycmF5LCBidXQgaXQgaXMgb2JqZWN0IScpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YS5ub2Rlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGVyZSBpcyBubyBkYXRhIHRvIHNob3chJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZXJlIGlzIG5vIG5vZGVzIGluZm9ybWF0aW9uIGluIHRoZSBkYXRhLCBzbyB3ZSBoYXZlIG5vdGhpbmcgdG8gc2hvdyEnKTtcclxuICAgIH1cclxuICAgIGlmIChkYXRhLmxpbmtzICYmICEoZGF0YS5lZGdlcyBpbnN0YW5jZW9mIEFycmF5KSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignXFwnbGlua3NcXCcgc2hvdWxkIGJlIGFuIEFycmF5LCBidXQgaXQgaXMgb2JqZWN0IScpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogVmlldyBmcmFtZSBkZWZpbml0aW9uLFxyXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBWaWV3RnJhbWVEZWZpbml0aW9uXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBpZCAtIFZpZXcgZnJhbWUgaWRlbnRpZnllclxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbGFiZWwgLSBUaXRsZSBvZiB0aGUgdmlldyBmcmFtZSxcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGJvcmRlckNvbG9yIC0gQ29sb3Igb2YgdGhlIGJvcmRlclxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gYmFja2dyb3VuZENvbG9yIC0gQ29sb3Igb2YgdGhlIGJhY2tncm91bmRcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNwYWNlU2hhcmUgLSBIb3cgbXVjaCB0aGUgdmlldyBmcmFtZSB3aWxsIHRha2VcclxuICogQHByb3BlcnR5IHtib29sZWFufSBjb2xsYXBzZWQgLSBEZWZpbmUgZGVmYXVsdCBzdGF0ZVxyXG4gKiBmcm9tIHdob2xlIHNwYWNlIG9mIHRoZSBncmFwaCAoWW91IGNhbiB0YWtlIGl0IGFzIHBlcnNlbnRzIG9yIGZsZXggZ3JvdylcclxuKi9cclxuXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZGVmZW5pdGlvblRvUHVibGljTW9kZWwgKGRlZmVuaXRpb24sIGZ1bGxTY3JlZW5Nb2RlKSB7XHJcbiAgICBjb25zdCBpc0FjdGl2ZSA9IGZ1bGxTY3JlZW5Nb2RlID8gZmFsc2UgOiAhZGVmZW5pdGlvbi5jb2xsYXBzZWQ7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBpZDogZGVmZW5pdGlvbi5pZCxcclxuICAgICAgICBsYWJlbDogZGVmZW5pdGlvbi5sYWJlbCxcclxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGRlZmVuaXRpb24uYmFja2dyb3VuZENvbG9yLFxyXG4gICAgICAgIGJvcmRlckNvbG9yOiBkZWZlbml0aW9uLmJvcmRlckNvbG9yLFxyXG4gICAgICAgIGFjdGl2ZTogaXNBY3RpdmUsXHJcbiAgICAgICAgZXhwYW5kZWQ6ICFkZWZlbml0aW9uLmNvbGxhcHNlZCxcclxuICAgICAgICBwb3NpdGlvbjogdW5kZWZpbmVkLFxyXG4gICAgICAgIHZpZXdQb3J0UG9zaXRpb246IHVuZGVmaW5lZCxcclxuICAgICAgICB2aWV3UG9ydFBvc2l0aW9uQm91bmRzOiB1bmRlZmluZWQsXHJcbiAgICAgICAgdmlld1BvcnRCb3VuZHM6IHVuZGVmaW5lZCxcclxuICAgICAgICBub2RlQm91bmRzOiB1bmRlZmluZWQsXHJcbiAgICAgICAgc2l6ZTogdW5kZWZpbmVkLFxyXG4gICAgICAgIGN1c3RvbWVTaXplZDogZmFsc2UsXHJcbiAgICAgICAgc3BhY2VTaGFyZTogZGVmZW5pdGlvbi5zcGFjZVNoYXJlLFxyXG4gICAgICAgIHVwZGF0ZUJvdW5kczogZmFsc2UsXHJcbiAgICAgICAgaXNPdmVyVmlldzogZmFsc2UsXHJcbiAgICB9O1xyXG59XHJcblxyXG4vKipcclxuICogQHByaXZhdGVcclxuICogQ3JldGVzIGpvaW50IG5vZGVzIGZyb20gbm9kZU1vZGVsc1xyXG4gKiBAcGFyYW0ge1xyXG4gKiAgICAgIEFycmF5IG9mIHtcclxuICAgICAgICAgICAgaWQ6IHN0cmluZyxcclxuICAgICAgICAgICAgbGFiZWw6IHN0cmluZyxcclxuICAgICAgICAgICAgdmlld0ZyYW1lOiBzdHJpbmcsXHJcbiAgICAgICAgICAgIHR5cGVJZDogc3RyaW5nLFxyXG4gICAgICAgICAgICByZXNvdXJjZVR5cGU6IHN0cmluZyxcclxuICAgICAgICAgICAgcmVzb3VyY2U6IHN0cmluZyxcclxuICogICAgICB9XHJcbiAqIH0gTm9kZU1vZGVscyAtIGxpc3Qgb2YgbW9kZWxzXHJcbiAqIEByZXR1cm5zIHtBcnJheSBvZiBOb2RlfSBsaXN0IG9mIGpvaW50IG5vZGVzXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSm9pbnROb2RlcyAobm9kZU1vZGVscywgcGFyYW1ldGVycykge1xyXG4gICAgY29uc3Qgam9pbnROb2RlcyA9IFtdO1xyXG4gICAgbm9kZU1vZGVscy5mb3JFYWNoKG5vZGUgPT4ge1xyXG4gICAgICAgIGpvaW50Tm9kZXMucHVzaChuZXcgZ3JhcGhFbGVtZW50cy5Ob2RlKG5vZGUsIHBhcmFtZXRlcnMpKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGpvaW50Tm9kZXM7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBDcmV0ZXMgam9pbnQgbGlua3MgZnJvbSBtb2RlbHMgKG5hdGl2ZUxpbmtzKVxyXG4gKiBAcGFyYW0ge1xyXG4gKiAgICAgIEFycmF5IG9mIHtcclxuICogICAgICAgICAgaWQ6IHN0cmluZyxcclxuICogICAgICAgICAgdGFyZ2V0OiBzdHJpbmcsXHJcbiAqICAgICAgICAgIHNvdXJjZTogc3RyaW5nLFxyXG4gKiAgICAgIH1cclxuICogfSBuYXRpdmVMaW5rcyAtIGxpc3Qgb2YgbW9kZWxzXHJcbiAqIEByZXR1cm5zIHtMaW5rW119IGxpc3Qgb2Ygam9pbnQgbGlua3NcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVKb2ludExpbmtzIChsaW5rTW9kZWxzLCBqb2ludE5vZGVzLCBwYXJhbWV0ZXJzKSB7XHJcbiAgICBjb25zdCBqb2ludExpbmtzID0gW107XHJcbiAgICBjb25zdCBpZE1hcCA9IHt9O1xyXG4gICAgam9pbnROb2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xyXG4gICAgICAgIGlkTWFwW25vZGUubW9kZWwuaWRdID0gbm9kZS5pZDtcclxuICAgIH0pO1xyXG4gICAgbGlua01vZGVscy5mb3JFYWNoKGxpbmsgPT4ge1xyXG4gICAgICAgIHZhciBsaW5rTW9kZWwgPSBfLmNsb25lRGVlcChsaW5rKTtcclxuICAgICAgICBsaW5rTW9kZWwuc291cmNlVHlwZSA9IGxpbmsuc291cmNlO1xyXG4gICAgICAgIGxpbmtNb2RlbC50YXJnZXRUeXBlID0gbGluay50YXJnZXQ7XHJcbiAgICAgICAgbGlua01vZGVsLnNvdXJjZSA9IGlkTWFwW2xpbmsuc291cmNlXTtcclxuICAgICAgICBsaW5rTW9kZWwudGFyZ2V0ID0gaWRNYXBbbGluay50YXJnZXRdO1xyXG4gICAgICAgIGxpbmtNb2RlbC5yb3V0aW5nID0gcGFyYW1ldGVycy5saW5rUm91dGluZztcclxuICAgICAgICBjb25zdCBuZXdMaW5rID0gbmV3IGdyYXBoRWxlbWVudHMuTGluayhsaW5rTW9kZWwsIHBhcmFtZXRlcnMpO1xyXG4gICAgICAgIGpvaW50TGlua3MucHVzaChuZXdMaW5rKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGpvaW50TGlua3M7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBkYXRlMlN0cmluZyAoZGF0ZSkge1xyXG4gICAgcmV0dXJuIHBhZFN0cihkYXRlLmdldEZ1bGxZZWFyKCkpICsgJ18nICtcclxuICAgICAgICAgICAgcGFkU3RyKDEgKyBkYXRlLmdldE1vbnRoKCkpICsgJ18nICtcclxuICAgICAgICAgICAgcGFkU3RyKGRhdGUuZ2V0RGF0ZSgpKSArICdfJyArXHJcbiAgICAgICAgICAgIHBhZFN0cihkYXRlLmdldEhvdXJzKCkpICsgJ18nICtcclxuICAgICAgICAgICAgcGFkU3RyKGRhdGUuZ2V0TWludXRlcygpKSArICdfJyArXHJcbiAgICAgICAgICAgIHBhZFN0cihkYXRlLmdldFNlY29uZHMoKSk7XHJcblxyXG4gICAgZnVuY3Rpb24gcGFkU3RyIChpKSB7XHJcbiAgICAgICAgcmV0dXJuIChpIDwgMTApID8gJzAnICsgaSA6ICcnICsgaTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHBuZzJCbG9iIChkYXRhVVJJKSB7XHJcbiAgICAvLyBjb252ZXJ0IGJhc2U2NCB0byByYXcgYmluYXJ5IGRhdGEgaGVsZCBpbiBhIHN0cmluZ1xyXG4gICAgLy8gZG9lc24ndCBoYW5kbGUgVVJMRW5jb2RlZCBEYXRhVVJJcyAtIHNlZSBTTyBhbnN3ZXIgIzY4NTAyNzYgZm9yIGNvZGUgdGhhdCBkb2VzIHRoaXNcclxuICAgIHZhciBieXRlU3RyaW5nID0gYXRvYihkYXRhVVJJLnNwbGl0KCcsJylbMV0pO1xyXG5cclxuICAgIC8vIHdyaXRlIHRoZSBieXRlcyBvZiB0aGUgc3RyaW5nIHRvIGFuIEFycmF5QnVmZmVyXHJcbiAgICB2YXIgYWIgPSBuZXcgQXJyYXlCdWZmZXIoYnl0ZVN0cmluZy5sZW5ndGgpO1xyXG4gICAgdmFyIGlhID0gbmV3IFVpbnQ4QXJyYXkoYWIpO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlU3RyaW5nLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWFbaV0gPSBieXRlU3RyaW5nLmNoYXJDb2RlQXQoaSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gd3JpdGUgdGhlIEFycmF5QnVmZmVyIHRvIGEgYmxvYiwgYW5kIHlvdSdyZSBkb25lXHJcbiAgICB2YXIgYmIgPSBuZXcgQmxvYihbYWJdLCB7IHR5cGU6ICdpbWFnZS9wbmcnIH0pO1xyXG4gICAgcmV0dXJuIGJiO1xyXG59IiwiaW1wb3J0IHtcclxuICAgIGFycmF5VG9NYXAsXHJcbiAgICBtYXBUb0FycmF5LFxyXG4gICAgZ2V0R2xvYmFsTm9kZVBvc2l0aW9uLFxyXG4gICAgc2NhbGVkVG9HbG9iYWxTaXplLFxyXG5cclxufSBmcm9tICcuL3V0aWxzJztcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0TmF0aXZlVG9MYXlvdXRNb2RlbHMgKG5vZGVNb2RlbHMsIGxpbmtNb2RlbHMsIHBhcmFtZXRlcnMpIHtcclxuICAgIGNvbnN0IHNpemUgPSBwYXJhbWV0ZXJzLmVsZW1lbnRTaXplO1xyXG4gICAgY29uc3Qgbm9kZXMgPSBub2RlTW9kZWxzVG9MYXlvdXROb2Rlcyhub2RlTW9kZWxzLCBwYXJhbWV0ZXJzLmVsZW1lbnRTaXplKTtcclxuICAgIGNvbnN0IGxpbmtzID0gbGlua01vZGVsc1RvTGF5b3V0TGlua3MobGlua01vZGVscywgbm9kZXMpO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbm9kZXM6IG5vZGVzLFxyXG4gICAgICAgIGxpbmtzOiBsaW5rcyxcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gbm9kZU1vZGVsc1RvTGF5b3V0Tm9kZXMgKG5vZGVNb2RlbHMpIHtcclxuICAgICAgICByZXR1cm4gbm9kZU1vZGVscy5tYXAobm9kZU1vZGVsID0+IG5vZGVNb2RlbFRvTGF5b3V0Tm9kZShub2RlTW9kZWwpKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgZnVuY3Rpb24gbGlua01vZGVsc1RvTGF5b3V0TGlua3MgKGxpbmtNb2RlbHMsIG5vZGVzKSB7XHJcbiAgICAgICAgY29uc3Qgbm9kZU1hcCA9IGFycmF5VG9NYXAobm9kZXMpO1xyXG4gICAgICAgIGNvbnN0IGxpbmtzID0gbGlua01vZGVscy5tYXAobGluayA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBsaW5rTW9kZWxUb0xheW91dExpbmsobGluaywgbm9kZU1hcCk7XHJcbiAgICAgICAgfSkuZmlsdGVyKGxpbmsgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gbGluay5zb3VyY2UgJiYgbGluay50YXJnZXQgJiYgbGluay5zb3VyY2UgIT09IGxpbmsudGFyZ2V0O1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGxpbmtzLmZvckVhY2gobGluayA9PiB7XHJcbiAgICAgICAgICAgIGxpbmsuc291cmNlLnRhcmdldExpbmtzLnB1c2gobGluayk7XHJcbiAgICAgICAgICAgIGxpbmsudGFyZ2V0LnNvdXJjZUxpbmtzLnB1c2gobGluayk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGxpbmtzO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG5vZGVNb2RlbFRvTGF5b3V0Tm9kZSAobm9kZU1vZGVsKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgaWQ6IG5vZGVNb2RlbC5pZCxcclxuICAgICAgICAgICAgeDogbm9kZU1vZGVsLnBvc2l0aW9uLnggfHwgTWF0aC5yYW5kb20oKSxcclxuICAgICAgICAgICAgeTogbm9kZU1vZGVsLnBvc2l0aW9uLnkgfHwgTWF0aC5yYW5kb20oKSxcclxuICAgICAgICAgICAgb3JpZ2luYWxOb2RlOiBub2RlTW9kZWwsXHJcbiAgICAgICAgICAgIHdpZHRoOiBzaXplLndpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IHNpemUuaGVpZ2h0LFxyXG4gICAgICAgICAgICB0YXJnZXRMaW5rczogW10sXHJcbiAgICAgICAgICAgIHNvdXJjZUxpbmtzOiBbXSxcclxuICAgICAgICAgICAgdmlld0ZyYW1lOiBub2RlTW9kZWwudmlld0ZyYW1lLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbGlua01vZGVsVG9MYXlvdXRMaW5rIChsaW5rTW9kZWwsIG5vZGVNYXApIHtcclxuICAgICAgICBjb25zdCBzb3VyY2UgPSBub2RlTWFwW2xpbmtNb2RlbC5zb3VyY2VdO1xyXG4gICAgICAgIGNvbnN0IHRhcmdldCA9IG5vZGVNYXBbbGlua01vZGVsLnRhcmdldF07XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgb3JpZ2luYWxMaW5rOiBsaW5rTW9kZWwsXHJcbiAgICAgICAgICAgIHNvdXJjZTogc291cmNlLFxyXG4gICAgICAgICAgICB0YXJnZXQ6IHRhcmdldCxcclxuICAgICAgICAgICAgdmFsdWU6IDEsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRMR0VsZW1lbnRzVG9MYXlvdXRNb2RlbHMgKGxnTm9kZXMsIGxnTGlua3MsIG9wdGlvbnMpIHtcclxuICAgIGNvbnN0IHNjYWxlID0gb3B0aW9ucy5zY2FsZTtcclxuICAgIGNvbnN0IG5vZGVzID0gbGdOb2Rlcy5tYXAobm9kZSA9PiBub2RlVG9MYXlvdXROb2RlKG5vZGUpKTtcclxuICAgIGNvbnN0IGxpbmtzID0gbGlua3NUb0xheW91dExpbmtzKGxnTGlua3MsIG5vZGVzKTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG5vZGVzOiBub2RlcyxcclxuICAgICAgICBsaW5rczogbGlua3MsXHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIGxpbmtzVG9MYXlvdXRMaW5rcyAobGluaywgbm9kZXMpIHtcclxuICAgICAgICBjb25zdCBub2RlTWFwID0gYXJyYXlUb01hcChub2Rlcyk7XHJcbiAgICAgICAgY29uc3QgbGlua3MgPSBsaW5rLm1hcChsaW5rID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGxpbmtUb0xheW91dExpbmsobGluaywgbm9kZU1hcCk7XHJcbiAgICAgICAgfSkuZmlsdGVyKGxpbmsgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gbGluay5zb3VyY2UgJiYgbGluay50YXJnZXQgJiYgbGluay5zb3VyY2UgIT09IGxpbmsudGFyZ2V0O1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGxpbmtzLmZvckVhY2gobGluayA9PiB7XHJcbiAgICAgICAgICAgIGxpbmsuc291cmNlLnRhcmdldExpbmtzLnB1c2gobGluayk7XHJcbiAgICAgICAgICAgIGxpbmsudGFyZ2V0LnNvdXJjZUxpbmtzLnB1c2gobGluayk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGxpbmtzO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG5vZGVUb0xheW91dE5vZGUgKG5vZGUpIHtcclxuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IGdldEdsb2JhbE5vZGVQb3NpdGlvbihub2RlKTtcclxuICAgICAgICBjb25zdCBzaXplID0gc2NhbGVkVG9HbG9iYWxTaXplKG5vZGUuc2l6ZSwgc2NhbGUpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGlkOiBub2RlLmlkLFxyXG4gICAgICAgICAgICB4OiBwb3NpdGlvbi54LFxyXG4gICAgICAgICAgICB5OiBwb3NpdGlvbi55LFxyXG4gICAgICAgICAgICBvcmlnaW5hbE5vZGU6IG5vZGUsXHJcbiAgICAgICAgICAgIHdpZHRoOiBzaXplLndpZHRoLFxyXG4gICAgICAgICAgICBoZWlndGg6IHNpemUuaGVpZ3RoLFxyXG4gICAgICAgICAgICB0YXJnZXRMaW5rczogW10sXHJcbiAgICAgICAgICAgIHNvdXJjZUxpbmtzOiBbXSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGxpbmtUb0xheW91dExpbmsgKGxpbmssIG5vZGVNYXApIHtcclxuICAgICAgICBjb25zdCBzb3VyY2UgPSBub2RlTWFwW2xpbmsubW9kZWwuc291cmNlXTtcclxuICAgICAgICBjb25zdCB0YXJnZXQgPSBub2RlTWFwW2xpbmsubW9kZWwudGFyZ2V0XTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBvcmlnaW5hbExpbms6IGxpbmssXHJcbiAgICAgICAgICAgIHNvdXJjZTogc291cmNlLFxyXG4gICAgICAgICAgICB0YXJnZXQ6IHRhcmdldCxcclxuICAgICAgICAgICAgdmFsdWU6IDEsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG5cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0RE1FbGVtZW50c1RvTGF5b3V0TW9kZWxzIChkbU5vZGVzLCBkbUxpbmtzKSB7XHJcbiAgICBjb25zdCBub2RlTWFwID0gYXJyYXlUb01hcChkbU5vZGVzLm1hcChub2RlID0+IG5vZGVUb0xheW91dE5vZGUobm9kZSkpKTtcclxuICAgIGNvbnN0IGxpbmtzID0gbGlua3NUb0xheW91dExpbmtzKGRtTGlua3MsIG5vZGVNYXApO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbm9kZXM6IG1hcFRvQXJyYXkobm9kZU1hcCksXHJcbiAgICAgICAgbGlua3M6IGxpbmtzLFxyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBsaW5rc1RvTGF5b3V0TGlua3MgKGxpbmssIG5vZGVNYXApIHtcclxuICAgICAgICBjb25zdCBsaW5rcyA9IGxpbmsubWFwKGxpbmsgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gbGlua1RvTGF5b3V0TGluayhsaW5rLCBub2RlTWFwKTtcclxuICAgICAgICB9KS5maWx0ZXIobGluayA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBsaW5rLnNvdXJjZSAmJiBsaW5rLnRhcmdldCAmJiBsaW5rLnNvdXJjZSAhPT0gbGluay50YXJnZXQ7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgbGlua3MuZm9yRWFjaChsaW5rID0+IHtcclxuICAgICAgICAgICAgbGluay5zb3VyY2UudGFyZ2V0TGlua3MucHVzaChsaW5rKTtcclxuICAgICAgICAgICAgbGluay50YXJnZXQuc291cmNlTGlua3MucHVzaChsaW5rKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gbGlua3M7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbm9kZVRvTGF5b3V0Tm9kZSAobm9kZSkge1xyXG4gICAgICAgIGNvbnN0IHBvcnRQb3NpdGlvbiA9IG5vZGUuZ2V0UG9ydFBvc2l0aW9uKCk7XHJcbiAgICAgICAgY29uc3QgcG9ydFByaW1pdGl2ZSA9IG5vZGUuZ2V0UG9ydCgpLnByaW1pdGl2ZTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBpZDogcG9ydFByaW1pdGl2ZS5pZCxcclxuICAgICAgICAgICAgeDogMCxcclxuICAgICAgICAgICAgeTogMCxcclxuICAgICAgICAgICAgb3JpZ2luYWxOb2RlOiBwb3J0UHJpbWl0aXZlLFxyXG4gICAgICAgICAgICB0YXJnZXRMaW5rczogW10sXHJcbiAgICAgICAgICAgIHNvdXJjZUxpbmtzOiBbXSxcclxuICAgICAgICAgICAgb3JkZXI6IHBvcnRQb3NpdGlvbi55LFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIGxpbmtUb0xheW91dExpbmsgKGxpbmssIG5vZGVNYXApIHtcclxuICAgICAgICBjb25zdCBzb3VyY2VQcmltaXRpdmUgPSBsaW5rLnNvdXJjZS5nZXRQb3J0KCkucHJpbWl0aXZlO1xyXG4gICAgICAgIGNvbnN0IHRhcmdldFByaW1pdGl2ZSA9IGxpbmsudGFyZ2V0LmdldFBvcnQoKS5wcmltaXRpdmU7XHJcblxyXG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IG5vZGVNYXBbc291cmNlUHJpbWl0aXZlLmlkXTtcclxuICAgICAgICBjb25zdCB0YXJnZXQgPSBub2RlTWFwW3RhcmdldFByaW1pdGl2ZS5pZF07XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGNhY2hlSWQ6IGNhY2hMaW5rRnVuY3Rpb24gKHNvdXJjZVByaW1pdGl2ZSwgdGFyZ2V0UHJpbWl0aXZlKSxcclxuICAgICAgICAgICAgb3JpZ2luYWxMaW5rOiBsaW5rLFxyXG4gICAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcclxuICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXHJcbiAgICAgICAgICAgIHZhbHVlOiAxLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY2FjaExpbmtGdW5jdGlvbiAoc291cmNlLCB0YXJnZXQpIHtcclxuICAgICAgICByZXR1cm4gc291cmNlLmlkICsgJ34jdHFETUxpbmsjficgKyB0YXJnZXQuaWQ7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0Sm9pbnRFbGVtZW50c1RvTGF5b3V0TW9kZWxzIChqTm9kZXMsIGpMaW5rcykge1xyXG4gICAgY29uc3Qgbm9kZU1hcCA9IGFycmF5VG9NYXAoak5vZGVzLm1hcChub2RlID0+IG5vZGVUb0xheW91dE5vZGUobm9kZSkpKTtcclxuICAgIGNvbnN0IGxpbmtzID0gbGlua3NUb0xheW91dExpbmtzKGpMaW5rcywgbm9kZU1hcCk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBub2RlczogbWFwVG9BcnJheShub2RlTWFwKSxcclxuICAgICAgICBsaW5rczogbGlua3MsXHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIGxpbmtzVG9MYXlvdXRMaW5rcyAobGluaywgbm9kZU1hcCkge1xyXG4gICAgICAgIGNvbnN0IGxpbmtzID0gbGluay5tYXAobGluayA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBsaW5rVG9MYXlvdXRMaW5rKGxpbmssIG5vZGVNYXApO1xyXG4gICAgICAgIH0pLmZpbHRlcihsaW5rID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGxpbmsuc291cmNlICYmIGxpbmsudGFyZ2V0ICYmIGxpbmsuc291cmNlICE9PSBsaW5rLnRhcmdldDtcclxuICAgICAgICB9KTtcclxuICAgICAgICBsaW5rcy5mb3JFYWNoKGxpbmsgPT4ge1xyXG4gICAgICAgICAgICBsaW5rLnNvdXJjZS50YXJnZXRMaW5rcy5wdXNoKGxpbmspO1xyXG4gICAgICAgICAgICBsaW5rLnRhcmdldC5zb3VyY2VMaW5rcy5wdXNoKGxpbmspO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBsaW5rcztcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBub2RlVG9MYXlvdXROb2RlIChub2RlKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgaWQ6IG5vZGUuaWQsXHJcbiAgICAgICAgICAgIG9yaWdpbmFsTm9kZTogbm9kZSxcclxuICAgICAgICAgICAgeDogMCxcclxuICAgICAgICAgICAgeTogMCxcclxuICAgICAgICAgICAgdGFyZ2V0TGlua3M6IFtdLFxyXG4gICAgICAgICAgICBzb3VyY2VMaW5rczogW10sXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgZnVuY3Rpb24gbGlua1RvTGF5b3V0TGluayAobGluaywgbm9kZU1hcCkge1xyXG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IG5vZGVNYXBbbGluay5nZXQoJ3NvdXJjZScpLmlkXTtcclxuICAgICAgICBjb25zdCB0YXJnZXQgPSBub2RlTWFwW2xpbmsuZ2V0KCd0YXJnZXQnKS5pZF07XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIG9yaWdpbmFsTGluazogbGluayxcclxuICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsXHJcbiAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0LFxyXG4gICAgICAgICAgICB2YWx1ZTogMSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gc3VtIChhcnJheSwgZikge1xyXG4gICAgbGV0IHMgPSAwLFxyXG4gICAgICAgIG4gPSBhcnJheS5sZW5ndGgsXHJcbiAgICAgICAgYSxcclxuICAgICAgICBpID0gLTE7XHJcblxyXG4gICAgaWYgKGYgPT0gbnVsbCkge1xyXG4gICAgICAgIHdoaWxlICgrK2kgPCBuKSB7XHJcbiAgICAgICAgICAgIGEgPSArYXJyYXlbaV07XHJcbiAgICAgICAgICAgIGlmIChhKSBzICs9IGE7XHJcbiAgICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB3aGlsZSAoKytpIDwgbikge1xyXG4gICAgICAgICAgICBhID0gK2YoYXJyYXlbaV0sIGksIGFycmF5KTtcclxuICAgICAgICAgICAgaWYgKGEpIHMgKz0gYTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHM7XHJcbn1cclxuXHJcbmxldCBwcmVmaXggPSAnJCc7XHJcbmZ1bmN0aW9uIE1hcCAoKSB7fVxyXG5NYXAucHJvdG90eXBlID0gbWFwJDEucHJvdG90eXBlID0ge1xyXG4gICAgY29uc3RydWN0b3I6IE1hcCxcclxuICAgIGhhczogZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgIHJldHVybiAocHJlZml4ICsga2V5KSBpbiB0aGlzO1xyXG4gICAgfSxcclxuICAgIGdldDogZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzW3ByZWZpeCArIGtleV07XHJcbiAgICB9LFxyXG4gICAgc2V0OiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgIHRoaXNbcHJlZml4ICsga2V5XSA9IHZhbHVlO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuICAgIHJlbW92ZTogZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgIGxldCBwcm9wZXJ0eSA9IHByZWZpeCArIGtleTtcclxuICAgICAgICByZXR1cm4gcHJvcGVydHkgaW4gdGhpcyAmJiBkZWxldGUgdGhpc1twcm9wZXJ0eV07XHJcbiAgICB9LFxyXG4gICAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmb3IgKGxldCBwcm9wZXJ0eSBpbiB0aGlzKSBpZiAocHJvcGVydHlbMF0gPT09IHByZWZpeCkgZGVsZXRlIHRoaXNbcHJvcGVydHldO1xyXG4gICAgfSxcclxuICAgIGtleXM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBsZXQga2V5cyA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IHByb3BlcnR5IGluIHRoaXMpIGlmIChwcm9wZXJ0eVswXSA9PT0gcHJlZml4KSBrZXlzLnB1c2gocHJvcGVydHkuc2xpY2UoMSkpO1xyXG4gICAgICAgIHJldHVybiBrZXlzO1xyXG4gICAgfSxcclxuICAgIHZhbHVlczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGxldCB2YWx1ZXMgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBwcm9wZXJ0eSBpbiB0aGlzKSBpZiAocHJvcGVydHlbMF0gPT09IHByZWZpeCkgdmFsdWVzLnB1c2godGhpc1twcm9wZXJ0eV0pO1xyXG4gICAgICAgIHJldHVybiB2YWx1ZXM7XHJcbiAgICB9LFxyXG4gICAgZW50cmllczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGxldCBlbnRyaWVzID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgcHJvcGVydHkgaW4gdGhpcykgaWYgKHByb3BlcnR5WzBdID09PSBwcmVmaXgpIGVudHJpZXMucHVzaCh7a2V5OiBwcm9wZXJ0eS5zbGljZSgxKSwgdmFsdWU6IHRoaXNbcHJvcGVydHldfSk7XHJcbiAgICAgICAgcmV0dXJuIGVudHJpZXM7XHJcbiAgICB9LFxyXG4gICAgc2l6ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGxldCBzaXplID0gMDtcclxuICAgICAgICBmb3IgKGxldCBwcm9wZXJ0eSBpbiB0aGlzKSBpZiAocHJvcGVydHlbMF0gPT09IHByZWZpeCkgKytzaXplO1xyXG4gICAgICAgIHJldHVybiBzaXplO1xyXG4gICAgfSxcclxuICAgIGVtcHR5OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZm9yIChsZXQgcHJvcGVydHkgaW4gdGhpcykgaWYgKHByb3BlcnR5WzBdID09PSBwcmVmaXgpIHJldHVybiBmYWxzZTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0sXHJcbiAgICBlYWNoOiBmdW5jdGlvbiAoZikge1xyXG4gICAgICAgIGZvciAobGV0IHByb3BlcnR5IGluIHRoaXMpIGlmIChwcm9wZXJ0eVswXSA9PT0gcHJlZml4KSBmKHRoaXNbcHJvcGVydHldLCBwcm9wZXJ0eS5zbGljZSgxKSwgdGhpcyk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gbWFwJDEgKG9iamVjdCwgZikge1xyXG4gICAgbGV0IG1hcCA9IG5ldyBNYXA7XHJcblxyXG4gICAgLy8gQ29weSBjb25zdHJ1Y3Rvci5cclxuICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBNYXApIG9iamVjdC5lYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7IG1hcC5zZXQoa2V5LCB2YWx1ZSk7IH0pO1xyXG5cclxuICAgIC8vIEluZGV4IGFycmF5IGJ5IG51bWVyaWMgaW5kZXggb3Igc3BlY2lmaWVkIGtleSBmdW5jdGlvbi5cclxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xyXG4gICAgICAgIGxldCBpID0gLTEsXHJcbiAgICAgICAgICAgIG4gPSBvYmplY3QubGVuZ3RoLFxyXG4gICAgICAgICAgICBvO1xyXG5cclxuICAgICAgICBpZiAoZiA9PSBudWxsKSB3aGlsZSAoKytpIDwgbikgbWFwLnNldChpLCBvYmplY3RbaV0pO1xyXG4gICAgICAgIGVsc2Ugd2hpbGUgKCsraSA8IG4pIG1hcC5zZXQoZihvID0gb2JqZWN0W2ldLCBpLCBvYmplY3QpLCBvKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDb252ZXJ0IG9iamVjdCB0byBtYXAuXHJcbiAgICBlbHNlIGlmIChvYmplY3QpIGZvciAobGV0IGtleSBpbiBvYmplY3QpIG1hcC5zZXQoa2V5LCBvYmplY3Rba2V5XSk7XHJcblxyXG4gICAgcmV0dXJuIG1hcDtcclxufVxyXG5cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBuZXN0ICgpIHtcclxuICAgIGxldCBrZXlzID0gW10sXHJcbiAgICAgICAgc29ydEtleXMgPSBbXSxcclxuICAgICAgICBzb3J0VmFsdWVzLFxyXG4gICAgICAgIHJvbGx1cCxcclxuICAgICAgICBuZXN0O1xyXG5cclxuICAgIGZ1bmN0aW9uIGFwcGx5IChhcnJheSwgZGVwdGgsIGNyZWF0ZVJlc3VsdCwgc2V0UmVzdWx0KSB7XHJcbiAgICAgICAgaWYgKGRlcHRoID49IGtleXMubGVuZ3RoKSByZXR1cm4gcm9sbHVwICE9IG51bGxcclxuICAgICAgICAgICAgPyByb2xsdXAoYXJyYXkpIDogKHNvcnRWYWx1ZXMgIT0gbnVsbFxyXG4gICAgICAgICAgICA/IGFycmF5LnNvcnQoc29ydFZhbHVlcylcclxuICAgICAgICAgICAgOiBhcnJheSk7XHJcblxyXG4gICAgICAgIGxldCBpID0gLTEsXHJcbiAgICAgICAgICAgIG4gPSBhcnJheS5sZW5ndGgsXHJcbiAgICAgICAgICAgIGtleSA9IGtleXNbZGVwdGgrK10sXHJcbiAgICAgICAgICAgIGtleVZhbHVlLFxyXG4gICAgICAgICAgICB2YWx1ZSxcclxuICAgICAgICAgICAgdmFsdWVzQnlLZXkgPSBtYXAkMSgpLFxyXG4gICAgICAgICAgICB2YWx1ZXMsXHJcbiAgICAgICAgICAgIHJlc3VsdCA9IGNyZWF0ZVJlc3VsdCgpO1xyXG5cclxuICAgICAgICB3aGlsZSAoKytpIDwgbikge1xyXG4gICAgICAgICAgICB2YWx1ZXMgPSB2YWx1ZXNCeUtleS5nZXQoa2V5VmFsdWUgPSBrZXkodmFsdWUgPSBhcnJheVtpXSkgKyAnJyk7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZXMpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlc0J5S2V5LnNldChrZXlWYWx1ZSwgW3ZhbHVlXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhbHVlc0J5S2V5LmVhY2goZnVuY3Rpb24gKHZhbHVlcywga2V5KSB7XHJcbiAgICAgICAgICAgIHNldFJlc3VsdChyZXN1bHQsIGtleSwgYXBwbHkodmFsdWVzLCBkZXB0aCwgY3JlYXRlUmVzdWx0LCBzZXRSZXN1bHQpKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBlbnRyaWVzIChtYXAsIGRlcHRoKSB7XHJcbiAgICAgICAgaWYgKCsrZGVwdGggPiBrZXlzLmxlbmd0aCkgcmV0dXJuIG1hcDtcclxuICAgICAgICBsZXQgYXJyYXksIHNvcnRLZXkgPSBzb3J0S2V5c1tkZXB0aCAtIDFdO1xyXG4gICAgICAgIGlmIChyb2xsdXAgIT0gbnVsbCAmJiBkZXB0aCA+PSBrZXlzLmxlbmd0aCkgYXJyYXkgPSBtYXAuZW50cmllcygpO1xyXG4gICAgICAgIGVsc2UgYXJyYXkgPSBbXSwgbWFwLmVhY2goZnVuY3Rpb24gKHYsIGspIHsgYXJyYXkucHVzaCh7a2V5OiBrLCB2YWx1ZXM6IGVudHJpZXModiwgZGVwdGgpfSk7IH0pO1xyXG4gICAgICAgIHJldHVybiBzb3J0S2V5ICE9IG51bGwgPyBhcnJheS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBzb3J0S2V5KGEua2V5LCBiLmtleSk7IH0pIDogYXJyYXk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG5lc3QgPSB7XHJcbiAgICAgICAgb2JqZWN0OiBmdW5jdGlvbiAoYXJyYXkpIHsgcmV0dXJuIGFwcGx5KGFycmF5LCAwLCBjcmVhdGVPYmplY3QsIHNldE9iamVjdCk7IH0sXHJcbiAgICAgICAgbWFwOiBmdW5jdGlvbiAoYXJyYXkpIHsgcmV0dXJuIGFwcGx5KGFycmF5LCAwLCBjcmVhdGVNYXAsIHNldE1hcCk7IH0sXHJcbiAgICAgICAgZW50cmllczogZnVuY3Rpb24gKGFycmF5KSB7IHJldHVybiBlbnRyaWVzKGFwcGx5KGFycmF5LCAwLCBjcmVhdGVNYXAsIHNldE1hcCksIDApOyB9LFxyXG4gICAgICAgIGtleTogZnVuY3Rpb24gKGQpIHsga2V5cy5wdXNoKGQpOyByZXR1cm4gbmVzdDsgfSxcclxuICAgICAgICBzb3J0S2V5czogZnVuY3Rpb24gKG9yZGVyKSB7IHNvcnRLZXlzW2tleXMubGVuZ3RoIC0gMV0gPSBvcmRlcjsgcmV0dXJuIG5lc3Q7IH0sXHJcbiAgICAgICAgc29ydFZhbHVlczogZnVuY3Rpb24gKG9yZGVyKSB7IHNvcnRWYWx1ZXMgPSBvcmRlcjsgcmV0dXJuIG5lc3Q7IH0sXHJcbiAgICAgICAgcm9sbHVwOiBmdW5jdGlvbiAoZikgeyByb2xsdXAgPSBmOyByZXR1cm4gbmVzdDsgfVxyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVPYmplY3QgKCkge1xyXG4gICAgICAgIHJldHVybiB7fTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzZXRPYmplY3QgKG9iamVjdCwga2V5LCB2YWx1ZSkge1xyXG4gICAgICAgIG9iamVjdFtrZXldID0gdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY3JlYXRlTWFwICgpIHtcclxuICAgICAgICByZXR1cm4gbWFwJDEoKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzZXRNYXAgKG1hcCwga2V5LCB2YWx1ZSkge1xyXG4gICAgICAgIG1hcC5zZXQoa2V5LCB2YWx1ZSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiByZWludGVycG9sYXRlIChhLCBiKSB7XHJcbiAgICByZXR1cm4gYSA9ICthLCBiIC09IGEsIGZ1bmN0aW9uICh0KSB7XHJcbiAgICAgICAgcmV0dXJuIGEgKyBiICogdDtcclxuICAgIH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBtaW4gKGFycmF5LCBmKSB7XHJcbiAgICBsZXQgaSA9IC0xLFxyXG4gICAgICAgIG4gPSBhcnJheS5sZW5ndGgsXHJcbiAgICAgICAgYSxcclxuICAgICAgICBiO1xyXG5cclxuICAgIGlmIChmID09IG51bGwpIHtcclxuICAgICAgICB3aGlsZSAoKytpIDwgbikgaWYgKChiID0gYXJyYXlbaV0pICE9IG51bGwgJiYgYiA+PSBiKSB7IGEgPSBiOyBicmVhazsgfVxyXG4gICAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoKGIgPSBhcnJheVtpXSkgIT0gbnVsbCAmJiBhID4gYikgYSA9IGI7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoKGIgPSBmKGFycmF5W2ldLCBpLCBhcnJheSkpICE9IG51bGwgJiYgYiA+PSBiKSB7IGEgPSBiOyBicmVhazsgfVxyXG4gICAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoKGIgPSBmKGFycmF5W2ldLCBpLCBhcnJheSkpICE9IG51bGwgJiYgYSA+IGIpIGEgPSBiO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBhO1xyXG59IiwiaW1wb3J0ICogYXMgam9pbnQgZnJvbSAncmFwcGlkJztcclxuaW1wb3J0ICogYXMgXyBmcm9tICdsb2Rhc2gnO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNhY2hlSWRGb3JWaWV3RnJhbWVVSSAodmlld0ZyYW1lKSB7XHJcbiAgICByZXR1cm4gJ3RxLWxnLXZpZXctZnJhbWUtdWktJyArIHZpZXdGcmFtZS5pZDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFZpZXdGcmFtZUlkRm9yTm9kZSAobm9kZSkge1xyXG4gICAgcmV0dXJuIG5vZGUudmlld0ZyYW1lT3duZXJJZCB8fCBub2RlLm1vZGVsLnZpZXdGcmFtZTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrUGFnaW5hdGlvbiAodmlld0ZyYW1lKSB7XHJcbiAgICBjb25zdCB2aWV3UG9ydFBvc2l0aW9uQm91bmRzID0gdmlld0ZyYW1lLnZpZXdQb3J0UG9zaXRpb25Cb3VuZHM7XHJcbiAgICBjb25zdCB2aWV3UG9ydFBvc2l0aW9uID0gdmlld0ZyYW1lLnZpZXdQb3J0UG9zaXRpb247XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBjYW5Nb3ZlVXA6IHZpZXdQb3J0UG9zaXRpb25Cb3VuZHMgJiYgdmlld1BvcnRQb3NpdGlvbi55ID4gdmlld1BvcnRQb3NpdGlvbkJvdW5kcy5taW5ZLFxyXG4gICAgICAgIGNhbk1vdmVEb3duOiB2aWV3UG9ydFBvc2l0aW9uQm91bmRzICYmIHZpZXdQb3J0UG9zaXRpb24ueSA8IHZpZXdQb3J0UG9zaXRpb25Cb3VuZHMubWF4WSxcclxuICAgICAgICBjYW5Nb3ZlTGVmdDogdmlld1BvcnRQb3NpdGlvbkJvdW5kcyAmJiB2aWV3UG9ydFBvc2l0aW9uLnggPiB2aWV3UG9ydFBvc2l0aW9uQm91bmRzLm1pblgsXHJcbiAgICAgICAgY2FuTW92ZVJpZ2h0OiB2aWV3UG9ydFBvc2l0aW9uQm91bmRzICYmIHZpZXdQb3J0UG9zaXRpb24ueCA8IHZpZXdQb3J0UG9zaXRpb25Cb3VuZHMubWF4WCxcclxuICAgIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBSZXR1cm5zIHBvaW50IG9mIGNyb3NzaW5nIG9mIHR3byBsaW5lc1xyXG4gKiBAcGFyYW0ge1BvaW50fSBwMSAtIHRoZSBmaXJzdCBwb2ludCBvZiBsaW5lLTFcclxuICogQHBhcmFtIHtQb2ludH0gcDIgLSB0aGUgc2Vjb25kIHBvaW50IG9mIGxpbmUtMVxyXG4gKiBAcGFyYW0ge1BvaW50fSBwMyAtIHRoZSBmaXJzdCBwb2ludCBvZiBsaW5lLTJcclxuICogQHBhcmFtIHtQb2ludH0gcDQgLSB0aGUgc2Vjb25kIHBvaW50IG9mIGxpbmUtMlxyXG4gKiBAcmV0dXJucyB7UG9pbnR9XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q3Jvc1BvaW50IChwMSwgcDIsIHAzLCBwNCkge1xyXG4gICAgbGV0IHgxID0gcDEueDtcclxuICAgIGxldCB5MSA9IHAxLnk7XHJcblxyXG4gICAgbGV0IHgyID0gcDIueDtcclxuICAgIGxldCB5MiA9IHAyLnk7XHJcbiAgICBcclxuICAgIGxldCB4MyA9IHAzLng7XHJcbiAgICBsZXQgeTMgPSBwMy55O1xyXG4gICAgXHJcbiAgICBsZXQgeDQgPSBwNC54O1xyXG4gICAgbGV0IHk0ID0gcDQueTtcclxuXHJcbiAgICBsZXQgazEsIGsyLCBiMSwgYjI7XHJcbiAgICBsZXQgcngsIHJ5LCB4eCwgeXk7XHJcbiAgICBsZXQgcmVzID0ge307XHJcbiAgICBcclxuICAgIGlmICh4MSA9PSB4MiAmJiB4MyA9PSB4NCkgcmV0dXJuIG51bGw7XHJcbiAgICBpZiAoeDEgPT09IHgyKSB7XHJcbiAgICAgICAgazIgPSAoeTMgLSB5NCkgLyAoeDMgLSB4NCk7XHJcbiAgICAgICAgYjIgPSB5MyAtIGsyICogeDM7XHJcblxyXG4gICAgICAgIHJ4ID0geDE7XHJcbiAgICAgICAgcnkgPSBrMiAqIHJ4ICsgYjI7XHJcbiAgICB9IGVsc2UgaWYgKHgzID09PSB4NCkge1xyXG4gICAgICAgIGsxID0gKHkxIC0geTIpIC8gKHgxIC0geDIpO1xyXG4gICAgICAgIGIxID0geTEgLSBrMSAqIHgxO1xyXG5cclxuICAgICAgICByeCA9IHgzO1xyXG4gICAgICAgIHJ5ID0gazEgKiByeCArIGIxO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBrMSA9ICh5MSAtIHkyKSAvICh4MSAtIHgyKTtcclxuICAgICAgICBiMSA9IHkxIC0gazEgKiB4MTtcclxuXHJcbiAgICAgICAgazIgPSAoeTMgLSB5NCkgLyAoeDMgLSB4NCk7XHJcbiAgICAgICAgYjIgPSB5MyAtIGsyICogeDM7XHJcblxyXG4gICAgICAgIGlmIChrMSA9PSBrMikge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICByeCA9IChiMiAtIGIxKSAvIChrMSAtIGsyKTtcclxuICAgICAgICByeSA9IGsxICogcnggKyBiMTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoeTIgPCB5MSkge1xyXG4gICAgICAgIHl5ID0geTE7XHJcbiAgICAgICAgeTEgPSB5MjtcclxuICAgICAgICB5MiA9IHl5O1xyXG4gICAgfVxyXG4gICAgaWYgKHk0IDwgeTMpIHtcclxuICAgICAgICB5eSA9IHkzO1xyXG4gICAgICAgIHkzID0geTQ7XHJcbiAgICAgICAgeTQgPSB5eTtcclxuICAgIH1cclxuICAgIGlmICh4MiA8IHgxKSB7XHJcbiAgICAgICAgeHggPSB4MTtcclxuICAgICAgICB4MSA9IHgyO1xyXG4gICAgICAgIHgyID0geHg7XHJcbiAgICB9XHJcbiAgICBpZiAoeDQgPCB4Mykge1xyXG4gICAgICAgIHh4ID0geDM7XHJcbiAgICAgICAgeDMgPSB4NDtcclxuICAgICAgICB4NCA9IHh4O1xyXG4gICAgfVxyXG4gICAgcmVzLnggPSByeDtcclxuICAgIHJlcy55ID0gcnk7XHJcbiAgICBjb25zdCBlcnJvciA9IDE7XHJcbiAgICBpZiAoXHJcbiAgICAgICAgeDEgLSBlcnJvciA8PSByZXMueCAmJiByZXMueCA8PSB4MiArIGVycm9yICYmXHJcbiAgICAgICAgeDMgLSBlcnJvciA8PSByZXMueCAmJiByZXMueCA8PSB4NCArIGVycm9yICYmXHJcbiAgICAgICAgeTEgLSBlcnJvciA8PSByZXMueSAmJiByZXMueSA8PSB5MiArIGVycm9yICYmXHJcbiAgICAgICAgeTMgLSBlcnJvciA8PSByZXMueSAmJiByZXMueSA8PSB5NCArIGVycm9yIFxyXG4gICAgKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8vIFRoaXMgaXMgdGhlIG1heGltdW0gZGlzdGFuY2UgYmV0d2VlbiBsaW5rc1xyXG5leHBvcnQgY29uc3QgR0FQID0gMTA7IC8vIHB4XHJcbi8vIE9ubHkgZm9yIERlcml2YXRpb24gbWFwXHJcbmV4cG9ydCBmdW5jdGlvbiBhZGp1c3RWZXJ0aWNlcyAoZ3JhcGgsIGNlbGwpIHtcclxuICAgIGlmICghY2VsbCkge1xyXG4gICAgICAgIGdyYXBoLmdldExpbmtzKCkuZm9yRWFjaChmdW5jdGlvbiAobGluaykge1xyXG4gICAgICAgICAgICBhZGp1c3RWZXJ0aWNlcyhncmFwaCwgbGluayk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgLy8gSWYgdGhlIGNlbGwgaXMgYSB2aWV3LCBmaW5kIGl0cyBtb2RlbC5cclxuICAgIGNlbGwgPSBjZWxsLm1vZGVsICYmIGNlbGwubW9kZWwuZ2V0ID8gY2VsbC5tb2RlbCA6IGNlbGw7XHJcblxyXG4gICAgaWYgKGNlbGwgaW5zdGFuY2VvZiBqb2ludC5kaWEuRWxlbWVudCkge1xyXG4gICAgICAgIGdyYXBoLmdldENvbm5lY3RlZExpbmtzKGNlbGwpLmZvckVhY2goZnVuY3Rpb24gKGxpbmspIHtcclxuICAgICAgICAgICAgYWRqdXN0VmVydGljZXMoZ3JhcGgsIGxpbmspO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIFxyXG4gICAgaWYgKGNlbGwuaGlkZGVuKSByZXR1cm47XHJcbiAgICBjZWxsLnNldCgndmVydGljZXMnLCBbXSk7XHJcbiAgICBcclxuICAgIC8vIFRoZSBjZWxsIGlzIGEgbGluay4gTGV0J3MgZmluZCBpdHMgc291cmNlIGFuZCB0YXJnZXQgbW9kZWxzLlxyXG4gICAgY29uc3Qgc3JjSWQgPSBjZWxsLmdldCgnc291cmNlJykuaWQgfHwgY2VsbC5wcmV2aW91cygnc291cmNlJykuaWQ7XHJcbiAgICBjb25zdCB0cmdJZCA9IGNlbGwuZ2V0KCd0YXJnZXQnKS5pZCB8fCBjZWxsLnByZXZpb3VzKCd0YXJnZXQnKS5pZDtcclxuICAgIGNvbnN0IHNyY1BvcnQgPSBjZWxsLmdldCgnc291cmNlJykucG9ydCB8fCBjZWxsLnByZXZpb3VzKCdzb3VyY2UnKS5wb3J0O1xyXG4gICAgY29uc3QgdHJnUG9ydCA9IGNlbGwuZ2V0KCd0YXJnZXQnKS5wb3J0IHx8IGNlbGwucHJldmlvdXMoJ3RhcmdldCcpLnBvcnQ7XHJcblxyXG4gICAgLy8gSWYgb25lIG9mIHRoZSBlbmRzIGlzIG5vdCBhIG1vZGVsLCB0aGUgbGluayBoYXMgbm8gc2libGluZ3MuXHJcbiAgICBpZiAoIXNyY0lkIHx8ICF0cmdJZCkgcmV0dXJuO1xyXG5cclxuICAgIGNvbnN0IHNpYmxpbmdzID0gZ3JhcGguZ2V0TGlua3MoKS5maWx0ZXIoc2libGluZyA9PiB7XHJcbiAgICAgICAgaWYgKHNpYmxpbmcuaGlkZGVuKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgY29uc3QgX3NyY0lkID0gc2libGluZy5nZXQoJ3NvdXJjZScpLmlkO1xyXG4gICAgICAgIGNvbnN0IF90cmdJZCA9IHNpYmxpbmcuZ2V0KCd0YXJnZXQnKS5pZDtcclxuICAgICAgICBjb25zdCBfc3JjUG9ydCA9IHNpYmxpbmcuZ2V0KCdzb3VyY2UnKS5wb3J0O1xyXG4gICAgICAgIGNvbnN0IF90cmdQb3J0ID0gc2libGluZy5nZXQoJ3RhcmdldCcpLnBvcnQ7XHJcblxyXG4gICAgICAgIGNvbnN0IHNhbWVFbmRzU2FtZURpcmVjdGlvbiA9IF9zcmNJZCA9PT0gc3JjSWQgJiYgX3RyZ0lkID09PSB0cmdJZCAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9zcmNQb3J0ID09PSBzcmNQb3J0ICYmIF90cmdQb3J0ID09PSB0cmdQb3J0O1xyXG4gICAgICAgIGNvbnN0IHNhbWVFbmRzU2FtZU9wcG9zaXRlRGlyZWN0aW9uID0gX3NyY0lkID09PSB0cmdJZCAmJiBfdHJnSWQgPT09IHNyY0lkICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3NyY1BvcnQgPT09IHRyZ1BvcnQgJiYgX3RyZ1BvcnQgPT09IHNyY1BvcnQ7XHJcbiAgICAgICAgcmV0dXJuIChzYW1lRW5kc1NhbWVEaXJlY3Rpb24pIHx8IChzYW1lRW5kc1NhbWVPcHBvc2l0ZURpcmVjdGlvbik7XHJcbiAgICB9KTtcclxuXHJcbiAgICBzd2l0Y2ggKHNpYmxpbmdzLmxlbmd0aCkge1xyXG4gICAgY2FzZSAwOlxyXG4gICAgY2FzZSAxOlxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgZGVmYXVsdDoge1xyXG4gICAgICAgIC8vIFRoZXJlIGlzIG1vcmUgdGhhbiBvbmUgc2libGluZ3MuIFdlIG5lZWQgdG8gY3JlYXRlIHZlcnRpY2VzLlxyXG4gICAgICAgIC8vIEZpcnN0IG9mIGFsbCB3ZSdsbCBmaW5kIHRoZSBtaWRkbGUgcG9pbnQgb2YgdGhlIGxpbmsuXHJcbiAgICAgICAgY29uc3Qgc3JjQ2VsbCA9IGdyYXBoLmdldENlbGwoc3JjSWQpO1xyXG4gICAgICAgIGNvbnN0IHNyY1Bvc2l0aW9uID0gc3JjQ2VsbC5wb3NpdGlvbigpO1xyXG4gICAgICAgIGNvbnN0IHNyY1BvcnQgPSBzcmNDZWxsLmF0dHIoJy4nICsgY2VsbC5nZXQoJ3NvdXJjZScpLnBvcnQpO1xyXG4gICAgICAgIGlmICghc3JjUG9ydCkgcmV0dXJuO1xyXG4gICAgICAgIGNvbnN0IHNyY1BvcnRQb3NpdGlvbiA9IHtcclxuICAgICAgICAgICAgeDogc3JjUG9ydFsncmVmLXgnXSArIHNyY1Bvc2l0aW9uLngsXHJcbiAgICAgICAgICAgIHk6IHNyY1BvcnRbJ3JlZi15J10gKyBzcmNQb3NpdGlvbi55LFxyXG4gICAgICAgICAgICB0aGV0YTogam9pbnQuZy5wb2ludC5wcm90b3R5cGUudGhldGEsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCB0cmdDZWxsID0gZ3JhcGguZ2V0Q2VsbCh0cmdJZCk7XHJcbiAgICAgICAgY29uc3QgdHJnUG9zaXRpb24gPSB0cmdDZWxsLnBvc2l0aW9uKCk7XHJcbiAgICAgICAgY29uc3QgdHJnUG9ydCA9IHRyZ0NlbGwuYXR0cignLicgKyBjZWxsLmdldCgndGFyZ2V0JykucG9ydCk7XHJcbiAgICAgICAgaWYgKCF0cmdQb3J0KSByZXR1cm47XHJcbiAgICAgICAgY29uc3QgdHJnUG9ydFBvc2l0aW9uID0ge1xyXG4gICAgICAgICAgICB4OiB0cmdQb3J0WydyZWYteCddICsgdHJnUG9zaXRpb24ueCxcclxuICAgICAgICAgICAgeTogdHJnUG9ydFsncmVmLXknXSArIHRyZ1Bvc2l0aW9uLnksXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBtaWRQb2ludCA9IGpvaW50LmcubGluZShzcmNQb3J0UG9zaXRpb24sIHRyZ1BvcnRQb3NpdGlvbikubWlkcG9pbnQoKTtcclxuXHJcbiAgICAgICAgLy8gVGhlbiBmaW5kIHRoZSBhbmdsZSBpdCBmb3Jtcy5cclxuICAgICAgICBjb25zdCB0aGV0YSA9IHNyY1BvcnRQb3NpdGlvbi50aGV0YSh0cmdQb3J0UG9zaXRpb24pO1xyXG4gICAgICAgIGNvbnN0IGNlbGxJbmRleCA9IHNpYmxpbmdzLmluZGV4T2YoY2VsbCk7XHJcblxyXG4gICAgICAgIC8vIFdlIHdhbnQgdGhlIG9mZnNldCB2YWx1ZXMgdG8gYmUgY2FsY3VsYXRlZCBhcyBmb2xsb3dzIDAsIDIwLCAyMCwgNDAsIDQwLCA2MCwgNjAgLi5cclxuICAgICAgICBjb25zdCBvZmZzZXQgPSBHQVAgKiBNYXRoLmNlaWwoKGNlbGxJbmRleCArIChzaWJsaW5ncy5sZW5ndGggJSAyID09PSAwID8gMSA6IDApKSAvIDIpO1xyXG5cclxuICAgICAgICAvLyBOb3cgd2UgbmVlZCB0aGUgdmVydGljZXMgdG8gYmUgcGxhY2VkIGF0IHBvaW50cyB3aGljaCBhcmUgJ29mZnNldCcgcGl4ZWxzIGRpc3RhbnRcclxuICAgICAgICAvLyBmcm9tIHRoZSBmaXJzdCBsaW5rIGFuZCBmb3JtcyBhIHBlcnBlbmRpY3VsYXIgYW5nbGUgdG8gaXQuIEFuZCBhcyBpbmRleCBnb2VzIHVwXHJcbiAgICAgICAgLy8gYWx0ZXJuYXRlIGxlZnQgYW5kIHJpZ2h0LlxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gIF4gIG9kZCBpbmRleGVzIFxyXG4gICAgICAgIC8vICB8XHJcbiAgICAgICAgLy8gIHwtLS0tPiAgaW5kZXggMCBsaW5lIChzdHJhaWdodCBsaW5lIGJldHdlZW4gYSBzb3VyY2UgY2VudGVyIGFuZCBhIHRhcmdldCBjZW50ZXIuXHJcbiAgICAgICAgLy8gIHxcclxuICAgICAgICAvLyAgdiAgZXZlbiBpbmRleGVzXHJcbiAgICAgICAgY29uc3Qgc2lnbiA9IGNlbGxJbmRleCAlIDIgPyAxIDogLTE7XHJcbiAgICAgICAgY29uc3QgYW5nbGUgPSBqb2ludC5nLnRvUmFkKHRoZXRhICsgc2lnbiAqIDkwKTtcclxuXHJcbiAgICAgICAgLy8gV2UgZm91bmQgdGhlIHZlcnRleC5cclxuICAgICAgICBjb25zdCB2ZXJ0ZXggPSBqb2ludC5nLnBvaW50LmZyb21Qb2xhcihvZmZzZXQsIGFuZ2xlLCBtaWRQb2ludCk7XHJcblxyXG4gICAgICAgIGNlbGwuc2V0KCd2ZXJ0aWNlcycsIFt7IHg6IHZlcnRleC54LCB5OiB2ZXJ0ZXgueSB9XSk7XHJcbiAgICB9fVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGF0aCAoc2VsZWN0ZWRFbGVtZW50LCBkYXRhQ29udGFpbmVyKSB7XHJcbiAgICBjb25zdCBzb3VyY2VNYXAgPSBkYXRhQ29udGFpbmVyLm1hcHMuc291cmNlTWFwO1xyXG4gICAgY29uc3QgdGFyZ2V0TWFwID0gZGF0YUNvbnRhaW5lci5tYXBzLnRhcmdldE1hcDtcclxuICAgIGNvbnN0IG5vZGVNYXAgPSBkYXRhQ29udGFpbmVyLm1hcHMubm9kZU1hcDtcclxuXHJcbiAgICBjb25zdCBwYXRoTm9kZXMgPSB7fTtcclxuICAgIGNvbnN0IHBhdGhMaW5rc1dlc3QgPSB7fTtcclxuICAgIGNvbnN0IHBhdGhMaW5rc0Vhc3QgPSB7fTtcclxuXHJcbiAgICBpZiAobm9kZU1hcFtzZWxlY3RlZEVsZW1lbnQuaWRdKSB7XHJcbiAgICAgICAgc2VsZWN0Tm9kZSAoc2VsZWN0ZWRFbGVtZW50LCB0cnVlKTtcclxuICAgICAgICBzZWxlY3ROb2RlIChzZWxlY3RlZEVsZW1lbnQsIGZhbHNlKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcGF0aExpbmtzV2VzdFtzZWxlY3RlZEVsZW1lbnQuaWRdID0gc2VsZWN0ZWRFbGVtZW50O1xyXG4gICAgICAgIHBhdGhMaW5rc0Vhc3Rbc2VsZWN0ZWRFbGVtZW50LmlkXSA9IHNlbGVjdGVkRWxlbWVudDtcclxuICAgICAgICBzZWxlY3ROb2RlIChub2RlTWFwW3NlbGVjdGVkRWxlbWVudC5tb2RlbC50YXJnZXRdLCB0cnVlKTtcclxuICAgICAgICBzZWxlY3ROb2RlIChub2RlTWFwW3NlbGVjdGVkRWxlbWVudC5tb2RlbC5zb3VyY2VdLCBmYWxzZSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc2VsZWN0Tm9kZSAoY3VyTm9kZSwgZGlyZWN0aW9uKSB7XHJcbiAgICAgICAgcGF0aE5vZGVzW2N1ck5vZGUuaWRdID0gY3VyTm9kZTtcclxuICAgICAgICBjdXJOb2RlLmFzcGVjdHMuZm9yRWFjaChhc3BlY3QgPT4gcGF0aE5vZGVzW2FzcGVjdC5pZF0gPSBhc3BlY3QpO1xyXG4gICAgICAgIGNvbnN0IGxpbmtzID0gZGlyZWN0aW9uID8gdGFyZ2V0TWFwW2N1ck5vZGUuaWRdIDogc291cmNlTWFwW2N1ck5vZGUuaWRdO1xyXG4gICAgICAgIGlmIChsaW5rcykge1xyXG4gICAgICAgICAgICBsaW5rcy5mb3JFYWNoIChsaW5rID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgICAgICAhcGF0aExpbmtzRWFzdFtsaW5rLmlkXSAmJiBkaXJlY3Rpb24gfHxcclxuICAgICAgICAgICAgICAgICAgICAhcGF0aExpbmtzV2VzdFtsaW5rLmlkXSAmJiAhZGlyZWN0aW9uXHJcbiAgICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhMaW5rc0Vhc3RbbGluay5pZF0gPSBsaW5rO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhMaW5rc1dlc3RbbGluay5pZF0gPSBsaW5rO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBzZWxlY3ROb2RlKG5vZGVNYXBbZGlyZWN0aW9uID8gbGluay5tb2RlbC50YXJnZXQgOiBsaW5rLm1vZGVsLnNvdXJjZV0sIGRpcmVjdGlvbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gXy5tZXJnZShwYXRoTGlua3NFYXN0LCBwYXRoTGlua3NXZXN0LCBwYXRoTm9kZXMpO1xyXG59IiwiaW1wb3J0ICogYXMgXyBmcm9tICdsb2Rhc2gnO1xyXG5cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqIFJldHVybnMgbGltaXR0ZWQgYnkgYm91bmRzIHBvaW50IHZhbHVlXHJcbiAqIEBwYXJhbSB7UG9pbnR9IHBvaW50IFxyXG4gKiBAcGFyYW0ge0JvdW5kc30gYm91bmRzIFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGxpbWl0UG9pbnRQb3NpdGlvbiAocG9pbnQsIGJvdW5kcykge1xyXG4gICAgaWYgKCFib3VuZHMpIHJldHVybiBwb2ludDtcclxuICAgIFxyXG4gICAgY29uc3QgeCA9IE1hdGgubWF4KFxyXG4gICAgICAgIE1hdGgubWluKFxyXG4gICAgICAgICAgICBwb2ludC54LFxyXG4gICAgICAgICAgICBib3VuZHMubWF4WCxcclxuICAgICAgICApLFxyXG4gICAgICAgIGJvdW5kcy5taW5YLFxyXG4gICAgKTtcclxuICAgIGNvbnN0IHkgPSBNYXRoLm1heChcclxuICAgICAgICBNYXRoLm1pbihcclxuICAgICAgICAgICAgcG9pbnQueSxcclxuICAgICAgICAgICAgYm91bmRzLm1heFksXHJcbiAgICAgICAgKSxcclxuICAgICAgICBib3VuZHMubWluWSxcclxuICAgICk7XHJcbiAgICBcclxuICAgIHJldHVybiB7IHg6IHgsIHk6IHkgfTtcclxufVxyXG5cclxuLy8gZ2xvYmFsID0ge1xyXG4vLyAgICAgeDogMSxcclxuLy8gICAgIHk6IDEsXHJcbi8vIH1cclxuLy8gc2NhbGVkID0ge1xyXG4vLyAgICAgeDogZ2xvYmFsLnggKiBzY2FsZSxcclxuLy8gICAgIHk6IGdsb2JhbC55ICogc2NhbGUsXHJcbi8vIH1cclxuLy8gbG9jYWwgPSB7XHJcbi8vICAgICB4OiBzY2FsZWQueCArIHZpZXdGcmFtZVNjYWxlZFBvcy54IC0gdmlld0ZyYW1lVmlld1BvcnRQb3NpdGlvbi54LFxyXG4vLyAgICAgeTogc2NhbGVkLnkgKyB2aWV3RnJhbWVTY2FsZWRQb3MueSAtIHZpZXdGcmFtZVZpZXdQb3J0UG9zaXRpb24ueSxcclxuLy8gfVxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRTY2FsZWRWaWV3RnJhbWVQb3NpdGlvbiAodmlld0ZyYW1lKSB7XHJcbiAgICBpZiAodmlld0ZyYW1lLnBvc2l0aW9uIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcclxuICAgICAgICByZXR1cm4gdmlld0ZyYW1lLnBvc2l0aW9uKCk7XHJcbiAgICB9IGVsc2UgaWYgKHZpZXdGcmFtZS5wb3NpdGlvbikge1xyXG4gICAgICAgIHJldHVybiB2aWV3RnJhbWUucG9zaXRpb247XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW5jb3JyZWN0IHBhcmFtZXRlciEnKTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldEdsb2JhbFZpZXdQb3J0UG9zaXRpb24gKHZpZXdGcmFtZSkge1xyXG4gICAgaWYgKHZpZXdGcmFtZS5wb3NpdGlvblZpZXdQb3J0KSB7XHJcbiAgICAgICAgcmV0dXJuIHZpZXdGcmFtZS5wb3NpdGlvblZpZXdQb3J0KCk7XHJcbiAgICB9IGVsc2UgaWYgKHZpZXdGcmFtZS52aWV3UG9ydFBvc2l0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIHZpZXdGcmFtZS52aWV3UG9ydFBvc2l0aW9uO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luY29ycmVjdCBwYXJhbWV0ZXIhJyk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRHbG9iYWxOb2RlUG9zaXRpb24gKG5vZGUpIHtcclxuICAgIHJldHVybiBfLmNsb25lKG5vZGUubW9kZWwucG9zaXRpb24pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2NhbGVkTm9kZVBvc2l0aW9uIChub2RlLCBzY2FsZSkge1xyXG4gICAgaWYgKCFzY2FsZSkgdGhyb3cgbmV3IEVycm9yKCdTY2FsZSBpcyB1bmRlZmluZWQhJyk7XHJcblxyXG4gICAgY29uc3QgcG9zaXRpb24gPSBnZXRHbG9iYWxOb2RlUG9zaXRpb24obm9kZSk7XHJcbiAgICByZXR1cm4gZ2xvYmFsVG9TY2FsZWRQb2ludChwb3NpdGlvbiwgc2NhbGUpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0TG9jYWxOb2RlUG9zaXRpb24gKG5vZGUsIHNjYWxlLCB2aWV3RnJhbWUpIHtcclxuICAgIGlmICghc2NhbGUpIHRocm93IG5ldyBFcnJvcignU2NhbGUgaXMgdW5kZWZpbmVkIScpO1xyXG5cclxuICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0R2xvYmFsTm9kZVBvc2l0aW9uKG5vZGUpO1xyXG4gICAgcmV0dXJuIGdsb2JhbFRvTG9jYWxQb2ludChwb3NpdGlvbiwgc2NhbGUsIHZpZXdGcmFtZSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRHbG9iYWxOb2RlU2l6ZSAobm9kZSwgc2NhbGUpIHtcclxuICAgIGNvbnN0IHNjYWxlZFNpemUgPSBnZXRTY2FsZWROb2RlU2l6ZShub2RlKTtcclxuXHJcbiAgICByZXR1cm4gc2NhbGVkVG9HbG9iYWxTaXplKHNjYWxlZFNpemUsIHNjYWxlKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFNjYWxlZE5vZGVTaXplIChub2RlKSB7XHJcbiAgICByZXR1cm4gbm9kZS5nZXQoJ3NpemUnKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdsb2JhbFRvU2NhbGVkUG9pbnQgKHBvaW50LCBzY2FsZSkge1xyXG4gICAgaWYgKCFzY2FsZSkgdGhyb3cgbmV3IEVycm9yKCdTY2FsZSBpcyB1bmRlZmluZWQhJyk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB4OiBwb2ludC54ICogc2NhbGUueCxcclxuICAgICAgICB5OiBwb2ludC55ICogc2NhbGUueSxcclxuICAgIH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBzY2FsZWRUb0dsb2JhbFBvaW50IChwb2ludCwgc2NhbGUpIHtcclxuICAgIGlmICghc2NhbGUpIHRocm93IG5ldyBFcnJvcignU2NhbGUgaXMgdW5kZWZpbmVkIScpO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgeDogcG9pbnQueCAvIHNjYWxlLngsXHJcbiAgICAgICAgeTogcG9pbnQueSAvIHNjYWxlLnksXHJcbiAgICB9O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2xvYmFsVG9Mb2NhbFBvaW50IChwb2ludCwgc2NhbGUsIHZpZXdGcmFtZSkge1xyXG4gICAgaWYgKCFzY2FsZSkgdGhyb3cgbmV3IEVycm9yKCdTY2FsZSBpcyB1bmRlZmluZWQhJyk7XHJcbiAgICBjb25zdCBzY2FsZWRQb2ludCA9IGdsb2JhbFRvU2NhbGVkUG9pbnQocG9pbnQsIHNjYWxlKTtcclxuXHJcbiAgICByZXR1cm4gc2NhbGVkVG9Mb2NhbFBvaW50KHNjYWxlZFBvaW50LCBzY2FsZSwgdmlld0ZyYW1lKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGxvY2FsVG9HbG9iYWxQb2ludCAocG9pbnQsIHNjYWxlLCB2aWV3RnJhbWUpIHtcclxuICAgIGlmICghc2NhbGUpIHRocm93IG5ldyBFcnJvcignU2NhbGUgaXMgdW5kZWZpbmVkIScpO1xyXG4gICAgY29uc3Qgc2NhbGVkUG9pbnQgPSBsb2NhbFRvU2NhbGVkUG9pbnQocG9pbnQsIHNjYWxlLCB2aWV3RnJhbWUpO1xyXG4gICAgXHJcbiAgICByZXR1cm4gc2NhbGVkVG9HbG9iYWxQb2ludChzY2FsZWRQb2ludCwgc2NhbGUsIHZpZXdGcmFtZSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBsb2NhbFRvU2NhbGVkUG9pbnQgKHBvaW50LCBzY2FsZSwgdmlld0ZyYW1lKSB7XHJcbiAgICBpZiAoIXNjYWxlKSB0aHJvdyBuZXcgRXJyb3IoJ1NjYWxlIGlzIHVuZGVmaW5lZCEnKTtcclxuXHJcbiAgICBjb25zdCBzY2FsZWRWaWV3RnJhbWVPZmZzZXQgPSBnZXRTY2FsZWRWaWV3RnJhbWVQb3NpdGlvbih2aWV3RnJhbWUpO1xyXG4gICAgY29uc3QgZ2xvYmFsVmlld1BvcnRPZmZzZXQgPSBnZXRHbG9iYWxWaWV3UG9ydFBvc2l0aW9uKHZpZXdGcmFtZSk7XHJcbiAgICBjb25zdCBzY2FsZWRWaWV3UG9ydE9mZnNldCA9IGdsb2JhbFRvU2NhbGVkUG9pbnQoZ2xvYmFsVmlld1BvcnRPZmZzZXQsIHNjYWxlKTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHg6IHBvaW50LnggLSBzY2FsZWRWaWV3RnJhbWVPZmZzZXQueCArIHNjYWxlZFZpZXdQb3J0T2Zmc2V0LngsXHJcbiAgICAgICAgeTogcG9pbnQueSAtIHNjYWxlZFZpZXdGcmFtZU9mZnNldC55ICsgc2NhbGVkVmlld1BvcnRPZmZzZXQueSxcclxuICAgIH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBzY2FsZWRUb0xvY2FsUG9pbnQgKHBvaW50LCBzY2FsZSwgdmlld0ZyYW1lKSB7XHJcbiAgICBpZiAoIXNjYWxlKSB0aHJvdyBuZXcgRXJyb3IoJ1NjYWxlIGlzIHVuZGVmaW5lZCEnKTtcclxuXHJcbiAgICBjb25zdCBzY2FsZWRWaWV3RnJhbWVPZmZzZXQgPSBnZXRTY2FsZWRWaWV3RnJhbWVQb3NpdGlvbih2aWV3RnJhbWUpO1xyXG4gICAgY29uc3QgZ2xvYmFsVmlld1BvcnRPZmZzZXQgPSBnZXRHbG9iYWxWaWV3UG9ydFBvc2l0aW9uKHZpZXdGcmFtZSk7XHJcbiAgICBjb25zdCBzY2FsZWRWaWV3UG9ydE9mZnNldCA9IGdsb2JhbFRvU2NhbGVkUG9pbnQoZ2xvYmFsVmlld1BvcnRPZmZzZXQsIHNjYWxlKTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHg6IHBvaW50LnggKyBzY2FsZWRWaWV3RnJhbWVPZmZzZXQueCAtIHNjYWxlZFZpZXdQb3J0T2Zmc2V0LngsXHJcbiAgICAgICAgeTogcG9pbnQueSArIHNjYWxlZFZpZXdGcmFtZU9mZnNldC55IC0gc2NhbGVkVmlld1BvcnRPZmZzZXQueSxcclxuICAgIH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnbG9iYWxUb1NjYWxlZFNpemUgKHNpemUsIHNjYWxlKSB7XHJcbiAgICBpZiAoIXNjYWxlKSB0aHJvdyBuZXcgRXJyb3IoJ1NjYWxlIGlzIHVuZGVmaW5lZCEnKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgd2lkdGg6IHNpemUud2lkdGggKiBzY2FsZS54LFxyXG4gICAgICAgIGhlaWdodDogc2l6ZS5oZWlnaHQgKiBzY2FsZS55LFxyXG4gICAgfTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlZFRvR2xvYmFsU2l6ZSAoc2l6ZSwgc2NhbGUpIHtcclxuICAgIGlmICghc2NhbGUpIHRocm93IG5ldyBFcnJvcignU2NhbGUgaXMgdW5kZWZpbmVkIScpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB3aWR0aDogc2l6ZS53aWR0aCAvIHNjYWxlLngsXHJcbiAgICAgICAgaGVpZ2h0OiBzaXplLmhlaWdodCAvIHNjYWxlLnksXHJcbiAgICB9O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2xvYmFsVG9TY2FsZWRCb3VuZHMgKGJvdW5kcywgc2NhbGUpIHtcclxuICAgIGNvbnN0IHNjYWxlZE1pblBvc2l0aW9uID0gZ2xvYmFsVG9TY2FsZWRQb2ludCh7IHg6IGJvdW5kcy5taW5YLCB5OiBib3VuZHMubWluWSB9LCBzY2FsZSk7XHJcbiAgICBjb25zdCBzY2FsZWRNYXhQb3NpdGlvbiA9IGdsb2JhbFRvU2NhbGVkUG9pbnQoeyB4OiBib3VuZHMubWF4WCwgeTogYm91bmRzLm1heFkgfSwgc2NhbGUpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBtaW5YOiBzY2FsZWRNaW5Qb3NpdGlvbi54LFxyXG4gICAgICAgIG1heFg6IHNjYWxlZE1heFBvc2l0aW9uLngsXHJcbiAgICAgICAgbWluWTogc2NhbGVkTWluUG9zaXRpb24ueSxcclxuICAgICAgICBtYXhZOiBzY2FsZWRNYXhQb3NpdGlvbi55LFxyXG4gICAgICAgIHdpZHRoOiBzY2FsZWRNYXhQb3NpdGlvbi54IC0gc2NhbGVkTWluUG9zaXRpb24ueCxcclxuICAgICAgICBoZWlnaHQ6IHNjYWxlZE1heFBvc2l0aW9uLnkgLSBzY2FsZWRNaW5Qb3NpdGlvbi55LFxyXG4gICAgfTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlZFRvR2xvYmFsQm91bmRzIChib3VuZHMsIHNjYWxlKSB7XHJcbiAgICBjb25zdCBzY2FsZWRNaW5Qb3NpdGlvbiA9IHNjYWxlZFRvR2xvYmFsUG9pbnQoeyB4OiBib3VuZHMubWluWCwgeTogYm91bmRzLm1pblkgfSwgc2NhbGUpO1xyXG4gICAgY29uc3Qgc2NhbGVkTWF4UG9zaXRpb24gPSBzY2FsZWRUb0dsb2JhbFBvaW50KHsgeDogYm91bmRzLm1heFgsIHk6IGJvdW5kcy5tYXhZIH0sIHNjYWxlKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbWluWDogc2NhbGVkTWluUG9zaXRpb24ueCxcclxuICAgICAgICBtYXhYOiBzY2FsZWRNYXhQb3NpdGlvbi54LFxyXG4gICAgICAgIG1pblk6IHNjYWxlZE1pblBvc2l0aW9uLnksXHJcbiAgICAgICAgbWF4WTogc2NhbGVkTWF4UG9zaXRpb24ueSxcclxuICAgICAgICB3aWR0aDogc2NhbGVkTWF4UG9zaXRpb24ueCAtIHNjYWxlZE1pblBvc2l0aW9uLngsXHJcbiAgICAgICAgaGVpZ2h0OiBzY2FsZWRNYXhQb3NpdGlvbi55IC0gc2NhbGVkTWluUG9zaXRpb24ueSxcclxuICAgIH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBzaHJpbmtCb3VuZHMgKGJvdW5kcywgcGFkZGluZ1JlY3RhbmdsZSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBtaW5YOiBib3VuZHMubWluWCArIHBhZGRpbmdSZWN0YW5nbGUueCxcclxuICAgICAgICBtYXhYOiBib3VuZHMubWF4WCAtIHBhZGRpbmdSZWN0YW5nbGUueCxcclxuICAgICAgICBtaW5ZOiBib3VuZHMubWluWSArIHBhZGRpbmdSZWN0YW5nbGUueSxcclxuICAgICAgICBtYXhZOiBib3VuZHMubWF4WSAtIHBhZGRpbmdSZWN0YW5nbGUueSxcclxuICAgICAgICB3aWR0aDogYm91bmRzLm1heFggLSBib3VuZHMubWluWCAtIHBhZGRpbmdSZWN0YW5nbGUueCAqIDIsXHJcbiAgICAgICAgaGVpZ2h0OiBib3VuZHMubWF4WSAtIGJvdW5kcy5taW5ZIC0gcGFkZGluZ1JlY3RhbmdsZS55ICogMixcclxuICAgIH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBleHRlbmRCb3VuZHMgKGJvdW5kcywgZXh0ZW5kQnkpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbWluWDogYm91bmRzLm1pblggLSBleHRlbmRCeS54LFxyXG4gICAgICAgIG1heFg6IGJvdW5kcy5tYXhYICsgZXh0ZW5kQnkueCxcclxuICAgICAgICBtaW5ZOiBib3VuZHMubWluWSAtIGV4dGVuZEJ5LnksXHJcbiAgICAgICAgbWF4WTogYm91bmRzLm1heFkgKyBleHRlbmRCeS55LFxyXG4gICAgICAgIHdpZHRoOiBib3VuZHMubWF4WCArIGV4dGVuZEJ5LnggKiAyIC0gYm91bmRzLm1pblgsXHJcbiAgICAgICAgaGVpZ2h0OiBib3VuZHMubWF4WSArIGV4dGVuZEJ5LnkgKiAyIC0gYm91bmRzLm1pblksXHJcbiAgICB9O1xyXG59XHJcblxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0RWxlbWVudFNpemUgKHJvb3RJZCkge1xyXG4gICAgY29uc3QgcGFwZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChyb290SWQpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB3aWR0aDogcGFwZXIuY2xpZW50V2lkdGgsXHJcbiAgICAgICAgaGVpZ2h0OiBwYXBlci5jbGllbnRIZWlnaHQsXHJcbiAgICB9O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gYXJyYXlUb01hcCAoYXJyYXksIHVzZUFzSWQpIHtcclxuICAgIHVzZUFzSWQgPSB1c2VBc0lkIHx8ICdpZCc7XHJcbiAgICBjb25zdCBtYXAgPSB7fTtcclxuICAgIGFycmF5LmZvckVhY2goZWwgPT4ge1xyXG4gICAgICAgIG1hcFtlbFt1c2VBc0lkXV0gPSBlbDtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIG1hcDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIG1hcFRvQXJyYXkgKG1hcCkge1xyXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG1hcCkubWFwKGtleSA9PiBtYXBba2V5XSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXREaXN0IChwMSwgcDIpIHtcclxuICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3cocDEueCAtIHAyLngsIDIpICsgTWF0aC5wb3cocDEueSAtIHAyLnksIDIpKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldERpZmYgKG4xLCBuMikge1xyXG4gICAgY29uc3QgbWluID0gTWF0aC5taW4objEsIG4yKTtcclxuICAgIGlmIChtaW4gPCAwKSB7XHJcbiAgICAgICAgbjEgKz0gLW1pbjtcclxuICAgICAgICBuMiArPSAtbWluO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIE1hdGguYWJzKG4yIC0gbjEpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gb25EcmFnU3RhcnQgKGV2ZW50LCBtb3ZlQ2FsbGJhY2ssIHJlbGVhc2VDYWxsYmFjaykge1xyXG4gICAgbGV0IHN0YXJ0WCA9IDA7XHJcbiAgICBsZXQgc3RhcnRZID0gMDtcclxuICBcclxuICAgIGNvbnN0IHBvaW50UHJvdmlkZXIgPSBldmVudCBpbnN0YW5jZW9mIE1vdXNlRXZlbnQgPyBldmVudCA6IGV2ZW50LnRvdWNoZXNbMF07XHJcbiAgXHJcbiAgICBpZiAocG9pbnRQcm92aWRlci5wYWdlWCkgc3RhcnRYID0gcG9pbnRQcm92aWRlci5wYWdlWDtcclxuICAgIGVsc2UgaWYgKHBvaW50UHJvdmlkZXIuY2xpZW50WCkgc3RhcnRYID0gcG9pbnRQcm92aWRlci5jbGllbnRYO1xyXG4gIFxyXG4gICAgaWYgKHBvaW50UHJvdmlkZXIucGFnZVkpIHN0YXJ0WSA9IHBvaW50UHJvdmlkZXIucGFnZVk7XHJcbiAgICBlbHNlIGlmIChwb2ludFByb3ZpZGVyLmNsaWVudFkpIHN0YXJ0WSA9IHBvaW50UHJvdmlkZXIuY2xpZW50WTtcclxuICBcclxuICAgIHdpbmRvdy5nZXRTZWxlY3Rpb24oKS5yZW1vdmVBbGxSYW5nZXMoKTtcclxuICBcclxuICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgX29uY2hhbmdlKTtcclxuICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIF9vbmVuZCk7XHJcbiAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIF9vbmNoYW5nZSk7XHJcbiAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgX29uZW5kKTtcclxuICBcclxuICAgIGZ1bmN0aW9uIF9vbmNoYW5nZSAoZXZlbnQpIHtcclxuICAgICAgICBjb25zdCBwb2ludFByb3ZpZGVyID0gZXZlbnQgaW5zdGFuY2VvZiBNb3VzZUV2ZW50ID8gZXZlbnQgOiBldmVudC50b3VjaGVzWzBdO1xyXG4gIFxyXG4gICAgICAgIGxldCBlbmRYID0gMDtcclxuICAgICAgICBpZiAocG9pbnRQcm92aWRlci5wYWdlWCkgZW5kWCA9IHBvaW50UHJvdmlkZXIucGFnZVg7XHJcbiAgICAgICAgZWxzZSBpZiAocG9pbnRQcm92aWRlci5jbGllbnRYKSBlbmRYID0gcG9pbnRQcm92aWRlci5jbGllbnRYO1xyXG4gIFxyXG4gICAgICAgIGNvbnN0IGRpZmZYID0gZW5kWCAtIHN0YXJ0WDtcclxuICAgICAgICBzdGFydFggPSBlbmRYO1xyXG4gIFxyXG4gICAgICAgIGxldCBlbmRZID0gMDtcclxuICAgICAgICBpZiAocG9pbnRQcm92aWRlci5wYWdlWSkgZW5kWSA9IHBvaW50UHJvdmlkZXIucGFnZVk7XHJcbiAgICAgICAgZWxzZSBpZiAocG9pbnRQcm92aWRlci5jbGllbnRZKSBlbmRZID0gcG9pbnRQcm92aWRlci5jbGllbnRZO1xyXG4gIFxyXG4gICAgICAgIGNvbnN0IGRpZmZZID0gZW5kWSAtIHN0YXJ0WTtcclxuICAgICAgICBzdGFydFkgPSBlbmRZO1xyXG4gIFxyXG4gICAgICAgIG1vdmVDYWxsYmFjayh7IHg6IGRpZmZYLCB5OiBkaWZmWSwgfSk7XHJcbiAgICB9XHJcbiAgXHJcbiAgICBmdW5jdGlvbiBfb25lbmQgKCkge1xyXG4gICAgICAgIGRvY3VtZW50LmJvZHkub25tb3VzZW1vdmUgPSBkb2N1bWVudC5ib2R5Lm9ubW91c2V1cCA9IG51bGw7XHJcbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBfb25jaGFuZ2UpO1xyXG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIF9vbmVuZCk7XHJcbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBfb25jaGFuZ2UpO1xyXG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBfb25lbmQpO1xyXG4gICAgICAgIGlmIChyZWxlYXNlQ2FsbGJhY2spIHJlbGVhc2VDYWxsYmFjaygpO1xyXG4gICAgfVxyXG4gIH0iXX0=
