# baseURI: http://topbraid.org/swa
# imports: http://spinrdf.org/spl-dynamic-ranges
# imports: http://topbraid.org/search
# imports: http://topbraid.org/sparqlmotionlib-swp
# imports: http://topbraid.org/swa.spin
# imports: http://topbraid.org/swacharts
# imports: http://topbraid.org/swamaps
# imports: http://topbraid.org/swashacl
# imports: http://topbraid.org/swauml
# imports: http://topbraid.org/tosh.ui
# imports: http://uispin.org/html
# imports: http://uispin.org/swon
# imports: http://www.w3.org/2004/02/skos/core
# prefix: swa

@prefix acjob: <http://evn.topbraidlive.org/tagger/acjob#> .
@prefix acpp: <http://topbraid.org/nlp/autoclassifier-preproc#> .
@prefix adminguide: <http://server.topbraidlive.org/doc/adminguide#> .
@prefix afn: <http://jena.hpl.hp.com/ARQ/function#> .
@prefix arg: <http://spinrdf.org/arg#> .
@prefix autotagger: <http://evn.topbraidlive.org/autotagger#> .
@prefix cfg: <http://server.topbraidlive.org/web/2009/config#> .
@prefix charts: <http://uispin.org/charts#> .
@prefix compliance: <http://topbraid.org/compliance#> .
@prefix composite: <http://www.topbraid.org/2007/05/composite.owl#> .
@prefix conceptmatch: <http://topbraid.org/conceptmatch#> .
@prefix config: <http://server.topbraidlive.org/dynamic/config#> .
@prefix config-importers: <http://edg.topbraidlive.org/config/importers#> .
@prefix contact: <http://www.w3.org/2000/10/swap/pim/contact#> .
@prefix core-soa: <http://www.semanticweb.org/ontologies/2010/01/core-soa.owl#> .
@prefix corpus: <http://topbraid.org/corpus#> .
@prefix corpusprojects: <http://topbraid.org/corpus-projects#> .
@prefix crosswalk: <http://topbraid.org/crosswalk#> .
@prefix crosswalk.spin: <http://topbraid.org/crosswalk.spin#> .
@prefix crosswalkapp: <http://topbraid.org/swa/crosswalkapp#> .
@prefix crosswalkprojects: <http://teamwork.topbraidlive.org/crosswalkprojects#> .
@prefix css: <http://uispin.org/css#> .
@prefix daml: <http://www.daml.org/2001/03/daml+oil#> .
@prefix dash: <http://datashapes.org/dash#> .
@prefix dashboard: <http://example.org/dashboard#> .
@prefix datagraph: <http://teamwork.topbraidlive.org/datagraph/datagraphprojects#> .
@prefix dataset: <http://teamwork.topbraidlive.org/dataset#> .
@prefix datasetapp: <http://topbraid.org/swa/datasetapp#> .
@prefix datasetviewer: <http://topbraid.org/swa/datasetviewer#> .
@prefix datatype: <http://qudt.org/vocab/datatype/> .
@prefix dc: <http://purl.org/dc/elements/1.1/> .
@prefix dcam: <http://purl.org/dc/dcam/> .
@prefix dcterms: <http://purl.org/dc/terms/> .
@prefix ddl: <http://edg.topbraidlive.org/1.0/importers/ddl#> .
@prefix default: <http://uispin.org/default#> .
@prefix defaultapp: <http://topbraid.org/swa/defaultapp#> .
@prefix deployProjectToServer: <http://server.topbraidlive.org/doc/deployProjectToServer#> .
@prefix devguide: <http://evn.topbraidlive.org/evndoc.www/devguide#> .
@prefix doap: <http://usefulinc.com/ns/doap#> .
@prefix doc: <http://www.w3.org/2000/10/swap/pim/doc#> .
@prefix document: <http://topbraid.org/document#> .
@prefix documents: <http://edg.topbraid.solutions/1.0/shapes/documents#> .
@prefix dtype: <http://www.linkedmodel.org/schema/dtype#> .
@prefix edg: <http://edg.topbraid.solutions/model/> .
@prefix edg-config: <http://edg.ext.topbraidlive.org/schema/config/importers#> .
@prefix edg-importer: <http://edg.topbraidlive.org/importer/> .
@prefix edg-qa: <http://edg.topbraidlive.org/utility/qa/> .
@prefix edg.c: <http://edg.topbraid.solutions/controller/> .
@prefix edg.global: <urn:x-evn-global:> .
@prefix edg.glossary: <http://edg.topbraid.solutions/glossary/> .
@prefix edg.sqoop: <http://edg.topbraid.solutions/model/sqoop/> .
@prefix edg.v: <http://edg.topbraid.solutions/view/> .
@prefix edgproduct: <http://edg.topbraidlive.org/edgproduct#> .
@prefix eeh-lib: <http://www.environmenthub.no/spin/1.0/eeh-lib#> .
@prefix eeh-reportlib: <http://www.environmenthub.no/spin/1.0/eeh-reportlib#> .
@prefix elements: <http://purl.org/dc/elements/1.1/> .
@prefix email: <http://topbraid.org/email#> .
@prefix evn: <http://topbraid.org/evn/evn#> .
@prefix evnAdminIndex: <http://evn.topbraidlive.org/evnAdminIndex#> .
@prefix evnIntro: <http://evn.topbraidlive.org/evndoc.www/evnIntro#> .
@prefix evndoc: <http://evn.topbraidlive.org/evndoc.www/evndoc#> .
@prefix evnimport: <http://evn.topbraidlive.org/uispin/evnimport#> .
@prefix evninstallguide: <http://teamwork.topbraidlive.org/doc/evninstallguide#> .
@prefix evnui: <http://evn.topbraidlive.org/ui#> .
@prefix ex: <http://example.org/> .
@prefix extjs: <http://uispin.com/extjs#> .
@prefix flow: <http://www.w3.org/2005/01/wf/flow#> .
@prefix fn: <http://www.w3.org/2005/xpath-functions#> .
@prefix foaf: <http://xmlns.com/foaf/0.1/> .
@prefix formTemplate: <http://teamwork.topbraidlive.org/system/formTemplate#> .
@prefix forms: <http://www.topbraid.org/2007/01/forms.owl#> .
@prefix geo: <http://www.w3.org/2003/01/geo/wgs84_pos#> .
@prefix gettingstarted: <http://evn.topbraidlive.org/evndoc.www/gettingstarted#> .
@prefix glossary: <http://evn.topbraidlive.org/evndoc.www/glossary#> .
@prefix governance: <http://topbraid.org/teamworkgovernance.ui#> .
@prefix gr: <http://purl.org/goodrelations/v1#> .
@prefix graphql: <http://datashapes.org/graphql#> .
@prefix graphql.search: <http://teamwork.topbraidlive.org/graphql.search#> .
@prefix html: <http://uispin.org/html#> .
@prefix imported: <http://topbraid.org/imported#> .
@prefix inference: <http://www.topbraid.org/2007/06/inference.owl#> .
@prefix jdbc: <http://edg.topbraidlive.org/1.0/importers/jdbc#> .
@prefix json: <http://topbraid.org/json#> .
@prefix kennedys: <http://topbraid.org/examples/kennedys#> .
@prefix let: <http://uispin.org/let#> .
@prefix letrs: <http://uispin.org/letrs#> .
@prefix lib-importer: <http://edg.topbraid.solutions/importer/lib#> .
@prefix lineage-transform: <http://edg.topbraid.solutions/transform/importer/lineage#> .
@prefix list: <http://jena.hpl.hp.com/ARQ/list#> .
@prefix log: <http://www.w3.org/2000/10/swap/log#> .
@prefix metadata: <http://topbraid.org/metadata#> .
@prefix ontologyprojects: <http://teamwork.topbraidlive.org/ontologyprojects#> .
@prefix ontologyviewer: <http://topbraid.org/swa/ontologyviewer#> .
@prefix org: <http://www.w3.org/ns/org#> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix permissionGroupMgmt: <http://server.topbraidlive.org/doc/permissionGroupMgmt#> .
@prefix pg: <http://server.topbraidlive.org/web/2013/permissiongroups#> .
@prefix prov: <http://www.w3.org/ns/prov#> .
@prefix provo: <http://www.w3.org/ns/prov#> .
@prefix proxy-lineage: <http://edg.topbraid.solutions/proxy/importer/lineage#> .
@prefix quantity: <http://qudt.org/vocab/quantity/> .
@prefix qudd: <http://qudt.org/schema/datastructure/> .
@prefix quds: <http://qudt.org/schema/datastructure/> .
@prefix qudt: <http://qudt.org/schema/qudt/> .
@prefix qudt-refdata: <http://qudt.org/vocab/refdata/> .
@prefix qudt.type: <http://qudt.org/vocab/type/> .
@prefix raci: <http://topbraid.org/raci#> .
@prefix raci.spin: <http://topbraid.org/raci.spin#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix rdm: <http://rdm.topbraidlive.org/rdm/> .
@prefix rdmapp: <http://rdm.topbraidlive.org/rdmapp#> .
@prefix rdmfact: <http://topbraid.org/rdmfact#> .
@prefix rdmprojects: <http://rdm.topbraidlive.org/rdmprojects#> .
@prefix rdmviewer: <http://rdm.topbraidlive.org/rdmviewer#> .
@prefix saf: <http://topbraid.org/saf/> .
@prefix safconfig: <http://topbraid.org/safconfig/> .
@prefix safindex: <http://topbraid.org/safindex#> .
@prefix safm: <http://saf.topbraidlive.org/metaschema/> .
@prefix savedQueries: <http://teamwork.topbraidlive.org/ui/savedQueries#> .
@prefix scheduler: <http://topbraid.org/scheduler#> .
@prefix sd: <http://www.w3.org/ns/sparql-service-description#> .
@prefix search: <http://topbraid.org/search#> .
@prefix search.spin: <http://topbraid.org/search.spin#> .
@prefix server: <http://server.topbraidlive.org/server.ui#> .
@prefix sh: <http://www.w3.org/ns/shacl#> .
@prefix shapesgraph: <http://teamwork.topbraidlive.org/shapesgraph/shapesgraphprojects#> .
@prefix sharepoint: <http://topbraid.org/sharepoint#> .
@prefix sharepoint.spin: <http://topbraid.org/sharepoint.spin#> .
@prefix sioc: <http://rdfs.org/sioc/ns#> .
@prefix skos: <http://www.w3.org/2004/02/skos/core#> .
@prefix skosapp: <http://evn.topbraidlive.org/uiplugins#> .
@prefix skosshapes: <http://topbraid.org/skos.shapes#> .
@prefix skostemplate: <http://topbraid.org/spin/skostemplates#> .
@prefix skosxl: <http://www.w3.org/2008/05/skos-xl#> .
@prefix sm: <http://topbraid.org/sparqlmotion#> .
@prefix smf: <http://topbraid.org/sparqlmotionfunctions#> .
@prefix sml: <http://topbraid.org/sparqlmotionlib#> .
@prefix soa: <http://www.semanticweb.org/ontologies/2010/01/core-soa.owl#> .
@prefix softwareprojects: <http://teamwork.topbraidlive.org/software/softwareprojects#> .
@prefix solr: <http://topbraid.org/solr#> .
@prefix sp: <http://spinrdf.org/sp#> .
@prefix sparqlmotionlib-swp: <http://topbraid.org/sparqlmotionlib-swp#> .
@prefix sparqlmotionlib-tbc: <http://topbraid.org/sparqlmotionlib-tbc#> .
@prefix spell: <http://topbraid.org/spellcheckresults#> .
@prefix spif: <http://spinrdf.org/spif#> .
@prefix spin: <http://spinrdf.org/spin#> .
@prefix spin.ui: <http://spinrdf.org/spin.ui#> .
@prefix spinmap: <http://spinrdf.org/spinmap#> .
@prefix spinmapl: <http://topbraid.org/spin/spinmapl#> .
@prefix spinx: <http://spinrdf.org/spinx#> .
@prefix spl: <http://spinrdf.org/spl#> .
@prefix spl-dynamic-ranges: <http://spinrdf.org/spl-dynamic-ranges#> .
@prefix spr: <http://spinrdf.org/spr#> .
@prefix spra: <http://spinrdf.org/spra#> .
@prefix ss: <http://www.topbraidcomposer.org/owl/2006/08/spreadsheets.owl#> .
@prefix stats: <http://topbraid.org/statistics#> .
@prefix status: <http://topbraid.org/status#> .
@prefix style: <http://uispin.org/style#> .
@prefix svg: <http://uispin.org/svg#> .
@prefix swa: <http://topbraid.org/swa#> .
@prefix swaclasses: <http://topbraid.org/swaclasses#> .
@prefix swadoc: <http://topbraid.org/swadoc#> .
@prefix swaeditor: <http://topbraid.org/swaeditor#> .
@prefix swaowl: <http://topbraid.org/swaowl#> .
@prefix swash: <http://topbraid.org/swash#> .
@prefix swashacl: <http://topbraid.org/swashacl#> .
@prefix swauml: <http://topbraid.org/swauml#> .
@prefix swon: <http://uispin.org/swon#> .
@prefix sxml: <http://topbraid.org/sxml#> .
@prefix tables: <http://topbraid.org/tables#> .
@prefix tablesmap: <http://topbraid.org/spin/tablesmap#> .
@prefix tagger: <http://evn.topbraidlive.org/tagger#> .
@prefix taggerprojects: <http://evn.topbraidlive.org/taggerprojects#> .
@prefix taggerspin: <http://evn.topbraidlive.org/taggerspin#> .
@prefix taggerui: <http://evn.topbraidlive.org/taggerui#> .
@prefix task: <http://topbraid.org/task#> .
@prefix tasks: <http://topbraid.org/tasks#> .
@prefix tasks.spin: <http://topbraid.org/tasks.spin#> .
@prefix taxonomies: <http://evn.topbraidlive.org/evnprojects#> .
@prefix tbl: <http://topbraidlive.org/functions#> .
@prefix tbladmin: <http://server.topbraidlive.org/system-applications/tbladmin#> .
@prefix tbladmindoc: <http://server.topbraidlive.org/doc/adminguide#> .
@prefix tblinstallguide: <http://server.topbraidlive.org/doc/tblinstallguide#> .
@prefix tblui: <http://server.topbraidlive.org/tblui#> .
@prefix teaminstallsec: <http://teamwork.topbraidlive.org/doc/teamworkInstallGuideSections#> .
@prefix teamwork: <http://topbraid.org/teamwork#> .
@prefix teamworkAdmin: <http://teamwork.topbraidlive.org/doc/teamworkAdmin#> .
@prefix teamworkconfig: <http://server.topbraidlive.org/system-applications/teamworkconfig#> .
@prefix teamworkconstraints: <http://topbraid.org/teamworkconstraints#> .
@prefix teamworkdashboard: <http://topbraid.org/teamworkdashboard#> .
@prefix teamworknotifications: <http://topbraid.org/teamworknotifications#> .
@prefix teamworkrules: <http://topbraid.org/teamworkrules#> .
@prefix teamworkscripts: <http://topbraid.org/teamworkscripts#> .
@prefix teamworkupdate: <http://teamworkAPI.topbraid.com/teamworkUpdate#> .
@prefix textindex: <http://topbraid.org/textindex#> .
@prefix tika-importer: <http://teamwork.topbraidlive.org/corpus/tika-importer#> .
@prefix tops: <http://www.topbraid.org/tops#> .
@prefix tosh: <http://topbraid.org/tosh#> .
@prefix tosh.ui: <http://topbraid.org/tosh.ui#> .
@prefix tracker: <http://teamwork.topbraidlive.org/ui/tracker#> .
@prefix ui: <http://uispin.org/ui#> .
@prefix uitest: <http://uispin.org/test#> .
@prefix uix: <http://topbraidlive.org/uix#> .
@prefix unit: <http://qudt.org/vocab/unit/> .
@prefix userAdminIndex: <http://evn.topbraidlive.org/userAdminIndex#> .
@prefix userIndex: <http://evn.topbraidlive.org/evndoc.www/userIndex#> .
@prefix userdat: <http://teamwork.topbraidlive.org/ui/userdata> .
@prefix userdata: <http://teamwork.topbraidlive.org/ui/userdata#> .
@prefix usingtagger: <http://evn.topbraidlive.org/taggerdoc.www/usingtagger#> .
@prefix vaem: <http://www.linkedmodel.org/schema/vaem#> .
@prefix victory: <http://edg.topbraid.solutions/victory/> .
@prefix visual: <http://topbraid.org/visual#> .
@prefix voag: <http://voag.linkedmodel.org/voag/> .
@prefix vs: <http://www.w3.org/2003/06/sw-vocab-status/ns#> .
@prefix wf: <http://www.w3.org/2005/01/wf/flow#> .
@prefix wot: <http://xmlns.com/wot/0.1/> .
@prefix xhtml: <http://topbraid.org/xhtml#> .
@prefix xlink: <http://www.w3.org/1999/xlink#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

rdf:type
  swa:hiddenProperty "if no object exists" ;
.
<http://dbpedia.org/ontology/thumbnail>
  a rdf:Property ;
  rdfs:label "thumbnail" ;
  rdfs:subPropertyOf swa:thumbnail ;
.
<http://schema.org/image>
  a rdf:Property ;
  rdfs:label "image" ;
  rdfs:subPropertyOf swa:thumbnail ;
.
arg:_base
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:action
  a rdf:Property ;
  rdfs:label "action" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:addBoxInEditMode
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:allowHistoryMode
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:allowLogMessage
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:allowProvenanceMode
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:allowURIs
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:alwaysDisplay
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:appName
  a rdf:Property ;
  rdfs:label "app name" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:argumentName
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:blankNode
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:bnode
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:cache
  a rdf:Property ;
  rdfs:label "cache" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:cacheId
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:callback
  a rdf:Property ;
  rdfs:label "callback" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:categoryFunction
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:changeHandler
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:checkAllProperties
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:checkDropFunction
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:child
  a rdf:Property ;
  rdfs:label "child" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:childIndex
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:childrenQuery
  a rdf:Property ;
  rdfs:label "children query" ;
  rdfs:subPropertyOf ui:query ;
.
arg:class
  a rdf:Property ;
  rdfs:label "class" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:classSelectedEvent
  a rdf:Property ;
  rdfs:label "Class Selected Event" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:classTreeDataProvider
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:closable
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:closed
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:code
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:colClass
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:colWidths
  a rdf:Property ;
  rdfs:label "col widths" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:comment
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:compact
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:condition
  a rdf:Property ;
  rdfs:label "condition" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:constant
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:contextResource
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:contextResourceGetter
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:count
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:createHandler
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:custom
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:customEast
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:customWest
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:data
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:dataGraph
  a rdf:Property ;
  rdfs:label "data graph" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:dataProvider
  a rdf:Property ;
  rdfs:label "data provider" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:datatype
  a rdf:Property ;
  rdfs:label "datatype" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:deepLinkingEvent
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:deepLinkingPanel
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:defaultImage
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:deleteHandler
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:depth
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:descSorting
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:desktopId
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:desktopWindowClass
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:directInstancesOnly
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:disabled
  a rdf:Property ;
  rdfs:label "disabled" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:document
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:domain
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:draggable
  a rdf:Property ;
  rdfs:label "draggable" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:eastClosed
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:eastFixed
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:eastSize
  a rdf:Property ;
  rdfs:label "east size" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:editOnly
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:editWidget
  a rdf:Property ;
  rdfs:label "edit widget" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:editable
  a rdf:Property ;
  rdfs:label "editable" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:editing
  a rdf:Property ;
  rdfs:label "editing" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:element
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:elementId
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:encodeValues
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:event
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:excludedAppName
  a rdf:Property ;
  rdfs:comment "The opposite of arg:appName - may be used to filter out certain actions by app name." ;
  rdfs:domain swa:Action ;
  rdfs:label "excluded app name" ;
  rdfs:range xsd:string ;
.
arg:extraLabelFunction
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:facetClass
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:facetValue
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:fid
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:filter
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:filterFunction
  a rdf:Property ;
  rdfs:label "filter function" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:filterFunctionArgument
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:filterFunctionArgument2
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:filterNode
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:fixed
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:fixedResource
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:focusNode
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:footerPlugin
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:formId
  a rdf:Property ;
  rdfs:label "form id" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:function
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:gadgetLabel
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:gadgetName
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:gridId
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:group
  a rdf:Property ;
  rdfs:label "group" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:groupId
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:headerClass
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:headerLabel
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:height
  a rdf:Property ;
  rdfs:label "height" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:hiddenColName
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:hideCaseSensitivity
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:hideGlobalSearch
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:hideIfEmpty
  a rdf:Property ;
  rdfs:label "hide if empty" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:hideInModes
  a rdf:Property ;
  rdfs:label "hide in modes" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:hidePropertiesFunction
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:hidePropertyGroupsFunction
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:iconClass
  a rdf:Property ;
  rdfs:label "icon class" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:id
  a rdf:Property ;
  rdfs:label "id" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:ignoreURIconfigParameters
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:initialValue
  a rdf:Property ;
  rdfs:label "initial value" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:inlineEditCancelCallback
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:input
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:inputType
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:instanceSelectedEvent
  a rdf:Property ;
  rdfs:label "Instance Selected Event" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:inverse
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:item
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:keepBNodes
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:key
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:keyProperties
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:keyPropertiesList
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:kind
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:label
  a rdf:Property ;
  rdfs:label "label" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:labelOverride
  a rdf:Property ;
  rdfs:label "label override" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:labelProperty
  a rdf:Property ;
  rdfs:label "label property" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:labelWidth
  a rdf:Property ;
  rdfs:label "label width" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:layoutPanel
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:leftWidth
  a rdf:Property ;
  rdfs:label "left width" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:linear
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:listId
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:loadId
  a rdf:Property ;
  rdfs:label "load id" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:loadImmediately
  a rdf:Property ;
  rdfs:label "load immediately" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:localSearch
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:matchIds
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:maxHeight
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:maxLength
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:maxResultCount
  a rdf:Property ;
  rdfs:label "max result count" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:member
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:menuFilterNode
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:metadata
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:minHeight
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:minWidth
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:modeName
  a rdf:Property ;
  rdfs:label "mode name" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:modeNames
  a rdf:Property ;
  rdfs:label "mode names" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:multiSelect
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:newObject
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:newValue
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:noBorder
  a rdf:Property ;
  rdfs:label "no border" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:northFixed
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:northSize
  a rdf:Property ;
  rdfs:label "north size" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:object
  a rdf:Property ;
  rdfs:label "object" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:objectType
  a rdf:Property ;
  rdfs:label "object type" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:oldElementId
  a rdf:Property ;
  rdfs:label "old element id" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:onChange
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:onClick
  a rdf:Property ;
  rdfs:label "on click" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:onDoubleClick
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:onLoaded
  a rdf:Property ;
  rdfs:label "on loaded" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:onSelect
  a rdf:Property ;
  rdfs:label "on select" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:open
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:openable
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:overlayImage
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:ownerId
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:page
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:pagerId
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:params
  a rdf:Property ;
  rdfs:label "params" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:parent
  a rdf:Property ;
  rdfs:label "parent" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:parentId
  a rdf:Property ;
  rdfs:label "parent id" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:path
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:placeholder
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:plugin
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:predicates
  a rdf:Property ;
  rdfs:label "predicates" ;
  rdfs:subPropertyOf ui:resultSet ;
.
arg:previous
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:property
  a rdf:Property ;
  rdfs:label "property" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:propertySelectionTemplate
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:queryGraph
  a rdf:Property ;
  rdfs:label "query graph" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:range
  a rdf:Property ;
  rdfs:label "range" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:readOnly
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:refreshEvent
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:refreshFilterFunction
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:relationship
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:required
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:resourceGetter
  a rdf:Property ;
  rdfs:label "resource getter" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:resourceSelectedEvent
  a rdf:Property ;
  rdfs:label "resource selected event" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:resourceSelectionEvent
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:resourceTypeCode
  a rdf:Property ;
  rdfs:label "resource type code" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:resourceTypeLabel
  a rdf:Property ;
  rdfs:label "resource type label" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:resourceURI
  a rdf:Property ;
  rdfs:label "resource URI" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:resourceURIs
  a rdf:Property ;
  rdfs:label "resource URIs" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:resources
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:rest
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:restoreSearch
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:resultsId
  a rdf:Property ;
  rdfs:label "results id" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:root
  a rdf:Property ;
  rdfs:label "root" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:rootClass
  a rdf:Property ;
  rdfs:label "Root Class" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:rootType
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:rootsQuery
  a rdf:Property ;
  rdfs:label "roots query" ;
  rdfs:subPropertyOf ui:query ;
.
arg:rowCount
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:rowIndex
  a rdf:Property ;
  rdfs:label "row index" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:rowNumCookie
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:rows
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:script
  a rdf:Property ;
  rdfs:label "script" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:search
  a rdf:Property ;
  rdfs:label "search" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:searchButtonHandler
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:searchCompletedEvent
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:searchGraph
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:searchMemoryModel
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:searchResultsGeneratedEvent
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:searchResultsGridHandler
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:searchWidget
  a rdf:Property ;
  rdfs:label "search widget" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:section
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:selectId
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:selectedResource
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:selectedType
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:shape
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:shapeSectionAbove
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:showFooter
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:showResourceActions
  a rdf:Property ;
  rdfs:label "show resource actions" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:showSearchResultsActions
  a rdf:Property ;
  rdfs:label "show search results actions" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:showType
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:showURI
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:sidx
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:single
  a rdf:Property ;
  rdfs:label "single" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:size
  a rdf:Property ;
  rdfs:label "size" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:sord
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:sortByFirstKeyProperty
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:sortProperty
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:sortPropertyInverse
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:southFixed
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:southSize
  a rdf:Property ;
  rdfs:label "south size" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:storageKey
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:string
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:style
  a rdf:Property ;
  rdfs:label "style" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:subClass
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:subTitle
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:subject
  a rdf:Property ;
  rdfs:label "subject" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:suggestedRange
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:suppressActions
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:suppressExcludeSubclassesBox
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:suppressHeader
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:suppressInitializer
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:suppressInlineEditing
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:suppressKeyPropertiesSelection
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:suppressLabelColumn
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:suppressLanguage
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:suppressLocalSearch
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:suppressMenu
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:suppressNestedKeyPropertiesSelection
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:suppressShapeSection
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:suppressTypeSelection
  a rdf:Property ;
  rdfs:label "suppress type selection" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:tabId
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:tabName
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:tabStorageKey
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:tableFactory
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:tabular
  a rdf:Property ;
  rdfs:label "tabular" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:targetId
  a rdf:Property ;
  rdfs:label "target id" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:template
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:templateGraph
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:templates
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:term
  a rdf:Property ;
  rdfs:label "term" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:text
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:title
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:toggleFunctionCall
  a rdf:Property ;
  rdfs:label "toggle function call" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:toolTip
  a rdf:Property ;
  rdfs:label "tool tip" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:topHeight
  a rdf:Property ;
  rdfs:label "top height" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:topPager
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:treeChildrenTemplate
  a rdf:Property ;
  rdfs:label "tree children template" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:treeDataProvider
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:treeId
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:treeMoveHandler
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:treePathTemplate
  a rdf:Property ;
  rdfs:label "tree path template" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:treeRootsTemplate
  a rdf:Property ;
  rdfs:label "tree roots template" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:type
  a rdf:Property ;
  rdfs:label "type" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:typeLabel
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:typeSelectable
  a rdf:Property ;
  rdfs:label "type selectable" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:uid
  a rdf:Property ;
  rdfs:label "uid" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:unclosable
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:unmaximizable
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:unminimizable
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:updateLink
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:uri
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:useContextResourceAsType
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:useGraph
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:useUUID
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:value
  a rdf:Property ;
  rdfs:label "value" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:varName
  a rdf:Property ;
  rdfs:label "var name" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:view
  a rdf:Property ;
  rdfs:label "view" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:viewModeName
  a rdf:Property ;
  rdfs:label "view mode name" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:viewWidget
  a rdf:Property ;
  rdfs:label "view widget" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:visitedGraph
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:visitedNodes
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:westClosed
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:westFixed
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:westSize
  a rdf:Property ;
  rdfs:label "west size" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:width
  a rdf:Property ;
  rdfs:label "width" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:windowId
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:withInitializer
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:withSelectMenu
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:x
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:xrange
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:y
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
spin:Modules
  ui:instanceView """
<swa:ArgumentsFormBody arg:resource=\"{= ?this }\" ui:id=\"form\"/>
"""^^ui:Literal ;
.
search:results
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:count ;
      spl:valueType xsd:integer ;
      rdfs:comment "The number of rows to deliver at most." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:descSorting ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to sort in descending order." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:produceJSON ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to directly product JSON output, as hard-coded for DataTables." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:sortProperty ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The property to sort against." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:sortPropertyInverse ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True if the sort property is an inverse property." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:startIndex ;
      spl:valueType xsd:integer ;
      rdfs:comment "The row index to start with." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:suppressLabelColumn ;
      spl:valueType xsd:boolean ;
      rdfs:comment "Only used if produceJSON=true." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:search ;
      spl:valueType search:Search ;
      rdfs:comment "The search:Search to execute." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:searchGraph ;
      spl:valueType rdfs:Resource ;
    ] ;
  rdfs:comment "Executes a given search:Search and executes the child elements with two additional variable bindings: ?totalCount will contain the number of matching rows, and ?results is a SPARQL result set with one column called ?result. Alternatively, if arg:produceJSON is true, it will directly insert JSON in the format expected by the SWA DataTables components." ;
  rdfs:label "results" ;
  rdfs:subClassOf ui:ControlElement ;
.
search:toSHACL
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:uri ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The URI of the shape to generate. Defaults to a blank node." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:search ;
      spl:valueType search:Search ;
      rdfs:comment "The search:Search." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:targetGraph ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The target graph, e.g. ui:tempGraph." ;
    ] ;
  ui:private true ;
  rdfs:comment "Converts a given search:Search into a SHACL shape that defines the same constraints. If needed, also includes SHACLTON annotations to indicate how to render the results into JSON." ;
  rdfs:label "to SHACL" ;
  rdfs:subClassOf ui:ControlElement ;
.
sm:source
  swa:hiddenProperty true ;
.
sml:swpNote
  swa:hiddenProperty true ;
.
<http://topbraid.org/swa>
  a owl:Ontology ;
  rdfs:comment """A library of reusable components for SWP-based applications. Includes elements to insert forms, trees, grids etc.

This library is under active development, and most elements and functions are declared \"private\" to discourage direct use. If you need any of the private elements, please let us know. We will make reasonable efforts to keep the non-private elements stable.""" ;
  rdfs:label "SWA - SWP Application Components" ;
  owl:imports <http://spinrdf.org/spl-dynamic-ranges> ;
  owl:imports <http://topbraid.org/search> ;
  owl:imports <http://topbraid.org/sparqlmotionlib-swp> ;
  owl:imports <http://topbraid.org/swa.spin> ;
  owl:imports <http://topbraid.org/swacharts> ;
  owl:imports <http://topbraid.org/swamaps> ;
  owl:imports <http://topbraid.org/swashacl> ;
  owl:imports <http://topbraid.org/swauml> ;
  owl:imports <http://topbraid.org/tosh.ui> ;
  owl:imports <http://uispin.org/html> ;
  owl:imports <http://uispin.org/swon> ;
  owl:imports <http://www.w3.org/2004/02/skos/core> ;
  owl:versionInfo "0.9.5" ;
  sh:declare [
      a sh:PrefixDeclaration ;
      sh:namespace "http://topbraid.org/swa#"^^xsd:anyURI ;
      sh:prefix "swa" ;
    ] ;
.
swa:Abstract
  a ui:NodeClass ;
  ui:prototype """
<section id=\"introduction\">
    <ui:insertionPoint ui:pointId=\"body\"/>
</section>
"""^^ui:Literal ;
  rdfs:comment "Inserts an Abstract to the start of a Document. This also sets the correct anchor point for the table of contents, so it should be present in all swa:Documents." ;
  rdfs:label "Abstract" ;
  rdfs:subClassOf swa:DocumentElements ;
.
swa:AbstractBorderLayout
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:eastClosed ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to have the East panel minimized/closed by default." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:eastFixed ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to make the eastern panel not resizable." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:eastSize ;
      spl:valueType xsd:integer ;
      rdfs:comment "The pixel size of the east panel." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:northFixed ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to make the north panel not resizable." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:northSize ;
      spl:valueType xsd:integer ;
      rdfs:comment "The pixel size of the north panel." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:southFixed ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to make the south panel not resizable." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:southSize ;
      spl:valueType xsd:integer ;
      rdfs:comment "The pixel size of the south panel." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:storageKey ;
      spl:valueType xsd:string ;
      rdfs:comment "A unique identifier within the server, to help save and restore the layout if the user has resized windows. For example, this could be \"myApp\". If not specified, the layout will not be remembered, and switching between child views in a MultiGadgetWindow will reset the layout." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:westClosed ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to have the West panel minimized/closed by default." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:westFixed ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to make the west panel not resizable." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:westSize ;
      spl:valueType xsd:integer ;
      rdfs:comment "The pixel size of the west panel." ;
    ] ;
  ui:abstract true ;
  rdfs:comment "Abstract base class that groups together some arguments needed for border layouts." ;
  rdfs:label "Abstract border layout" ;
  rdfs:subClassOf swa:LayoutElements ;
.
swa:AbstractEnumDropDownEditor
  a swa:ObjectEditorClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:onChange ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional JavaScript function to execute upon a change to the select field." ;
    ] ;
  ui:abstract true ;
  ui:private true ;
  ui:prototype """
<span let:name=\"new-{= ?uid }\" let:range=\"{= swa:localRangeAtClass(swa:resourceType(?subject), ?predicate) }\">
    <select class=\"form-control {= swa:testClass(?predicate) }\" name=\"{= ?name }\" onchange=\"{= ?onChange }\">
        <ui:call arg:resource=\"{= ?range }\" ui:template=\"{= swa:OneOfItems }\">
            <option/>
            <ui:forEach ui:indexVar=\"index\" ui:resultSet=\"{= ?rs }\">
                <option selected=\"{= IF((?object = ?item), &quot;selected&quot;, ?none) }\" value=\"{= ui:encodeNode(?item, true, true) }\">{= ui:label(?item) }</option>
            </ui:forEach>
        </ui:call>
    </select>
</span>
"""^^ui:Literal ;
  rdfs:label "Abstract enum drop down editor" ;
  rdfs:subClassOf swa:ObjectEditor ;
.
swa:AbstractEnumDropDownFacet
  a swa:ObjectFacetClass ;
  ui:private true ;
  ui:prototype """
<span let:name=\"value{= ?uid }\" let:range=\"{= swa:localRangeAtClass(swa:resourceType(), ?predicate) }\" let:restore=\"{= swa:restoreFacetValue(?predicate) }\">
    <select class=\"form-control {= swa:testClass(?predicate) }\" let:value=\"{= IF(bound(?restore), spl:object(?restore, search:object), ?none) }\" name=\"{= ?name }\">
        <ui:call arg:resource=\"{= ?range }\" ui:template=\"{= swa:OneOfItems }\">
            <option type=\"radio\">{= ?item }</option>
            <ui:forEach ui:indexVar=\"index\" ui:resultSet=\"{= ?rs }\">
                <option selected=\"{= IF((?value = ?item), &quot;selected&quot;, ?none) }\" type=\"radio\" value=\"{= ui:encodeNode(?item, true, true) }\">{= ui:label(?item) }</option>
            </ui:forEach>
        </ui:call>
    </select>
</span>
"""^^ui:Literal ;
  rdfs:label "Abstract enum drop down facet" ;
  rdfs:subClassOf swa:ObjectFacet ;
.
swa:AbstractInlineEditor
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:readOnly ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to make this non-editable. This can be used to have a consistent layout even if the user does not have editing permissions." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:value ;
      rdfs:comment "The original value to display and edit." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:updateLink ;
      spl:valueType xsd:string ;
      rdfs:comment "A link to the servlet to call when a new value has been entered by the user. The new value will be passed into the service as argument called \"newValue\"." ;
    ] ;
  ui:abstract true ;
  rdfs:label "Abstract inline editor" ;
  rdfs:subClassOf swa:InlineEditorElements ;
.
swa:AbstractObject
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:defaultValue "160px" ;
      spl:optional true ;
      spl:predicate arg:labelWidth ;
      spl:valueType xsd:string ;
      rdfs:comment "The label width, defaults to 160px. Set to \"inline\" to have the preferred width, i.e. it will occupy exactly the needed space." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:class ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional CSS class for the main loadable. Defaults to swa-labeled-objects." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:editWidget ;
      spl:valueType swa:ObjectEditorClass ;
      rdfs:comment "The preferred widget if in edit mode." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:hideIfEmpty ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to suppress this if the given subject has no value for the given predicate. Has no effect if we are not in view mode." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:hideInModes ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional comma-separated list of mode names (e.g. \"edit\", \"search\", \"view\") enumerating those views in which this widget shall be hidden." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:label ;
      spl:valueType xsd:string ;
      rdfs:comment "A label, overriding the default label." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:linear ;
      spl:valueType xsd:boolean ;
      rdfs:comment "By default (false), the label and the widget will be laid out in a tabular style, with all widgets nicely aligned underneath one another. If set to true, then no such alignment will happen. (In previous versions of SWA this was represented using arg:tabular)." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:searchWidget ;
      spl:valueType swa:ObjectFacetClass ;
      rdfs:comment "The preferred facet widget." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:viewWidget ;
      spl:valueType swa:ObjectViewerClass ;
      rdfs:comment "The preferred widget if in view mode." ;
    ] ;
  ui:abstract true ;
  rdfs:comment "Base class of swa:Object and swa:Objects, to declare the arguments that the subclasses have in common." ;
  rdfs:label "Abstract object" ;
  rdfs:subClassOf swa:ObjectElements ;
.
swa:AbstractRadioButtonsEditor
  a swa:ObjectEditorClass ;
  ui:private true ;
  ui:prototype """
<span let:name=\"new-{= ?uid }\" let:range=\"{= swa:localRangeAtClass(swa:resourceType(?subject), ?predicate) }\">
    <ui:call arg:resource=\"{= ?range }\" ui:template=\"{= swa:OneOfItems }\">
        <div class=\"form-check\">
            <ui:forEach ui:indexVar=\"index\" ui:resultSet=\"{= ?rs }\">
                <ui:if ui:condition=\"{= ?index &gt; 0 }\">
                    <br/>
                </ui:if>
                <input checked=\"{= IF((?item = ?object), &quot;checked&quot;, ?none) }\" name=\"{= ?name }\" type=\"radio\" value=\"{= ui:encodeNode(?item, true, true) }\"/>{= ui:label(?item) }</ui:forEach>
        </div>
    </ui:call>
</span>
"""^^ui:Literal ;
  rdfs:label "Radio buttons editor" ;
  rdfs:subClassOf swa:ObjectEditor ;
.
swa:AbstractSubject
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:defaultValue "160px" ;
      spl:optional true ;
      spl:predicate arg:labelWidth ;
      spl:valueType xsd:string ;
      rdfs:comment "The label width, defaults to 160px. Set to \"inline\" to have the preferred width, i.e. it will occupy exactly the needed space." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:hideIfEmpty ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to suppress this if the given subject has no value for the given predicate. Has no effect if we are not in view mode." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:label ;
      spl:valueType xsd:string ;
      rdfs:comment "A label, overriding the default label." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:linear ;
      spl:valueType xsd:boolean ;
      rdfs:comment "By default (false), the label and the widget will be laid out in a tabular style, with all widgets nicely aligned underneath one another. If set to true, then no such alignment will happen. (In previous versions of SWA this was represented using arg:tabular)." ;
    ] ;
  ui:abstract true ;
  rdfs:comment "Similar to swa:AbstractObject but for the other direction." ;
  rdfs:label "Abstract subject" ;
  rdfs:subClassOf swa:SubjectElements ;
.
swa:AbstractTextFieldEditor
  a swa:ObjectEditorClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:datatype ;
      spl:valueType rdfs:Datatype ;
      rdfs:comment "An optional rdfs:Datatype that may be set to prefer a certain datatype." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:onChange ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional JavaScript function to execute upon a change to the input field." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:suppressLanguage ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to disallow editing the language." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:inputType ;
      spl:valueType xsd:string ;
      rdfs:comment "Either \"text\" or \"password\"." ;
    ] ;
  ui:abstract true ;
  ui:prototype """
<ui:group let:datatype=\"{= COALESCE(?datatype, IF(bound(?object), datatype(?object), swa:localRange(?predicate, ?subject))) }\">
    <swa:ObjectEditorHiddenDatatypeField arg:datatype=\"{= ?datatype }\" arg:uid=\"{= ?uid }\"/>
    <table class=\"swa-abstract-text-field-editor-container\">
        <tr>
            <td class=\"swa-width-100\">
                <input class=\"swa-text-field form-control {= swa:testClass(?predicate) }\" id=\"new-{= ?uid }\" name=\"new-{= ?uid }\" onchange=\"{= ?onChange }\" type=\"{= ?inputType }\" value=\"{= ?object }\"/>
            </td>
            <ui:if ui:condition=\"{= (((?datatype = xsd:string) || (?datatype = rdfs:Literal)) || (?datatype = rdf:langString)) || (bound(?object) &amp;&amp; (lang(?object) != &quot;&quot;)) }\">
                <ui:group let:shacl=\"{= swa:isFromSHACLDatatypeConstraint(?datatype, ?predicate, ?subject) }\">
                    <ui:if ui:condition=\"{= swa:falseOrUnbound(?suppressLanguage) &amp;&amp; ((?datatype = rdf:langString) || (!?shacl)) }\">
                        <td>
                            <swa:LangSelector arg:initialValue=\"{= lang(?object) }\" arg:required=\"{= ?shacl &amp;&amp; (?datatype = rdf:langString) }\" arg:uid=\"{= ?uid }\"/>
                        </td>
                    </ui:if>
                </ui:group>
            </ui:if>
        </tr>
    </table>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "Base class to share common functionality of TextFieldEditor and PasswordEditor." ;
  rdfs:label "Abstract text field editor" ;
  rdfs:subClassOf swa:ObjectEditor ;
.
swa:AbstractWindow
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:id ;
      spl:valueType xsd:string ;
      rdfs:comment "The (HTML and ui:loadable) id to use for this Window. Must be a string constant - no variables or other expressions allowed!" ;
    ] ;
  ui:abstract true ;
  rdfs:label "Abstract window" ;
  rdfs:subClassOf swa:ApplicationElements ;
.
swa:Action
  a rdfs:Class ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:appName ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of an application that this action is applicable for. Can be used to narrow down some actions so that they only show up for applications where the context variable \"swaAppName\" has been set to a given value." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:group ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the group that this belongs to. Actions from the same group will be visually separated from those in other groups (e.g. using dividers in menus). All groups will be ordered alphabetically." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:iconClass ;
      spl:valueType xsd:string ;
      rdfs:comment "The CSS class(es) for icons representing the action." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:condition ;
      spl:valueType xsd:boolean ;
      rdfs:comment "An expression delivering a boolean. Only Actions that return true will be displayed and can be selected. Depending on the context, different variables will be pre-bound when the condition is evaluated. For example, ResourceActions have ?resource pre-bound with the selected resource and SearchResultActions have the variable ?appName pre-bound with the surrounding SWA application name." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:onSelect ;
      spl:valueType xsd:string ;
      rdfs:comment "JavaScript code that shall be executed when the Action is executed by the user." ;
    ] ;
  rdfs:comment """Abstract superclass for objects that represent an executable action. Actions are typically rendered as menu items or buttons and may have a label and/or an icon.

The SWA actions framework supports plug-in development in which available actions are discovered dynamically. The plug-in developer simply needs to create an instance of an Action class in an SWP graph, and the framework can traverse, filter and sort the available actions when needed.

Actions can be grouped by applications, so that not all globally registered actions will be visible everywhere. SWA applications that wish to restrict the actions should set a global context variable \"swaAppName\" globally, using ui:setContext. This may be a comma-separated list of names, e.g. \"EVN,Editor\" for all actions related to EVN and those associated with \"Editor\" (the global Delete resource action is marked like that).

When the user triggers execution, the engine will execute the JavaScript code specified by the onSelect argument. If no onSelect is declared then the Action is expected to be an SWP element class that executes some transaction performing updates to the graph.""" ;
  rdfs:label "Action" ;
.
swa:AddDefaultValuesPlugin
  a rdfs:Class ;
  rdfs:comment "Metaclass of SWP elements that will be executed whenever a new resource is created, via swa:addDefaultValues. See swa:AddDefaultValuesPlugins." ;
  rdfs:label "Add default values plugin" ;
  rdfs:subClassOf ui:Operation ;
.
swa:AddDefaultValuesPlugins
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to add the default values for." ;
    ] ;
  ui:abstract true ;
  rdfs:comment "Abstract superclass with instances of swa:AddDefaultValuesPlugin. Note that when creating the subclass, you still need to change its rdf:type to swa:AddDefaultValuesPlugin." ;
  rdfs:label "Add default values plugins" ;
  rdfs:subClassOf ui:Operations ;
.
swa:AddPropertyBox
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:subject ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject being edited (not needed if only used in search mode)." ;
    ] ;
  ui:prototype """
<ui:if ui:condition=\"{= swa:isSearchMode() || (swa:isEditMode() &amp;&amp; bound(?subject)) }\">
    <ui:group let:id=\"{= ui:uniqueId() }\" let:resourceType=\"{= swa:resourceType(?subject) }\" let:restoreSearch=\"{= swa:restoreSearch() }\">
        <ui:if ui:condition=\"{= bound(?restoreSearch) }\">
            <ui:forEach ui:resultSet=\"{#
                    SELECT ?predicate
                    WHERE {
                        ?restoreSearch search:facet/search:property ?predicate .
                        FILTER NOT EXISTS {
                            GRAPH ui:tempGraph {
                                ?restoreSearch swa:used ?predicate .
                            } .
                        } .
                    } }\">
                <swa:Object arg:predicate=\"{= ?predicate }\"/>
            </ui:forEach>
        </ui:if>
        <ui:loadable ui:loadId=\"{= ?id }-object\">
            <ui:if ui:condition=\"{= bound(?addProperty) }\">
                <swa:Objects arg:predicate=\"{= ?addProperty }\" arg:subject=\"{= ?subject }\"/>
            </ui:if>
        </ui:loadable>
        <ui:loadable ui:loadId=\"{= ?id }\">
            <ui:group letrs:properties=\"{#
                    SELECT ?property
                    WHERE {
                        ?property spl:relevantPropertyAtClass ?resourceType .
                        FILTER ((!swa:isHiddenProperty(?property)) &amp;&amp; (?property NOT IN (owl:deprecated, owl:differentFrom, rdfs:isDefinedBy, owl:sameAs, rdfs:seeAlso, rdf:value, owl:versionInfo))) .
                    }
                    ORDER BY (ui:label(?property)) }\">
                <div class=\"swa-add-property-box\" id=\"{= ?id }-div\">
                    <span>Add property: </span>
                    <select autocomplete=\"off\" class=\"form-control\" id=\"{= ?id }-select\" onchange=\"if($('#{= ?id }-select').val()) { swa.addPropertyToSearchForm('{= ?id }', $('#{= ?id }-select').val()); }\">
                        <option selected=\"selected\"/>
                    </select>
                    <script>var select = $('#{= ?id }-select');
					var form = select.closest('form');
					var used = swa.getPropertiesUsedOnForm(form);<ui:forEach ui:resultSet=\"{= ?properties }\">if(!used['{= ?property }']) {
						select.append('&lt;option value=\"{= ?property }\"&gt;{= ui:label(?property) }&lt;/option&gt;');
					}</ui:forEach>if(select.children().length == 1) {
						$('#{= ?id }-div').css('display', 'none');
					}</script>
                </div>
            </ui:group>
        </ui:loadable>
    </ui:group>
</ui:if>
"""^^ui:Literal ;
  rdfs:comment "A drop down box that can be placed to the end of a form body to allow users to add other properties that are not yet visible." ;
  rdfs:label "Add property box" ;
  rdfs:subClassOf swa:FormElements ;
.
swa:AllArgumentPredicates
  a spin:SelectTemplate ;
  spin:body [
      a sp:Select ;
      sp:orderBy (
          [
            a ui:label ;
            sp:arg1 [
                sp:varName "predicate" ;
              ] ;
          ]
        ) ;
      sp:resultVariables (
          [
            sp:varName "predicate" ;
          ]
        ) ;
      sp:where (
          [
            a sp:TriplePath ;
            sp:object [
                sp:varName "atClass" ;
              ] ;
            sp:path [
                a sp:ModPath ;
                sp:modMax -2 ;
                sp:modMin 0 ;
                sp:subPath rdfs:subClassOf ;
              ] ;
            sp:subject [
                sp:varName "class" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "arg" ;
              ] ;
            sp:predicate spin:constraint ;
            sp:subject [
                sp:varName "atClass" ;
              ] ;
          ]
          [
            sp:object spl:Argument ;
            sp:predicate rdf:type ;
            sp:subject [
                sp:varName "arg" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "predicate" ;
              ] ;
            sp:predicate spl:predicate ;
            sp:subject [
                sp:varName "arg" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:class ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class to get the arguments of." ;
    ] ;
  spin:labelTemplate "All spl:Argument predicates of {?class}" ;
  rdfs:comment "Gets a list of the properties behind all spl:Arguments declared at a given class and its superclasses, sorted by their ui:labels." ;
  rdfs:label "All argument predicates" ;
  rdfs:subClassOf spin:SelectTemplates ;
.
swa:AllInstances
  a spin:SelectTemplate ;
  spin:body [
      a sp:Select ;
      sp:orderBy (
          [
            a ui:label ;
            sp:arg1 [
                sp:varName "instance" ;
              ] ;
          ]
        ) ;
      sp:resultVariables (
          [
            sp:varName "instance" ;
          ]
          [
            sp:varName "uri" ;
          ]
          [
            sp:varName "type" ;
          ]
        ) ;
      sp:where (
          [
            a sp:TriplePath ;
            sp:object [
                sp:varName "class" ;
              ] ;
            sp:path [
                a sp:ModPath ;
                sp:modMax -2 ;
                sp:modMin 0 ;
                sp:subPath rdfs:subClassOf ;
              ] ;
            sp:subject [
                sp:varName "type" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "type" ;
              ] ;
            sp:predicate rdf:type ;
            sp:subject [
                sp:varName "instance" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a xsd:string ;
                sp:arg1 [
                    sp:varName "instance" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "uri" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:class ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class that the instances must have." ;
    ] ;
  rdfs:comment "Gets all instances of a given class, and its subclasses, and orders them by label. Note this may (obviously) not scale if a class has too many instances." ;
  rdfs:label "All instances" ;
  rdfs:subClassOf spin:SelectTemplates ;
.
swa:AllInstancesRadioButtonsEditor
  a swa:ObjectEditorClass ;
  ui:prototype """
<span let:name=\"new-{= ?uid }\" let:range=\"{= swa:localRange(?predicate, ?subject) }\">
    <div class=\"form-check\">
        <ui:forEach ui:indexVar=\"index\" ui:resultSet=\"{#
                SELECT DISTINCT ?instance ?label
                WHERE {
                    ?instance rdf:type/(rdfs:subClassOf)* ?range .
                    BIND (ui:label(?instance) AS ?label) .
                }
                ORDER BY (?label) }\">
            <ui:if ui:condition=\"{= ?index &gt; 0 }\">
                <br/>
            </ui:if>
            <input checked=\"{= IF((?instance = ?object), &quot;checked&quot;, ?none) }\" name=\"{= ?name }\" type=\"radio\" value=\"{= ui:encodeNode(?instance, true, true) }\"/>{= ?label }</ui:forEach>
    </div>
</span>
"""^^ui:Literal ;
  rdfs:comment "Displays radio buttons for all instances of the class that is the value type/range of the property." ;
  rdfs:label "All instances radio buttons editor" ;
  rdfs:subClassOf swa:ObjectEditor ;
.
swa:AnyObjectFacet
  a swa:ObjectFacetClass ;
  swa:facetSearchType search:AnyFacetValue ;
  swa:objectFacetMenuName "any value" ;
  swa:objectWidgetWeight [
      a swa:WeightedExpression ;
      swa:expression [
          a swa:hasMatchingRestoreFacetValue ;
          arg:facetClass swa:AnyObjectFacet ;
          arg:property [
              sp:varName "predicate" ;
            ] ;
        ] ;
      swa:weight -5 ;
    ] ;
  ui:prototype """
<div class=\"swa-facet-constant\">
    <input id=\"any{= ?uid }\" name=\"any{= ?uid }\" type=\"hidden\" value=\"true\"/>
    <span>any value</span>
</div>
"""^^ui:Literal ;
  rdfs:comment "A facet representing any value for the given predicate, no matter which specific value." ;
  rdfs:label "Any object facet" ;
  rdfs:subClassOf swa:ObjectFacet ;
.
swa:AnyURILiteralViewer
  a swa:ObjectViewerClass ;
  swa:objectWidgetWeight [
      a swa:WeightedExpression ;
      swa:expression [
          a sp:eq ;
          sp:arg1 [
              sp:varName "type" ;
            ] ;
          sp:arg2 xsd:anyURI ;
        ] ;
      swa:weight 1 ;
    ] ;
  ui:private true ;
  ui:prototype """
<div class=\"swa-shifted-label\">
    <ui:if ui:condition=\"{= spif:isValidURI(str(?object)) }\">
        <swa:Link arg:resource=\"{= IRI(str(?object)) }\"/>
    </ui:if>
    <ui:else>{= str(?object) }</ui:else>
</div>
"""^^ui:Literal ;
  rdfs:comment "The default viewer for xsd:anyURI values: shows a hyperlink to the URI." ;
  rdfs:label "AnyURI literal viewer" ;
  rdfs:subClassOf swa:ObjectViewer ;
.
swa:ApplicationElements
  a ui:NodeClass ;
  rdfs:comment "Abstract base class of elements that depend on the event hub mechanism outside of OpenSocial containers. Defines ui:headIncludes that import the relevant JavaScript libraries to set up a local event hub." ;
  rdfs:label "Application elements" ;
  rdfs:subClassOf swa:Elements ;
.
swa:ApplicationFooter
  a ui:NodeClass ;
  ui:prototype """
<div class=\"swa-footer ui-layout-south\"/>
"""^^ui:Literal ;
  rdfs:comment "An empty placeholder that typically serves as \"south\" component in a border layout - the area is often obscured by the browser's status messages when the mouse moves over a link." ;
  rdfs:label "Application footer" ;
  rdfs:subClassOf swa:ApplicationElements ;
.
swa:Applications
  a ui:NodeClass ;
  ui:abstract true ;
  ui:responseType ui:HTML ;
  rdfs:comment "The recommended base class for stand-alone SWA applications." ;
  rdfs:label "Applications" ;
  rdfs:subClassOf swa:ApplicationElements ;
.
swa:ArgumentsFormBody
  a ui:ResourceViewClass ;
  ui:prototype """
<ui:call arg:class=\"{= swa:resourceType(?resource) }\" ui:template=\"{= swa:AllArgumentPredicates }\">
    <swa:ObjectsGroup arg:label=\"Arguments\" arg:predicates=\"{= ?rs }\" arg:subject=\"{= ?resource }\"/>
</ui:call>
"""^^ui:Literal ;
  rdfs:comment "A form body that shows all declared spl:Arguments (via spin:constraint) of the resource type. Can be used to edit SWP views, SPIN modules, SPARQLMotion functions etc." ;
  rdfs:label "Arguments form body" ;
  rdfs:subClassOf swa:FormBody ;
.
swa:AutoComplete
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:allowURIs ;
      spl:valueType xsd:boolean ;
      rdfs:comment "If set to true, users are allowed to enter arbitrary (external) URIs as long as they start with http and are well-formed URIs. Note that this bypasses any testing for type-conformance and should therefore be used with care." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:categoryFunction ;
      spl:valueType rdfs:Resource ;
      rdfs:comment """An optional SPARQL function that takes a resource and returns the name of a category. These categories are then sent to the autocomplete widget which will render the results grouped with sub-titles.

Examples of this include swa:categoryByNamespace.

If no value is present, it will also look for one specified using the context variable \"swaCategoryFunction\".""" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:class ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional CSS class that is used for the resulting text field." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:extraLabelFunction ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "An optional function that takes a resource and produces the part in parantheses." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:filterFunction ;
      spl:valueType spin:Function ;
      rdfs:comment "An optional SPARQL function that takes one resource as its argument and returns true if the resource shall be included." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:filterFunctionArgument ;
      rdfs:comment "An optional second argument to the filter function." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:filterFunctionArgument2 ;
      rdfs:comment "An optional second argument to the filter function. This is only used if arg:filterFunctionArgument also has a value." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:hiddenInputClass ;
      spl:valueType xsd:string ;
      rdfs:comment "The class to assign to the hidden input field that actually holds the value." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:initialValue ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The initial resource to place into the text field." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:menuFilterNode ;
      rdfs:comment "An optional argument that will be forwarded into the context menu, to filter some conditions." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:onSelect ;
      spl:valueType xsd:string ;
      rdfs:comment "A JavaScript snippet that shall be executed when the user selects a resource. The variable 'resource' will contain the URI of the selected value." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:placeholder ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional placeholder text to appear in empty fields until the user enters something, e.g. \"Enter first name\"." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:queryGraph ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:sendQueryGraph ;
      spl:valueType xsd:boolean ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:withSelectMenu ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to show a drop down menu at the right hand side, allowing users to open selection dialogs as an alternative way of populating the auto-complete." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:id ;
      spl:valueType xsd:string ;
      rdfs:comment "The id of the HTML input element." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:type ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The rdf:type of the matching resources. Will also include subclasses of that type." ;
    ] ;
  ui:prototype """
<ui:createLink arg:allowURIs=\"{= ?allowURIs }\" arg:categoryFunction=\"{= COALESCE(?categoryFunction, ui:contextValue(&quot;swaCategoryFunction&quot;)) }\" arg:extraLabelFunction=\"{= ?extraLabelFunction }\" arg:filterFunction=\"{= ?filterFunction }\" arg:filterFunctionArgument=\"{= ?filterFunctionArgument }\" arg:filterFunctionArgument2=\"{= ?filterFunctionArgument2 }\" arg:queryGraph=\"{= COALESCE(?queryGraph, ?nil) }\" arg:type=\"{= ?type }\" ui:sendQueryGraph=\"{= COALESCE(?sendQueryGraph, true) }\" ui:snippet=\"true\" ui:viewClass=\"{= swa:AutoCompleteCallback }\">
    <input class=\"{= ?hiddenInputClass }\" id=\"{= ?id }\" name=\"{= ?id }\" type=\"hidden\" value=\"{= ui:encodeNode(?initialValue, true, true) }\"/>
    <ui:group let:appName=\"{= swa:appName() }\" let:displayId=\"{= ?id }-field\">
        <input class=\"form-control swa-auto-complete {= ?class }\" id=\"{= ?displayId }\" placeholder=\"{= COALESCE(?placeholder, &quot;Start typing&quot;) }\" type=\"text\" value=\"{= ui:label(?initialValue) }\"/>
        <!-- <img alt=\"Dropdown Icon\" class=\"swa-auto-complete-drop-down-img\" id=\"{= ?displayId }-drop-down\" src=\"{= ui:lib() }/swa/css/images/ContextMenu.gif\"/> -->
        <ui:if ui:condition=\"{= ?withSelectMenu &amp;&amp; bound(?appName) }\">
            <a class=\"swa-auto-complete-select-menu swa-icon\" href=\"javascript:void(0)\" id=\"{= ?id }-menu\" onclick=\"{= ui:functionCall(&quot;swa.openAutoCompleteSelectMenu&quot;, ?id, ?type, ?appName, ?menuFilterNode) }\"/>
        </ui:if>
        <swa:WidgetInitializer arg:script=\"swa.initAutoComplete('{= ?displayId }', '{= ?id }', '{= ?link }', &quot;{= ui:escapeJSON(?onSelect) }&quot;)\"/>
    </ui:group>
</ui:createLink>
"""^^ui:Literal ;
  rdfs:comment "Inserts a text field that automatically suggests matching resources as the user starts typing. Matching resources must be instances of the provided type class." ;
  rdfs:label "Auto complete" ;
  rdfs:subClassOf swa:AutoCompleteElements ;
.
swa:AutoCompleteCallback
  a ui:Service ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:allowURIs ;
      spl:valueType xsd:boolean ;
      rdfs:comment "See comment at swa:AutoComplete." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:categoryFunction ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "An optional SPARQL function to produce categories." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:extraLabelFunction ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "An optional function that takes a resource and produces the part in parantheses." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:filterFunction ;
      spl:valueType spin:Function ;
      rdfs:comment "The filter function (if specified) from the AutoComplete." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:filterFunctionArgument ;
      rdfs:comment "An optional node that will be passed as second argument to the filter function." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:filterFunctionArgument2 ;
      rdfs:comment "The optional second argument of the filter function. This is only used if arg:filteFunctionArgument also has a value." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:term ;
      spl:valueType xsd:string ;
      rdfs:comment "The start of the name as entered by the user." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:type ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The type of resource to get matching instances of." ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:group>
    <ui:if ui:condition=\"{= (?allowURIs &amp;&amp; bound(?term)) &amp;&amp; spif:isValidURI(?term) }\">
        <swon:Array>
            <swon:Object>
                <swon:Value arg:name=\"editLabel\" arg:value=\"{= ?term }\"/>
                <swon:Value arg:name=\"resource\" arg:value=\"{= ?term }\"/>
                <swon:Value arg:name=\"isURI\" arg:value=\"{= true }\"/>
                <ui:if ui:condition=\"{= spl:hasValue(IRI(?term), rdf:type) }\">
                    <swon:Value arg:name=\"label\" arg:value=\"{= ?term } (typed resource: {= ui:label(IRI(?term)) })\"/>
                    <swon:Value arg:name=\"value\" arg:value=\"{= ?term } (typed resource: {= ui:label(IRI(?term)) })\"/>
                </ui:if>
                <ui:else>
                    <swon:Value arg:name=\"label\" arg:value=\"{= ?term } (untyped resource)\"/>
                    <swon:Value arg:name=\"value\" arg:value=\"{= ?term } (untyped resource)\"/>
                </ui:else>
            </swon:Object>
        </swon:Array>
    </ui:if>
    <ui:else>
        <swon:RSObjectArray arg:resultSet='{#
                SELECT DISTINCT ?resource ?label (?label AS ?value) ?editLabel ?category
                WHERE {
                    ( ?type ?term ?anyLang 20 0 ?filterFunction ?filterFunctionArgument ?filterFunctionArgument2 ) ui:autoComplete ( ?resource ?labelRaw ?editLabel ) .
                    BIND (IF(bound(?extraLabelFunction), CONCAT(?labelRaw, COALESCE(spif:invoke(?extraLabelFunction, ?resource), \"\")), ?labelRaw) AS ?label) .
                    BIND (IF(bound(?categoryFunction), spif:invoke(?categoryFunction, ?resource), ?none) AS ?category) .
                }
                ORDER BY (?category) (LCASE(?label)) }'/>
    </ui:else>
</ui:group>
"""^^ui:Literal ;
  ui:responseType ui:JSON ;
  rdfs:comment "Internally used by the AutoComplete widget to fetch the matching resources." ;
  rdfs:label "Auto complete callback" ;
  rdfs:subClassOf swa:AutoCompleteElements ;
.
swa:AutoCompleteElements
  a ui:NodeClass ;
  ui:abstract true ;
  ui:private true ;
  rdfs:comment "Abstract base class for auto-complete elements." ;
  rdfs:label "Auto complete elements" ;
  rdfs:subClassOf swa:Elements ;
.
swa:AutoCompleteSelectAction
  a rdfs:Class ;
  rdfs:comment "Class of actions that show up in the drop down menu behind an auto-complete widget." ;
  rdfs:label "Auto complete select action" ;
  rdfs:subClassOf swa:Action ;
.
swa:AutoCompleteSelectActions
  a spin:SelectTemplate ;
  spin:body [
      a sp:Select ;
      sp:orderBy (
          [
            sp:varName "group" ;
          ]
          [
            sp:varName "label" ;
          ]
        ) ;
      sp:resultVariables (
          [
            sp:varName "actionName" ;
          ]
          [
            sp:varName "actionLocalName" ;
          ]
          [
            sp:varName "onSelect" ;
          ]
          [
            sp:varName "enabled" ;
          ]
          [
            sp:varName "group" ;
          ]
          [
            sp:varName "label" ;
          ]
          [
            sp:varName "iconClass" ;
          ]
        ) ;
      sp:where (
          [
            a sp:NamedGraph ;
            sp:elements (
                (
                  [
                    sp:object swa:AutoCompleteSelectAction ;
                    sp:predicate rdf:type ;
                    sp:subject [
                        sp:varName "action" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "label" ;
                      ] ;
                    sp:predicate rdfs:label ;
                    sp:subject [
                        sp:varName "action" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "condition" ;
                      ] ;
                    sp:predicate arg:condition ;
                    sp:subject [
                        sp:varName "action" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression [
                        a ui:encodeNode ;
                        sp:arg1 [
                            sp:varName "action" ;
                          ] ;
                      ] ;
                    sp:variable [
                        sp:varName "actionName" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression [
                        a afn:localname ;
                        sp:arg1 [
                            sp:varName "action" ;
                          ] ;
                      ] ;
                    sp:variable [
                        sp:varName "actionLocalName" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression [
                        a spl:object ;
                        sp:arg1 [
                            sp:varName "action" ;
                          ] ;
                        sp:arg2 arg:onSelect ;
                      ] ;
                    sp:variable [
                        sp:varName "onSelectFunctionName" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression [
                        a sp:concat ;
                        sp:arg1 [
                            sp:varName "onSelectFunctionName" ;
                          ] ;
                        sp:arg2 "('" ;
                        sp:arg3 [
                            sp:varName "elementId" ;
                          ] ;
                        sp:arg4 "', '" ;
                        sp:arg5 [
                            a xsd:string ;
                            sp:arg1 [
                                sp:varName "type" ;
                              ] ;
                          ] ;
                        sp:arg6 "', '" ;
                        sp:arg7 [
                            a smf:qname ;
                            sp:arg1 [
                                sp:varName "type" ;
                              ] ;
                          ] ;
                        sp:arg8 "')" ;
                      ] ;
                    sp:variable [
                        sp:varName "onSelect" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression [
                        a sp:coalesce ;
                        sp:arg1 [
                            a spl:object ;
                            sp:arg1 [
                                sp:varName "action" ;
                              ] ;
                            sp:arg2 arg:group ;
                          ] ;
                        sp:arg2 "" ;
                      ] ;
                    sp:variable [
                        sp:varName "group" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression [
                        a spl:object ;
                        sp:arg1 [
                            sp:varName "action" ;
                          ] ;
                        sp:arg2 arg:iconClass ;
                      ] ;
                    sp:variable [
                        sp:varName "iconClass" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression [
                        a spl:object ;
                        sp:arg1 [
                            sp:varName "action" ;
                          ] ;
                        sp:arg2 arg:appName ;
                      ] ;
                    sp:variable [
                        sp:varName "actionAppName" ;
                      ] ;
                  ]
                  [
                    a sp:Filter ;
                    sp:expression [
                        a sp:or ;
                        sp:arg1 [
                            a sp:not ;
                            sp:arg1 [
                                a sp:bound ;
                                sp:arg1 [
                                    sp:varName "actionAppName" ;
                                  ] ;
                              ] ;
                          ] ;
                        sp:arg2 [
                            a sp:and ;
                            sp:arg1 [
                                a sp:not ;
                                sp:arg1 [
                                    a swa:hasExcludedAppName ;
                                    arg:action [
                                        sp:varName "action" ;
                                      ] ;
                                    arg:appName [
                                        sp:varName "appName" ;
                                      ] ;
                                  ] ;
                              ] ;
                            sp:arg2 [
                                a swa:hasAppName ;
                                sp:arg1 [
                                    sp:varName "appName" ;
                                  ] ;
                                sp:arg2 [
                                    sp:varName "actionAppName" ;
                                  ] ;
                              ] ;
                          ] ;
                      ] ;
                  ]
                )
                [
                  a sp:Bind ;
                  sp:expression [
                      a spin:evalInGraph ;
                      sp:arg1 [
                          sp:varName "condition" ;
                        ] ;
                      sp:arg2 [
                          a ui:currentQueryGraph ;
                        ] ;
                      sp:arg3 arg:type ;
                      sp:arg4 [
                          sp:varName "type" ;
                        ] ;
                      sp:arg5 arg:filterNode ;
                      sp:arg6 [
                          sp:varName "filterNode" ;
                        ] ;
                    ] ;
                  sp:variable [
                      sp:varName "enabled" ;
                    ] ;
                ]
                [
                  a sp:Filter ;
                  sp:expression [
                      a sp:bound ;
                      sp:arg1 [
                          sp:varName "enabled" ;
                        ] ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode ui:graph ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:appName ;
      spl:valueType xsd:string ;
      rdfs:comment "The current app name." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:filterNode ;
      rdfs:comment "An optional node that can be used by each condition." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:elementId ;
      spl:valueType xsd:string ;
      rdfs:comment "The id of the auto-complete element." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:type ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The type of resources to insert." ;
    ] ;
  spin:private true ;
  rdfs:label "Auto-complete select actions" ;
  rdfs:subClassOf spin:SelectTemplates ;
.
swa:AutoCompleteSelectMenuCallback
  a ui:JSONService ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:filterNode ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "An optional node that can be used by the conditions of each action." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:elementId ;
      spl:valueType xsd:string ;
      rdfs:comment "The id of the div holding the current widget." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:type ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The type of resources allowed" ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:call arg:appName=\"{= ui:contextValue(&quot;swaAppName&quot;) }\" arg:elementId=\"{= ?elementId }\" arg:filterNode=\"{= ?filterNode }\" arg:type=\"{= ?type }\" ui:template=\"{= swa:AutoCompleteSelectActions }\">
    <swon:RSObjectArray arg:resultSet=\"{= ?rs }\"/>
</ui:call>
"""^^ui:Literal ;
  rdfs:label "Auto-complete select menu callback" ;
  rdfs:subClassOf swa:MenuElements ;
  rdfs:subClassOf ui:JSONServices ;
.
swa:AvailableLangJSON
  a ui:Service ;
  ui:private true ;
  ui:prototype """
<swon:Object>
    <swon:Value arg:name=\"data\">
        <swon:Array>
            <ui:forEach ui:indexVar=\"index\" ui:resultSet='{#
                    SELECT DISTINCT ?lang
                    WHERE {
                        {
                            GRAPH ui:graph {
                                BIND (COALESCE(spl:object(swa:LangSelector, swa:customLanguages), spl:object(swa:LangSelector, swa:defaultLanguages)) AS ?langs) .
                            } .
                            ?lang spif:split ( ?langs \" \" ) .
                        }
                        UNION
                        {
                            BIND (xsd:string(?initialValue) AS ?lang) .
                        } .
                        FILTER (?lang != \"\") .
                    } }'>
                <swon:Object>
                    <swon:Value arg:name=\"label\" arg:value=\"{= ?lang }\"/>
                    <swon:Value arg:name=\"value\" arg:value=\"{= ?lang }\"/>
                </swon:Object>
            </ui:forEach>
        </swon:Array>
    </swon:Value>
</swon:Object>
"""^^ui:Literal ;
  rdfs:label "Available lang JSON" ;
  rdfs:subClassOf ui:JSONServices ;
.
swa:BNodeViewer
  a swa:ObjectViewerClass ;
  swa:objectWidgetWeight [
      a swa:WeightedExpression ;
      swa:expression [
          a sp:eq ;
          sp:arg1 [
              sp:varName "kind" ;
            ] ;
          sp:arg2 "blank" ;
        ] ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:group>
    <ui:if ui:condition=\"{= !smf:hasLabelsPlugin(?object) }\">
        <swa:NestedObjectViewer arg:object=\"{= ?object }\"/>
    </ui:if>
    <ui:elseif ui:condition=\"{= ?predicate = ui:instanceView }\">
        <div class=\"swa-shifted-label\">
            <pre class=\"swa-source-code-viewer\">{= ?object }</pre>
        </div>
    </ui:elseif>
    <ui:else>
        <div class=\"swa-shifted-label\">
            <ui:resourceView ui:matchIds=\"label\" ui:resource=\"{= ?object }\"/>
        </div>
    </ui:else>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "The default object viewer for blank nodes." ;
  rdfs:label "Blank node viewer" ;
  rdfs:subClassOf swa:ObjectViewer ;
.
swa:BNodeViewerEditor
  a swa:ObjectEditorClass ;
  swa:objectWidgetWeight [
      a swa:WeightedExpression ;
      swa:expression [
          a sp:isBlank ;
          sp:arg1 [
              sp:varName "object" ;
            ] ;
        ] ;
      swa:weight -10 ;
    ] ;
  ui:prototype """
<ui:setContext ui:varName=\"mode\" ui:varValue=\"view\">
    <swa:ObjectViewer ui:args=\"*\"/>
    <input name=\"new-{= ?uid }\" type=\"hidden\" value=\"{= ui:encodeNode(?object, true) }\"/>
</ui:setContext>
"""^^ui:Literal ;
  rdfs:comment "The default editor for bnodes: a read-only display. This serves as fall-back so that users can at least delete the entry." ;
  rdfs:label "Blank node viewer editor" ;
  rdfs:subClassOf swa:ObjectEditor ;
.
swa:BooleanEditor
  a swa:ObjectEditorClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:onChange ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional JavaScript function to execute upon a change to the selector." ;
    ] ;
  swa:objectWidgetWeight [
      a swa:WeightedExpression ;
      swa:expression [
          a sp:eq ;
          sp:arg1 [
              a sp:datatype ;
              sp:arg1 [
                  sp:varName "object" ;
                ] ;
            ] ;
          sp:arg2 xsd:boolean ;
        ] ;
      swa:weight 4 ;
    ] ;
  swa:objectWidgetWeight [
      a swa:WeightedExpression ;
      swa:expression [
          a sp:eq ;
          sp:arg1 [
              sp:varName "range" ;
            ] ;
          sp:arg2 xsd:boolean ;
        ] ;
      swa:weight 3 ;
    ] ;
  ui:private true ;
  ui:prototype """
<select class=\"form-control {= swa:testClass(?predicate) }\" data-inline-edit-cancel-callback=\"{= ?inlineEditCancelCallback }\" data-inline-edit-save-callback=\"{= ?inlineEditSaveCallback }\" id=\"{= ?elementId }\" name=\"new-{= ?uid }\" onchange=\"{= ?onChange }\">
    <option value=\"\"/>
    <option selected=\"{= IF((?object = false), &quot;selected&quot;, ?nothing) }\" value=\"false\">false</option>
    <option selected=\"{= IF((?object = true), &quot;selected&quot;, ?nothing) }\" value=\"true\">true</option>
</select>
"""^^ui:Literal ;
  rdfs:comment "A combo box with options empty, true, and false." ;
  rdfs:label "Boolean editor" ;
  rdfs:subClassOf swa:ObjectEditor ;
.
swa:BooleanFacet
  a swa:ObjectFacetClass ;
  swa:facetSearchType search:ObjectFacetValue ;
  swa:objectFacetMenuName "boolean" ;
  swa:objectWidgetWeight [
      a swa:WeightedExpression ;
      swa:expression [
          a sp:and ;
          sp:arg1 [
              a sp:bound ;
              sp:arg1 [
                  sp:varName "range" ;
                ] ;
            ] ;
          sp:arg2 [
              a sp:eq ;
              sp:arg1 [
                  sp:varName "range" ;
                ] ;
              sp:arg2 xsd:boolean ;
            ] ;
        ] ;
      swa:weight 5 ;
    ] ;
  ui:prototype """
<span let:name=\"value{= ?uid }\" let:restore=\"{= swa:restoreFacetValue(?predicate) }\">
    <select class=\"form-control {= swa:testClass(?predicate) }\" let:value=\"{= IF(bound(?restore), spl:object(?restore, search:object), ?none) }\" name=\"{= ?name }\">
        <option/>
        <option selected=\"{= IF((!?value), &quot;selected&quot;, ?none) }\" value=\"{= ui:encodeNode(false) }\">false</option>
        <option selected=\"{= IF(?value, &quot;selected&quot;, ?none) }\" value=\"{= ui:encodeNode(true) }\">true</option>
    </select>
</span>
"""^^ui:Literal ;
  rdfs:label "Boolean facet" ;
  rdfs:subClassOf swa:ObjectFacet ;
.
swa:BorderLayout
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:class ;
      spl:valueType xsd:string ;
      rdfs:comment "The CSS class of this element." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:id ;
      spl:valueType xsd:string ;
      rdfs:comment "The HTML id of this element." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:layoutPanel ;
      spl:valueType xsd:string ;
      rdfs:comment "The position within the surrounding BorderLayout: one of \"east\", \"north\", \"west\", \"south\" or \"center\"." ;
    ] ;
  ui:prototype """
<ui:group let:uid=\"{= COALESCE(?id, ui:uniqueId()) }\">
    <div class=\"{= ?class }{= IF(bound(?layoutPanel), CONCAT(&quot; ui-layout-&quot;, ?layoutPanel), ?none) }\" id=\"{= ?uid }\" layoutfunction=\"{= ?uid }LayoutInitHandler\" let:parent=\"#{= ?uid }\">
        <ui:insertionPoint ui:pointId=\"1\"/>
        <ui:insertionPoint ui:pointId=\"2\"/>
        <ui:insertionPoint ui:pointId=\"3\"/>
        <ui:insertionPoint ui:pointId=\"4\"/>
        <ui:insertionPoint ui:pointId=\"5\"/>
        <script>var {= ?uid }Layout;
function {= ?uid }LayoutInitHandler() {
{= ?uid }Layout = $('{= ?parent }').layout({defaults: { applyDefaultStyles: true, enableCursorHotkey: false }<swa:BorderLayoutOptions arg:fixed=\"{= ?westFixed }\" arg:name=\"west\" arg:parent=\"{= ?parent }\" arg:size=\"{= ?westSize }\" arg:storageKey=\"{= ?storageKey }\"/>
            <swa:BorderLayoutOptions arg:fixed=\"{= ?eastFixed }\" arg:name=\"east\" arg:parent=\"{= ?parent }\" arg:size=\"{= ?eastSize }\" arg:storageKey=\"{= ?storageKey }\"/>
            <swa:BorderLayoutOptions arg:name=\"center\" arg:parent=\"{= ?parent }\" arg:storageKey=\"{= ?storageKey }\"/>
            <swa:BorderLayoutOptions arg:fixed=\"{= ?northFixed }\" arg:name=\"north\" arg:parent=\"{= ?parent }\" arg:size=\"{= ?northSize }\" arg:storageKey=\"{= ?storageKey }\"/>
            <swa:BorderLayoutOptions arg:fixed=\"{= ?southFixed }\" arg:name=\"south\" arg:parent=\"{= ?parent }\" arg:size=\"{= ?southSize }\" arg:storageKey=\"{= ?storageKey }\"/>})
};
$(document).ready(function() {
  if (!!$.prototype.layout) {

{= ?uid }LayoutInitHandler();
  }
	      });</script>
    </div>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "A convenience wrapper around the jQuery UI Layout for usage inside of other containers, such as the panels of a FullScreenBorderLayout." ;
  rdfs:label "Border layout" ;
  rdfs:subClassOf swa:AbstractBorderLayout ;
.
swa:BorderLayoutOptions
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:closed ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to start off closed/minimized." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:custom ;
      spl:valueType xsd:string ;
      rdfs:comment "Can point to a JavaScript function that returns a configuration object. The function will receive one argument, which is the provided storageKey. All other values will be ignored if arg:custom is present." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:fixed ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to make this panel not resizable." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:parent ;
      spl:valueType xsd:string ;
      rdfs:comment "The jQuery expression used to retrieve the parent on which the layout is applied. Must be specified if arg:storageKey is set." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:size ;
      spl:valueType xsd:integer ;
      rdfs:comment "The size value." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:storageKey ;
      spl:valueType xsd:string ;
      rdfs:comment "The key to use if this layout shall be remembered in localStorage." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:name ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the pane, e.g. \"west\"." ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:group>
    <swon:Value arg:expression=\"false\" arg:name=\"scrollToBookmarkOnLoad\"/>
    <ui:if ui:condition=\"{= bound(?custom) }\">
        <swon:Value arg:name=\"{= ?name }\">{= ui:functionCall(?custom, ?storageKey) }</swon:Value>
    </ui:if>
    <ui:elseif ui:condition=\"{= bound(?size) || bound(?fixed) }\">
        <swon:Value arg:name=\"{= ?name }\">
            <swon:Object>
                <ui:if ui:condition=\"{= bound(?size) }\">
                    <ui:if ui:condition=\"{= bound(?storageKey) }\">
                        <swon:Value arg:expression=\"swa.getStorageNumber('{= ?storageKey }-{= ?name }', {= ?size })\" arg:name=\"size\"/>
                    </ui:if>
                    <ui:else>
                        <swon:Value arg:name=\"size\" arg:value=\"{= ?size }\"/>
                    </ui:else>
                </ui:if>
                <ui:if ui:condition=\"{= ?closed }\">
                    <swon:Value arg:expression=\"swa.getStorageValue('{= ?storageKey }-{= ?name }-open') != 'true'\" arg:name=\"initClosed\"/>
                    <swon:Value arg:name=\"spacing_closed\" arg:value=\"{= 6 }\"/>
                </ui:if>
                <ui:else>
                    <swon:Value arg:expression=\"(function(){ var isOpen = swa.getStorageValue('{= ?storageKey }-{= ?name }-open'); if(!isOpen){ return false; }  return isOpen != 'true';})()\" arg:name=\"initClosed\"/>
                </ui:else>
                <ui:if ui:condition=\"{= bound(?fixed) }\">
                    <swon:Value arg:name=\"closable\" arg:value=\"{= false }\"/>
                    <swon:Value arg:name=\"pane_spacing\" arg:value=\"{= 0 }\"/>
                    <swon:Value arg:name=\"slidable\" arg:value=\"{= false }\"/>
                    <swon:Value arg:name=\"spacing_open\" arg:value=\"{= 0 }\"/>
                    <swon:Value arg:name=\"resizable\" arg:value=\"{= false }\"/>
                </ui:if>
                <swon:Value arg:expression=\"function (paneDirection, paneElement, paneState) { swa.setStorageValue('{= ?storageKey }-{= ?name }', paneState.size); swa.resizeGrid(paneDirection, paneElement); }\" arg:name=\"onresize_end\"/>
                <ui:if ui:condition=\"{= bound(?storageKey) }\">
                    <swon:Value arg:expression=\"function(){ swa.setStorageValue('{= ?storageKey }-{= ?name }-open', true);}\" arg:name=\"onopen_end\"/>
                    <swon:Value arg:expression=\"function(){ swa.setStorageValue('{= ?storageKey }-{= ?name }-open', false);}\" arg:name=\"onclose_end\"/>
                </ui:if>
            </swon:Object>
        </swon:Value>
    </ui:elseif>
    <ui:else>
        <swon:Value arg:name=\"{= ?name }\">
            <swon:Object>
                <swon:Value arg:expression=\"function (paneDirection, paneElement, paneState) { swa.setStorageValue('{= ?storageKey }-{= ?name }', paneState.size); swa.resizeGrid(paneDirection, paneElement); }\" arg:name=\"onresize_end\"/>
            </swon:Object>
        </swon:Value>
    </ui:else>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "A helper to BorderLayout to conveniently set JavaScript options." ;
  rdfs:label "Border layout options" ;
  rdfs:subClassOf swa:LayoutElements ;
.
swa:BrowserCheck
  a ui:NodeClass ;
  ui:headIncludes """
<ui:group>
    <meta name=\"test\" value=\"swa:BrowserCheck:HeadIncludes\"/>
</ui:group>
"""^^ui:Literal ;
  ui:prototype """
<ui:group>
    <script>$(document).ready(function() {
  var browserCompatibility = $.cookie('browserCompatibility');
  if (browserCompatibility == null || browserCompatibility == 'check') {
if (!swa.isBrowserCompatible()) {
  swa.populateModalDialog(swa.browserCompatibilityMessage);
}
$.cookie('browserCompatibility','checked');
  }
})</script>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "Should be placed into the beginning of an SWA application's main element, i.e. the start of the body. Will check that a browser is one of the supported versions." ;
  rdfs:label "Browser check" ;
  rdfs:subClassOf swa:ScriptElements ;
.
swa:Bundle
  a ui:Script ;
  ui:dependsOn swa:VendorScripts ;
  ui:prototype """
<ui:group>
    <meta content=\"swa:Bundle\" name=\"swa-bundle-start\"/>
    <script src=\"{= ui:lib() }/assets/build/runtime.bundle.js\"/>
    <script src=\"{= ui:lib() }/assets/build/vendors.bundle.js\"/>
    <script src=\"{= ui:lib() }/assets/build/topbraid.bundle.js\"/>
    <meta content=\"swa:Bundle\" name=\"swa-bundle-end\"/>
</ui:group>
"""^^ui:Literal ;
  rdfs:label "Bundle" ;
  rdfs:subClassOf ui:Scripts ;
.
swa:Button
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:class ;
      spl:valueType xsd:string ;
      rdfs:comment "An extra CSS class for the button. If this contains Bootstrap's \"btn\", the SWA styling will be suppressed." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:dataAttrValue ;
      spl:valueType xsd:string ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:disabled ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to disable the button." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:iconClass ;
      spl:valueType xsd:string ;
      rdfs:comment "The CSS class of the icon to display on the button (if any)." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:id ;
      spl:valueType xsd:string ;
      rdfs:comment "The HTML id of the button." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:label ;
      spl:valueType xsd:string ;
      rdfs:comment "The text on the button. Optional if an icon is set." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:overlayImage ;
      spl:valueType xsd:string ;
      rdfs:comment "The path to an overlay icon." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:style ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional CSS style for the button." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:toolTip ;
      spl:valueType xsd:string ;
      rdfs:comment "A tool tip text to appear over the button." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:onClick ;
      spl:valueType xsd:string ;
      rdfs:comment "The JavaScript code that shall be executed when clicked on." ;
    ] ;
  ui:prototype """
<button class=\"{= IF((bound(?class) &amp;&amp; CONTAINS(?class, &quot;btn&quot;)), &quot;&quot;, &quot;swa-button &quot;) }{= ?class }\" data-uri=\"{= ?dataAttrValue }\" disabled=\"{= IF(?disabled, &quot;disabled&quot;, ?none) }\" id=\"{= ?id }\" onclick=\"{= ?onClick }\" title=\"{= ?toolTip }\" type=\"button\">
    <ui:if ui:condition=\"{= bound(?iconClass) }\">
        <div class=\"swa-icon swa-button-icon {= ?iconClass }\">
            <ui:if ui:condition=\"{= bound(?overlayImage) }\">
                <img alt=\"\" src=\"{= ?overlayImage }\"/>
            </ui:if>
        </div>
        <ui:if ui:condition=\"{= bound(?label) }\">
            <span class=\"swa-button-bound-label\">{= ?label }</span>
        </ui:if>
        <ui:else>
            <span class=\"swa-button-unbound-label\">&nbsp;</span>
        </ui:else>
    </ui:if>
    <ui:else>{= ?label }</ui:else>
</button>
"""^^ui:Literal ;
  rdfs:comment "A Button with a label and an optional icon, calling some JS when clicked. It is recommended to use this for buttons in SWA applications to ensure unified look and feel." ;
  rdfs:label "Button" ;
  rdfs:subClassOf swa:ButtonElements ;
.
swa:ButtonElements
  a ui:NodeClass ;
  ui:abstract true ;
  rdfs:comment "Abstract base class of elements related to buttons." ;
  rdfs:label "Button elements" ;
  rdfs:subClassOf swa:Elements ;
.
swa:CanBatchEditResourcesService
  a swa:DeleteResourcesService ;
  ui:prototype """
<ui:group letrs:edits='{#
        SELECT ?resource
        WHERE {
            ?str spif:split ( ?resources \" \" ) .
            BIND (ui:decodeNode(CONCAT(\"&lt;\", ?str, \"&gt;\")) AS ?resource) .
            FILTER swa:canDeleteResource(?resource) .
        } }'>
    <swon:Array>
        <ui:if ui:condition=\"{= spr:rowCount(?edits) &gt; 0 }\">
            <ui:forEach ui:resultSet=\"{= ?edits }\">
                <swon:Object>
                    <swon:Value arg:name=\"URI\" arg:value=\"{= ?resource }\"/>
                </swon:Object>
            </ui:forEach>
        </ui:if>
    </swon:Array>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "Verifies that all resources from a given list can be edited." ;
  rdfs:label "Can batch edit resources service" ;
  rdfs:subClassOf swa:DeleteResourcesServices ;
.
swa:CanDeleteResourcesService
  a swa:DeleteResourcesService ;
  ui:prototype """
<swon:Object let:count='{#
        SELECT (COUNT(?resource) AS ?count)
        WHERE {
            ?str spif:split ( ?resources \" \" ) .
            BIND (ui:decodeNode(CONCAT(\"&lt;\", ?str, \"&gt;\")) AS ?resource) .
            FILTER (!swa:canDeleteResource(?resource)) .
        } }'>
    <ui:if ui:condition=\"{= ?count &gt; 0 }\">
        <swon:Value arg:name=\"error\" arg:value=\"{= ?count } of the selected rows are read-only.\"/>
    </ui:if>
    <ui:else>
        <ui:forEach ui:resultSet='{#
                SELECT ?resource
                WHERE {
                    ?str spif:split ( ?resources \" \" ) .
                    BIND (ui:decodeNode(CONCAT(\"&lt;\", ?str, \"&gt;\")) AS ?resource) .
                } }'>
            <swa:ResourceDestructor arg:resource=\"{= ?resource }\"/>
        </ui:forEach>
        <swon:Value arg:name=\"tripleCount\" arg:value=\"{#
                SELECT (COUNT(?s) AS ?tripleCount)
                WHERE {
                    GRAPH ui:tempGraph {
                        ?s ?p ?o .
                        FILTER (?s != swa:DestructorMetadata) .
                    } .
                } }\"/>
        <swon:Value arg:name=\"message\" arg:value=\"Are you sure you want to delete the selected row(s)?\"/>
        <div/>
    </ui:else>
</swon:Object>
"""^^ui:Literal ;
  rdfs:comment "Verifies that all resources from a given list can be deleted." ;
  rdfs:label "Can delete resources service" ;
  rdfs:subClassOf swa:DeleteResourcesServices ;
.
swa:CanLinkBNodeFunctions
  a spin:Function ;
  spin:abstract true ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:node ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The blank node to check." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Abstract superclass for functions that take a blank node and can determine whether this bnode can become the selected resource. To use this mechanism, set a context variable \"canLinkBNodeFunction\" to point at your subclass of this class here. Will be used to determine whether swa:Links will produce a clickable hyperlink." ;
  rdfs:label "Can link blank node functions" ;
  rdfs:subClassOf swa:Functions ;
.
swa:CancelProgressCallback
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:id ;
      spl:valueType xsd:string ;
      rdfs:comment "The id of the progress cancel." ;
    ] ;
  ui:prototype """
<ui:group>{= ui:cancelProgress(?id) }</ui:group>
"""^^ui:Literal ;
  rdfs:label "Cancel progress callback" ;
  rdfs:subClassOf ui:JSONServices ;
.
swa:CardinalityFacet
  a swa:ObjectFacetClass ;
  swa:facetSearchType search:CardinalityFacetValue ;
  swa:objectFacetMenuName "min/max number of values" ;
  swa:objectWidgetWeight [
      a swa:WeightedExpression ;
      swa:expression true ;
      swa:weight -5 ;
    ] ;
  ui:private true ;
  ui:prototype """
<span let:restore=\"{= swa:restoreFacetValue(?predicate) }\">
    <input class=\"{= swa:testClass(?predicate) }-min form-control\" name=\"cmin{= ?uid }\" size=\"4\" type=\"text\" value=\"{= IF(bound(?restore), spl:object(?restore, search:minCardinality), ?none) }\"/>
    <span> - </span>
    <input class=\"{= swa:testClass(?predicate) }-max form-control\" name=\"cmax{= ?uid }\" size=\"4\" type=\"text\" value=\"{= IF(bound(?restore), spl:object(?restore, search:maxCardinality), ?none) }\"/>
    <span> values</span>
</span>
"""^^ui:Literal ;
  rdfs:comment "A facet with two input fields for min and max cardinality of a property." ;
  rdfs:label "Cardinality facet" ;
  rdfs:subClassOf swa:ObjectFacet ;
.
swa:CardinalitySubjectFacet
  a swa:SubjectFacetClass ;
  swa:facetSearchType search:CardinalityFacetValue ;
  swa:subjectFacetMenuName "min/max number of values" ;
  swa:subjectWidgetWeight [
      a swa:WeightedExpression ;
      swa:expression [
          a swa:hasMatchingInverseRestoreFacetValue ;
          arg:facetClass swa:CardinalitySubjectFacet ;
          arg:property [
              sp:varName "predicate" ;
            ] ;
        ] ;
      swa:weight -2 ;
    ] ;
  ui:prototype """
<span let:restore=\"{= swa:restoreInverseFacetValue(?predicate) }\">
    <input class=\"form-control {= swa:testClass(?predicate) }-cmin\" name=\"cmin{= ?uid }\" size=\"4\" type=\"text\" value=\"{= IF(bound(?restore), spl:object(?restore, search:minCardinality), ?none) }\"/>
    <span> - </span>
    <input class=\"form-control {= swa:testClass(?predicate) }-cmax\" name=\"cmax{= ?uid }\" size=\"4\" type=\"text\" value=\"{= IF(bound(?restore), spl:object(?restore, search:maxCardinality), ?none) }\"/>
    <span> values</span>
</span>
"""^^ui:Literal ;
  rdfs:label "Cardinality subject facet" ;
  rdfs:subClassOf swa:SubjectFacet ;
.
swa:CheckBoxList
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:rs ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resultset populating the list. Must have a column ?node and a column ?value (true or false)." ;
    ] ;
  rdfs:comment "Displays a list of checkboxes populated by a given result set (e.g. coming from a SPIN template call). If editable, then each click to check or uncheck an item issues a server request to make the corresponding change to the underlying data." ;
  rdfs:label "Check box list" ;
  rdfs:subClassOf swa:ListElements ;
.
swa:CheckSPARQLPathService
  a ui:Service ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:path ;
      spl:valueType xsd:string ;
      rdfs:comment "The path string." ;
    ] ;
  ui:private true ;
  ui:prototype """
<swon:Object>
    <swon:Value arg:name=\"error\" arg:value=\"{= swa:checkPathSyntax(?path) }\"/>
</swon:Object>
"""^^ui:Literal ;
  rdfs:comment """Checks whether a given string is a valid SPARQL and SHACL path expression using the prefixes from the current query graph (_base).

Note that SPARQL syntax includes NegatedPropertySets which are not supported by SHACL, so these produce an error here.""" ;
  rdfs:subClassOf ui:JSONServices ;
.
swa:CheckSourceCodeService
  a ui:Service ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate being edited." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:subject ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject node." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:text ;
      spl:valueType xsd:string ;
      rdfs:comment "The text to validate, as entered by the user." ;
    ] ;
  ui:prototype """
<swon:Object>
    <swon:Value arg:name=\"error\" arg:value=\"{= swa:getEditorTextError(?subject, ?predicate, ?text) }\"/>
</swon:Object>
"""^^ui:Literal ;
  rdfs:comment "Used as a callback by swa:SourceCodeEditor to validate user input whenever there is a breather." ;
  rdfs:label "Check source code service" ;
  rdfs:subClassOf ui:JSONServices ;
.
swa:ClassDestructor
  a swa:Destructor ;
  ui:private true ;
  ui:prototype """
<ui:group>
    <!-- Mark all subclasses to be deletable -->
    <ui:update ui:updateQuery=\"{!
            INSERT {
                GRAPH ui:tempGraph {
                    swa:DestructorMetadata swa:delete ?child .
                } .
            }
            WHERE {
                ?child (rdfs:subClassOf)* ?resource .
            } }\"/>
    <!-- Mark all superclasses to be not deletable -->
    <ui:update ui:updateQuery=\"{!
            INSERT {
                GRAPH ui:tempGraph {
                    swa:DestructorMetadata swa:keep ?parent .
                } .
            }
            WHERE {
                ?resource (rdfs:subClassOf)+ ?parent .
            } }\"/>
    <!-- Unmark all deletable classes that have a surviving parent -->
    <ui:update ui:updateQuery=\"{!
            DELETE {
                GRAPH ui:tempGraph {
                    swa:DestructorMetadata swa:delete ?child .
                } .
            }
            WHERE {
                ?child (rdfs:subClassOf)+ ?resource .
                ?child (rdfs:subClassOf)+ ?other .
                FILTER NOT EXISTS {
                    GRAPH ui:tempGraph {
                        swa:DestructorMetadata ?either ?other .
                    } .
                } .
            } }\"/>
    <!-- Delete all instances of deletable classes unless they have other types -->
    <ui:forEach ui:resultSet=\"{#
            SELECT ?instance
            WHERE {
                GRAPH ui:tempGraph {
                    swa:DestructorMetadata swa:delete ?class .
                } .
                ?instance a ?class .
                FILTER NOT EXISTS {
                    ?instance a ?otherType .
                    FILTER NOT EXISTS {
                        GRAPH ui:tempGraph {
                            swa:DestructorMetadata swa:delete ?otherType .
                        } .
                    } .
                } .
            } }\">
        <swa:ResourceDestructor arg:resource=\"{= ?instance }\"/>
    </ui:forEach>
    <!-- Delete subject triples -->
    <ui:update ui:updateQuery=\"{!
            INSERT {
                GRAPH ui:tempGraph {
                    ?s ?p ?o .
                } .
            }
            WHERE {
                GRAPH ui:tempGraph {
                    swa:DestructorMetadata swa:delete ?c .
                } .
                ( ?s ?p ?o ) tops:dependsOn ?c .
            } }\"/>
    <!-- Delete depending properties -->
    <ui:forEach ui:resultSet=\"{#
            SELECT ?property
            WHERE {
                GRAPH ui:tempGraph {
                    swa:DestructorMetadata swa:delete ?class .
                } .
                ?property rdfs:domain ?class .
            } }\">
        <swa:ResourceDestructor arg:resource=\"{= ?property }\"/>
    </ui:forEach>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "Deletes all triples related to the class itself, its subclasses that do not have any other surviving parents, and all instances of those classes." ;
  rdfs:label "Class destructor" ;
  rdfs:subClassOf swa:Destructors ;
.
swa:ClassFormBody
  a ui:ResourceViewClass ;
  ui:private true ;
  ui:prototype """
<ui:group default:subject=\"{= ?resource }\">
    <ui:call arg:subject=\"{= ?resource }\" ui:template=\"{= swa:modeProperty(swa:formObjectPredicateSelectionTemplate) }\">
        <swa:ObjectsGroup arg:filterFunction=\"{= swa:isAnnotationProperty }\" arg:label=\"Annotations\" arg:predicates=\"{= ?rs }\"/>
        <swa:ObjectsGroup arg:filterFunction=\"{= swa:isClassAxiomProperty }\" arg:label=\"Class Axioms\" arg:predicates=\"{= ?rs }\"/>
        <swa:ObjectsGroup arg:filterFunction=\"{= swa:isNonClassAxiomProperty }\" arg:label=\"Properties\" arg:predicates=\"{= ?rs }\"/>
    </ui:call>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "The default view for rdfs:Class, with widget groups for Annotation Properties, Class Axioms and Other Properties." ;
  rdfs:label "Class form body" ;
  rdfs:subClassOf swa:FormBody ;
.
swa:ClassPropertyTreeChildren
  a spin:SelectTemplate ;
  spin:body [
      a sp:Select ;
      sp:orderBy (
          [
            sp:varName "nodeType" ;
          ]
          [
            sp:varName "label" ;
          ]
        ) ;
      sp:resultVariables (
          [
            sp:varName "node" ;
          ]
          [
            sp:varName "label" ;
          ]
          [
            sp:varName "leaf" ;
          ]
          [
            sp:varName "icon" ;
          ]
          [
            sp:varName "movable" ;
          ]
          [
            sp:varName "metadata" ;
          ]
        ) ;
      sp:where (
          [
            a sp:SubQuery ;
            sp:query [
                a sp:Select ;
                sp:limit "5000"^^xsd:long ;
                sp:where (
                    [
                      a sp:Union ;
                      sp:elements (
                          (
                            [
                              sp:object [
                                  sp:varName "node" ;
                                ] ;
                              sp:predicate swa:superClassOfLimited ;
                              sp:subject [
                                  sp:varName "parent" ;
                                ] ;
                            ]
                            [
                              a sp:Filter ;
                              sp:expression [
                                  a sp:and ;
                                  sp:arg1 [
                                      a sp:and ;
                                      sp:arg1 [
                                          a sp:isIRI ;
                                          sp:arg1 [
                                              sp:varName "node" ;
                                            ] ;
                                        ] ;
                                      sp:arg2 [
                                          a sp:ne ;
                                          sp:arg1 [
                                              sp:varName "node" ;
                                            ] ;
                                          sp:arg2 owl:Nothing ;
                                        ] ;
                                    ] ;
                                  sp:arg2 [
                                      a sp:ne ;
                                      sp:arg1 [
                                          sp:varName "node" ;
                                        ] ;
                                      sp:arg2 owl:NamedIndividual ;
                                    ] ;
                                ] ;
                            ]
                            [
                              a sp:Bind ;
                              sp:expression [
                                  a sp:not ;
                                  sp:arg1 [
                                      a swa:classHasSubClassOrDirectRelevantProperty ;
                                      arg:class [
                                          sp:varName "node" ;
                                        ] ;
                                    ] ;
                                ] ;
                              sp:variable [
                                  sp:varName "leaf" ;
                                ] ;
                            ]
                            [
                              a sp:Bind ;
                              sp:expression [
                                  a sp:if ;
                                  sp:arg1 [
                                      a swa:isImportedResource ;
                                      arg:resource [
                                          sp:varName "node" ;
                                        ] ;
                                    ] ;
                                  sp:arg2 "swa-icon-class-imported" ;
                                  sp:arg3 "swa-icon-class" ;
                                ] ;
                              sp:variable [
                                  sp:varName "icon" ;
                                ] ;
                            ]
                            [
                              a sp:Bind ;
                              sp:expression "class" ;
                              sp:variable [
                                  sp:varName "nodeType" ;
                                ] ;
                            ]
                            [
                              a sp:Bind ;
                              sp:expression [
                                  a sp:not ;
                                  sp:arg1 [
                                      a swa:isReadOnlyTriple ;
                                      sp:arg1 [
                                          sp:varName "node" ;
                                        ] ;
                                      sp:arg2 rdfs:subClassOf ;
                                      sp:arg3 [
                                          sp:varName "parent" ;
                                        ] ;
                                    ] ;
                                ] ;
                              sp:variable [
                                  sp:varName "movable" ;
                                ] ;
                            ]
                            [
                              a sp:Bind ;
                              sp:expression "Class" ;
                              sp:variable [
                                  sp:varName "metadata" ;
                                ] ;
                            ]
                          )
                          (
                            [
                              sp:object [
                                  sp:varName "node" ;
                                ] ;
                              sp:predicate swa:directRelevantClassOfProperty ;
                              sp:subject [
                                  sp:varName "parent" ;
                                ] ;
                            ]
                            [
                              a sp:Filter ;
                              sp:expression [
                                  a sp:and ;
                                  sp:arg1 [
                                      a sp:and ;
                                      sp:arg1 [
                                          a sp:and ;
                                          sp:arg1 [
                                              a sp:and ;
                                              sp:arg1 [
                                                  a sp:and ;
                                                  sp:arg1 [
                                                      a sp:and ;
                                                      sp:arg1 [
                                                          a sp:isIRI ;
                                                          sp:arg1 [
                                                              sp:varName "node" ;
                                                            ] ;
                                                        ] ;
                                                      sp:arg2 [
                                                          a sp:ne ;
                                                          sp:arg1 [
                                                              sp:varName "node" ;
                                                            ] ;
                                                          sp:arg2 owl:bottomDataProperty ;
                                                        ] ;
                                                    ] ;
                                                  sp:arg2 [
                                                      a sp:ne ;
                                                      sp:arg1 [
                                                          sp:varName "node" ;
                                                        ] ;
                                                      sp:arg2 owl:bottomObjectProperty ;
                                                    ] ;
                                                ] ;
                                              sp:arg2 [
                                                  a sp:ne ;
                                                  sp:arg1 [
                                                      sp:varName "node" ;
                                                    ] ;
                                                  sp:arg2 owl:differentFrom ;
                                                ] ;
                                            ] ;
                                          sp:arg2 [
                                              a sp:ne ;
                                              sp:arg1 [
                                                  sp:varName "node" ;
                                                ] ;
                                              sp:arg2 owl:sameAs ;
                                            ] ;
                                        ] ;
                                      sp:arg2 [
                                          a sp:ne ;
                                          sp:arg1 [
                                              sp:varName "node" ;
                                            ] ;
                                          sp:arg2 owl:topDataProperty ;
                                        ] ;
                                    ] ;
                                  sp:arg2 [
                                      a sp:ne ;
                                      sp:arg1 [
                                          sp:varName "node" ;
                                        ] ;
                                      sp:arg2 owl:topObjectProperty ;
                                    ] ;
                                ] ;
                            ]
                            [
                              a sp:Bind ;
                              sp:expression true ;
                              sp:variable [
                                  sp:varName "leaf" ;
                                ] ;
                            ]
                            [
                              a sp:Bind ;
                              sp:expression [
                                  a sp:coalesce ;
                                  sp:arg1 [
                                      a swa:resourceIcon ;
                                      arg:resource [
                                          sp:varName "node" ;
                                        ] ;
                                    ] ;
                                  sp:arg2 "swa-icon-property" ;
                                ] ;
                              sp:variable [
                                  sp:varName "baseIcon" ;
                                ] ;
                            ]
                            [
                              a sp:Bind ;
                              sp:expression [
                                  a swa:primaryKeyProperty ;
                                  arg:class [
                                      sp:varName "parent" ;
                                    ] ;
                                ] ;
                              sp:variable [
                                  sp:varName "pk" ;
                                ] ;
                            ]
                            [
                              a sp:Bind ;
                              sp:expression [
                                  a sp:if ;
                                  sp:arg1 [
                                      a sp:and ;
                                      sp:arg1 [
                                          a sp:bound ;
                                          sp:arg1 [
                                              sp:varName "pk" ;
                                            ] ;
                                        ] ;
                                      sp:arg2 [
                                          a sp:eq ;
                                          sp:arg1 [
                                              sp:varName "pk" ;
                                            ] ;
                                          sp:arg2 [
                                              sp:varName "node" ;
                                            ] ;
                                        ] ;
                                    ] ;
                                  sp:arg2 "swa-icon-primary-key-property" ;
                                  sp:arg3 [
                                      sp:varName "baseIcon" ;
                                    ] ;
                                ] ;
                              sp:variable [
                                  sp:varName "baseIcon2" ;
                                ] ;
                            ]
                            [
                              a sp:Bind ;
                              sp:expression [
                                  a sp:if ;
                                  sp:arg1 [
                                      a swa:isImportedResource ;
                                      arg:resource [
                                          sp:varName "node" ;
                                        ] ;
                                    ] ;
                                  sp:arg2 [
                                      a sp:concat ;
                                      sp:arg1 [
                                          sp:varName "baseIcon2" ;
                                        ] ;
                                      sp:arg2 "-imported" ;
                                    ] ;
                                  sp:arg3 [
                                      sp:varName "baseIcon2" ;
                                    ] ;
                                ] ;
                              sp:variable [
                                  sp:varName "icon" ;
                                ] ;
                            ]
                            [
                              a sp:Bind ;
                              sp:expression "property" ;
                              sp:variable [
                                  sp:varName "nodeType" ;
                                ] ;
                            ]
                            [
                              a sp:Bind ;
                              sp:expression [
                                  a sp:and ;
                                  sp:arg1 [
                                      a sp:exists ;
                                      sp:elements (
                                          [
                                            sp:object [
                                                sp:varName "parent" ;
                                              ] ;
                                            sp:predicate rdfs:domain ;
                                            sp:subject [
                                                sp:varName "node" ;
                                              ] ;
                                          ]
                                        ) ;
                                    ] ;
                                  sp:arg2 [
                                      a sp:not ;
                                      sp:arg1 [
                                          a swa:isReadOnlyTriple ;
                                          sp:arg1 [
                                              sp:varName "node" ;
                                            ] ;
                                          sp:arg2 rdfs:domain ;
                                          sp:arg3 [
                                              sp:varName "parent" ;
                                            ] ;
                                        ] ;
                                    ] ;
                                ] ;
                              sp:variable [
                                  sp:varName "movable" ;
                                ] ;
                            ]
                            [
                              a sp:Bind ;
                              sp:expression "Property" ;
                              sp:variable [
                                  sp:varName "metadata" ;
                                ] ;
                            ]
                            [
                              a sp:Bind ;
                              sp:expression [
                                  a swa:propertyLabelAtClassOrShape ;
                                  arg:property [
                                      sp:varName "node" ;
                                    ] ;
                                  arg:theClassOrShape [
                                      sp:varName "parent" ;
                                    ] ;
                                ] ;
                              sp:variable [
                                  sp:varName "labelOverride" ;
                                ] ;
                            ]
                          )
                        ) ;
                    ]
                    [
                      a sp:Filter ;
                      sp:expression [
                          a sp:or ;
                          sp:arg1 [
                              a sp:not ;
                              sp:arg1 [
                                  a sp:bound ;
                                  sp:arg1 [
                                      sp:varName "filterFunction" ;
                                    ] ;
                                ] ;
                            ] ;
                          sp:arg2 [
                              a spif:invoke ;
                              sp:arg1 [
                                  sp:varName "filterFunction" ;
                                ] ;
                              sp:arg2 [
                                  sp:varName "node" ;
                                ] ;
                            ] ;
                        ] ;
                    ]
                  ) ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:coalesce ;
                sp:arg1 [
                    sp:varName "labelOverride" ;
                  ] ;
                sp:arg2 [
                    a ui:label ;
                    sp:arg1 [
                        sp:varName "node" ;
                      ] ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "label" ;
              ] ;
          ]
        ) ;
    ] ;
  rdfs:comment "A template that delivers all (named) subclasses of a given parent class, using rdfs:subClassOf, all properties that are directly associated with the class via rdfs:domain and all property constraints associated with those properties." ;
  rdfs:label "Class-Property tree children" ;
  rdfs:subClassOf swa:TreeChildrenTemplates ;
.
swa:ClassPropertyTreeDataProvider
  a swa:TreeDataProvider ;
  arg:changeHandler "swa.handleChangeForClassPropertyTree" ;
  arg:treeChildrenTemplate swa:ClassPropertyTreeChildren ;
  arg:treePathTemplate swa:ClassPropertyTreePath ;
  arg:treeRootsTemplate swa:ClassPropertyTreeRoots ;
  rdfs:comment "A data provider for a class tree that also shows properties associated with each class, and the SHACL property constraints using those properties." ;
  rdfs:label "Class-Property tree data provider" ;
.
swa:ClassPropertyTreeGadget
  a swa:Gadget ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:editable ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to have buttons to create classes and properties appear under the tree." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:filterFunction ;
      spl:valueType spin:Function ;
      rdfs:comment "A filter function for the nodes in the tree (see swa:Tree)." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:showNodeShapesButton ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to add a button to issue an event to select sh:NodeShape." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:classSelectedEvent ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the event to publish when the selected class has changed." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:rootClass ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The root class of the tree." ;
    ] ;
  ui:prototype """
<ui:group let:dataProvider=\"{= swa:ClassPropertyTreeDataProvider }\" let:treeId=\"{= COALESCE(?treeId, ui:uniqueId()) }\">
    <div class=\"swa-gadget-toolbar\">
        <swa:AutoComplete arg:filterFunction=\"{= swa:filterSubclassesOfRoot }\" arg:filterFunctionArgument=\"{= ?rootClass }\" arg:id=\"classTreeAutoComplete\" arg:onSelect=\"gadgets.Hub.publish('{= ?resourceSelectedEvent }', resource);\" arg:placeholder=\"{= swa:autoCompleteSearchPlaceholder(&quot;Class&quot;) }\" arg:type=\"{= rdfs:Class }\"/>
        <swa:Space/>
        <button class=\"btn btn-default btn-xs swa-button swa-class-property-tree-gadget-button\" onclick=\"swa.loadModalDialog('swa:FindClassOrPropertyByTextDialog', '{= ?treeId }-findDialog', {filterFunction: '{= ?filterFunction }', loadId: '{= ?treeId }-findDialog', resourceSelectedEvent: '{= ?resourceSelectedEvent }', rootClass: '{= ?rootClass }', treeId: '{= ?treeId }'}, 600, 500)\" title=\"Find class or property by text...\">...</button>
        <ui:if ui:condition=\"{= ?editable }\">
            <div class=\"swa-float-right\">
                <swa:CreateResourceButton arg:classSelectedEvent=\"{= ?classSelectedEvent }\" arg:contextResourceGetter=\"swa.getSelectedTreeClassOrError('{= ?treeId }', 'Error: Please select a parent class first.')\" arg:createHandler=\"{= swa:CreateClassHandler }\" arg:iconClass=\"swa-icon-class\" arg:resourceSelectedEvent=\"{= ?resourceSelectedEvent }\" arg:resourceType=\"{= owl:Class }\" arg:suppressTypeSelection=\"{= true }\"/>
                <swa:CreateResourceButton arg:contextResourceGetter=\"swa.getSelectedTreeClassOrError('{= ?treeId }', 'Error: Please select a parent class first.')\" arg:createHandler=\"{= swa:CreatePropertyHandler }\" arg:iconClass=\"swa-icon-datatype-property\" arg:resourceSelectedEvent=\"{= ?resourceSelectedEvent }\" arg:resourceType=\"{= owl:DatatypeProperty }\" arg:resourceTypeLabel=\"Attribute (Datatype Property)\" arg:suppressTypeSelection=\"{= true }\"/>
                <swa:CreateResourceButton arg:contextResourceGetter=\"swa.getSelectedTreeClassOrError('{= ?treeId }', 'Error: Please select a parent class first.')\" arg:createHandler=\"{= swa:CreatePropertyHandler }\" arg:iconClass=\"swa-icon-object-property\" arg:resourceSelectedEvent=\"{= ?resourceSelectedEvent }\" arg:resourceType=\"{= owl:ObjectProperty }\" arg:resourceTypeLabel=\"Relationship (Object Property)\" arg:suppressTypeSelection=\"{= true }\"/>
                <ui:if ui:condition=\"{= EXISTS {
                    sh:PropertyShape a ?any .
                } }\">
                    <swa:CreatePropertyConstraintButton arg:resourceSelectedEvent=\"{= ?resourceSelectedEvent }\" arg:treeId=\"{= ?treeId }\"/>
                    <ui:if ui:condition=\"{= ?showNodeShapesButton }\">
                        <swa:Space/>
                        <swa:Button arg:class=\"btn btn-default btn-xs\" arg:iconClass=\"swa-icon-shape\" arg:onClick=\"{= swa:publishEvent(?classSelectedEvent, CONCAT(&quot;\\&quot;&quot;, str(sh:NodeShape), &quot;\\&quot;&quot;)) }\" arg:toolTip=\"View Node Shapes\"/>
                    </ui:if>
                </ui:if>
                <ui:insertionPoint ui:pointId=\"buttons\"/>
            </div>
            <div class=\"swa-class-property-tree-gadget-button-clear-div\"/>
        </ui:if>
    </div>
    <div class=\"ui-layout-content\">
        <swa:Tree arg:checkDropFunction=\"swa.isClassPropertyTreeManipulationAllowed\" arg:dataProvider=\"{= ?dataProvider }\" arg:draggable=\"{= ?editable }\" arg:filterFunction=\"{= ?filterFunction }\" arg:id=\"{= ?treeId }\" arg:onSelect=\"if(swa.treeResourceIsClass(resource, '{= ?treeId }')) { {= swa:publishEvent(?classSelectedEvent, &quot;resource&quot;) } }{= swa:publishEvent(?resourceSelectedEvent, &quot;resource&quot;) }\" arg:root=\"{= ?rootClass }\" arg:treeMoveHandler=\"{= IF(?editable, swa:ClassPropertyTreeMoveHandler, ?none) }\"/>
    </div>
    <swa:Subscribe arg:code=\"{= spl:objectInGraph(?dataProvider, arg:changeHandler, ui:graph) }(data, '{= ?treeId }')\" arg:event=\"org.topbraid.swa.change\"/>
    <swa:Subscribe arg:code=\"swa.selectTreeNode('{= ?treeId }', data)\" arg:event=\"{= ?resourceSelectedEvent }\"/>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "A gadget displaying a mixed class/property tree. The tree can publish events whenever the user selects a class or property." ;
  rdfs:label "Class/property tree gadget" ;
  rdfs:subClassOf swa:TreeGadgets ;
.
swa:ClassPropertyTreeMoveHandler
  a swa:TreeMoveHandlerClass ;
  ui:prototype """
<ui:transaction ui:logMessage=\"Move {= ui:label(?child) } under {= ui:label(?parent) }\">
    <ui:if ui:condition=\"{= EXISTS {
        ?child rdfs:domain ?any .
    } }\">
        <ui:update ui:updateQuery=\"{!
                DELETE {
                    ?child rdfs:domain ?domain .
                }
                INSERT {
                    ?child rdfs:domain ?parent .
                }
                WHERE {
                    ?child rdfs:domain ?domain .
                } }\"/>
    </ui:if>
    <ui:else>
        <ui:update ui:updateQuery=\"{!
                DELETE {
                    ?child rdfs:subClassOf ?superClass .
                }
                INSERT {
                    ?child rdfs:subClassOf ?parent .
                }
                WHERE {
                    ?child rdfs:subClassOf ?superClass .
                } }\"/>
    </ui:else>
</ui:transaction>
"""^^ui:Literal ;
  rdfs:label "Class property tree move handler" ;
  rdfs:subClassOf swa:TreeMoveHandlers ;
.
swa:ClassPropertyTreePath
  a spin:SelectTemplate ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "path" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a sp:if ;
                sp:arg1 [
                    a spl:instanceOf ;
                    sp:arg1 [
                        sp:varName "node" ;
                      ] ;
                    sp:arg2 rdf:Property ;
                  ] ;
                sp:arg2 [
                    a swa:shortestClassPropertyTreePath ;
                    arg:property [
                        sp:varName "node" ;
                      ] ;
                    arg:root [
                        sp:varName "root" ;
                      ] ;
                  ] ;
                sp:arg3 [
                    a sp:if ;
                    sp:arg1 [
                        a sp:exists ;
                        sp:elements (
                            [
                              sp:object [
                                  sp:varName "node" ;
                                ] ;
                              sp:predicate sh:property ;
                              sp:subject [
                                  sp:varName "class" ;
                                ] ;
                            ]
                          ) ;
                      ] ;
                    sp:arg2 [
                        a swa:shortestClassPropertyConstraintTreePath ;
                        arg:constraint [
                            sp:varName "node" ;
                          ] ;
                        arg:root [
                            sp:varName "root" ;
                          ] ;
                      ] ;
                    sp:arg3 [
                        a spif:shortestObjectsPath ;
                        sp:arg1 [
                            sp:varName "node" ;
                          ] ;
                        sp:arg2 rdfs:subClassOf ;
                        sp:arg3 [
                            sp:varName "root" ;
                          ] ;
                      ] ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "path" ;
              ] ;
          ]
        ) ;
    ] ;
  rdfs:comment "Used by the class-property tree to find the shortest path to a given node." ;
  rdfs:label "Class-property tree path" ;
  rdfs:subClassOf swa:TreePathTemplates ;
.
swa:ClassPropertyTreeRoots
  a spin:SelectTemplate ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "node" ;
          ]
          [
            sp:varName "label" ;
          ]
          [
            sp:varName "leaf" ;
          ]
          [
            sp:varName "icon" ;
          ]
          [
            sp:varName "movable" ;
          ]
          [
            sp:varName "metadata" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a sp:coalesce ;
                sp:arg1 [
                    sp:varName "root" ;
                  ] ;
                sp:arg2 rdfs:Resource ;
              ] ;
            sp:variable [
                sp:varName "node" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a ui:label ;
                sp:arg1 [
                    sp:varName "node" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "label" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:not ;
                sp:arg1 [
                    a swa:classHasSubClassOrDirectRelevantProperty ;
                    arg:class [
                        sp:varName "node" ;
                      ] ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "leaf" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:if ;
                sp:arg1 [
                    a swa:isImportedResource ;
                    arg:resource [
                        sp:varName "node" ;
                      ] ;
                  ] ;
                sp:arg2 "swa-icon-class-imported" ;
                sp:arg3 "swa-icon-class" ;
              ] ;
            sp:variable [
                sp:varName "icon" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression false ;
            sp:variable [
                sp:varName "movable" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression "Class" ;
            sp:variable [
                sp:varName "metadata" ;
              ] ;
          ]
        ) ;
    ] ;
  rdfs:comment "A template that delivers the roots of an SWA class-property tree. Unless a different root has been specified using arg:root, it will return rdfs:Resource." ;
  rdfs:label "Class-Property tree roots" ;
  rdfs:subClassOf swa:TreeRootsTemplates ;
.
swa:ClassTreeChildren
  a spin:SelectTemplate ;
  spin:body [
      a sp:Select ;
      sp:orderBy (
          [
            sp:varName "label" ;
          ]
        ) ;
      sp:resultVariables (
          [
            sp:varName "node" ;
          ]
          [
            sp:varName "label" ;
          ]
          [
            sp:varName "leaf" ;
          ]
          [
            sp:varName "icon" ;
          ]
          [
            sp:varName "movable" ;
          ]
        ) ;
      sp:where (
          [
            a sp:SubQuery ;
            sp:query [
                a sp:Select ;
                sp:limit "5000"^^xsd:long ;
                sp:where (
                    [
                      sp:object [
                          sp:varName "node" ;
                        ] ;
                      sp:predicate swa:superClassOfLimited ;
                      sp:subject [
                          sp:varName "parent" ;
                        ] ;
                    ]
                    [
                      a sp:Filter ;
                      sp:expression [
                          a sp:and ;
                          sp:arg1 [
                              a sp:and ;
                              sp:arg1 [
                                  a sp:isIRI ;
                                  sp:arg1 [
                                      sp:varName "node" ;
                                    ] ;
                                ] ;
                              sp:arg2 [
                                  a sp:ne ;
                                  sp:arg1 [
                                      sp:varName "node" ;
                                    ] ;
                                  sp:arg2 owl:Nothing ;
                                ] ;
                            ] ;
                          sp:arg2 [
                              a sp:ne ;
                              sp:arg1 [
                                  sp:varName "node" ;
                                ] ;
                              sp:arg2 owl:NamedIndividual ;
                            ] ;
                        ] ;
                    ]
                    [
                      a sp:Filter ;
                      sp:expression [
                          a sp:or ;
                          sp:arg1 [
                              a sp:not ;
                              sp:arg1 [
                                  a sp:bound ;
                                  sp:arg1 [
                                      sp:varName "filterFunction" ;
                                    ] ;
                                ] ;
                            ] ;
                          sp:arg2 [
                              a spif:invoke ;
                              sp:arg1 [
                                  sp:varName "filterFunction" ;
                                ] ;
                              sp:arg2 [
                                  sp:varName "node" ;
                                ] ;
                            ] ;
                        ] ;
                    ]
                  ) ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:notExists ;
                sp:elements (
                    [
                      sp:object [
                          sp:varName "node" ;
                        ] ;
                      sp:predicate rdfs:subClassOf ;
                      sp:subject [
                          sp:varName "child" ;
                        ] ;
                    ]
                  ) ;
              ] ;
            sp:variable [
                sp:varName "leaf" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a ui:label ;
                sp:arg1 [
                    sp:varName "node" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "label" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:if ;
                sp:arg1 [
                    a swa:isImportedResource ;
                    arg:resource [
                        sp:varName "node" ;
                      ] ;
                  ] ;
                sp:arg2 "swa-icon-class-imported" ;
                sp:arg3 "swa-icon-class" ;
              ] ;
            sp:variable [
                sp:varName "icon" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:not ;
                sp:arg1 [
                    a swa:isReadOnlyTriple ;
                    sp:arg1 [
                        sp:varName "node" ;
                      ] ;
                    sp:arg2 rdfs:subClassOf ;
                    sp:arg3 [
                        sp:varName "parent" ;
                      ] ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "movable" ;
              ] ;
          ]
        ) ;
    ] ;
  rdfs:comment "A template that delivers all (named) subclasses of a given parent class, using rdfs:subClassOf." ;
  rdfs:label "Class tree children" ;
  rdfs:subClassOf swa:TreeChildrenTemplates ;
.
swa:ClassTreeChildrenWithCounts
  a spin:SelectTemplate ;
  spin:body [
      a sp:Select ;
      sp:orderBy (
          [
            sp:varName "label" ;
          ]
        ) ;
      sp:resultVariables (
          [
            sp:varName "node" ;
          ]
          [
            sp:varName "label" ;
          ]
          [
            sp:varName "leaf" ;
          ]
          [
            sp:varName "icon" ;
          ]
          [
            sp:varName "movable" ;
          ]
          [
            sp:varName "countLabel" ;
          ]
          [
            sp:varName "count" ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "node" ;
              ] ;
            sp:predicate swa:superClassOfLimited ;
            sp:subject [
                sp:varName "parent" ;
              ] ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:and ;
                sp:arg1 [
                    a sp:and ;
                    sp:arg1 [
                        a sp:isIRI ;
                        sp:arg1 [
                            sp:varName "node" ;
                          ] ;
                      ] ;
                    sp:arg2 [
                        a sp:ne ;
                        sp:arg1 [
                            sp:varName "node" ;
                          ] ;
                        sp:arg2 owl:Nothing ;
                      ] ;
                  ] ;
                sp:arg2 [
                    a sp:ne ;
                    sp:arg1 [
                        sp:varName "node" ;
                      ] ;
                    sp:arg2 owl:NamedIndividual ;
                  ] ;
              ] ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:or ;
                sp:arg1 [
                    a sp:not ;
                    sp:arg1 [
                        a sp:bound ;
                        sp:arg1 [
                            sp:varName "filterFunction" ;
                          ] ;
                      ] ;
                  ] ;
                sp:arg2 [
                    a spif:invoke ;
                    sp:arg1 [
                        sp:varName "filterFunction" ;
                      ] ;
                    sp:arg2 [
                        sp:varName "node" ;
                      ] ;
                  ] ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:notExists ;
                sp:elements (
                    [
                      sp:object [
                          sp:varName "node" ;
                        ] ;
                      sp:predicate rdfs:subClassOf ;
                      sp:subject [
                          sp:varName "child" ;
                        ] ;
                    ]
                  ) ;
              ] ;
            sp:variable [
                sp:varName "leaf" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a ui:label ;
                sp:arg1 [
                    sp:varName "node" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "label" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a smf:countResults ;
                sp:arg1 "SELECT ?instance	WHERE {?class rdfs:subClassOf* ?node . ?instance a ?class}" ;
              ] ;
            sp:variable [
                sp:varName "count" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a fn:concat ;
                sp:arg1 [
                    sp:varName "label" ;
                  ] ;
                sp:arg2 " (" ;
                sp:arg3 [
                    sp:varName "count" ;
                  ] ;
                sp:arg4 ")" ;
              ] ;
            sp:variable [
                sp:varName "countLabel" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:if ;
                sp:arg1 [
                    a swa:isImportedResource ;
                    arg:resource [
                        sp:varName "node" ;
                      ] ;
                  ] ;
                sp:arg2 "swa-icon-class-imported" ;
                sp:arg3 "swa-icon-class" ;
              ] ;
            sp:variable [
                sp:varName "icon" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:not ;
                sp:arg1 [
                    a swa:isReadOnlyTriple ;
                    sp:arg1 [
                        sp:varName "node" ;
                      ] ;
                    sp:arg2 rdfs:subClassOf ;
                    sp:arg3 [
                        sp:varName "parent" ;
                      ] ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "movable" ;
              ] ;
          ]
        ) ;
    ] ;
  rdfs:comment "A template that delivers all (named) subclasses of a given parent class, using rdfs:subClassOf." ;
  rdfs:label "Class tree children with counts" ;
  rdfs:subClassOf swa:TreeChildrenTemplates ;
.
swa:ClassTreeDataProvider
  a swa:TreeDataProvider ;
  arg:changeHandler "swa.handleChangeForClassTree" ;
  arg:treeChildrenTemplate swa:ClassTreeChildren ;
  arg:treePathTemplate swa:ClassTreePath ;
  arg:treeRootsTemplate swa:ClassTreeRoots ;
  rdfs:comment "A data provider for a class tree starting at rdfs:Resource." ;
  rdfs:label "Class tree data provider" ;
.
swa:ClassTreeDataProviderWithCounts
  a swa:TreeDataProviderWithCounts ;
  arg:changeHandler "swa.handleChangeForClassTree" ;
  arg:treeChildrenTemplate swa:ClassTreeChildrenWithCounts ;
  arg:treePathTemplate swa:ClassTreePath ;
  arg:treeRootsTemplate swa:ClassTreeRootsWithCounts ;
  rdfs:comment "A data provider for a class tree starting at rdfs:Resource." ;
  rdfs:label "Class tree data provider with counts" ;
.
swa:ClassTreeGadget
  a swa:Gadget ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:editable ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to have a button to create classes appear under the tree." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:filterFunction ;
      spl:valueType spin:Function ;
      rdfs:comment "A filter function for the nodes in the tree (see swa:Tree)." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:refreshEvent ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of an event that causes the tree to refresh itself." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:classSelectedEvent ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the event to publish when the selected class has changed." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:classTreeDataProvider ;
      spl:valueType swa:TreeDataProvider ;
      rdfs:comment "An optional data provider for the class tree.  If not specified, it will use swa:ClassTreeDataProvider." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:rootClass ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The root class of the tree." ;
    ] ;
  ui:prototype """
<ui:group let:dataProvider=\"{= COALESCE(?classTreeDataProvider, swa:ClassTreeDataProvider) }\" let:treeId=\"{= COALESCE(?treeId, ui:uniqueId()) }\">
    <div class=\"swa-gadget-toolbar\">
        <swa:AutoComplete arg:filterFunction=\"{= swa:filterSubclassesOfRoot }\" arg:filterFunctionArgument=\"{= ?rootClass }\" arg:id=\"classTreeAutoComplete\" arg:onSelect=\"swa.selectTreeNode('{= ?treeId }', resource, '{= ui:currentQueryGraph() }');\" arg:placeholder=\"{= swa:autoCompleteSearchPlaceholder(&quot;Class&quot;) }\" arg:type=\"{= rdfs:Class }\"/>
        <ui:if ui:condition=\"{= ?editable }\">
            <div class=\"swa-float-right\">
                <swa:CreateResourceButton arg:contextResourceGetter=\"swa.getSelectedTreeResourceOrError('{= ?treeId }', 'Error: Please select a parent class first.')\" arg:createHandler=\"{= swa:CreateClassHandler }\" arg:iconClass=\"swa-icon-class\" arg:resourceSelectedEvent=\"{= ?resourceSelectedEvent }\" arg:resourceType=\"{= owl:Class }\" arg:suppressTypeSelection=\"{= true }\"/>
            </div>
            <div class=\"swa-class-property-tree-gadget-button-clear-right-div\"/>
        </ui:if>
    </div>
    <div class=\"ui-layout-content\">
        <swa:Tree arg:dataProvider=\"{= ?dataProvider }\" arg:filterFunction=\"{= ?filterFunction }\" arg:id=\"{= ?treeId }\" arg:onSelect=\"{= swa:publishEvent(?classSelectedEvent, &quot;resource&quot;) }{= swa:publishEvent(?resourceSelectedEvent, &quot;resource&quot;) }\" arg:root=\"{= ?rootClass }\"/>
    </div>
    <swa:Subscribe arg:code=\"{= spl:objectInGraph(?dataProvider, arg:changeHandler, ui:graph) }(data, '{= ?treeId }')\" arg:event=\"org.topbraid.swa.change\"/>
    <swa:Subscribe arg:code=\"swa.selectTreeNode('{= ?treeId }', data)\" arg:event=\"{= ?resourceSelectedEvent }\"/>
    <ui:if ui:condition=\"{= bound(?refreshEvent) }\">
        <swa:Subscribe arg:code=\"swa.refreshTree('{= ?treeId }')\" arg:event=\"{= ?refreshEvent }\"/>
    </ui:if>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "A gadget displaying a class tree. The tree can publish events whenever the user selects a class." ;
  rdfs:label "Class tree gadget" ;
  rdfs:subClassOf swa:TreeGadgets ;
.
swa:ClassTreeNavigationNode
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:class ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The root class." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:indentation ;
      spl:valueType xsd:string ;
      rdfs:comment "An intendation string, e.g. \"    \" for the first level of children." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:selected ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The class that shall be selected." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:visitedGraph ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The URI of the temp graph holding the visited nodes, e.g. ui:tempGraphTree1." ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:group>
    <ui:setContext ui:queryGraph=\"{= ?visitedGraph }\">
        <ui:update ui:updateQuery=\"{!
                INSERT {
                    ?class a rdfs:Class .
                }
                WHERE {
                } }\"/>
    </ui:setContext>
    <option selected=\"{= IF((?class = ?selected), &quot;selected&quot;, ?none) }\" title=\"{= ?class }\" value=\"{= ui:encodeNode(?class, true, true) }\">{= ?indentation }{= ui:label(?class) }</option>
    <ui:forEach ui:resultSet=\"{#
            SELECT ?subClass
            WHERE {
                ?subClass rdfs:subClassOf ?class .
                FILTER NOT EXISTS {
                    GRAPH ?visitedGraph {
                        ?subClass ?a rdfs:Class .
                    } .
                } .
                BIND (ui:label(?subClass) AS ?label) .
            }
            ORDER BY (?label) }\">
        <swa:ClassTreeNavigationNode arg:class=\"{= ?subClass }\" arg:indentation=\"{= ?indentation }&nbsp;&nbsp;&nbsp;&nbsp;\" arg:selected=\"{= ?selected }\" arg:visitedGraph=\"{= ?visitedGraph }\"/>
    </ui:forEach>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "Produces nodes in a pseudo-tree consisting of <option> elements where the labels are indented depending on the depth of the tree traversal." ;
  rdfs:subClassOf swa:TreeElements ;
.
swa:ClassTreePath
  a spin:SelectTemplate ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "path" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a spif:shortestObjectsPath ;
                sp:arg1 [
                    sp:varName "node" ;
                  ] ;
                sp:arg2 rdfs:subClassOf ;
                sp:arg3 [
                    sp:varName "root" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "path" ;
              ] ;
          ]
        ) ;
    ] ;
  rdfs:comment "Used by the class tree to find the shortest path to a given node." ;
  rdfs:label "Class tree path" ;
  rdfs:subClassOf swa:TreePathTemplates ;
.
swa:ClassTreeRoots
  a spin:SelectTemplate ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "node" ;
          ]
          [
            sp:varName "label" ;
          ]
          [
            sp:varName "leaf" ;
          ]
          [
            sp:varName "icon" ;
          ]
          [
            sp:varName "movable" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a sp:coalesce ;
                sp:arg1 [
                    sp:varName "root" ;
                  ] ;
                sp:arg2 rdfs:Resource ;
              ] ;
            sp:variable [
                sp:varName "node" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a ui:label ;
                sp:arg1 [
                    sp:varName "node" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "label" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:notExists ;
                sp:elements (
                    [
                      sp:object [
                          sp:varName "node" ;
                        ] ;
                      sp:predicate rdfs:subClassOf ;
                      sp:subject [
                          sp:varName "child" ;
                        ] ;
                    ]
                  ) ;
              ] ;
            sp:variable [
                sp:varName "leaf" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:if ;
                sp:arg1 [
                    a swa:isImportedResource ;
                    arg:resource [
                        sp:varName "node" ;
                      ] ;
                  ] ;
                sp:arg2 "swa-icon-class-imported" ;
                sp:arg3 "swa-icon-class" ;
              ] ;
            sp:variable [
                sp:varName "icon" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression false ;
            sp:variable [
                sp:varName "movable" ;
              ] ;
          ]
        ) ;
    ] ;
  rdfs:comment "A template that delivers the roots of an SWA class tree. Unless a different root has been specified using arg:root, it will return rdfs:Resource." ;
  rdfs:label "Class tree roots" ;
  rdfs:subClassOf swa:TreeRootsTemplates ;
.
swa:ClassTreeRootsWithCounts
  a spin:SelectTemplate ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "node" ;
          ]
          [
            sp:varName "label" ;
          ]
          [
            sp:varName "leaf" ;
          ]
          [
            sp:varName "icon" ;
          ]
          [
            sp:varName "movable" ;
          ]
          [
            sp:varName "countLabel" ;
          ]
          [
            sp:varName "count" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a sp:coalesce ;
                sp:arg1 [
                    sp:varName "root" ;
                  ] ;
                sp:arg2 rdfs:Resource ;
              ] ;
            sp:variable [
                sp:varName "node" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a ui:label ;
                sp:arg1 [
                    sp:varName "node" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "label" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:notExists ;
                sp:elements (
                    [
                      sp:object [
                          sp:varName "node" ;
                        ] ;
                      sp:predicate rdfs:subClassOf ;
                      sp:subject [
                          sp:varName "child" ;
                        ] ;
                    ]
                  ) ;
              ] ;
            sp:variable [
                sp:varName "leaf" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a smf:countResults ;
                sp:arg1 "SELECT ?instance	WHERE {?class rdfs:subClassOf* ?node . ?instance a ?class}" ;
              ] ;
            sp:variable [
                sp:varName "count" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a fn:concat ;
                sp:arg1 [
                    sp:varName "label" ;
                  ] ;
                sp:arg2 " (" ;
                sp:arg3 [
                    sp:varName "count" ;
                  ] ;
                sp:arg4 ")" ;
              ] ;
            sp:variable [
                sp:varName "countLabel" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:if ;
                sp:arg1 [
                    a swa:isImportedResource ;
                    arg:resource [
                        sp:varName "node" ;
                      ] ;
                  ] ;
                sp:arg2 "swa-icon-class-imported" ;
                sp:arg3 "swa-icon-class" ;
              ] ;
            sp:variable [
                sp:varName "icon" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression false ;
            sp:variable [
                sp:varName "movable" ;
              ] ;
          ]
        ) ;
    ] ;
  rdfs:comment "A template that delivers the roots of an SWA class tree. Unless a different root has been specified using arg:root, it will return rdfs:Resource." ;
  rdfs:label "Class tree roots with counts" ;
  rdfs:subClassOf swa:TreeRootsTemplates ;
.
swa:ClosableSearchBarEast
  a ui:NodeClass ;
  ui:headIncludes """
<script>(function ($) {$(document).ready(function () {$('body').addClass('search-application');});}(jQuery));</script>
"""^^ui:Literal ;
  rdfs:comment "Subclass this element (e.g. in your top-level application) to inject code that will make the East panel appear with a vertical placeholder \"Search\" when minimized/closed. This needs to be combined with setting arg:eastClosed=\"true\" in your BorderLayout. JavaScript injects the class \"search-application\" onto the body element once the page has loaded so we can style the tabs in an external stylesheet. Having the page \"namespaced\" as \"search-application\" allows us to conveniently prefix the css selectors so resizer tabs are not overriden everywhere. " ;
  rdfs:label "Minimizable search bar east" ;
  rdfs:subClassOf swa:LayoutElements ;
.
swa:ClosableSearchBarWest
  a ui:NodeClass ;
  ui:headIncludes """
<script>(function ($) {$(document).ready(function () {$('body').addClass('search-application');});}(jQuery));</script>
"""^^ui:Literal ;
  rdfs:comment "Subclass this element (e.g. in your top-level application) to inject code that will make the West panel appear with a vertical placeholder \"Search\" when minimized/closed. This needs to be combined with setting arg:westClosed=\"true\" in your BorderLayout. JavaScript injects the class \"search-application\" onto the body element once the page has loaded so we can style the tabs in an external stylesheet. Having the page \"namespaced\" as \"search-application\" allows us to conveniently prefix the css selectors so resizer tabs are not overriden everywhere. " ;
  rdfs:label "Minimizable search bar west" ;
  rdfs:subClassOf swa:LayoutElements ;
.
swa:CollapsibleLoadableFormSection
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:loadId ;
      spl:valueType xsd:string ;
      rdfs:comment "The id of the embedded loadable." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:label ;
      spl:valueType xsd:string ;
      rdfs:comment "The title of the section." ;
    ] ;
  ui:prototype """
<ui:group>
    <span class=\"swa-openable-indicator ui-icon ui-icon-triangle-1-e\" id=\"{= ?loadId }-button\"/>
    <div class=\"swa-sub-title swa-collapsible-loadable-form-section-clickable swa-loadable-form-section-clickable\" data-loadId=\"{= ?loadId }\" data-state=\"init\">
        <span>{= ?label }</span>
    </div>
    <ui:insertionPoint ui:pointId=\"body\"/>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "Displays a sub-header with a (Show) button. When clicked, will load the child ui:loadable." ;
  rdfs:label "Loadable form section" ;
  rdfs:subClassOf swa:FormElements ;
.
swa:ColumnLayout
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:class ;
      spl:valueType xsd:string ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:colClass ;
      spl:valueType xsd:string ;
      rdfs:comment "A second class to be passed in to the td element. Values in this class should match the values passed into the colWidths argument" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:colWidths ;
      spl:valueType xsd:string ;
      rdfs:comment "A comma-separated list of width style values for each column, in CSS notation. For example \"25%,25%,50%\" will create three columns, with the third column covering 50% of the available width." ;
    ] ;
  ui:prototype """
<table class=\"swa-layout-table {= IF(bound(?class), ?class, ?none) }\">
    <tr>
        <ui:forEach ui:indexVar=\"index\" ui:resultSet='{#
                SELECT ?colWidth
                WHERE {
                    ?colWidth spif:split ( ?colWidths \",\" ) .
                } }'>
            <td class=\"swa-layout-td {= IF(bound(?colClass), ?colClass, ?none) }\">
                <ui:insertionPoint ui:pointId=\"col{= ?index }\"/>
            </td>
        </ui:forEach>
    </tr>
</table>
"""^^ui:Literal ;
  rdfs:comment "A container that arranges its children into one or more column. The relative widths of each column must be specified using a comma-separated list (arg:colWidths). The immediate children of this element will be used as columns from left to right." ;
  rdfs:label "Column layout" ;
  rdfs:subClassOf swa:LayoutElements ;
.
swa:ConceptFacet
  a swa:ObjectFacetClass ;
  swa:facetSearchType search:ConceptFacetValue ;
  swa:objectFacetMenuName "equals or sub-concept" ;
  swa:objectWidgetWeight [
      a swa:WeightedExpression ;
      swa:expression [
          a sp:and ;
          sp:arg1 [
              a sp:bound ;
              sp:arg1 [
                  sp:varName "range" ;
                ] ;
            ] ;
          sp:arg2 [
              a spl:subClassOf ;
              sp:arg1 [
                  sp:varName "range" ;
                ] ;
              sp:arg2 skos:Concept ;
            ] ;
        ] ;
      swa:weight -2 ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:group let:restore=\"{= swa:restoreFacetValue(?predicate) }\" let:type=\"{= swa:localRangeAtClass(swa:resourceType(), ?predicate) }\">
    <span class=\"swa-concept-facet-span\" title=\"Equals to value or a sub-concept thereof\">&le;</span>
    <swa:AutoComplete arg:class=\"{= swa:testClass(?predicate) }\" arg:id=\"concept{= ?uid }\" arg:initialValue=\"{= IF(bound(?restore), spl:object(?restore, search:rootConcept), ?none) }\" arg:type=\"{= IF((bound(?type) &amp;&amp; isBlank(?type)), skos:Concept, ?type) }\"/>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "A facet for SKOS concepts, displaying an AutoComplete." ;
  rdfs:label "Concept facet" ;
  rdfs:subClassOf swa:ObjectFacet ;
.
swa:ConfirmDeleteResourceHandler
  a ui:Service ;
  ui:prototype """
<ui:group>
    <swa:ResourceDestructor arg:resource=\"{= ?resource }\"/>
    <swon:RSObject arg:resultSet='{#
            SELECT ?message ?tripleCount
            WHERE {
                {
                    SELECT (COUNT(?s) AS ?tripleCount)
                    WHERE {
                        GRAPH ui:tempGraph {
                            ?s ?p ?o .
                            FILTER (?s != swa:DestructorMetadata) .
                        } .
                    }
                } .
                BIND (fn:concat(\"Are you sure you want to delete \", ui:label(?resource), \"?\") AS ?message) .
            } }'/>
</ui:group>
"""^^ui:Literal ;
  ui:responseType ui:JSON ;
  rdfs:comment """Called to pre-compute which triples would need to be deleted to delete a given resource. Returns a JSON object such as

{
	\"message\" : \"Are you sure you want to delete XY?\",
	\"tripleCount : 102
}""" ;
  rdfs:label "Confirm delete resource handler" ;
  rdfs:subClassOf swa:DestructorElements ;
  rdfs:subClassOf ui:JSONServices ;
.
swa:ContainsStringFacet
  a swa:ObjectFacetClass ;
  swa:facetSearchType search:ContainsStringFacetValue ;
  swa:objectFacetMenuName "text contains" ;
  swa:objectWidgetWeight [
      a swa:WeightedExpression ;
      swa:expression [
          a sp:or ;
          sp:arg1 [
              a sp:not ;
              sp:arg1 [
                  a sp:bound ;
                  sp:arg1 [
                      sp:varName "range" ;
                    ] ;
                ] ;
            ] ;
          sp:arg2 [
              a swa:isDatatypeRange ;
              arg:range [
                  sp:varName "range" ;
                ] ;
            ] ;
        ] ;
    ] ;
  ui:private true ;
  ui:prototype """
<div class=\"nowrap\" let:datatype=\"{= swa:localRange(?predicate, ?subject) }\" let:restore=\"{= swa:restoreFacetValue(?predicate) }\">
    <input class=\"swa-exact-match-input form-control {= swa:testClass(?predicate) }\" name=\"contains{= ?uid }\" type=\"text\" value=\"{= IF(bound(?restore), spl:object(?restore, search:subString), ?none) }\"/>
    <swa:LangSelector arg:initialValue=\"{= IF(bound(?restore), spl:object(?restore, search:lang), ?none) }\" arg:uid=\"{= ?uid }\"/>
</div>
"""^^ui:Literal ;
  rdfs:comment "An ObjectFacet showing a text field. Matching values must contain the given string (verbatim, not by regex)." ;
  rdfs:label "Contains string facet" ;
  rdfs:subClassOf swa:ObjectFacet ;
.
swa:CreateCallFunctions
  a spin:Function ;
  spin:abstract true ;
  spin:returnType xsd:string ;
  rdfs:comment "Abstract base class for functions that produce a JavaScript call, e.g. to be used as event handlers." ;
  rdfs:label "Create call functions" ;
  rdfs:subClassOf swa:Functions ;
.
swa:CreateClassHandler
  a ui:NodeClass ;
  ui:private true ;
  ui:prototype """
<ui:transaction ui:logMessage=\"Create class with URI {= ?uri }\" ui:metadata=\"{= ?metadata }\">
    <ui:preCondition ui:errorMessage=\"{= COALESCE(swa:labelExistsPreCondition(?label), swa:validURIPreCondition(?uri), swa:unusedURIPreCondition(IRI(str(?uri)))) }\">
        <ui:preCondition ui:errorMessage=\"{= IF(spl:hasValue(?contextResource, owl:oneOf), &quot;Cannot create subclasses of class with an owl:oneOf&quot;, ?none) }\">
            <ui:group let:class=\"{= IRI(str(?uri)) }\" let:superClass=\"{= IF(spl:instanceOf(?contextResource, rdf:Property), COALESCE(spl:object(?contextResource, rdfs:domain), owl:Thing), ?contextResource) }\">
                <ui:update ui:updateQuery=\"{!
                        INSERT {
                            ?class rdfs:label ?prefLabel .
                            ?class rdfs:subClassOf ?superClass .
                        }
                        WHERE {
                            BIND (IF(bound(?labelLang), STRLANG(?label, ?labelLang), ?label) AS ?prefLabel) .
                        } }\"/>
                <ui:if ui:condition=\"{= EXISTS {
                    ?superClass a ?someType .
                } }\">
                    <ui:update ui:updateQuery=\"{!
                            INSERT {
                                ?class a ?type .
                            }
                            WHERE {
                                ?superClass a ?type .
                            } }\"/>
                </ui:if>
                <ui:else>
                    <ui:update ui:updateQuery=\"{!
                            INSERT {
                                ?class a ?resourceType .
                            }
                            WHERE {
                            } }\"/>
                </ui:else>
                <swa:createPrimaryKeyTriple ui:args=\"*\"/>
                <swa:addDefaultValues arg:resource=\"{= ?class }\"/>
            </ui:group>
        </ui:preCondition>
    </ui:preCondition>
</ui:transaction>
"""^^ui:Literal ;
  rdfs:comment "The updates that need to happen to create a new class. The newly created class will have the same rdf:types as the provided superclass, defaulting to the provided ?resourceType." ;
  rdfs:label "Create class handler" ;
  rdfs:subClassOf swa:CreateHandlers ;
.
swa:CreateForm
  a swa:FormClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:resourceURI ;
      spl:valueType xsd:string ;
      rdfs:comment "The URI of the new resource. If left blank then the form will include an edit field for the URI." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:formId ;
      spl:valueType xsd:string ;
      rdfs:comment "The id of the form (needed for the JavaScript form submission)." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The rdf:type of the instance to create." ;
    ] ;
  ui:prototype """
<ui:setContext ui:varName=\"mode\" ui:varValue=\"edit\">
    <form autocomplete=\"off\" class=\"swa-form\" id=\"{= ?formId }\">
        <input name=\"_base\" type=\"hidden\" value=\"{= swa:dataGraph() }\"/>
        <input name=\"resourceType\" type=\"hidden\" value=\"{= ?resourceType }\"/>
        <div class=\"swa-form-body\">
            <ui:if ui:condition=\"{= bound(?resourceURI) }\">
                <input name=\"resourceURI\" type=\"hidden\" value=\"{= ?resourceURI }\"/>
            </ui:if>
            <ui:else>
                <swa:URIField arg:resourceType=\"{= ?resourceType }\" arg:resourceURI=\"{= ?resourceURI }\"/>
            </ui:else>
            <ui:setContext ui:varName=\"resourceType\" ui:varValue=\"{= ?resourceType }\">
                <ui:classView ui:class=\"{= ?resourceType }\" ui:matchIds=\"create,edit,form\"/>
            </ui:setContext>
        </div>
    </form>
</ui:setContext>
"""^^ui:Literal ;
  rdfs:comment "A form that can be used to edit a new instance of a given class." ;
  rdfs:label "Create form" ;
  rdfs:subClassOf swa:Form ;
.
swa:CreateGenericTreeResourceHandler
  a ui:NodeClass ;
  ui:private true ;
  ui:prototype """
<ui:transaction ui:logMessage=\"Create {= ui:label(?resourceType) } with URI {= ?uri } as child of {= IF(bound(?contextResource), ui:label(?contextResource), &quot;(Root)&quot;) }\" ui:metadata=\"{= ?metadata }\">
    <ui:preCondition ui:errorMessage=\"{= COALESCE(swa:labelExistsPreCondition(?label), swa:validURIPreCondition(?uri), swa:unusedURIPreCondition(IRI(str(?uri)))) }\">
        <ui:update ui:updateQuery=\"{!
                INSERT {
                    ?resource a ?resourceType .
                    ?resource ?labelProperty ?prefLabel .
                    ?resource ?predicate ?object .
                    ?subject ?predicate ?resource .
                }
                WHERE {
                    BIND (IRI(str(?uri)) AS ?resource) .
                    BIND (IF(bound(?labelLang), STRLANG(?label, ?labelLang), ?label) AS ?prefLabel) .
                    BIND (ui:contextValue(&quot;swaGenericTreeProperty&quot;) AS ?predicate) .
                    BIND (COALESCE(ui:contextValue(&quot;swaGenericTreeInverse&quot;), false) AS ?inverse) .
                    BIND (IF((!?inverse), ?contextResource, ?none) AS ?subject) .
                    BIND (IF(?inverse, ?contextResource, ?none) AS ?object) .
                    BIND (swa:labelProperty(?resourceType) AS ?labelProperty) .
                } }\"/>
        <swa:createPrimaryKeyTriple ui:args=\"*\"/>
        <swa:addDefaultValues arg:resource=\"{= IRI(str(?uri)) }\"/>
    </ui:preCondition>
</ui:transaction>
"""^^ui:Literal ;
  rdfs:comment "The updates that need to happen to create a new resource with a given type in a generic tree. The parent resource must be the ?contextResource. The relationship property is taken from the context variables that are used throughout the generic tree." ;
  rdfs:label "Create generic tree resource handler" ;
  rdfs:subClassOf swa:CreateHandlers ;
.
swa:CreateHRefFunctions
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The URI resource to link to." ;
    ] ;
  rdfs:label "Create HRef functions" ;
  rdfs:subClassOf swa:Functions ;
.
swa:CreateHandlers
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:contextResource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "An optional context resource that is needed by some CreateHandlers. Examples include the superclass of a class and the parent concept of a skos:Concept." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:label ;
      spl:valueType xsd:string ;
      rdfs:comment "The preferred label." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:labelLang ;
      spl:valueType xsd:string ;
      rdfs:comment "The language of the label." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:metadata ;
      spl:valueType xsd:string ;
      rdfs:comment "The metadata string to pass into the transaction." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The type of the new resource (e.g. owl:Class)." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:uri ;
      spl:valueType xsd:string ;
      rdfs:comment "The uri of the new resource." ;
    ] ;
  ui:abstract true ;
  ui:private true ;
  rdfs:comment "Abstract superclass of the handlers of create buttons. Use the provided subclasses as examples and note how they wrap the update into a transaction including its metadata." ;
  rdfs:label "Create handlers" ;
  rdfs:subClassOf swa:EditHandlers ;
.
swa:CreateLinkFunctions
  a spin:Function ;
  spin:abstract true ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The URI resource to link to." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:uid ;
      spl:valueType xsd:string ;
      rdfs:comment "The uid of the link element - this can be used to learn more about the neighborhood of the link." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment """Abstract superclass for functions that take a URI resource and produce a JavaScript snippet that acts like a hyperlink for it. All link creation by widgets should run through one of those functions. If no function is called directly, then swa:createLink should be used which will find the most suitable link function for the given context.

For example, hyperlinks on a view form should replace the view form with a form for the selected resource. The form sets a context variable 'createLinkFunction' that points to a function that will replace the whole form after an ajax request.""" ;
  rdfs:label "Create link functions" ;
  rdfs:subClassOf swa:Functions ;
.
swa:CreatePropertyConstraintButton
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resourceSelectedEvent ;
      spl:valueType xsd:string ;
      rdfs:comment "The event to publish when done." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:treeId ;
      spl:valueType xsd:string ;
      rdfs:comment "The id of the tree." ;
    ] ;
  ui:prototype """
<swa:Button arg:class=\"btn btn-default btn-xs\" arg:iconClass=\"swa-icon-property-constraint\" arg:id=\"{= ?id }\" arg:onClick=\"{= ui:functionCall(&quot;swa.createPropertyConstraint&quot;, ?treeId, ?resourceSelectedEvent) }\" arg:overlayImage=\"{= ui:lib() }/assets/build/images/AddOverlay.png\" arg:toolTip=\"Add Property Shape...\"/>
"""^^ui:Literal ;
  rdfs:label "Create property constraint button" ;
  rdfs:subClassOf swa:ButtonElements ;
.
swa:CreatePropertyConstraintDialog
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The pre-selected predicate (if available)." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:loadId ;
      spl:valueType xsd:string ;
      rdfs:comment "The ui:loadId of the resulting ui:loadable." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resourceSelectedEvent ;
      spl:valueType xsd:string ;
      rdfs:comment "The event to fire when done, to navigate to the new constraint." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:shape ;
      spl:valueType sh:Shape ;
      rdfs:comment "The sh:Shape hosting the new constraint." ;
    ] ;
  ui:private true ;
  ui:prototype """
<div id=\"div-{= ?loadId }\" let:aid=\"{= ui:uniqueId() }\" let:cid=\"{= ui:uniqueId() }\" let:iid=\"{= ui:uniqueId() }\" let:pid=\"{= ui:uniqueId() }\" title=\"Create Property Shape\">
    <ui:if ui:condition=\"{= tosh:shaclExists() }\">
        <div id=\"tabsDIV\">
            <ul>
                <li>
                    <a href=\"#tab1\">On Single Property</a>
                </li>
                <li>
                    <a href=\"#tab2\">On Property Path</a>
                </li>
            </ul>
            <div id=\"tab1\">
                <swa:LabeledElement arg:label=\"Property to constrain:\">
                    <swa:AutoComplete arg:id=\"{= ?aid }\" arg:initialValue=\"{= ?predicate }\" arg:type=\"{= rdf:Property }\"/>
                </swa:LabeledElement>
                <swa:LabeledElement>
                    <div class=\"checkbox swa-create-property-constraint-dialog-checkbox-div\">
                        <input id=\"{= ?iid }\" type=\"checkbox\"/>
                        <span class=\"swa-checkbox-span\"> create an inverse property constraint</span>
                    </div>
                </swa:LabeledElement>
            </div>
            <div id=\"tab2\">
                <swa:LabeledElement arg:label=\"Path (SPARQL syntax):\">
                    <input id=\"{= ?pid }\" style=\"width: 300px\" type=\"text\"/>
                </swa:LabeledElement>
                <div class=\"text-danger\" id=\"{= ?pid }-error\"/>
            </div>
        </div>
        <div class=\"checkbox swa-create-property-constraint-dialog-checkbox-div\">
            <input id=\"{= ?cid }\" type=\"checkbox\"/>
            <span class=\"swa-checkbox-span\"> not extensible outside of this vocabulary</span>
        </div>
        <div class=\"swa-dialog-button-bar\">
            <button class=\"btn btn-default btn-xs\" onclick=\"handleClick{= ?aid }()\" swacontext=\"{= ui:encodeContext() }\">OK</button>
            <swa:Space/>
            <button class=\"btn btn-default btn-xs\" onclick=\"swa.closeDialog('{= ?loadId }')\">Cancel</button>
        </div>
        <script>$(\"#tabsDIV\").tabs();
$(\"#{= ?pid }\").on('input', function() { {= ui:functionCall(\"swa.updatePathError\", ui:currentQueryGraph(), ?pid, CONCAT(?pid, \"-error\")) } });
function handleClick{= ?aid }() {
	var tab = $('#tabsDIV').tabs(\"option\", \"active\");
	var predicate = $('#{= ?aid }').val();
	var path = $('#{= ?pid }').val();
	if((tab == 0 &amp;&amp; predicate &amp;&amp; predicate != '') || (path &amp;&amp; path != '' &amp;&amp; $('#{= ?pid }-error').text().length == 0)) {
		swa.createPropertyConstraintWorker('{= ?shape }', $('#{= ?aid }').val(),
			$('#{= ?cid }').is(':checked'), $('#{= ?iid }').is(':checked'), path,
			'{= ?resourceSelectedEvent }'); swa.closeDialog('{= ?loadId }');
	}
}</script>
    </ui:if>
    <ui:else>
        <div>The current vocabulary does not include the SHACL namespace.</div>
    </ui:else>
</div>
"""^^ui:Literal ;
  rdfs:comment "A dialog that can be used to create a sh:PropertyShape." ;
  rdfs:subClassOf swa:DialogElements ;
.
swa:CreatePropertyConstraintService
  a ui:Service ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:inverse ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to create a sh:inversePath path." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:path ;
      spl:valueType xsd:string ;
      rdfs:comment "The SPARQL string as entered by the user." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:blankNode ;
      spl:valueType xsd:boolean ;
      rdfs:comment "true to create a blank node." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The sh:predicate in the constraint." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:shape ;
      spl:valueType sh:Shape ;
      rdfs:comment "The sh:Shape to host the new constraint." ;
    ] ;
  ui:prototype """
<ui:group let:path=\"{= IF((STRLEN(?path) = 0), ?none, ?path) }\">
    <ui:if ui:condition=\"{= bound(?path) }\">
        <ui:group let:error=\"{= swa:checkPathSyntax(?path) }\">
            <ui:if ui:condition=\"{= bound(?error) }\">
                <ui:throw ui:message=\"Invalid path argument {= ?error }\"/>
            </ui:if>
        </ui:group>
    </ui:if>
    <ui:group let:propertyShape=\"{= IF(?blankNode, BNODE(), IF(bound(?path), swa:newResource(IRI(CONCAT(str(?shape), &quot;-PATH&quot;))), swa:createPropertyShapeURI(?inverse, ?predicate, ?shape))) }\">
        <ui:transaction ui:logMessage=\"Create property shape on {= COALESCE(?path, ui:label(?predicate)) } at {= ui:label(?shape) }\" ui:metadata=\"{ createdResource : '{= swa:unwrap(ui:encodeNode(?propertyShape, true, true)) }' }\">
            <ui:if ui:condition=\"{= !spl:instanceOf(?shape, sh:NodeShape) }\">
                <ui:update ui:updateQuery=\"{!
                        INSERT {
                            ?shape a sh:NodeShape .
                        }
                        WHERE {
                        } }\"/>
            </ui:if>
            <ui:update ui:updateQuery=\"{!
                    INSERT {
                        ?shape sh:property ?propertyShape .
                        ?propertyShape a sh:PropertyShape .
                    }
                    WHERE {
                    } }\"/>
            <ui:if ui:condition=\"{= bound(?path) }\">
                <tosh.ui:parsePath arg:string=\"{= ?path }\" arg:targetGraph=\"{= ui:tempGraph }\">
                    <ui:update ui:updateQuery=\"{!
                            INSERT {
                                ?s ?p ?o .
                            }
                            WHERE {
                                GRAPH ui:tempGraph {
                                    ?s ?p ?o .
                                } .
                            } }\"/>
                    <ui:update ui:updateQuery=\"{!
                            INSERT {
                                ?propertyShape sh:path ?pathRoot .
                            }
                            WHERE {
                            } }\"/>
                </tosh.ui:parsePath>
            </ui:if>
            <ui:elseif ui:condition=\"{= ?inverse }\">
                <ui:update ui:updateQuery=\"{!
                        INSERT {
                            ?propertyShape sh:path ?path .
                            ?path sh:inversePath ?predicate .
                        }
                        WHERE {
                            BIND (BNODE() AS ?path) .
                        } }\"/>
            </ui:elseif>
            <ui:else>
                <ui:update ui:updateQuery=\"{!
                        INSERT {
                            ?propertyShape sh:path ?predicate .
                        }
                        WHERE {
                        } }\"/>
            </ui:else>
        </ui:transaction>
    </ui:group>
</ui:group>
"""^^ui:Literal ;
  rdfs:label "Create property constraint service" ;
  rdfs:subClassOf ui:JSONServices ;
.
swa:CreatePropertyHandler
  a ui:NodeClass ;
  ui:prototype """
<ui:transaction ui:logMessage=\"Create {= ui:label(?resourceType) } with URI {= ?uri }\" ui:metadata=\"{= ?metadata }\">
    <ui:preCondition let:property=\"{= IRI(str(?uri)) }\" ui:errorMessage=\"{= COALESCE(swa:labelExistsPreCondition(?label), swa:validURIPreCondition(?uri), swa:unusedURIPreCondition(IRI(str(?uri)))) }\">
        <ui:update ui:updateQuery=\"{!
                INSERT {
                    ?property a ?resourceType .
                    ?property rdfs:label ?prefLabel .
                }
                WHERE {
                    BIND (IF(bound(?labelLang), STRLANG(?label, ?labelLang), ?label) AS ?prefLabel) .
                } }\"/>
        <swa:setDomain arg:domain=\"{= IF(spl:instanceOf(?contextResource, rdfs:Class), ?contextResource, spl:object(?contextResource, rdfs:domain)) }\" ui:this=\"{= ?property }\"/>
        <swa:createPrimaryKeyTriple ui:args=\"*\"/>
        <swa:addDefaultValues arg:resource=\"{= ?property }\"/>
    </ui:preCondition>
</ui:transaction>
"""^^ui:Literal ;
  rdfs:comment "Creates a new property. The ?resourceType should be something like owl:DatatypeProperty or owl:ObjectProperty and the ?contextResource must point to either a class or a property that has an rdfs:domain." ;
  rdfs:label "Create property handler" ;
  rdfs:subClassOf swa:CreateHandlers ;
.
swa:CreateResourceButton
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:defaultValue swa:CreateResourceHandler ;
      spl:optional true ;
      spl:predicate arg:createHandler ;
      spl:valueType ui:NodeClass ;
      rdfs:comment "The handler to call for actual creation - must be a subclass of swa:CreateHandlers." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:class ;
      spl:valueType xsd:string ;
      rdfs:comment "An extra CSS class for the button. If this contains Bootstrap's \"btn\", the SWA styling will be suppressed." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:classSelectedEvent ;
      spl:valueType xsd:string ;
      rdfs:comment "The event to send if this is creating a class." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:contextResourceGetter ;
      spl:valueType xsd:string ;
      rdfs:comment "A JS expression that delivers the (optional) context resource that will be passed into the create dialog and handler. For example this may be a JavaScript function call that delivers the currently selected class or parent in a tree." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:disabled ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to disable the button." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:iconClass ;
      spl:valueType xsd:string ;
      rdfs:comment "The CSS class for the icon." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:id ;
      spl:valueType xsd:string ;
      rdfs:comment "Unique ID for this button. Among other things, will be used for the id attribute on the generated HTML element." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:label ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional label for the button. Either label or icon should be specified." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:resourceSelectedEvent ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of an event to fire if the new resource has been created." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:resourceTypeLabel ;
      spl:valueType xsd:string ;
      rdfs:comment "A label describing the resource that will be created, e.g. \"Concept\" or \"Class\". Will be inserted into the button's tool tip. If left blank, the ui:label of the ?resourceType will be used." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:suppressTypeSelection ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to disallow selecting the subclasses of the resource type (even if a subclass exists)." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:toolTip ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional tool tip text." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:useContextResourceAsType ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to use the context resource as resourceType." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The type of resource to create." ;
    ] ;
  ui:prototype """
<ui:group let:id2=\"{= COALESCE(?id, ui:uniqueId()) }\" let:typeLabel=\"{= COALESCE(?resourceTypeLabel, ui:label(?resourceType)) }\">
    <swa:Button arg:class=\"{= IF((bound(?class) &amp;&amp; CONTAINS(?class, &quot;btn-default&quot;)), &quot;&quot;, &quot;btn btn-default btn-xs &quot;) }{= ?class }\" arg:disabled=\"{= ?disabled }\" arg:iconClass=\"{= ?iconClass }\" arg:id=\"{= ?id2 }\" arg:label=\"{= ?label }\" arg:onClick=\"swa.openCreateResourceDialog('create-{= ?id2 }-dialog', {= COALESCE(?contextResourceGetter, &quot;null&quot;) }, {= bound(?useContextResourceAsType) &amp;&amp; ?useContextResourceAsType })\" arg:overlayImage=\"{= ui:lib() }/assets/build/images/CreateOverlay.png\" arg:toolTip=\"{= COALESCE(?toolTip, CONCAT(&quot;Create &quot;, ?typeLabel, &quot;...&quot;)) }\"/>
    <ui:group let:loadId=\"create-{= ?id2 }-dialog\">
        <ui:loadable class=\"swa-float-left\" ui:loadId=\"{= ?loadId }\" ui:loadOnDemand=\"{= true }\">
            <swa:CreateResourceDialog arg:callback=\"swa.createResource\" arg:contextResource=\"{= ?contextResource }\" arg:createHandler=\"{= COALESCE(?createHandler, swa:CreateResourceHandler) }\" arg:label=\"Create {= ?typeLabel }\" arg:loadId=\"{= ?loadId }\" arg:resourceSelectedEvent=\"{= ?resourceSelectedEvent }\" arg:resourceType=\"{= ?resourceType }\" arg:suppressTypeSelection=\"{= ?suppressTypeSelection }\"/>
        </ui:loadable>
    </ui:group>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "A button that opens a dialog to create a resource. Once the dialog is done, the new resource will be \"selected\" by issuing an event." ;
  rdfs:label "Create resource button" ;
  rdfs:subClassOf swa:ButtonElements ;
.
swa:CreateResourceDialog
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:classSelectedEvent ;
      spl:valueType xsd:string ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:contextResource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The (optional) context resource that will be passed into the create handler." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:createHandler ;
      spl:valueType ui:NodeClass ;
      rdfs:comment "A subclass of swa:CreateResourceHandler that shall be called when the dialog completes. This only needs to be specified if the callback is the default function swa.createResource()." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:label ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional label to override the default label \"Create <label-of-type>\"." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:resourceSelectedEvent ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional event that shall be published after the new resource has been created. The payload of this event will be the new URI." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:suppressTypeSelection ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to suppress the type selection box." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:callback ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of a JavaScript function that shall be called if the user Oks the dialog. This must take arguments as: function(typeURI, resourceURI, label, labelLang) where label and labelLang are optional." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:loadId ;
      spl:valueType xsd:string ;
      rdfs:comment "The ui:loadId of the resulting ui:loadable." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The type of resource to create. If the type has subclasses, then a drop down box is displaying those alternatives." ;
    ] ;
  ui:private true ;
  ui:prototype """
<div id=\"div-{= ?loadId }\" title=\"{= COALESCE(?label, CONCAT(&quot;Create &quot;, ui:label(?resourceType))) }\">
    <ui:group let:context=\"{= ui:contextValue(&quot;swaAppName&quot;) }\">
        <!--ui:dumpScope ui:message=\"AAA1: swa:CreateResourceDialog\"/-->
        <!-- TODO: when there is a global config parameter set up to exclude specific collection types, use it here -->
        <ui:group let:ignoreURIconfigParameters=\"{= false }\">
            <form id=\"form-{= ?loadId }\">
                <ui:if ui:condition=\"{= ?ignoreURIconfigParameters }\">
                    <swa:CreateResourceDialogBody ui:args=\"*\"/>
                </ui:if>
                <ui:else>
                    <swa:CreateResourceDialogBodyForAssetCollection ui:args=\"*\"/>
                </ui:else>
            </form>
            <div class=\"swa-dialog-button-bar\">
                <button class=\"btn btn-default btn-xs\" disabled=\"{= IF((bound(?resourceType) &amp;&amp; swa:isAbstractClass(?resourceType)), &quot;disabled&quot;, ?none) }\" id=\"createResourceDialogOkButton\" onclick=\"{= ?callback }($('#type-select').val(), $('#uri-input').val(), $('#label-input').val(), $('#label-lang').val(), {= IF(bound(?contextResource), CONCAT(&quot;'&quot;, xsd:string(?contextResource), &quot;'&quot;), &quot;null&quot;) }, {= IF(bound(?createHandler), CONCAT(&quot;'&quot;, xsd:string(?createHandler), &quot;'&quot;), &quot;null&quot;) }, {= IF(bound(?resourceSelectedEvent), CONCAT(&quot;'&quot;, ?resourceSelectedEvent, &quot;'&quot;), &quot;null&quot;) }, 'createResourceDialogOkButton', {= IF(bound(?classSelectedEvent), CONCAT(&quot;'&quot;, ?classSelectedEvent, &quot;'&quot;), &quot;null&quot;) },'{= ?loadId }');swa.closeDialog('{= ?loadId }');\" swacontext=\"{= ui:encodeContext() }\">OK</button>
                <swa:Space/>
                <button class=\"btn btn-default btn-xs\" onclick=\"swa.closeDialog('{= ?loadId }')\">Cancel</button>
            </div>
        </ui:group>
    </ui:group>
</div>
"""^^ui:Literal ;
  rdfs:comment "A dialog that can be used to create a new instance of a given class. By default the dialog presents input fields for the new URI, the label and a select box for the type, if subclasses exist. The actual contents and behavior of this dialog can however be customized via a plug-in mechanism." ;
  rdfs:label "Create resource dialog" ;
  rdfs:subClassOf swa:DialogElements ;
.
swa:CreateResourceDialogBody
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:contextResource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The (optional) context resource that will be passed into the create handler." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:createHandler ;
      spl:valueType ui:NodeClass ;
      rdfs:comment "A subclass of swa:CreateResourceHandler that shall be called when the dialog completes. This only needs to be specified if the callback is the default function swa.createResource()." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:label ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional label to override the default label \"Create <label-of-type>\"." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:resourceSelectedEvent ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional event that shall be published after the new resource has been created. The payload of this event will be the new URI." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:suppressTypeSelection ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to suppress the type selection box." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:callback ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of a JavaScript function that shall be called if the user Oks the dialog. This must take arguments as: function(typeURI, resourceURI, label, labelLang) where label and labelLang are optional." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:ignoreURIconfigParameters ;
      spl:valueType xsd:boolean ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:loadId ;
      spl:valueType xsd:string ;
      rdfs:comment "The ui:loadId of the resulting ui:loadable." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The type of resource to create. If the type has subclasses, then a drop down box is displaying those alternatives." ;
    ] ;
  ui:private true ;
  ui:prototype """
<div id=\"div-{= ?loadId }\" title=\"{= COALESCE(?label, CONCAT(&quot;Create &quot;, ui:label(?resourceType))) }\">
    <ui:dynamicView arg:contextResource=\"{= ?contextResource }\" arg:resourceType=\"{= ?resourceType }\" arg:suppressTypeSelection=\"{= ?suppressTypeSelection }\" ui:class=\"{= COALESCE(swa:bestCreateResourceDialogPlugin(?contextResource, ?resourceType), swa:DefaultCreateResourceDialogPlugin) }\"/>
    <div class=\"swa-dialog-button-bar\">
        <button class=\"btn btn-default btn-xs\" disabled=\"{= IF((bound(?resourceType) &amp;&amp; swa:isAbstractClass(?resourceType)), &quot;disabled&quot;, ?none) }\" id=\"createResourceDialogOkButton\" onclick=\"{= ?callback }($('#type-select').val(), $('#uri-input').val(), $('#label-input').val(), $('#label-lang').val(), {= IF(bound(?contextResource), CONCAT(&quot;'&quot;, xsd:string(?contextResource), &quot;'&quot;), &quot;null&quot;) }, {= IF(bound(?createHandler), CONCAT(&quot;'&quot;, xsd:string(?createHandler), &quot;'&quot;), &quot;null&quot;) }, {= IF(bound(?resourceSelectedEvent), CONCAT(&quot;'&quot;, ?resourceSelectedEvent, &quot;'&quot;), &quot;null&quot;) }, 'createResourceDialogOkButton', {= IF(bound(?classSelectedEvent), CONCAT(&quot;'&quot;, ?classSelectedEvent, &quot;'&quot;), &quot;null&quot;) });swa.closeDialog('{= ?loadId }');\" swacontext=\"{= ui:encodeContext() }\">OK</button>
        <swa:Space/>
        <button class=\"btn btn-default btn-xs\" onclick=\"swa.closeDialog('{= ?loadId }')\">Cancel</button>
    </div>
</div>
"""^^ui:Literal ;
  rdfs:comment "Create dialog that can be used to create a new resource for the type-in-focus. By default the dialog presents input fields for the new URI, the label and a select box for the type, if subclasses exist. The actual contents and behavior of this dialog can however be customized via a plug-in mechanism." ;
  rdfs:label "Create resource dialog" ;
  rdfs:subClassOf swa:DialogElements ;
.
swa:CreateResourceDialogBodyForAssetCollection
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:contextResource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The (optional) context resource that will be passed into the create handler." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:createHandler ;
      spl:valueType ui:NodeClass ;
      rdfs:comment "A subclass of swa:CreateResourceHandler that shall be called when the dialog completes. This only needs to be specified if the callback is the default function swa.createResource()." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:label ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional label to override the default label \"Create <label-of-type>\"." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:resourceSelectedEvent ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional event that shall be published after the new resource has been created. The payload of this event will be the new URI." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:suppressTypeSelection ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to suppress the type selection box." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:callback ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of a JavaScript function that shall be called if the user Oks the dialog. This must take arguments as: function(typeURI, resourceURI, label, labelLang) where label and labelLang are optional." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:loadId ;
      spl:valueType xsd:string ;
      rdfs:comment "The ui:loadId of the resulting ui:loadable." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The type of resource to create. If the type has subclasses, then a drop down box is displaying those alternatives." ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:setContext ui:varName=\"rootType\" ui:varValue=\"{= ?resourceType }\">
    <ui:loadable let:nonAbstractClassDynamicView=\"{= COALESCE(swa:bestCreateResourceDialogPlugin(?contextResource, ?resourceType), swa:DefaultCreateResourceDialogPluginForAssetCollection) }\" ui:loadId=\"create-resource-dialog-body\">
        <!--ui:dumpScope ui:message=\"AAA1: swa:CreateResourceDialogBodyForAssetCollection\"/-->
        <ui:dynamicView arg:contextResource=\"{= ?contextResource }\" arg:resourceType=\"{= ?resourceType }\" arg:suppressTypeSelection=\"{= ?suppressTypeSelection }\" ui:class=\"{= ?nonAbstractClassDynamicView }\"/>
    </ui:loadable>
</ui:setContext>
"""^^ui:Literal ;
  rdfs:comment "Create dialog that can be used to create a new resource for the type-in-focus. By default the dialog presents input fields for the new URI, the label and a select box for the type, if subclasses exist. The actual contents and behavior of this dialog can however be customized via a plug-in mechanism." ;
  rdfs:label "Create resource dialog (EDG)" ;
  rdfs:subClassOf swa:DialogElements ;
.
swa:CreateResourceDialogJSON
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:contextResource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The (optional) context resource that will be passed into the create handler." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:createHandler ;
      spl:valueType ui:NodeClass ;
      rdfs:comment "A subclass of swa:CreateResourceHandler that shall be called when the dialog completes. This only needs to be specified if the callback is the default function swa.createResource()." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:label ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional label to override the default label \"Create <label-of-type>\"." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:resourceSelectedEvent ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional event that shall be published after the new resource has been created. The payload of this event will be the new URI." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:suppressTypeSelection ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to suppress the type selection box." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:callback ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of a JavaScript function that shall be called if the user Oks the dialog. This must take arguments as: function(typeURI, resourceURI, label, labelLang) where label and labelLang are optional." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:loadId ;
      spl:valueType xsd:string ;
      rdfs:comment "The ui:loadId of the resulting ui:loadable." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The type of resource to create. If the type has subclasses, then a drop down box is displaying those alternatives." ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:setContext ui:varName=\"rootType\" ui:varValue=\"{= ?resourceType }\">
    <ui:loadable ui:loadId=\"create-resource-dialog-body\">
        <ui:group let:myClass=\"{= COALESCE(swa:bestCreateResourceDialogPlugin(?contextResource, ?resourceType), swa:DefaultCreateResourceDialogPluginForAssetCollection) }\">
            <!--ui:dumpScope ui:message=\"AAA1: swa:CreateResourceDialogJSON\"/-->
            <div>
                <ui:dynamicView arg:contextResource=\"{= ?contextResource }\" arg:resourceType=\"{= ?resourceType }\" arg:suppressTypeSelection=\"{= ?suppressTypeSelection }\" ui:class=\"{= ?myClass }\"/>
            </div>
        </ui:group>
    </ui:loadable>
</ui:setContext>
"""^^ui:Literal ;
  rdfs:comment "A dialog that can be used to create a new instance of a given class. By default the dialog presents input fields for the new URI, the label and a select box for the type, if subclasses exist. The actual contents and behavior of this dialog can however be customized via a plug-in mechanism." ;
  rdfs:label "Create resource dialog" ;
  rdfs:subClassOf swa:DialogElements ;
.
swa:CreateResourceDialogPlugin
  a rdfs:Class ;
  rdfs:comment """The class of plugins that can declare alternative ways of creating new resources. Each of those plugins needs to have HTML input fields (possibly hidden) that bind the following HTML ids:
- \"label-input\": the human-readable label of the resource
- \"label-lang\": the optional language tag for the label
- \"uri-input\": the URI of the resource
- \"type-select\": the URI of the selected type
Any of those can be hidden values for example to auto-generate URIs based on UUIDs or derive them from the type. Only label and language may be empty (although leaving the label empty is discouraged).""" ;
  rdfs:label "Create resource dialog plugin" ;
  rdfs:subClassOf ui:NodeClass ;
.
swa:CreateResourceDialogPlugins
  a swa:CreateResourceDialogPlugin ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:contextResource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The (optional) context resource that will be passed into the create handler." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:suppressTypeSelection ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to suppress the type selection box." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The type of resource being created." ;
    ] ;
  ui:abstract true ;
  rdfs:comment "Abstract base class of plugins that can implement alternative ways of defining label and URI of new resources." ;
  rdfs:label "Create resource dialog plugins" ;
  rdfs:subClassOf swa:DialogElements ;
.
swa:CreateResourceDialogTypeSelectionPanel
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:suppressTypeSelection ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to suppress the type selection box." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The type of resource being created." ;
    ] ;
  ui:prototype """
<ui:group let:rootType=\"{= ui:contextValue(&quot;rootType&quot;) }\">
    <ui:group let:constrainType=\"{= COALESCE(?rootType, ?resourceType) }\">
        <ui:if ui:condition=\"{= ((!bound(?suppressTypeSelection)) || (!?suppressTypeSelection)) &amp;&amp; spl:hasValue(?any, rdfs:subClassOf, ?constrainType) }\">
            <swa:LabeledElement arg:label=\"Type:\">
                <select autocomplete=\"off\" class=\"form-control\" id=\"type-select\" onchange=\"swa.updateCreateResourceDialog()\">
                    <option disabled=\"disabled\" value=\"\"/>
                    <ui:forEach ui:resultSet=\"{#
                            SELECT DISTINCT ?resourceLabel ?class ?primary
                            WHERE {
                                ?class (rdfs:subClassOf)* ?constrainType .
                                BIND (ui:label(?class) AS ?resourceLabel) .
                                BIND (swa:hasPrimaryKey(?class) AS ?primary) .
                                FILTER (!swa:isAbstractClass(?class)) .
                            }
                            ORDER BY (?resourceLabel) }\">
                        <option selected=\"{= IF((?resourceType = ?class), &quot;selected&quot;, ?none) }\" value=\"{= IF(?primary, &quot;-&quot;, ?none) }{= ?class }\">{= ?resourceLabel }{= IF(?primary, \" (*)\", ?none) }</option>
                    </ui:forEach>
                </select>
                <script>var selected_option = $('#type-select option:selected');
				if(selected_option[0].value !== \"\"){
					$('#type-select option[value=\"\"]').remove();
				}</script>
            </swa:LabeledElement>
        </ui:if>
        <ui:else>
            <input data-ref=\"{= ui:label(?resourceType) }\" id=\"type-select\" type=\"hidden\" value=\"{= ?resourceType }\"/>
        </ui:else>
    </ui:group>
</ui:group>
"""^^ui:Literal ;
  rdfs:label "Create resource dialog type selection panel" ;
  rdfs:subClassOf swa:DialogElements ;
.
swa:CreateResourceDialogTypeSelectionPanelForAssetCollection
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:suppressTypeSelection ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to suppress the type selection box." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The type of resource being created." ;
    ] ;
  ui:prototype """
<ui:group let:rootType=\"{= ui:contextValue(&quot;rootType&quot;) }\">
    <ui:group let:constrainType=\"{= COALESCE(?rootType, ?resourceType) }\">
        <!--ui:dumpScope ui:message=\"AAA: swa:CreateResourceDialogTypeSelectionPanel\"/-->
        <ui:if ui:condition=\"{= ((!bound(?suppressTypeSelection)) || (!?suppressTypeSelection)) &amp;&amp; spl:hasValue(?any, rdfs:subClassOf, ?constrainType) }\">
            <swa:LabeledElement arg:label=\"Type:\">
                <select autocomplete=\"off\" class=\"form-control\" id=\"type-select\" onchange=\"swa.updateCreateResourceDialogForAssetCollections()\">
                    <option data-abstract=\"true\" disabled=\"disabled\" selected=\"false\">Select {= ui:label(?resourceType) } type</option>
                    <ui:forEach ui:resultSet=\"{#
                            SELECT DISTINCT ?resourceLabel ?class ?primary
                            WHERE {
                                {
                                    ?class (rdfs:subClassOf)* ?constrainType .
                                    FILTER ((!swa:isAbstractClass(?class)) &amp;&amp; NOT EXISTS {
                                        ?class swa:editingProhibited true .
                                    }) .
                                } .
                                BIND (ui:label(?class) AS ?resourceLabel) .
                                BIND (swa:hasPrimaryKey(?class) AS ?primary) .
                            }
                            ORDER BY (?resourceLabel) }\">
                        <option selected=\"{= IF((?resourceType = ?class), &quot;selected&quot;, ?none) }\" value=\"{= IF(?primary, &quot;-&quot;, ?none) }{= ?class }\">{= ?resourceLabel }{= IF(?primary, \" (*)\", ?none) }</option>
                    </ui:forEach>
                </select>
            </swa:LabeledElement>
        </ui:if>
        <ui:else>
            <input data-ref=\"{= ui:label(?resourceType) }\" id=\"type-select\" type=\"hidden\" value=\"{= ?resourceType }\"/>
        </ui:else>
    </ui:group>
</ui:group>
"""^^ui:Literal ;
  rdfs:label "Create resource dialog type selection panel for asset collection" ;
  rdfs:subClassOf swa:DialogElements ;
.
swa:CreateResourceDialogUsingCustom
  a swa:CreateResourceDialogPlugin ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate swa:resourceURIconstructorFunction ;
      spl:valueType rdfs:Resource ;
    ] ;
  ui:prototype """
<ui:group>
    <ui:loadable ui:loadId=\"create-resource-dialog-body\">
        <!--ui:dumpScope ui:message=\"AAA: swa:CreateResourceDialogUsingLabel\"/-->
        <swa:LabeledElement arg:label=\"Label:\">
            <input autocomplete=\"off\" class=\"form-control swa-create-resource-label-input\" id=\"label-input\" type=\"text\"/>
            <swa:LangSelector arg:uid=\"label\"/>
        </swa:LabeledElement>
        <swa:URIField arg:resourceType=\"{= ?resourceType }\" arg:resourceURI=\"http://your.namespace.com#\"/>
        <input data-property=\"contextResource\" type=\"hidden\" value=\"{= ?contextResource }\"/>
    </ui:loadable>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "A create dialog for resources that has an empty input area for custom URI." ;
  rdfs:label "Create resource dialog using custom" ;
  rdfs:subClassOf swa:CreateResourceDialogPlugins ;
  rdfs:subClassOf swa:DialogElements ;
.
swa:CreateResourceDialogUsingLabel
  a swa:CreateResourceDialogPlugin ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate swa:resourceURIconstructorFunction ;
      spl:valueType rdfs:Resource ;
    ] ;
  ui:prototype """
<ui:group let:resourceSpecificConstructor=\"{= swa:getClassPropertyValue(?resourceType, swa:resourceURIconstructorFunction) }\">
    <ui:loadable let:resourceURIconstructor=\"{= COALESCE(?resourceURIconstructorFunction, ?resourceSpecificConstructor, swa:newResourceUsingLabelForAssetCollection) }\" ui:loadId=\"create-resource-dialog-body\">
        <!--ui:dumpScope ui:message=\"AAA: swa:CreateResourceDialogUsingLabel\"/-->
        <swa:LabeledElement arg:label=\"Label:\">
            <input autocomplete=\"off\" class=\"form-control swa-create-resource-label-input\" id=\"label-input\" type=\"text\"/>
            <swa:LangSelector arg:uid=\"label\"/>
        </swa:LabeledElement>
        <swa:URIFieldForAssetCollection arg:resourceType=\"{= ?resourceType }\"/>
        <input data-property=\"contextResource\" type=\"hidden\" value=\"{= ?contextResource }\"/>
        <script>swa.initCreateResourceLabelFieldForAssetCollection('label-input', 'uri-input','{= swa:newResourceForAssetCollection(?resourceType) }',true)</script>
    </ui:loadable>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "A create dialog for resources that use the label string for the URI." ;
  rdfs:label "Create resource dialog using label" ;
  rdfs:subClassOf swa:CreateResourceDialogPlugins ;
.
swa:CreateResourceHandler
  a ui:NodeClass ;
  ui:private true ;
  ui:prototype """
<ui:transaction ui:checkConstraints=\"{= true }\" ui:logMessage=\"Create {= ui:label(?resourceType) } with URI {= ?uri }\" ui:metadata=\"{= ?metadata }\">
    <!--ui:dumpScope ui:message=\"AAA1: swa:CreateResourceHandler\"/-->
    <ui:preCondition ui:errorMessage=\"{= COALESCE(swa:labelExistsPreCondition(?label), swa:URIExistsPreCondition(?uri), swa:validURIPreCondition(?uri), swa:unusedURIPreCondition(IRI(str(?uri))), swa:nonEmptyPrimaryKeyPreCondition(?resourceType, IRI(str(?uri))), swa:nonAbstractClassPreCondition(?resourceType)) }\">
        <ui:preCondition ui:errorMessage=\"{= IF(spl:hasValue(?resourceType, owl:oneOf), &quot;Cannot create new instances of a class with an owl:oneOf&quot;, ?none) }\">
            <ui:update ui:updateQuery=\"{!
                    INSERT {
                        ?resource a ?resourceType .
                        ?resource ?labelProperty ?prefLabel .
                    }
                    WHERE {
                        BIND (IRI(str(?uri)) AS ?resource) .
                        BIND (IF(bound(?labelLang), STRLANG(?label, ?labelLang), ?label) AS ?prefLabel) .
                        BIND (swa:labelProperty(?resourceType) AS ?labelProperty) .
                    } }\"/>
            <swa:createPrimaryKeyTriple ui:args=\"*\"/>
            <swa:addDefaultValues arg:resource=\"{= IRI(str(?uri)) }\"/>
        </ui:preCondition>
    </ui:preCondition>
</ui:transaction>
"""^^ui:Literal ;
  rdfs:comment "The updates that need to happen to create a new resource with a given type." ;
  rdfs:label "Create resource handler" ;
  rdfs:subClassOf swa:CreateHandlers ;
.
swa:CreateResourceService
  a rdfs:Class ;
  rdfs:comment "Metaclass of services that create a new row for an swa:EditableGridGadget." ;
  rdfs:label "Create resource service" ;
  rdfs:subClassOf ui:Service ;
.
swa:CreateResourceServices
  a swa:CreateResourceService ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The default resource type used by the surrounding grid." ;
    ] ;
  ui:abstract true ;
  rdfs:label "Create resource services" ;
  rdfs:subClassOf ui:JSONServices ;
.
swa:CreateResourceWithPrimaryKeyDialogPlugin
  a swa:CreateResourceDialogPlugin ;
  ui:prototype """
<ui:group let:primaryKey=\"{= swa:primaryKeyProperty(?resourceType) }\">
    <swa:CreateResourceDialogTypeSelectionPanel arg:resourceType=\"{= ?resourceType }\" arg:suppressTypeSelection=\"{= ?suppressTypeSelection }\"/>
    <swa:LabeledElement arg:label=\"Label:\">
        <input autocomplete=\"off\" class=\"form-control swa-create-resource-label-input\" id=\"label-input\" type=\"text\"/>
        <script>swa.initCreateResourceLabelFieldEnter('label-input')</script>
        <swa:LangSelector arg:uid=\"label\"/>
    </swa:LabeledElement>
    <swa:LabeledElement arg:label=\"{= ui:label(?primaryKey) }:\">
        <input class=\"form-control\" id=\"id-input\" type=\"text\"/>
        <script>{= ui:functionCall(\"swa.initCreateResourcePrimaryKeyField\", \"id-input\", swa:primaryKeyURIStart(?resourceType)) }</script>
    </swa:LabeledElement>
    <swa:LabeledElement arg:label=\"Identifier:\">
        <input class=\"form-control swa-uri-field swa-create-resource-with-primary-key-dialog-plugin-identifier\" disabled=\"disabled\" id=\"uri-input\" type=\"text\" value=\"{= swa:primaryKeyURIStart(?resourceType) }\"/>
    </swa:LabeledElement>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "A create resource dialog with a required field for the primary key property - that ID is used to produce URIs. This is used by default if the resourceType declares a primary key using spl:PrimaryKeyPropertyConstraint." ;
  rdfs:label "Create resource with primary key dialog plugin" ;
  rdfs:subClassOf swa:CreateResourceDialogPlugins ;
.
swa:CreateResourceWithPrimaryKeyDialogPluginJSONFields
  a swa:CreateResourceDialogPlugin ;
  ui:prototype """
<ui:group let:primaryKey=\"{= swa:primaryKeyProperty(?resourceType) }\">
    <swa:CreateResourceDialogTypeSelectionPanel arg:resourceType=\"{= ?resourceType }\" arg:suppressTypeSelection=\"{= ?suppressTypeSelection }\"/>
    <swa:LabeledElement arg:label=\"Label:\">
        <input autocomplete=\"off\" class=\"form-control swa-create-resource-label-input\" id=\"label-input\" type=\"text\"/>
        <script>swa.initCreateResourceLabelFieldEnter('label-input')</script>
        <swa:LangSelector arg:uid=\"label\"/>
    </swa:LabeledElement>
    <swa:LabeledElement arg:label=\"{= ui:label(?primaryKey) }:\">
        <input class=\"form-control\" id=\"id-input\" type=\"text\"/>
        <script>{= ui:functionCall(\"swa.initCreateResourcePrimaryKeyField\", \"id-input\", swa:primaryKeyURIStart(?resourceType)) }</script>
    </swa:LabeledElement>
    <swa:LabeledElement arg:label=\"Identifier:\">
        <input class=\"form-control swa-uri-field swa-create-resource-with-primary-key-dialog-plugin-identifier\" disabled=\"disabled\" id=\"uri-input\" type=\"text\" value=\"{= swa:primaryKeyURIStart(?resourceType) }\"/>
    </swa:LabeledElement>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "A create resource dialog with a required field for the primary key property - that ID is used to produce URIs. This is used by default if the resourceType declares a primary key using spl:PrimaryKeyPropertyConstraint." ;
  rdfs:label "Create resource with primary key dialog plugin" ;
  rdfs:subClassOf swa:CreateResourceDialogPlugins ;
.
swa:DataTable
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:additionalClasses ;
      spl:valueType xsd:string ;
      rdfs:comment "Any additional classes to apply to the table's container element" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:columnsService ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:createResourceHandler ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:createService ;
      spl:valueType xsd:string ;
      rdfs:comment "The service to use when creating a record in a the table. Used in conjunction with editable config option" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:dtType ;
      spl:valueType xsd:string ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:editButton ;
      spl:valueType xsd:boolean ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:editable ;
      spl:valueType xsd:boolean ;
      rdfs:comment "Specifies if the table should have editing capabilities" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:exports ;
      spl:valueType xsd:boolean ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:filter ;
      spl:valueType xsd:boolean ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:hasCloneButton ;
      spl:valueType xsd:boolean ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:hasFixedHeader ;
      spl:valueType xsd:boolean ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:hasViewDetails ;
      spl:valueType xsd:boolean ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:hideIfEmpty ;
      spl:valueType xsd:boolean ;
      rdfs:comment """Hides the table if no data is returned. If you are setting this to true you need a sibling <div> element next to the data table with the class \"ui-helper-hidden-accessbile\" with whatever message you want to display.
for example:

<div class=\"ui-helper-hidden-accessible\">None</div>""" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:id ;
      spl:valueType xsd:string ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:multiSelect ;
      spl:valueType xsd:boolean ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:onlyExportVisibleColumns ;
      spl:valueType xsd:boolean ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:pageLength ;
      spl:valueType xsd:integer ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:resourceSelectedEvent ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of an event to publish when the user clicks on a result. The data payload of this event is the URI of the resource." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "Specifies the \"type\" when creating an entry in the table. Used in conjunction with editable config option" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:searchGraph ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:selectAll ;
      spl:valueType xsd:boolean ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:suppressLabelColumn ;
      spl:valueType xsd:boolean ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:dataEndpoint ;
      spl:valueType xsd:string ;
      rdfs:comment "The JSON service (viewClass) that provides the columns definition for the table" ;
    ] ;
  ui:prototype """
<div class=\"table-container {= ?additionalClasses }\" data-columns-endpoint=\"{= COALESCE(?columnsService, swa:DataTableSearchColumns) }\" data-create-service=\"{= COALESCE(?createService, swa:DefaultCreateResourceDialogPluginForAssetCollection) }\" data-create-service-handler=\"{= COALESCE(?createResourceHandler, swa:CreateResourceHandler) }\" data-datatable=\"true\" data-datatable-type=\"{= COALESCE(?dtType, &quot;dataTable&quot;) }\" data-editable=\"{= COALESCE(?editable, false) }\" data-endpoint=\"{= COALESCE(?dataEndpoint, swa:DataTableSearchResultsCallback) }\" data-has-clone-button=\"{= COALESCE(?hasCloneButton, ?nil) }\" data-has-edit-button=\"{= COALESCE(?editButton, ?nil) }\" data-has-exports=\"{= COALESCE(?exports, ?nil) }\" data-has-filter=\"{= COALESCE(?filter, ?nil) }\" data-has-fixed-header=\"{= COALESCE(?hasFixedHeader, ?nil) }\" data-has-select-all=\"{= COALESCE(?selectAll, ?nil) }\" data-hide-if-empty=\"{= COALESCE(?hideIfEmpty, ?nil) }\" data-multiselect=\"{= COALESCE(?multiSelect, ?nil) }\" data-only-export-visible-columns=\"{= COALESCE(?onlyExportVisibleColumns, ?nil) }\" data-page-length=\"{= COALESCE(?pageLength, ?nil) }\" data-resource-selected-event=\"{= COALESCE(?resourceSelectedEvent, ?nil) }\" data-resource-type=\"{= COALESCE(?resourceType, ?nil) }\" data-search-graph=\"{= COALESCE(?searchGraph, ?nil) }\" data-suppress-label-column=\"{= COALESCE(?suppressLabelColumn, ?nil) }\" data-viewable-details=\"{= COALESCE(?hasViewDetails, ?nil) }\" data-with-toolbar-config=\"{= COALESCE(?withToolbarConfig, ?nil) }\" id=\"{= COALESCE(?id, ui:uniqueId()) }\"/>
"""^^ui:Literal ;
  rdfs:comment """A standard DataTable usage:

<swa:DataTable
    arg:additionalClasses=\"my-custom-table\"
    arg:dataColumnsEndpoint=\"saf:getSearchColumnsService\"
    arg:dataEndpoint=\"saf:getSearchResultsService\"
    arg:editable=\"true\"
    arg:hasViewableDetails=\"true\"
    arg:createService=\"http://topbraid.org/swa#CreateResourceDialogJSON\"
    arg:hasSelectAll=\"true\"
    arg:resourceSelectedEvent=\"org.datasetapp.instanceSelected\"
    arg:resourceType=\"http://edg.topbraid.solutions/model/GlossaryViewpoint\"
    arg:searchGraph=\"urn:x-swp-session:2ad4720f-bb8e-4030-b48d-6b3b2b6ead9e\"
    arg:hasScrollCollapse=\"true\"/>""" ;
  rdfs:subClassOf swa:Elements ;
.
swa:DataTableResultSetColumnsJSON
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:columns ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:suppressLabelColumn ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to suppress the first column." ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:group>
    <ui:if ui:condition=\"{= bound(?columns) }\">
        <swon:Array>
            <swon:Object>
                <swon:Value arg:name=\"title\" arg:value=\"uri\"/>
                <swon:Value arg:name=\"data\" arg:value=\"uri\"/>
                <swon:Value arg:name=\"searchable\" arg:value=\"{= false }\"/>
                <swon:Value arg:name=\"visible\" arg:value=\"{= false }\"/>
                <swon:Value arg:name=\"orderable\" arg:value=\"{= false }\"/>
            </swon:Object>
            <ui:forEach ui:resultSet=\"{= ?rs }\">
                <swon:Object>
                    <swon:Value arg:name=\"title\" arg:value=\"{= IF((STRLEN(?propPath) &gt; 0), (REPLACE(?propPath, &quot;[.]&quot;, &quot; &quot;) + ui:label(?colName)), ui:label(?colName)) }\"/>
                    <swon:Value arg:name=\"data\" arg:value=\"{= IF((STRLEN(?propPath) &gt; 0), (REPLACE(?propPath, &quot;[.]&quot;, &quot; &quot;) + ui:label(?colName)), ui:label(?colName)) }\"/>
                    <swon:Value arg:name=\"defaultContent\" arg:value=\"\"/>
                    <ui:if ui:condition=\"{= ?numeric }\">
                        <swon:Value arg:name=\"type\" arg:value=\"num\"/>
                    </ui:if>
                    <ui:else>
                        <swon:Value arg:name=\"type\" arg:value=\"{= ?varName }\"/>
                    </ui:else>
                </swon:Object>
            </ui:forEach>
        </swon:Array>
    </ui:if>
    <ui:else>
        <swon:Object/>
    </ui:else>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "JSON representation of the of the columns for a DataTable generated from a resultSet" ;
  rdfs:label "Data table result set columns JSON" ;
  rdfs:subClassOf ui:JSONServices ;
.
swa:DataTableSearchColumns
  a spin:SelectTemplate ;
  spin:body [
      a sp:Select ;
      sp:orderBy (
          [
            sp:varName "columnIndex" ;
          ]
        ) ;
      sp:resultVariables (
          [
            sp:varName "colName" ;
          ]
          [
            sp:varName "numeric" ;
          ]
          [
            sp:varName "varName" ;
          ]
          [
            sp:varName "inverse" ;
          ]
          [
            sp:varName "isCount" ;
          ]
          [
            sp:varName "propPath" ;
          ]
          [
            sp:varName "qName" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Union ;
            sp:elements (
                (
                  [
                    a sp:Filter ;
                    sp:expression [
                        a sp:or ;
                        sp:arg1 [
                            a sp:not ;
                            sp:arg1 [
                                a sp:bound ;
                                sp:arg1 [
                                    sp:varName "suppressLabelColumn" ;
                                  ] ;
                              ] ;
                          ] ;
                        sp:arg2 [
                            a sp:not ;
                            sp:arg1 [
                                sp:varName "suppressLabelColumn" ;
                              ] ;
                          ] ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression "label" ;
                    sp:variable [
                        sp:varName "varName" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression -1 ;
                    sp:variable [
                        sp:varName "columnIndex" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression false ;
                    sp:variable [
                        sp:varName "isCount" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression "" ;
                    sp:variable [
                        sp:varName "propPath" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression [
                        a spl:objectInGraph ;
                        sp:arg1 [
                            sp:varName "search" ;
                          ] ;
                        sp:arg2 search:rootType ;
                        sp:arg3 [
                            sp:varName "searchGraph" ;
                          ] ;
                      ] ;
                    sp:variable [
                        sp:varName "rootType" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression [
                        a swa:labelInGraph ;
                        arg:resource [
                            sp:varName "rootType" ;
                          ] ;
                        arg:resourceGraph [
                            sp:varName "queryGraph" ;
                          ] ;
                      ] ;
                    sp:variable [
                        sp:varName "colName" ;
                      ] ;
                  ]
                )
                (
                  [
                    a sp:NamedGraph ;
                    sp:elements (
                        [
                          sp:object [
                              sp:varName "rootType" ;
                            ] ;
                          sp:predicate search:rootType ;
                          sp:subject [
                              sp:varName "search" ;
                            ] ;
                        ]
                        [
                          sp:object [
                              sp:varName "column" ;
                            ] ;
                          sp:predicate spin:column ;
                          sp:subject [
                              sp:varName "search" ;
                            ] ;
                        ]
                        [
                          sp:object [
                              sp:varName "columnIndex" ;
                            ] ;
                          sp:predicate spin:columnIndex ;
                          sp:subject [
                              sp:varName "column" ;
                            ] ;
                        ]
                        [
                          sp:object [
                              sp:varName "keyProperty" ;
                            ] ;
                          sp:predicate search:columnProperty ;
                          sp:subject [
                              sp:varName "column" ;
                            ] ;
                        ]
                        [
                          a sp:Bind ;
                          sp:expression [
                              a sp:exists ;
                              sp:elements (
                                  [
                                    sp:object search:InversePropertyColumn ;
                                    sp:predicate rdf:type ;
                                    sp:subject [
                                        sp:varName "column" ;
                                      ] ;
                                  ]
                                ) ;
                            ] ;
                          sp:variable [
                              sp:varName "inverse" ;
                            ] ;
                        ]
                        [
                          a sp:Bind ;
                          sp:expression [
                              a spl:hasValue ;
                              sp:arg1 [
                                  sp:varName "column" ;
                                ] ;
                              sp:arg2 search:columnType ;
                              sp:arg3 search:CountColumnType ;
                            ] ;
                          sp:variable [
                              sp:varName "isCount" ;
                            ] ;
                        ]
                      ) ;
                    sp:graphNameNode [
                        sp:varName "searchGraph" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression [
                        a swa:propertyLabelAtClassOrShapeInGraph ;
                        arg:property [
                            sp:varName "keyProperty" ;
                          ] ;
                        arg:theClassOrShape [
                            sp:varName "rootType" ;
                          ] ;
                        arg:theGraph [
                            sp:varName "queryGraph" ;
                          ] ;
                      ] ;
                    sp:variable [
                        sp:varName "colName" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression [
                        a swa:isNumericDatatype ;
                        arg:node [
                            a swa:localRangeAtClass ;
                            arg:class [
                                sp:varName "rootType" ;
                              ] ;
                            arg:property [
                                sp:varName "keyProperty" ;
                              ] ;
                          ] ;
                      ] ;
                    sp:variable [
                        sp:varName "numeric" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression [
                        a xsd:string ;
                        sp:arg1 [
                            sp:varName "keyProperty" ;
                          ] ;
                      ] ;
                    sp:variable [
                        sp:varName "varName" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression [
                        a smf:qname ;
                        sp:arg1 [
                            sp:varName "keyProperty" ;
                          ] ;
                      ] ;
                    sp:variable [
                        sp:varName "qNameRaw" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression [
                        a sp:if ;
                        sp:arg1 [
                            a sp:contains ;
                            sp:arg1 [
                                sp:varName "qNameRaw" ;
                              ] ;
                            sp:arg2 ":" ;
                          ] ;
                        sp:arg2 [
                            sp:varName "qNameRaw" ;
                          ] ;
                        sp:arg3 [
                            a sp:concat ;
                            sp:arg1 ":" ;
                            sp:arg2 [
                                sp:varName "qNameRaw" ;
                              ] ;
                          ] ;
                      ] ;
                    sp:variable [
                        sp:varName "qName" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression [
                        a search:propertyPath ;
                        arg:column [
                            sp:varName "column" ;
                          ] ;
                        arg:searchGraph [
                            sp:varName "searchGraph" ;
                          ] ;
                      ] ;
                    sp:variable [
                        sp:varName "propPath" ;
                      ] ;
                  ]
                )
              ) ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:suppressLabelColumn ;
      spl:valueType xsd:boolean ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:lang ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:queryGraph ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:searchGraph ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The graph containing the search:Search." ;
    ] ;
  spin:private true ;
  rdfs:label "Data table search columns" ;
  rdfs:subClassOf spin:SelectTemplates ;
.
swa:DataTableSearchColumnsJSON
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:queryGraph ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:searchGraph ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The graph containing the search:Search to execute." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:suppressLabelColumn ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to suppress the first column." ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:group>
    <ui:if ui:condition=\"{= bound(?searchGraph) }\">
        <ui:call arg:lang=\"{= ui:lang() }\" arg:queryGraph=\"{= COALESCE(?queryGraph, swa:GetQueryGraphFromSearchGraph(?searchGraph)) }\" arg:searchGraph=\"{= ?searchGraph }\" arg:suppressLabelColumn=\"{= ?suppressLabelColumn }\" ui:template=\"{= swa:DataTableSearchColumns }\">
            <swon:Array>
                <swon:Object>
                    <swon:Value arg:name=\"title\" arg:value=\"uri\"/>
                    <swon:Value arg:name=\"data\" arg:value=\"uri\"/>
                    <swon:Value arg:name=\"searchable\" arg:value=\"{= false }\"/>
                    <swon:Value arg:name=\"visible\" arg:value=\"{= false }\"/>
                    <swon:Value arg:name=\"orderable\" arg:value=\"{= false }\"/>
                </swon:Object>
                <ui:forEach ui:resultSet=\"{= ?rs }\">
                    <swon:Object>
                        <swon:Value arg:name=\"defaultContent\" arg:value=\"\"/>
                        <ui:if ui:condition=\"{= ?isCount }\">
                            <ui:if ui:condition=\"{= ?inverse }\">
                                <swon:Value arg:name=\"data\" arg:value=\"{= ui:encodeURL((&quot;# [inv] &quot; + IF((STRLEN(?propPath) &gt; 0), (REPLACE(?propPath, &quot;[.]&quot;, &quot; &quot;) + xsd:string(?qName)), COALESCE(xsd:string(REPLACE(?qName, &quot;[.]&quot;, &quot;&quot;)), REPLACE(?colName, &quot;[.]&quot;, &quot;&quot;))))) }\"/>
                                <swon:Value arg:name=\"title\" arg:value=\"# [inv] {= IF((STRLEN(?propPath) &gt; 0), (REPLACE(?propPath, &quot;[.]&quot;, &quot; &quot;) + xsd:string(?colName)), ?colName) }\"/>
                            </ui:if>
                            <ui:else>
                                <swon:Value arg:name=\"data\" arg:value=\"{= ui:encodeURL((&quot;# &quot; + IF((STRLEN(?propPath) &gt; 0), (REPLACE(?propPath, &quot;[.]&quot;, &quot; &quot;) + xsd:string(?qName)), COALESCE(xsd:string(REPLACE(?qName, &quot;[.]&quot;, &quot;&quot;)), REPLACE(?colName, &quot;[.]&quot;, &quot;&quot;))))) }\"/>
                                <swon:Value arg:name=\"title\" arg:value=\"#{= IF((STRLEN(?propPath) &gt; 0), (REPLACE(?propPath, &quot;[.]&quot;, &quot; &quot;) + xsd:string(?colName)), ?colName) }\"/>
                            </ui:else>
                        </ui:if>
                        <ui:else>
                            <ui:if ui:condition=\"{= ?inverse }\">
                                <swon:Value arg:name=\"data\" arg:value=\"{= ui:encodeURL((&quot;[inv] &quot; + IF((STRLEN(?propPath) &gt; 0), (REPLACE(?propPath, &quot;[.]&quot;, &quot; &quot;) + xsd:string(?qName)), COALESCE(xsd:string(REPLACE(?qName, &quot;[.]&quot;, &quot;&quot;)), REPLACE(?colName, &quot;[.]&quot;, &quot;&quot;))))) }\"/>
                                <swon:Value arg:name=\"title\" arg:value=\"[inv] {= IF((STRLEN(?propPath) &gt; 0), (REPLACE(?propPath, &quot;[.]&quot;, &quot; &quot;) + xsd:string(?colName)), ?colName) }\"/>
                            </ui:if>
                            <ui:else>
                                <swon:Value arg:name=\"data\" arg:value=\"{= ui:encodeURL(IF((STRLEN(?propPath) &gt; 0), (REPLACE(?propPath, &quot;[.]&quot;, &quot; &quot;) + xsd:string(?qName)), COALESCE(xsd:string(REPLACE(?qName, &quot;[.]&quot;, &quot;&quot;)), REPLACE(?colName, &quot;[.]&quot;, &quot;&quot;)))) }\"/>
                                <swon:Value arg:name=\"title\" arg:value=\"{= IF((STRLEN(?propPath) &gt; 0), (REPLACE(?propPath, &quot;[.]&quot;, &quot; &quot;) + xsd:string(?colName)), ?colName) }\"/>
                            </ui:else>
                        </ui:else>
                        <ui:if ui:condition=\"{= ?numeric }\">
                            <swon:Value arg:name=\"type\" arg:value=\"num\"/>
                        </ui:if>
                        <ui:else>
                            <swon:Value arg:name=\"type\" arg:value=\"{= ?varName }\"/>
                        </ui:else>
                    </swon:Object>
                </ui:forEach>
            </swon:Array>
        </ui:call>
    </ui:if>
    <ui:else>
        <swon:Object/>
    </ui:else>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "JSON representation of the of the columns for a DataTable generated from a searchGraph." ;
  rdfs:label "Data table search columns JSON" ;
  rdfs:subClassOf ui:JSONServices ;
.
swa:DataTableSearchResultsBody
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:columnsService ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:createResourceHandler ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:createService ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:dataEndpoint ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:dtType ;
      spl:valueType xsd:string ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:editButton ;
      spl:valueType xsd:boolean ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:editable ;
      spl:valueType xsd:boolean ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:exports ;
      spl:valueType xsd:boolean ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:filter ;
      spl:valueType xsd:boolean ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:hasCloneButton ;
      spl:valueType xsd:boolean ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:hasComparisonMatrix ;
      spl:valueType xsd:boolean ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:hasFixedHeader ;
      spl:valueType xsd:boolean ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:hasViewDetails ;
      spl:valueType xsd:boolean ;
      rdfs:comment "			" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:hideFilter ;
      spl:valueType xsd:boolean ;
      rdfs:comment "true to hide filters" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:hideIfEmpty ;
      spl:valueType xsd:boolean ;
      rdfs:comment """Hides the table if no data is returned. If you are setting this to true you need a sibling <div> element next to the data table with the class \"ui-helper-hidden-accessbile\" with whatever message you want to display.
for example:

<div class=\"ui-helper-hidden-accessible\">None</div>""" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:id ;
      spl:valueType xsd:string ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:multiSelect ;
      spl:valueType xsd:boolean ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:onlyExportVisibleColumns ;
      spl:valueType xsd:boolean ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:pageLength ;
      spl:valueType xsd:integer ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:searchGraph ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The graph containing the search:Search to execute." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:selectAll ;
      spl:valueType xsd:boolean ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:suppressLabelColumn ;
      spl:valueType xsd:boolean ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resourceSelectedEvent ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of an event to publish when the user clicks on a result. The data payload of this event is the URI of the resource." ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:if ui:condition=\"{= bound(?searchGraph) }\">
    <ui:group let:tableId=\"{= COALESCE(?id, ui:uniqueId()) }\">
        <swa:DataTable arg:columnsService=\"{= COALESCE(?columnsService, swa:DataTableSearchColumnsJSON) }\" arg:createResourceHandler=\"{= COALESCE(?createResourceHandler, swa:CreateResourceHandler) }\" arg:createService=\"{= COALESCE(?createService, swa:CreateResourceDialogJSON) }\" arg:dataEndpoint=\"{= COALESCE(?dataEndpoint, swa:DataTableSearchResultsCallback) }\" arg:dtType=\"{= COALESCE(?dtType, ?nil) }\" arg:editButton=\"{= COALESCE(?editButton, ?nil) }\" arg:editable=\"{= COALESCE(?editable, ?nil) }\" arg:exports=\"{= COALESCE(?exports, ?nil) }\" arg:filter=\"{= COALESCE(?filter, ?nil) }\" arg:hasCloneButton=\"{= COALESCE(?hasCloneButton, ?nil) }\" arg:hasFixedHeader=\"{= COALESCE(?hasFixedHeader, ?nil) }\" arg:hasViewDetails=\"{= COALESCE(?hasViewDetails, ?nil) }\" arg:hideFilter=\"{= COALESCE(?hidefilter, ?nil) }\" arg:hideIfEmpty=\"{= COALESCE(?hideIfEmpty, ?nil) }\" arg:id=\"{= ?tableId }\" arg:multiSelect=\"{= COALESCE(?multiSelect, ?nil) }\" arg:onlyExportVisibleColumns=\"{= COALESCE(?onlyExportVisibleColumns, ?nil) }\" arg:pageLength=\"{= COALESCE(?pageLength, ?nil) }\" arg:resourceSelectedEvent=\"{= COALESCE(?resourceSelectedEvent, ?nil) }\" arg:resourceType=\"{= COALESCE(?resourceType, ?nil) }\" arg:searchGraph=\"{= ?searchGraph }\" arg:selectAll=\"{= COALESCE(?selectAll, ?nil) }\" arg:suppressLabelColumn=\"{= COALESCE(?suppressLabelColumn, ?nil) }\" arg:withToolbarConfig=\"true\"/>
        <div class=\"ui-helper-hidden-accessible\">None</div>
        <script>gadgets.Hub.publish('org.topbraid.swa.rebuildTable', '{= ?tableId }');</script>
    </ui:group>
</ui:if>
"""^^ui:Literal ;
  rdfs:comment "The body of the swa:DataTableSearchResultsGadget, which can also be used in other places that operate on a given searchGraph." ;
  rdfs:label "Data table search results body" ;
  rdfs:subClassOf swa:GridElements ;
.
swa:DataTableSearchResultsCallback
  a ui:Service ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:page ;
      spl:valueType xsd:integer ;
      rdfs:comment "The current page - starting with 1." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:rows ;
      spl:valueType xsd:integer ;
      rdfs:comment "The number of rows to deliver." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:sidx ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the sort column (for property)." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:sord ;
      spl:valueType xsd:string ;
      rdfs:comment "\"asc\" or \"desc\"" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:suppressLabelColumn ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to not have a label column." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:searchGraph ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The graph containing the search:Search instance." ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:group>
    <ui:if ui:condition=\"{= bound(?searchGraph) }\">
        <ui:setContext let:startIndex=\"{= COALESCE(((?page - 1) * ?rows), 0) }\" ui:queryGraph=\"{= ?searchGraph }\">
            <ui:group let:desc=\"{= ?sord = &quot;desc&quot; }\" let:search=\"{= search:theSearch() }\" let:sortProperty=\"{= IF((bound(?sidx) &amp;&amp; (?sidx != &quot;label&quot;)), IF(fn:starts-with(?sidx, &quot;-&quot;), IRI(fn:substring(?sidx, 2)), IRI(?sidx)), ?none) }\" let:sortPropertyInverse=\"{= bound(?sidx) &amp;&amp; fn:starts-with(?sidx, &quot;-&quot;) }\">
                <ui:group let:queryGraph=\"{= spl:object(?search, search:queryGraph) }\">
                    <search:results arg:count=\"{= ?rows }\" arg:descSorting=\"{= ?desc }\" arg:produceJSON=\"{= true }\" arg:search=\"{= ?search }\" arg:searchGraph=\"{= ?searchGraph }\" arg:sortProperty=\"{= ?sortProperty }\" arg:sortPropertyInverse=\"{= ?sortPropertyInverse }\" arg:startIndex=\"{= ?startIndex }\" arg:suppressLabelColumn=\"{= ?suppressLabelColumn }\"/>
                </ui:group>
            </ui:group>
        </ui:setContext>
    </ui:if>
    <ui:else>
        <swon:Object/>
    </ui:else>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment """Delivers the content of the current page of a swa:DataTableSearchResultsGadget in the format expected by DataTables:

{
	data : [
		{
			\"key\":\"value\",
			\"key\":\"value\",
		}
			...
		{
			\"key\":\"value\",
			\"key\":\"value\",
		}
		...
	]
}""" ;
  rdfs:label "Data table search results callback" ;
  rdfs:subClassOf ui:JSONServices ;
.
swa:DataTableSearchResultsGadget
  a swa:Gadget ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:columnsService ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:multiSelect ;
      spl:valueType xsd:boolean ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:rowCount ;
      spl:valueType xsd:integer ;
      rdfs:comment "The default number of rows to display." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:rowNumCookie ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of a cookie remembering the number of rows." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:suppressLabelColumn ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to suppress the first column." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:tableId ;
      spl:valueType xsd:string ;
    ] ;
  ui:prototype """
<ui:group let:id=\"{= COALESCE(?tableId, ui:uniqueId()) }\" let:pagerId=\"{= ui:uniqueId() }\">
    <swa:Subscribe arg:code=\"swa.searchPerformed=true;swa.loadWithResource('{= ?id }-loadable', 'searchGraph', data)\" arg:event=\"{= swa:searchEvent(?searchEvent) }\"/>
    <ui:loadable class=\"ui-layout-content\" ui:loadId=\"{= ?id }-loadable\" ui:loadOnDemand=\"{= true }\">
        <swa:DataTableSearchResultsBody arg:exports=\"{= true }\" arg:filter=\"{= true }\" arg:hideIfEmpty=\"{= false }\" ui:args=\"*\"/>
    </ui:loadable>
    <div id=\"{= ?pagerId }\"/>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "A search results gadget that renders the matching resources and possibly their key properties in a grid (currently using jqGrid)." ;
  rdfs:label "Grid search results gadget" ;
  rdfs:subClassOf swa:SearchResultsGadgets ;
.
swa:DataViewsForResource
  a spin:SelectTemplate ;
  spin:body [
      a sp:Select ;
      sp:orderBy (
          [
            sp:varName "viewLabel" ;
          ]
        ) ;
      sp:resultVariables (
          [
            sp:varName "view" ;
          ]
        ) ;
      sp:where (
          [
            a sp:NamedGraph ;
            sp:elements (
                (
                  [
                    sp:object [
                        sp:varName "type" ;
                      ] ;
                    sp:predicate rdf:type ;
                    sp:subject [
                        sp:varName "resource" ;
                      ] ;
                  ]
                  [
                    a sp:TriplePath ;
                    sp:object [
                        sp:varName "class" ;
                      ] ;
                    sp:path [
                        a sp:ModPath ;
                        sp:modMax -2 ;
                        sp:modMin 0 ;
                        sp:subPath rdfs:subClassOf ;
                      ] ;
                    sp:subject [
                        sp:varName "type" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "view" ;
                      ] ;
                    sp:predicate ui:dataView ;
                    sp:subject [
                        sp:varName "class" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression [
                        a spl:object ;
                        sp:arg1 [
                            sp:varName "view" ;
                          ] ;
                        sp:arg2 arg:condition ;
                      ] ;
                    sp:variable [
                        sp:varName "condition" ;
                      ] ;
                  ]
                  [
                    a sp:Filter ;
                    sp:expression [
                        a sp:or ;
                        sp:arg1 [
                            a sp:not ;
                            sp:arg1 [
                                a sp:bound ;
                                sp:arg1 [
                                    sp:varName "condition" ;
                                  ] ;
                              ] ;
                          ] ;
                        sp:arg2 [
                            a spin:eval ;
                            sp:arg1 [
                                sp:varName "condition" ;
                              ] ;
                            sp:arg2 arg:this ;
                            sp:arg3 [
                                sp:varName "resource" ;
                              ] ;
                          ] ;
                      ] ;
                  ]
                )
                [
                  a sp:Bind ;
                  sp:expression [
                      a ui:label ;
                      sp:arg1 [
                          sp:varName "view" ;
                        ] ;
                    ] ;
                  sp:variable [
                      sp:varName "viewLabel" ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode ui:unionGraph ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to get the reports of." ;
    ] ;
  rdfs:comment "Gets all SWP views marked with ui:id=\"data\" for a given resource." ;
  rdfs:label "Data views for resource" ;
  rdfs:subClassOf spin:SelectTemplates ;
.
swa:DataViewsSection
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:label ;
      spl:valueType xsd:string ;
      rdfs:comment "The title of the section." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to display the reports for." ;
    ] ;
  ui:prototype """
<ui:if ui:condition=\"{= swa:isViewMode() }\">
    <ui:call arg:resource=\"{= ?resource }\" ui:template=\"{= swa:DataViewsForResource }\">
        <ui:if ui:condition=\"{= !spr:isEmpty(?rs) }\">
            <div class=\"swa-sub-title\">{= COALESCE(?label, \"Data Views\") }</div>
            <ui:forEach ui:resultSet=\"{= ?rs }\">
                <ui:group let:id=\"{= ui:uniqueId() }\">
                    <div class=\"swa-data-view-header\">
                        <ui:setContext ui:queryGraph=\"{= ui:unionGraph }\">
                            <b>{= ui:label(spl:object(?view, arg:dataProvider)) }</b>
                            <swa:Space/>
                            <swa:Space/>
                            <swa:Space/>
                            <a href=\"javascript:void(0)\" id=\"{= ?id }-a\" onclick=\"swa.load('{= ?id }', {load: true});$('#{= ?id }-a').attr('href', null);\">({= ui:label(spl:object(?view, rdf:type)) })</a>
                        </ui:setContext>
                    </div>
                    <ui:loadable class=\"swa-data-view\" ui:loadId=\"{= ?id }\">
                        <ui:if ui:condition=\"{= bound(?load) }\">
                            <ui:group let:this=\"{= ?resource }\">
                                <ui:dynamicView ui:instance=\"{= ?view }\"/>
                            </ui:group>
                        </ui:if>
                    </ui:loadable>
                </ui:group>
            </ui:forEach>
        </ui:if>
    </ui:call>
</ui:if>
"""^^ui:Literal ;
  rdfs:comment "A section on a resource form that displays all \"data views\" available for the current resource. Dataviews are attached to a resource's class via ui:dataView, and may have an evaluable expression attached to them to further narrow down when they apply. If any such view is found, and the form is in view mode, then the form will provide expandable blocks to quickly open up those views." ;
  rdfs:label "Data views section" ;
  rdfs:subClassOf swa:FormElements ;
.
swa:DatatypeEnumDropDownEditor
  a swa:ObjectEditorClass ;
  swa:objectWidgetWeight [
      a swa:WeightedExpression ;
      swa:expression [
          a sp:and ;
          sp:arg1 [
              a sp:bound ;
              sp:arg1 [
                  sp:varName "range" ;
                ] ;
            ] ;
          sp:arg2 [
              a swa:isDatatypeEnumeration ;
              arg:resource [
                  sp:varName "range" ;
                ] ;
            ] ;
        ] ;
      swa:weight 5 ;
    ] ;
  ui:prototype """
<swa:AbstractEnumDropDownEditor ui:args=\"*\"/>
"""^^ui:Literal ;
  rdfs:label "Datatype enum drop down editor" ;
  rdfs:subClassOf swa:AbstractEnumDropDownEditor ;
.
swa:DatatypeEnumDropDownFacet
  a swa:ObjectFacetClass ;
  swa:facetSearchType search:ObjectFacetValue ;
  swa:objectFacetMenuName "drop down list" ;
  swa:objectWidgetWeight [
      a swa:WeightedExpression ;
      swa:expression [
          a sp:and ;
          sp:arg1 [
              a sp:bound ;
              sp:arg1 [
                  sp:varName "range" ;
                ] ;
            ] ;
          sp:arg2 [
              a swa:isDatatypeEnumeration ;
              arg:resource [
                  sp:varName "range" ;
                ] ;
            ] ;
        ] ;
      swa:weight 2 ;
    ] ;
  ui:private true ;
  ui:prototype """
<swa:AbstractEnumDropDownFacet ui:args=\"*\"/>
"""^^ui:Literal ;
  rdfs:label "Datatype enum drop down facet" ;
  rdfs:subClassOf swa:AbstractEnumDropDownFacet ;
.
swa:DatatypeEnumRadioButtonsEditor
  a swa:ObjectEditorClass ;
  ui:private true ;
  ui:prototype """
<swa:AbstractRadioButtonsEditor ui:args=\"*\"/>
"""^^ui:Literal ;
  rdfs:label "Datatype enum radio buttons editor" ;
  rdfs:subClassOf swa:AbstractRadioButtonsEditor ;
.
swa:DateEditor
  a swa:ObjectEditorClass ;
  swa:objectWidgetWeight [
      a swa:WeightedExpression ;
      swa:expression [
          a sp:eq ;
          sp:arg1 [
              a sp:datatype ;
              sp:arg1 [
                  sp:varName "object" ;
                ] ;
            ] ;
          sp:arg2 xsd:date ;
        ] ;
      swa:weight 5 ;
    ] ;
  swa:objectWidgetWeight [
      a swa:WeightedExpression ;
      swa:expression [
          a sp:eq ;
          sp:arg1 [
              sp:varName "range" ;
            ] ;
          sp:arg2 xsd:date ;
        ] ;
      swa:weight 3 ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:group>
    <swa:ObjectEditorHiddenDatatypeField arg:datatype=\"{= xsd:date }\" arg:uid=\"{= ?uid }\"/>
    <input class=\"form-control\" id=\"dateEditor-{= ?uid }\" size=\"10\" type=\"text\" value=\"{= ?object }\"/>
    <input id=\"new-{= ?uid }\" name=\"new-{= ?uid }\" type=\"hidden\" value=\"{= ?object }\"/>
    <swa:WidgetInitializer arg:script=\"swa.initDatePicker('{= ?uid }')\"/>
</ui:group>
"""^^ui:Literal ;
  rdfs:label "Date editor" ;
  rdfs:subClassOf swa:ObjectEditor ;
.
swa:DateRangeFacet
  a swa:ObjectFacetClass ;
  swa:facetSearchType search:RangeFacetValue ;
  swa:objectFacetMenuName "min/max range" ;
  swa:objectWidgetWeight [
      a swa:WeightedExpression ;
      swa:expression [
          a sp:and ;
          sp:arg1 [
              a sp:bound ;
              sp:arg1 [
                  sp:varName "range" ;
                ] ;
            ] ;
          sp:arg2 [
              a sp:eq ;
              sp:arg1 [
                  sp:varName "range" ;
                ] ;
              sp:arg2 xsd:date ;
            ] ;
        ] ;
      swa:weight 5 ;
    ] ;
  ui:prototype """
<span class=\"swa-date-range-facet-span\" let:restore=\"{= swa:restoreFacetValue(?predicate) }\">
    <ui:group let:max=\"{= IF(bound(?restore), spl:object(?restore, search:max), ?none) }\" let:min=\"{= IF(bound(?restore), spl:object(?restore, search:min), ?none) }\">
        <input class=\"{= swa:testClass(?predicate) }-min form-control\" id=\"dateEditor-{= ?uid }Min\" size=\"10\" type=\"text\" value=\"{= ?min }\"/>
        <span> - </span>
        <input class=\"{= swa:testClass(?predicate) }-max form-control\" id=\"dateEditor-{= ?uid }Max\" size=\"10\" type=\"text\" value=\"{= ?max }\"/>
        <input id=\"min{= ?uid }\" name=\"min{= ?uid }\" type=\"hidden\" value=\"{= ?min }\"/>
        <input id=\"max{= ?uid }\" name=\"max{= ?uid }\" type=\"hidden\" value=\"{= ?max }\"/>
        <input id=\"datatype{= ?uid }\" name=\"datatype{= ?uid }\" type=\"hidden\" value=\"{= xsd:date }\"/>
        <script>swa.initDatePicker('{= ?uid }Min', 'min{= ?uid }');
		swa.initDatePicker('{= ?uid }Max', 'max{= ?uid }');</script>
    </ui:group>
</span>
"""^^ui:Literal ;
  rdfs:label "Date range facet" ;
  rdfs:subClassOf swa:ObjectFacet ;
.
swa:DateTimeEditor
  a swa:ObjectEditorClass ;
  swa:objectWidgetWeight [
      a swa:WeightedExpression ;
      swa:expression [
          a sp:eq ;
          sp:arg1 [
              a sp:datatype ;
              sp:arg1 [
                  sp:varName "object" ;
                ] ;
            ] ;
          sp:arg2 xsd:dateTime ;
        ] ;
      swa:weight 5 ;
    ] ;
  swa:objectWidgetWeight [
      a swa:WeightedExpression ;
      swa:expression [
          a sp:eq ;
          sp:arg1 [
              sp:varName "range" ;
            ] ;
          sp:arg2 xsd:dateTime ;
        ] ;
      swa:weight 3 ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:group>
    <swa:ObjectEditorHiddenDatatypeField arg:datatype=\"{= xsd:dateTime }\" arg:uid=\"{= ?uid }\"/>
    <input class=\"form-control\" id=\"dateTimeEditor{= ?uid }\" size=\"20\" type=\"text\" value=\"{= SUBSTR(str(?object), 1, 19) }\"/>
    <swa:Space/>
    <swa:TimeZonePicker arg:id=\"timeZoneEditor{= ?uid }\"/>
    <input id=\"new-{= ?uid }\" name=\"new-{= ?uid }\" type=\"hidden\" value=\"{= ?object }\"/>
    <swa:WidgetInitializer arg:script=\"swa.initDateTimePicker('{= ?uid }');\"/>
</ui:group>
"""^^ui:Literal ;
  rdfs:label "Date/time editor" ;
  rdfs:subClassOf swa:ObjectEditor ;
.
swa:DateTimeRangeFacet
  a swa:ObjectFacetClass ;
  swa:facetSearchType search:RangeFacetValue ;
  swa:objectFacetMenuName "min/max range" ;
  swa:objectWidgetWeight [
      a swa:WeightedExpression ;
      swa:expression [
          a sp:and ;
          sp:arg1 [
              a sp:bound ;
              sp:arg1 [
                  sp:varName "range" ;
                ] ;
            ] ;
          sp:arg2 [
              a sp:eq ;
              sp:arg1 [
                  sp:varName "range" ;
                ] ;
              sp:arg2 xsd:dateTime ;
            ] ;
        ] ;
      swa:weight 5 ;
    ] ;
  ui:prototype """
<span class=\"swa-date-range-facet-span\" let:restore=\"{= swa:restoreFacetValue(?predicate) }\">
    <ui:group let:max=\"{= IF(bound(?restore), spl:object(?restore, search:max), ?none) }\" let:min=\"{= IF(bound(?restore), spl:object(?restore, search:min), ?none) }\">
        <input class=\"form-control date-range\" id=\"dateTimeEditor{= ?uid }Min\" size=\"20\" type=\"text\" value=\"{= ?min }\"/>
        <swa:Space/>
        <swa:TimeZonePicker arg:id=\"timeZoneEditor{= ?uid }Min\"/>
        <span> - </span>
        <br/>
        <input class=\"form-control date-range\" id=\"dateTimeEditor{= ?uid }Max\" size=\"20\" type=\"text\" value=\"{= ?max }\"/>
        <swa:Space/>
        <swa:TimeZonePicker arg:id=\"timeZoneEditor{= ?uid }Max\"/>
        <input id=\"min{= ?uid }\" name=\"min{= ?uid }\" type=\"hidden\" value=\"{= ?min }\"/>
        <input id=\"max{= ?uid }\" name=\"max{= ?uid }\" type=\"hidden\" value=\"{= ?max }\"/>
        <input id=\"datatype{= ?uid }\" name=\"datatype{= ?uid }\" type=\"hidden\" value=\"{= xsd:dateTime }\"/>
        <script>swa.initDateTimePicker('{= ?uid }Min', 'min{= ?uid }');
		swa.initDateTimePicker('{= ?uid }Max', 'max{= ?uid }');</script>
    </ui:group>
</span>
"""^^ui:Literal ;
  rdfs:label "DateTime range facet" ;
  rdfs:subClassOf swa:ObjectFacet ;
.
swa:DefaultCreateResourceDialogPlugin
  a swa:CreateResourceDialogPlugin ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:ignoreURIconfigParameters ;
      spl:valueType xsd:boolean ;
    ] ;
  ui:prototype """
<ui:loadable ui:loadId=\"create-resource-dialog-body\">
    <ui:if ui:condition=\"{= bound(?primaryKeyClass) || swa:hasPrimaryKey(?resourceType) }\">
        <swa:CreateResourceWithPrimaryKeyDialogPlugin arg:resourceType=\"{= ?primaryKeyClass }\" ui:args=\"*\"/>
    </ui:if>
    <ui:else>
        <swa:CreateResourceDialogTypeSelectionPanel arg:resourceType=\"{= ?resourceType }\" arg:suppressTypeSelection=\"{= ?suppressTypeSelection }\"/>
        <swa:LabeledElement arg:label=\"Label:\">
            <input autocomplete=\"off\" class=\"form-control swa-create-resource-label-input\" id=\"label-input\" type=\"text\"/>
            <script>swa.initCreateResourceLabelField('label-input', 'uri-field')</script>
            <swa:LangSelector arg:uid=\"label\"/>
        </swa:LabeledElement>
        <swa:URIField arg:resourceType=\"{= ?resourceType }\"/>
    </ui:else>
</ui:loadable>
"""^^ui:Literal ;
  rdfs:comment "The default swa:CreateResourceDialogPlugin consisting of input fields for label and resource URI, where the URI gets updated if the label changes." ;
  rdfs:label "Default create resource dialog plugin" ;
  rdfs:subClassOf swa:CreateResourceDialogPlugins ;
.
swa:DefaultCreateResourceDialogPluginForAssetCollection
  a swa:CreateResourceDialogPlugin ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:ignoreURIconfigParameters ;
      spl:valueType xsd:boolean ;
    ] ;
  ui:prototype """
<ui:group let:forceUUID=\"{= COALESCE(spl:object(?resourceType, swa:instancesHaveRandomURI), false) }\">
    <div data-resource-label=\"{= ui:label(?resourceType) }\" let:useConstructMethod=\"{= swa:getURIConstructMethod() }\">
        <ui:group>
            <!--ui:dumpScope ui:message=\"AAA1: swa:DefaultCreateResourceDialogPlugin\"/-->
            <ui:if ui:condition=\"{= bound(?primaryKeyClass) || swa:hasPrimaryKey(?resourceType) }\">
                <swa:CreateResourceWithPrimaryKeyDialogPlugin arg:resourceType=\"{= ?primaryKeyClass }\" ui:args=\"*\"/>
            </ui:if>
            <ui:else>
                <swa:CreateResourceDialogTypeSelectionPanelForAssetCollection arg:resourceType=\"{= ?resourceType }\" arg:suppressTypeSelection=\"{= ?suppressTypeSelection }\"/>
                <ui:if ui:condition=\"{= !swa:isAbstractClass(?resourceType) }\">
                    <ui:if ui:condition=\"{= (!?forceUUID) &amp;&amp; (?useConstructMethod = &quot;label&quot;) }\">
                        <swa:CreateResourceDialogUsingLabel arg:resourceType=\"{= ?resourceType }\"/>
                    </ui:if>
                    <ui:elseif ui:condition=\"{= (!?forceUUID) &amp;&amp; (?useConstructMethod = &quot;custom&quot;) }\">
                        <swa:CreateResourceDialogUsingCustom arg:resourceType=\"{= ?resourceType }\"/>
                    </ui:elseif>
                    <ui:else>
                        <!--div class=\"edg-create-instance ui-helper-hidden-accessible\"-->
                        <swa:LabeledElement arg:label=\"Label:\">
                            <input autocomplete=\"off\" class=\"form-control swa-create-resource-label-input\" id=\"label-input\" type=\"text\"/>
                            <swa:LangSelector arg:uid=\"label\"/>
                        </swa:LabeledElement>
                        <swa:URIFieldForAssetCollection arg:ignoreURIconfigParameters=\"{= COALESCE(?ignoreURIconfigParameters, false) }\" arg:resourceType=\"{= ?resourceType }\"/>
                        <!--/div-->
                        <ui:if ui:condition=\"{= ?forceUUID || (?useConstructMethod = &quot;uuid&quot;) }\">
                            <script>swa.initCreateResourceLabelFieldForAssetCollection('label-input', 'uri-input','{= swa:newUUIDresourceForAssetCollection(?resourceType) }',false )</script>
                        </ui:if>
                        <ui:else>
                            <ui:group let:useLabel=\"{= ?useConstructMethod = &quot;label&quot; }\">
                                <script>swa.initCreateResourceLabelFieldForAssetCollection('label-input', 'uri-input','{= swa:newResourceForAssetCollection(?resourceType) }',{= ?useLabel } )</script>
                            </ui:group>
                        </ui:else>
                    </ui:else>
                </ui:if>
            </ui:else>
        </ui:group>
    </div>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "The default swa:CreateResourceDialogPluginForAssetCollection consisting of input fields for label and resource URI, where the URI gets updated if the label changes. At the class level the property 'swa:instancesHaveRandomURI' overrides any user configuration settings." ;
  rdfs:label "Default create resource dialog plugin for asset collection" ;
  rdfs:subClassOf swa:CreateResourceDialogPlugins ;
.
swa:DefaultCreateResourceDialogPluginJSONFields
  a swa:CreateResourceDialogPlugin ;
  ui:prototype """
<ui:group>
    <swon:Array>
        <swon:Object>
            <swon:Value arg:name=\"label\" arg:value=\"Label\"/>
            <swon:Value arg:name=\"name\" arg:value=\"label\"/>
            <swon:Value arg:name=\"disable\" arg:value=\"true\"/>
        </swon:Object>
        <swon:Object>
            <swon:Value arg:name=\"label\" arg:value=\"Lang\"/>
            <swon:Value arg:name=\"name\" arg:value=\"labelLang\"/>
            <swon:Value arg:name=\"type\" arg:value=\"select\"/>
            <swon:Values arg:name=\"options\">
                <swa:GetLangsJSON ui:args=\"*\"/>
            </swon:Values>
        </swon:Object>
        <ui:if ui:condition=\"{= swa:hasPrimaryKey(?resourceType) }\">
            <swon:Object>
                <swon:Value arg:name=\"label\" arg:value=\"pk\"/>
                <swon:Value arg:name=\"name\" arg:value=\"pk\"/>
            </swon:Object>
        </ui:if>
        <swon:Object>
            <swon:Value arg:name=\"label\" arg:value=\"Identifier\"/>
            <swon:Value arg:name=\"name\" arg:value=\"uri\"/>
            <swon:Value arg:name=\"className\" arg:value=\"uri\"/>
            <ui:if ui:condition=\"{= swa:hasPrimaryKey(?resourceType) }\">
                <swon:Value arg:name=\"def\" arg:value=\"{= swa:primaryKeyURIStart(?resourceType) }\"/>
            </ui:if>
            <ui:else>
                <swon:Value arg:name=\"def\" arg:value=\"{= swa:getDefaultNamespace(?resourceType) }\"/>
            </ui:else>
        </swon:Object>
        <swon:Object>
            <swon:Value arg:name=\"label\" arg:value=\"Type\"/>
            <swon:Value arg:name=\"name\" arg:value=\"type\"/>
            <swon:Value arg:name=\"type\" arg:value=\"select\"/>
            <swon:Value arg:name=\"def\" arg:value=\"{= ?resourceType }\"/>
            <swon:Values arg:name=\"options\">
                <swa:GetTypesJSON ui:args=\"*\"/>
            </swon:Values>
        </swon:Object>
    </swon:Array>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "The default swa:CreateResourceDialogPlugin consisting of input fields for label and resource URI, where the URI gets updated if the label changes." ;
  rdfs:label "Default create resource dialog plugin" ;
  rdfs:subClassOf swa:CreateResourceDialogPlugins ;
.
swa:DefaultDeleteResourcesService
  a swa:DeleteResourcesService ;
  ui:prototype """
<ui:group letrs:rs='{#
        SELECT ?resource
        WHERE {
            ?str spif:split ( ?resources \" \" ) .
            BIND (ui:decodeNode(CONCAT(\"&lt;\", ?str, \"&gt;\")) AS ?resource) .
        } }'>
    <ui:forEach ui:resultSet=\"{= ?rs }\">
        <swa:ResourceDestructor arg:resource=\"{= ?resource }\"/>
    </ui:forEach>
    <ui:transaction ui:logMessage=\"Delete {= spr:rowCount(?rs) } rows\">
        <ui:update ui:updateQuery=\"{!
                DELETE {
                    ?s ?p ?o .
                }
                WHERE {
                    GRAPH ui:tempGraph {
                        ?s ?p ?o .
                    } .
                } }\"/>
    </ui:transaction>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "A default delete service that assumes that all rows are in the base graph and thus editable. It uses swa:canDeleteResource for each resource before proceeding." ;
  rdfs:label "Default delete resources service" ;
  rdfs:subClassOf swa:DeleteResourcesServices ;
.
swa:DefaultDestructor
  a swa:Destructor ;
  ui:prototype """
<ui:group>
    <ui:update ui:updateQuery=\"{!
            INSERT {
                GRAPH ui:tempGraph {
                    ?s ?p ?o .
                } .
            }
            WHERE {
                ( ?s ?p ?o ) tops:dependsOn ?resource .
            } }\"/>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "The default destructor of a resource deletes all triples that depend on the resource, including depending blank nodes." ;
  rdfs:label "Default destructor" ;
  rdfs:subClassOf swa:Destructors ;
.
swa:DefaultGenericTreePropertySelectionTemplate
  a spin:SelectTemplate ;
  spin:body [
      a sp:Select ;
      sp:distinct true ;
      sp:orderBy (
          [
            sp:varName "label" ;
          ]
          [
            sp:varName "inverse" ;
          ]
        ) ;
      sp:resultVariables (
          [
            sp:varName "property" ;
          ]
          [
            sp:varName "inverse" ;
          ]
          [
            sp:expression [
                a sp:not ;
                sp:arg1 [
                    sp:varName "editable" ;
                  ] ;
              ] ;
            sp:varName "readOnly" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Union ;
            sp:elements (
                (
                  [
                    sp:object [
                        sp:varName "?0" ;
                      ] ;
                    sp:predicate swa:genericTreeProperties ;
                    sp:subject [
                        sp:varName "resourceType" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "property" ;
                      ] ;
                    sp:predicate rdf:first ;
                    sp:subject [
                        sp:varName "?0" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "?1" ;
                      ] ;
                    sp:predicate rdf:rest ;
                    sp:subject [
                        sp:varName "?0" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "editable" ;
                      ] ;
                    sp:predicate rdf:first ;
                    sp:subject [
                        sp:varName "?1" ;
                      ] ;
                  ]
                  [
                    sp:object () ;
                    sp:predicate rdf:rest ;
                    sp:subject [
                        sp:varName "?1" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression false ;
                    sp:variable [
                        sp:varName "inverse" ;
                      ] ;
                  ]
                  [
                    a sp:Filter ;
                    sp:expression [
                        a sp:bound ;
                        sp:arg1 [
                            sp:varName "property" ;
                          ] ;
                      ] ;
                  ]
                )
                (
                  [
                    sp:object [
                        sp:varName "?2" ;
                      ] ;
                    sp:predicate swa:genericTreeInverseProperties ;
                    sp:subject [
                        sp:varName "resourceType" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "property" ;
                      ] ;
                    sp:predicate rdf:first ;
                    sp:subject [
                        sp:varName "?2" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "?3" ;
                      ] ;
                    sp:predicate rdf:rest ;
                    sp:subject [
                        sp:varName "?2" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "editable" ;
                      ] ;
                    sp:predicate rdf:first ;
                    sp:subject [
                        sp:varName "?3" ;
                      ] ;
                  ]
                  [
                    sp:object () ;
                    sp:predicate rdf:rest ;
                    sp:subject [
                        sp:varName "?3" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression true ;
                    sp:variable [
                        sp:varName "inverse" ;
                      ] ;
                  ]
                  [
                    a sp:Filter ;
                    sp:expression [
                        a sp:bound ;
                        sp:arg1 [
                            sp:varName "property" ;
                          ] ;
                      ] ;
                  ]
                )
              ) ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a ui:label ;
                sp:arg1 [
                    sp:varName "property" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "label" ;
              ] ;
          ]
        ) ;
    ] ;
  rdfs:comment "The default property selection template, returning all object-valued properties that have the resource type (or a superclass if it) as its domain and as well as (in the inverse direction) those that have the resource type in their range." ;
  rdfs:label "Default generic tree property selection template" ;
  rdfs:subClassOf swa:GenericTreePropertySelectionTemplates ;
.
swa:DefaultHeaderLabelFunction
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a ui:label ;
                sp:arg1 [
                    a swa:resourceType ;
                    arg:resource [
                        sp:varName "resource" ;
                      ] ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "typeLabel" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:concat ;
                sp:arg1 [
                    a ui:label ;
                    sp:arg1 [
                        sp:varName "resource" ;
                      ] ;
                  ] ;
                sp:arg2 "  (" ;
                sp:arg3 [
                    sp:varName "typeLabel" ;
                  ] ;
                sp:arg4 ")" ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  rdfs:comment "The default header label function, displaying the ui:label of the resource and the label of the rdf:type in parantheses." ;
  rdfs:label "Default header label function" ;
  rdfs:subClassOf swa:HeaderLabelFunctions ;
.
swa:DefaultObjectWidgetMiddleColumn
  a swa:ObjectWidgetMiddleColumnClass ;
  ui:prototype """
<td class=\"swa-labeled-objects-icons-td\">
    <span class=\"swa-icon\" id=\"error-{= ?predicate }\"/>
</td>
"""^^ui:Literal ;
  rdfs:label "Default object widget middle column" ;
  rdfs:subClassOf swa:ObjectWidgetMiddleColumn ;
.
swa:DefaultObjectsBody
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:offset ;
      spl:valueType xsd:integer ;
      rdfs:comment "The offset for the \"next 50\" recursive calls." ;
    ] ;
  ui:prototype """
<ui:group>
    <ui:if ui:condition=\"{= bound(?subject) }\">
        <ui:call arg:currentLang=\"{= ui:lang() }\" arg:languages=\"{= swa:getLanguagesList() }\" arg:predicate=\"{= ?predicate }\" arg:subject=\"{= ?subject }\" let:special=\"{= swa:specialAddButtonFunction(?predicate, ?subject) }\" ui:template=\"{= swa:SortedObjectsByLanguage }\">
            <ui:if ui:condition=\"{= ((spr:isEmpty(?rs) &amp;&amp; (!swa:isViewMode())) &amp;&amp; (!bound(?special))) &amp;&amp; (!swa:isBlankNodeProperty(?predicate)) }\">
                <ui:if ui:condition=\"{= swa:isAutoAddRowProperty(?predicate) }\">
                    <div class=\"swa-object-row\">
                        <swa:ObjectWidgetRow arg:predicate=\"{= ?predicate }\" arg:subject=\"{= ?subject }\"/>
                    </div>
                </ui:if>
            </ui:if>
            <ui:else>
                <ui:group let:limit=\"{= 50 }\" let:offset=\"{= COALESCE(?offset, 0) }\">
                    <ui:forEach ui:limit=\"{= ?limit }\" ui:offset=\"{= ?offset }\" ui:resultSet=\"{= ?rs }\">
                        <div class=\"swa-object-row\">
                            <swa:ObjectWidgetRow arg:object=\"{= ?object }\" arg:predicate=\"{= ?predicate }\" arg:subject=\"{= ?subject }\"/>
                        </div>
                    </ui:forEach>
                    <ui:group let:id=\"{= ui:uniqueId() }\" let:rowCount=\"{= spr:rowCount(?rs) }\">
                        <ui:loadable ui:loadId=\"{= ?id }\">
                            <ui:if ui:condition=\"{= ?rowCount &gt; (?offset + ?limit) }\">
                                <ui:if ui:condition=\"{= bound(?newOffset) }\">
                                    <swa:DefaultObjectsBody arg:offset=\"{= ?newOffset }\" ui:args=\"*\"/>
                                </ui:if>
                                <ui:else>
                                    <div class=\"swa-objects-show-more\">
                                        <a href=\"javascript:void(0)\" onclick=\"swa.load('{= ?id }', { newOffset: {= ?offset + ?limit } })\">Show entries {= (?offset + ?limit) + 1 } to {= spl:min(?rowCount, ((?offset + ?limit) + ?limit)) } of {= ?rowCount }</a>
                                    </div>
                                </ui:else>
                            </ui:if>
                        </ui:loadable>
                    </ui:group>
                </ui:group>
            </ui:else>
        </ui:call>
    </ui:if>
    <ui:else>
        <div class=\"swa-object-row\">
            <swa:ObjectWidgetRow arg:predicate=\"{= ?predicate }\"/>
        </div>
    </ui:else>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "The default implementation of swa:ObjectsBody, containing one row for each value." ;
  rdfs:label "Default objects body" ;
  rdfs:subClassOf swa:ObjectsBody ;
.
swa:DefaultSubjectWidgetMiddleColumn
  a swa:SubjectWidgetMiddleColumnClass ;
  ui:prototype """
<td class=\"swa-labeled-objects-icons-td\">
    <span class=\"swa-icon\" id=\"error-{= ?predicate }\"/>
</td>
"""^^ui:Literal ;
  rdfs:label "Default subject widget middle column" ;
  rdfs:subClassOf swa:SubjectWidgetMiddleColumn ;
.
swa:DeleteResourceHandler
  a swa:EditHandlerClass ;
  ui:private true ;
  ui:prototype """
<ui:group>
    <swa:ResourceDestructor arg:resource=\"{= ?resource }\"/>
    <ui:transaction ui:logMessage=\"Delete {= ui:label(?resource) }\">
        <ui:update ui:updateQuery=\"{!
                DELETE {
                    ?s ?p ?o .
                }
                WHERE {
                    GRAPH ui:tempGraph {
                        ?s ?p ?o .
                    } .
                    FILTER (?s != swa:DestructorMetadata) .
                } }\"/>
    </ui:transaction>
</ui:group>
"""^^ui:Literal ;
  ui:responseType ui:JSON ;
  rdfs:comment "The handler of the Delete button under the Resource form. This is executes collects all triples that need to be deleted using the destructors framework, and then deletes those." ;
  rdfs:label "Delete resource handler" ;
  rdfs:subClassOf swa:DestructorElements ;
  rdfs:subClassOf swa:EditHandlers ;
.
swa:DeleteResourcesService
  a rdfs:Class ;
  rdfs:comment "Metaclass used by swa:EditableGridGadget to implement the delete button." ;
  rdfs:label "Delete resources service" ;
  rdfs:subClassOf ui:Service ;
.
swa:DeleteResourcesServices
  a swa:DeleteResourcesService ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resources ;
      spl:valueType xsd:string ;
      rdfs:comment "A space-separated list of URIs for the resources that shall be deleted." ;
    ] ;
  ui:abstract true ;
  rdfs:label "Delete resources services" ;
  rdfs:subClassOf ui:JSONServices ;
.
swa:DeleteSessionGraphService
  a ui:Service ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:sessionGraph ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The session graph to delete." ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:group let:dummy=\"{= ui:deleteSessionGraph(?sessionGraph) }\"/>
"""^^ui:Literal ;
  ui:responseType ui:TEXT ;
  rdfs:label "Delete session graph service" ;
  rdfs:subClassOf ui:Services ;
.
swa:Destructor
  a rdfs:Class ;
  rdfs:comment "Metaclass of swa:Destructors." ;
  rdfs:label "Destructor" ;
  rdfs:subClassOf ui:NodeClass ;
.
swa:DestructorElements
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to delete." ;
    ] ;
  ui:abstract true ;
  ui:private true ;
  rdfs:comment "Abstract superclass to group all elements related to deleting resources." ;
  rdfs:label "Destructor elements" ;
  rdfs:subClassOf swa:Elements ;
.
swa:DestructorMetadata
  a rdfs:Resource ;
  rdfs:comment "A marker URI used by destructors to distinguish triples that are metadata and not actually deletable triples. Should be used as subject of those triples." ;
  rdfs:label "Destructor metadata" ;
.
swa:Destructors
  a swa:Destructor ;
  ui:abstract true ;
  rdfs:comment """Superclass to group all elements that deliver all triples that need to be deleted if a given resource is to be deleted. These destructors should not create any output, but only run ui:updates to add all triples that shall be deleted to ui:tempGraph. While doing so, they may recursively insert other swa:Destructors using the swa:ResourceDestructor element on \"depending\" resources, e.g. if subclasses of a given class shall also be deleted.

The property ui:instanceView and ui:id=\"destructor\" should be used to link a class with its most suitable swa:Destructor. The swa:DefaultDestructor simply deletes all triples that mention the resource as subject, predicate or object.

Destructors can be used by delete operations - to either execute the deletion, to figure out whether a resource can be deleted, or simply to display \"depending\" triples so that the user can see dependencies within a model.""" ;
  rdfs:label "Destructors" ;
  rdfs:subClassOf swa:DestructorElements ;
.
swa:DetailsViewPagination
  a ui:NodeClass ;
  ui:prototype """
<ui:group>
    <div id=\"pagination\"/>
</ui:group>
"""^^ui:Literal ;
  rdfs:subClassOf swa:Elements ;
.
swa:DialogElements
  a ui:NodeClass ;
  ui:abstract true ;
  ui:responseType ui:HTML ;
  rdfs:comment "Abstract superclass for dialog-related elements." ;
  rdfs:label "Dialog elements" ;
  rdfs:subClassOf swa:Elements ;
.
swa:DocumentElements
  a ui:NodeClass ;
  ui:abstract true ;
  rdfs:comment "Abstract superclass for SWP elements useful to produce documents such as manuals and help pages." ;
  rdfs:label "Document elements" ;
  rdfs:subClassOf swa:Elements ;
.
swa:DocumentLink
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:style ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional style class for the link." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:document ;
      spl:valueType ui:NodeClass ;
      rdfs:comment "The document element to point to." ;
    ] ;
  ui:prototype """
<ui:createLink ui:viewClass=\"{= ?document }\">
    <a class=\"{= ?style }\" href=\"{= ?link }\">{= swa:labelInGraph(?document, ui:graph) }</a>
</ui:createLink>
"""^^ui:Literal ;
  rdfs:comment "Creates a hyperlink (<a href=\"LINK\">TITLE</a>) to a given swa:Document. The TITLE will be the rdfs:label of the target element." ;
  rdfs:label "Document link" ;
  rdfs:subClassOf swa:DocumentElements ;
.
swa:Documents
  a ui:NodeClass ;
  ui:abstract false ;
  ui:headIncludes """
<ui:group>
    <script src=\"{= ui:lib() }/assets/js/toc.js\"/>
    <link href=\"{= ui:lib() }/assets/css/doc.css\" rel=\"stylesheet\" type=\"text/css\"/>
</ui:group>
"""^^ui:Literal ;
  ui:responseType ui:HTML ;
  rdfs:comment "Abstract base class for top-level documents." ;
  rdfs:label "Document" ;
  rdfs:subClassOf swa:DocumentElements ;
.
swa:DynamicEnumRangeEditor
  a swa:ObjectEditorClass ;
  swa:objectWidgetWeight [
      a swa:WeightedExpression ;
      swa:expression [
          a sp:exists ;
          sp:elements (
              [
                sp:object [
                    sp:varName "any" ;
                  ] ;
                sp:predicate spl:dynamicEnumRange ;
                sp:subject [
                    sp:varName "predicate" ;
                  ] ;
              ]
            ) ;
        ] ;
      swa:weight 9 ;
    ] ;
  ui:prototype """
<ui:group let:id=\"new-{= ?uid }\">
    <input id=\"{= ?id }\" name=\"{= ?id }\" type=\"hidden\" value=\"{= ui:encodeNode(?object, true, true) }\"/>
    <ui:group let:displayId=\"{= ?id }-field\">
        <input class=\"swa-auto-complete swa-text-field form-control\" id=\"{= ?displayId }\" type=\"text\" value=\"{= ui:label(?object) }\"/>
        <script>{= ui:functionCall(\"swa.initDynamicEnumRangeAutoComplete\", ?id) }</script>
        <script>setTimeout('{= ui:functionCall(\"swa.updateDynamicEnumRangeAutoComplete\", ?id, ?subject, ?predicate, \"Edits\") }', 0)</script>
        <swa:Subscribe arg:code=\"swa.perhapsUpdateDynamicEnumRangeAutoComplete('{= ?id }', '{= ?subject }', '{= ?predicate }', 'Edits', data, '{= swa:dynamicEnumRangeTriggerPropertiesList(?predicate) }')\" arg:event=\"org.topbraid.swa.editWidgetChange\" arg:ownerId=\"{= ?id }\"/>
    </ui:group>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "The default editor for properties marked with spl:dynamicEnumRange. Consists of an auto-complete field that resets when the value in a trigger field for the same resource changes. For example, if schema:addressRegion depends on schema:addressCountry, then the country widget will issue an event that this widget is subscribed to. When the matching event is received, it will clear the text. Callbacks to the auto-complete use the SELECT query from the spl:dynamicEnumRange." ;
  rdfs:label "Dynamic enum range editor" ;
  rdfs:subClassOf swa:ObjectEditor ;
.
swa:DynamicEnumRangeFacet
  a swa:ObjectFacetClass ;
  swa:objectWidgetWeight [
      a swa:WeightedExpression ;
      swa:expression [
          a sp:exists ;
          sp:elements (
              [
                sp:object [
                    sp:varName "any" ;
                  ] ;
                sp:predicate spl:dynamicEnumRange ;
                sp:subject [
                    sp:varName "predicate" ;
                  ] ;
              ]
            ) ;
        ] ;
      swa:weight 9 ;
    ] ;
  ui:prototype """
<ui:group let:id=\"value{= ?uid }\" let:restore=\"{= swa:restoreFacetValue(?predicate) }\">
    <ui:group let:displayId=\"{= ?id }-field\" let:initialObject=\"{= IF(bound(?restore), spl:object(?restore, search:object), ?none) }\">
        <input id=\"{= ?id }\" name=\"{= ?id }\" type=\"hidden\" value=\"{= ui:encodeNode(?initialObject, true, true) }\"/>
        <input class=\"swa-auto-complete form-control\" id=\"{= ?displayId }\" type=\"text\" value=\"{= ui:label(?initialObject) }\"/>
        <script>{= ui:functionCall(\"swa.initDynamicEnumRangeAutoComplete\", ?id) }</script>
        <script>setTimeout('{= ui:functionCall(\"swa.updateDynamicEnumRangeAutoComplete\", ?id, ?subject, ?predicate, \"Search\") }', 0)</script>
        <swa:Subscribe arg:code=\"swa.perhapsUpdateDynamicEnumRangeAutoComplete('{= ?id }', '{= ?subject }', '{= ?predicate }', 'Search', data, '{= swa:dynamicEnumRangeTriggerPropertiesList(?predicate) }')\" arg:event=\"org.topbraid.swa.searchFacetChange\" arg:ownerId=\"{= ?id }\"/>
    </ui:group>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "An auto-complete field populated by the values of a dynamic enum range property." ;
  rdfs:label "Dynamic enum range facet" ;
  rdfs:subClassOf swa:ObjectFacet ;
.
swa:EditHandlerClass
  a rdfs:Class ;
  rdfs:comment "Metaclass of swa:EditHandlers. Makes the swa:confirmHandler show up on their forms." ;
  rdfs:label "Edit handler class" ;
  rdfs:subClassOf ui:Service ;
.
swa:EditHandlers
  a swa:EditHandlerClass ;
  ui:abstract true ;
  ui:private true ;
  rdfs:comment "An abstract element that should be used to group together edit handlers that are called by the client to perform updates. Those services should create a ui:transaction and within it ui:updates. The EVN/Teamwork platform is currently the only officially supported mode of this, and the JSON response is automatically created by the ui:transaction." ;
  rdfs:label "Edit handlers" ;
  rdfs:subClassOf ui:JSONServices ;
.
swa:EditMode
  a swa:Mode ;
  swa:formObjectPredicateSelectionTemplate swa:SuitableObjectPredicates ;
  swa:isSingleFunction swa:isSingle ;
  swa:modeLabel "Edit&nbsp;" ;
  swa:modeName "edit" ;
  swa:objectWidgetClass swa:ObjectEditor ;
  swa:objectWidgetMiddleColumnClass swa:EditWidgetMiddleColumn ;
  swa:objectWidgetRowClass swa:ObjectEditorRow ;
  swa:subjectWidgetMiddleColumnClass swa:SubjectEditWidgetMiddleColumn ;
  swa:subjectWidgetRowClass swa:SubjectEditorRow ;
  rdfs:label "Edit mode" ;
.
swa:EditResourceDialog
  a ui:NodeClass ;
  a owl:DeprecatedClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:title ;
      spl:valueType xsd:string ;
      rdfs:comment "The title of the dialog. If left unbound, this will use the label of the resource." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:loadId ;
      spl:valueType xsd:string ;
      rdfs:comment "The ui:loadId of the ui:loadable that will be placed around the dialog." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to display." ;
    ] ;
  ui:prototype """
<div id=\"div-{= ?loadId }\" let:fid=\"form-{= ?loadId }\" title=\"{= COALESCE(?title, ui:label(?resource)) }\">
    <ui:setContext ui:varName=\"createLinkFunction\" ui:varValue=\"{= swa:createNoLink }\">
        <ui:loadable class=\"swa-dialog-body\" ui:loadId=\"{= ?fid }-loadable\">
            <ui:setContext ui:varName=\"mode\" ui:varValue=\"edit\">
                <form autocomplete=\"off\" class=\"swa-form\" id=\"{= ?fid }\" resource=\"{= swa:resourceURIOrBNodeId(?resource) }\">
                    <input name=\"_base\" type=\"hidden\" value=\"{= ui:currentQueryGraph() }\"/>
                    <div class=\"swa-form-body\">
                        <ui:resourceView ui:matchIds=\"{= ?extraMatchIds }edit,form\" ui:resource=\"{= ?resource }\"/>
                    </div>
                </form>
            </ui:setContext>
        </ui:loadable>
    </ui:setContext>
</div>
"""^^ui:Literal ;
  rdfs:comment "A dialog that shows a switchable form for a given resource. The JavaScript call swa.openEditResourceDialog() can be used to open it." ;
  rdfs:label "Switchable form dialog" ;
  rdfs:subClassOf swa:DialogElements ;
.
swa:EditSearchResultsAction
  a swa:SearchResultsAction ;
  arg:condition [
      a sp:if ;
      sp:arg1 [
          a sp:and ;
          sp:arg1 [
              a swa:hasAppName ;
              sp:arg1 [
                  sp:varName "appName" ;
                ] ;
              sp:arg2 "Editor" ;
            ] ;
          sp:arg2 [
              a sp:not ;
              sp:arg1 [
                  a swa:hasAppName ;
                  sp:arg1 [
                      sp:varName "appName" ;
                    ] ;
                  sp:arg2 "ReadOnly" ;
                ] ;
            ] ;
        ] ;
      sp:arg2 true ;
      sp:arg3 [
          sp:varName "none" ;
        ] ;
    ] ;
  arg:onSelect "swa.openMultiResourceEditDialogFromSearchForm(formId)" ;
  rdfs:label "Batch edit search results..." ;
.
swa:EditWidgetMiddleColumn
  a swa:ObjectWidgetMiddleColumnClass ;
  ui:prototype """
<td class=\"swa-labeled-objects-icons-td\" let:buttonId=\"{= ui:uniqueId() }\">
    <div class=\"{= IF(((?single || swa:isSingle(?predicate, ?subject)) &amp;&amp; (!swa:isBlankNodeProperty(?predicate))), &quot;swa-display-none&quot;, &quot; swa-icon&quot;) } swa-add-button-div\" data-context=\"{= ui:encodeContext() }\" id=\"{= ?buttonId }\">
        <ui:if ui:condition=\"{= !spl:instanceOf(?predicate, spin:MagicProperty) }\">
            <a class=\"swa-add-row-button\" href=\"javascript:void(0)\" onclick=\"{= ui:functionCall(COALESCE(swa:specialAddButtonFunction(?predicate, ?subject), IF(swa:isBlankNodeProperty(?predicate), &quot;swa.addBlankNodeObjectEditorRow&quot;, &quot;swa.addObjectEditorRow&quot;)), ui:currentQueryGraph(), CONCAT(?uid, &quot;-body&quot;), (?single = true), ?subject, ?predicate, COALESCE(swa:appName(), &quot;&quot;), ?editWidget, ?buttonId) }\"/>
        </ui:if>
    </div>
</td>
"""^^ui:Literal ;
  rdfs:label "Edit widget middle column" ;
  rdfs:subClassOf swa:ObjectWidgetMiddleColumn ;
.
swa:EditableDatatableGadget
  a swa:Gadget ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:columnsService ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:createHandler ;
      spl:valueType swa:CreateResourceService ;
      rdfs:comment "An (optional) custom handler for the create button." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:deleteHandler ;
      spl:valueType swa:DeleteResourcesService ;
      rdfs:comment "An SWP service that is called when the user presses the delete button." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:editButton ;
      spl:valueType xsd:boolean ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:exports ;
      spl:valueType xsd:boolean ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:filter ;
      spl:valueType xsd:boolean ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:hasCloneButton ;
      spl:valueType xsd:boolean ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:pageLength ;
      spl:valueType xsd:integer ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:readOnly ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to operate in view-only mode." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:rowCount ;
      spl:valueType xsd:integer ;
      rdfs:comment "The default number of rows to display." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:rowNumCookie ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of a cookie remembering the number of rows." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:suppressLabelColumn ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to suppress the first column." ;
    ] ;
  ui:prototype """
<ui:group let:gridId=\"{= ui:uniqueId() }\" let:id=\"{= ui:uniqueId() }\" let:pagerId=\"{= ui:uniqueId() }\">
    <swa:Subscribe arg:code=\"swa.searchPerformed=true;swa.loadWithResource('{= ?id }-loadable', 'searchGraph', data)\" arg:event=\"{= swa:searchEvent(?searchEvent) }\"/>
    <swa:Subscribe arg:code=\"swa.handleChangeForGrid(data, '{= ?gridId }')\" arg:event=\"org.topbraid.swa.change\"/>
    <ui:loadable class=\"ui-layout-content\" ui:loadId=\"{= ?id }-loadable\" ui:loadOnDemand=\"{= true }\">
        <swa:DataTableSearchResultsBody arg:editButton=\"{= ?editButton }\" arg:editable=\"{= !?readOnly }\" arg:hasCloneButton=\"{= ?hasCloneButton }\" arg:hideIfEmpty=\"{= false }\" ui:args=\"*\"/>
    </ui:loadable>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment """A gadget displaying a datatable where each row represents one resource. The datatable has editing support via Add, Edit and Delete buttons at the top.

The rows of the datatable are derived from a search, e.g. combined with a swa:FormSearchGadget or a swa:FacetedSearchGadget. By default, the datatable typically displays all instances, i.e. an \"empty\" search that can be started using arg:autoStart=\"true\" at the associated swa:FormSearchGadget.""" ;
  rdfs:label "Editable Datatable gadget" ;
  rdfs:subClassOf swa:SearchResultsGadgets ;
.
swa:EditableGridGadget
  a swa:Gadget ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:createHandler ;
      spl:valueType swa:CreateResourceService ;
      rdfs:comment "An (optional) custom handler for the create button." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:deleteHandler ;
      spl:valueType swa:DeleteResourcesService ;
      rdfs:comment "An SWP service that is called when the user presses the delete button." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:readOnly ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to operate in view-only mode." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:rowCount ;
      spl:valueType xsd:integer ;
      rdfs:comment "The default number of rows to display." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:rowNumCookie ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of a cookie remembering the number of rows." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:suppressLabelColumn ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to suppress the first column." ;
    ] ;
  ui:prototype """
<ui:group let:gridId=\"{= ui:uniqueId() }\" let:id=\"{= ui:uniqueId() }\" let:pagerId=\"{= ui:uniqueId() }\">
    <swa:Subscribe arg:code=\"swa.searchPerformed=true;swa.loadWithResource('{= ?id }-loadable', 'searchGraph', data)\" arg:event=\"{= swa:searchEvent(?searchEvent) }\"/>
    <swa:Subscribe arg:code=\"swa.handleChangeForGrid(data, '{= ?gridId }')\" arg:event=\"org.topbraid.swa.change\"/>
    <ui:loadable class=\"ui-layout-content\" ui:loadId=\"{= ?id }-loadable\" ui:loadOnDemand=\"{= true }\">
        <swa:GridSearchResultsBody arg:multiSelect=\"{= true }\" arg:onDoubleClick=\"{= IF(swa:falseOrUnbound(?readOnly), &quot;swa.openSwitchableResourceDialog(resource)&quot;, &quot;swa.openViewResourceDialog(resource)&quot;) }\" arg:topPager=\"{= true }\" ui:args=\"*\"/>
        <ui:if let:function=\"{= ui:contextValue(&quot;swaCanDeleteResourceFunction&quot;) }\" ui:condition=\"{= swa:falseOrUnbound(?readOnly) }\">
            <ui:group let:resourceType=\"{#
                    SELECT ?resourceType
                    WHERE {
                        GRAPH ?searchGraph {
                            BIND (spl:object(search:theSearch(), search:rootType) AS ?resourceType) .
                        } .
                    } }\">
                <script>if ( $('#datasetappSearchResultsWindow').length ) { swa.setStorageValue('datasetapp-gridId', '{= ?gridId }');}
swa.addGridButton(\"{= ?gridId }\", \"{= ?pagerId }\", {= ui:functionCall(\"swa.createEditRowsButton\", ?gridId, ?resourceType, IF(bound(?function), xsd:string(?function), \"\")) })</script>
                <ui:if ui:condition=\"{= bound(?createHandler) }\">
                    <script>swa.addGridButton(\"{= ?gridId }\", \"{= ?pagerId }\", {= ui:functionCall(\"swa.createCustomCreateRowButton\", ?gridId, ?resourceType, ui:label(?resourceType), ?createHandler) })</script>
                </ui:if>
                <ui:else>
                    <script>swa.addGridButton(\"{= ?gridId }\", \"{= ?pagerId }\", {= ui:functionCall(\"swa.createCreateRowButton\", ?gridId, ?resourceType, ui:label(?resourceType), ?resourceSelectedEvent) })</script>
                </ui:else>
            </ui:group>
            <ui:if ui:condition=\"{= bound(?deleteHandler) }\">
                <script>swa.addGridButton(\"{= ?gridId }\", \"{= ?pagerId }\", {= ui:functionCall(\"swa.createDeleteRowsButton\", ?gridId, ?deleteHandler, IF(bound(?function), xsd:string(?function), \"\")) })</script>
            </ui:if>
        </ui:if>
        <script>(function ($) {
			'use strict';
			$(document).ready(function () {

				{= ui:functionCall(\"swa.initGridFooter\", ?pagerId) }

			});
		}(jQuery));</script>
    </ui:loadable>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment """A gadget displaying a grid where each row represents one resource. The grid has editing support via Add, Edit and Delete buttons at the bottom.

The rows of the grid are derived from a search, e.g. combined with a swa:FormSearchGadget or a swa:FacetedSearchGadget. By default, the grid typically displays all instances, i.e. an \"empty\" search that can be started using arg:autoStart=\"true\" at the associated swa:FormSearchGadget.""" ;
  rdfs:label "Editable grid gadget" ;
  rdfs:subClassOf swa:SearchResultsGadgets ;
.
swa:Elements
  a ui:NodeClass ;
  ui:abstract true ;
  ui:headIncludes """
<ui:group>
    <!-- shortcut icon -->
    <link href=\"{= ui:lib() }/assets/images/tqicon.ico\" rel=\"shortcut icon\"/>
    <script>$.jqplot.config.enablePlugins = true;</script>
    <script>swa.imgPath=\"{= ui:lib() }/assets/build/images/carousel/\";</script>
</ui:group>
"""^^ui:Literal ;
  ui:includeScript swa:Bundle ;
  ui:includeScript swa:VendorScripts ;
  ui:includeStyle swa:VendorStyles ;
  rdfs:comment "Abstract superclass of all SWA elements. Makes sure that certain required head includes (JavaScript and CSS files) are present." ;
  rdfs:label "Elements" ;
  rdfs:subClassOf ui:ViewElements ;
.
swa:EmptyTemplate
  a spin:SelectTemplate ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "dummy" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Filter ;
            sp:expression false ;
          ]
        ) ;
    ] ;
  rdfs:comment "A template that can be used to represent an empty result set with one column but now rows, if a reference to a template is needed." ;
  rdfs:label "Empty template" ;
  rdfs:subClassOf spin:SelectTemplates ;
.
swa:ExactMatchStringFacet
  a swa:ObjectFacetClass ;
  swa:facetSearchType search:ObjectFacetValue ;
  swa:objectFacetMenuName "text equals" ;
  swa:objectWidgetWeight [
      a swa:WeightedExpression ;
      swa:expression [
          a sp:or ;
          sp:arg1 [
              a sp:eq ;
              sp:arg1 [
                  sp:varName "range" ;
                ] ;
              sp:arg2 xsd:string ;
            ] ;
          sp:arg2 [
              a sp:eq ;
              sp:arg1 [
                  sp:varName "range" ;
                ] ;
              sp:arg2 rdfs:Literal ;
            ] ;
        ] ;
      swa:weight -1 ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:group let:datatype=\"{= swa:localRange(?predicate, ?subject) }\" let:restore=\"{= swa:restoreFacetValue(?predicate) }\">
    <div class=\"nowrap\" let:restoreObject=\"{= IF(bound(?restore), spl:object(?restore, search:object), ?none) }\">
        <input class=\"swa-exact-match-input form-control {= swa:testClass(?predicate) }\" id=\"{= ?uid }-text\" onchange=\"swa.updateExactMatchStringFacet('{= ?uid }')\" type=\"text\" value=\"{= ?restoreObject }\"/>
        <swa:LangSelector arg:changeHandler=\"swa.updateExactMatchStringFacet('{= ?uid }')\" arg:initialValue=\"{= lang(?restoreObject) }\" arg:uid=\"{= ?uid }\"/>
        <input id=\"{= ?uid }-hidden\" name=\"value{= ?uid }\" type=\"hidden\" value=\"\"/>
    </div>
    <ui:if ui:condition=\"{= bound(?restore) }\">
        <script>swa.updateExactMatchStringFacet('{= ?uid }')</script>
    </ui:if>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "An ObjectFacet showing a text field. The resulting string will be matched against using equals comparison, i.e. not a regex." ;
  rdfs:label "Exact match string facet" ;
  rdfs:subClassOf swa:ObjectFacet ;
.
swa:ExistingValuesSelectFacet
  a swa:ObjectFacetClass ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:label ;
      spl:valueType xsd:string ;
    ] ;
  ui:prototype """
<span let:mylabel=\"{= COALESCE(?label, &quot;Select...&quot;) }\" let:name=\"value{= ?uid }\" let:resourceType=\"{= swa:resourceType() }\">
    <select class=\"form-control\" name=\"{= ?name }\">
        <option disabled=\"disabled\" selected=\"selected\">{= ?mylabel }</option>
        <ui:forEach ui:indexVar=\"index\" ui:resultSet=\"{#
                SELECT DISTINCT ?value ?valueLabel
                WHERE {
                    ?type (rdfs:subClassOf)* ?resourceType .
                    ?instance a ?type .
                    ?instance ?predicate ?value .
                    BIND (ui:label(?value) AS ?valueLabel) .
                }
                ORDER BY (?valueLabel) }\">
            <option selected=\"{= IF((?object = ?value), &quot;selected&quot;, ?none) }\" value=\"{= ui:encodeNode(?value, true, true) }\">{= ?valueLabel }</option>
        </ui:forEach>
    </select>
</span>
"""^^ui:Literal ;
  rdfs:comment "A simple drop down box of all existing values of the given property at any instance of the given resource type. This may be slow for large models." ;
  rdfs:label "Existing values select facet" ;
  rdfs:subClassOf swa:ObjectFacet ;
.
swa:ExportGridCallback
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:data ;
      spl:valueType xsd:string ;
      rdfs:comment "The data to export - the service basically just echos this string back." ;
    ] ;
  ui:prototype """
<ui:group>{= ?data }</ui:group>
"""^^ui:Literal ;
  ui:responseType ui:TEXT ;
  rdfs:comment "Used by swa:ResultSetGrid as a server-side callback to render a result set into a tab-separated values text table." ;
  rdfs:label "Export grid callback" ;
  rdfs:subClassOf swa:GridElements ;
.
swa:ExportSearchResultsToCSVAction
  a swa:SearchResultsAction ;
  arg:condition true ;
  arg:onSelect "swa.exportSearchResults(formId,  searchGraph, 'csv')" ;
  rdfs:label "Export results to SPARQL CSV spreadsheet" ;
.
swa:ExportSearchResultsToJSONAction
  a swa:SearchResultsAction ;
  arg:condition true ;
  arg:onSelect "swa.exportSearchResults(formId, searchGraph, 'json')" ;
  rdfs:label "Export results to SPARQL JSON file" ;
.
swa:ExportSearchResultsToSimpleAction
  a swa:SearchResultsAction ;
  arg:condition true ;
  arg:onSelect "swa.exportSearchResults(formId, searchGraph,  'simple')" ;
  rdfs:label "Export results to simple TSV spreadsheet" ;
.
swa:ExportSearchResultsToTSVAction
  a swa:SearchResultsAction ;
  arg:condition true ;
  arg:onSelect "swa.exportSearchResults(formId,  searchGraph, 'tsv')" ;
  rdfs:label "Export results to SPARQL TSV spreadsheet" ;
.
swa:ExportSearchResultsToXMLAction
  a swa:SearchResultsAction ;
  arg:condition true ;
  arg:onSelect "swa.exportSearchResults(formId, searchGraph, 'xml')" ;
  rdfs:label "Export results to SPARQL XML file" ;
.
swa:FieldViewGadget
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:focusNode ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The focus node (usually subject)." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate being edited." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:viewGadget ;
      spl:valueType rdfs:Resource ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:group>
    <ui:dynamicView arg:focusNode=\"{= ?focusNode }\" arg:path=\"{= ?predicate }\" ui:class=\"{= ?viewGadget }\"/>
</ui:group>
"""^^ui:Literal ;
  ui:responseType ui:HTML ;
  rdfs:comment "Callback used by the FormField when the property defines a tosh:viewGadget." ;
  rdfs:label "Field view gadget" ;
  rdfs:subClassOf swa:FormElements ;
.
swa:FieldViewer
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:inverse ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to insert a subjects body." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:focusNode ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The focus node (usually subject)." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate being edited." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:value ;
      rdfs:comment "The RDF value." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:viewWidget ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The view widget to use." ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:group>
    <ui:if ui:condition=\"{= ?inverse }\">
        <ui:dynamicView arg:object=\"{= ?value }\" arg:subject=\"{= ?focusNode }\" ui:args=\"*\" ui:class=\"{= ?viewWidget }\"/>
    </ui:if>
    <ui:else>
        <ui:dynamicView arg:object=\"{= ?value }\" arg:subject=\"{= ?focusNode }\" ui:args=\"*\" ui:class=\"{= ?viewWidget }\"/>
    </ui:else>
</ui:group>
"""^^ui:Literal ;
  ui:responseType ui:HTML ;
  rdfs:comment "Callback used by the FormView when the property defines a tosh:viewWidget that is not handled client-side." ;
  rdfs:label "Field viewer" ;
  rdfs:subClassOf swa:FormElements ;
.
swa:FilterFunctions
  a spin:Function ;
  spin:abstract true ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:node ;
      rdfs:comment "The RDF node to filter." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Abstract superclass of SPIN functions that take an RDF node as an argument and either return true (allowed) or false (disallowed). Use cases of those functions include filtering nodes in trees." ;
  rdfs:label "Filter functions" ;
  rdfs:subClassOf swa:Functions ;
.
swa:FindClassOrPropertyByText
  a spin:SelectTemplate ;
  spin:body [
      a sp:Select ;
      sp:distinct true ;
      sp:limit "100"^^xsd:long ;
      sp:orderBy (
          [
            sp:varName "label" ;
          ]
        ) ;
      sp:resultVariables (
          [
            sp:varName "label" ;
          ]
          [
            sp:varName "predicate" ;
          ]
          [
            sp:varName "text" ;
          ]
          [
            sp:varName "uri" ;
          ]
        ) ;
      sp:where (
          (
            (
              [
                a sp:Union ;
                sp:elements (
                    (
                      [
                        a sp:TriplePath ;
                        sp:object [
                            sp:varName "rootClass" ;
                          ] ;
                        sp:path [
                            a sp:ModPath ;
                            sp:modMax -2 ;
                            sp:modMin 0 ;
                            sp:subPath rdfs:subClassOf ;
                          ] ;
                        sp:subject [
                            sp:varName "resource" ;
                          ] ;
                      ]
                    )
                    (
                      [
                        a sp:TriplePath ;
                        sp:object rdf:Property ;
                        sp:path [
                            a sp:ModPath ;
                            sp:modMax -2 ;
                            sp:modMin 0 ;
                            sp:subPath rdfs:subClassOf ;
                          ] ;
                        sp:subject [
                            sp:varName "type" ;
                          ] ;
                      ]
                      [
                        sp:object [
                            sp:varName "type" ;
                          ] ;
                        sp:predicate rdf:type ;
                        sp:subject [
                            sp:varName "resource" ;
                          ] ;
                      ]
                    )
                  ) ;
              ]
              [
                a sp:Filter ;
                sp:expression [
                    a sp:and ;
                    sp:arg1 [
                        a sp:isIRI ;
                        sp:arg1 [
                            sp:varName "resource" ;
                          ] ;
                      ] ;
                    sp:arg2 [
                        a sp:or ;
                        sp:arg1 [
                            a sp:not ;
                            sp:arg1 [
                                a sp:bound ;
                                sp:arg1 [
                                    sp:varName "filterFunction" ;
                                  ] ;
                              ] ;
                          ] ;
                        sp:arg2 [
                            a spif:invoke ;
                            sp:arg1 [
                                sp:varName "filterFunction" ;
                              ] ;
                            sp:arg2 [
                                sp:varName "resource" ;
                              ] ;
                          ] ;
                      ] ;
                  ] ;
              ]
            )
            [
              sp:object [
                  sp:varName "text" ;
                ] ;
              sp:predicate [
                  sp:varName "predicate" ;
                ] ;
              sp:subject [
                  sp:varName "resource" ;
                ] ;
            ]
            [
              a sp:Filter ;
              sp:expression [
                  a sp:regex ;
                  sp:arg1 [
                      sp:varName "text" ;
                    ] ;
                  sp:arg2 [
                      sp:varName "string" ;
                    ] ;
                  sp:arg3 "i" ;
                ] ;
            ]
          )
          [
            a sp:Bind ;
            sp:expression [
                a ui:label ;
                sp:arg1 [
                    sp:varName "resource" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "label" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:str ;
                sp:arg1 [
                    sp:varName "resource" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "uri" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:column [
      a spin:Column ;
      spin:columnIndex 0 ;
      spin:columnWidth 200 ;
      rdfs:label "Resource" ;
    ] ;
  spin:column [
      a spin:Column ;
      spin:columnIndex 1 ;
      spin:columnWidth 150 ;
      rdfs:label "Predicate" ;
    ] ;
  spin:column [
      a spin:Column ;
      spin:columnIndex 2 ;
      spin:columnWidth 200 ;
      rdfs:label "Text" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:filterFunction ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "An optional filter function." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:string ;
      spl:valueType xsd:string ;
      rdfs:comment "The match string." ;
    ] ;
  rdfs:label "Find class or property by text" ;
  rdfs:subClassOf spin:SelectTemplates ;
.
swa:FindClassOrPropertyByTextDialog
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:filterFunction ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "An optional filter function." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:loadId ;
      spl:valueType xsd:string ;
      rdfs:comment "The loadId." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resourceSelectedEvent ;
      spl:valueType xsd:string ;
      rdfs:comment "The event to publish when a resource is selected from the grid." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:rootClass ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The root class of the tree." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:treeId ;
      spl:valueType xsd:string ;
      rdfs:comment "The id of the tree to update." ;
    ] ;
  ui:private true ;
  ui:prototype """
<div id=\"div-{= ?loadId }\" let:id=\"{= ui:uniqueId() }\" title=\"Find class or property by text\">
    <div>
        <span>
            <b>Text: </b>
        </span>
        <input class=\"form-control swa-find-class-or-property-by-text-dialog-form-control\" id=\"{= ?id }\" type=\"text\"/>
        <swa:Space/>
        <div class=\"inline-block\">
            <button class=\"btn btn-primary btn-sm swa-margin-ten\" onclick=\"var s = $('#{= ?id }').val();if(s &amp;&amp; s != '') { swa.load('{= ?id }-loadable', { string: '&quot;' + s + '&quot;' }) }\">Search</button>
            <button class=\"btn btn-primary btn-sm swa-margin-ten\" onclick=\" $('#div-{= ?loadId }').remove();\">Select</button>
        </div>
    </div>
    <ui:loadable class=\"swa-find-class-or-property-by-text-dialog-loadable\" ui:loadId=\"{= ?id }-loadable\" ui:loadOnDemand=\"{= true }\">
        <ui:call arg:filterFunction=\"{= IF((bound(?filterFunction) &amp;&amp; (?filterFunction != &quot;&quot;)), ?filterFunction, ?none) }\" arg:rootClass=\"{= ?rootClass }\" arg:string=\"{= ?string }\" ui:template=\"{= swa:FindClassOrPropertyByText }\">
            <swa:ResultSetGrid arg:additionalClasses=\"FindClassOrProp\" arg:dtType=\"findClassByProperty\" arg:hiddenColName=\"uri\" arg:resourceSelectedEvent=\"org.ontologyapp.instanceSelected\" arg:resultSet=\"{= ?rs }\"/>
        </ui:call>
    </ui:loadable>
</div>
"""^^ui:Literal ;
  rdfs:label "Find class or property by text dialog" ;
  rdfs:subClassOf swa:DialogElements ;
.
swa:FirstInstances
  a spin:SelectTemplate ;
  spin:body [
      a sp:Select ;
      sp:orderBy (
          [
            a ui:label ;
            sp:arg1 [
                sp:varName "instance" ;
              ] ;
          ]
        ) ;
      sp:resultVariables (
          [
            sp:varName "instance" ;
          ]
          [
            sp:varName "uri" ;
          ]
          [
            sp:varName "type" ;
          ]
        ) ;
      sp:where (
          [
            a sp:SubQuery ;
            sp:query [
                a sp:Select ;
                sp:limit "200"^^xsd:long ;
                sp:where (
                    [
                      a sp:TriplePath ;
                      sp:object [
                          sp:varName "class" ;
                        ] ;
                      sp:path [
                          a sp:ModPath ;
                          sp:modMax -2 ;
                          sp:modMin 0 ;
                          sp:subPath rdfs:subClassOf ;
                        ] ;
                      sp:subject [
                          sp:varName "type" ;
                        ] ;
                    ]
                    [
                      sp:object [
                          sp:varName "type" ;
                        ] ;
                      sp:predicate rdf:type ;
                      sp:subject [
                          sp:varName "instance" ;
                        ] ;
                    ]
                  ) ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a xsd:string ;
                sp:arg1 [
                    sp:varName "instance" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "uri" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:class ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class that the instances must have." ;
    ] ;
  rdfs:comment "Gets a number of instances of a given class, and its subclasses, and orders them by label. The current cut-off is after 200 instances, and ordering is done at the end so the output may be unpredictable." ;
  rdfs:label "First instances" ;
  rdfs:subClassOf spin:SelectTemplates ;
.
swa:FocusNodeReportService
  a ui:Service ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:focusNode ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The focus node. Can be empty to support invocation from swa:GraphReportService (this may change in the future)." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:generatorIds ;
      spl:valueType xsd:string ;
      rdfs:comment "A comma-separated list of generator IDs (see ResultsGeneratorFactory.getId()). If provided then only the matching generators will be executed." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The type of instances to report on - leave empty for all instances." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:validationPlugin ;
      spl:valueType ui:NodeClass ;
      rdfs:comment "An optional SWP element that shall be called with an argument arg:dataGraph (pointing at the query graph) and with the results of the validation as default graph." ;
    ] ;
  ui:prototype """
<ui:group let:queryGraph=\"{= ui:currentQueryGraph() }\" let:report=\"{= BNODE() }\">
    <sml:GenerateReport sml:class=\"{= ?resourceType }\" sml:focusNode=\"{= ?focusNode }\" sml:ids=\"{= ?generatorIds }\" sml:ignoreImports=\"{= true }\" sml:result=\"{= ?report }\">
        <ui:update ui:updateQuery=\"{!
                INSERT {
                    GRAPH ui:tempGraph {
                        ?s ?p ?o .
                    } .
                }
                WHERE {
                    ?s ?p ?o .
                } }\"/>
    </sml:GenerateReport>
    <ui:if ui:condition=\"{= !bound(?generatorIds) }\">
        <sml:ValidateGraph sml:class=\"{= ?resourceType }\" sml:focusNode=\"{= ?focusNode }\" sml:generateSuggestions=\"{= true }\" sml:ignoreImports=\"{= true }\" sml:ignoreSPLConstraints=\"{= true }\">
            <ui:update ui:updateQuery=\"{!
                    INSERT {
                        GRAPH ui:tempGraph {
                            ?s ?p ?o .
                        } .
                    }
                    WHERE {
                        ?s ?p ?o .
                    } }\"/>
            <ui:if ui:condition=\"{= bound(?validationPlugin) }\">
                <ui:dynamicView arg:dataGraph=\"{= ?queryGraph }\" ui:class=\"{= ?validationPlugin }\"/>
            </ui:if>
        </sml:ValidateGraph>
    </ui:if>
    <ui:setContext ui:queryGraph=\"{= ui:tempGraph }\">
        <ui:update ui:updateQuery=\"{!
                INSERT {
                    ?report sh:result ?result .
                }
                WHERE {
                    ?rep sh:result ?result .
                    ?result sh:focusNode ?focusNode .
                } }\"/>
        <tosh.ui:getReportJSON arg:labelsGraph=\"{= ?queryGraph }\" arg:limit=\"{= 1000 }\" arg:report=\"{= ?report }\"/>
    </ui:setContext>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "Gets a JSON report for a given focus node or all nodes, including the results delivered by sml:GenerateReport and sml:ValidateGraph." ;
  rdfs:label "Focus node report service" ;
  rdfs:subClassOf ui:JSONServices ;
.
swa:Form
  a swa:FormClass ;
  ui:abstract true ;
  rdfs:comment "Base class for the various types of forms, depending on the mode." ;
  rdfs:label "Form" ;
  rdfs:subClassOf swa:FormElements ;
.
swa:FormBody
  a ui:ResourceViewClass ;
  ui:abstract true ;
  rdfs:comment "Base class for the body element of forms. Subclasses of this are meant to be inserted into Forms, and should be associated as ui:instanceView with domain classes." ;
  rdfs:label "Form body" ;
  rdfs:subClassOf swa:FormElements ;
  rdfs:subClassOf ui:ResourceViews ;
.
swa:FormClass
  a rdfs:Class ;
  rdfs:comment "Metaclass for the various kinds of forms." ;
  rdfs:label "Form class" ;
  rdfs:subClassOf ui:NodeClass ;
.
swa:FormElements
  a ui:NodeClass ;
  ui:abstract true ;
  ui:private true ;
  rdfs:comment "Abstract superclass to group together form related SWA elements." ;
  rdfs:label "Form elements" ;
  rdfs:subClassOf swa:Elements ;
.
swa:FormHeader
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:label ;
      spl:valueType xsd:string ;
      rdfs:comment "The label to put upfront, e.g. \"Edit \"." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:toolTip ;
      spl:valueType xsd:string ;
      rdfs:comment "A tool tip text for the header." ;
    ] ;
  ui:private true ;
  ui:prototype """
<div class=\"swa-header\" title=\"{= ?toolTip }\">
    <div class=\"swa-top\">
        <div class=\"swa-left swa-header-label\">
            <ui:if ui:condition=\"{= bound(?label) }\">
                <span>{= ?label }</span>
            </ui:if>
        </div>
        <div class=\"swa-right swa-form-header-toolbar\">
            <ui:insertionPoint ui:pointId=\"toolBar\"/>
        </div>
    </div>
</div>
"""^^ui:Literal ;
  rdfs:comment "A header for forms, with a potential extension point to insert buttons in the upper right corner. Not stable." ;
  rdfs:label "Form header" ;
  rdfs:subClassOf swa:FormElements ;
.
swa:FormSearchGadget
  a swa:Gadget ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:autoStart ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to have the form submit its \"empty\" default search. This can be used to pre-populate any depending result widgets." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:cacheId ;
      spl:valueType xsd:string ;
      rdfs:comment "An ID to activate caching." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:checkAllProperties ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to have all properties (check boxes) checked by default, unless a search is restored or a search:defaultSearch exists." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:extraResourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "If specified, this type and its subclasses will also be shown in the type selection drop down. Use case is skos:Concept + skosxl:Label (extra)." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:footerPlugin ;
      spl:valueType swa:SearchFormFooterPlugin ;
      rdfs:comment "An SWP element to appear in the lower right corner." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:formId ;
      spl:valueType xsd:string ;
      rdfs:comment "The id that shall be used for the new form. The system will generate a unique new id if left blank." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:hideCaseSensitivity ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to hide the check box for case sensitive search at the global text search." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:hideGlobalSearch ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to suppress global text search. By default a text field will appear on the top of the form, allowing users to search across all string properties of the given resources. However, this may be slow and can therefore be disabled. If the class being searched over defines swa:textSearchProperties, then the text search will only operate on those explicitly enumerated properties - even if arg:hideGlobalSearch is true." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:localSearch ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to always use local search, false to always use global search, unspecified to allow the user to choose." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:plugin ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "An optional plugin (subclass of swa:SearchFormPlugins) that will be inserted at the bottom of the search form." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:searchButtonHandler ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of a JavaScript function to handle the click event for the Search button." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:staticTitle ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to not have the gadget update the title of the surrounding window." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:suppressExcludeSubclassesBox ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to never show the Exclude subclasses of X checkbox at the bottom." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:suppressKeyPropertiesSelection ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to disable the check boxes for selecting the result columns." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:suppressLocalSearch ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to have no local search option." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:suppressNestedKeyPropertiesSelection ;
      spl:valueType xsd:boolean ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:typeSelectable ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to allow users to switch to the search class using a drop down box." ;
    ] ;
  ui:prototype """
<ui:group let:fid=\"{= IF(bound(?formId), ?formId, ui:uniqueId()) }\" let:searchGraph=\"{= ui:createSessionGraph() }\">
    <ui:if ui:condition=\"{= swa:falseOrUnbound(?staticTitle) }\">
        <swa:WindowTitleSetter arg:title=\"Search for {= ui:label(?resourceType) }\"/>
    </ui:if>
    <ui:setContext let:lid=\"{= IF(bound(?formId), CONCAT(?formId, &quot;LID&quot;), ui:uniqueId()) }\" ui:varName=\"mode\" ui:varValue=\"search\">
        <ui:if ui:condition=\"{= ?typeSelectable }\">
            <ui:loadable ui:loadId=\"{= ?fid }TypeSwitch\">
                <swa:SearchFormTypeSwitch arg:extraResourceType=\"{= ?extraResourceType }\" arg:fid=\"{= ?fid }\" arg:loadId=\"{= ?lid }\" arg:resourceType=\"{= ?resourceType }\" arg:selectedType=\"{= IF(bound(?restoreSearch), spl:object(?restoreSearch, search:rootType), ?none) }\"/>
            </ui:loadable>
        </ui:if>
        <ui:loadable class=\"ui-layout-content swa-search-form\" ui:loadId=\"{= ?lid }\">
            <ui:setContext ui:varName=\"resourceType\" ui:varValue=\"{= ?resourceType }\">
                <ui:setContext ui:varName=\"createLinkFunction\" ui:varValue=\"{= swa:createNewTabLink }\">
                    <ui:setContext ui:varName=\"suppressRDFType\" ui:varValue=\"{= !?typeSelectable }\">
                        <ui:setContext ui:varName=\"swaRestoreSearch\" ui:varValue=\"{= COALESCE(?restoreSearch, spl:object(?resourceType, search:defaultSearch)) }\">
                            <ui:if ui:condition=\"{= bound(?restoreSearch) }\">
                                <script>{= ui:functionCall(\"swa.setWindowTitleIfExists\", ?fid, CONCAT(\"Search \", ui:label(?resourceType))) }</script>
                            </ui:if>
                            <form autocomplete=\"off\" class=\"swa-form search-mode swa-form-search\" id=\"{= ?fid }\" let:qg=\"{= IF(bound(?queryGraph), ?queryGraph, ui:currentQueryGraph()) }\" onsubmit=\"$('#test-search-button').click(); return false;\" searchGraph=\"{= ?searchGraph }\">
                                <input name=\"type\" type=\"hidden\" value=\"&lt;{= ?resourceType }&gt;\"/>
                                <input name=\"_base\" type=\"hidden\" value=\"{= ?qg }\"/>
                                <ui:if ui:condition=\"{= ?qg != ui:currentQueryGraph() }\">
                                    <input name=\"schema\" type=\"hidden\" value=\"{= ui:encodeNode(ui:currentQueryGraph(), true, true) }\"/>
                                </ui:if>
                                <ui:if ui:condition=\"{= ?sortByFirstKeyProperty }\">
                                    <input name=\"_sortByFirstKeyProperty\" type=\"hidden\" value=\"true\"/>
                                </ui:if>
                                <ui:setContext ui:varName=\"suppressKeyPropertiesSelection\" ui:varValue=\"{= ?suppressKeyPropertiesSelection }\">
                                    <div class=\"swa-form-body\">
                                        <swa:SearchFormHiddenFields/>
                                        <swa:SearchFormFullTextSection arg:hideCaseSensitivity=\"{= ?hideCaseSensitivity }\" arg:hideGlobalSearch=\"{= ?hideGlobalSearch }\" arg:resourceType=\"{= ?resourceType }\"/>
                                        <ui:setContext ui:varName=\"checkAllProperties\" ui:varValue=\"{= ?checkAllProperties }\">
                                            <ui:setContext ui:varName=\"suppressNestedKeyPropertiesSelection\" ui:varValue=\"{= ?suppressNestedKeyPropertiesSelection }\">
                                                <ui:if ui:condition=\"{= bound(?restoreSearch) || (!bound(?cacheId)) }\">
                                                    <ui:classView ui:class=\"{= swa:resourceType() }\" ui:matchIds=\"search,form\"/>
                                                </ui:if>
                                                <ui:else>
                                                    <ui:classView ui:cacheKey=\"swa:FormSearchGadget/{= ?cacheId }/{= swa:bnodeId(spl:object(?resourceType, search:defaultSearch)) }\" ui:class=\"{= swa:resourceType() }\" ui:matchIds=\"search,form\"/>
                                                </ui:else>
                                            </ui:setContext>
                                        </ui:setContext>
                                        <ui:if ui:condition=\"{= bound(?plugin) }\">
                                            <ui:dynamicView ui:class=\"{= ?plugin }\"/>
                                        </ui:if>
                                        <ui:if ui:condition=\"{= swa:falseOrUnbound(?suppressExcludeSubclassesBox) }\">
                                            <swa:SearchFormDirectInstancesSection arg:resourceType=\"{= ?resourceType }\"/>
                                        </ui:if>
                                        <ui:if ui:condition=\"{= swa:falseOrUnbound(?suppressLocalSearch) }\">
                                            <swa:SearchFormLocalSection arg:constant=\"{= ?localSearch }\"/>
                                        </ui:if>
                                        <swa:SearchFormKeyPropertiesHiddenFields arg:resourceType=\"{= ?resourceType }\"/>
                                    </div>
                                </ui:setContext>
                            </form>
                        </ui:setContext>
                    </ui:setContext>
                </ui:setContext>
            </ui:setContext>
        </ui:loadable>
        <div class=\"swa-form-footer\" let:handler=\"{= COALESCE(?searchButtonHandler, &quot;swa.performSearchFormSearch&quot;) }('{= ?fid }', '{= ?searchGraph }', '{= swa:searchEvent(?searchEvent) }')\">
            <swa:Button arg:class=\"btn btn-default btn-xs swa-search-button\" arg:id=\"{= ?fid }-search-button\" arg:label=\"Search\" arg:onClick=\"{= ?handler }\"/>
            <swa:Space/>
            <swa:Button arg:class=\"btn btn-default btn-xs\" arg:label=\"Reset\" arg:onClick=\"swa.reloadSearchForm('{= ?lid }')\"/>
            <ui:if ui:condition=\"{= ?loadImmediately }\">
                <script>{= ?handler }</script>
            </ui:if>
            <ui:if ui:condition=\"{= bound(?footerPlugin) }\">
                <swa:Space/>
                <swa:Space/>
                <div class=\"swa-float-right\">
                    <ui:dynamicView arg:formId=\"{= ?fid }\" ui:class=\"{= ?footerPlugin }\"/>
                </div>
            </ui:if>
        </div>
    </ui:setContext>
    <script type=\"text/javascript\">$(\"#{= ?fid }\").submit(function(e){$(\"#test-search-button\").click(); return false;});</script>
    <ui:if ui:condition=\"{= bound(?classSelectedEvent) }\">
        <swa:SubscribeArgument arg:argumentName=\"resourceType\" arg:event=\"{= ?classSelectedEvent }\"/>
    </ui:if>
    <ui:if ui:condition=\"{= bound(?autoStart) }\">
        <script>swa.whenReady(function () { {= ui:functionCall(\"swa.submitSearchForm\", ?fid) }})</script>
    </ui:if>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment """A form-based search gadget that provides input widgets for search filters (facet values).

Implementation note: The gadget creates a session graph at start-up and reuses that graph for the duration of its existence. Whenever the user clicks the search button, the content of that session graph is completely replaced with a new instance of search:Search, before the search event is published.""" ;
  rdfs:label "Form search gadget" ;
  rdfs:subClassOf swa:SearchGadgets ;
.
swa:FormSectionInfoButton
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:sectionId ;
      spl:valueType xsd:string ;
      rdfs:comment "The HTML ID of the section that this belongs to." ;
    ] ;
  ui:prototype """
<ui:if ui:condition=\"{= swa:isEditMode() }\">
    <swa:Space/>
    <swa:Space/>
    <span id=\"{= ?sectionId }-button\" onclick=\"swa.showFormSectionInfo('{= ?sectionId }')\">
        <i class=\"fa fa-info-circle\" style=\"color: #15428B; cursor: pointer\"/>
    </span>
</ui:if>
"""^^ui:Literal ;
  rdfs:label "Form section info button" ;
  rdfs:subClassOf swa:FormElements ;
.
swa:FormTitle
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to show the title for." ;
    ] ;
  ui:prototype """
<ui:if ui:condition=\"{= !swa:contextValueIsTrue(&quot;swaHideFormTitle&quot;) }\">
    <div class=\"swa-title\">{= ui:label(?resource) }</div>
</ui:if>
"""^^ui:Literal ;
  rdfs:comment "An element that should be used to insert a header into the top of a form body. This does not only set the correct CSS style, but also includes logic that allows surrounding callers to switch off the label altogether. For example, if the form is shown as part of an application that already shows the title in a separate Header object, then the application can use ui:setContext to set the variable \"swaHideFormTitle\" to true." ;
  rdfs:label "Form title" ;
  rdfs:subClassOf swa:FormElements ;
.
swa:FullScreenBorderLayout
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:customEast ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional JavaScript function that returns a configuration object for the east panel." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:customWest ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional JavaScript function that returns a configuration object for the west panel." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:deepLinkingEvent ;
      spl:valueType xsd:string ;
      rdfs:comment """The name of an event that shall be published and subscribed to for \"deep linking\". If set, then the value of the data payload of the event will be placed behind the # of the browser URL. JavaScript code is used to make sure that whenever this value changes (e.g. when the user hits the Back button), then the event is re-published. In a typical scenario, the deep linking event may be the \"resourceSelected\" event that other components on the screen subscribe to.

The value of this argument is also used in other places as a \"default\" for the resource selection. To support this, the value of this argument is being remembered on the client in the global variable swa.deepLinkingEvent.""" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:deepLinkingPanel ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the panel to open on startup if a deep link is present. Can only be used together with deepLinkingEvent. Possible values are \"center\", \"east\" etc." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:suppressInitializer ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to not include the swa:Initializer." ;
    ] ;
  ui:headIncludes """
<ui:group>
    <style>html, body {
			height: 100%;
			margin: 0;
		}</style>
</ui:group>
"""^^ui:Literal ;
  ui:prototype """
<ui:group let:uid=\"{= ui:uniqueId() }\">
    <ui:insertionPoint ui:pointId=\"1\"/>
    <ui:insertionPoint ui:pointId=\"2\"/>
    <ui:insertionPoint ui:pointId=\"3\"/>
    <ui:insertionPoint ui:pointId=\"4\"/>
    <ui:insertionPoint ui:pointId=\"5\"/>
    <script let:layoutFunction=\"{= ?uid }Layout\">function {= ?layoutFunction }() {
			var mainLayout = $('body').layout({
			defaults: {
				applyDefaultStyles: true,
				enableCursorHotkey: false
			}<swa:BorderLayoutOptions arg:closed=\"{= ?westClosed }\" arg:custom=\"{= ?customWest }\" arg:fixed=\"{= ?westFixed }\" arg:name=\"west\" arg:parent=\"body\" arg:size=\"{= ?westSize }\" arg:storageKey=\"{= ?storageKey }\"/>
        <swa:BorderLayoutOptions arg:closed=\"{= ?eastClosed }\" arg:custom=\"{= ?customEast }\" arg:fixed=\"{= ?eastFixed }\" arg:name=\"east\" arg:parent=\"body\" arg:size=\"{= ?eastSize }\" arg:storageKey=\"{= ?storageKey }\"/>
        <swa:BorderLayoutOptions arg:name=\"center\" arg:parent=\"body\" arg:storageKey=\"{= ?storageKey }\"/>
        <swa:BorderLayoutOptions arg:fixed=\"{= ?northFixed }\" arg:name=\"north\" arg:parent=\"body\" arg:size=\"{= ?northSize }\" arg:storageKey=\"{= ?storageKey }\"/>
        <swa:BorderLayoutOptions arg:fixed=\"{= ?southFixed }\" arg:name=\"south\" arg:parent=\"body\" arg:size=\"{= ?southSize }\" arg:storageKey=\"{= ?storageKey }\"/>})


return mainLayout;
}
	$(\"body\").attr(\"layoutfunction\", \"{= ?layoutFunction }\");

	$(document).ready(function () {

var layout = {= ?layoutFunction }();

$('.search-toggler').on('click', function () {

var layout = {= ?layoutFunction }();

	layout.toggle('west');

});


});</script>
    <ui:if ui:condition=\"{= (!bound(?suppressInitializer)) || (!?suppressInitializer) }\">
        <swa:Initializer/>
    </ui:if>
    <ui:if ui:condition=\"{= bound(?deepLinkingEvent) }\">
        <script>$(document).ready(function() {{= ui:functionCall(\"swa.initDeepLinking\", ?deepLinkingEvent, ?deepLinkingPanel) }})</script>
    </ui:if>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment """A convenience wrapper around the jQuery UI Layout. Makes it possible to define complex screen layouts with components in the west, east, north, south and center, and possibly with sliders between them. The BorderLayout can take up to 5 children, each of which must declare one the following HTML classes: \"ui-layout-west\", \"ui-layout-east\", \"ui-layout-north\", \"ui-layout-south\" or \"ui-layout-center\".

This element is mainly provided as a convenience, and possibly only for quick demos etc. For more options you may want to rather use jQuery UI Layout directly or create your own extension of this class based on a clone.""" ;
  rdfs:label "Full screen border layout" ;
  rdfs:subClassOf swa:AbstractBorderLayout ;
.
swa:FullTextSearchFunctions
  a spin:Function ;
  spin:abstract true ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:subClass ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class to start traversal at." ;
    ] ;
  rdfs:label "Full text search functions" ;
  rdfs:subClassOf swa:Functions ;
.
swa:Gadget
  a rdfs:Class ;
  rdfs:comment "A flexible, configurable user interface element that can be embedded into a gadget container, e.g. OpenSocial." ;
  rdfs:label "Gadget" ;
  rdfs:subClassOf ui:NodeClass ;
.
swa:GadgetWindows
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:layoutPanel ;
      spl:valueType xsd:string ;
      rdfs:comment "The target layout panel, e.g. \"center\"." ;
    ] ;
  ui:abstract true ;
  ui:responseType ui:HTML ;
  rdfs:comment """Base class for windows that can be loaded dynamically and then be inserted into an SWA application consisting of nested border layouts. Subclasses of this must have an swa:Window as the top-level result element, and that window should contain exactly one swa:Gadget. The window needs to pass through the provided arg:id - the easiest way to achieve that is using ui:args=\"*\".

These wrappers are needed and it is not sufficient to just have gadgets because the surrounding window does extra work such as setting the title and adding buttons that should depend on the actual gadget. Furthermore, gadgets may result in multiple DOM elements, and loading a Window makes sure that only one well-defined and reliable root exists.""" ;
  rdfs:label "Gadget windows" ;
  rdfs:subClassOf swa:AbstractWindow ;
.
swa:Gadgets
  a swa:Gadget ;
  ui:abstract true ;
  rdfs:comment "Base class of gadgets that can be inserted into a gadget container." ;
  rdfs:label "Gadgets" ;
  rdfs:subClassOf swa:Elements ;
.
swa:GenerateNewResourceURI
  a ui:Service ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Resource ;
    ] ;
  ui:prototype """
<ui:group let:aResourceType=\"{= IRI(?resourceType) }\">
    <ui:setContext ui:queryGraph=\"{= ui:unionGraph }\">
        <swon:Object>
            <swon:Value arg:name=\"newResourceURI\" arg:value=\"{= swa:newResourceForAssetCollection(?aResourceType) }\"/>
        </swon:Object>
    </ui:setContext>
</ui:group>
"""^^ui:Literal ;
  ui:responseType ui:JSON ;
  rdfs:label "Generate new resource URI" ;
  rdfs:subClassOf ui:JSONServices ;
.
swa:GenericTreeChildren
  a spin:SelectTemplate ;
  spin:body [
      a sp:Select ;
      sp:orderBy (
          [
            sp:varName "label" ;
          ]
        ) ;
      sp:resultVariables (
          [
            sp:varName "node" ;
          ]
          [
            sp:varName "label" ;
          ]
          [
            sp:varName "leaf" ;
          ]
          [
            sp:varName "icon" ;
          ]
          [
            sp:varName "movable" ;
          ]
        ) ;
      sp:where (
          [
            a sp:SubQuery ;
            sp:query [
                a sp:Select ;
                sp:limit "1000"^^xsd:long ;
                sp:where (
                    [
                      sp:object [
                          sp:varName "node" ;
                        ] ;
                      sp:predicate swa:genericTreeChild ;
                      sp:subject [
                          sp:varName "parent" ;
                        ] ;
                    ]
                    [
                      a sp:Filter ;
                      sp:expression [
                          a sp:or ;
                          sp:arg1 [
                              a sp:not ;
                              sp:arg1 [
                                  a sp:bound ;
                                  sp:arg1 [
                                      sp:varName "filterFunction" ;
                                    ] ;
                                ] ;
                            ] ;
                          sp:arg2 [
                              a spif:invoke ;
                              sp:arg1 [
                                  sp:varName "filterFunction" ;
                                ] ;
                              sp:arg2 [
                                  sp:varName "node" ;
                                ] ;
                            ] ;
                        ] ;
                    ]
                    [
                      a sp:Bind ;
                      sp:expression [
                          a sp:notExists ;
                          sp:elements (
                              [
                                sp:object [
                                    sp:varName "grandChild" ;
                                  ] ;
                                sp:predicate swa:genericTreeChild ;
                                sp:subject [
                                    sp:varName "node" ;
                                  ] ;
                              ]
                            ) ;
                        ] ;
                      sp:variable [
                          sp:varName "leaf" ;
                        ] ;
                    ]
                  ) ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a ui:label ;
                sp:arg1 [
                    sp:varName "node" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "label" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a swa:resourceIcon ;
                arg:resource [
                    sp:varName "node" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "icon" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:not ;
                sp:arg1 [
                    a swa:isGenericTreeTripleReadOnly ;
                    arg:child [
                        sp:varName "node" ;
                      ] ;
                    arg:parent [
                        sp:varName "parent" ;
                      ] ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "movable" ;
              ] ;
          ]
        ) ;
    ] ;
  rdfs:comment "Gets the children of a node in a generic tree. The context variable \"swaGenericTreeProperty\" must hold the property, which will be interpreted in forward direction (?parent ?p ?child) unless the context variable \"swaGenericTreeInverse\" is set to true. The tree icon can be overridden via the context variable \"swaGenericTreeIcon\"." ;
  rdfs:label "Generic tree children" ;
  rdfs:subClassOf swa:TreeChildrenTemplates ;
.
swa:GenericTreeDataProvider
  a swa:TreeDataProvider ;
  arg:changeHandler "swa.handleChangeForGenericTree" ;
  arg:treeChildrenTemplate swa:GenericTreeChildren ;
  arg:treePathTemplate swa:GenericTreePath ;
  arg:treeRootsTemplate swa:GenericTreeRoots ;
  rdfs:label "Generic tree data provider" ;
.
swa:GenericTreeGadget
  a swa:Gadget ;
  spin:constraint [
      a spl:Argument ;
      spl:defaultValue "swa:DefaultGenericTreePropertySelectionTemplate" ;
      spl:predicate arg:propertySelectionTemplate ;
      spl:valueType spin:SelectTemplate ;
      rdfs:comment "The URI of a SPIN template that delivers the available properties. This template should be a subclass of swa:GenericTreePropertySelectionTemplate." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:alwaysShowHeader ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to always show the header (selection of properties). This provides access to the \"parents only\" check box even if there is only one property." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:createHandler ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional JavaScript function that shall be executed when the user presses the create button. If left unspecified, a default CreateResourceButton will be inserted. The function must take four arguments: the URI of the resource type, the URI of the context resource (selected parent), the URI of the property and a boolean which is true if the property shall be used in inverse direction." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:editable ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to have a button to create classes appear under the tree." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:filterFunction ;
      spl:valueType spin:Function ;
      rdfs:comment "A filter function for the nodes in the tree (see swa:Tree)." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:inverse ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to use the property in inverse direction, i.e. (?child ?property ?parent) instead of the default (?parent ?property ?child)." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:parentsOnly ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to start with the parents-only option activated." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:property ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property to use for the parent-child relationship." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:refreshEvent ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of an event that causes the tree to refresh itself." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The type of resources to display." ;
    ] ;
  ui:prototype """
<ui:if ui:condition=\"{= bound(?resourceType) }\">
    <ui:setContext ui:varName=\"swaGenericTreeResourceType\" ui:varValue=\"{= ?resourceType }\">
        <ui:call arg:resourceType=\"{= ?resourceType }\" ui:template=\"{= COALESCE(?propertySelectionTemplate, swa:DefaultGenericTreePropertySelectionTemplate) }\">
            <ui:group let:inverse=\"{= COALESCE(?inverse, IF((spr:rowCount(?rs) = 1), spr:cell(?rs, 0, 1), false)) }\" let:parentsOnlyButtonId=\"genericTreeParentsOnly\" let:property=\"{= COALESCE(?property, IF((spr:rowCount(?rs) = 1), spr:cell(?rs, 0, 0), ?none)) }\">
                <ui:if ui:condition=\"{= (spr:rowCount(?rs) &gt; 1) || ?alwaysShowHeader }\">
                    <div class=\"swa-generic-tree-property-selection\" let:id=\"{= ui:uniqueId() }\">
                        <span class=\"swa-generic-tree-property-selection-label\">Property: </span>
                        <select autocomplete=\"off\" class=\"form-control swa-generic-tree-property-selection-select\" id=\"{= ?id }\" let:matchInverse=\"{= COALESCE(?inverse, false) }\" let:matchProperty=\"{= ?property }\">
                            <ui:if ui:condition=\"{= !bound(?property) }\">
                                <option value=\"\"/>
                            </ui:if>
                            <ui:forEach ui:resultSet=\"{= ?rs }\">
                                <option selected=\"{= IF(((?property = ?matchProperty) &amp;&amp; (?inverse = ?matchInverse)), &quot;selected&quot;, ?none) }\" value=\"{= IF(?readOnly, &quot;!&quot;, ?none) }{= IF(?inverse, &quot;-&quot;, ?none) }{= ?property }\">{= ui:label(?property) }{= IF(?inverse, \" [Inverse]\", ?none) }</option>
                            </ui:forEach>
                        </select>
                        <script>$('#{= ?id }').change(function() { swa.onGenericTreePropertySelectionChange($(this).val(), '{= ?resourceType }', $('#{= ?id }').closest('.swa-window')[0].id, '{= ?parentsOnlyButtonId }');});</script>
                        <swa:Space/>
                        <button class=\"btn btn-default btn-xs swa-button\" title=\"Show/Hide root nodes that have no children\">
                            <ui:handle ui:event=\"onclick\" ui:script=\"swa.onGenericTreeParentsOnlyChange('genericTreeParentsOnly', $('#{= ?id }').val(), '{= ?resourceType }', $('#{= ?id }').closest('.swa-window')[0].id)\"/>
                            <div class=\"ui-icon {= IF(COALESCE(?parentsOnly, false), &quot;ui-icon-circle-plus&quot;, &quot;ui-icon-circle-minus&quot;) }\" id=\"genericTreeParentsOnly\"/>
                        </button>
                        <ui:insertionPoint ui:pointId=\"headerButtons\"/>
                    </div>
                </ui:if>
                <ui:if ui:condition=\"{= bound(?property) }\">
                    <ui:setContext let:editable=\"{= IF((bound(?readOnly) &amp;&amp; ?editable), (!?readOnly), (?editable &amp;&amp; (!swa:internalGenericTreeReadOnlyHelper(?property, ?rs)))) }\" ui:varName=\"swaGenericTreeProperty\" ui:varValue=\"{= ?property }\">
                        <ui:setContext let:dataProvider=\"{= swa:GenericTreeDataProvider }\" let:treeId=\"{= COALESCE(?treeId, ui:uniqueId()) }\" ui:varName=\"swaGenericTreeInverse\" ui:varValue=\"{= bound(?inverse) &amp;&amp; ?inverse }\">
                            <div class=\"ui-layout-content\">
                                <ui:setContext ui:varName=\"swaGenericTreeParentsOnly\" ui:varValue=\"{= ?parentsOnly }\">
                                    <swa:Tree arg:dataProvider=\"{= ?dataProvider }\" arg:draggable=\"{= ?editable }\" arg:filterFunction=\"{= ?filterFunction }\" arg:id=\"{= ?treeId }\" arg:onSelect=\"{= swa:publishEvent(?resourceSelectedEvent, &quot;resource&quot;) }\" arg:treeMoveHandler=\"{= swa:GenericTreeMoveHandler }\"/>
                                </ui:setContext>
                            </div>
                            <script>$(\"#{= ?treeId }\").attr(\"swagenerictreeproperty\", \"{= ?property }\");</script>
                            <script>$(\"#{= ?treeId }\").attr(\"swagenerictreeinverse\", \"{= ?inverse }\");</script>
                            <script>$(\"#{= ?treeId }\").attr(\"swacontext\", \"{= ui:encodeContext() }\");</script>
                            <div class=\"swa-form-footer\">
                                <swa:AutoComplete arg:id=\"genericTreeAutoComplete\" arg:onSelect=\"swa.selectTreeNode('{= ?treeId }', resource, swa.queryGraphURI);\" arg:type=\"{= ?resourceType }\"/>
                                <div class=\"swa-float-right\">
                                    <ui:if ui:condition=\"{= ?editable }\">
                                        <ui:if ui:condition=\"{= bound(?createHandler) }\">
                                            <ui:group let:typeLabel=\"{= COALESCE(?resourceTypeLabel, ui:label(?resourceType)) }\">
                                                <swa:Button arg:class=\"btn btn-default btn-xs\" arg:iconClass=\"{= swa:resourceTypeIcon(?resourceType) }\" arg:onClick=\"{= ?createHandler }('{= ?resourceType }', swa.getSelectedTreeResourceOrError('{= ?treeId }', 'Error: Please select a parent resource first.'), '{= ?property }', {= ?inverse })\" arg:toolTip=\"{= COALESCE(?toolTip, CONCAT(&quot;Create &quot;, ?typeLabel, &quot;...&quot;)) }\"/>
                                            </ui:group>
                                        </ui:if>
                                        <ui:else>
                                            <swa:CreateResourceButton arg:contextResourceGetter=\"swa.getSelectedTreeResource('{= ?treeId }')\" arg:createHandler=\"{= swa:CreateGenericTreeResourceHandler }\" arg:iconClass=\"{= swa:resourceTypeIcon(?resourceType) }\" arg:resourceSelectedEvent=\"{= ?resourceSelectedEvent }\" arg:resourceType=\"{= ?resourceType }\"/>
                                        </ui:else>
                                    </ui:if>
                                    <ui:createLink arg:dataProvider=\"{= ?dataProvider }\" ui:sendContext=\"swaGenericTree\" ui:sendQueryGraph=\"{= true }\" ui:viewClass=\"{= swa:TreeTableExporter }\">
                                        <swa:Button arg:class=\"btn btn-default btn-xs\" arg:iconClass=\"ui-icon ui-icon-disk\" arg:onClick=\"window.open('{= ?link }')\" arg:toolTip=\"Export whole hierarchy\"/>
                                    </ui:createLink>
                                </div>
                            </div>
                            <ui:group default:ownerId=\"{= ?treeId }\">
                                <swa:Subscribe arg:code=\"{= spl:objectInGraph(?dataProvider, arg:changeHandler, ui:graph) }(data, '{= ?treeId }')\" arg:event=\"org.topbraid.swa.change\"/>
                                <swa:Subscribe arg:code=\"swa.selectTreeNode('{= ?treeId }', data)\" arg:event=\"{= ?resourceSelectedEvent }\"/>
                                <ui:if ui:condition=\"{= bound(?refreshEvent) }\">
                                    <swa:Subscribe arg:code=\"swa.refreshTree('{= ?treeId }')\" arg:event=\"{= ?refreshEvent }\"/>
                                </ui:if>
                            </ui:group>
                        </ui:setContext>
                    </ui:setContext>
                </ui:if>
                <ui:else>
                    <div class=\"ui-layout-content swa-generic-tree-gadget-content\">
                        <div class=\"swa-generic-tree-gadget-content-text\">No property selected</div>
                    </div>
                </ui:else>
            </ui:group>
        </ui:call>
    </ui:setContext>
</ui:if>
"""^^ui:Literal ;
  rdfs:comment "A generic gadget displaying a tree for a property selected by the user. The available properties must be defined when the application is set up, via a SELECT template. If this template produces more than one property, then a drop down box will be shown at the top of the gadget. The tree can publish events whenever the user selects a resource." ;
  rdfs:label "Generic tree gadget" ;
  rdfs:subClassOf swa:TreeGadgets ;
.
swa:GenericTreeGadgetWindow
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:editable ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to enable edit operations" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resourceSelectedEvent ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the event to subscribe to so that the window can be reloaded if the resource changes. The event will also be re-published whenever the user follows a hyperlink on the form. The data payload of the event needs to be the URI of a resource." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The type to display the instances of." ;
    ] ;
  ui:prototype """
<swa:Window arg:closable=\"{= true }\" arg:title=\"{= ui:label(?resourceType) } Hierarchy\" ui:args=\"*\">
    <swa:GenericTreeGadget ui:args=\"*\"/>
</swa:Window>
"""^^ui:Literal ;
  rdfs:comment "An swa:Window wrapping an swa:GenericTreeGadget. This is instantiated when the user opens a new window for a given class." ;
  rdfs:label "Generic tree gadget window" ;
  rdfs:subClassOf swa:GadgetWindows ;
.
swa:GenericTreeMoveHandler
  a swa:TreeMoveHandlerClass ;
  ui:prototype """
<ui:transaction let:inverse=\"{= ui:contextValue(&quot;swaGenericTreeInverse&quot;) }\" let:property=\"{= ui:contextValue(&quot;swaGenericTreeProperty&quot;) }\" ui:logMessage=\"Move {= ui:label(?child) } under {= ui:label(?parent) }\">
    <ui:if ui:condition=\"{= ?inverse }\">
        <ui:update ui:updateQuery=\"{!
                DELETE WHERE {
                    ?child ?property ?oldParent .
                } }\"/>
        <ui:update ui:updateQuery=\"{!
                INSERT {
                    ?child ?property ?parent .
                }
                WHERE {
                } }\"/>
    </ui:if>
    <ui:else>
        <ui:update ui:updateQuery=\"{!
                DELETE WHERE {
                    ?oldParent ?property ?child .
                } }\"/>
        <ui:update ui:updateQuery=\"{!
                INSERT {
                    ?parent ?property ?child .
                }
                WHERE {
                } }\"/>
    </ui:else>
</ui:transaction>
"""^^ui:Literal ;
  rdfs:label "Generic tree move handler" ;
  rdfs:subClassOf swa:TreeMoveHandlers ;
.
swa:GenericTreePath
  a spin:SelectTemplate ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "path" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a ui:contextValue ;
                sp:arg1 "swaGenericTreeProperty" ;
              ] ;
            sp:variable [
                sp:varName "property" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:if ;
                sp:arg1 [
                    a sp:coalesce ;
                    sp:arg1 [
                        a ui:contextValue ;
                        sp:arg1 "swaGenericTreeInverse" ;
                      ] ;
                    sp:arg2 false ;
                  ] ;
                sp:arg2 [
                    a spif:shortestObjectsPath ;
                    sp:arg1 [
                        sp:varName "node" ;
                      ] ;
                    sp:arg2 [
                        sp:varName "property" ;
                      ] ;
                    sp:arg3 [
                        sp:varName "root" ;
                      ] ;
                  ] ;
                sp:arg3 [
                    a spif:shortestSubjectsPath ;
                    sp:arg1 [
                        sp:varName "node" ;
                      ] ;
                    sp:arg2 [
                        sp:varName "property" ;
                      ] ;
                    sp:arg3 [
                        sp:varName "root" ;
                      ] ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "path" ;
              ] ;
          ]
        ) ;
    ] ;
  rdfs:label "Generic tree path" ;
  rdfs:subClassOf swa:TreePathTemplates ;
.
swa:GenericTreePropertySelectionTemplates
  a spin:SelectTemplate ;
  spin:abstract true ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The selected resource type of the tree." ;
    ] ;
  rdfs:comment "The base class of SELECT templates that can be used in conjunction with swa:GenericTreeGadget to define the available properties. The SELECT query of those templates must return at least one property in the first column of the result set. If the second column (?inverse) is true, then the property is meant to be used in \"inverse\" direction (which would be (?child ?property ?parent) instead of the default (?parent ?property ?child). If the third column (?readOnly) is true then editing is not allowed in this combination." ;
  rdfs:label "Generic tree property selection templates" ;
  rdfs:subClassOf spin:SelectTemplates ;
.
swa:GenericTreeRoots
  a spin:SelectTemplate ;
  spin:body [
      a sp:Select ;
      sp:distinct true ;
      sp:orderBy (
          [
            sp:varName "label" ;
          ]
        ) ;
      sp:resultVariables (
          [
            sp:varName "node" ;
          ]
          [
            sp:varName "label" ;
          ]
          [
            sp:varName "leaf" ;
          ]
          [
            sp:varName "icon" ;
          ]
          [
            sp:varName "movable" ;
          ]
        ) ;
      sp:where (
          [
            a sp:SubQuery ;
            sp:query [
                a sp:Select ;
                sp:limit "1000"^^xsd:long ;
                sp:where (
                    (
                      [
                        a sp:Bind ;
                        sp:expression [
                            a sp:coalesce ;
                            sp:arg1 [
                                a ui:contextValue ;
                                sp:arg1 "swaGenericTreeParentsOnly" ;
                              ] ;
                            sp:arg2 false ;
                          ] ;
                        sp:variable [
                            sp:varName "parentsOnly" ;
                          ] ;
                      ]
                      [
                        a sp:Bind ;
                        sp:expression [
                            a ui:contextValue ;
                            sp:arg1 "swaGenericTreeProperty" ;
                          ] ;
                        sp:variable [
                            sp:varName "property" ;
                          ] ;
                      ]
                      [
                        a sp:Bind ;
                        sp:expression [
                            a ui:contextValue ;
                            sp:arg1 "swaGenericTreeResourceType" ;
                          ] ;
                        sp:variable [
                            sp:varName "resourceType" ;
                          ] ;
                      ]
                      [
                        a sp:Bind ;
                        sp:expression [
                            a sp:exists ;
                            sp:elements (
                                [
                                  sp:object owl:SymmetricProperty ;
                                  sp:predicate rdf:type ;
                                  sp:subject [
                                      sp:varName "property" ;
                                    ] ;
                                ]
                              ) ;
                          ] ;
                        sp:variable [
                            sp:varName "symmetric" ;
                          ] ;
                      ]
                    )
                    [
                      a sp:TriplePath ;
                      sp:object [
                          sp:varName "resourceType" ;
                        ] ;
                      sp:path [
                          a sp:ModPath ;
                          sp:modMax -2 ;
                          sp:modMin 0 ;
                          sp:subPath rdfs:subClassOf ;
                        ] ;
                      sp:subject [
                          sp:varName "type" ;
                        ] ;
                    ]
                    [
                      sp:object [
                          sp:varName "type" ;
                        ] ;
                      sp:predicate rdf:type ;
                      sp:subject [
                          sp:varName "node" ;
                        ] ;
                    ]
                    [
                      a sp:Filter ;
                      sp:expression [
                          a sp:or ;
                          sp:arg1 [
                              sp:varName "symmetric" ;
                            ] ;
                          sp:arg2 [
                              a sp:notExists ;
                              sp:elements (
                                  [
                                    sp:object [
                                        sp:varName "node" ;
                                      ] ;
                                    sp:predicate swa:genericTreeChild ;
                                    sp:subject [
                                        sp:varName "parent" ;
                                      ] ;
                                  ]
                                  [
                                    a sp:Filter ;
                                    sp:expression [
                                        a spl:instanceOf ;
                                        sp:arg1 [
                                            sp:varName "parent" ;
                                          ] ;
                                        sp:arg2 [
                                            sp:varName "resourceType" ;
                                          ] ;
                                      ] ;
                                  ]
                                ) ;
                            ] ;
                        ] ;
                    ]
                    [
                      a sp:Filter ;
                      sp:expression [
                          a sp:or ;
                          sp:arg1 [
                              a sp:not ;
                              sp:arg1 [
                                  sp:varName "parentsOnly" ;
                                ] ;
                            ] ;
                          sp:arg2 [
                              a sp:exists ;
                              sp:elements (
                                  [
                                    sp:object [
                                        sp:varName "anyChild" ;
                                      ] ;
                                    sp:predicate swa:genericTreeChild ;
                                    sp:subject [
                                        sp:varName "node" ;
                                      ] ;
                                  ]
                                ) ;
                            ] ;
                        ] ;
                    ]
                  ) ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a ui:label ;
                sp:arg1 [
                    sp:varName "node" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "label" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:notExists ;
                sp:elements (
                    [
                      sp:object [
                          sp:varName "child" ;
                        ] ;
                      sp:predicate swa:genericTreeChild ;
                      sp:subject [
                          sp:varName "node" ;
                        ] ;
                    ]
                  ) ;
              ] ;
            sp:variable [
                sp:varName "leaf" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a swa:resourceIcon ;
                arg:resource [
                    sp:varName "node" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "icon" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:not ;
                sp:arg1 [
                    a spl:instanceOf ;
                    sp:arg1 [
                        sp:varName "property" ;
                      ] ;
                    sp:arg2 spin:MagicProperty ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "movable" ;
              ] ;
          ]
        ) ;
    ] ;
  rdfs:comment "Delivers the roots of a generic tree. This includes all instances of the resource type (stored in the context variable \"swaGenericTreeResourceType\") that are not children of another instance. Like swa:GenericTreeChildren, the context variable \"swaGenericTreeProperty\" must hold the property, and \"swaGenericTreeInverse\" is used to indicate whether the property shall be used in the inverse direction. If the context variable \"swaGenericTreeParentsOnly\" is true then the tree will hide nodes that have no children." ;
  rdfs:label "Generic tree roots" ;
  rdfs:subClassOf swa:TreeRootsTemplates ;
.
swa:GetColumnsFromResultSet
  a ui:NodeClass ;
  ui:prototype """
<swon:Array/>
"""^^ui:Literal ;
  rdfs:subClassOf swa:ResultSetGrid ;
.
swa:GetDataFromResultSet
  a ui:NodeClass ;
  rdfs:subClassOf swa:ResultSetGrid ;
.
swa:GetLangsJSON
  a swa:CreateResourceDialogPlugin ;
  a ui:NodeClass ;
  swa:defaultLanguages "en ar de es fr it pt ru zh" ;
  ui:private true ;
  ui:prototype """
<ui:group>
    <swon:Object>
        <swon:Value arg:name=\"label\" arg:value=\"\"/>
        <swon:Value arg:name=\"name\" arg:value=\"\"/>
    </swon:Object>
    <ui:forEach ui:resultSet='{#
            SELECT DISTINCT ?lang
            WHERE {
                {
                    GRAPH ui:graph {
                        BIND (COALESCE(spl:object(swa:LangSelector, swa:customLanguages), spl:object(swa:LangSelector, swa:defaultLanguages)) AS ?langs) .
                    } .
                    ?lang spif:split ( ?langs \" \" ) .
                }
                UNION
                {
                    BIND (xsd:string(?initialValue) AS ?lang) .
                } .
                FILTER (?lang != \"\") .
            }
            ORDER BY (?lang) }'>
        <swon:Object>
            <swon:Value arg:name=\"label\" arg:value=\"{= ?lang }\"/>
            <swon:Value arg:name=\"name\" arg:value=\"{= ?lang }\"/>
        </swon:Object>
    </ui:forEach>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "Gets and returns the available languages that exist in the system" ;
  rdfs:label "Available langs JSON" ;
  rdfs:subClassOf ui:JSONServices ;
.
swa:GetLocalResources
  a ui:Service ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:urls ;
      spl:valueType xsd:string ;
      rdfs:comment "A string-encoded JSON array of URLs to check." ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:json ui:str=\"{= ?urls }\" ui:varName=\"array\">
    <swon:RSArray arg:resultSet=\"{#
            SELECT DISTINCT ?uri
            WHERE {
                {
                    ?array ui:jsonArrayMembers ?member .
                    BIND (ui:jsonString(?member) AS ?url) .
                    FILTER spif:isValidURI(?url) .
                } .
                BIND (IRI(?url) AS ?uri) .
                FILTER EXISTS {
                    ?uri ?anyP ?anyO .
                } .
            } }\"/>
</ui:json>
"""^^ui:Literal ;
  rdfs:comment "Used as a callback by the rich text editor to determine which resources shall be redirected to local links, and which shall stay external links." ;
  rdfs:label "Get local resources" ;
  rdfs:subClassOf ui:JSONServices ;
.
swa:GetObjectViewer
  a ui:Service ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:viewWidget ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "A predefined view widget." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:object ;
      rdfs:comment "The value to render." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:subject ;
      spl:valueType rdfs:Resource ;
    ] ;
  ui:prototype """
<ui:group let:class=\"{= COALESCE(?viewWidget, swa:bestObjectViewerClass(?object, ?predicate, ?subject)) }\">
    <ui:if ui:condition=\"{= bound(?class) }\">
        <ui:dynamicView arg:object=\"{= ?object }\" arg:predicate=\"{= ?predicate }\" arg:subject=\"{= ?subject }\" ui:class=\"{= ?class }\"/>
    </ui:if>
</ui:group>
"""^^ui:Literal ;
  ui:responseType ui:HTML ;
  rdfs:label "Get object viewer" ;
  rdfs:subClassOf ui:Services ;
.
swa:GetQueryGraphFromSearchGraph
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "queryGraph" ;
          ]
        ) ;
      sp:where (
          [
            a sp:NamedGraph ;
            sp:elements (
                [
                  sp:object [
                      sp:varName "queryGraph" ;
                    ] ;
                  sp:predicate search:queryGraph ;
                  sp:subject [
                      sp:varName "subject" ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode [
                sp:varName "searchGraph" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:searchGraph ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The graph containing the search:Search." ;
    ] ;
  spin:private true ;
  rdfs:label "Extracts the query graph from the search graph" ;
  rdfs:subClassOf spin:Functions ;
.
swa:GetRelationshipTreeProperties
  a spin:SelectTemplate ;
  spin:body [
      a sp:Select ;
      sp:distinct true ;
      sp:orderBy (
          [
            a ui:label ;
            sp:arg1 [
                sp:varName "property" ;
              ] ;
          ]
        ) ;
      sp:resultVariables (
          [
            sp:varName "property" ;
          ]
          [
            sp:varName "inverse" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Union ;
            sp:elements (
                (
                  [
                    sp:object [
                        sp:varName "class" ;
                      ] ;
                    sp:predicate rdf:type ;
                    sp:subject [
                        sp:varName "root" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "property" ;
                      ] ;
                    sp:predicate swa:relevantClassOfProperty ;
                    sp:subject [
                        sp:varName "class" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "property" ;
                      ] ;
                    sp:predicate sh:path ;
                    sp:subject [
                        sp:varName "propertyShape" ;
                      ] ;
                  ]
                  [
                    a sp:Filter ;
                    sp:expression [
                        a sp:exists ;
                        sp:elements (
                            [
                              sp:object [
                                  sp:varName "rangeClass" ;
                                ] ;
                              sp:predicate sh:class ;
                              sp:subject [
                                  sp:varName "propertyShape" ;
                                ] ;
                            ]
                          ) ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression false ;
                    sp:variable [
                        sp:varName "inverse" ;
                      ] ;
                  ]
                )
                (
                  [
                    sp:object [
                        sp:varName "class" ;
                      ] ;
                    sp:predicate rdf:type ;
                    sp:subject [
                        sp:varName "root" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "property" ;
                      ] ;
                    sp:predicate swa:directRelevantClassOfInverseProperty ;
                    sp:subject [
                        sp:varName "class" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression true ;
                    sp:variable [
                        sp:varName "inverse" ;
                      ] ;
                  ]
                )
              ) ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:root ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class to get the arguments of." ;
    ] ;
  rdfs:comment "Gets a list of the properties relevant to a relationship tree" ;
  rdfs:label "Get relationship tree  properties" ;
  rdfs:seeAlso swa:hasRelationshipTreeProperties ;
  rdfs:subClassOf spin:SelectTemplates ;
.
swa:GetResourceLabel
  a ui:Service ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to get the label of." ;
    ] ;
  ui:prototype """
<swon:Object>
    <swon:Value arg:name=\"label\" arg:value=\"{= ui:label(?resource) }\"/>
</swon:Object>
"""^^ui:Literal ;
  rdfs:comment "A simple global service that can be used to retrieve the human-readable label of a given resource. Result is a JSON object such as { label : 'Hello' }." ;
  rdfs:label "Get resource label" ;
  rdfs:subClassOf ui:JSONServices ;
.
swa:GetTypesAndSuperTypes
  a ui:Service ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:instance ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The instance to get the types of." ;
    ] ;
  ui:private true ;
  ui:prototype """
<swon:RSArray arg:resultSet=\"{#
        SELECT DISTINCT ?uri
        WHERE {
            {
                ?instance a ?type .
                ?type (rdfs:subClassOf)* ?class .
                FILTER isIRI(?class) .
                FILTER spl:instanceOf(?class, sh:NodeShape) .
            } .
            BIND (spif:shortestObjectsPath(?class, rdfs:subClassOf) AS ?path) .
            BIND (swa:countSpaces(?path) AS ?depth) .
            BIND (str(?class) AS ?uri) .
            BIND ((?type = ?class) AS ?direct) .
        }
        ORDER BY DESC (?direct) DESC (?depth) (?uri) }\"/>
"""^^ui:Literal ;
  rdfs:comment "Gets a JSON array of class URIs starting with the direct types of a given instance and then walking up the tree. Will only return classes that are also node shapes." ;
  rdfs:label "Get types and super types" ;
  rdfs:subClassOf ui:JSONServices ;
.
swa:GetTypesJSON
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:abstractResults ;
      spl:valueType xsd:boolean ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:group>
    <ui:forEach ui:resultSet=\"{#
            SELECT DISTINCT ?resourceLabel ?class ?primary ?abstract
            WHERE {
                ?class (rdfs:subClassOf)* ?resourceType .
                BIND (ui:label(?class) AS ?resourceLabel) .
                BIND (swa:hasPrimaryKey(?class) AS ?primary) .
                BIND (swa:isAbstractClass(?class) AS ?abstract) .
                FILTER (!?abstract) .
            }
            ORDER BY (?resourceLabel) }\">
        <swon:Object>
            <swon:Value arg:name=\"label\" arg:value=\"{= ui:label(?class) }\"/>
            <swon:Value arg:name=\"value\" arg:value=\"{= ?class }\"/>
            <swon:Value arg:name=\"name\" arg:value=\"{= ?class }\"/>
        </swon:Object>
    </ui:forEach>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "Gets and returns the available classes that exist for this specific resource" ;
  rdfs:label "Available types JSON" ;
  rdfs:subClassOf ui:JSONServices ;
.
swa:GraphElements
  a ui:NodeClass ;
  ui:abstract true ;
  rdfs:label "Graph elements" ;
  rdfs:subClassOf swa:Elements ;
.
swa:GraphOperations
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:targetGraph ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The graph that will be edited." ;
    ] ;
  ui:abstract true ;
  rdfs:comment "Abstract base class for operations on whole graphs." ;
  rdfs:label "Graph operations" ;
  rdfs:subClassOf ui:Operations ;
.
swa:GraphReportService
  a ui:Service ;
  ui:prototype """
<swa:FocusNodeReportService/>
"""^^ui:Literal ;
  rdfs:comment "Gets a JSON report for a graph, including the results delivered by sml:GenerateReport and sml:ValidateGraph." ;
  rdfs:label "Graph report service" ;
  rdfs:subClassOf ui:JSONServices ;
.
swa:GridDataView
  a ui:ViewElement ;
  ui:prototype """
<ui:call arg:this=\"{= ?this }\" ui:template=\"{= ?dataProvider }\">
    <swa:ResultSetGrid arg:resultSet=\"{= ?rs }\"/>
</ui:call>
"""^^ui:Literal ;
  rdfs:comment "A DataView displaying a grid (table)." ;
  rdfs:label "Grid data view" ;
  rdfs:subClassOf ui:DataViews ;
.
swa:GridElements
  a ui:NodeClass ;
  ui:abstract true ;
  ui:private true ;
  rdfs:comment "Abstract superclass to group together grid related SWA elements." ;
  rdfs:label "Grid elements" ;
  rdfs:subClassOf swa:Elements ;
.
swa:GridSearchColumns
  a spin:SelectTemplate ;
  spin:body [
      a sp:Select ;
      sp:orderBy (
          [
            sp:varName "columnIndex" ;
          ]
        ) ;
      sp:resultVariables (
          [
            sp:varName "colName" ;
          ]
          [
            sp:varName "numeric" ;
          ]
          [
            sp:varName "varName" ;
          ]
          [
            sp:varName "inverse" ;
          ]
          [
            sp:varName "isCount" ;
          ]
          [
            sp:varName "propPath" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Union ;
            sp:elements (
                (
                  [
                    a sp:Filter ;
                    sp:expression [
                        a sp:or ;
                        sp:arg1 [
                            a sp:not ;
                            sp:arg1 [
                                a sp:bound ;
                                sp:arg1 [
                                    sp:varName "suppressLabelColumn" ;
                                  ] ;
                              ] ;
                          ] ;
                        sp:arg2 [
                            a sp:not ;
                            sp:arg1 [
                                sp:varName "suppressLabelColumn" ;
                              ] ;
                          ] ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression [
                        a spl:objectInGraph ;
                        sp:arg1 [
                            sp:varName "search" ;
                          ] ;
                        sp:arg2 search:queryGraph ;
                        sp:arg3 [
                            sp:varName "searchGraph" ;
                          ] ;
                      ] ;
                    sp:variable [
                        sp:varName "queryGraph" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression [
                        a spl:objectInGraph ;
                        sp:arg1 [
                            sp:varName "search" ;
                          ] ;
                        sp:arg2 search:rootType ;
                        sp:arg3 [
                            sp:varName "searchGraph" ;
                          ] ;
                      ] ;
                    sp:variable [
                        sp:varName "rootType" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression [
                        a spl:objectInGraph ;
                        sp:arg1 [
                            sp:varName "rootType" ;
                          ] ;
                        sp:arg2 rdfs:label ;
                        sp:arg3 [
                            sp:varName "queryGraph" ;
                          ] ;
                      ] ;
                    sp:variable [
                        sp:varName "colName" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression "label" ;
                    sp:variable [
                        sp:varName "varName" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression -1 ;
                    sp:variable [
                        sp:varName "columnIndex" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression false ;
                    sp:variable [
                        sp:varName "isCount" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression "" ;
                    sp:variable [
                        sp:varName "propPath" ;
                      ] ;
                  ]
                )
                (
                  [
                    a sp:NamedGraph ;
                    sp:elements (
                        [
                          sp:object [
                              sp:varName "rootType" ;
                            ] ;
                          sp:predicate search:rootType ;
                          sp:subject [
                              sp:varName "search" ;
                            ] ;
                        ]
                        [
                          sp:object [
                              sp:varName "column" ;
                            ] ;
                          sp:predicate spin:column ;
                          sp:subject [
                              sp:varName "search" ;
                            ] ;
                        ]
                        [
                          sp:object [
                              sp:varName "columnIndex" ;
                            ] ;
                          sp:predicate spin:columnIndex ;
                          sp:subject [
                              sp:varName "column" ;
                            ] ;
                        ]
                        [
                          sp:object [
                              sp:varName "keyProperty" ;
                            ] ;
                          sp:predicate search:columnProperty ;
                          sp:subject [
                              sp:varName "column" ;
                            ] ;
                        ]
                        [
                          a sp:Bind ;
                          sp:expression [
                              a sp:exists ;
                              sp:elements (
                                  [
                                    sp:object search:InversePropertyColumn ;
                                    sp:predicate rdf:type ;
                                    sp:subject [
                                        sp:varName "column" ;
                                      ] ;
                                  ]
                                ) ;
                            ] ;
                          sp:variable [
                              sp:varName "inverse" ;
                            ] ;
                        ]
                        [
                          a sp:Bind ;
                          sp:expression [
                              a spl:hasValue ;
                              sp:arg1 [
                                  sp:varName "column" ;
                                ] ;
                              sp:arg2 search:columnType ;
                              sp:arg3 search:CountColumnType ;
                            ] ;
                          sp:variable [
                              sp:varName "isCount" ;
                            ] ;
                        ]
                      ) ;
                    sp:graphNameNode [
                        sp:varName "searchGraph" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression [
                        a spl:objectInGraph ;
                        sp:arg1 [
                            sp:varName "keyProperty" ;
                          ] ;
                        sp:arg2 rdfs:label ;
                        sp:arg3 [
                            sp:varName "queryGraph" ;
                          ] ;
                      ] ;
                    sp:variable [
                        sp:varName "label1" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression [
                        a ui:label ;
                        sp:arg1 [
                            sp:varName "label1" ;
                          ] ;
                      ] ;
                    sp:variable [
                        sp:varName "colName" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression [
                        a swa:isNumericDatatype ;
                        arg:node [
                            a swa:localRangeAtClass ;
                            arg:class [
                                sp:varName "rootType" ;
                              ] ;
                            arg:property [
                                sp:varName "keyProperty" ;
                              ] ;
                          ] ;
                      ] ;
                    sp:variable [
                        sp:varName "numeric" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression [
                        a xsd:string ;
                        sp:arg1 [
                            sp:varName "keyProperty" ;
                          ] ;
                      ] ;
                    sp:variable [
                        sp:varName "varName" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression [
                        a search:propertyPath ;
                        arg:column [
                            sp:varName "column" ;
                          ] ;
                        arg:searchGraph [
                            sp:varName "searchGraph" ;
                          ] ;
                      ] ;
                    sp:variable [
                        sp:varName "propPath" ;
                      ] ;
                  ]
                )
              ) ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:suppressLabelColumn ;
      spl:valueType xsd:boolean ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:queryGraph ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:searchGraph ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The graph containing the search:Search." ;
    ] ;
  spin:private true ;
  rdfs:label "Grid search columns" ;
  rdfs:subClassOf spin:SelectTemplates ;
.
swa:GridSearchResultsBody
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:gridId ;
      spl:valueType xsd:string ;
      rdfs:comment "The id of the grid to generate." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:multiSelect ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to add a column with a checkbox for multi-selection." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:onDoubleClick ;
      spl:valueType xsd:string ;
      rdfs:comment "A JavaScript snippet to execute when the user double-clicks a row. In that snippet, the variable resource holds the currently selected resource." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:pagerId ;
      spl:valueType xsd:string ;
      rdfs:comment "The id of the pager to generate. Can be specified if the pager is then modified from the outside." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:rowCount ;
      spl:valueType xsd:integer ;
      rdfs:comment "The default number of rows to display." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:rowNumCookie ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of a cookie remembering the number of rows." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:searchGraph ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The graph containing the search:Search to execute." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:suppressLabelColumn ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to suppress the first column." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:topPager ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to have a secondary pager on top. Recommended to be used with arg:gridId set so that buttons can be added." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resourceSelectedEvent ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of an event to publish when the user clicks on a result. The data payload of this event is the URI of the resource." ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:if ui:condition=\"{= bound(?searchGraph) }\">
    <ui:group let:pagerId=\"{= COALESCE(?pagerId, ui:uniqueId()) }\" let:tableId=\"{= COALESCE(?gridId, ui:uniqueId()) }\">
        <table id=\"{= ?tableId }\"/>
        <script>$(\"#{= ?tableId }\").jqGrid({<ui:createLink arg:searchGraph=\"{= ?searchGraph }\" arg:suppressLabelColumn=\"{= ?suppressLabelColumn }\" ui:viewClass=\"{= swa:GridSearchResultsCallback }\">\"url\" : swa.redirectLink(\"{= ui:escapeJSON(?link) }\"),</ui:createLink>
            <swon:Value arg:name=\"datatype\" arg:value=\"json\"/>
            <ui:call arg:searchGraph=\"{= ?searchGraph }\" arg:suppressLabelColumn=\"{= ?suppressLabelColumn }\" ui:template=\"{= swa:GridSearchColumns }\">
                <swon:Values arg:name=\"colNames\">
                    <ui:forEach ui:resultSet=\"{= ?rs }\" ui:separator=\",\">\"{= ui:escapeJSON(?propPath) }{= IF(?isCount, \"#\", ?none) }{= IF(?inverse, \"[inv] \", ?none) }{= ui:escapeJSON(?colName) }\"</ui:forEach>
                </swon:Values>
                <swon:Values arg:name=\"colModel\">
                    <ui:forEach ui:resultSet=\"{= ?rs }\" ui:separator=\",\">
                        <swon:Object>
                            <ui:if ui:condition=\"{= ?numeric }\">
                                <swon:Value arg:name=\"align\" arg:value=\"right\"/>
                            </ui:if>
                            <swon:Value arg:name=\"name\" arg:value=\"{= IF(?inverse, &quot;-&quot;, ?none) }{= ?varName }\"/>
                        </swon:Object>
                    </ui:forEach>
                </swon:Values>
            </ui:call>
            <ui:if ui:condition=\"{= bound(?resourceSelectedEvent) }\">,onSelectRow: function(resource) {
		{= swa:publishEvent(?resourceSelectedEvent, \"resource\") }
	},</ui:if>
            <ui:if ui:condition=\"{= bound(?width) }\">
                <swon:Value arg:name=\"width\" arg:value=\"{= ?width }\"/>
            </ui:if>
            <ui:else>
                <swon:Value arg:name=\"autowidth\" arg:value=\"{= true }\"/>
            </ui:else>
            <swon:Value arg:name=\"altclass\" arg:value=\"swa-grid-alt\"/>
            <swon:Value arg:name=\"altRows\" arg:value=\"{= true }\"/>
            <swon:Value arg:name=\"height\" arg:value=\"auto\"/>
            <swon:Value arg:name=\"mtype\" arg:value=\"POST\"/>
,rowNum: <ui:if ui:condition=\"{= bound(?rowNumCookie) }\">swa.getCookie(\"{= ?rowNumCookie }\", rowNum: {= COALESCE(?rowCount, 10) })</ui:if>
            <ui:else>{= COALESCE(?rowCount, 10) }</ui:else>,
rowList:[5,10,15,20,25,30,35,40],
gridComplete: function() {
if(swa.searchPerformed){
{= swa:publishEvent(swa:searchCompletedEvent(), \"true\") }
swa.searchPerformed=false;
}
},<ui:if ui:condition=\"{= bound(?rowNumCookie) }\">loadComplete: function() {
	var currentRowNum = $(\"#{= ?tableId }\").getGridParam('rowNum');
	$.cookie('{= ?rowNumCookie }', currentRowNum);
},</ui:if>
            <ui:if ui:condition=\"{= bound(?onDoubleClick) }\">ondblClickRow: function(rowId) {
		var resource = rowId;
		{= ?onDoubleClick }
	},</ui:if>
            <ui:if ui:condition=\"{= ?multiSelect }\">
                <swon:Value arg:name=\"multiselect\" arg:value=\"{= true }\"/>
                <swon:Value arg:name=\"multiboxonly\" arg:value=\"{= true }\"/>
            </ui:if>
            <swon:Value arg:name=\"pager\" arg:value=\"#{= ?pagerId }\"/>
            <ui:if ui:condition=\"{= ?topPager }\">
                <swon:Value arg:name=\"toppager\" arg:value=\"{= true }\"/>
            </ui:if>
            <swon:Value arg:name=\"sortorder\" arg:value=\"asc\"/>
            <swon:Value arg:name=\"viewrecords\" arg:value=\"{= true }\"/>}).jqGrid('navGrid', '#{= ?pagerId }',{<swon:Value arg:name=\"add\" arg:value=\"{= false }\"/>
            <swon:Value arg:name=\"del\" arg:value=\"{= false }\"/>
            <swon:Value arg:name=\"edit\" arg:value=\"{= false }\"/>
            <swon:Value arg:name=\"search\" arg:value=\"{= false }\"/>
            <ui:if ui:condition=\"{= ?topPager }\">
                <swon:Value arg:name=\"cloneToTop\" arg:value=\"{= true }\"/>
            </ui:if>
});</script>
        <script>(function ($) {
			'use strict';
			$(document).ready(function () {

				$('.swa-window div.ui-jqgrid-toppager').appendTo('.swa-window.ui-layout-center');

			});
		}(jQuery));</script>
    </ui:group>
</ui:if>
"""^^ui:Literal ;
  rdfs:comment "The body of the swa:GridSearchResultsGadget, which can also be used in other places that operate on a given searchGraph." ;
  rdfs:label "Grid search results body" ;
  rdfs:subClassOf swa:GridElements ;
.
swa:GridSearchResultsCallback
  a ui:Service ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:page ;
      spl:valueType xsd:integer ;
      rdfs:comment "The current page - starting with 1." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:sidx ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the sort column (for property)." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:sord ;
      spl:valueType xsd:string ;
      rdfs:comment "\"asc\" or \"desc\"" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:suppressLabelColumn ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to not have a label column." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:rows ;
      spl:valueType xsd:integer ;
      rdfs:comment "The number of rows to deliver." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:searchGraph ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The graph containing the search:Search instance." ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:setContext let:startIndex=\"{= COALESCE(((?page - 1) * ?rows), 0) }\" ui:queryGraph=\"{= ?searchGraph }\">
    <ui:group let:desc=\"{= ?sord = &quot;desc&quot; }\" let:search=\"{= search:theSearch() }\" let:sortProperty=\"{= IF((bound(?sidx) &amp;&amp; (?sidx != &quot;label&quot;)), IF(fn:starts-with(?sidx, &quot;-&quot;), IRI(fn:substring(?sidx, 2)), IRI(?sidx)), ?none) }\" let:sortPropertyInverse=\"{= bound(?sidx) &amp;&amp; fn:starts-with(?sidx, &quot;-&quot;) }\">
        <ui:group let:queryGraph=\"{= spl:object(?search, search:queryGraph) }\">
            <search:results arg:count=\"{= ?rows }\" arg:descSorting=\"{= ?desc }\" arg:search=\"{= ?search }\" arg:searchGraph=\"{= ?searchGraph }\" arg:sortProperty=\"{= ?sortProperty }\" arg:sortPropertyInverse=\"{= ?sortPropertyInverse }\" arg:startIndex=\"{= ?startIndex }\">
                <swon:Object>
                    <ui:setContext let:floor=\"{= floor((?totalCount / ?rows)) }\" ui:queryGraph=\"{= ?queryGraph }\">
                        <swon:Value arg:name=\"page\" arg:value=\"{= ?page }\"/>
                        <swon:Value arg:name=\"records\" arg:value=\"{= ?totalCount }\"/>
                        <swon:Value arg:name=\"total\" arg:value=\"{= IF(((?floor * ?rows) &lt; ?totalCount), (?floor + 1), ?floor) }\"/>
                        <swon:Values arg:name=\"rows\">
                            <ui:if ui:condition=\"{= ?totalCount &gt; 0 }\">
                                <ui:forEach ui:resultSet=\"{= ?results }\" ui:separator=\",\">
                                    <swon:Object>
                                        <swon:Value arg:name=\"id\" arg:value=\"{= IF(isIRI(?result), ?result, swa:bnodeId(?result)) }\"/>
                                        <swon:Value arg:name=\"cell\">
                                            <ui:if ui:condition=\"{= EXISTS {
                                                GRAPH ?searchGraph {
                                                    ?search spin:column ?anyColumn .
                                                } .
                                            } }\">
                                                <swon:RSArray arg:resultSet=\"{#
                                                        SELECT ?label
                                                        WHERE {
                                                            {
                                                                FILTER ((!bound(?suppressLabelColumn)) || (!?suppressLabelColumn)) .
                                                                BIND (ui:label(?result) AS ?label) .
                                                                BIND (-1 AS ?columnIndex) .
                                                            }
                                                            UNION
                                                            {
                                                                GRAPH ?searchGraph {
                                                                    ?search spin:column ?column .
                                                                    ?column spin:columnIndex ?columnIndex .
                                                                    ?column search:columnProperty ?keyProperty .
                                                                    BIND (spl:object(?column, search:columnSubjectVarName) AS ?columnVar) .
                                                                    BIND (spl:object(?column, rdf:type) AS ?columnType) .
                                                                    BIND (spl:hasValue(?column, search:columnType, search:CountColumnType) AS ?isCount) .
                                                                    OPTIONAL {
                                                                        ?search search:facet ?facet .
                                                                        ?facet search:property ?keyProperty .
                                                                        ?facet search:facetValue/search:lang ?lang .
                                                                    } .
                                                                } .
                                                                BIND (IF((?columnType = search:InversePropertyColumn), IF(?isCount, spl:subjectCount(?keyProperty, ?result), swa:subjectsList(?result, ?keyProperty)), IF(?isCount, spl:objectCount(?result, ?keyProperty), ui:label(search:nestedObjectsList(?result, ?keyProperty, ?columnVar, ?searchGraph, ?lang)))) AS ?label) .
                                                            } .
                                                        }
                                                        ORDER BY (?columnIndex) }\"/>
                                            </ui:if>
                                            <ui:else>
                                                <swon:RSArray arg:resultSet=\"{#
                                                        SELECT ?label
                                                        WHERE {
                                                            BIND (ui:label(?result) AS ?label) .
                                                        } }\"/>
                                            </ui:else>
                                        </swon:Value>
                                    </swon:Object>
                                </ui:forEach>
                            </ui:if>
                        </swon:Values>
                    </ui:setContext>
                </swon:Object>
            </search:results>
        </ui:group>
    </ui:group>
</ui:setContext>
"""^^ui:Literal ;
  rdfs:comment """Delivers the content of the current page of a swa:GridSearchResultsGadget in the format expected by jqGrid:

{
	page : (optional page index),
	records : (number of result rows overall),
	total : (number of pages overall),
	rows : [
		{
			id : (URI of the resource, starting with @ for bnodes),
			cell : [ \"valueCol1\", \"valueCol2\", ... ]
		},
		...
	]
}""" ;
  rdfs:label "Grid search results callback" ;
  rdfs:subClassOf ui:JSONServices ;
.
swa:GridSearchResultsGadget
  a swa:Gadget ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:rowCount ;
      spl:valueType xsd:integer ;
      rdfs:comment "The default number of rows to display." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:rowNumCookie ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of a cookie remembering the number of rows." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:suppressLabelColumn ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to suppress the first column." ;
    ] ;
  ui:prototype """
<ui:group let:id=\"{= ui:uniqueId() }\" let:pagerId=\"{= ui:uniqueId() }\">
    <swa:Subscribe arg:code=\"swa.searchPerformed=true;swa.loadWithResource('{= ?id }-loadable', 'searchGraph', data)\" arg:event=\"{= swa:searchEvent(?searchEvent) }\"/>
    <ui:loadable class=\"ui-layout-content\" ui:loadId=\"{= ?id }-loadable\" ui:loadOnDemand=\"{= true }\">
        <swa:GridSearchResultsBody ui:args=\"*\"/>
    </ui:loadable>
    <div id=\"{= ?pagerId }\"/>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "A search results gadget that renders the matching resources and possibly their key properties in a grid (currently using jqGrid)." ;
  rdfs:label "Grid search results gadget" ;
  rdfs:subClassOf swa:SearchResultsGadgets ;
.
swa:HTMLLiteralViewer
  a swa:ObjectViewerClass ;
  ui:prototype """
<div class=\"swa-shifted-label\">
    <ui:parse ui:str=\"{= ?object }\"/>
    <swa:LangDisplay arg:lang=\"{= lang(?object) }\"/>
</div>
"""^^ui:Literal ;
  rdfs:comment "A viewer that can be selected for literals that contain valid HTML mark-up. The widget will use ui:parse to turn the HTML literal into proper HTML nodes, so that HTML tags like <b> will be used for formatting." ;
  rdfs:label "HTML literal viewer" ;
  rdfs:subClassOf swa:ObjectViewer ;
.
swa:Header
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:label ;
      spl:valueType xsd:string ;
      rdfs:comment "The label to insert." ;
    ] ;
  ui:prototype """
<div class=\"swa-header\">
    <div class=\"swa-header-label\">{= ?label }</div>
</div>
"""^^ui:Literal ;
  rdfs:comment "Displays the title area of a panel on the screen - typically a black bar with a label on it." ;
  rdfs:label "Header" ;
  rdfs:subClassOf swa:Elements ;
.
swa:HeaderLabelFunctions
  a spin:Function ;
  spin:abstract true ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to get the label of." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Abstract superclass for functions that take a resource and deliver a label that is displayed in the header of ViewForms and potentially other places. If you want to activate a different function than the default one, set the context variable 'headerLabelFunction' around the swa:ViewForm element." ;
  rdfs:label "Header label functions" ;
  rdfs:subClassOf swa:Functions ;
.
swa:HelpPage
  a ui:NodeClass ;
  ui:abstract true ;
  rdfs:label "Help page" ;
  rdfs:subClassOf swa:Elements ;
.
swa:ImageResourceViewer
  a swa:ObjectViewerClass ;
  swa:objectWidgetWeight [
      a swa:WeightedExpression ;
      swa:expression [
          a sp:eq ;
          sp:arg1 [
              sp:varName "kind" ;
            ] ;
          sp:arg2 "image" ;
        ] ;
      swa:weight 2 ;
    ] ;
  ui:prototype """
<img class=\"swa-image swa-image-viewer\" src=\"{= ?object }\"/>
"""^^ui:Literal ;
  rdfs:comment "The default viewer for URI resources that appear to be images, judged by their file extension." ;
  rdfs:label "Image resource viewer" ;
  rdfs:subClassOf swa:ObjectViewer ;
.
swa:InListDropDownEditor
  a swa:ObjectEditorClass ;
  ui:prototype """
<ui:group let:list=\"{= swa:propertyShapePropertyAtNode(?predicate, sh:in, ?subject) }\" let:name=\"new-{= ?uid }\">
    <ui:if ui:condition=\"{= bound(?list) }\">
        <select class=\"form-control {= swa:testClass(?predicate) }\" name=\"{= ?name }\">
            <option/>
            <ui:forEach ui:resultSet=\"{#
                    SELECT ?item
                    WHERE {
                        ?list (rdf:rest)*/rdf:first ?item .
                    } }\">
                <option selected=\"{= IF((?object = ?item), &quot;selected&quot;, ?none) }\" value=\"{= ui:encodeNode(?item, true, true) }\">{= ui:label(?item) }</option>
            </ui:forEach>
        </select>
    </ui:if>
    <ui:else>
        <div class=\"text-danger\">Error: No sh:in found</div>
    </ui:else>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "Can be used as a drop down selection box for values from sh:in enumerations." ;
  rdfs:label "SHACL sh:in list drop down editor" ;
  rdfs:subClassOf swa:ObjectEditor ;
.
swa:Index
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:cache ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to activate caching for the letter dialogs." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:labelProperty ;
      spl:valueType rdf:Property ;
      rdfs:comment "The label property, e.g. rdfs:label or skos:prefLabel." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:onSelect ;
      spl:valueType xsd:string ;
      rdfs:comment "The JavaScript code that will be called if the user has selected a resource. The variable resource will point to the URI of the selected resource." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The type of instances to index." ;
    ] ;
  ui:prototype """
<div class=\"swa-index\">
    <ui:forEach ui:resultSet=\"{#
            SELECT *
            WHERE {
                rdf:nil swa:letters ?letter .
            } }\" ui:separator=\" \">
        <a href=\"javascript:void(0)\" onclick=\"swa.openIndexLetterDialog('swaIndexLetterDialog', '{= ?letter }')\">{= ?letter }</a>
    </ui:forEach>
    <swa:IndexLetterDialog arg:cache=\"{= ?cache }\" arg:labelProperty=\"{= ?labelProperty }\" arg:onSelect=\"{= ?onSelect }\" arg:resourceType=\"{= ?resourceType }\"/>
</div>
"""^^ui:Literal ;
  rdfs:comment "Displays a list of hyperlinks A B C ... Z * where each letter opens a dialog with all resources starting with that letter." ;
  rdfs:label "Index" ;
  rdfs:subClassOf swa:IndexElements ;
.
swa:IndexElements
  a ui:NodeClass ;
  ui:abstract true ;
  ui:private true ;
  rdfs:comment "Abstract superclass for elements related to A-Z search index." ;
  rdfs:label "Index elements" ;
  rdfs:subClassOf swa:Elements ;
.
swa:IndexLetterDialog
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:cache ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to activate caching for the dialogs." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:labelProperty ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property holding the label information, e.g. skos:prefLabel." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:onSelect ;
      spl:valueType xsd:string ;
      rdfs:comment "The JavaScript that will be called." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The type of instances to display." ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:loadable class=\"swa-display-none\" ui:cache=\"{= ?cache }\" ui:loadId=\"swaIndexLetterDialog\">
    <ui:if ui:condition=\"{= bound(?letter) }\">
        <div id=\"div-swaIndexLetterDialog\" title=\"{= ?letter }\">
            <swa:SearchResultsGrid arg:onSelect=\"{= ?onSelect };swa.closeDialog('swaIndexLetterDialog');\" arg:params=\"_base={= ui:currentQueryGraph() }&amp;_cache={= ?cache }&amp;facet0={= ui:encodeURL(ui:encodeNode(?labelProperty, true, true)) }&amp;regex0=%5E{= ?letter }&amp;lang0={= ui:lang() }&amp;type={= ui:encodeURL(ui:encodeNode(?resourceType, true, true)) }\" arg:type=\"{= ?resourceType }\" arg:width=\"{= 400 }\"/>
        </div>
    </ui:if>
</ui:loadable>
"""^^ui:Literal ;
  rdfs:comment "A dialog that displays a sorted list of all resources starting with a given letter." ;
  rdfs:label "Index letter dialog" ;
  rdfs:subClassOf swa:IndexElements ;
.
swa:InitTBF
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:resourceSelectedEvent ;
      spl:valueType xsd:string ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:group let:linkFunction=\"{= ui:contextValue(&quot;tbfLinkFunction&quot;) }\">
    <ui:if ui:condition=\"{= bound(?linkFunction) }\">
        <script>tbf.setLinkFunction('{= ?linkFunction }')</script>
    </ui:if>
    <ui:if ui:condition=\"{= bound(?resourceSelectedEvent) }\">
        <script>tbf.setResourceSelectedEvent('{= ?resourceSelectedEvent }')</script>
    </ui:if>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "Prepares the TBF library so that it works correctly under the current context." ;
  rdfs:label "Init TBF" ;
  rdfs:subClassOf swa:FormElements ;
.
swa:Initializer
  a ui:NodeClass ;
  ui:prototype """
<script let:appName=\"{= ui:contextValue(&quot;swaAppName&quot;) }\" let:tabKey=\"{= ui:contextValue(&quot;swaTabKey&quot;) }\" let:tabStorageKey=\"{= ui:contextValue(&quot;swaTabStorageKey&quot;) }\">(function(swa) {
  var swa = swa || {};

	swa.queryGraphURI='{= ui:currentQueryGraph() }';
swa.swaAppName='{= ?appName }';<ui:if ui:condition=\"{= bound(?tabKey) &amp;&amp; bound(?tabStorageKey) }\">var key = '{= ?tabStorageKey }tabs-{= ?tabKey }';

		swa.tabQueryGraphURIs[key] = '{= ui:currentQueryGraph() }';</ui:if>
})(swa);</script>
"""^^ui:Literal ;
  rdfs:comment "Should be placed into the beginning of an SWA application's main element, i.e. the start of the body. Will set some variables required by some SWA features. Note that swa:FullScreenBorderLayout includes this automatically." ;
  rdfs:label "Initializer" ;
  rdfs:subClassOf swa:ScriptElements ;
.
swa:InlineEditorContainer
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:placeholder ;
      spl:valueType xsd:string ;
      rdfs:comment "Placeholder to show if no value provided" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:readOnly ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to make this non-editable. This can be used to have a consistent layout even if the user does not have editing permissions." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:value ;
      rdfs:comment "The original value to display and edit." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:id ;
      spl:valueType xsd:string ;
      rdfs:comment "The id to use." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:updateLink ;
      spl:valueType xsd:string ;
      rdfs:comment "A link to the servlet to call when a new value has been entered by the user. The new value will be passed into the service as argument called \"newValue\"." ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:group>
    <table class=\"swa-inline-editor\" id=\"{= ?id }\" updatelink=\"{= ?updateLink }\">
        <tr>
            <td>
                <div class=\"swa-inline-editor-text-parent\" id=\"{= ?id }-text-parent\">
                    <span class=\"{= IF(((!bound(?value)) &amp;&amp; bound(?placeholder)), &quot;swa-display-none&quot;, &quot;&quot;) }\" id=\"{= ?id }-text\">{= ui:label(?value) }</span>
                    <ui:if ui:condition=\"{= bound(?placeholder) &amp;&amp; swa:falseOrUnbound(?readOnly) }\">
                        <span class=\"text-muted{= IF(bound(?value), &quot; swa-display-none&quot;, &quot; &quot;) }\" id=\"{= ?id }-placeholder\">{= ?placeholder }</span>
                    </ui:if>
                </div>
                <div class=\"swa-display-none\" id=\"{= ?id }-editor-parent\">
                    <ui:insertionPoint ui:pointId=\"editor\"/>
                </div>
            </td>
            <td class=\"swa-inline-editor-button-cell swa-hidden\" id=\"{= ?id }-button-cell\">
                <div class=\"swa-inline-editor-button swa-inline-editor-button-edit\" id=\"{= ?id }-button\"/>
            </td>
        </tr>
    </table>
    <ui:if ui:condition=\"{= swa:falseOrUnbound(?readOnly) }\">
        <script>swa.initInlineEditor(\"{= ?id }\");</script>
    </ui:if>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "Implements the container of an inline editor, consisting of a display field of the current value, and the mouse-over logic to toggle to edit mode." ;
  rdfs:label "Inline editor container" ;
  rdfs:subClassOf swa:InlineEditorElements ;
.
swa:InlineEditorElements
  a ui:NodeClass ;
  ui:abstract true ;
  rdfs:comment "Base class for elements that can be used for inline editing on HTML pages. Inline editors appear as display text but when the mouse moves over them, a small pencil icon appears to switch the text to a suitable editor (e.g. text field, text area, auto-complete)." ;
  rdfs:label "Inline editor elements" ;
  rdfs:subClassOf swa:Elements ;
.
swa:InlineEditorUpdateServices
  a ui:Service ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:newValue ;
      rdfs:comment "The new value, as entered by the user." ;
    ] ;
  rdfs:comment "Abstract base class for services that take a new value (entered by the user) and perform an update to some data. This is often implemented using a ui:update. The service needs to return a JSON object with an attribute \"status\" : \"ok|warning|error\" and (if not OK) \"message\" for the error or warning message. The UI can use that information to inform the user that there was something wrong. If the status is returned as \"ok\" or \"warning\" then the actual edit should be performed, and in case of \"error\" it should not do anything." ;
  rdfs:label "Inline editor update services" ;
  rdfs:subClassOf ui:JSONServices ;
.
swa:InstanceSearchDialogAutoCompleteSelectAction
  a swa:AutoCompleteSelectAction ;
  arg:condition [
      a sp:not ;
      sp:arg1 [
          a teamwork:isOntology ;
          sp:arg1 [
              a teamwork:currentMasterGraph ;
            ] ;
        ] ;
    ] ;
  arg:onSelect "swa.openAutoCompleteInstanceSearchDialog" ;
  rdfs:label "Select using search dialog..." ;
.
swa:InstancesGridGadget
  a swa:Gadget ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:classSelectedEvent ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the event to subscribe to so that the instances can be reloaded whenever the class changes." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:directInstancesOnly ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to only display the direct instances of the class, i.e. instances of subclasses will not be displayed." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:editButton ;
      spl:valueType xsd:boolean ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:editable ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to have a button to create classes appear under the tree." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class of instances to display." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:instanceSelectedEvent ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the event to fire if the selected instance has changed." ;
    ] ;
  ui:prototype """
<ui:group let:loadId=\"{= ui:uniqueId() }\" let:searchGraph=\"{= ui:createSessionGraph() }\">
    <ui:if ui:condition=\"{= bound(?resourceType) }\">
        <swa:WindowTitleSetter arg:title=\"Instances of {= ui:label(?resourceType) }\"/>
        <ui:loadable class=\"ui-layout-content\" ui:loadId=\"{= ?loadId }\">
            <ui:setContext ui:queryGraph=\"{= ?searchGraph }\">
                <ui:update ui:updateQuery=\"{!
                        DELETE WHERE {
                            ?s ?p ?o .
                        } }\"/>
            </ui:setContext>
            <ui:group let:queryGraph=\"{= ui:currentQueryGraph() }\" let:search=\"{= BNODE() }\">
                <ui:setContext ui:queryGraph=\"{= ?searchGraph }\">
                    <ui:update ui:updateQuery=\"{!
                            INSERT {
                                ?search a search:Search .
                                ?search search:queryGraph ?queryGraph .
                                ?search search:rootType ?resourceType .
                                ?search search:directInstancesSearch ?directInstancesOnly .
                            }
                            WHERE {
                            } }\"/>
                </ui:setContext>
                <ui:if ui:condition=\"{= EXISTS {
                    ?subClass rdfs:subClassOf ?resourceType .
                } &amp;&amp; swa:falseOrUnbound(?directInstancesOnly) }\">
                    <ui:setContext ui:queryGraph=\"{= ?searchGraph }\">
                        <ui:update ui:updateQuery=\"{!
                                INSERT {
                                    ?search spin:column ?column .
                                    ?column spin:columnIndex 0 .
                                    ?column search:columnSubjectVarName &quot;result&quot; .
                                    ?column a search:PropertyColumn .
                                    ?column search:columnProperty rdf:type .
                                }
                                WHERE {
                                    BIND (BNODE() AS ?column) .
                                } }\"/>
                    </ui:setContext>
                </ui:if>
            </ui:group>
            <swa:DataTableSearchResultsBody arg:editButton=\"{= ?editButton }\" arg:exports=\"{= true }\" arg:filter=\"{= true }\" arg:resourceSelectedEvent=\"{= ?instanceSelectedEvent }\" arg:resourceType=\"{= ?resourceType }\" ui:args=\"*\"/>
        </ui:loadable>
    </ui:if>
    <swa:SubscribeArgument arg:argumentName=\"resourceType\" arg:event=\"{= ?classSelectedEvent }\"/>
    <swa:Subscribe arg:code=\"swa.handleChangeForInstancesGrid(data, &quot;{= ?resourceType }&quot;, '{= ?loadId }')\" arg:event=\"org.topbraid.swa.change\"/>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "A gadget that displays the instances of a given class (?resourceType) in a grid. The gadget has an auto-complete box under the grid." ;
  rdfs:label "Instances grid gadget" ;
  rdfs:subClassOf swa:Gadgets ;
.
swa:InstancesSelectEditor
  a swa:ObjectEditorClass ;
  ui:prototype """
<span let:name=\"new-{= ?uid }\" let:range=\"{= swa:localRangeAtClass(swa:resourceType(?subject), ?predicate) }\">
    <select class=\"form-control {= swa:testClass(?predicate) }\" name=\"{= ?name }\">
        <option/>
        <ui:forEach ui:indexVar=\"index\" ui:resultSet=\"{#
                SELECT DISTINCT ?instance ?label
                WHERE {
                    ?type (rdfs:subClassOf)* ?range .
                    ?instance a ?type .
                    BIND (ui:label(?instance) AS ?label) .
                }
                ORDER BY (?label) }\">
            <option selected=\"{= IF((?object = ?instance), &quot;selected&quot;, ?none) }\" value=\"{= ui:encodeNode(?instance, true, true) }\">{= ?label }</option>
        </ui:forEach>
    </select>
</span>
"""^^ui:Literal ;
  rdfs:comment "Produces a simple HTML drop down (select) of all instances of the given range, including all subclasses." ;
  rdfs:label "Instances select editor" ;
  rdfs:subClassOf swa:ObjectEditor ;
.
swa:InstancesSelectFacet
  a swa:ObjectFacetClass ;
  ui:prototype """
<span let:name=\"value{= ?uid }\" let:range=\"{= swa:localRangeAtClass(swa:resourceType(?subject), ?predicate) }\">
    <select class=\"form-control {= swa:testClass(?predicate) }\" name=\"{= ?name }\">
        <option/>
        <ui:forEach ui:indexVar=\"index\" ui:resultSet=\"{#
                SELECT DISTINCT ?instance ?label
                WHERE {
                    ?type (rdfs:subClassOf)* ?range .
                    ?instance a ?type .
                    BIND (ui:label(?instance) AS ?label) .
                }
                ORDER BY (?label) }\">
            <option selected=\"{= IF((?object = ?instance), &quot;selected&quot;, ?none) }\" value=\"{= ui:encodeNode(?instance, true, true) }\">{= ?label }</option>
        </ui:forEach>
    </select>
</span>
"""^^ui:Literal ;
  rdfs:comment "A simple drop down box of all instances of the given range (including subclasses)." ;
  rdfs:label "Instances select facet" ;
  rdfs:subClassOf swa:ObjectFacet ;
.
swa:JSONDataForSpanningTree
  a ui:Service ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:inverse ;
      spl:valueType xsd:boolean ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:relationship ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "Predicate relationship to visualize" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:root ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The root of the tree" ;
    ] ;
  ui:prototype """
<ui:group let:isInverse=\"{= COALESCE(?inverse, false) }\">
    <!--ui:dumpScope ui:message=\"AAA1: swa:JSONDataForSpanningTree\"/-->
    <swa:PseudoSpanningTree arg:inverse=\"{= ?isInverse }\" arg:maxHeight=\"{= 8 }\" arg:relationship=\"{= ?relationship }\" arg:subject=\"{= ?root }\"/>
</ui:group>
"""^^ui:Literal ;
  rdfs:label "JSON data for spanning tree" ;
  rdfs:subClassOf ui:JSONServices ;
.
swa:Label
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:node ;
      rdfs:comment "The RDF node to display the label of." ;
    ] ;
  ui:prototype """
<span class=\"swa-label\">
    <ui:if ui:condition=\"{= isLiteral(?node) }\">{= ui:label(?node) }</ui:if>
    <ui:else>
        <ui:resourceView ui:matchIds=\"label\" ui:resource=\"{= ?node }\"/>
    </ui:else>
</span>
"""^^ui:Literal ;
  rdfs:comment "A span that inserts an instance view of a given resource with match id \"label\". If the node is a literal it will simply render the ui:label of the literal." ;
  rdfs:label "Label" ;
  rdfs:subClassOf swa:Elements ;
.
swa:LabelRegexStringFacet
  a swa:ObjectFacetClass ;
  swa:facetSearchType search:RegexFacetValue ;
  swa:objectFacetMenuName "label matches regular expression" ;
  swa:objectWidgetWeight [
      a swa:WeightedExpression ;
      swa:expression [
          a sp:and ;
          sp:arg1 [
              a sp:bound ;
              sp:arg1 [
                  sp:varName "range" ;
                ] ;
            ] ;
          sp:arg2 [
              a sp:not ;
              sp:arg1 [
                  a swa:isDatatypeRange ;
                  arg:range [
                      sp:varName "range" ;
                    ] ;
                ] ;
            ] ;
        ] ;
      swa:weight -2 ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:group let:restore=\"{= swa:restoreFacetValue(?predicate) }\">
    <input class=\"form-control {= swa:testClass(?predicate) }\" name=\"label{= ?uid }\" type=\"text\" value=\"{= IF(bound(?restore), spl:object(?restore, search:pattern), ?none) }\"/>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "An ObjectFacet showing a text field. The resulting string will be matched against as a regex on labels of linked object resources." ;
  rdfs:label "Label regex string facet" ;
  rdfs:subClassOf swa:ObjectFacet ;
.
swa:LabeledElement
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:class ;
      spl:valueType xsd:string ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:label ;
      spl:valueType xsd:string ;
      rdfs:comment "The label text." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:toolTip ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional tool tip text to appear over the label." ;
    ] ;
  ui:prototype """
<table class=\"swa-labeled-objects-table\" let:id=\"{= ui:uniqueId() }\">
    <tr>
        <td class=\"swa-labeled-objects-label-td swa-labeled-objects-tabular-label {= IF(bound(?class), ?class, ?none) }\">
            <div class=\"swa-shifted-label\">
                <label for=\"{= ?id }\" title=\"{= ?toolTip }\">{= ?label }</label>
            </div>
        </td>
        <td class=\"swa-labeled-objects-icons-td\">
            <span class=\"swa-icon\"/>
        </td>
        <td id=\"{= ?id }\">
            <ui:insertionPoint ui:pointId=\"body\"/>
        </td>
    </tr>
</table>
"""^^ui:Literal ;
  rdfs:comment "A container element with one child, that places a label to the left and the child element to the right, in the same layout as the tabular forms." ;
  rdfs:label "Labeled element" ;
  rdfs:subClassOf swa:LayoutElements ;
.
swa:LabeledObjects
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:single ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to only allow at most one object for this component." ;
    ] ;
  ui:errorPrototype """
<ui:if ui:condition=\"{= !bound(?predicate) }\">
    <div>ERROR: Missing arg:predicate for object</div>
</ui:if>
"""^^ui:Literal ;
  ui:private true ;
  ui:prototype """
<ui:if ui:condition=\"{= (((!bound(?hideIfEmpty)) || (?hideIfEmpty != true)) || (swa:mode() != swa:ViewMode)) || ((bound(?subject) &amp;&amp; (EXISTS {
    ?subject ?predicate ?anyObject .
} || spl:instanceOf(?predicate, spin:MagicProperty))) || (bound(?subject) &amp;&amp; swa:isMandatory(?predicate, ?subject))) }\">
    <ui:if ui:condition=\"{= (!bound(?hideInModes)) || (!swa:containsCurrentModeName(?hideInModes)) }\">
        <ui:if let:loadId=\"{= COALESCE(?elementId, ui:uniqueId()) }\" ui:condition=\"{= (((rdf:type != ?predicate) || (swa:mode() != swa:SearchMode)) || ui:contextValue(&quot;isNested&quot;)) || COALESCE(ui:contextValue(&quot;suppressRDFType&quot;), true) }\">
            <ui:if ui:condition=\"{= !swa:isHiddenObjectWidget(?subject, ?predicate) }\">
                <ui:loadable class=\"{= COALESCE(?class, &quot;swa-labeled-objects&quot;) }\" ui:loadId=\"{= ?loadId }\">
                    <ui:setContext ui:varName=\"{= IF(?editing, &quot;mode&quot;, ?none) }\" ui:varValue=\"edit\">
                        <table class=\"swa-labeled-objects-table\" let:pid=\"{= ui:uniqueId() }\">
                            <tr let:comment=\"{= swa:propertyCommentAtNode(?predicate, ?subject) }\">
                                <td class=\"swa-labeled-objects-label-td {= IF(swa:falseOrUnbound(?linear), &quot;swa-labeled-objects-tabular-label&quot;, ?none) }\" style=\"{= IF(bound(?labelWidth), CONCAT(&quot;width: &quot;, ?labelWidth, &quot; !important; min-width: &quot;, ?labelWidth, &quot; !important&quot;), ?none) }\">
                                    <ui:if ui:condition=\"{= ?openable }\">
                                        <div class=\"swa-shifted-label\">
                                            <div class=\"swa-openable-object-icon ui-icon ui-icon-triangle-1-{= IF(((bound(?open) &amp;&amp; ?open) || (!swa:isSearchMode())), &quot;s&quot;, &quot;e&quot;) }\" id=\"{= ?pid }-button\" onclick=\"swa.toggleOpenableObject('{= ?pid }-body', '{= ?pid }-button')\"/>
                                            <div class=\"swa-float-left\">
                                                <swa:PropertyLabel arg:comment=\"{= ?comment }\" arg:id=\"property-label-{= ?predicate }\" arg:inferred=\"{= bound(?subject) &amp;&amp; swa:isInferredProperty(?predicate, ?subject) }\" arg:label=\"{= COALESCE(?label, swa:propertyLabelAtNode(?predicate, ?subject)) }\" arg:property=\"{= ?predicate }\" arg:subject=\"{= IF(swa:isEditMode(), ?subject, IF((bound(?subject) &amp;&amp; swa:isMandatory(?predicate, ?subject)), ?subject, ?none)) }\"/>
                                            </div>
                                            <div class=\"swa-clear-both\"/>
                                        </div>
                                    </ui:if>
                                    <ui:else>
                                        <div class=\"swa-shifted-label\">
                                            <swa:PropertyLabel arg:comment=\"{= ?comment }\" arg:id=\"property-label-{= ?predicate }\" arg:inferred=\"{= bound(?subject) &amp;&amp; swa:isInferredProperty(?predicate, ?subject) }\" arg:label=\"{= COALESCE(?label, swa:propertyLabelAtNode(?predicate, ?subject)) }\" arg:property=\"{= ?predicate }\" arg:subject=\"{= IF(swa:isEditMode(), ?subject, IF((bound(?subject) &amp;&amp; swa:isMandatory(?predicate, ?subject)), ?subject, ?none)) }\"/>
                                        </div>
                                    </ui:else>
                                </td>
                                <ui:dynamicView arg:editWidget=\"{= ?editWidget }\" arg:predicate=\"{= ?predicate }\" arg:searchWidget=\"{= ?searchWidget }\" arg:single=\"{= ?single }\" arg:subject=\"{= ?subject }\" arg:uid=\"{= ?pid }\" arg:viewWidget=\"{= ?viewWidget }\" ui:class=\"{= COALESCE(swa:modeProperty(swa:objectWidgetMiddleColumnClass), swa:DefaultObjectWidgetMiddleColumn) }\"/>
                                <td class=\"swa-labeled-objects-body-td {= IF((?openable &amp;&amp; swa:isSearchMode()), &quot;ui-helper-hidden-accessible&quot;, ?none) }\" id=\"{= ?pid }-body\">
                                    <ui:setContext ui:varName=\"editWidget\" ui:varValue=\"{= ?editWidget }\">
                                        <ui:setContext ui:varName=\"searchWidget\" ui:varValue=\"{= ?searchWidget }\">
                                            <ui:setContext ui:varName=\"viewWidget\" ui:varValue=\"{= ?viewWidget }\">
                                                <swa:ObjectsBody ui:args=\"*\"/>
                                            </ui:setContext>
                                        </ui:setContext>
                                    </ui:setContext>
                                </td>
                            </tr>
                            <ui:if ui:condition=\"{= ?editing }\">
                                <tr>
                                    <td/>
                                    <td/>
                                    <td class=\"swa-labeled-objects-editing\">
                                        <input name=\"_base\" type=\"hidden\" value=\"{= ui:currentQueryGraph() }\"/>
                                        <swa:Button arg:class=\"btn btn-default btn-xs inline-edit-save\" arg:iconClass=\"ui-icon ui-icon-check\" arg:id=\"{= ?pid }-saveButton\" arg:label=\"Save Changes\"/>
                                        <swa:Space/>
                                        <swa:Button arg:class=\"btn btn-default btn-xs inline-edit-cancel\" arg:iconClass=\"ui-icon ui-icon-cancel\" arg:id=\"{= ?pid }-cancelButton\" arg:label=\"Cancel\"/>
                                    </td>
                                </tr>
                            </ui:if>
                        </table>
                    </ui:setContext>
                </ui:loadable>
            </ui:if>
        </ui:if>
    </ui:if>
</ui:if>
"""^^ui:Literal ;
  rdfs:comment "The default implementation of swa:Object and swa:Objects. Displays a label on the left and the value widget(s) on the right." ;
  rdfs:label "Labeled objects" ;
  rdfs:subClassOf swa:Objects ;
.
swa:LabeledSubjects
  a ui:NodeClass ;
  ui:private true ;
  ui:prototype """
<ui:if ui:condition=\"{= (((!bound(?hideIfEmpty)) || (?hideIfEmpty != true)) || (swa:mode() != swa:ViewMode)) || (bound(?object) &amp;&amp; EXISTS {
    ?anySubject ?predicate ?object .
}) }\">
    <ui:if ui:condition=\"{= !swa:isHiddenSubjectWidget(?object, ?predicate) }\">
        <table class=\"swa-labeled-objects-table\" let:pid=\"{= ui:uniqueId() }\" let:useLabel=\"{= IF(STRENDS(?label, &quot; (inverse)&quot;), ?none, ?label) }\">
            <tr>
                <td class=\"swa-labeled-objects-label-td {= IF(swa:falseOrUnbound(?linear), &quot;swa-labeled-objects-tabular-label&quot;, ?none) }\" style=\"{= IF(bound(?labelWidth), CONCAT(&quot;width: &quot;, ?labelWidth), ?none) }\">
                    <div class=\"swa-shifted-label\" let:comment=\"{= swa:inversePropertyShapePropertyAtNode(?predicate, sh:description, ?object) }\">
                        <ui:if ui:condition=\"{= bound(?label) }\">
                            <swa:PropertyLabel arg:comment=\"{= ?comment }\" arg:inverse=\"{= !bound(?useLabel) }\" arg:label=\"{= IF(bound(?useLabel), ?useLabel, ui:label(?predicate)) }\"/>
                        </ui:if>
                        <ui:else>
                            <ui:group let:name=\"{= swa:inversePropertyShapePropertyAtNode(?predicate, sh:name, ?object) }\">
                                <swa:PropertyLabel arg:comment=\"{= ?comment }\" arg:inverse=\"{= !bound(?name) }\" arg:label=\"{= COALESCE(?name, ui:label(?predicate)) }\"/>
                            </ui:group>
                        </ui:else>
                    </div>
                </td>
                <ui:dynamicView arg:editWidget=\"{= ?editWidget }\" arg:object=\"{= ?object }\" arg:predicate=\"{= ?predicate }\" arg:searchWidget=\"{= ?searchWidget }\" arg:single=\"{= ?single }\" arg:uid=\"{= ?pid }\" arg:viewWidget=\"{= ?viewWidget }\" ui:class=\"{= COALESCE(swa:modeProperty(swa:subjectWidgetMiddleColumnClass), swa:DefaultSubjectWidgetMiddleColumn) }\"/>
                <td class=\"swa-labeled-objects-body-td\" id=\"{= ?pid }-body\">
                    <swa:SubjectsBody ui:args=\"*\"/>
                </td>
            </tr>
        </table>
    </ui:if>
</ui:if>
"""^^ui:Literal ;
  rdfs:comment "Default implementation of swa:Subjects." ;
  rdfs:label "Labeled subjects" ;
  rdfs:subClassOf swa:Subjects ;
.
swa:LangDisplay
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:lang ;
      spl:valueType xsd:string ;
      rdfs:comment "The language tag." ;
    ] ;
  ui:prototype """
<ui:if ui:condition=\"{= bound(?lang) &amp;&amp; (?lang != &quot;&quot;) }\">
    <ui:if ui:condition=\"{= ui:contextValue(&quot;langFlags&quot;) }\">
        <img alt=\"Language Display\" class=\"swa-lang-img\" src=\"{= swa:langImage(?lang) }\" title=\"Language code: {= ?lang }\"/>
    </ui:if>
    <ui:else>
        <span class=\"swa-lang\">({= ?lang })</span>
    </ui:else>
</ui:if>
"""^^ui:Literal ;
  rdfs:comment "Displays a given language. Does nothing if the language is unbound." ;
  rdfs:label "Lang display" ;
  rdfs:subClassOf swa:FormElements ;
.
swa:LangSelector
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:changeHandler ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional JS snippet that shall be called on changes of the selection." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:initialValue ;
      spl:valueType xsd:string ;
      rdfs:comment "The initial language to display." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:plain ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to suppress the \"form-control\" class that may mess up the layout." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:required ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to always have a pre-selected language." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:uid ;
      spl:valueType xsd:string ;
      rdfs:comment "The uid of the surrounding widget. Will become the XY half of the lang-XY field name." ;
    ] ;
  swa:defaultLanguages "en ar de es fr it pt ru zh" ;
  ui:private true ;
  ui:prototype """
<ui:group>
    <input id=\"hidden-lang-selector\" type=\"hidden\" value=\"\"/>
    <select class=\"{= IF(swa:falseOrUnbound(?plain), &quot;form-control &quot;, ?none) }swa-lang-selector\" id=\"{= ?uid }-lang\" name=\"lang-{= ?uid }\" onchange=\"$('#hidden-lang-selector').val(value);\" title=\"Language (e.g. 'en' for English)\">
        <ui:if ui:condition=\"{= swa:falseOrUnbound(?required) }\">
            <option selected=\"selected\" value=\"\"/>
        </ui:if>
        <ui:forEach ui:indexVar=\"index\" ui:resultSet='{#
                SELECT DISTINCT ?lang
                WHERE {
                    {
                        GRAPH ui:graph {
                            BIND (COALESCE(spl:object(swa:LangSelector, swa:customLanguages), spl:object(swa:LangSelector, swa:defaultLanguages)) AS ?langs) .
                        } .
                        ?lang spif:split ( ?langs \" \" ) .
                    }
                    UNION
                    {
                        BIND (xsd:string(?initialValue) AS ?lang) .
                    } .
                    FILTER (?lang != \"\") .
                } }'>
            <option selected=\"{= IF(((?initialValue = ?lang) || (((!bound(?initialValue)) &amp;&amp; ?required) &amp;&amp; (?index = 0))), &quot;selected&quot;, ?none) }\">{= ?lang }</option>
        </ui:forEach>
    </select>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "A select box that allows users to select a language code. The result is a form field such as lang-uniqueId42 that is sent to the edit servlet. The list of languages is specified by the property swa:defaultLanguages. These can be overloaded by adding a triple swa:LangSelector swa:customLanguages \"space-separated string\" to a UI graph." ;
  rdfs:label "Lang selector" ;
  rdfs:subClassOf swa:FormElements ;
.
swa:LanguageListShape
  a sh:NodeShape ;
  sh:sparql [
      sh:message "Invalid language tag \"{?tag}\"" ;
      sh:prefixes <http://topbraid.org/swa> ;
      sh:select """SELECT $this (swa:customLanguages AS ?path) ?value ?tag
WHERE {
	$this swa:customLanguages ?value .
 	?tag spif:split (?value \" \") .
 	FILTER (?tag != \"\" && !spif:isValidLangTag(?tag))
}""" ;
    ] ;
  sh:targetNode swa:LangSelector ;
.
swa:LayoutElements
  a ui:NodeClass ;
  ui:abstract true ;
  ui:private true ;
  rdfs:comment "Abstract base class for elements that can be used to drive an application's layout." ;
  rdfs:label "Layout elements" ;
  rdfs:subClassOf swa:Elements ;
.
swa:Link
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:id ;
      spl:valueType xsd:string ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:labelOverride ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional override to the label." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The URI resource to link to." ;
    ] ;
  ui:prototype """
<ui:group let:href=\"{= swa:createHRef(?resource) }\">
    <ui:if ui:condition=\"{= bound(?href) }\">
        <a class=\"swa-link\" href=\"{= ?href }\" id=\"{= ?id }\">
            <ui:if ui:condition=\"{= bound(?labelOverride) }\">{= ?labelOverride }</ui:if>
            <ui:else>
                <swa:Label arg:node=\"{= ?resource }\"/>
            </ui:else>
        </a>
    </ui:if>
    <ui:else>
        <ui:group let:uid=\"{= COALESCE(?id, ui:uniqueId()) }\">
            <ui:group let:link=\"{= swa:createLink(?resource, ?uid) }\">
                <ui:if ui:condition=\"{= bound(?link) }\">
                    <a class=\"swa-link\" href=\"javascript:void(0)\" id=\"{= ?uid }\" onclick=\"{= ?link }\">
                        <ui:if ui:condition=\"{= bound(?labelOverride) }\">{= ?labelOverride }</ui:if>
                        <ui:else>
                            <swa:Label arg:node=\"{= ?resource }\"/>
                        </ui:else>
                    </a>
                </ui:if>
                <ui:else>
                    <ui:if ui:condition=\"{= bound(?labelOverride) }\">{= ?labelOverride }</ui:if>
                    <ui:else>
                        <swa:Label arg:node=\"{= ?resource }\"/>
                    </ui:else>
                </ui:else>
            </ui:group>
        </ui:group>
    </ui:else>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "Creates a hyperlink to switch the current view to a given resource. This element should be used to create all hyperlinks in SWA applications, because this single place provides greater flexibility to make adjustments to the links. In particular, the semantics of what should happen if the user clicks on a link may be different for each application or even within different parts of a single application: in some cases the application may want to replace a form on the screen, while in other cases the selected resource should be opened in a modal dialog. The SPIN functions swa:createHRef and swa:createLink are used to define the link. If these functions return nothing, then no link is displayed, but rather an swa:Label." ;
  rdfs:label "Link" ;
  rdfs:subClassOf swa:Elements ;
.
swa:ListElements
  a ui:NodeClass ;
  rdfs:label "List elements" ;
  rdfs:subClassOf swa:Elements ;
.
swa:LiteralViewer
  a swa:ObjectViewerClass ;
  swa:objectWidgetWeight [
      a swa:WeightedExpression ;
      swa:expression [
          a sp:eq ;
          sp:arg1 [
              sp:varName "kind" ;
            ] ;
          sp:arg2 "literal" ;
        ] ;
    ] ;
  ui:private true ;
  ui:prototype """
<div class=\"swa-shifted-label\">{= ?object }<ui:if ui:condition=\"{= lang(?object) != &quot;&quot; }\">
        <swa:LangDisplay arg:lang=\"{= lang(?object) }\"/>
    </ui:if>
</div>
"""^^ui:Literal ;
  rdfs:comment "A node viewer for literal values, displaying the literal's text. If a language tag is present, then this will be displayed behind the text." ;
  rdfs:label "Literal viewer" ;
  rdfs:subClassOf swa:ObjectViewer ;
.
swa:LoadableFormSection
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:hideLabelWhenDone ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to hide the label when clicked." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:labelStyle ;
      spl:valueType xsd:string ;
      rdfs:comment "Optional CSS styles for the header." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:loadId ;
      spl:valueType xsd:string ;
      rdfs:comment "The id of the embedded loadable." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:label ;
      spl:valueType xsd:string ;
      rdfs:comment "The title of the section." ;
    ] ;
  ui:prototype """
<ui:group ui:id=\"{= ui:uniqueId() }\">
    <div class=\"swa-sub-title swa-loadable-form-section-clickable\" id=\"{= ?id }\" onclick=\"$(this).attr('onclick', '');$(this).removeClass('swa-loadable-form-section-clickable');swa.load('{= ?loadId }');{= IF(?hideLabelWhenDone, &quot;$(this).hide()&quot;, ?none) }\" style=\"{= ?labelStyle }\">
        <span>{= ?label }</span>
    </div>
    <ui:insertionPoint ui:pointId=\"body\"/>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "Displays a sub-header with a (Show) button. When clicked, will load the child ui:loadable." ;
  rdfs:label "Loadable form section" ;
  rdfs:subClassOf swa:FormElements ;
.
swa:LocalUnionRangesService
  a ui:Service ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property to add a widget for." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:subject ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject resource (on the form)." ;
    ] ;
  ui:prototype """
<swon:RSObjectArray arg:resultSet=\"{#
        SELECT ?range ?label
        WHERE {
            {
                ?subject a ?type .
                BIND (swa:localUnionRangeAtClass(?type, ?predicate) AS ?list) .
                FILTER bound(?list) .
                FILTER NOT EXISTS {
                    ?list rdf:first/sh:datatype xsd:string .
                    ?list (rdf:rest/rdf:first)/sh:datatype rdf:langString .
                    ?list rdf:rest/rdf:rest rdf:nil .
                } .
            } .
            ?list (rdf:rest)*/rdf:first ?rangeShape .
            ?rangeShape sh:datatype|sh:class ?range .
            BIND (ui:label(?range) AS ?label) .
        } }\"/>
"""^^ui:Literal ;
  rdfs:comment "Used by the Add row button to determine whether a property has multiple ranges (e.g. rdf:HTML or xsd:string). Returns an array of those. The array is empty if no union range exists or if the union is exactly xsd:string or rdf:langString." ;
  rdfs:label "Local union ranges service" ;
  rdfs:subClassOf ui:JSONServices ;
.
swa:MakePrimaryKeyDialog
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:loadId ;
      spl:valueType xsd:string ;
      rdfs:comment "The ui:loadId of the ui:loadable that will be placed around the dialog." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property to make the primary key." ;
    ] ;
  ui:prototype """
<ui:group let:class=\"{= spl:object(?property, rdfs:domain) }\">
    <div id=\"div-{= ?loadId }\" title=\"Make {= ui:label(?property) } the primary key of {= ui:label(?class) }\">
        <swa:LabeledElement arg:label=\"Start of URIs:\">
            <input class=\"swa-create-resource-label-input form-control\" id=\"uriStart\" type=\"text\" value=\"http://example.org/{= afn:localname(?class) }-\"/>
        </swa:LabeledElement>
        <br/>
        <div>Please enter the start of the globally unique identifiers that shall be used for
		instances of the class {= ui:label(?class) }.
		The value of the primary key itself will be appended to the URI start.
		A typical example is&nbsp;<b>http://example.org/Country-</b>.
	</div>
    </div>
</ui:group>
"""^^ui:Literal ;
  rdfs:label "Make primary key dialog" ;
  rdfs:subClassOf swa:DialogElements ;
.
swa:MakePrimaryKeyResourceAction
  a swa:ResourceAction ;
  arg:appName "Editor" ;
  arg:condition [
      a sp:if ;
      sp:arg1 [
          a sp:and ;
          sp:arg1 [
              a spl:instanceOf ;
              sp:arg1 [
                  sp:varName "resource" ;
                ] ;
              sp:arg2 rdf:Property ;
            ] ;
          sp:arg2 [
              a sp:exists ;
              sp:elements (
                  [
                    sp:object [
                        sp:varName "anyDomain" ;
                      ] ;
                    sp:predicate rdfs:domain ;
                    sp:subject [
                        sp:varName "resource" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "anyType" ;
                      ] ;
                    sp:predicate rdf:type ;
                    sp:subject dash:PrimaryKeyConstraintComponent ;
                  ]
                ) ;
            ] ;
        ] ;
      sp:arg2 true ;
      sp:arg3 [
          sp:varName "none" ;
        ] ;
    ] ;
  arg:iconClass "make-primary-key" ;
  arg:onSelect "swa.makePrimaryKey(resourceURI)" ;
  rdfs:label "Make primary key..." ;
.
swa:MenuElements
  a ui:NodeClass ;
  ui:abstract true ;
  ui:private true ;
  rdfs:comment "Abstract superclass to group menu-related elements." ;
  rdfs:label "Menu elements" ;
  rdfs:subClassOf swa:Elements ;
.
swa:Meta
  a ui:Script ;
  ui:prototype """
<meta content=\"IE=Edge,chrome=1\" http-equiv=\"X-UA-Compatible\"/>
"""^^ui:Literal ;
  rdfs:label "Meta" ;
  rdfs:subClassOf ui:Scripts ;
.
swa:Mode
  a rdfs:Class ;
  rdfs:comment "The class of the various modes that a form can be in, e.g. editing, viewing. Each Mode holds pointers to the relevant subclasses that shall be inserted." ;
  rdfs:label "Mode" ;
.
swa:MultiGadgetChild
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:iconClass ;
      spl:valueType xsd:string ;
      rdfs:comment "The CSS style of an icon representing this child." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:title ;
      spl:valueType xsd:string ;
      rdfs:comment "The title of the child." ;
    ] ;
  ui:prototype """
<ui:group let:window=\"{#
        SELECT ?window
        WHERE {
            GRAPH ui:graph {
                ?window ui:child ?thisParent .
            } .
        } }\">
    <ui:group let:childIndex=\"{= spl:objectInGraph(?thisParent, ui:childIndex, ui:graph) }\" let:layoutPanel=\"{= spl:objectInGraph(?window, arg:layoutPanel, ui:graph) }\" let:windowId=\"{= spl:objectInGraph(?window, arg:id, ui:graph) }\">
        <div class=\"swa-window swa-window-border ui-layout-{= ?layoutPanel } {= IF((?childIndex != 0), &quot;swa-display-none&quot;, ?none) }\" id=\"{= ?windowId }-child-{= ?childIndex }\">
            <div class=\"swa-header\" id=\"{= ?id }\">
                <div class=\"swa-header-label swa-float-left\">{= ?title }</div>
                <ui:forEach ui:resultSet=\"{#
                        SELECT ?child ?ci
                        WHERE {
                            GRAPH ui:graph {
                                ?window ui:child ?child .
                                ?child ui:childIndex ?ci .
                                FILTER (?childIndex != ?ci) .
                            } .
                        } }\">
                    <ui:if ui:condition=\"{= bound(?buttonText) }\">
                        <div class=\"swa-header-label-container swa-float-right\" onclick=\"{= ui:functionCall(&quot;swa.switchMultiGadgetWindow&quot;, ?windowId, ?ci) }\" title=\"Switch to {= spl:objectInGraph(?child, arg:title, ui:graph) }\">{= ?buttonText }</div>
                    </ui:if>
                    <ui:else>
                        <div class=\"swa-multi-gadget-button {= spl:objectInGraph(?child, arg:iconClass, ui:graph) }\" onclick=\"{= ui:functionCall(&quot;swa.switchMultiGadgetWindow&quot;, ?windowId, ?ci) }\" title=\"Switch to {= spl:objectInGraph(?child, arg:title, ui:graph) }\"/>
                    </ui:else>
                </ui:forEach>
                <div class=\"swa-multi-gadget-arrow\"/>
                <div class=\"swa-clear-both\"/>
            </div>
            <ui:insertionPoint ui:pointId=\"1\"/>
        </div>
    </ui:group>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "A child in an swa:MultiGadgetWindow. Must define title and icon (which must be string constants, not derived values) so that they can be used for the switching icons. Instances of this class should onlye have a single child - an swa:Gadget." ;
  rdfs:label "Multi gadget child" ;
  rdfs:subClassOf swa:ApplicationElements ;
.
swa:MultiGadgetWindow
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:layoutPanel ;
      spl:valueType xsd:string ;
      rdfs:comment "The position within the surrounding BorderLayout: one of \"east\", \"north\", \"west\", \"south\" or \"center\"." ;
    ] ;
  ui:prototype """
<ui:group>
    <ui:insertionPoint ui:pointId=\"1\"/>
    <ui:insertionPoint ui:pointId=\"2\"/>
    <ui:insertionPoint ui:pointId=\"3\"/>
    <ui:insertionPoint ui:pointId=\"4\"/>
    <ui:insertionPoint ui:pointId=\"5\"/>
    <ui:insertionPoint ui:pointId=\"6\"/>
    <ui:insertionPoint ui:pointId=\"7\"/>
    <ui:insertionPoint ui:pointId=\"8\"/>
    <ui:insertionPoint ui:pointId=\"9\"/>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "A window containing multiple swa:MultiGadgetChild elements. Users can bring to the foreground one of them at a time, using icon buttons in the upper right corner. This element must only have swa:MultiGadgetChild elements as children. The arg:id must be present, and be a string constant." ;
  rdfs:label "Multi gadget window" ;
  rdfs:subClassOf swa:AbstractWindow ;
.
swa:MultiResourceEditDialog
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:loadId ;
      spl:valueType xsd:string ;
      rdfs:comment "The ui:loadId of the ui:loadable that will be placed around the dialog." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The default type of the resources, used to select a suitable form." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resourceURIs ;
      spl:valueType xsd:string ;
      rdfs:comment "A space-separated list of URIs of the resources to edit." ;
    ] ;
  ui:prototype """
<ui:group let:resource=\"{= &lt;urn:x-swa:MultiResource&gt; }\" let:sessionGraph=\"{= ui:createSessionGraph(ui:currentQueryGraph()) }\" letrs:rs='{#
        SELECT ?r
        WHERE {
            ?uri spif:split ( ?resourceURIs \" \" ) .
            BIND (ui:decodeNode(CONCAT(\"&lt;\", str(?uri), \"&gt;\")) AS ?r) .
        } }'>
    <ui:group let:first=\"{= spr:cell(?rs, 0, 0) }\">
        <ui:update ui:updateQuery=\"{!
                INSERT {
                    GRAPH ?sessionGraph {
                        ?resource ?p ?o .
                    } .
                }
                WHERE {
                    ?first ?p ?o .
                    FILTER NOT EXISTS {
                        ( ?rs 0 ) spr:colCells ?other .
                        FILTER ((?other != ?first) &amp;&amp; NOT EXISTS {
                            ?other ?p ?o .
                        }) .
                    } .
                } }\"/>
    </ui:group>
    <div id=\"div-{= ?loadId }\" let:oldQueryGraph=\"{= ui:currentQueryGraph() }\" title=\"Edit {= spr:rowCount(?rs) } instances of {= ui:label(?resourceType) }\">
        <ui:setContext let:fid=\"multiResourceEditForm\" ui:queryGraph=\"{= ui:graphWithImports(?sessionGraph) }\" ui:varName=\"mode\" ui:varValue=\"edit\">
            <form autocomplete=\"off\" class=\"swa-form\" id=\"{= ?fid }\">
                <input name=\"_base\" type=\"hidden\" value=\"{= ?oldQueryGraph }\"/>
                <input name=\"_resourceURIs\" type=\"hidden\" value=\"{= ?resourceURIs }\"/>
                <div class=\"swa-form-body\">
                    <ui:classView ui:class=\"{= COALESCE(?resourceType, spl:object(?resource, rdf:type)) }\" ui:matchIds=\"edit,form\" ui:resource=\"{= ?resource }\"/>
                </div>
            </form>
        </ui:setContext>
    </div>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "A dialog that makes it possible to edit properties of multiple resources at the same time. This is a modal dialog that uses a session graph to build up a temporary instance with the intersection of all values. Then an edit form is displayed for that instance. The session graph is discarded once the dialog is closed." ;
  rdfs:label "Multi resource edit dialog" ;
  rdfs:subClassOf swa:DialogElements ;
.
swa:NeighborGramClassPropertiesDataService
  a ui:JSONService ;
  ui:prototype """
<swon:Object letrs:incomingAxiomProperties=\"{#
        SELECT DISTINCT ?incomingProperty ?domain
        WHERE {
            {
                GRAPH ui:graph {
                    ?axiomProperty a swa:PropertyAxiomProperty .
                } .
                ?incomingProperty ?axiomProperty ?focusNode .
            }
            UNION
            {
                ?propertyShape sh:class|sh:node ?focusNode .
                FILTER (!dash:isDeactivated(?propertyShape)) .
                ?propertyShape sh:path ?incomingProperty .
            } .
            FILTER isIRI(?incomingProperty) .
            BIND (swa:localDomain(?focusNode, ?incomingProperty) AS ?domain) .
            FILTER (?domain != ?focusNode) .
        } }\" letrs:incomingProperties=\"{#
        SELECT DISTINCT ?incomingProperty
        WHERE {
            ?anySubject ?incomingProperty ?focusNode .
            FILTER (!swa:isPropertyAxiomProperty(?incomingProperty)) .
            FILTER (!isBlank(?anySubject)) .
            FILTER (?incomingProperty != rdf:type) .
            FILTER (?incomingProperty != sh:class) .
            FILTER (?incomingProperty != sh:node) .
        } }\" letrs:parentClasses=\"{#
        SELECT DISTINCT ?parentClass
        WHERE {
            ?focusNode rdfs:subClassOf ?parentClass .
            FILTER (!isBlank(?parentClass)) .
        } }\" letrs:properties=\"{#
        SELECT DISTINCT ?property
        WHERE {
            ?focusNode swa:relevantClassOfProperty ?property .
            BIND (swauml:valueType(?property, ?focusNode) AS ?range) .
            FILTER (!swa:isDatatypeRange(?range)) .
            FILTER swa:isNotHiddenProperty(?property) .
            FILTER (!isBlank(?property)) .
        } }\">
    <swon:Value arg:name=\"nodes\">
        <swon:Array>
            <swon:Object>
                <swon:Value arg:name=\"id\" arg:value=\"{= ?focusNode }\"/>
                <swon:Value arg:name=\"label\" arg:value=\"{= ui:label(?focusNode) }\"/>
                <swon:Value arg:name=\"size\" arg:value=\"40\"/>
            </swon:Object>
            <ui:if ui:condition=\"{= spr:rowCount(?parentClasses) &gt; 0 }\">
                <swon:Comma/>
                <ui:forEach ui:resultSet=\"{= ?parentClasses }\" ui:separator=\",\">
                    <swon:Object>
                        <swon:Value arg:name=\"id\" arg:value=\"{= ?parentClass }\"/>
                        <swon:Value arg:name=\"label\" arg:value=\"{= ui:label(?parentClass) }\"/>
                        <swon:Value arg:name=\"size\" arg:value=\"40\"/>
                    </swon:Object>
                </ui:forEach>
            </ui:if>
            <ui:if ui:condition=\"{= spr:rowCount(?properties) &gt; 0 }\">
                <swon:Comma/>
                <ui:forEach ui:resultSet=\"{= ?properties }\" ui:separator=\",\">
                    <swon:Object let:range=\"{= swauml:valueType(?property, ?focusNode) }\">
                        <ui:if ui:condition=\"{= bound(?range) &amp;&amp; (!isBlank(?range)) }\">
                            <swon:Value arg:name=\"id\" arg:value=\"{= ?range }\"/>
                            <swon:Value arg:name=\"label\" arg:value=\"{= ui:label(?range) }\"/>
                            <swon:Value arg:name=\"alternateId\" arg:value=\"{= ?range }\"/>
                        </ui:if>
                        <ui:else>
                            <swon:Value arg:name=\"id\" arg:value=\"{= rdfs:Resource }\"/>
                            <swon:Value arg:name=\"label\" arg:value=\"{= ui:label(rdfs:Resource) }\"/>
                            <swon:Value arg:name=\"alternateId\" arg:value=\"{= rdfs:Resource }\"/>
                        </ui:else>
                        <swon:Value arg:name=\"size\" arg:value=\"40\"/>
                    </swon:Object>
                </ui:forEach>
            </ui:if>
            <ui:if ui:condition=\"{= spr:rowCount(?incomingProperties) &gt; 0 }\">
                <swon:Comma/>
                <ui:forEach ui:resultSet=\"{= ?incomingProperties }\" ui:separator=\",\">
                    <ui:group letrs:subjects=\"{#
                            SELECT ?subject
                            WHERE {
                                ?subject ?incomingProperty ?focusNode .
                                FILTER (!isBlank(?subject)) .
                            } }\">
                        <ui:forEach ui:resultSet=\"{= ?subjects }\" ui:separator=\",\">
                            <swon:Object>
                                <swon:Value arg:name=\"id\" arg:value=\"{= ?subject }\"/>
                                <swon:Value arg:name=\"label\" arg:value=\"{= ui:label(?subject) }\"/>
                                <swon:Value arg:name=\"alternateId\" arg:value=\"{= ?subject }\"/>
                            </swon:Object>
                        </ui:forEach>
                    </ui:group>
                </ui:forEach>
            </ui:if>
            <ui:if ui:condition=\"{= spr:rowCount(?incomingAxiomProperties) &gt; 0 }\">
                <swon:Comma/>
                <ui:forEach ui:resultSet=\"{= ?incomingAxiomProperties }\" ui:separator=\",\">
                    <ui:if ui:condition=\"{= bound(?domain) &amp;&amp; (!isBlank(?domain)) }\">
                        <swon:Object>
                            <swon:Value arg:name=\"id\" arg:value=\"{= ?domain }\"/>
                            <swon:Value arg:name=\"label\" arg:value=\"{= ui:label(?domain) }\"/>
                            <swon:Value arg:name=\"alternateId\" arg:value=\"{= ?domain }\"/>
                        </swon:Object>
                    </ui:if>
                </ui:forEach>
            </ui:if>
        </swon:Array>
    </swon:Value>
    <swon:Value arg:name=\"edges\">
        <swon:Array>
            <ui:if ui:condition=\"{= spr:rowCount(?parentClasses) &gt; 0 }\">
                <ui:forEach ui:indexVar=\"rowIndex\" ui:resultSet=\"{= ?parentClasses }\" ui:separator=\",\">
                    <swon:Object>
                        <swon:Value arg:name=\"id\" arg:value=\"{= rdfs:subClassOf }\"/>
                        <swon:Value arg:name=\"label\" arg:value=\"{= ui:label(rdfs:subClassOf) }\"/>
                        <swon:Value arg:name=\"source\" arg:value=\"{= ?focusNode }\"/>
                        <swon:Value arg:name=\"target\" arg:value=\"{= ?parentClass }\"/>
                    </swon:Object>
                </ui:forEach>
            </ui:if>
            <ui:if ui:condition=\"{= spr:rowCount(?properties) &gt; 0 }\">
                <ui:if ui:condition=\"{= spr:rowCount(?parentClasses) &gt; 0 }\">
                    <swon:Comma/>
                </ui:if>
                <ui:forEach ui:resultSet=\"{= ?properties }\" ui:separator=\",\">
                    <swon:Object let:range=\"{= swauml:valueType(?property, ?focusNode) }\">
                        <swon:Value arg:name=\"id\" arg:value=\"{= ?property }\"/>
                        <swon:Value arg:name=\"label\" arg:value=\"{= swa:propertyLabelAtClassOrShape(?property, ?focusNode) }\"/>
                        <swon:Value arg:name=\"source\" arg:value=\"{= ?focusNode }\"/>
                        <ui:if ui:condition=\"{= bound(?range) &amp;&amp; (!isBlank(?range)) }\">
                            <swon:Value arg:name=\"target\" arg:value=\"{= ?range }\"/>
                        </ui:if>
                        <ui:else>
                            <swon:Value arg:name=\"target\" arg:value=\"{= rdfs:Resource }\"/>
                        </ui:else>
                    </swon:Object>
                </ui:forEach>
            </ui:if>
            <ui:if ui:condition=\"{= spr:rowCount(?incomingProperties) &gt; 0 }\">
                <ui:if ui:condition=\"{= (spr:rowCount(?parentClasses) &gt; 0) || (spr:rowCount(?properties) &gt; 0) }\">
                    <swon:Comma/>
                </ui:if>
                <ui:forEach ui:resultSet=\"{= ?incomingProperties }\" ui:separator=\",\">
                    <ui:group letrs:subjects=\"{#
                            SELECT ?subject
                            WHERE {
                                ?subject ?incomingProperty ?focusNode .
                                FILTER (!isBlank(?subject)) .
                            } }\">
                        <ui:forEach ui:resultSet=\"{= ?subjects }\" ui:separator=\",\">
                            <swon:Object>
                                <swon:Value arg:name=\"id\" arg:value=\"{= ?incomingProperty }\"/>
                                <swon:Value arg:name=\"label\" arg:value=\"{= ui:label(?incomingProperty) }\"/>
                                <swon:Value arg:name=\"source\" arg:value=\"{= ?subject }\"/>
                                <swon:Value arg:name=\"target\" arg:value=\"{= ?focusNode }\"/>
                            </swon:Object>
                        </ui:forEach>
                    </ui:group>
                </ui:forEach>
            </ui:if>
            <ui:if ui:condition=\"{= spr:rowCount(?incomingAxiomProperties) &gt; 0 }\">
                <ui:if ui:condition=\"{= ((spr:rowCount(?parentClasses) &gt; 0) || (spr:rowCount(?properties) &gt; 0)) || (spr:rowCount(?incomingProperties) &gt; 0) }\">
                    <swon:Comma/>
                </ui:if>
                <ui:forEach ui:resultSet=\"{= ?incomingAxiomProperties }\" ui:separator=\",\">
                    <ui:if ui:condition=\"{= bound(?domain) &amp;&amp; (!isBlank(?domain)) }\">
                        <swon:Object>
                            <swon:Value arg:name=\"id\" arg:value=\"{= ?incomingProperty }\"/>
                            <swon:Value arg:name=\"label\" arg:value=\"{= ui:label(?incomingProperty) }\"/>
                            <swon:Value arg:name=\"source\" arg:value=\"{= ?domain }\"/>
                            <swon:Value arg:name=\"target\" arg:value=\"{= ?focusNode }\"/>
                        </swon:Object>
                    </ui:if>
                </ui:forEach>
            </ui:if>
        </swon:Array>
    </swon:Value>
</swon:Object>
"""^^ui:Literal ;
  rdfs:subClassOf swa:NeighborGramPropertiesDataService ;
.
swa:NeighborGramInstanceObjectPropertiesDataService
  a ui:JSONService ;
  ui:prototype """
<swon:Object letrs:incomingProperties=\"{#
        SELECT DISTINCT ?incomingProperty ?propertyPlacementConstraint
        WHERE {
            ?anySubject ?incomingProperty ?focusNode .
            FILTER (?incomingProperty != rdf:type) .
            FILTER (!isBlank(?anySubject)) .
            OPTIONAL {
                ?propertyConstraint sh:path ?incomingProperty .
                ?anySubject a ?myType .
                ?someClass sh:property ?propertyConstraint .
                ?myType (rdfs:subClassOf)* ?someClass .
                ?propertyConstraint edg:propertyPlacementConstraint ?propertyPlacementConstraint .
            } .
        } }\" letrs:properties=\"{#
        SELECT DISTINCT ?property ?propertyPlacementConstraint
        WHERE {
            ?focusNode ?property ?anyObject .
            BIND (swa:localRange(?property, ?focusNode) AS ?range) .
            FILTER ((!swa:isDatatypeRange(?range)) &amp;&amp; (?property != rdf:type)) .
            FILTER (!isBlank(?anyObject)) .
            FILTER (!isLiteral(?anyObject)) .
            OPTIONAL {
                ?propertyConstraint sh:path ?property .
                ?focusNode a ?myType .
                ?someClass sh:property ?propertyConstraint .
                ?myType (rdfs:subClassOf)* ?someClass .
                ?propertyConstraint edg:propertyPlacementConstraint ?propertyPlacementConstraint .
            } .
        } }\" letrs:types=\"{#
        SELECT DISTINCT ?type
        WHERE {
            ?focusNode a ?type .
        } }\">
    <swon:Value arg:name=\"nodes\">
        <swon:Array>
            <swon:Object>
                <swon:Value arg:name=\"id\" arg:value=\"{= ?focusNode }\"/>
                <swon:Value arg:name=\"label\" arg:value=\"{= ui:label(?focusNode) }\"/>
                <swon:Value arg:name=\"size\" arg:value=\"40\"/>
            </swon:Object>
            <ui:if ui:condition=\"{= spr:rowCount(?types) &gt; 0 }\">
                <swon:Comma/>
                <ui:forEach ui:resultSet=\"{= ?types }\" ui:separator=\",\">
                    <swon:Object>
                        <swon:Value arg:name=\"id\" arg:value=\"{= ?type }\"/>
                        <swon:Value arg:name=\"label\" arg:value=\"{= ui:label(?type) }\"/>
                        <swon:Value arg:name=\"size\" arg:value=\"40\"/>
                        <swon:Value arg:name=\"type\" arg:value=\"Class\"/>
                    </swon:Object>
                </ui:forEach>
            </ui:if>
            <ui:if ui:condition=\"{= spr:rowCount(?properties) &gt; 0 }\">
                <swon:Comma/>
                <ui:forEach ui:resultSet=\"{= ?properties }\" ui:separator=\",\">
                    <ui:group letrs:objects=\"{#
                            SELECT ?object
                            WHERE {
                                ?focusNode ?property ?object .
                                FILTER (!isBlank(?object)) .
                            } }\">
                        <ui:forEach ui:resultSet=\"{= ?objects }\" ui:separator=\",\">
                            <swon:Object>
                                <swon:Value arg:name=\"id\" arg:value=\"{= ?object }\"/>
                                <swon:Value arg:name=\"label\" arg:value=\"{= ui:label(?object) }\"/>
                                <swon:Value arg:name=\"size\" arg:value=\"40\"/>
                                <swon:Value arg:name=\"alternateId\" arg:value=\"{= ?object }\"/>
                            </swon:Object>
                        </ui:forEach>
                    </ui:group>
                </ui:forEach>
            </ui:if>
            <ui:if ui:condition=\"{= spr:rowCount(?incomingProperties) &gt; 0 }\">
                <swon:Comma/>
                <ui:forEach ui:resultSet=\"{= ?incomingProperties }\" ui:separator=\",\">
                    <ui:group letrs:subjects=\"{#
                            SELECT ?subject
                            WHERE {
                                ?subject ?incomingProperty ?focusNode .
                                FILTER (!isBlank(?subject)) .
                            } }\">
                        <ui:forEach ui:resultSet=\"{= ?subjects }\" ui:separator=\",\">
                            <swon:Object>
                                <swon:Value arg:name=\"id\" arg:value=\"{= ?subject }\"/>
                                <swon:Value arg:name=\"label\" arg:value=\"{= ui:label(?subject) }\"/>
                                <swon:Value arg:name=\"size\" arg:value=\"40\"/>
                                <swon:Value arg:name=\"alternateId\" arg:value=\"{= ?subject }\"/>
                            </swon:Object>
                        </ui:forEach>
                    </ui:group>
                </ui:forEach>
            </ui:if>
        </swon:Array>
    </swon:Value>
    <swon:Value arg:name=\"edges\">
        <swon:Array>
            <ui:if ui:condition=\"{= spr:rowCount(?types) &gt; 0 }\">
                <ui:forEach ui:indexVar=\"rowIndex\" ui:resultSet=\"{= ?types }\" ui:separator=\",\">
                    <swon:Object>
                        <swon:Value arg:name=\"id\" arg:value=\"{= rdf:type }\"/>
                        <swon:Value arg:name=\"label\" arg:value=\"type\"/>
                        <swon:Value arg:name=\"source\" arg:value=\"{= ?focusNode }\"/>
                        <swon:Value arg:name=\"target\" arg:value=\"{= ?type }\"/>
                    </swon:Object>
                </ui:forEach>
            </ui:if>
            <ui:if ui:condition=\"{= spr:rowCount(?properties) &gt; 0 }\">
                <ui:if ui:condition=\"{= spr:rowCount(?types) &gt; 0 }\">
                    <swon:Comma/>
                </ui:if>
                <ui:forEach ui:resultSet=\"{= ?properties }\" ui:separator=\",\">
                    <ui:group letrs:objects=\"{#
                            SELECT ?object
                            WHERE {
                                ?focusNode ?property ?object .
                                FILTER (!isBlank(?object)) .
                            } }\">
                        <ui:forEach ui:indexVar=\"rowIndex\" ui:resultSet=\"{= ?objects }\" ui:separator=\",\">
                            <swon:Object>
                                <swon:Value arg:name=\"id\" arg:value=\"{= ?property }\"/>
                                <swon:Value arg:name=\"label\" arg:value=\"{= ui:label(?property) }\"/>
                                <swon:Value arg:name=\"source\" arg:value=\"{= ?focusNode }\"/>
                                <swon:Value arg:name=\"target\" arg:value=\"{= ?object }\"/>
                                <ui:if ui:condition=\"{= bound(?propertyPlacementConstraint) }\">
                                    <swon:Value arg:name=\"placement\" arg:value=\"{= ?propertyPlacementConstraint }\"/>
                                </ui:if>
                            </swon:Object>
                        </ui:forEach>
                    </ui:group>
                </ui:forEach>
            </ui:if>
            <ui:if ui:condition=\"{= spr:rowCount(?incomingProperties) &gt; 0 }\">
                <ui:if ui:condition=\"{= (spr:rowCount(?types) &gt; 0) || (spr:rowCount(?properties) &gt; 0) }\">
                    <swon:Comma/>
                </ui:if>
                <ui:forEach ui:resultSet=\"{= ?incomingProperties }\" ui:separator=\",\">
                    <ui:group letrs:subjects=\"{#
                            SELECT ?subject
                            WHERE {
                                ?subject ?incomingProperty ?focusNode .
                                FILTER (!isBlank(?subject)) .
                            } }\">
                        <ui:forEach ui:indexVar=\"rowIndex\" ui:resultSet=\"{= ?subjects }\" ui:separator=\",\">
                            <swon:Object>
                                <swon:Value arg:name=\"id\" arg:value=\"{= ?incomingProperty }\"/>
                                <swon:Value arg:name=\"label\" arg:value=\"{= ui:label(?incomingProperty) }\"/>
                                <swon:Value arg:name=\"source\" arg:value=\"{= ?subject }\"/>
                                <swon:Value arg:name=\"target\" arg:value=\"{= ?focusNode }\"/>
                                <ui:if ui:condition=\"{= bound(?propertyPlacementConstraint) }\">
                                    <swon:Value arg:name=\"placement\" arg:value=\"{= ?propertyPlacementConstraint }\"/>
                                </ui:if>
                            </swon:Object>
                        </ui:forEach>
                    </ui:group>
                </ui:forEach>
            </ui:if>
        </swon:Array>
    </swon:Value>
</swon:Object>
"""^^ui:Literal ;
  rdfs:subClassOf swa:NeighborGramPropertiesDataService ;
.
swa:NeighborGramPane
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:sessionGraph ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "A graph for session information" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:focusNode ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The focus node of the diagram" ;
    ] ;
  ui:headIncludes """
<ui:group>
    <meta content=\"IE=Edge,chrome=1\" http-equiv=\"X-UA-Compatible\"/>
    <meta charset=\"utf-8\"/>
    <link href=\"{= ui:lib() }/assets/lib/visualizations-library/css/main.css\" rel=\"stylesheet\" type=\"text/css\"/>
    <link href=\"{= ui:lib() }/assets/lib/neighborgram/css/main.css\" rel=\"stylesheet\" type=\"text/css\"/>
    <script src=\"{= ui:lib() }/assets/build/lib/gram-common/vendors.bundle.js\"/>
    <script src=\"{= ui:lib() }/assets/lib/neighborgram/js/main.min.js\"/>
</ui:group>
"""^^ui:Literal ;
  ui:prototype """
<ui:group>
    <div id=\"tqLgDefaultUI\"/>
    <div class=\"tq-ng_column_graph-row__graph\" id=\"graphPlace\"/>
    <script>swa.neighborgram = {focusNodeUri: \"{= ?focusNode }\", resourcePath: \"{= ui:lib() }/assets/build/lib/neighborgram\", base: \"{= ui:graphWithImports(ui:currentQueryGraph()) }\"}</script>
</ui:group>
"""^^ui:Literal ;
  ui:responseType ui:HTML ;
  rdfs:subClassOf swa:ScriptElements ;
.
swa:NeighborGramPropertiesDataService
  a ui:JSONService ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:focusNode ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The focus node of the diagram" ;
    ] ;
  ui:prototype """
<ui:group>
    <ui:if ui:condition=\"{= spl:instanceOf(?focusNode, rdfs:Class) }\">
        <swa:NeighborGramClassPropertiesDataService arg:focusNode=\"{= ?focusNode }\"/>
    </ui:if>
    <ui:else>
        <swa:NeighborGramInstanceObjectPropertiesDataService arg:focusNode=\"{= ?focusNode }\"/>
    </ui:else>
</ui:group>
"""^^ui:Literal ;
  rdfs:subClassOf ui:JSONServices ;
.
swa:NestedObjectEditor
  a swa:ObjectEditorClass ;
  swa:objectWidgetWeight [
      a swa:WeightedExpression ;
      swa:expression [
          a swa:isBlankNodeProperty ;
          arg:property [
              sp:varName "predicate" ;
            ] ;
        ] ;
      swa:weight 1 ;
    ] ;
  ui:prototype """
<ui:group>
    <ui:if ui:condition=\"{= bound(?object) }\">
        <div class=\"swa-nested-form swa-nested-object-editor\">
            <input name=\"new-{= ?uid }\" type=\"hidden\" value=\"{= ui:encodeNode(?object, true, true) }\"/>
            <ui:resourceView ui:matchIds=\"nested,edit,form\" ui:resource=\"{= ?object }\"/>
        </div>
    </ui:if>
    <ui:else>
        <ui:group let:object=\"{= IRI(CONCAT(&quot;urn:x-new-bnode:&quot;, ui:uniqueId())) }\" let:range=\"{= swa:localRange(?predicate, ?subject) }\">
            <input name=\"new-{= ?uid }\" type=\"hidden\" value=\"{= ui:encodeNode(?object, true, true) }\"/>
            <ui:group let:id=\"{= ui:uniqueId() }\">
                <input name=\"resource-{= ?id }\" type=\"hidden\" value=\"{= ui:encodeNode(?object, true, true) }\"/>
                <input name=\"path-{= ?id }\" type=\"hidden\" value=\"{= ui:encodeNode(rdf:type) }\"/>
                <input name=\"new-{= ?id }\" type=\"hidden\" value=\"{= ui:encodeNode(?range, true, true) }\"/>
            </ui:group>
            <div class=\"swa-nested-form swa-nested-object-editor\">
                <ui:setContext ui:varName=\"mode\" ui:varValue=\"edit\">
                    <ui:setContext ui:varName=\"resourceType\" ui:varValue=\"{= ?range }\">
                        <ui:classView arg:subject=\"{= ?object }\" ui:class=\"{= ?range }\" ui:matchIds=\"nested,edit,form\" ui:resource=\"{= ?object }\"/>
                    </ui:setContext>
                </ui:setContext>
            </div>
        </ui:group>
    </ui:else>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "A nested form, suitable for editing \"depending\" blank nodes. This is the default editor for properties that are marked with swa:blankNodeProperty=true in the ui:graph." ;
  rdfs:label "Nested object editor" ;
  rdfs:subClassOf swa:ObjectEditor ;
.
swa:NestedObjectFacet
  a swa:ObjectFacetClass ;
  swa:facetSearchType search:NestedFacetValue ;
  swa:objectFacetMenuName "nested form" ;
  swa:objectWidgetWeight [
      a swa:WeightedExpression ;
      swa:expression [
          a sp:not ;
          sp:arg1 [
              a swa:isDatatypeRange ;
              arg:range [
                  sp:varName "range" ;
                ] ;
            ] ;
        ] ;
      swa:weight -1 ;
    ] ;
  swa:objectWidgetWeight [
      a swa:WeightedExpression ;
      swa:expression [
          a swa:isBlankNodeProperty ;
          arg:property [
              sp:varName "predicate" ;
            ] ;
        ] ;
      swa:weight 1 ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:group let:restore=\"{= swa:restoreFacetValue(?predicate) }\">
    <ui:group let:subjectVarName=\"{= IF(bound(?restore), spl:object(?restore, search:nestedSubjectVarName), ui:uniqueId()) }\">
        <div class=\"swa-nested-form\" let:range=\"{= swa:localRangeAtClass(swa:resourceType(), ?predicate) }\" let:restore=\"{= swa:restoreFacetValue(?predicate) }\" name=\"{= ?subjectVarName }\">
            <input name=\"nested{= ?uid }\" type=\"hidden\" value=\"{= ?subjectVarName }\"/>
            <ui:setContext ui:varName=\"subjectVarName\" ui:varValue=\"{= ?subjectVarName }\">
                <ui:setContext ui:varName=\"resourceType\" ui:varValue=\"{= ?range }\">
                    <ui:setContext ui:varName=\"isNested\" ui:varValue=\"{= true }\">
                        <ui:classView ui:class=\"{= ?range }\" ui:matchIds=\"nested,search,form\"/>
                    </ui:setContext>
                </ui:setContext>
            </ui:setContext>
            <script>$(\"#facetSelector-{= ?uid }\").addClass('swa-nested-form-facet-selector')</script>
        </div>
    </ui:group>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "Represents a nested form that points to a depending object resource. This widget is used by default if the property is marked to be swa:blankNodeProperty true in the UI graph. For other (non-datatype) properties it can be selected manually." ;
  rdfs:label "Nested object facet" ;
  rdfs:subClassOf swa:ObjectFacet ;
.
swa:NestedObjectViewer
  a swa:ObjectViewerClass ;
  swa:objectWidgetWeight [
      a swa:WeightedExpression ;
      swa:expression [
          a sp:and ;
          sp:arg1 [
              a sp:eq ;
              sp:arg1 [
                  sp:varName "kind" ;
                ] ;
              sp:arg2 "blank" ;
            ] ;
          sp:arg2 [
              a swa:isBlankNodeProperty ;
              arg:property [
                  sp:varName "predicate" ;
                ] ;
            ] ;
        ] ;
      swa:weight 20 ;
    ] ;
  ui:prototype """
<ui:group>
    <ui:if ui:condition=\"{= isBlank(?object) }\">
        <ui:loadable blanknodeid=\"{= ui:encodeNode(?object, true) }\" class=\"swa-nested-form swa-nested-object-viewer\" ui:loadId=\"{= ui:uniqueId() }\">
            <ui:resourceView ui:matchIds=\"nested,view,form\" ui:resource=\"{= ?object }\"/>
        </ui:loadable>
    </ui:if>
    <ui:else>
        <div class=\"swa-nested-form swa-nested-object-viewer\">
            <ui:resourceView ui:matchIds=\"nested,view,form\" ui:resource=\"{= ?object }\"/>
        </div>
    </ui:else>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "Displays an expanded view of an object as a \"nested form\". Currently only really suitable for blank nodes, e.g. schema:PostalAddress dangling off a schema:Person.  This is the default viewer for properties that are marked with swa:blankNodeProperty=true in the ui:graph." ;
  rdfs:label "Nested object viewer" ;
  rdfs:subClassOf swa:ObjectViewer ;
.
swa:NestedSubjectFacet
  a swa:SubjectFacetClass ;
  swa:facetSearchType search:NestedFacetValue ;
  swa:subjectFacetMenuName "nested form" ;
  swa:subjectWidgetWeight [
      a swa:WeightedExpression ;
      swa:expression [
          a swa:hasMatchingInverseRestoreFacetValue ;
          arg:facetClass swa:NestedSubjectFacet ;
          arg:property [
              sp:varName "predicate" ;
            ] ;
        ] ;
      swa:weight -1 ;
    ] ;
  ui:private true ;
  ui:prototype """
<div class=\"swa-nested-form\" let:domain=\"{= swa:localDomain(?none, ?predicate) }\" let:restore=\"{= swa:restoreInverseFacetValue(?predicate) }\">
    <ui:group let:subjectVarName=\"{= IF(bound(?restore), spl:object(?restore, search:nestedSubjectVarName), ui:uniqueId()) }\">
        <input name=\"nested{= ?uid }\" type=\"hidden\" value=\"{= ?subjectVarName }\"/>
        <ui:setContext ui:varName=\"subjectVarName\" ui:varValue=\"{= ?subjectVarName }\">
            <ui:setContext ui:varName=\"resourceType\" ui:varValue=\"{= ?domain }\">
                <ui:setContext ui:varName=\"suppressKeyPropertiesSelection\" ui:varValue=\"{= true }\">
                    <ui:setContext ui:varName=\"isNested\" ui:varValue=\"{= true }\">
                        <ui:classView ui:class=\"{= ?domain }\" ui:matchIds=\"search,form\"/>
                    </ui:setContext>
                </ui:setContext>
            </ui:setContext>
        </ui:setContext>
    </ui:group>
</div>
"""^^ui:Literal ;
  rdfs:comment "Represents a nested form that points to a depending subject resource." ;
  rdfs:label "Nested subject facet" ;
  rdfs:subClassOf swa:SubjectFacet ;
.
swa:NoneGenericTreePropertySelectionTemplate
  a spin:SelectTemplate ;
  spin:body [
      a sp:Select ;
      sp:where (
          [
            a sp:Filter ;
            sp:expression false ;
          ]
        ) ;
    ] ;
  rdfs:comment "A selection template that produces no matches, effectively disabling the selection drop down." ;
  rdfs:label "None generic tree property selection template" ;
  rdfs:subClassOf swa:GenericTreePropertySelectionTemplates ;
.
swa:NoneObjectFacet
  a swa:ObjectFacetClass ;
  swa:facetSearchType search:NoneFacetValue ;
  swa:objectFacetMenuName "no value" ;
  swa:objectWidgetWeight [
      a swa:WeightedExpression ;
      swa:expression true ;
      swa:weight -6 ;
    ] ;
  ui:prototype """
<div class=\"swa-facet-constant\">
    <input id=\"none{= ?uid }\" name=\"none{= ?uid }\" type=\"hidden\" value=\"true\"/>
    <span>no value</span>
</div>
"""^^ui:Literal ;
  rdfs:comment "A facet representing the existence of no value for the given predicate." ;
  rdfs:label "None object facet" ;
  rdfs:subClassOf swa:ObjectFacet ;
.
swa:Note
  a ui:NodeClass ;
  ui:prototype """
<div class=\"admon\">
    <img align=\"left\" alt=\"Note Icon\" hspace=\"30px\" src=\"{= ui:lib() }/assets/images/icon-note.jpg\" vspace=\"0px\" width=\"60px\"/>
    <p>
        <ui:insertionPoint ui:pointId=\"body\"/>
    </p>
</div>
"""^^ui:Literal ;
  rdfs:label "Note" ;
  rdfs:subClassOf swa:DocumentElements ;
.
swa:NumericRangeFacet
  a swa:ObjectFacetClass ;
  swa:facetSearchType search:RangeFacetValue ;
  swa:objectFacetMenuName "min/max range" ;
  swa:objectWidgetWeight [
      a swa:WeightedExpression ;
      swa:expression [
          a sp:and ;
          sp:arg1 [
              a sp:bound ;
              sp:arg1 [
                  sp:varName "range" ;
                ] ;
            ] ;
          sp:arg2 [
              a swa:isNumericDatatype ;
              arg:node [
                  sp:varName "range" ;
                ] ;
            ] ;
        ] ;
      swa:weight 5 ;
    ] ;
  ui:private true ;
  ui:prototype """
<div class=\"nowrap\" let:restore=\"{= swa:restoreFacetValue(?predicate) }\">
    <input class=\"form-control {= swa:testClass(?predicate) }-min\" name=\"min{= ?uid }\" size=\"6\" type=\"text\" value=\"{= IF(bound(?restore), spl:object(?restore, search:min), ?none) }\"/>
    <span> - </span>
    <input class=\"form-control {= swa:testClass(?predicate) }-max\" name=\"max{= ?uid }\" size=\"6\" type=\"text\" value=\"{= IF(bound(?restore), spl:object(?restore, search:max), ?none) }\"/>
</div>
"""^^ui:Literal ;
  rdfs:comment "A facet with two input fields for min and max value of a numeric range." ;
  rdfs:label "Numeric range facet" ;
  rdfs:subClassOf swa:ObjectFacet ;
.
swa:Object
  a ui:NodeClass ;
  ui:prototype """
<swa:LabeledObjects arg:single=\"{= true }\" ui:args=\"*\"/>
"""^^ui:Literal ;
  rdfs:comment "Inserts a widget for a single value of a given predicate at the given subject. This element should only be used if the property doesn't have a max cardinality of 1 anyway, to overload the default behavior." ;
  rdfs:label "Object" ;
  rdfs:subClassOf swa:AbstractObject ;
.
swa:ObjectEditor
  a swa:ObjectEditorClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:inlineEditCancelCallback ;
      spl:valueType xsd:string ;
      rdfs:comment "A JavaScript function to call when Cancelling the inline editor" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:inlineEditSaveCallback ;
      spl:valueType xsd:string ;
      rdfs:comment "A JavaScript function to call when saving from the inline editor" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:range ;
      spl:valueType rdfs:Class ;
      rdfs:comment "An optional range." ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:group let:class=\"{= COALESCE(ui:contextValue(&quot;editWidget&quot;), swa:propertyEditWidget(?subject, ?predicate), swa:bestObjectEditorClass(?object, ?predicate, ?subject, ?range)) }\">
    <ui:if ui:condition=\"{= bound(?class) }\">
        <ui:dynamicView arg:object=\"{= ?object }\" arg:predicate=\"{= ?predicate }\" arg:range=\"{= ?range }\" arg:subject=\"{= ?subject }\" arg:uid=\"{= ?uid }\" ui:class=\"{= ?class }\"/>
    </ui:if>
    <ui:else>
        <b>ERROR: No ObjectEditor found for {= ui:label(?predicate) } at {= ui:label(swa:resourceType(?subject)) } and range {= swa:localRange(?predicate, ?subject) }</b>
    </ui:else>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "Inserts an editor for a given object, with different behavior depending on the type of object or the context." ;
  rdfs:label "Object editor" ;
  rdfs:subClassOf swa:ObjectWidget ;
.
swa:ObjectEditorClass
  a rdfs:Class ;
  rdfs:comment "Metaclass of the various types of object editors." ;
  rdfs:label "Object editor class" ;
  rdfs:subClassOf swa:ObjectWidgetClass ;
.
swa:ObjectEditorHiddenDatatypeField
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:datatype ;
      spl:valueType rdfs:Datatype ;
      rdfs:comment "The datatype to send to the server for new values of this widget." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:uid ;
      spl:valueType xsd:string ;
      rdfs:comment "The uid identifying the associated editor." ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:if ui:condition=\"{= bound(?datatype) }\">
    <input name=\"datatype-{= ?uid }\" type=\"hidden\" value=\"{= ui:encodeNode(?datatype, true, true) }\"/>
</ui:if>
"""^^ui:Literal ;
  rdfs:comment "A hidden field used to send a datatype to the SWP edit servlet." ;
  rdfs:label "Object editor hidden datatype field" ;
  rdfs:subClassOf swa:FormElements ;
.
swa:ObjectEditorHiddenFields
  a swa:ObjectWidgetClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:groupId ;
      spl:valueType xsd:string ;
      rdfs:comment "The id of a group that can be used to activate/deactivate using swa.(de)activateHiddenFields." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:keepBNodes ;
      spl:valueType xsd:boolean ;
      rdfs:comment "Set to true if this is part of a blank node structure (in particular rdf:Lists) where deleting a node does not imply deleting any depending objects." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:newObject ;
      rdfs:comment "A new object to generate." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:object ;
      rdfs:comment "The object node." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:uid ;
      spl:valueType xsd:string ;
      rdfs:comment "The unique id of this group." ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:group let:group=\"{= IF(bound(?groupId), CONCAT(&quot;swa-group-&quot;, ?groupId), ?none) }\">
    <input class=\"swa-editor-hidden-field {= ?group }\" name=\"resource-{= ?uid }\" type=\"hidden\" value=\"{= ui:encodeNode(COALESCE(?subject, &lt;urn:x-app-edit:root&gt;), true, true) }\"/>
    <input class=\"swa-editor-hidden-field {= ?group }\" name=\"path-{= ?uid }\" type=\"hidden\" value=\"&lt;{= ?predicate }&gt;\"/>
    <ui:if ui:condition=\"{= bound(?object) }\">
        <input class=\"swa-editor-hidden-field {= ?group }\" name=\"old-{= ?uid }\" type=\"hidden\" value=\"{= ui:encodeNode(?object, true, true) }\"/>
    </ui:if>
    <ui:if ui:condition=\"{= bound(?keepBNodes) }\">
        <input class=\"swa-editor-hidden-field {= ?group }\" name=\"keepBNodes-{= ?uid }\" type=\"hidden\" value=\"true\"/>
    </ui:if>
    <ui:if ui:condition=\"{= bound(?newObject) }\">
        <input class=\"swa-editor-hidden-field {= ?group }\" name=\"new-{= ?uid }\" type=\"hidden\" value=\"{= ui:encodeNode(?newObject, true, true) }\"/>
    </ui:if>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "Inserts the hidden fields needed to link the server with a widget. Note that the fields have a marker class swa-editor-hidden-field that is used by delete row operations." ;
  rdfs:label "Object editor hidden fields" ;
  rdfs:subClassOf swa:ObjectElements ;
.
swa:ObjectEditorRow
  a swa:ObjectWidgetRowClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:editWidget ;
      spl:valueType swa:ObjectEditor ;
      rdfs:comment "An optional edit widget that shall be preferred." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:range ;
      spl:valueType rdfs:Class ;
      rdfs:comment "An optional range such as xsd:string to select a \"preferred\" widget and create a value with that type/datatype." ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:group let:uid=\"{= ui:uniqueId() }\">
    <ui:if ui:condition=\"{= ((bound(?subject) &amp;&amp; bound(?object)) &amp;&amp; bound(?predicate)) &amp;&amp; (swa:isReadOnlyTriple(?subject, ?predicate, ?object) || swa:isPrimaryKeyProperty(?predicate, ?subject)) }\">
        <ui:setContext ui:varName=\"mode\" ui:varValue=\"view\">
            <div class=\"swa-object-row-read-only\">
                <swa:ObjectViewer ui:args=\"*\"/>
            </div>
        </ui:setContext>
    </ui:if>
    <ui:else>
        <table class=\"swa-object-editor-row-table\" id=\"{= ?uid }\">
            <tr>
                <td class=\"swa-object-row-main-td\">
                    <ui:loadable class=\"nowrap\" ui:loadId=\"swa-object-row-{= ?uid }\">
                        <swa:ObjectEditorHiddenFields ui:args=\"*\"/>
                        <ui:setContext ui:varName=\"{= IF(bound(?editWidgetOverride), &quot;editWidget&quot;, ?none) }\" ui:varValue=\"{= ?editWidgetOverride }\">
                            <swa:ObjectEditor ui:args=\"*\"/>
                        </ui:setContext>
                    </ui:loadable>
                </td>
                <td class=\"swa-object-row-button-td\">
                    <a class=\"swa-delete-row-button swa-icon ui-icon ui-icon-closethick\" href=\"javascript:void(0)\" onclick=\"swa.deleteRow(&quot;{= ?uid }&quot;)\"/>
                </td>
            </tr>
        </table>
    </ui:else>
</ui:group>
"""^^ui:Literal ;
  ui:responseType ui:HTML ;
  rdfs:label "Object editor row" ;
  rdfs:subClassOf swa:ObjectWidgetRow ;
.
swa:ObjectElements
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:elementId ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional HTML ID for the element containing this object." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:subject ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject resource of the form or widget. May be left empty in which case the subjectType will be used." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate." ;
    ] ;
  ui:abstract true ;
  ui:private true ;
  rdfs:comment "Abstract superclass for all elements that take a subject/predicate combination and then display or edit the objects." ;
  rdfs:label "Object elements" ;
  rdfs:subClassOf swa:FormElements ;
.
swa:ObjectFacet
  a swa:ObjectFacetClass ;
  ui:private true ;
  ui:prototype """
<ui:group let:class=\"{= COALESCE(ui:contextValue(&quot;searchWidget&quot;), swa:propertyShapePropertyAtClass(?predicate, tosh:searchWidget, swa:resourceType()), swa:bestObjectFacetClass(?predicate)) }\">
    <ui:if ui:condition=\"{= bound(?class) }\">
        <ui:dynamicView arg:predicate=\"{= ?predicate }\" arg:uid=\"{= ?uid }\" ui:class=\"{= ?class }\"/>
        <ui:group let:restoreSearch=\"{= swa:restoreSearch() }\">
            <ui:if ui:condition=\"{= bound(?restoreSearch) }\">
                <ui:update ui:updateQuery=\"{!
                        INSERT {
                            GRAPH ui:tempGraph {
                                ?restoreSearch swa:used ?predicate .
                            } .
                        }
                        WHERE {
                        } }\"/>
            </ui:if>
        </ui:group>
    </ui:if>
    <ui:else>
        <b>ERROR: No ObjectFacet found for {= ui:label(?predicate) } at {= ui:label(swa:resourceType()) } and range {= ui:label(swa:localRangeAtClass(swa:resourceType(), ?predicate)) }</b>
    </ui:else>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment """An object widget representing a facet on a search form.

ObjectFacets should support restoring their state from a \"saved search\" (instance of search:Search). See the existing widgets for example source code.""" ;
  rdfs:label "Object facet" ;
  rdfs:subClassOf swa:ObjectWidget ;
.
swa:ObjectFacetClass
  a rdfs:Class ;
  rdfs:comment "The metaclass of object facets." ;
  rdfs:label "Object facet class" ;
  rdfs:subClassOf swa:ObjectWidgetClass ;
.
swa:ObjectFacetRow
  a swa:ObjectWidgetRowClass ;
  ui:private true ;
  ui:prototype """
<ui:group let:uid=\"{= ui:uniqueId() }\">
    <table>
        <tr>
            <td class=\"swa-widget-span\" id=\"{= ?uid }\">
                <ui:loadable ui:loadId=\"{= ?uid }-loadable\">
                    <input name=\"facet{= ?uid }\" type=\"hidden\" value=\"{= ui:encodeNode(?predicate, true, true) }\"/>
                    <ui:group let:subjectVarName=\"{= ui:contextValue(&quot;subjectVarName&quot;) }\">
                        <ui:if ui:condition=\"{= bound(?subjectVarName) }\">
                            <input name=\"subject{= ?uid }\" type=\"hidden\" value=\"{= ?subjectVarName }\"/>
                        </ui:if>
                    </ui:group>
                    <ui:if ui:condition=\"{= bound(?selectedWidget) }\">
                        <ui:dynamicView arg:predicate=\"{= ?predicate }\" arg:uid=\"{= ?uid }\" ui:class=\"{= ?selectedWidget }\"/>
                    </ui:if>
                    <ui:else>
                        <swa:ObjectFacet arg:predicate=\"{= ?predicate }\" arg:uid=\"{= ?uid }\"/>
                    </ui:else>
                </ui:loadable>
            </td>
            <td class=\"swa-align-top\" let:buttonId=\"facetSelector-{= ?uid }\">
                <div class=\"swa-facet-selector\" id=\"{= ?buttonId }\" onclick=\"{= ui:functionCall(&quot;swa.openFacetSelectionMenu&quot;, ?buttonId, ?uid, swa:resourceType(), ?predicate, false, COALESCE(ui:contextValue(&quot;swaObjectFacetWidgetsFilterFunction&quot;), &quot;&quot;)) }\" title=\"Alternative filters\"/>
            </td>
        </tr>
    </table>
</ui:group>
"""^^ui:Literal ;
  rdfs:label "Object facet row" ;
  rdfs:subClassOf swa:ObjectWidgetRow ;
.
swa:ObjectFacetWidgets
  a spin:SelectTemplate ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "actionName" ;
          ]
          [
            sp:varName "actionLocalName" ;
          ]
          [
            sp:varName "onSelect" ;
          ]
          [
            sp:varName "enabled" ;
          ]
          [
            sp:varName "group" ;
          ]
          [
            sp:varName "label" ;
          ]
          [
            sp:varName "iconClass" ;
          ]
        ) ;
      sp:where (
          [
            a sp:NamedGraph ;
            sp:elements (
                [
                  a sp:SubQuery ;
                  sp:query [
                      a sp:Select ;
                      sp:distinct true ;
                      sp:orderBy (
                          [
                            a sp:Desc ;
                            sp:expression [
                                sp:varName "weight" ;
                              ] ;
                          ]
                        ) ;
                      sp:where (
                          [
                            sp:object [
                                sp:varName "label" ;
                              ] ;
                            sp:predicate swa:objectFacetMenuName ;
                            sp:subject [
                                sp:varName "widgetClass" ;
                              ] ;
                          ]
                          [
                            sp:object [
                                sp:varName "w" ;
                              ] ;
                            sp:predicate swa:objectWidgetWeight ;
                            sp:subject [
                                sp:varName "widgetClass" ;
                              ] ;
                          ]
                          [
                            sp:object [
                                sp:varName "expression" ;
                              ] ;
                            sp:predicate swa:expression ;
                            sp:subject [
                                sp:varName "w" ;
                              ] ;
                          ]
                          [
                            a sp:Bind ;
                            sp:expression [
                                a sp:coalesce ;
                                sp:arg1 [
                                    a spl:object ;
                                    sp:arg1 [
                                        sp:varName "w" ;
                                      ] ;
                                    sp:arg2 swa:weight ;
                                  ] ;
                                sp:arg2 0 ;
                              ] ;
                            sp:variable [
                                sp:varName "weight" ;
                              ] ;
                          ]
                        ) ;
                    ] ;
                ]
                [
                  a sp:Filter ;
                  sp:expression [
                      a spin:eval ;
                      sp:arg1 [
                          sp:varName "expression" ;
                        ] ;
                      sp:arg2 arg:predicate ;
                      sp:arg3 [
                          sp:varName "predicate" ;
                        ] ;
                      sp:arg4 arg:range ;
                      sp:arg5 [
                          sp:varName "range" ;
                        ] ;
                      sp:arg6 arg:resourceType ;
                      sp:arg7 [
                          sp:varName "resourceType" ;
                        ] ;
                    ] ;
                ]
                [
                  a sp:Bind ;
                  sp:expression [
                      sp:varName "widgetClass" ;
                    ] ;
                  sp:variable [
                      sp:varName "actionName" ;
                    ] ;
                ]
                [
                  a sp:Bind ;
                  sp:expression [
                      a afn:localname ;
                      sp:arg1 [
                          sp:varName "widgetClass" ;
                        ] ;
                    ] ;
                  sp:variable [
                      sp:varName "actionLocalName" ;
                    ] ;
                ]
                [
                  a sp:Bind ;
                  sp:expression true ;
                  sp:variable [
                      sp:varName "enabled" ;
                    ] ;
                ]
                [
                  a sp:Bind ;
                  sp:expression [
                      a sp:concat ;
                      sp:arg1 "swa.replaceFacet('" ;
                      sp:arg2 [
                          sp:varName "elementId" ;
                        ] ;
                      sp:arg3 "', '" ;
                      sp:arg4 [
                          a xsd:string ;
                          sp:arg1 [
                              sp:varName "widgetClass" ;
                            ] ;
                        ] ;
                      sp:arg5 "', '" ;
                      sp:arg6 [
                          a xsd:string ;
                          sp:arg1 [
                              sp:varName "resourceType" ;
                            ] ;
                        ] ;
                      sp:arg7 "', '" ;
                      sp:arg8 [
                          a xsd:string ;
                          sp:arg1 [
                              sp:varName "predicate" ;
                            ] ;
                        ] ;
                      sp:arg9 "')" ;
                    ] ;
                  sp:variable [
                      sp:varName "onSelect" ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode ui:graph ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:or ;
                sp:arg1 [
                    a sp:not ;
                    sp:arg1 [
                        a sp:bound ;
                        sp:arg1 [
                            sp:varName "filterFunction" ;
                          ] ;
                      ] ;
                  ] ;
                sp:arg2 [
                    a spif:invoke ;
                    sp:arg1 [
                        sp:varName "filterFunction" ;
                      ] ;
                    sp:arg2 [
                        sp:varName "widgetClass" ;
                      ] ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:filterFunction ;
      spl:valueType spin:Function ;
      rdfs:comment "An optional filter function that takes an swa:ObjectFacetWidget as its (only) argument and returns false if the widget is not allowed. True means that the widget shall be included. This is used by TBI to prevent the regular expression search widget." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:elementId ;
      spl:valueType xsd:string ;
      rdfs:comment "The id of the surrounding element that shall have its content replaced." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate to get the widget for." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:range ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The range class." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The resource type on the form." ;
    ] ;
  rdfs:comment "Gets the suitable facet widgets for a drop down menu." ;
  rdfs:label "Object facet widgets" ;
  rdfs:subClassOf spin:SelectTemplates ;
.
swa:ObjectFacetWidgetsCallback
  a ui:JSONService ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:filterFunction ;
      spl:valueType spin:Function ;
      rdfs:comment "An optional filter function to get - this is taken from the context variable \"swaObjectFacetWidgetsFilterFunction\"." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:elementId ;
      spl:valueType xsd:string ;
      rdfs:comment "The id of the div holding the current widget." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate of the widget." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The class on the form." ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:call arg:elementId=\"{= ?elementId }\" arg:filterFunction=\"{= ?filterFunction }\" arg:predicate=\"{= ?predicate }\" arg:range=\"{= swa:localRangeAtClass(?resourceType, ?predicate) }\" arg:resourceType=\"{= ?resourceType }\" ui:args=\"template\" ui:template=\"{= swa:ObjectFacetWidgets }\">
    <swon:RSObjectArray arg:resultSet=\"{= ?rs }\"/>
</ui:call>
"""^^ui:Literal ;
  rdfs:label "Object facet widgets callback" ;
  rdfs:subClassOf swa:MenuElements ;
  rdfs:subClassOf ui:JSONServices ;
.
swa:ObjectGroupElements
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:label ;
      spl:valueType xsd:string ;
      rdfs:comment "The title label." ;
    ] ;
  ui:abstract true ;
  ui:private true ;
  rdfs:comment "Abstract superclass serving as base for various object groups." ;
  rdfs:label "Object group elements" ;
  rdfs:subClassOf swa:FormElements ;
.
swa:ObjectPredicateSelectionTemplates
  a spin:SelectTemplate ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:subject ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject." ;
    ] ;
  rdfs:comment "Abstract base class for templates that can be used to select which predicates shall appear on a form, based on a subject or a subject type from the context." ;
  rdfs:label "Predicate selection templates" ;
  rdfs:subClassOf spin:SelectTemplates ;
.
swa:ObjectViewer
  a swa:ObjectViewerClass ;
  ui:private true ;
  ui:prototype """
<div class=\"swa-object-widget\" let:class=\"{= COALESCE(ui:contextValue(&quot;viewWidget&quot;), swa:propertyViewWidget(?subject, ?predicate), swa:bestObjectViewerClass(?object, ?predicate, ?subject)) }\">
    <ui:if ui:condition=\"{= bound(?class) }\">
        <ui:dynamicView arg:object=\"{= ?object }\" arg:predicate=\"{= ?predicate }\" arg:subject=\"{= ?subject }\" ui:class=\"{= ?class }\"/>
    </ui:if>
    <ui:else>
        <ui:if ui:condition=\"{= bound(?object) }\">[Error: no ObjectViewer found for {= ui:label(?subject) }, {= ui:label(?predicate) }, {= ui:label(?object) }]</ui:if>
    </ui:else>
</div>
"""^^ui:Literal ;
  rdfs:comment """A read-only widget displaying a single object. In order to be selected on forms, subclasses of this class must specify a weight > 0 and an expression that returns true for the given input variable bindings:
- ?type: the datatype or rdf:type of the object being displayed
- ?kind: \"literal\", \"blank\", \"uri\" or \"image\"
- ?predicate: the property being displayed""" ;
  rdfs:label "Object viewer" ;
  rdfs:subClassOf swa:ObjectWidget ;
.
swa:ObjectViewerClass
  a rdfs:Class ;
  rdfs:comment "The metaclass of object viewer elements." ;
  rdfs:label "Object viewer class" ;
  rdfs:subClassOf swa:ObjectWidgetClass ;
.
swa:ObjectViewerRow
  a swa:ObjectWidgetRowClass ;
  ui:private true ;
  ui:prototype """
<ui:group let:datatype=\"{= IF(isLiteral(?object), datatype(?object), ?no) }\" let:uid=\"{= ui:uniqueId() }\">
    <div about=\"{= IF(isIRI(?subject), ?subject, ?noBNodes) }\" class=\"swa-widget-row\" content=\"{= IF(isLiteral(?object), ?object, ?no) }\" datatype=\"{= ?datatype }\" href=\"{= IF(isIRI(?object), ?object, ?no) }\" id=\"{= ?uid }\" property=\"{= IF(isLiteral(?object), ui:encodeNode(?predicate), ?no) }\" rel=\"{= IF(isIRI(?object), ui:encodeNode(?predicate), ?no) }\" ui:addNamespace=\"{= IF(swa:hasPrefix(?predicate), ?predicate, ?none) }\">
        <swa:ObjectViewer arg:uid=\"{= ?uid }\" ui:args=\"*\"/>
    </div>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "A row in an ObjectViewer." ;
  rdfs:label "Object viewer row" ;
  rdfs:subClassOf swa:ObjectWidgetRow ;
.
swa:ObjectWidget
  a swa:ObjectWidgetClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:object ;
      rdfs:comment "The object to display or edit." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:uid ;
      spl:valueType xsd:string ;
      rdfs:comment "The uid used to identify the triple." ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:dynamicView arg:object=\"{= ?object }\" arg:predicate=\"{= ?predicate }\" arg:subject=\"{= ?subject }\" ui:class=\"{= swa:modeProperty(swa:objectWidgetClass) }\"/>
"""^^ui:Literal ;
  rdfs:comment "A component representing a single RDF node. Depending on the mode, this may for example be an ObjectViewer or ObjectEditor." ;
  rdfs:label "Object widget" ;
  rdfs:subClassOf swa:ObjectElements ;
.
swa:ObjectWidgetClass
  a rdfs:Class ;
  rdfs:comment "Metaclass of the various object widget types." ;
  rdfs:label "Object widget class" ;
  rdfs:subClassOf ui:NodeClass ;
.
swa:ObjectWidgetMiddleColumn
  a swa:ObjectWidgetMiddleColumnClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:editWidget ;
      spl:valueType swa:ObjectEditorClass ;
      rdfs:comment "The preferred widget if in edit mode." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:searchWidget ;
      spl:valueType swa:ObjectFacetClass ;
      rdfs:comment "The preferred facet widget." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:single ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True whether the surrounding widget has at most one value." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:viewWidget ;
      spl:valueType swa:ObjectViewerClass ;
      rdfs:comment "The preferred widget if in view mode." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:uid ;
      spl:valueType xsd:string ;
      rdfs:comment "The uid of the surrounding widget." ;
    ] ;
  ui:abstract true ;
  ui:private true ;
  rdfs:comment "Base class of the elements that can show up as middle column between the label and the actual widgets on a form. The selection of the particular middle column element is made through the mode property swa:objectWidgetMiddleColumnClass." ;
  rdfs:label "Object widget middle column" ;
  rdfs:subClassOf swa:ObjectElements ;
.
swa:ObjectWidgetMiddleColumnClass
  a rdfs:Class ;
  rdfs:comment "Metaclass of the various object widget middle column types." ;
  rdfs:label "Object widget middle column class" ;
  rdfs:subClassOf ui:NodeClass ;
.
swa:ObjectWidgetRow
  a swa:ObjectWidgetRowClass ;
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:object ;
      rdfs:comment "The object node." ;
    ] ;
  ui:prototype """
<ui:dynamicView arg:object=\"{= ?object }\" arg:predicate=\"{= ?predicate }\" arg:subject=\"{= ?subject }\" ui:class=\"{= swa:modeProperty(swa:objectWidgetRowClass) }\"/>
"""^^ui:Literal ;
  rdfs:comment "Superclass for the widget row types." ;
  rdfs:label "Object widget row" ;
  rdfs:subClassOf swa:ObjectElements ;
.
swa:ObjectWidgetRowClass
  a rdfs:Class ;
  rdfs:comment "Metaclass for ObjectWidgetRows." ;
  rdfs:label "Object widget row class" ;
  rdfs:subClassOf ui:NodeClass ;
.
swa:Objects
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:open ;
      spl:valueType xsd:boolean ;
      rdfs:comment "If arg:openable=\"true\" then this can be set to true to have the content visible by default." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:openable ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to have an open/close icon appear next to the label. Requires a predicate to be present. The content will appear hidden in search mode, but arg:open=\"true\" can be used to control the state." ;
    ] ;
  ui:prototype """
<ui:group let:function=\"{= swa:modeProperty(swa:isSingleFunction) }\">
    <swa:LabeledObjects arg:single=\"{= IF(bound(?function), spif:invoke(?function, ?predicate, ?subject), swa:modeProperty(swa:isSingleConstant)) }\" ui:args=\"*\"/>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "A two-columned structure with a label on the left and zero or more objects on the right." ;
  rdfs:label "Objects" ;
  rdfs:subClassOf swa:AbstractObject ;
.
swa:ObjectsBody
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:single ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to allow at most one value." ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:dynamicView arg:predicate=\"{= ?predicate }\" arg:single=\"{= ?single }\" arg:subject=\"{= ?subject }\" ui:class=\"{= COALESCE(swa:modeProperty(swa:objectsBodyClass), swa:DefaultObjectsBody) }\"/>
"""^^ui:Literal ;
  rdfs:comment "The body of an Object(s) widget, typically containing one row for each value. This can be \"overloaded\" via a mode property." ;
  rdfs:label "Objects body" ;
  rdfs:subClassOf swa:ObjectElements ;
.
swa:ObjectsEnum
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:alwaysDisplay ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to have this always displayed, even if no properties are inside." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:hideIfEmpty ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to hide the whole group if the subject has no value for any property in it." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:open ;
      spl:valueType xsd:boolean ;
      rdfs:comment "If arg:openable=\"true\" then this can be set to true to have the content visible by default." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:openable ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to have an open/close icon appear next to the label. Requires a label to be present. The content will appear hidden by default, but arg:open=\"true\" can be used to control the initial state." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:subject ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject resource to display." ;
    ] ;
  ui:prototype """
<ui:if let:tp=\"{= ?thisParent }\" ui:condition=\"{= (((((!bound(?subject)) || swa:isEditMode()) || (COALESCE(?hideIfEmpty, false) = false)) || swa:subjectHasObjectFromEnum(?subject, ?thisParent)) || swa:objectHasSubjectFromEnum(?subject, ?thisParent)) || ?alwaysDisplay }\">
    <div class=\"swa-objects-group {= IF((((swa:isEditMode() || swa:isSearchMode()) &amp;&amp; (!swa:objectsEnumPropertiesHaveType(?tp))) &amp;&amp; swa:falseOrUnbound(?alwaysDisplay)), &quot;ui-helper-hidden-accessible&quot;, ?none) }\" let:bodyId=\"{= ui:uniqueId() }\">
        <ui:if ui:condition=\"{= ?openable }\">
            <div class=\"swa-sub-title\" let:id=\"{= ui:uniqueId() }\">
                <div class=\"swa-openable-object-icon ui-icon ui-icon-triangle-1-{= IF((bound(?open) &amp;&amp; ?open), &quot;s&quot;, &quot;e&quot;) }\" id=\"{= ?id }\" onclick=\"swa.toggleOpenableObject('{= ?bodyId }', '{= ?id }')\"/>
                <div class=\"swa-float-left\">{= ?label }</div>
                <div class=\"swa-clear-both\"/>
            </div>
        </ui:if>
        <ui:elseif ui:condition=\"{= bound(?label) }\">
            <div class=\"swa-sub-title\">{= ?label }</div>
        </ui:elseif>
        <div class=\"{= IF((?openable &amp;&amp; ((!bound(?open)) || (!?open))), &quot;ui-helper-hidden-accessible&quot;, ?none) }\" id=\"{= ?bodyId }\">
            <ui:insertionPoint ui:pointId=\"body\"/>
        </div>
    </div>
</ui:if>
"""^^ui:Literal ;
  rdfs:comment "A container around a finite list of swa:Objects (or swa:Subjects) elements - not computed through a filter function but explicitly enumerated. Can be used in conjunction with swa:ObjectsPlaceholder. By default all swa:Objects inside of an ObjectsEnum are displayed under a simple title. However, if arg:openable=\"true\" then the body can be expanded and collapsed via an arrow icon. This can be used to organize forms into optional sections." ;
  rdfs:label "Objects enum" ;
  rdfs:subClassOf swa:ObjectGroupElements ;
.
swa:ObjectsGroup
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:filterFunction ;
      spl:valueType spin:Function ;
      rdfs:comment "An optional filter function that takes a predicate and a subject as arguments and returns true for all predicates that should be displayed." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:predicates ;
      spl:valueType sp:Select ;
      rdfs:comment "A result set (e.g., SPARQL SELECT query) that delivers the predicates in this group." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:subject ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to display." ;
    ] ;
  ui:prototype """
<ui:group letrs:rs=\"{#
        SELECT ?predicate
        WHERE {
            ( ?predicates 0 ) spr:colCells ?predicate .
            FILTER ((!bound(?filterFunction)) || spif:invoke(?filterFunction, ?predicate, ?subject)) .
            FILTER (!swa:isHiddenPropertyAtSubject(?predicate, ?subject)) .
            MINUS {
                ?subject swa:shapePropertiesOnForm ?predicate .
            } .
        } }\">
    <ui:if ui:condition=\"{= spr:rowCount(?rs) &gt; 0 }\">
        <div class=\"swa-objects-group\">
            <ui:if ui:condition=\"{= bound(?label) }\">
                <div class=\"swa-sub-title\">{= ?label }</div>
            </ui:if>
            <ui:forEach ui:resultSet=\"{= ?rs }\">
                <swa:Objects arg:predicate=\"{= ?predicate }\" arg:subject=\"{= ?subject }\"/>
            </ui:forEach>
        </div>
    </ui:if>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "A group of swa:Objects elements where the predicates are computed by taking a result set (e.g. of all relevant properties) and applying a filter on top of it, e.g. to only show the annotation properties among those that are relevant. This will also filter out any properties that will be inserted based on Shape definitions." ;
  rdfs:label "Objects group" ;
  rdfs:subClassOf swa:ObjectGroupElements ;
.
swa:ObjectsPlaceholder
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:addBoxInEditMode ;
      spl:valueType xsd:boolean ;
      rdfs:comment "If true and the form is in edit mode, then instead of showing all possible properties there is a drop down box where the user can pick a property to add." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:filterFunction ;
      spl:valueType spin:Function ;
      rdfs:comment "An optional filter function that takes a predicate and an optional subject as arguments and returns true for all predicates that should be displayed. If no function is specified then all \"other\" predicates will be shown." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:hidePropertiesFunction ;
      spl:valueType spin:Function ;
      rdfs:comment "An optional SPARQL function that takes a property as argument and returns true if the property should be hidden. This only applies to properties listed due to their presence in SHACL property groups." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:hidePropertyGroupsFunction ;
      spl:valueType spin:Function ;
      rdfs:comment "An optional SPARQL function that takes a sh:PropertyGroup as its parameter and returns true if the group should be hidden." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:open ;
      spl:valueType xsd:boolean ;
      rdfs:comment "If arg:openable=\"true\" then this can be set to true to have the content visible by default." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:openable ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to have an open/close icon appear next to the label. Requires a label to be present. The content will appear hidden by default, but arg:open=\"true\" can be used to control the initial state." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:shapeSectionAbove ;
      spl:valueType xsd:boolean ;
      rdfs:comment "By default, the Shape-based sections will be placed under this Section. If set to true, it will be moved above." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:subject ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject resource to display." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:suppressShapeSection ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to not include any Shape-based sections." ;
    ] ;
  ui:prototype """
<ui:call arg:subject=\"{= ?subject }\" let:rootView=\"{= swa:rootView(?thisParent) }\" ui:template=\"{= swa:modeProperty(swa:formObjectPredicateSelectionTemplate) }\">
    <ui:update ui:updateQuery=\"{!
            INSERT {
                GRAPH ui:tempGraph {
                    ?thisParent swa:used ?predicate .
                } .
            }
            WHERE {
                {
                    ?rootView swa:predicatesOfObjects ?predicate .
                }
                UNION
                {
                    {
                        FILTER swa:falseOrUnbound(?suppressShapeSection) .
                    } .
                    ?subject swa:shapePropertiesOnForm ?predicate .
                } .
            } }\"/>
    <ui:if ui:condition=\"{= swa:falseOrUnbound(?suppressShapeSection) &amp;&amp; ?shapeSectionAbove }\">
        <swa:ShapeFormSection arg:hidePropertiesFunction=\"{= ?hidePropertiesFunction }\" arg:hidePropertyGroupsFunction=\"{= ?hidePropertyGroupsFunction }\" arg:resource=\"{= ?subject }\"/>
    </ui:if>
    <ui:group letrs:rs=\"{#
            SELECT ?predicate
            WHERE {
                ( ?rs 0 ) spr:colCells ?predicate .
                FILTER NOT EXISTS {
                    GRAPH ui:tempGraph {
                        ?thisParent swa:used ?predicate .
                    } .
                } .
                FILTER (!swa:isHiddenPropertyAtSubject(?predicate, ?subject)) .
                FILTER ((!bound(?filterFunction)) || spif:invoke(?filterFunction, ?predicate, ?subject)) .
            } }\">
        <ui:if ui:condition=\"{= spr:rowCount(?rs) &gt; 0 }\">
            <div class=\"{= IF(bound(?label), &quot;swa-objects-group&quot;, ?none) } {= IF((!bound(?label)), &quot;swa-margin-bottom-zero&quot;, ?none) }\\\" let:bodyId=\"{= ui:uniqueId() }\">
                <ui:if ui:condition=\"{= ?openable }\">
                    <div class=\"swa-sub-title\" let:id=\"{= ui:uniqueId() }\">
                        <div class=\"swa-openable-object-icon ui-icon ui-icon-triangle-1-{= IF((bound(?open) &amp;&amp; ?open), &quot;s&quot;, &quot;e&quot;) }\" id=\"{= ?id }\" onclick=\"swa.toggleOpenableObject('{= ?bodyId }', '{= ?id }')\"/>
                        <div class=\"swa-float-left\">{= ?label }</div>
                        <div class=\"swa-clear-both\"/>
                    </div>
                </ui:if>
                <ui:elseif ui:condition=\"{= bound(?label) }\">
                    <div class=\"swa-sub-title\">{= ?label }</div>
                </ui:elseif>
                <div class=\"{= IF((?openable &amp;&amp; ((!bound(?open)) || (!?open))), &quot;ui-helper-hidden-accessible&quot;, ?none) }\" id=\"{= ?bodyId }\">
                    <ui:if ui:condition=\"{= swa:isEditMode() &amp;&amp; ?addBoxInEditMode }\">
                        <ui:forEach ui:resultSet=\"{= ?rs }\">
                            <ui:if ui:condition=\"{= EXISTS {
                                ?subject ?predicate ?any .
                            } }\">
                                <swa:Objects arg:predicate=\"{= ?predicate }\" arg:subject=\"{= ?subject }\"/>
                            </ui:if>
                        </ui:forEach>
                        <swa:AddPropertyBox ui:args=\"*\"/>
                    </ui:if>
                    <ui:else>
                        <ui:forEach ui:resultSet=\"{= ?rs }\">
                            <swa:Objects arg:predicate=\"{= ?predicate }\" arg:subject=\"{= ?subject }\"/>
                        </ui:forEach>
                    </ui:else>
                </div>
            </div>
        </ui:if>
    </ui:group>
    <ui:if ui:condition=\"{= swa:falseOrUnbound(?suppressShapeSection) &amp;&amp; swa:falseOrUnbound(?shapeSectionAbove) }\">
        <swa:ShapeFormSection arg:hidePropertiesFunction=\"{= ?hidePropertiesFunction }\" arg:hidePropertyGroupsFunction=\"{= ?hidePropertyGroupsFunction }\" arg:resource=\"{= ?subject }\"/>
    </ui:if>
</ui:call>
"""^^ui:Literal ;
  rdfs:comment """Inserts Objects for all \"other\" properties for the given subject. This includes all properties that are not mentioned explicitly through other swa:Objects elements on the surrounding element tree. A filter function can be provided to further exclude certain properties that shouldn't be visible at all.

This element by default also inserts additional sections based on SHACL Shape definitions. These sections can be suppressed or placed in another order using arguments.""" ;
  rdfs:label "Objects placeholder" ;
  rdfs:subClassOf swa:ObjectGroupElements ;
.
swa:OneOfItems
  a spin:SelectTemplate ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "item" ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "oneOf" ;
              ] ;
            sp:predicate owl:oneOf ;
            sp:subject [
                sp:varName "resource" ;
              ] ;
          ]
          [
            a sp:TriplePath ;
            sp:object [
                sp:varName "item" ;
              ] ;
            sp:path [
                a sp:SeqPath ;
                sp:path1 [
                    a sp:ModPath ;
                    sp:modMax -2 ;
                    sp:modMin 0 ;
                    sp:subPath rdf:rest ;
                  ] ;
                sp:path2 rdf:first ;
              ] ;
            sp:subject [
                sp:varName "oneOf" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The datatype or class." ;
    ] ;
  rdfs:comment "Given an rdfs:Datatype or enumerated class, returns the members of the owl:oneOf enumeration." ;
  rdfs:label "oneOf items" ;
  rdfs:subClassOf spin:SelectTemplates ;
.
swa:Options
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:defaultValue false ;
      spl:optional true ;
      spl:predicate arg:encodeValues ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to send values through ui:encodeNode, e.g., produce @value=\"&lt;http://...&gt;\" instead of @value=\"http://...\"" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:title ;
      spl:valueType xsd:string ;
      rdfs:comment "Title for an optgroup containing the options" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resultSet ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "Result set with variables ?party and ?label" ;
    ] ;
  ui:prototype """
<ui:if ui:condition=\"{= !spr:isEmpty(?resultSet) }\">
    <ui:if ui:condition=\"{= bound(?title) }\">
        <optgroup label=\"{= ?title }\">
            <ui:forEach ui:resultSet=\"{= ?resultSet }\">
                <option title=\"{= ?tooltip }\" value=\"{= IF(swa:falseOrUnbound(?encodeValues), ?resource, ui:encodeNode(?resource, true, true)) }\">{= ?label }</option>
            </ui:forEach>
        </optgroup>
    </ui:if>
    <ui:else>
        <ui:forEach ui:resultSet=\"{= ?resultSet }\">
            <option title=\"{= ?tooltip }\" value=\"{= IF(swa:falseOrUnbound(?encodeValues), ?resource, ui:encodeNode(?resource, true, true)) }\">{= ?label }</option>
        </ui:forEach>
    </ui:else>
</ui:if>
"""^^ui:Literal ;
  rdfs:comment "Renders HTML option elements for each row in the result set. If a title is given, they will be surrounded by an optgroup element. Result set columns: ?label, ?value, ?tooltip." ;
  rdfs:label "option group" ;
  rdfs:subClassOf swa:Elements ;
.
swa:ParamsDialog
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:dataGraph ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The data graph." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:callback ;
      spl:valueType xsd:string ;
      rdfs:comment "A JavaScript expression that shall be evaluated if the user Oks the dialog. This expression can access the params from the server using the variable 'data'. For example to simply apply the edits, make it \"swa.processEdits(data)\"." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:label ;
      spl:valueType xsd:string ;
      rdfs:comment "The title label of the dialog." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:loadId ;
      spl:valueType xsd:string ;
      rdfs:comment "The ui:loadId of the resulting ui:loadable." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The type of resource to create." ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:loadable ui:loadId=\"{= ?loadId }\">
    <ui:if ui:condition=\"{= bound(?resourceType) }\">
        <div id=\"div-{= ?loadId }\" title=\"{= ?label }\">
            <ui:setContext ui:queryGraph=\"{= ui:graph }\" ui:varName=\"dataGraph\" ui:varValue=\"{= ui:currentQueryGraph() }\">
                <swa:CreateForm arg:formId=\"{= ?loadId }-form\" arg:resourceType=\"{= ?resourceType }\" arg:resourceURI=\"urn:x-swa:Dummy\"/>
            </ui:setContext>
            <div class=\"swa-dialog-button-bar\">
                <button class=\"btn btn-default btn-xs\" onclick=\"swa.submitParamsDialog('{= ?loadId }', &quot;{= ui:escapeJSON(?callback) }&quot;)\">OK</button>
                <swa:Space/>
                <button class=\"btn btn-default btn-xs\" onclick=\"swa.closeDialog('{= ?loadId }')\">Cancel</button>
            </div>
        </div>
    </ui:if>
</ui:loadable>
"""^^ui:Literal ;
  rdfs:comment "A dialog that displays an edit form (swa:CreateForm) for a new instance of a given class. When the user presses the OK button, it will translate the edited values into a set of parameters (name-value-pairs) using a server callback. The resulting parameters can then be used to invoke another service such as an SWP request or a SPARQLMotion script." ;
  rdfs:label "Params dialog" ;
  rdfs:subClassOf swa:DialogElements ;
.
swa:PasswordEditor
  a swa:ObjectEditorClass ;
  ui:prototype """
<swa:AbstractTextFieldEditor arg:inputType=\"password\" arg:suppressLanguage=\"{= true }\" ui:args=\"*\"/>
"""^^ui:Literal ;
  rdfs:comment "Similar to TextFieldEditor but with a password field instead of a normal text field - the entered characters are not visible to the user. This widget has no weight - in order to use it on a form you could use <swa:Object swa:editWidget=\"swa:PasswordEditor\" ... />." ;
  rdfs:label "Password editor" ;
  rdfs:subClassOf swa:AbstractTextFieldEditor ;
.
swa:PasswordViewer
  a swa:ObjectViewerClass ;
  ui:prototype """
<div class=\"swa-shifted-label\">
    <ui:if ui:condition=\"{= bound(?object) &amp;&amp; isLiteral(?object) }\">
        <ui:forEach ui:resultSet=\"{#
                SELECT ?i
                WHERE {
                    BIND (fn:string-length(xsd:string(?object)) AS ?length) .
                    ?i spif:for ( 0 ?length ) .
                } }\">?</ui:forEach>
    </ui:if>
</div>
"""^^ui:Literal ;
  rdfs:comment "A viewer for passwords that replaces all characters with a special dot symbol." ;
  rdfs:label "Password viewer" ;
  rdfs:subClassOf swa:ObjectViewer ;
.
swa:PathElements
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:focusNode ;
      rdfs:comment "The focus node to display. Will be unbound if used in search forms." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:path ;
      rdfs:comment "The SHACL path derived from sh:path (typically just the URI of a property)." ;
    ] ;
  ui:abstract true ;
  rdfs:comment "Abstract base class of UI elements that display a given focus node / path combination. To be used with tosh:viewGadget." ;
  rdfs:label "Path elements" ;
  rdfs:subClassOf swa:FormElements ;
.
swa:Pitfall
  a ui:NodeClass ;
  ui:prototype """
<div class=\"admon\">
    <img align=\"left\" alt=\"Pitfall Icon\" hspace=\"30px\" src=\"{= ui:lib() }/assets/images/icon-pitfall.jpg\" vspace=\"0px\" width=\"60px\"/>
    <p>
        <ui:insertionPoint ui:pointId=\"body\"/>
    </p>
</div>
"""^^ui:Literal ;
  rdfs:label "Pitfall" ;
  rdfs:subClassOf swa:DocumentElements ;
.
swa:PlainTextFieldEditor
  a swa:ObjectEditorClass ;
  ui:prototype """
<swa:AbstractTextFieldEditor arg:datatype=\"{= ?range }\" arg:inputType=\"text\" arg:suppressLanguage=\"{= true }\" ui:args=\"*\"/>
"""^^ui:Literal ;
  rdfs:comment "A text field without the ability to enter a language tag. This can be selected \"manually\" on forms, using arg:editWidget." ;
  rdfs:label "Plain text field editor" ;
  rdfs:subClassOf swa:AbstractTextFieldEditor ;
.
swa:PredicatesInGroup
  a spin:SelectTemplate ;
  spin:body [
      a sp:Select ;
      sp:distinct true ;
      sp:resultVariables (
          [
            sp:varName "predicate" ;
          ]
          [
            sp:varName "propertyLabel" ;
          ]
          [
            sp:varName "isInverse" ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "group" ;
              ] ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "?0" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "?1" ;
              ] ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "?0" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "focusNode" ;
              ] ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "?1" ;
              ] ;
          ]
          [
            sp:object () ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "?1" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "?2" ;
              ] ;
            sp:predicate swa:predicatesInGroup ;
            sp:subject [
                sp:varName "?0" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "predicate" ;
              ] ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "?2" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "?3" ;
              ] ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "?2" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "propertyLabel" ;
              ] ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "?3" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "?4" ;
              ] ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "?3" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "isInverse" ;
              ] ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "?4" ;
              ] ;
          ]
          [
            sp:object () ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "?4" ;
              ] ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:or ;
                sp:arg1 [
                    a sp:or ;
                    sp:arg1 [
                        sp:varName "isInverse" ;
                      ] ;
                    sp:arg2 [
                        a sp:not ;
                        sp:arg1 [
                            a sp:bound ;
                            sp:arg1 [
                                sp:varName "hidePropertiesFunction" ;
                              ] ;
                          ] ;
                      ] ;
                  ] ;
                sp:arg2 [
                    a sp:not ;
                    sp:arg1 [
                        a spif:invoke ;
                        sp:arg1 [
                            sp:varName "hidePropertiesFunction" ;
                          ] ;
                        sp:arg2 [
                            sp:varName "predicate" ;
                          ] ;
                      ] ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:hidePropertiesFunction ;
      spl:valueType spin:Function ;
      rdfs:comment "An optional SPARQL function that takes a property as argument and returns true if the property should be hidden." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:focusNode ;
      rdfs:comment "The focus node." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:group ;
      spl:valueType sh:PropertyGroup ;
      rdfs:comment "The sh:PropertyGroup to display." ;
    ] ;
  spin:private true ;
  rdfs:label "Predicates in group" ;
  rdfs:subClassOf spin:SelectTemplates ;
.
swa:ProgressJSONCallback
  a ui:Service ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:id ;
      spl:valueType xsd:string ;
      rdfs:comment "The id of the progress to check." ;
    ] ;
  ui:prototype """
<ui:group>{= COALESCE(ui:progressJSON(?id), false) }</ui:group>
"""^^ui:Literal ;
  rdfs:comment "A service used by the SWA progress bars." ;
  rdfs:label "Progress JSON callback" ;
  rdfs:subClassOf ui:JSONServices ;
.
swa:PropertyFormBody
  a ui:ResourceViewClass ;
  ui:private true ;
  ui:prototype """
<ui:group default:subject=\"{= ?resource }\">
    <ui:call arg:subject=\"{= ?resource }\" ui:template=\"{= swa:modeProperty(swa:formObjectPredicateSelectionTemplate) }\">
        <swa:ObjectsGroup arg:filterFunction=\"{= swa:isAnnotationProperty }\" arg:label=\"Annotations\" arg:predicates=\"{= ?rs }\"/>
        <swa:ObjectsGroup arg:filterFunction=\"{= swa:isPropertyAxiomProperty }\" arg:label=\"Property Axioms\" arg:predicates=\"{= ?rs }\"/>
        <swa:ObjectsGroup arg:filterFunction=\"{= swa:isNonPropertyAxiomProperty }\" arg:label=\"Properties\" arg:predicates=\"{= ?rs }\"/>
    </ui:call>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "The default view for rdf:Property, with widget groups for Annotation Properties, Property Axioms and Other Properties." ;
  rdfs:label "Property form body" ;
  rdfs:subClassOf swa:FormBody ;
.
swa:PropertyLabel
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:comment ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional comment to serve as tool tip text." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:id ;
      spl:valueType xsd:string ;
      rdfs:comment "An id for the resulting span, in case you ever need to reference it." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:inferred ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to use styling to indicate that the values of this property are inferred (by a SHACL triple rule)." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:inverse ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to have the label surrounded by \"is ... of\"." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:property ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property to display." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:subject ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject (if available) - used on edit forms for non-inverse properties." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:label ;
      spl:valueType xsd:string ;
      rdfs:comment "The label to display." ;
    ] ;
  ui:prototype """
<label>
    <ui:if ui:condition=\"{= ?inverse }\">
        <span class=\"swa-property-label\" id=\"{= ?id }\" title=\"{= COALESCE(ui:convertHTMLToText(?comment), IF(bound(?property), spl:object(?property, rdfs:comment), ?none)) }\">{= ?label }</span>
        <span class=\"swa-property-label-inverse\"> (inverse)</span>
        <span class=\"swa-property-label\">:</span>
    </ui:if>
    <ui:elseif ui:condition=\"{= ?inferred }\">
        <span class=\"swa-property-label\" id=\"{= ?id }\" title=\"{= COALESCE(ui:convertHTMLToText(?comment), IF(bound(?property), spl:object(?property, rdfs:comment), ?none)) }\">{= ?label }</span>
        <span class=\"swa-property-label-inferred\" title=\"Values of this property are automatically computed (using SHACL rules)\"> (inferred)</span>
        <span class=\"swa-property-label\">:</span>
    </ui:elseif>
    <ui:else>
        <span class=\"swa-property-label\" id=\"{= ?id }\" title=\"{= COALESCE(ui:convertHTMLToText(?comment), IF(bound(?property), spl:object(?property, rdfs:comment), ?none)) }\">{= ?label }:<ui:if ui:condition=\"{= (bound(?subject) &amp;&amp; swa:isMandatory(?property, ?subject)) &amp;&amp; (!swa:isSearchMode()) }\">
                <span class=\"form-required\">&nbsp;*</span>
            </ui:if>
        </span>
    </ui:else>
</label>
"""^^ui:Literal ;
  rdfs:comment "The label used to display the name of the property on a form, consisting of the property's label and a column. Should also be used to display properties elsewhere to have a central implementation that could be overloaded etc." ;
  rdfs:label "Property label" ;
  rdfs:subClassOf swa:Elements ;
.
swa:PropertyShapeFormBody
  a ui:ResourceViewClass ;
  ui:prototype """
<ui:setContext ui:varName=\"resourceType\" ui:varValue=\"{= sh:PropertyShape }\">
    <ui:forEach ui:resultSet=\"{#
            SELECT DISTINCT ?group
            WHERE {
                ?resource swa:propertyGroupsForNode ?group .
                BIND (COALESCE(spl:object(?group, sh:order), 9999999) AS ?order) .
                BIND (ui:label(?group) AS ?label) .
            }
            ORDER BY (?order) (?label) }\">
        <swa:ShapePropertyGroupSection arg:focusNode=\"{= ?resource }\" arg:group=\"{= ?group }\"/>
    </ui:forEach>
</ui:setContext>
"""^^ui:Literal ;
  rdfs:label "Property shape form body" ;
  rdfs:subClassOf swa:FormBody ;
.
swa:PseudoSpanningTree
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:inverse ;
      spl:valueType xsd:boolean ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:maxHeight ;
      spl:valueType xsd:integer ;
      rdfs:comment "Maximum height of the tree" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:relationship ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The relationship to graph" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:subject ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "Subject of a triple" ;
    ] ;
  ui:prototype """
<ui:group let:isInverse=\"{= COALESCE(?inverse, false) }\">
    <ui:setContext ui:queryGraph=\"{= ui:tempGraph }\" ui:silentTransactions=\"{= true }\">
        <ui:addPropertyValue arg:property=\"{= arg:visited }\" arg:value=\"{= true }\" ui:this=\"{= ?subject }\"/>
    </ui:setContext>
    <swon:Object letrs:children=\"{#
            SELECT ?child
            WHERE {
                {
                    FILTER (?isInverse != true) .
                    ?subject ?relationship ?child .
                }
                UNION
                {
                    FILTER (?isInverse = true) .
                    ?child ?relationship ?subject .
                } .
                FILTER NOT EXISTS {
                    GRAPH ui:tempGraph {
                        ?child arg:visited true .
                    } .
                } .
            } }\">
        <swon:Value arg:name=\"name\" arg:value=\"{= ui:label(?subject) }\"/>
        <ui:if ui:condition=\"{= (spr:rowCount(?children) &gt; 0) &amp;&amp; (?maxHeight &gt; 0) }\">
            <swon:Value arg:name=\"children\">
                <swon:Array>
                    <ui:forEach ui:resultSet=\"{= ?children }\" ui:separator=\",\">
                        <swa:PseudoSpanningTree arg:inverse=\"{= ?inverse }\" arg:maxHeight=\"{= ?maxHeight - 1 }\" arg:relationship=\"{= ?relationship }\" arg:subject=\"{= ?child }\"/>
                    </ui:forEach>
                </swon:Array>
            </swon:Value>
        </ui:if>
    </swon:Object>
</ui:group>
"""^^ui:Literal ;
  rdfs:label "Pseudo spanning tree for SWON Objects" ;
  rdfs:subClassOf swon:Elements ;
.
swa:RDFListEditor
  a swa:ObjectEditorClass ;
  swa:objectWidgetWeight [
      a swa:WeightedExpression ;
      swa:expression [
          a sp:or ;
          sp:arg1 [
              a sp:or ;
              sp:arg1 [
                  a sp:eq ;
                  sp:arg1 [
                      sp:varName "object" ;
                    ] ;
                  sp:arg2 () ;
                ] ;
              sp:arg2 [
                  a sp:and ;
                  sp:arg1 [
                      a sp:isBlank ;
                      sp:arg1 [
                          sp:varName "object" ;
                        ] ;
                    ] ;
                  sp:arg2 [
                      a sp:exists ;
                      sp:elements (
                          [
                            sp:object [
                                sp:varName "any" ;
                              ] ;
                            sp:predicate rdf:first ;
                            sp:subject [
                                sp:varName "object" ;
                              ] ;
                          ]
                        ) ;
                    ] ;
                ] ;
            ] ;
          sp:arg2 [
              a sp:eq ;
              sp:arg1 [
                  sp:varName "range" ;
                ] ;
              sp:arg2 rdf:List ;
            ] ;
        ] ;
      swa:weight 3 ;
    ] ;
  ui:prototype """
<div class=\"swa-rdf-list-editor\" let:id=\"{= ui:uniqueId() }\" let:range=\"{= COALESCE(swa:listMemberType(?predicate, ?subject), IF((?predicate = sh:in), COALESCE(swa:listMemberTypeForIn(?subject), xsd:string), ?none)) }\">
    <input name=\"keepBNodes-{= ?uid }\" type=\"hidden\" value=\"true\"/>
    <input name=\"new-{= ?uid }\" type=\"hidden\" value=\"{= ui:encodeNode(?object, true, true) }\"/>
    <ol class=\"swa-rdf-list-editor-ol\" id=\"{= ?id }-ol\">
        <ui:if ui:condition=\"{= bound(?object) }\">
            <ui:forEach ui:indexVar=\"index\" ui:resultSet=\"{#
                    SELECT ?member ?item ?rest
                    WHERE {
                        ?object (rdf:rest)* ?item .
                        ?item rdf:first ?member .
                        ?item rdf:rest ?rest .
                    } }\">
                <li class=\"swa-rdf-list-editor-li\" id=\"{= ?id }-row-{= ?index }\">
                    <swa:RDFListEditorRow arg:id=\"{= ?id }\" arg:item=\"{= ?item }\" arg:member=\"{= ?member }\" arg:range=\"{= ?range }\" arg:rest=\"{= ?rest }\"/>
                </li>
            </ui:forEach>
        </ui:if>
        <div class=\"swa-rdf-list-editor-add-button ui-icon ui-icon-plus\" id=\"{= ?id }-add-button\" onclick=\"{= ui:functionCall(&quot;swa.rdfListEditorAddRow&quot;, ?id, ui:currentQueryGraph(), ?range) }\" title=\"Add item to this list\"/>
    </ol>
</div>
"""^^ui:Literal ;
  rdfs:comment "The default editor for rdf:List objects. Presents each list member with its own edit widget, arranged vertically. Items can be moved up or down to determine the order." ;
  rdfs:label "RDF list editor" ;
  rdfs:subClassOf swa:ObjectEditor ;
.
swa:RDFListEditorRow
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:item ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The rdf:List item that has the member as its rdf:first. Unbound to create a new list item." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:range ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The declared range (for new values)." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:rest ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The next list item (rdf:rest). Unbound means rdf:nil." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:id ;
      spl:valueType xsd:string ;
      rdfs:comment "The id of the surrounding widget" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:member ;
      rdfs:comment "The list member." ;
    ] ;
  ui:prototype """
<ui:group let:item=\"{= COALESCE(?item, BNODE()) }\" let:uid=\"{= ui:uniqueId() }\">
    <div class=\"swa-rdf-list-editor-button\">
        <a class=\"ui-icon ui-icon-arrowthick-1-n\" onclick=\"swa.rdfListEditorMoveRowUp(this)\" title=\"Move up in this list\"/>
    </div>
    <div class=\"swa-rdf-list-editor-button\">
        <a class=\"ui-icon ui-icon-closethick\" onclick=\"swa.rdfListEditorDeleteRow(this)\" title=\"Remove from this list\"/>
    </div>
    <div class=\"swa-rdf-list-editor-button-separator\"/>
    <div class=\"swa-rdf-list-editor-main\" data-list-item=\"{= ui:encodeNode(?item, true, true) }\" data-list-uid=\"{= ?uid }\">
        <swa:ObjectEditorHiddenFields arg:keepBNodes=\"{= true }\" arg:newObject=\"{= COALESCE(?rest, rdf:nil) }\" arg:object=\"{= ?rest }\" arg:predicate=\"{= rdf:rest }\" arg:subject=\"{= ?item }\" arg:uid=\"{= ?uid }-rest\"/>
        <swa:ObjectEditorHiddenFields arg:keepBNodes=\"{= true }\" arg:object=\"{= ?member }\" arg:predicate=\"{= rdf:first }\" arg:subject=\"{= ?item }\" arg:uid=\"{= ?uid }\"/>
        <swa:ObjectEditor arg:object=\"{= ?member }\" arg:predicate=\"{= rdf:first }\" arg:range=\"{= ?range }\" arg:subject=\"{= ?item }\" arg:uid=\"{= ?uid }\"/>
    </div>
</ui:group>
"""^^ui:Literal ;
  ui:responseType ui:HTML ;
  rdfs:comment """Each instance of this element class represents two triples:

?item rdf:first ?member .
?item rdf:rest ?rest .

For the first item, the surrounding widget represents the triple

?subject ?predicate ?item (= ?object) where ?object may be rdf:nil.
""" ;
  rdfs:subClassOf swa:FormElements ;
.
swa:RDFListViewer
  a swa:ObjectViewerClass ;
  swa:objectWidgetWeight [
      a swa:WeightedExpression ;
      swa:expression [
          a sp:eq ;
          sp:arg1 [
              sp:varName "kind" ;
            ] ;
          sp:arg2 "list" ;
        ] ;
      swa:weight 1 ;
    ] ;
  ui:prototype """
<div class=\"swa-rdf-list-viewer\">
    <ol class=\"swa-rdf-list-viewer-ol\">
        <ui:forEach ui:resultSet=\"{#
                SELECT ?member ?item
                WHERE {
                    ?object (rdf:rest)* ?item .
                    ?item rdf:first ?member .
                } }\">
            <li class=\"swa-rdf-list-viewer-li\">
                <swa:ObjectViewer arg:object=\"{= ?member }\" arg:predicate=\"{= rdf:first }\" arg:subject=\"{= ?item }\"/>
            </li>
        </ui:forEach>
    </ol>
</div>
"""^^ui:Literal ;
  rdfs:comment "A viewer for rdf:Lists, arranging values vertically in a scrollable container." ;
  rdfs:label "RDF list viewer" ;
  rdfs:subClassOf swa:ObjectViewer ;
.
swa:RDFTypeJSON
  a ui:Service ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Resource ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:group>
    <swon:Object>
        <ui:if ui:condition=\"{= !bound(?resourceType) }\">
            <ui:setResponseHeader ui:statusCode=\"{= 422 }\"/>
            <swon:Value arg:name=\"error\">
                <swon:Object>
                    <swon:Value arg:name=\"status\" arg:value=\"422\"/>
                    <swon:Value arg:name=\"title\" arg:value=\"Invalid Parameters\"/>
                    <swon:Value arg:name=\"detail\" arg:value=\"Missing required parameter resourceType\"/>
                </swon:Object>
            </swon:Value>
        </ui:if>
        <ui:else>
            <swon:Value arg:name=\"data\">
                <swon:Array>
                    <swon:Object>
                        <swon:Value arg:name=\"value\" arg:value=\"''\"/>
                        <swon:Value arg:name=\"label\" arg:value=\"Restrict to class\"/>
                        <swon:Value arg:name=\"selected\" arg:value=\"selected\"/>
                        <swon:Value arg:name=\"disabled\" arg:value=\"{= true }\"/>
                    </swon:Object>
                    <ui:forEach ui:indexVar=\"index\" ui:resultSet=\"{#
                            SELECT DISTINCT ?value ?valueLabel
                            WHERE {
                                ?value (rdfs:subClassOf)* ?resourceType .
                                BIND (ui:label(?value) AS ?valueLabel) .
                            }
                            ORDER BY (?valueLabel) }\">
                        <swon:Object>
                            <swon:Value arg:name=\"value\" arg:value=\"{= ?value }\"/>
                            <swon:Value arg:name=\"label\" arg:value=\"{= ?valueLabel }\"/>
                            <swon:Value arg:name=\"selected\" arg:value=\"{= IF((?object = ?value), &quot;selected&quot;, ?none) }\"/>
                        </swon:Object>
                    </ui:forEach>
                </swon:Array>
            </swon:Value>
        </ui:else>
    </swon:Object>
</ui:group>
"""^^ui:Literal ;
  rdfs:label "RDFType JSON" ;
  rdfs:subClassOf ui:JSONServices ;
.
swa:RedirectAfterPost
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional false ;
      spl:predicate arg:url ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The redirect target URL." ;
    ] ;
  ui:prototype """
<ui:group>
    <ui:setResponseHeader ui:statusCode=\"{= 303 }\"/>
    <ui:setResponseHeader ui:headerName=\"Location\" ui:headerValue=\"{= ?url }\"/>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "Performs an HTTP redirect to a different URL, using the status code \"303 See Other\". This is a good practice after a successful POST request, as it prevents double POST requests when the user hits Refresh or the back button." ;
  rdfs:label "Redirect after post" ;
  rdfs:subClassOf ui:Operations ;
.
swa:RegexStringFacet
  a swa:ObjectFacetClass ;
  swa:facetSearchType search:RegexFacetValue ;
  swa:objectFacetMenuName "text matches regular expression" ;
  swa:objectWidgetWeight [
      a swa:WeightedExpression ;
      swa:expression [
          a sp:or ;
          sp:arg1 [
              a sp:not ;
              sp:arg1 [
                  a sp:bound ;
                  sp:arg1 [
                      sp:varName "range" ;
                    ] ;
                ] ;
            ] ;
          sp:arg2 [
              a swa:isDatatypeRange ;
              arg:range [
                  sp:varName "range" ;
                ] ;
            ] ;
        ] ;
      swa:weight -2 ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:group let:datatype=\"{= swa:localRange(?predicate, ?subject) }\" let:restore=\"{= swa:restoreFacetValue(?predicate) }\">
    <input class=\"{= swa:testClass(?predicate) } swa-regex-string-facet form-control\" name=\"regex{= ?uid }\" type=\"text\" value=\"{= IF(bound(?restore), spl:object(?restore, search:pattern), ?none) }\"/>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "An ObjectFacet showing a text field. The resulting string will be matched against as a regex." ;
  rdfs:label "Regex string facet" ;
  rdfs:subClassOf swa:ObjectFacet ;
.
swa:RelationshipTreePage
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:root ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The root of the tree" ;
    ] ;
  ui:headIncludes """
<ui:group>
    <title>Property Relationship Tree</title>
    <meta content=\"IE=Edge,chrome=1\" http-equiv=\"X-UA-Compatible\"/>
    <link href=\"{= ui:lib() }/assets/lib/d3/css/d3Tree.css\" rel=\"stylesheet\" type=\"text/css\"/>
    <script src=\"{= ui:lib() }/assets/lib/d3/d3.min.js\"/>
    <script src=\"{= ui:lib() }/assets/lib/d3/js/d3Tree.js\"/>
</ui:group>
"""^^ui:Literal ;
  ui:prototype """
<ui:group>
    <!--ui:dumpScope ui:message=\"AAA1: swa:RelationshipTreePage\"/-->
    <div class=\"swa-relationship-tree-page-relationship\">
        <ui:call arg:root=\"{= ?root }\" ui:template=\"{= swa:GetRelationshipTreeProperties }\" ui:varName=\"properties\">
            <!--ui:dumpResultSet ui:message=\"AAA2: swa:RelationshipTreePage\" ui:resultSet=\"{= ?properties }\"/-->
            <span>Relationship: </span>
            <select class=\"form-control vocabSelect\" id=\"propertySelect\">
                <option/>
                <ui:forEach ui:resultSet=\"{= ?properties }\">
                    <option data-inverse=\"{= ?inverse }\" value=\"{= ?property }\">{= CONCAT(ui:label(?property), IF(?inverse, \" (inverse)\", \"\")) }</option>
                </ui:forEach>
            </select>
        </ui:call>
        <script>$(\"#propertySelect\").change(function(e){if($(this).val()) { swa.load(\"tree\", { relationship : \"&lt;\" + $(this).val() + \"&gt;\", inverse : \"'\"+ $('option:selected', this).attr('data-inverse') + \"'\"  })}});</script>
    </div>
    <ui:loadable ui:loadId=\"tree\" ui:loadOnDemand=\"{= true }\">
        <ui:group let:isInverted=\"{= IF((?inverse = &quot;undefined&quot;), false, xsd:boolean(?inverse)) }\">
            <ui:group let:hasLink=\"{= swa:resourceIsSubjectOrObject(?isInverted, ?relationship, ?root) }\">
                <!--ui:dumpScope ui:message=\"AAA3: swa:RelationshipTreePage\"/-->
                <ui:if ui:condition=\"{= ?hasLink }\">
                    <div id=\"svg\"/>
                    <ui:createLink arg:inverse=\"{= ?isInverted }\" arg:relationship=\"{= ?relationship }\" arg:root=\"{= ?root }\" ui:sendQueryGraph=\"{= true }\" ui:viewClass=\"{= swa:JSONDataForSpanningTree }\">
                        <script>d3Tree.init();
			d3.json(\"{= ?link }\").then( function(data){
 				d3Tree.flareFunction(null,data);}).
  				catch(function(err){console.log(err)
  				d3Tree.flareFunction(err,null);})
			d3.select(self.frameElement).style(\"height\", \"800px\");</script>
                    </ui:createLink>
                </ui:if>
                <ui:else>
                    <div class=\"row\">
                        <div class=\"col-xs-6 col-xs-offset-1 col1\">
                            <ui:if ui:condition=\"{= ?isInverted }\">
                                <p class=\"text-info\">
                                    <b>{= ui:label(?root) }</b> is not being referred to by any resources using the property&nbsp;<b>{= ui:label(?relationship) }</b>.</p>
                            </ui:if>
                            <ui:else>
                                <p class=\"text-info\">
                                    <b>{= ui:label(?root) }</b> has no values for the property&nbsp;<b>{= ui:label(?relationship) }</b>.</p>
                            </ui:else>
                        </div>
                    </div>
                    <script>d3Tree.clear();</script>
                </ui:else>
            </ui:group>
        </ui:group>
    </ui:loadable>
</ui:group>
"""^^ui:Literal ;
  ui:responseType ui:HTML ;
  rdfs:comment "d3.json(\"{= ?link }\", d3Tree.flareFunction);" ;
  rdfs:subClassOf swa:ScriptElements ;
.
swa:RequireJSLibrary
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:path ;
      spl:valueType xsd:string ;
      rdfs:comment "The relative path (after lib/) of the JS file." ;
    ] ;
  ui:prototype """
<script>swa.requireJSLibrary('{= ui:lib() }/{= ?path }');</script>
"""^^ui:Literal ;
  rdfs:comment "Makes sure that the head of the HTML document has a <script> tag importing a given library." ;
  rdfs:label "Require JS library" ;
  rdfs:subClassOf swa:ScriptElements ;
.
swa:ResourceAction
  a rdfs:Class ;
  rdfs:comment """An action that can be applied to a given Resource, e.g. the selected node of a tree or the subject on a form. In the executing JavaScript, the variable resourceURI points to the URI of the selected resource from the menu.

Note that when selecting suitable actions, the execution engine will evaluate the condition on the ui:unionGraph, which may include more triples than expected by the engine. The expression may want to switch to the current domain model using ui:currentQueryGraph() instead.""" ;
  rdfs:label "Resource action" ;
  rdfs:subClassOf swa:Action ;
.
swa:ResourceActions
  a spin:SelectTemplate ;
  spin:body [
      a sp:Select ;
      sp:orderBy (
          [
            sp:varName "group" ;
          ]
          [
            sp:varName "label" ;
          ]
        ) ;
      sp:resultVariables (
          [
            sp:varName "actionName" ;
          ]
          [
            sp:varName "actionLocalName" ;
          ]
          [
            sp:varName "onSelect" ;
          ]
          [
            sp:varName "enabled" ;
          ]
          [
            sp:varName "group" ;
          ]
          [
            sp:varName "label" ;
          ]
          [
            sp:varName "iconClass" ;
          ]
        ) ;
      sp:where (
          [
            a sp:NamedGraph ;
            sp:elements (
                (
                  [
                    sp:object [
                        sp:varName "optionsType" ;
                      ] ;
                    sp:predicate rdf:type ;
                    sp:subject [
                        sp:varName "action" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "label" ;
                      ] ;
                    sp:predicate rdfs:label ;
                    sp:subject [
                        sp:varName "action" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "condition" ;
                      ] ;
                    sp:predicate arg:condition ;
                    sp:subject [
                        sp:varName "action" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression [
                        a ui:encodeNode ;
                        sp:arg1 [
                            sp:varName "action" ;
                          ] ;
                      ] ;
                    sp:variable [
                        sp:varName "actionName" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression [
                        a afn:localname ;
                        sp:arg1 [
                            sp:varName "action" ;
                          ] ;
                      ] ;
                    sp:variable [
                        sp:varName "actionLocalName" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression [
                        a spl:object ;
                        sp:arg1 [
                            sp:varName "action" ;
                          ] ;
                        sp:arg2 arg:onSelect ;
                      ] ;
                    sp:variable [
                        sp:varName "onSelectRaw" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression [
                        a sp:coalesce ;
                        sp:arg1 [
                            sp:varName "onSelectRaw" ;
                          ] ;
                        sp:arg2 [
                            a sp:if ;
                            sp:arg1 [
                                a swa:hasOtherArgument ;
                                spl:class [
                                    sp:varName "action" ;
                                  ] ;
                              ] ;
                            sp:arg2 [
                                a sp:concat ;
                                sp:arg1 "swa.openHandlerDialog(\"" ;
                                sp:arg2 [
                                    a ui:escapeJSON ;
                                    sp:arg1 [
                                        sp:varName "label" ;
                                      ] ;
                                  ] ;
                                sp:arg3 "\", \"<" ;
                                sp:arg4 [
                                    a xsd:string ;
                                    sp:arg1 [
                                        sp:varName "action" ;
                                      ] ;
                                  ] ;
                                sp:arg5 ">\", \"" ;
                                sp:arg6 [
                                    a ui:escapeJSON ;
                                    sp:arg1 [
                                        a xsd:string ;
                                        sp:arg1 [
                                            sp:varName "resource" ;
                                          ] ;
                                      ] ;
                                  ] ;
                                sp:arg7 "\")" ;
                              ] ;
                            sp:arg3 [
                                sp:varName "none" ;
                              ] ;
                          ] ;
                      ] ;
                    sp:variable [
                        sp:varName "onSelect" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression [
                        a sp:coalesce ;
                        sp:arg1 [
                            a spl:object ;
                            sp:arg1 [
                                sp:varName "action" ;
                              ] ;
                            sp:arg2 arg:group ;
                          ] ;
                        sp:arg2 "" ;
                      ] ;
                    sp:variable [
                        sp:varName "group" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression [
                        a spl:object ;
                        sp:arg1 [
                            sp:varName "action" ;
                          ] ;
                        sp:arg2 arg:iconClass ;
                      ] ;
                    sp:variable [
                        sp:varName "iconClass" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression [
                        a spl:object ;
                        sp:arg1 [
                            sp:varName "action" ;
                          ] ;
                        sp:arg2 arg:appName ;
                      ] ;
                    sp:variable [
                        sp:varName "actionAppName" ;
                      ] ;
                  ]
                  [
                    a sp:Filter ;
                    sp:expression [
                        a sp:if ;
                        sp:arg1 [
                            a sp:bound ;
                            sp:arg1 [
                                sp:varName "actionAppName" ;
                              ] ;
                          ] ;
                        sp:arg2 [
                            a sp:and ;
                            sp:arg1 [
                                a sp:not ;
                                sp:arg1 [
                                    a swa:hasExcludedAppName ;
                                    arg:action [
                                        sp:varName "action" ;
                                      ] ;
                                    arg:appName [
                                        sp:varName "appName" ;
                                      ] ;
                                  ] ;
                              ] ;
                            sp:arg2 [
                                a swa:hasAppName ;
                                sp:arg1 [
                                    sp:varName "appName" ;
                                  ] ;
                                sp:arg2 [
                                    sp:varName "actionAppName" ;
                                  ] ;
                              ] ;
                          ] ;
                        sp:arg3 [
                            a sp:or ;
                            sp:arg1 [
                                a sp:not ;
                                sp:arg1 [
                                    a sp:bound ;
                                    sp:arg1 [
                                        sp:varName "appName" ;
                                      ] ;
                                  ] ;
                              ] ;
                            sp:arg2 [
                                a sp:eq ;
                                sp:arg1 [
                                    sp:varName "appName" ;
                                  ] ;
                                sp:arg2 "" ;
                              ] ;
                          ] ;
                      ] ;
                  ]
                  [
                    a sp:Filter ;
                    sp:expression [
                        a sp:or ;
                        sp:arg1 [
                            a sp:or ;
                            sp:arg1 [
                                a sp:not ;
                                sp:arg1 [
                                    a sp:bound ;
                                    sp:arg1 [
                                        sp:varName "readOnly" ;
                                      ] ;
                                  ] ;
                              ] ;
                            sp:arg2 [
                                a sp:not ;
                                sp:arg1 [
                                    sp:varName "readOnly" ;
                                  ] ;
                              ] ;
                          ] ;
                        sp:arg2 [
                            a spl:object ;
                            sp:arg1 [
                                sp:varName "action" ;
                              ] ;
                            sp:arg2 swa:readOnly ;
                          ] ;
                      ] ;
                  ]
                )
                [
                  a sp:Bind ;
                  sp:expression [
                      a spin:evalInGraph ;
                      sp:arg1 [
                          sp:varName "condition" ;
                        ] ;
                      sp:arg2 [
                          a ui:currentQueryGraph ;
                        ] ;
                      sp:arg3 arg:resource ;
                      sp:arg4 [
                          sp:varName "resource" ;
                        ] ;
                      sp:arg5 arg:desktopId ;
                      sp:arg6 [
                          sp:varName "desktopId" ;
                        ] ;
                    ] ;
                  sp:variable [
                      sp:varName "enabled" ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode ui:graph ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:bound ;
                sp:arg1 [
                    sp:varName "enabled" ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:appName ;
      spl:valueType xsd:string ;
      rdfs:comment "The current app name." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:desktopId ;
      spl:valueType xsd:string ;
      rdfs:comment "The id of an swa:Desktop in the surrounding application. Unbound if no desktop exists. This can be used to activate certain actions that require a desktop to be present." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:optionsType ;
      spl:valueType rdfs:Class ;
      rdfs:comment """Determines which options should be returned based on button clicked.
""" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:readOnly ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to exclude editing actions." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The Resource to get the actions for." ;
    ] ;
  spin:private true ;
  rdfs:label "Resource actions" ;
  rdfs:subClassOf spin:SelectTemplates ;
.
swa:ResourceActionsButton
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:class ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional CSS class for the button." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:editable ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to include the edit actions." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:id ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional id for the button." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to apply the action(s) on. If left blank, then a getter expression must be provided." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:resourceGetter ;
      spl:valueType xsd:string ;
      rdfs:comment "A JavaScript expression that is evaluated to return the URI of the selected resource." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:toolTip ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional tool tip text to appear on the button." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resourceSelectedEvent ;
      spl:valueType xsd:string ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:group let:id=\"{= COALESCE(?id, ui:uniqueId()) }\">
    <button class=\"swa-button swa-resource-actions-button {= ?class }\" id=\"{= ?id }\" onclick=\"swa.openResourceActionsMenu('{= ?id }', '{= IF(bound(?resourceGetter), ?resourceGetter, CONCAT(&quot;\\&quot;&quot;, swa:unwrap(ui:encodeNode(?resource, true, true)), &quot;\\&quot;&quot;)) }', '{= ui:currentQueryGraph() }', '{= swa:appName() }', '{= ui:contextValue(&quot;swaCanDeleteResourceFunction&quot;) }', {= IF(bound(?editable), (!?editable), false) }, '{= ?resourceSelectedEvent }')\" title=\"{= ?toolTip }\">
        <div class=\"ui-icon ui-icon-gear\"/>
    </button>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "A Button displaying a popup menu when pressed, consisting of ResourceActions for a given resource. The resource is either a constant or delivered dynamically through a (JavaScript) getter expression." ;
  rdfs:label "Resource actions button" ;
  rdfs:subClassOf swa:MenuElements ;
.
swa:ResourceActionsCallback
  a ui:JSONService ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:appName ;
      spl:valueType xsd:string ;
      rdfs:comment "The current app name to narrow down the results." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:desktopId ;
      spl:valueType xsd:string ;
      rdfs:comment "See swa:ResourceActions." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:optionsType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "Determines which options to return based on which button was pushed" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:readOnly ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to exclude actions that are editing." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to get the actions of." ;
    ] ;
  ui:prototype """
<ui:call arg:appName=\"{= ?appName }\" arg:desktopId=\"{= ?desktopId }\" arg:optionsType=\"{= ?optionsType }\" arg:readOnly=\"{= ?readOnly }\" arg:resource=\"{= ?resource }\" ui:template=\"{= swa:ResourceActions }\">
    <swon:RSObjectArray arg:resultSet=\"{= ?rs }\"/>
</ui:call>
"""^^ui:Literal ;
  rdfs:label "Resource actions callback" ;
  rdfs:subClassOf swa:MenuElements ;
  rdfs:subClassOf ui:JSONServices ;
.
swa:ResourceDestructor
  a swa:Destructor ;
  ui:prototype """
<ui:if ui:condition=\"{= NOT EXISTS {
    GRAPH ui:tempGraph {
        swa:DestructorMetadata swa:visited ?resource .
    } .
} }\">
    <ui:update ui:updateQuery=\"{!
            INSERT {
                GRAPH ui:tempGraph {
                    swa:DestructorMetadata swa:visited ?resource .
                } .
            }
            WHERE {
            } }\"/>
    <ui:resourceView ui:matchIds=\"destructor\" ui:resource=\"{= ?resource }\"/>
</ui:if>
"""^^ui:Literal ;
  rdfs:comment "A helper element that can be used to collect all triples that need to be deleted if a given resource is to be deleted. This remembers metadata about whether it has already \"seen\" a given resource, thus avoiding infinite loops." ;
  rdfs:label "Resource destructor" ;
  rdfs:subClassOf swa:Destructors ;
.
swa:ResourceEditHandlers
  a swa:EditHandlerClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to execute the action on." ;
    ] ;
  rdfs:label "Resource edit handlers" ;
  rdfs:subClassOf swa:EditHandlers ;
.
swa:ResourceEnumDropDownEditor
  a swa:ObjectEditorClass ;
  ui:private true ;
  ui:prototype """
<swa:AbstractEnumDropDownEditor ui:args=\"*\"/>
"""^^ui:Literal ;
  rdfs:label "Resource enum drop down editor" ;
  rdfs:subClassOf swa:AbstractEnumDropDownEditor ;
.
swa:ResourceEnumDropDownFacet
  a swa:ObjectFacetClass ;
  swa:facetSearchType search:ObjectFacetValue ;
  swa:objectFacetMenuName "drop down list" ;
  swa:objectWidgetWeight [
      a swa:WeightedExpression ;
      swa:expression [
          a sp:and ;
          sp:arg1 [
              a sp:bound ;
              sp:arg1 [
                  sp:varName "range" ;
                ] ;
            ] ;
          sp:arg2 [
              a swa:isResourceEnumeration ;
              arg:resource [
                  sp:varName "range" ;
                ] ;
            ] ;
        ] ;
      swa:weight 3 ;
    ] ;
  ui:private true ;
  ui:prototype """
<swa:AbstractEnumDropDownFacet ui:args=\"*\"/>
"""^^ui:Literal ;
  rdfs:label "Resource enum drop down facet" ;
  rdfs:subClassOf swa:AbstractEnumDropDownFacet ;
.
swa:ResourceEnumRadioButtonsEditor
  a swa:ObjectEditorClass ;
  swa:objectWidgetWeight [
      a swa:WeightedExpression ;
      swa:expression [
          a sp:and ;
          sp:arg1 [
              a sp:bound ;
              sp:arg1 [
                  sp:varName "range" ;
                ] ;
            ] ;
          sp:arg2 [
              a swa:isResourceEnumeration ;
              arg:resource [
                  sp:varName "range" ;
                ] ;
            ] ;
        ] ;
      swa:weight 6 ;
    ] ;
  ui:private true ;
  ui:prototype """
<swa:AbstractRadioButtonsEditor ui:args=\"*\"/>
"""^^ui:Literal ;
  rdfs:label "Resource enum radio buttons editor" ;
  rdfs:subClassOf swa:AbstractRadioButtonsEditor ;
.
swa:ResourceFormBody
  a ui:ResourceViewClass ;
  ui:private true ;
  ui:prototype """
<ui:group>
    <ui:call arg:subject=\"{= ?resource }\" ui:template=\"{= swa:modeProperty(swa:formObjectPredicateSelectionTemplate) }\">
        <swa:ObjectsGroup arg:filterFunction=\"{= swa:isAnnotationProperty }\" arg:label=\"Annotations\" arg:predicates=\"{= ?rs }\" arg:subject=\"{= ?resource }\"/>
        <swa:ObjectsGroup arg:filterFunction=\"{= swa:isNonAnnotationProperty }\" arg:label=\"Properties\" arg:predicates=\"{= ?rs }\" arg:subject=\"{= ?resource }\"/>
    </ui:call>
    <swa:ObjectsPlaceholder arg:label=\"Other Properties\" arg:shapeSectionAbove=\"{= true }\" arg:subject=\"{= ?resource }\"/>
    <ui:call arg:object=\"{= ?resource }\" ui:template=\"{= swa:modeProperty(swa:formSubjectPredicateSelectionTemplate) }\">
        <swa:SubjectsGroup arg:label=\"Incoming References\" arg:object=\"{= ?resource }\" arg:predicates=\"{= ?rs }\"/>
    </ui:call>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "The default view for rdfs:Resource, with widget groups for Annotation Properties and Other Properties." ;
  rdfs:label "Resource form body" ;
  rdfs:subClassOf swa:FormBody ;
.
swa:ResourceInUIGraphViewer
  a swa:ObjectViewerClass ;
  ui:prototype """
<div class=\"swa-shifted-label\">{= swa:labelInGraph(?object, ui:graph) }</div>
"""^^ui:Literal ;
  rdfs:comment "A viewer that switches to the ui:graph to retrieve the object's label." ;
  rdfs:label "Resource in ui:graph viewer" ;
  rdfs:subClassOf swa:ObjectViewer ;
.
swa:ResourceQname
  a ui:Service ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
    ] ;
  ui:errorPrototype """
<ui:if ui:condition=\"{= !bound(?resource) }\">
    <ui:setResponseHeader ui:statusCode=\"{= 422 }\"/>
</ui:if>
"""^^ui:Literal ;
  ui:private false ;
  ui:prototype """
<swon:Object>
    <swon:Value arg:name=\"qname\" arg:value=\"{= smf:qname(?resource) }\"/>
    <swon:Value arg:name=\"label\" arg:value=\"{= ui:label(?resource) }\"/>
    <swon:Value arg:name=\"uri\" arg:value=\"{= str(?resource) }\"/>
</swon:Object>
"""^^ui:Literal ;
  ui:responseType ui:JSON ;
  rdfs:label "Resource qname" ;
  rdfs:subClassOf ui:JSONServices ;
.
swa:ResourceSelectionDialog
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:label ;
      spl:valueType xsd:string ;
      rdfs:comment "The label of the dialog." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:callback ;
      spl:valueType xsd:string ;
      rdfs:comment "A callback expression to invoke when the resource has been selected. The variable 'resource' will contain the selected resource, and 'label' its label." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:loadId ;
      spl:valueType xsd:string ;
      rdfs:comment "The ui:loadId of the resulting ui:loadable." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The type of resources to select." ;
    ] ;
  ui:private true ;
  ui:prototype """
<div id=\"div-{= ?loadId }\" title=\"{= COALESCE(?label, fn:concat(&quot;Select &quot;, ui:label(?resourceType))) }\">
    <swa:LabeledElement arg:label=\"{= ui:label(?resourceType) }\">
        <swa:AutoComplete arg:id=\"{= ui:uniqueId() }\" arg:onSelect=\"swa.closeDialog(&quot;{= ?loadId }&quot;);eval({= ?callback });\" arg:type=\"{= ?resourceType }\"/>
    </swa:LabeledElement>
    <div class=\"swa-dialog-button-bar\">
        <button class=\"btn btn-default btn-xs\" onclick=\"swa.closeDialog('{= ?loadId }')\">Cancel</button>
    </div>
</div>
"""^^ui:Literal ;
  rdfs:comment "A dialog that can be used to select a single resource with a given type. Currently only shows an auto-complete box, but future versions may also have a tree of classes and a grid of instances per class." ;
  rdfs:label "Resource selection dialog" ;
  rdfs:subClassOf swa:DialogElements ;
.
swa:ResourceSubjectEditor
  a swa:SubjectEditorClass ;
  swa:subjectWidgetWeight [
      a swa:WeightedExpression ;
      swa:expression [
          a sp:or ;
          sp:arg1 [
              a sp:not ;
              sp:arg1 [
                  a sp:bound ;
                  sp:arg1 [
                      sp:varName "subject" ;
                    ] ;
                ] ;
            ] ;
          sp:arg2 [
              a sp:isIRI ;
              sp:arg1 [
                  sp:varName "subject" ;
                ] ;
            ] ;
        ] ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:group let:domain=\"{= swa:localDomain(?object, ?predicate) }\">
    <swa:AutoComplete arg:class=\"swa-auto-complete-text\" arg:id=\"new-{= ?uid }\" arg:initialValue=\"{= ?subject }\" arg:placeholder=\"{= IF(bound(?domain), CONCAT(&quot;Select &quot;, ui:label(?domain)), ?none) }\" arg:type=\"{= ?domain }\" arg:withSelectMenu=\"{= true }\"/>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "A SubjectEditor based on an AutoComplete widget." ;
  rdfs:label "Resource subject editor" ;
  rdfs:subClassOf swa:SubjectEditor ;
.
swa:ResourceSubjectFacet
  a swa:SubjectFacetClass ;
  swa:facetSearchType search:ObjectFacetValue ;
  swa:subjectFacetMenuName "equals" ;
  swa:subjectWidgetWeight [
      a swa:WeightedExpression ;
      swa:expression [
          a swa:hasMatchingInverseRestoreFacetValue ;
          arg:facetClass swa:ResourceSubjectFacet ;
          arg:property [
              sp:varName "predicate" ;
            ] ;
        ] ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:group let:domain=\"{= swa:localDomain(?none, ?predicate) }\" let:restore=\"{= swa:restoreInverseFacetValue(?predicate) }\">
    <swa:AutoComplete arg:id=\"value{= ?uid }\" arg:initialValue=\"{= IF(bound(?restore), spl:object(?restore, search:object), ?none) }\" arg:placeholder=\"{= IF(bound(?domain), CONCAT(&quot;Select &quot;, ui:label(?domain)), ?none) }\" arg:type=\"{= ?domain }\"/>
</ui:group>
"""^^ui:Literal ;
  rdfs:label "Resource subject facet" ;
  rdfs:subClassOf swa:SubjectFacet ;
.
swa:ResourceSummary
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:defaultImage ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "An optional default image to be used if no swa:summaryImage can be found." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to display." ;
    ] ;
  ui:prototype """
<table class=\"swa-resource-summary\" let:searchGraph=\"{= ui:contextValue(&quot;searchGraph&quot;) }\">
    <tr let:description=\"{= swa:getDescription(?this) }\" let:image=\"{= COALESCE(swa:getThumbnail(?this), ?defaultImage) }\">
        <td class=\"swa-resource-summary-subject\" default:subject=\"{= ?this }\">
            <div class=\"swa-title\">{= ui:label(?this) }</div>
            <ui:if ui:condition=\"{= bound(?description) }\">
                <ui:if ui:condition=\"{= datatype(?description) = rdf:HTML }\">
                    <div class=\"swa-resource-summary-description\">
                        <ui:parse ui:str=\"{= ?description }\"/>
                    </div>
                </ui:if>
                <ui:else>
                    <div class=\"swa-resource-summary-description\">{= swa:abbreviatedText(?description, 150) }</div>
                </ui:else>
            </ui:if>
            <ui:if ui:condition=\"{= bound(?searchGraph) }\">
                <ui:forEach ui:resultSet=\"{#
                        SELECT ?property
                        WHERE {
                            ?searchGraph search:columnPropertiesFromTheSearch ?property .
                        } }\">
                    <swa:Objects arg:predicate=\"{= ?property }\" arg:subject=\"{= ?this }\"/>
                </ui:forEach>
            </ui:if>
        </td>
        <ui:if ui:condition=\"{= bound(?image) }\">
            <td class=\"swa-resource-summary-image-cell\" valign=\"top\">
                <img alt=\"Summary\" class=\"swa-resource-summary-image\" src=\"{= ?image }\"/>
            </td>
        </ui:if>
    </tr>
</table>
"""^^ui:Literal ;
  rdfs:comment "The default summary view (in particular used by swa:SummarySearchResultsGadget)." ;
  rdfs:label "Resource summary" ;
  rdfs:subClassOf ui:ResourceViews ;
.
swa:ResourceTooltipData
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to get tooltip data for" ;
    ] ;
  ui:prototype """
<section let:description=\"{= swa:getDescription(?resource) }\" let:homeGraph=\"{= smf:definedIn(?resource) }\">
    <ui:if ui:condition=\"{= bound(?homeGraph) }\">
        <p>
		Defined in: <b>{= ui:label(IRI(?homeGraph)) }</b>
        </p>
    </ui:if>
    <ui:if ui:condition=\"{= bound(?description) }\">
        <ui:if ui:condition=\"{= datatype(?description) = rdf:HTML }\">
            <ui:parse ui:str=\"{= swa:redirectHRefs(?description) }\"/>
        </ui:if>
        <ui:else>
            <p>{= swa:abbreviatedText(?description, 300) }</p>
        </ui:else>
    </ui:if>
    <ui:else>
        <p>No description available</p>
    </ui:else>
</section>
"""^^ui:Literal ;
  ui:responseType ui:HTML ;
  rdfs:subClassOf swa:Elements ;
.
swa:ResourceViewDialog
  a ui:NodeClass ;
  a owl:DeprecatedClass ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:loadId ;
      spl:valueType xsd:string ;
      rdfs:comment "The ui:loadId of the ui:loadable that will be placed around the dialog." ;
    ] ;
  ui:prototype """
<ui:loadable ui:loadId=\"{= ?loadId }\">
    <ui:if ui:condition=\"{= bound(?resource) }\">
        <div id=\"div-{= ?loadId }\" title=\"{= ui:label(?resource) }\">
            <ui:setContext ui:varName=\"createLinkFunction\" ui:varValue=\"{= swa:createNoLink }\">
                <ui:resourceView ui:resource=\"{= ?resource }\"/>
            </ui:setContext>
        </div>
    </ui:if>
</ui:loadable>
"""^^ui:Literal ;
  rdfs:comment "A dialog that shows the default view of a given resource. This needs to be inserted into the document and will remain initially invisible. The JavaScript call swa.openResourceViewDialog() must be called with the provided loadId and the URI of a resource." ;
  rdfs:label "Resource view dialog" ;
  rdfs:subClassOf swa:DialogElements ;
.
swa:ResultSetGrid
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:additionalClasses ;
      spl:valueType xsd:string ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:colWidths ;
      spl:valueType xsd:string ;
      rdfs:comment "A comma-separated list of integers, one for each column, to be used as width." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:dtType ;
      spl:valueType xsd:string ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:exports ;
      spl:valueType xsd:boolean ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:height ;
      spl:valueType xsd:string ;
      rdfs:comment "The height of the grid. Can be set as number (of pixels) or as percentage (only 100% is acceped) or \"auto\" (which is the default)." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:hiddenColName ;
      spl:valueType xsd:string ;
      rdfs:comment "The (optional) name of a column that shall be hidden. This can be used to store a pointer to a resource while the visible columns contain literal values. The invisible column can still be queried in the onSelect handler. In a typical set up, the hidden column is used to represent the URI of a resource, while other properties of that resource are being displayed. For this to work, the usual design pattern is to have a result set where the first column is computed as in BIND (xsd:string(?resource) AS ?resourceURI) and arg:hiddenColName=\"resourceURI\". If the hidden column is a resource, it will be converted to a human-readable label and then not work as expected." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:onlyExportVisibleColumns ;
      spl:valueType xsd:boolean ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:resourceSelectedEvent ;
      spl:valueType xsd:string ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:rowCount ;
      spl:valueType xsd:integer ;
      rdfs:comment "The maximum number of rows to display (page size). Defaults to 10." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:tableId ;
      spl:valueType xsd:string ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resultSet ;
      spl:valueType sp:Select ;
      rdfs:comment "The SPARQL ResultSet to display. Note that columns should not be called ?id to avoid a conflict inside of the jqGrid API." ;
    ] ;
  ui:prototype """
<ui:group let:pagerId=\"{= ui:uniqueId() }\" let:tableId=\"{= COALESCE(?tableId, ui:uniqueId()) }\" letrs:cols=\"{#
        SELECT ?colName
        WHERE {
            ?resultSet spr:colIndices ?colIndex .
            BIND (spr:colName(?resultSet, ?colIndex) AS ?colName) .
            FILTER ((!bound(?hiddenColName)) || (?colName != ?hiddenColName)) .
        } }\">
    <ui:bind>
        <ui:stringify ui:varName=\"columnData\">
            <ui:group>
                <ui:if ui:condition=\"{= bound(?cols) }\">
                    <swon:Array>
                        <swon:Object>
                            <swon:Value arg:name=\"title\" arg:value=\"uri\"/>
                            <swon:Value arg:name=\"data\" arg:value=\"uri\"/>
                            <swon:Value arg:name=\"type\" arg:value=\"uri\"/>
                            <swon:Value arg:name=\"defaultContent\" arg:value=\"\"/>
                            <swon:Value arg:name=\"visible\" arg:value=\"{= false }\"/>
                        </swon:Object>
                        <ui:forEach ui:resultSet=\"{= ?cols }\">
                            <swon:Object>
                                <swon:Value arg:name=\"title\" arg:value=\"{= ui:label(?colName) }\"/>
                                <swon:Value arg:name=\"data\" arg:value=\"{= ui:label(?colName) }\"/>
                                <swon:Value arg:name=\"type\" arg:value=\"{= ui:label(?colName) }\"/>
                                <swon:Value arg:name=\"defaultContent\" arg:value=\"\"/>
                            </swon:Object>
                        </ui:forEach>
                    </swon:Array>
                </ui:if>
                <ui:else>
                    <swon:Object/>
                </ui:else>
            </ui:group>
        </ui:stringify>
        <ui:stringify ui:varName=\"resultSetData\">
            <swon:RSObjectArray arg:resultSet=\"{= ?resultSet }\"/>
        </ui:stringify>
        <div class=\"table-container {= ?additionalClasses }\" data-column-data=\"{= ?columnData }\" data-data-data=\"{= ?resultSetData }\" data-datatable=\"true\" data-datatable-type=\"{= COALESCE(?dtType, &quot;resultSet&quot;) }\" data-editable=\"{= COALESCE(?editable, false) }\" data-endpoint=\"{= COALESCE(?dataEndpoint, swa:DataTableSearchResultsCallback) }\" data-from-dom=\"true\" data-has-exports=\"{= COALESCE(?exports, ?nil) }\" data-has-filter=\"{= COALESCE(?filter, ?nil) }\" data-has-select-all=\"{= COALESCE(?selectAll, ?nil) }\" data-hide-if-empty=\"{= COALESCE(?hideIfEmpty, ?nil) }\" data-only-export-visible-columns=\"{= COALESCE(?onlyExportVisibleColumns, ?nil) }\" data-page-length=\"{= COALESCE(?pageLength, ?nil) }\" data-resource-selected-event=\"{= ?resourceSelectedEvent }\" data-resource-type=\"{= COALESCE(?resourceType, ?nil) }\" data-search-graph=\"{= COALESCE(?searchGraph, ?nil) }\" data-suppress-label-column=\"{= ?suppressLabelColumn }\" id=\"{= ?tableId }\"/>
        <div class=\"ui-helper-hidden-accessible\">None</div>
        <script>gadgets.Hub.publish('org.topbraid.swa.rebuildTable', '{= ?tableId }');</script>
    </ui:bind>
</ui:group>
"""^^ui:Literal ;
  ui:responseType ui:JSON ;
  rdfs:comment """A tabular component to display the results of an existing SPARQL result set. This component does not do lazy loading but constructs a static data table from all entries in the result set. Use this only for small data sets.

If the result set has been created from a SPIN template (via ui:call) then the grid will look up the spin:column metadata attached to the template to learn about column titles, width and alignment (numeric columns are right-aligned).

WARNING: due to a bug you cannot use ?id as a column variable.""" ;
  rdfs:label "Result Set Grid" ;
  rdfs:subClassOf swa:GridElements ;
.
swa:ResultSetLinkList
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:class ;
      spl:valueType xsd:string ;
      rdfs:comment "An additional CSS class for the generated div." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:id ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional HTML id for the generated div." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resultSet ;
      spl:valueType sp:Select ;
      rdfs:comment "The SPARQL ResultSet to display." ;
    ] ;
  ui:prototype """
<div class=\"swa-result-set-link-list {= ?class }\" id=\"{= ?id }\">
    <ui:call arg:resultSet=\"{= ?resultSet }\" ui:template=\"{= swon:ForEachResultSetRowIndex }\">
        <ui:forEach ui:resultSet=\"{= ?rs }\">
            <div class=\"swa-result-set-link-item\">
                <swa:Link arg:resource=\"{= spr:cell(?resultSet, ?rowIndex, 0) }\"/>
            </div>
        </ui:forEach>
    </ui:call>
</div>
"""^^ui:Literal ;
  rdfs:comment "A list of vertically stacked hyperlinks to the resources from a result set. Each entry is a div with a hyperlink around the most suitable view with matchId=\"label\". Individual instances can therefore be displayed in a customized rendering, as long as they define an SWP view with ui:id=\"label\". By default this is simply the ui:label of each resource (see rdfs:Resource in SWA)." ;
  rdfs:label "Result set link list" ;
  rdfs:subClassOf swa:ListElements ;
.
swa:ResultSetObjectsView
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:label ;
      spl:valueType xsd:string ;
      rdfs:comment "The label to display on the left." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:toolTip ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional tool tip to appear over the label." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resultSet ;
      spl:valueType sp:Select ;
      rdfs:comment "The result set of values to display. The first column will be used only." ;
    ] ;
  ui:prototype """
<table class=\"swa-labeled-objects-table\" let:id=\"{= ui:uniqueId() }\">
    <tr>
        <td class=\"swa-labeled-objects-label-td swa-labeled-objects-tabular-label\">
            <div class=\"swa-shifted-label\">
                <label for=\"{= ?id }\" title=\"{= ?toolTip }\">{= ?label }</label>
            </div>
        </td>
        <td class=\"swa-labeled-objects-icons-td\">
            <span class=\"swa-icon\"/>
        </td>
        <td class=\"swa-labeled-objects-body-td\" id=\"{= ?id }\">
            <div>
                <ui:forEach ui:resultSet=\"{#
                        SELECT ?rowIndex
                        WHERE {
                            ?resultSet spr:rowIndices ?rowIndex .
                        } }\">
                    <div class=\"swa-object-row\">
                        <swa:ObjectViewer arg:object=\"{= spr:cell(?resultSet, ?rowIndex, 0) }\" arg:predicate=\"{= swa:nonExistingDummyProperty }\"/>
                    </div>
                </ui:forEach>
            </div>
        </td>
    </tr>
</table>
"""^^ui:Literal ;
  rdfs:comment "A widget that looks like swa:Objects but with its objects taken from a result set, not a subject/property combination. The widget displays a label on the left and rows of object views on the right. It uses the same logic for widget selection like swa:Objects, but only for view mode and not editing." ;
  rdfs:label "Result set objects view" ;
  rdfs:subClassOf swa:FormElements ;
.
swa:RichTextViewer
  a swa:ObjectViewerClass ;
  swa:objectWidgetWeight [
      a swa:WeightedExpression ;
      swa:expression [
          a sp:and ;
          sp:arg1 [
              a sp:eq ;
              sp:arg1 [
                  sp:varName "kind" ;
                ] ;
              sp:arg2 "literal" ;
            ] ;
          sp:arg2 [
              a sp:or ;
              sp:arg1 [
                  a spl:subPropertyOf ;
                  sp:arg1 [
                      sp:varName "predicate" ;
                    ] ;
                  sp:arg2 skos:note ;
                ] ;
              sp:arg2 [
                  a sp:eq ;
                  sp:arg1 [
                      sp:varName "type" ;
                    ] ;
                  sp:arg2 rdf:HTML ;
                ] ;
            ] ;
        ] ;
      swa:weight 5 ;
    ] ;
  ui:prototype """
<div class=\"swa-shifted-label\">
    <ui:parse ui:str=\"{= swa:redirectHRefs(?object) }\"/>
    <swa:LangDisplay arg:lang=\"{= lang(?object) }\"/>
</div>
"""^^ui:Literal ;
  rdfs:comment "A viewer for HTML-based values. Parses the literal into HTML and inserts that into the document. Links will be redirected using the currently registered createLinkFunction." ;
  rdfs:label "Rich text viewer" ;
  rdfs:subClassOf swa:ObjectViewer ;
.
swa:RoleDropDownEditor
  a swa:ObjectEditorClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:onChange ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional JavaScript function to execute upon a change to the select field." ;
    ] ;
  ui:abstract false ;
  ui:private true ;
  ui:prototype """
<span let:name=\"new-{= ?uid }\">
    <select class=\"form-control {= swa:testClass(?predicate) }\" name=\"{= ?name }\" onchange=\"{= ?onChange }\">
        <option/>
        <ui:forEach ui:resultSet=\"{#
                SELECT ?role
                WHERE {
                    ?any smf:role ?role .
                } }\">
            <option selected=\"{= IF((?object = ?role), &quot;selected&quot;, ?none) }\" value=\"{= ui:encodeNode(?role, true, true) }\">{= ui:label(?role) }</option>
        </ui:forEach>
    </select>
</span>
"""^^ui:Literal ;
  rdfs:label "Role drop down editor" ;
  rdfs:subClassOf swa:ObjectEditor ;
.
swa:ScriptElements
  a ui:NodeClass ;
  ui:abstract true ;
  rdfs:comment "Abstract base class for elements that generate JavaScript snippets (usually in <script> tags)." ;
  rdfs:label "Script elements" ;
  rdfs:subClassOf swa:Elements ;
.
swa:SearchForm
  a swa:FormClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:cache ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to set the form's body to be cached. This should be used if the ontology/classes do not change at runtime." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:formId ;
      spl:valueType xsd:string ;
      rdfs:comment "The id that shall be used for the new form. The system will generate a unique new id if left blank." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:headerLabel ;
      spl:valueType xsd:string ;
      rdfs:comment "The label of the header - if provided this will override the default label generation." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:loadImmediately ;
      spl:valueType xsd:boolean ;
      rdfs:comment "If set to true this will execute the search immediately when the widget is created." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:noBorder ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to suppress the border around the form. This can be useful if the surrounding container (SplitPane) already has a border." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:onSelect ;
      spl:valueType xsd:string ;
      rdfs:comment "The onSelect handler of the generated SearchResultsGrid." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:queryGraph ;
      spl:valueType owl:Ontology ;
      rdfs:comment "An optional graph that contains the schema (needed to determine whether an instance has a class that is the subclass of the resource type)." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:restoreSearch ;
      spl:valueType search:Search ;
      rdfs:comment "Creates this search form from a given search:Search object that represents a previous state (\"saved search\"). The widgets themselves can query this value using the context variable \"swaRestoreSearch\"." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:rootType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "If the type is selectable, then use this as root class for the selection drop down." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:rowNumCookie ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional name for a cookie that shall be used to remember the chosen number of rows." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:searchButtonHandler ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of a JavaScript function to handle the Search button click event." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:searchResultsGeneratedEvent ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of an event to fire after search results are generated for the results grid." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:sortByFirstKeyProperty ;
      spl:valueType xsd:boolean ;
      rdfs:comment "Set to true to always sort by the first selected key property. This is usually used in conjunction with arg:suppressKeyPropertiesSelection=true to support cases in which the key properties are pre-selected." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:suppressHeader ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to suppress the header, e.g. to replace it with a custom header instead." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:suppressKeyPropertiesSelection ;
      spl:valueType xsd:boolean ;
      rdfs:comment "Set to true to hide the check boxes that allow the user to select the result columns. It will then only use the swa:keyProperties attached to the type without enabling the user to modify them." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:suppressLocalSearch ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to suppress the local search option." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:typeSelectable ;
      spl:valueType xsd:boolean ;
      rdfs:comment "If set to true, the form will have a drop down selection in the top where users can switch to a subclass of the resource type." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The subject type to display." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resultsId ;
      spl:valueType xsd:string ;
      rdfs:comment "The id of a div that shall contain the results grid when the user hits Search." ;
    ] ;
  ui:prototype """
<ui:setContext let:fid=\"{= IF(bound(?formId), ?formId, ui:uniqueId()) }\" let:lid=\"{= IF(bound(?formId), CONCAT(?formId, &quot;LID&quot;), ui:uniqueId()) }\" ui:varName=\"mode\" ui:varValue=\"search\">
    <ui:if ui:condition=\"{= (!bound(?suppressHeader)) || (!?suppressHeader) }\">
        <swa:FormHeader arg:label=\"{= COALESCE(?headerLabel, IF((bound(?typeSelectable) &amp;&amp; ?typeSelectable), &quot;Search&quot;, CONCAT(&quot;Search &quot;, ui:label(?resourceType)))) }\"/>
    </ui:if>
    <ui:if ui:condition=\"{= ?typeSelectable }\">
        <ui:loadable ui:loadId=\"{= ?fid }TypeSwitch\">
            <swa:SearchFormTypeSwitch arg:fid=\"{= ?fid }\" arg:loadId=\"{= ?lid }\" arg:resourceType=\"{= COALESCE(?rootType, ?resourceType) }\" arg:selectedType=\"{= IF(bound(?restoreSearch), spl:object(?restoreSearch, search:rootType), ?resourceType) }\"/>
        </ui:loadable>
    </ui:if>
    <ui:loadable class=\"ui-layout-content\" ui:cache=\"{= ?cache }\" ui:loadId=\"{= ?lid }\">
        <ui:setContext ui:varName=\"resourceType\" ui:varValue=\"{= ?resourceType }\">
            <ui:setContext ui:varName=\"createLinkFunction\" ui:varValue=\"{= swa:createNewTabLink }\">
                <ui:setContext ui:varName=\"suppressRDFType\" ui:varValue=\"{= !?typeSelectable }\">
                    <ui:setContext ui:varName=\"swaRestoreSearch\" ui:varValue=\"{= ?restoreSearch }\">
                        <form autocomplete=\"off\" class=\"search-mode swa-form {= IF(((!bound(?noBorder)) || (?noBorder = false)), &quot; swa-form-border&quot;, &quot;&quot;) }\" id=\"{= ?fid }\" let:qg=\"{= IF(bound(?queryGraph), ?queryGraph, ui:currentQueryGraph()) }\">
                            <input name=\"type\" type=\"hidden\" value=\"&lt;{= ?resourceType }&gt;\"/>
                            <input name=\"_base\" type=\"hidden\" value=\"{= ?qg }\"/>
                            <ui:if ui:condition=\"{= ?qg != ui:currentQueryGraph() }\">
                                <input name=\"schema\" type=\"hidden\" value=\"{= ui:encodeNode(ui:currentQueryGraph(), true, true) }\"/>
                            </ui:if>
                            <ui:if ui:condition=\"{= ?sortByFirstKeyProperty }\">
                                <input name=\"_sortByFirstKeyProperty\" type=\"hidden\" value=\"true\"/>
                            </ui:if>
                            <ui:setContext ui:varName=\"suppressKeyPropertiesSelection\" ui:varValue=\"{= ?suppressKeyPropertiesSelection }\">
                                <div class=\"swa-form-body\">
                                    <swa:SearchFormFullTextSection arg:resourceType=\"{= ?resourceType }\"/>
                                    <ui:classView ui:class=\"{= swa:resourceType() }\" ui:matchIds=\"search,form\"/>
                                    <swa:SearchFormDirectInstancesSection arg:resourceType=\"{= ?resourceType }\"/>
                                    <ui:if ui:condition=\"{= swa:falseOrUnbound(?suppressLocalSearch) }\">
                                        <swa:SearchFormLocalSection/>
                                    </ui:if>
                                    <swa:SearchFormKeyPropertiesHiddenFields arg:resourceType=\"{= ?resourceType }\"/>
                                </div>
                            </ui:setContext>
                        </form>
                    </ui:setContext>
                </ui:setContext>
            </ui:setContext>
        </ui:setContext>
    </ui:loadable>
    <div class=\"swa-form-footer\" let:handler=\"{= COALESCE(?searchButtonHandler, &quot;swa.loadSearchResultsGrid&quot;) }('{= ?fid }', '{= ?resultsId }', &quot;{= ui:escapeJSON(?onSelect) }&quot;, {= IF(bound(?rowNumCookie), CONCAT(&quot;\\&quot;&quot;, ?rowNumCookie, &quot;\\&quot;&quot;), &quot;null&quot;) }{= IF(bound(?searchResultsGeneratedEvent), CONCAT(&quot;, '&quot;, ?searchResultsGeneratedEvent, &quot;'&quot;), ?none) })\">
        <swa:Button arg:class=\"btn btn-default btn-xs\" arg:id=\"test-search-button\" arg:label=\"Search\" arg:onClick=\"{= ?handler }\"/>
        <swa:Space/>
        <swa:Button arg:class=\"btn btn-default btn-xs\" arg:label=\"Reset\" arg:onClick=\"swa.reloadSearchForm('{= ?lid }')\"/>
        <ui:if ui:condition=\"{= ?loadImmediately }\">
            <script>{= ?handler }</script>
        </ui:if>
        <ui:insertionPoint ui:pointId=\"footer\"/>
    </div>
</ui:setContext>
"""^^ui:Literal ;
  rdfs:comment """A component displaying a search form that can be used to drive a result set grid.

This is left here for legacy reasons - any new application should use FormSearchGadget.""" ;
  rdfs:label "Search form" ;
  rdfs:subClassOf swa:Form ;
.
swa:SearchFormDirectInstancesSection
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class being searched." ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:if ui:condition=\"{= EXISTS {
    ?subClass rdfs:subClassOf ?resourceType .
} }\">
    <div class=\"checkbox\">
        <input id=\"directInstancesCb\" name=\"directInstances\" type=\"checkbox\"/>
        <swa:Space/>
        <label class=\"swa-search-form-direct-instances-label\" for=\"directInstancesCb\">Exclude subclasses of {= ui:label(?resourceType) }</label>
    </div>
</ui:if>
"""^^ui:Literal ;
  rdfs:comment "A section showing up at the bottom of the search form, allowing users to activate direct instances only search. The section is empty if the class doesn't have any subclasses." ;
  rdfs:label "Search form direct instances section" ;
  rdfs:subClassOf swa:FormElements ;
.
swa:SearchFormFooterPlugin
  a rdfs:Class ;
  rdfs:comment "A component that can appear in the lower right corner of a search form." ;
  rdfs:label "Search form footer plugin" ;
  rdfs:subClassOf ui:NodeClass ;
.
swa:SearchFormFooterPlugins
  a swa:SearchFormFooterPlugin ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:formId ;
      spl:valueType xsd:string ;
      rdfs:comment "The id of the search form." ;
    ] ;
  rdfs:label "Search form footer plugins" ;
  rdfs:subClassOf swa:FormElements ;
.
swa:SearchFormFullTextSection
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:hideCaseSensitivity ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to hide the check box for case sensitive search." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:hideGlobalSearch ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to only show the search for explicitly enumerated properties." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class being searched." ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:group>
    <ui:if ui:condition=\"{= swa:hasFullTextSearchProperty(?resourceType) }\">
        <div class=\"swa-objects-group\">
            <table class=\"swa-labeled-objects-table\">
                <tr>
                    <td class=\"swa-labeled-objects-tabular-label swa-search-form-full-text-section-label\">
                        <span class=\"swa-sub-title\">Search&nbsp;Text&nbsp;Properties</span>
                    </td>
                    <td let:id=\"{= ui:uniqueId() }\">
                        <input class=\"form-control\" name=\"regex{= ?id }\" type=\"text\"/>
                        <input name=\"facet{= ?id }\" type=\"hidden\" value=\"union {= swa:fullTextSearchPropertiesConcat(?resourceType) }\"/>
                    </td>
                </tr>
            </table>
        </div>
    </ui:if>
    <ui:elseif ui:condition=\"{= (!bound(?hideGlobalSearch)) || (!?hideGlobalSearch) }\">
        <div class=\"swa-objects-group\">
            <table class=\"swa-labeled-objects-table\">
                <tr class=\"swa-labeled-objects-tr\">
                    <td class=\"swa-labeled-objects-tabular-label wa-search-form-full-text-section-label\">
                        <div class=\"swa-sub-title\">Search&nbsp;any&nbsp;Text</div>
                    </td>
                    <td class=\"searchContainer\">
                        <div>
                            <input class=\"form-control \" name=\"string\" type=\"text\" value=\"{= swa:restoreSearchString() }\"/>
                            <ui:if ui:condition=\"{= swa:falseOrUnbound(?hideCaseSensitivity) }\">
                                <div class=\"checkbox\">
                                    <input checked=\"{= IF(swa:restoreSearchStringCaseSensitive(), &quot;checked&quot;, ?none) }\" id=\"caseSensative\" name=\"stringCS\" type=\"checkbox\" value=\"true\"/>
                                    <label for=\"caseSensative\">Case sensitive</label>
                                </div>
                            </ui:if>
                        </div>
                    </td>
                </tr>
            </table>
        </div>
    </ui:elseif>
</ui:group>
"""^^ui:Literal ;
  rdfs:label "Search form full text section" ;
  rdfs:subClassOf swa:FormElements ;
.
swa:SearchFormGadget
  a swa:Gadget ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:footerPlugin ;
      spl:valueType swa:SearchFormFooterPlugin ;
      rdfs:comment "An SWP element to appear in the lower right corner." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:formId ;
      spl:valueType xsd:string ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:searchButtonHandler ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of a JavaScript function to handle the click event for the Search button." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:searchResultsGeneratedEvent ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of an event to fire after search results are generated for the results grid." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:typeSelectable ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to allow users to switch to the search class using a drop down box." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:classSelectedEvent ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the event to subscribe to so that the form can be reloaded whenever the class changes." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:instanceSelectedEvent ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the event to fire if the user has clicked on an instance in the results grid." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class of instances being searched." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resultsId ;
      spl:valueType xsd:string ;
      rdfs:comment "The id of the matching SearchResultsGridGadget." ;
    ] ;
  ui:prototype """
<ui:group let:formId=\"{= IF(bound(?formId), ?formId, ui:uniqueId()) }\">
    <swa:WindowTitleSetter arg:title=\"Search {= ui:label(?resourceType) }\"/>
    <swa:SearchForm arg:formId=\"{= ?formId }\" arg:noBorder=\"{= true }\" arg:onSelect=\"{= swa:publishEvent(?instanceSelectedEvent, &quot;resource&quot;) }\" arg:resourceType=\"{= ?resourceType }\" arg:resultsId=\"{= ?resultsId }\" arg:searchButtonHandler=\"{= ?searchButtonHandler }\" arg:searchResultsGeneratedEvent=\"{= ?searchResultsGeneratedEvent }\" arg:suppressHeader=\"{= true }\" arg:typeSelectable=\"{= ?typeSelectable }\">
        <ui:insert ui:into=\"footer\">
            <ui:if ui:condition=\"{= bound(?footerPlugin) }\">
                <swa:Space/>
                <swa:Space/>
                <div class=\"swa-float-right\">
                    <ui:dynamicView arg:formId=\"{= ?formId }\" ui:class=\"{= ?footerPlugin }\"/>
                </div>
            </ui:if>
        </ui:insert>
    </swa:SearchForm>
    <swa:SubscribeArgument arg:argumentName=\"resourceType\" arg:event=\"{= ?classSelectedEvent }\"/>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "Deprecated (with TopBraid 4.3): Please migrate to swa:GridSearchResultsGadget and swa:FormSearchGadget." ;
  rdfs:label "Search form gadget" ;
  rdfs:subClassOf swa:Gadgets ;
.
swa:SearchFormHiddenFields
  a ui:NodeClass ;
  ui:prototype """
<ui:group let:object=\"{= ui:contextValue(&quot;contextObject&quot;) }\" let:predicate=\"{= ui:contextValue(&quot;contextPredicate&quot;) }\" let:subject=\"{= ui:contextValue(&quot;contextSubject&quot;) }\">
    <ui:if ui:condition=\"{= bound(?predicate) }\">
        <ui:if ui:condition=\"{= bound(?subject) }\">
            <input name=\"facetContext\" type=\"hidden\" value=\"&lt;{= ?predicate }&gt;\"/>
            <input name=\"valueContext\" type=\"hidden\" value=\"&lt;{= ?subject }&gt;\"/>
        </ui:if>
        <ui:elseif ui:condition=\"{= bound(?object) }\">
            <input name=\"facetContext\" type=\"hidden\" value=\"-&lt;{= ?predicate }&gt;\"/>
            <input name=\"valueContext\" type=\"hidden\" value=\"&lt;{= ?object }&gt;\"/>
        </ui:elseif>
    </ui:if>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "Inserts hidden field that instruct the search engine to use a context object or subject if the corresponding context variable have been bound." ;
  rdfs:label "Search form hidden fields" ;
  rdfs:subClassOf swa:FormElements ;
.
swa:SearchFormKeyPropertiesHiddenFields
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class to insert the key properties of." ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:group let:list=\"{= swa:getKeyProperties(?resourceType) }\">
    <ui:if ui:condition=\"{= bound(?list) }\">
        <ui:forEach ui:indexVar=\"index\" ui:resultSet=\"{#
                SELECT ?keyProperty
                WHERE {
                    GRAPH ui:graph {
                        ?list list:member ?keyProperty .
                    } .
                } }\">
            <input class=\"swaKeyPropertyHiddenField\" name=\"keyProperty{= ?index }\" type=\"hidden\" value=\"{= ui:encodeNode(?keyProperty, true, true) }\"/>
        </ui:forEach>
    </ui:if>
</ui:group>
"""^^ui:Literal ;
  rdfs:label "Search form key properties hidden fields" ;
  rdfs:subClassOf swa:FormElements ;
.
swa:SearchFormLocalSection
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:constant ;
      spl:valueType xsd:boolean ;
      rdfs:comment "If set, then the checkbox will be disabled and have the given value." ;
    ] ;
  ui:private true ;
  ui:prototype """
<div class=\"checkbox\">
    <input checked=\"{= IF(COALESCE(?constant, swa:restoreSearchLocal()), &quot;checked&quot;, ?none) }\" class=\"swa-search-form-direct-instances-label\" disabled=\"{= IF(bound(?constant), &quot;disabled&quot;, ?none) }\" id=\"swaSearchLocalResultsOnly\" name=\"local\" title=\"If activated then the search results will only include items that have an rdf:type statement in the base graph, i.e. results from sub-graphs are excluded\" type=\"checkbox\"/>
    <ui:if ui:condition=\"{= ?constant }\">
        <input name=\"local\" type=\"hidden\" value=\"true\"/>
    </ui:if>
    <swa:Space/>
    <label class=\"swa-search-form-direct-instances-label\" for=\"swaSearchLocalResultsOnly\" title=\"If activated then the search results will only include items that have an rdf:type statement in the base graph, i.e. results from sub-graphs are excluded\">Return local results only</label>
</div>
"""^^ui:Literal ;
  rdfs:comment "A section showing up at the bottom of the search form, allowing users to activate search on the local resources only." ;
  rdfs:subClassOf swa:FormElements ;
.
swa:SearchFormPlugins
  a ui:NodeClass ;
  rdfs:comment "Base class for elements that can be plugged into a swa:FormSearchGadget." ;
  rdfs:label "Search form plugins" ;
  rdfs:subClassOf swa:FormElements ;
.
swa:SearchFormTypeSwitch
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:extraResourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "If specified, this type and its subclasses will also be shown in the type selection drop down. Use case is skos:Concept + skosxl:Label (extra)." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:selectedType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The initially selected type." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:fid ;
      spl:valueType xsd:string ;
      rdfs:comment "The form ID, passed in from the outside." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:loadId ;
      spl:valueType xsd:string ;
      rdfs:comment "The ui:loadId of the body of the form." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The root class for the search form." ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:if ui:condition=\"{= bound(?extraResourceType) || EXISTS {
    ?subClass rdfs:subClassOf ?resourceType .
} }\">
    <table class=\"swa-labeled-objects-table swa-search-form-type-switch\">
        <tr>
            <td class=\"swa-labeled-objects-label-td swa-labeled-objects-tabular-label swa-search-form-type-switch-label-padding\">
                <swa:PropertyLabel arg:label=\"Search for\"/>
            </td>
            <td class=\"swa-labeled-objects-icons-td\">
                <span class=\"swa-icon\"/>
            </td>
            <td class=\"swa-labeled-objects-body-td\" let:id=\"{= ?fid }-typeSelect\">
                <ui:if ui:condition=\"{= (!bound(?extraResourceType)) &amp;&amp; (spif:countTransitiveSubjects(rdfs:subClassOf, ?resourceType) &gt; 1000) }\">
                    <swa:AutoComplete arg:filterFunction=\"{= swa:filterSubclassesOfRoot }\" arg:filterFunctionArgument=\"{= ?resourceType }\" arg:id=\"{= ?fid }-typeselect\" arg:onSelect=\"swa.loadWithResource('{= ?loadId }', 'resourceType', resource)\" arg:type=\"{= rdfs:Class }\"/>
                </ui:if>
                <ui:else>
                    <select autocomplete=\"off\" class=\"form-control swa-search-form-type-select\" id=\"{= ?id }\" title=\"{= COALESCE(?selectedType, ?resourceType) }\">
                        <ui:forEach ui:resultSet=\"{#
                                SELECT DISTINCT ?label ?class
                                WHERE {
                                    ?class (rdfs:subClassOf)* ?resourceType .
                                    BIND (ui:label(?class) AS ?label) .
                                }
                                ORDER BY (?label) }\">
                            <option selected=\"{= IF((COALESCE(?selectedType, ?resourceType) = ?class), &quot;selected&quot;, ?none) }\" title=\"{= ?class }\" value=\"{= ?class }\">{= ?label }</option>
                        </ui:forEach>
                        <ui:if ui:condition=\"{= bound(?extraResourceType) }\">
                            <option disabled=\"disabled\">SKOS-XL Label Classes:</option>
                            <ui:forEach ui:resultSet=\"{#
                                    SELECT DISTINCT ?label ?class
                                    WHERE {
                                        ?class (rdfs:subClassOf)* ?extraResourceType .
                                        BIND (ui:label(?class) AS ?label) .
                                    }
                                    ORDER BY (?label) }\">
                                <option title=\"{= ?class }\" value=\"{= ?class }\">{= ?label }</option>
                            </ui:forEach>
                        </ui:if>
                    </select>
                    <script>$('#{= ?id }').change(function() {
						$(this).prop('title', $(this).val());
						var newType = '&lt;' + $(this).val() + '&gt;';
						swa.load('{= ?loadId }', { resourceType: newType });
					});</script>
                </ui:else>
            </td>
        </tr>
    </table>
</ui:if>
"""^^ui:Literal ;
  rdfs:comment "If the given resource type has at least one subclass, then this will display a drop down box where the user can select a class. This will reload the ui:loadable (form body) with the selected type. Future versions may also display a button that opens a tree dialog." ;
  rdfs:label "Search form type switch" ;
  rdfs:subClassOf swa:FormElements ;
.
swa:SearchGadgets
  a swa:Gadget ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:classSelectedEvent ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of an event that shall control which class is displayed as root class." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:searchEvent ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of an event that shall be posted when the search has been updated. This can be used to link this with a results gadget. The data payload of these events will is the URI of a session graph that holds the search:Search object to run - there can only be one such instance in that graph." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class to search instances of." ;
    ] ;
  ui:abstract true ;
  rdfs:comment "Abstract base class of gadgets that can issue a search. Examples include search form or faceted search. Common to those is that users search over instances of a given class (which later becomes the search:rootType of the search:Search object). When the user executes a search, the search gadgets should publish a search event which any number of SearchResultsGadgets can subscribe to." ;
  rdfs:label "Search gadgets" ;
  rdfs:subClassOf swa:Gadgets ;
.
swa:SearchMode
  a swa:Mode ;
  swa:formClass swa:SearchForm ;
  swa:formObjectPredicateSelectionTemplate swa:SuitableObjectPredicatesWithMagicProperties ;
  swa:isSingleConstant true ;
  swa:modeName "search" ;
  swa:objectWidgetClass swa:ObjectFacet ;
  swa:objectWidgetMiddleColumnClass swa:SearchWidgetMiddleColumn ;
  swa:objectWidgetRowClass swa:ObjectFacetRow ;
  swa:subjectWidgetMiddleColumnClass swa:SubjectSearchWidgetMiddleColumn ;
  swa:subjectWidgetRowClass swa:SubjectFacetRow ;
  rdfs:comment "A mode in which forms are displaying search fields, e.g. a range slider for numeric values and a text field for regex string matching." ;
  rdfs:label "Search mode" ;
.
swa:SearchResultsAction
  a rdfs:Class ;
  rdfs:comment "Class for actions that can be performed on the results of a Search. The onSelect will be executed with the variable formId pointing to the search form. Look at the source code of the pre-defined example actions on how to proceed with the formId." ;
  rdfs:label "Search results action" ;
  rdfs:subClassOf swa:Action ;
.
swa:SearchResultsActions
  a spin:SelectTemplate ;
  spin:body [
      a sp:Select ;
      sp:orderBy (
          [
            sp:varName "group" ;
          ]
          [
            sp:varName "label" ;
          ]
        ) ;
      sp:resultVariables (
          [
            sp:varName "actionName" ;
          ]
          [
            sp:varName "actionLocalName" ;
          ]
          [
            sp:varName "onSelect" ;
          ]
          [
            sp:varName "enabled" ;
          ]
          [
            sp:varName "group" ;
          ]
          [
            sp:varName "label" ;
          ]
          [
            sp:varName "iconClass" ;
          ]
        ) ;
      sp:where (
          [
            a sp:NamedGraph ;
            sp:elements (
                [
                  sp:object swa:SearchResultsAction ;
                  sp:predicate rdf:type ;
                  sp:subject [
                      sp:varName "action" ;
                    ] ;
                ]
                [
                  sp:object [
                      sp:varName "label" ;
                    ] ;
                  sp:predicate rdfs:label ;
                  sp:subject [
                      sp:varName "action" ;
                    ] ;
                ]
                [
                  sp:object [
                      sp:varName "condition" ;
                    ] ;
                  sp:predicate arg:condition ;
                  sp:subject [
                      sp:varName "action" ;
                    ] ;
                ]
                [
                  a sp:Bind ;
                  sp:expression [
                      a afn:localname ;
                      sp:arg1 [
                          sp:varName "action" ;
                        ] ;
                    ] ;
                  sp:variable [
                      sp:varName "actionLocalName" ;
                    ] ;
                ]
                [
                  a sp:Bind ;
                  sp:expression [
                      a ui:encodeNode ;
                      sp:arg1 [
                          sp:varName "action" ;
                        ] ;
                    ] ;
                  sp:variable [
                      sp:varName "actionName" ;
                    ] ;
                ]
                [
                  a sp:Bind ;
                  sp:expression [
                      a spl:object ;
                      sp:arg1 [
                          sp:varName "action" ;
                        ] ;
                      sp:arg2 arg:onSelect ;
                    ] ;
                  sp:variable [
                      sp:varName "onSelect" ;
                    ] ;
                ]
                [
                  a sp:Bind ;
                  sp:expression [
                      a spl:object ;
                      sp:arg1 [
                          sp:varName "action" ;
                        ] ;
                      sp:arg2 arg:appName ;
                    ] ;
                  sp:variable [
                      sp:varName "actionAppName" ;
                    ] ;
                ]
                [
                  a sp:Bind ;
                  sp:expression [
                      a sp:coalesce ;
                      sp:arg1 [
                          a spl:object ;
                          sp:arg1 [
                              sp:varName "action" ;
                            ] ;
                          sp:arg2 arg:group ;
                        ] ;
                      sp:arg2 "" ;
                    ] ;
                  sp:variable [
                      sp:varName "group" ;
                    ] ;
                ]
                [
                  a sp:Bind ;
                  sp:expression [
                      a spl:object ;
                      sp:arg1 [
                          sp:varName "action" ;
                        ] ;
                      sp:arg2 arg:iconClass ;
                    ] ;
                  sp:variable [
                      sp:varName "iconClass" ;
                    ] ;
                ]
                [
                  a sp:Bind ;
                  sp:expression [
                      a spin:evalInGraph ;
                      sp:arg1 [
                          sp:varName "condition" ;
                        ] ;
                      sp:arg2 [
                          a ui:currentQueryGraph ;
                        ] ;
                      sp:arg3 arg:appName ;
                      sp:arg4 [
                          sp:varName "appName" ;
                        ] ;
                    ] ;
                  sp:variable [
                      sp:varName "enabled" ;
                    ] ;
                ]
                [
                  a sp:Filter ;
                  sp:expression [
                      a sp:and ;
                      sp:arg1 [
                          a sp:and ;
                          sp:arg1 [
                              a sp:bound ;
                              sp:arg1 [
                                  sp:varName "enabled" ;
                                ] ;
                            ] ;
                          sp:arg2 [
                              a sp:not ;
                              sp:arg1 [
                                  a swa:hasExcludedAppName ;
                                  arg:action [
                                      sp:varName "action" ;
                                    ] ;
                                  arg:appName [
                                      sp:varName "appName" ;
                                    ] ;
                                ] ;
                            ] ;
                        ] ;
                      sp:arg2 [
                          a sp:or ;
                          sp:arg1 [
                              a sp:not ;
                              sp:arg1 [
                                  a sp:bound ;
                                  sp:arg1 [
                                      sp:varName "actionAppName" ;
                                    ] ;
                                ] ;
                            ] ;
                          sp:arg2 [
                              a swa:hasAppName ;
                              sp:arg1 [
                                  sp:varName "appName" ;
                                ] ;
                              sp:arg2 [
                                  sp:varName "actionAppName" ;
                                ] ;
                            ] ;
                        ] ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode ui:graph ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:appName ;
      spl:valueType xsd:string ;
      rdfs:comment "The current swaAppName, passed into the eval expression." ;
    ] ;
  spin:private true ;
  rdfs:label "Search results actions" ;
  rdfs:subClassOf spin:SelectTemplates ;
.
swa:SearchResultsActionsCallback
  a ui:JSONService ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:appName ;
      spl:valueType xsd:string ;
      rdfs:comment "The value of the swaAppName context variable as provided by the caller." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:searchGraph ;
      spl:valueType xsd:string ;
    ] ;
  ui:prototype """
<ui:call arg:appName=\"{= ?appName }\" ui:template=\"{= swa:SearchResultsActions }\">
    <swon:RSObjectArray arg:resultSet=\"{= ?rs }\"/>
</ui:call>
"""^^ui:Literal ;
  rdfs:label "Search results actions callback" ;
  rdfs:subClassOf swa:MenuElements ;
  rdfs:subClassOf ui:JSONServices ;
.
swa:SearchResultsGadgets
  a swa:Gadget ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:searchEvent ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the event to list to when a search has been triggered. If left blank, then a default event name will be used consistently across all search views." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resourceSelectedEvent ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of an event to publish when the user clicks on a result. The data payload of this event is the URI of the resource." ;
    ] ;
  ui:abstract true ;
  rdfs:comment "Base class of gadgets that can display the results of a Search. Search may be initiated by a search form or faceted search, and those gadget publish an event pointing to a session graph containing a single search:Search instance. This can be used in conjunction with the magic property search:result to perform the actual search. Subclasses of this may render the results in any way they like, and they should publish the event specified by arg:resourceSelectedEvent when someone clicks on a result." ;
  rdfs:label "Search results gadgets" ;
  rdfs:subClassOf swa:Gadgets ;
.
swa:SearchResultsGrid
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:onSelect ;
      spl:valueType xsd:string ;
      rdfs:comment "JavaScript code that shall be executed if the user selects a row in the grid. In this JavaScript code, the variable resource contains the URI of the selected resource." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:rowNumCookie ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of a cookie that shall be used to remember the selected number of rows (10 by default)." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:searchMemoryModel ;
      spl:valueType xsd:boolean ;
      rdfs:comment "Whether to search the in-memory graph or search external data sources" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:sortByFirstKeyProperty ;
      spl:valueType xsd:boolean ;
      rdfs:comment "Set to true to always sort by the first selected key property. This is usually used in conjunction with arg:suppressKeyPropertiesSelection=true to support cases in which the key properties are pre-selected." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:width ;
      spl:valueType xsd:integer ;
      rdfs:comment "An optional fixed width (in pixels, but without the 'px'). If unset, autowidth will be used." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:keyPropertiesList ;
      spl:valueType xsd:string ;
      rdfs:comment "A space-separated list of encoded key properties." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:params ;
      spl:valueType xsd:string ;
      rdfs:comment "A URL-encoded string of the parameters produced by a SearchForm." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:type ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The type of resources being edited." ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:group let:first=\"{= COALESCE(ui:param(&quot;_sortByFirstKeyProperty&quot;, xsd:boolean), ?sortByFirstKeyProperty, false) }\" let:pagerId=\"{= ui:uniqueId() }\" let:tableId=\"{= ui:uniqueId() }\">
    <table id=\"{= ?tableId }\"/>
    <div id=\"{= ?pagerId }\"/>
    <script>$(\"#{= ?tableId }\").jqGrid({url:swa.server+\"getSearchResults?{= ?params }\",<swon:Value arg:name=\"datatype\" arg:value=\"json\"/>,
colNames:[
<ui:if ui:condition=\"{= bound(?keyPropertiesList) }\">
            <ui:if ui:condition=\"{= !?first }\">'Resource'{= IF((STRLEN(?keyPropertiesList) &gt; 0), \",\", ?none) }</ui:if>
            <ui:forEach ui:resultSet=\"{#
                    SELECT ?colName ?inverse
                    WHERE {
                        ?keyPropertiesList swa:keyPropertiesFromList ( ?keyProperty ?inverse ) .
                        BIND (spif:titleCase(ui:label(?keyProperty)) AS ?colName) .
                    } }\" ui:separator=\",\">' {= IF(?inverse, \"[Inverse] \", ?none) }{= ?colName }'</ui:forEach>
        </ui:if>
        <ui:else>
		'Resource'
	</ui:else>],
colModel:[
<ui:if ui:condition=\"{= bound(?keyPropertiesList) }\">
            <ui:if ui:condition=\"{= !?first }\">{ name : 'label' }{= IF((STRLEN(?keyPropertiesList) &gt; 0), \",\", ?none) }</ui:if>
            <ui:forEach ui:indexVar=\"index\" ui:resultSet=\"{#
                    SELECT ?keyProperty
                    WHERE {
                        ?keyPropertiesList swa:keyPropertiesFromList ( ?keyProperty ?inverse ) .
                    } }\" ui:separator=\",\">{<swon:Value arg:name=\"name\" arg:value=\"{= afn:localname(?keyProperty) }_{= ?index }\"/>
	            		}
	    			</ui:forEach>
        </ui:if>
        <ui:else>{ name : 'label' }</ui:else>
],
<ui:if ui:condition=\"{= bound(?onSelect) }\">onSelectRow: function(resource) {
		{= ?onSelect }
	},</ui:if>
        <ui:if ui:condition=\"{= bound(?width) }\">width: {= ?width }</ui:if>
        <ui:else>autowidth: true</ui:else>,
height: 'auto',
mtype: 'POST',
rowNum: <ui:if ui:condition=\"{= bound(?rowNumCookie) }\">swa.getCookie(\"{= ?rowNumCookie }\", 10)</ui:if>
        <ui:else>10</ui:else>,
rowList:[5,10,15,20,25],<ui:if ui:condition=\"{= bound(?rowNumCookie) }\">loadComplete: function() {
	var currentRowNum = $(\"#{= ?tableId }\").getGridParam('rowNum');
	$.cookie('{= ?rowNumCookie }', currentRowNum);
},</ui:if>pager: '#{= ?pagerId }',
sortorder: 'asc',
gridview: true,
postData: { smm:<ui:if ui:condition=\"{= bound(?searchMemoryModel) }\">{= ?searchMemoryModel }</ui:if>
        <ui:else>swa.searchMemoryModel</ui:else>},
onPaging: function(pgButton) { $(\"#{= ?tableId }\").setGridParam({postData:{smm: true}}); },
viewrecords: true
}).jqGrid('navGrid', '#{= ?pagerId }', {
	add: false,
	del: false,
	edit: false,
	search: false
});</script>
</ui:group>
"""^^ui:Literal ;
  ui:responseType ui:HTML ;
  rdfs:comment "Instances of this class are usually automatically created as a result of a user pressing the Search button on a SearchForm. The search button collects the parameters (form field values) and the grid allows users to browse through the matching resources based in a lazy loading manner. SWA users typically just instantiate a SearchForm and let it do the heavy lifting of passing the correct parameters around." ;
  rdfs:label "Search results grid" ;
  rdfs:subClassOf swa:GridElements ;
.
swa:SearchWidgetMiddleColumn
  a swa:ObjectWidgetMiddleColumnClass ;
  ui:prototype """
<td class=\"swa-labeled-objects-icons-td\" let:buttonId=\"{= ui:uniqueId() }\" let:isNested=\"{= ui:contextValue(&quot;isNested&quot;) }\" let:restoreSearch=\"{= ui:contextValue(&quot;swaRestoreSearch&quot;) }\">
    <div class=\"swa-key-property-input {= IF(bound(?restoreSearch), swa:keyPropertyInputClass(?predicate, ?restoreSearch), IF(COALESCE(ui:contextValue(&quot;checkAllProperties&quot;), false), &quot;swa-key-property-checked&quot;, &quot;swa-key-property-unchecked&quot;)) } {= IF((ui:contextValue(&quot;suppressKeyPropertiesSelection&quot;) || (ui:contextValue(&quot;suppressNestedKeyPropertiesSelection&quot;) &amp;&amp; ?isNested)), &quot;ui-helper-hidden-accessible&quot;, ?none) }\" id=\"{= ?buttonId }\" onclick=\"swa.clickKeyPropertyBox('{= ?buttonId }', '{= ?isNested }')\" title=\"Select whether and how this property should become a column in the results table\" value=\"{= ui:encodeNode(?predicate, true, true) }\"/>
</td>
"""^^ui:Literal ;
  rdfs:comment "The middle column on search forms, containing the button to select whether and how the property should become a column in the result set." ;
  rdfs:label "Search widget middle column" ;
  rdfs:subClassOf swa:ObjectWidgetMiddleColumn ;
.
swa:Section
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:title ;
      spl:valueType xsd:string ;
      rdfs:comment "The title of the section - turned into a heading." ;
    ] ;
  ui:prototype """
<section id=\"{#
        SELECT ?id
        WHERE {
            GRAPH ui:graph {
                ?element ui:prototype ?thisParent .
                BIND (swa:anchorId(?element) AS ?id) .
            } .
        } }\">
    <h2 class=\"title sectiontitle\">{= ?title }</h2>
    <ui:insertionPoint ui:pointId=\"body\"/>
</section>
"""^^ui:Literal ;
  rdfs:label "Section" ;
  rdfs:subClassOf swa:DocumentElements ;
.
swa:SectionLink
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:document ;
      spl:valueType ui:NodeClass ;
      rdfs:comment "The top-level document element containing the section. Can be used to point from one document to a section in another." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:section ;
      spl:valueType ui:NodeClass ;
      rdfs:comment "The section element - must have a swa:Section as its prototype." ;
    ] ;
  ui:prototype """
<a href=\"{= IF(bound(?document), CONCAT(&quot;swp?_viewClass=&quot;, ui:encodeURL(xsd:string(?document))), ?none) }#{= swa:anchorId(?section) }\">{#
        SELECT ?title
        WHERE {
            GRAPH ui:graph {
                ?section ui:prototype/arg:title ?title .
            } .
        } }</a>
"""^^ui:Literal ;
  rdfs:comment "Creates a hyperlink (<a href=\"LINK\">TITLE</a>) to a given section identified by the URI of an element that has an swa:Section as its prototype root element. The TITLE will be the arg:title of that swa:Section. The hyperlink will be the anchor created for that element." ;
  rdfs:label "Section link" ;
  rdfs:subClassOf swa:DocumentElements ;
.
swa:Sections
  a ui:NodeClass ;
  ui:abstract true ;
  rdfs:comment "Abstract base class for sections of a document." ;
  rdfs:label "Sections" ;
  rdfs:subClassOf swa:DocumentElements ;
.
swa:SessionGraphDeleter
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:ownerId ;
      spl:valueType xsd:string ;
      rdfs:comment "The id of the DOM element that defines the life cycle." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:sessionGraph ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The session graph to delete." ;
    ] ;
  ui:prototype """
<script>$(\"#{= ?ownerId }\").on(\"remove\", function () { swa.deleteSessionGraph('{= ?sessionGraph }'); });</script>
"""^^ui:Literal ;
  rdfs:comment "A script that can be tied to certain DOM elements so that a session graph is unregistered when the DOM element is destroyed. This is particularly useful if a dialog has created a session graph, and we don't want garbage to float around until the session ends." ;
  rdfs:label "Session graph deleter" ;
  rdfs:subClassOf swa:ScriptElements ;
.
swa:SetPrimaryKeyService
  a ui:Service ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property that shall become the primary key." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:uriStart ;
      spl:valueType xsd:string ;
      rdfs:comment "The start of the URI to use." ;
    ] ;
  ui:prototype """
<ui:group let:class=\"{= spl:object(?property, rdfs:domain) }\">
    <ui:transaction ui:logMessage=\"Set primary key of {= ui:label(?class) } to {= ui:label(?property) }\">
        <ui:update ui:updateQuery=\"{!
                DELETE {
                    ?old ?p ?o .
                    ?class spin:constraint ?old .
                }
                WHERE {
                    ?class spin:constraint ?old .
                    ?old a spl:PrimaryKeyPropertyConstraint .
                    ?old ?p ?o .
                } }\"/>
        <ui:update ui:updateQuery=\"{!
                DELETE {
                    ?old ?p ?o .
                    ?class sh:property ?old .
                }
                WHERE {
                    ?class sh:property ?old .
                    ?old dash:uriStart ?anyURIStart .
                    ?old ?p ?o .
                    FILTER isBlank(?old) .
                } }\"/>
        <ui:update ui:updateQuery=\"{!
                INSERT {
                    ?class sh:property ?ps .
                    ?ps a sh:PropertyShape .
                    ?ps sh:path ?property .
                    ?ps dash:uriStart ?uriStart .
                }
                WHERE {
                    BIND (BNODE() AS ?ps) .
                } }\"/>
        <ui:update ui:updateQuery=\"{!
                INSERT {
                    ?class a sh:NodeShape .
                }
                WHERE {
                    FILTER (!spl:instanceOf(?class, sh:NodeShape)) .
                } }\"/>
    </ui:transaction>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "Sets the dash:uriStart constraint for a given property, replacing any previously existing constraint (including legacy SPL constraints). This assumes that the class is identified as the rdfs:domain of the property." ;
  rdfs:label "Set primary key service" ;
  rdfs:subClassOf ui:JSONServices ;
.
swa:ShapeFormSection
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:hidePropertiesFunction ;
      spl:valueType spin:Function ;
      rdfs:comment "An optional SPARQL function that takes a property as argument and returns true if the property should be hidden." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:hidePropertyGroupsFunction ;
      spl:valueType spin:Function ;
      rdfs:comment "An optional SPARQL function that takes a sh:PropertyGroup as its parameter and returns true if the group should be hidden." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource or unbound if we are on a search form." ;
    ] ;
  ui:prototype """
<ui:forEach ui:resultSet=\"{#
        SELECT DISTINCT ?group
        WHERE {
            ?resource swa:propertyGroupsForNode ?group .
            BIND (COALESCE(spl:object(?group, sh:order), 999999) AS ?order) .
            BIND (ui:label(?group) AS ?label) .
            FILTER ((!bound(?hidePropertyGroupsFunction)) || (!spif:invoke(?hidePropertyGroupsFunction, ?group))) .
        }
        ORDER BY (?order) (?label) }\">
    <swa:ShapePropertyGroupSection arg:focusNode=\"{= ?resource }\" arg:group=\"{= ?group }\" arg:hidePropertiesFunction=\"{= ?hidePropertiesFunction }\"/>
</ui:forEach>
"""^^ui:Literal ;
  rdfs:comment "This will insert sections based on SHACL shape definitions: any sh:PropertyGroup used by shapes in target of the class will become one section, with its declared properties in their provided sh:order." ;
  rdfs:label "Shape form section" ;
  rdfs:subClassOf swa:FormElements ;
.
swa:ShapePropertyGroupSection
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:compact ;
      spl:valueType xsd:boolean ;
      rdfs:comment "If set to true then no header section will show up." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:focusNode ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource that is the focus node." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:hidePropertiesFunction ;
      spl:valueType spin:Function ;
      rdfs:comment "An optional SPARQL function that takes a property as argument and returns true if the property should be hidden." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:labelWidth ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional arg:labelWidth, to be propagated into the nested swa:Objects." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:group ;
      spl:valueType sh:PropertyGroup ;
      rdfs:comment "The sh:PropertyGroup providing the properties." ;
    ] ;
  ui:prototype """
<ui:if let:sectionId=\"{= ui:uniqueId() }\" ui:condition=\"{= (!swa:isViewMode()) || swa:hasPropertyGroupValue(?focusNode, ?group) }\">
    <div class=\"{= IF(swa:falseOrUnbound(?compact), &quot;swa-objects-group&quot;, &quot;swa-objects-group-compact&quot;) }\" id=\"{= ?sectionId }\" let:bodyId=\"{= ui:uniqueId() }\" let:id=\"{= ui:uniqueId() }\" let:open=\"{= spl:object(?group, tosh:open) }\" let:openable=\"{= spl:object(?group, tosh:openable) }\">
        <ui:if ui:condition=\"{= swa:falseOrUnbound(?compact) }\">
            <ui:if ui:condition=\"{= ?openable }\">
                <div class=\"swa-sub-title\">
                    <div class=\"swa-openable-object-icon ui-icon ui-icon-triangle-1-{= IF((bound(?open) &amp;&amp; ?open), &quot;s&quot;, &quot;e&quot;) }\" id=\"{= ?id }\" onclick=\"swa.toggleOpenableObject('{= ?bodyId }', '{= ?id }');swa.toggleFormSectionInfoButton('{= ?sectionId }')\"/>
                    <div class=\"swa-float-left\">{= COALESCE(?label, ui:label(?group)) }</div>
                    <div class=\"swa-float-left\" id=\"{= ?sectionId }-info-button-div\" style=\"{= IF(swa:falseOrUnbound(?open), &quot;display: none&quot;, ?none) }\">
                        <swa:FormSectionInfoButton arg:sectionId=\"{= ?sectionId }\"/>
                    </div>
                    <div class=\"swa-clear-both\"/>
                </div>
            </ui:if>
            <ui:else>
                <div class=\"swa-sub-title\">
                    <span>{= COALESCE(?label, ui:label(?group)) }</span>
                    <swa:FormSectionInfoButton arg:sectionId=\"{= ?sectionId }\"/>
                </div>
            </ui:else>
        </ui:if>
        <div class=\"{= IF(((?openable &amp;&amp; swa:falseOrUnbound(?compact)) &amp;&amp; swa:falseOrUnbound(?open)), &quot;ui-helper-hidden-accessible&quot;, ?none) }\" id=\"{= ?bodyId }\" let:desc=\"{= IF(swa:isViewMode(), spl:object(?group, tosh:viewGroupDescription), IF(swa:isEditMode(), spl:object(?group, tosh:editGroupDescription), ?none)) }\">
            <ui:if ui:condition=\"{= bound(?desc) }\">
                <div class=\"swa-objects-group-description\">{= ?desc }</div>
            </ui:if>
            <ui:loadable ui:loadId=\"{= ?bodyId }-loadable\" ui:loadLater=\"{= ?openable }\">
                <ui:call arg:focusNode=\"{= ?focusNode }\" arg:group=\"{= ?group }\" arg:hidePropertiesFunction=\"{= ?hidePropertiesFunction }\" ui:template=\"{= swa:PredicatesInGroup }\">
                    <ui:group let:viewGadget=\"{= spl:object(?group, tosh:viewGadget) }\">
                        <ui:forEach ui:resultSet=\"{= ?rs }\">
                            <ui:if ui:condition=\"{= swa:isViewMode() }\">
                                <ui:if ui:condition=\"{= bound(?viewGadget) }\">
                                    <ui:dynamicView arg:focusNode=\"{= ?focusNode }\" arg:path=\"{= ?predicate }\" ui:class=\"{= ?viewGadget }\"/>
                                </ui:if>
                                <ui:else>
                                    <ui:setContext ui:varName=\"{= IF(?compact, &quot;swa-no-edit-button&quot;, ?none) }\" ui:varValue=\"{= true }\">
                                        <ui:if ui:condition=\"{= ?isInverse }\">
                                            <swa:Subjects arg:hideIfEmpty=\"{= true }\" arg:label=\"{= ?propertyLabel }\" arg:labelWidth=\"{= ?labelWidth }\" arg:object=\"{= ?focusNode }\" arg:predicate=\"{= ?predicate }\"/>
                                        </ui:if>
                                        <ui:else>
                                            <swa:Objects arg:class=\"{= IF(?compact, &quot;swa-labeled-objects-no-hover&quot;, ?none) }\" arg:hideIfEmpty=\"{= true }\" arg:label=\"{= ?propertyLabel }\" arg:labelWidth=\"{= ?labelWidth }\" arg:predicate=\"{= ?predicate }\" arg:subject=\"{= ?focusNode }\"/>
                                        </ui:else>
                                    </ui:setContext>
                                </ui:else>
                            </ui:if>
                            <ui:elseif ui:condition=\"{= swa:isEditMode() }\">
                                <ui:if ui:condition=\"{= !spl:instanceOf(?predicate, spin:MagicProperty) }\">
                                    <ui:if ui:condition=\"{= ?isInverse }\">
                                        <swa:Subjects arg:hideIfEmpty=\"{= true }\" arg:label=\"{= ?propertyLabel }\" arg:labelWidth=\"{= ?labelWidth }\" arg:object=\"{= ?focusNode }\" arg:predicate=\"{= ?predicate }\" arg:single=\"{= swa:isSingleInverse(?focusNode, ?predicate) }\"/>
                                    </ui:if>
                                    <ui:else>
                                        <swa:Objects arg:hideIfEmpty=\"{= true }\" arg:label=\"{= ?propertyLabel }\" arg:labelWidth=\"{= ?labelWidth }\" arg:predicate=\"{= ?predicate }\" arg:subject=\"{= ?focusNode }\"/>
                                    </ui:else>
                                </ui:if>
                            </ui:elseif>
                            <ui:else>
                                <ui:if ui:condition=\"{= ?isInverse }\">
                                    <swa:Subjects arg:hideIfEmpty=\"{= true }\" arg:label=\"{= ?propertyLabel }\" arg:labelWidth=\"{= ?labelWidth }\" arg:object=\"{= ?focusNode }\" arg:predicate=\"{= ?predicate }\"/>
                                </ui:if>
                                <ui:else>
                                    <swa:Objects arg:hideIfEmpty=\"{= true }\" arg:label=\"{= ?propertyLabel }\" arg:labelWidth=\"{= ?labelWidth }\" arg:predicate=\"{= ?predicate }\" arg:subject=\"{= ?focusNode }\"/>
                                </ui:else>
                            </ui:else>
                        </ui:forEach>
                    </ui:group>
                    <ui:if ui:condition=\"{= (bound(?focusNode) &amp;&amp; swa:falseOrUnbound(?open)) &amp;&amp; EXISTS {
                        ?rs spr:rowIndices ?rowIndex .
                        BIND (spr:cell(?rs, ?rowIndex, 0) AS ?predicate) .
                        ?focusNode ?predicate ?anyValue .
                    } }\">
                        <script>swa.toggleOpenableObject('{= ?bodyId }', '{= ?id }');$('#{= ?sectionId }-info-button-div').css('display', '')</script>
                    </ui:if>
                </ui:call>
            </ui:loadable>
        </div>
    </div>
</ui:if>
"""^^ui:Literal ;
  rdfs:comment """Inserts a group with swa:Objects and swa:Subjects for all properties and inverse properties declared for a given sh:PropertyGroup at a given focus node.

Instances of this element usually don't need to be created by hand - they get automatically added to the end of a form.""" ;
  rdfs:subClassOf swa:ObjectGroupElements ;
.
swa:ShowSHACLQueryAction
  a swa:SearchResultsAction ;
  arg:condition true ;
  arg:onSelect "swa.showSearchQuery(formId, true)" ;
  rdfs:label "Show SHACL query shape..." ;
.
swa:ShowSearchQueryAction
  a swa:SearchResultsAction ;
  arg:condition true ;
  arg:onSelect "swa.showSearchQuery(formId, false)" ;
  rdfs:label "Show SPARQL query..." ;
.
swa:SigmaNeighborGramClassPropertiesDataService
  a ui:JSONService ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:focusNode ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The focus node of the diagram" ;
    ] ;
  ui:prototype """
<swon:Object letrs:parentClasses=\"{#
        SELECT DISTINCT ?parentClass
        WHERE {
            ?focusNode rdfs:subClassOf ?parentClass .
            FILTER (!isBlank(?parentClass)) .
        } }\" letrs:properties=\"{#
        SELECT DISTINCT ?property
        WHERE {
            ?property tops:relevantPropertiesOfClass ?focusNode .
            ?property a owl:ObjectProperty .
            FILTER (!isBlank(?property)) .
        } }\">
    <swon:Value arg:name=\"nodes\">
        <swon:Array>
            <swon:Object>
                <swon:Value arg:name=\"id\" arg:value=\"{= ?focusNode }\"/>
                <swon:Value arg:name=\"label\" arg:value=\"{= ui:label(?focusNode) }\"/>
                <swon:Value arg:name=\"size\" arg:value=\"40\"/>
            </swon:Object>
            <ui:if ui:condition=\"{= spr:rowCount(?parentClasses) &gt; 0 }\">
                <swon:Comma/>
                <ui:if ui:condition=\"{= spr:rowCount(?parentClasses) &gt; 1 }\">
                    <swon:Object>
                        <swon:Value arg:name=\"id\" arg:value=\"{= rdfs:subClassOf }\"/>
                        <swon:Value arg:name=\"size\" arg:value=\"0\"/>
                    </swon:Object>
                    <swon:Comma/>
                    <ui:forEach ui:resultSet=\"{= ?parentClasses }\" ui:separator=\",\">
                        <swon:Object>
                            <swon:Value arg:name=\"id\" arg:value=\"{= ?parentClass }\"/>
                            <swon:Value arg:name=\"label\" arg:value=\"{= ui:label(?parentClass) }\"/>
                            <swon:Value arg:name=\"size\" arg:value=\"40\"/>
                        </swon:Object>
                    </ui:forEach>
                </ui:if>
                <ui:else>
                    <ui:forEach ui:resultSet=\"{= ?parentClasses }\">
                        <swon:Object>
                            <swon:Value arg:name=\"id\" arg:value=\"{= ?parentClass }\"/>
                            <swon:Value arg:name=\"label\" arg:value=\"{= ui:label(?parentClass) }\"/>
                            <swon:Value arg:name=\"size\" arg:value=\"40\"/>
                        </swon:Object>
                    </ui:forEach>
                </ui:else>
            </ui:if>
            <ui:if ui:condition=\"{= spr:rowCount(?properties) &gt; 0 }\">
                <swon:Comma/>
                <ui:forEach ui:resultSet=\"{= ?properties }\" ui:separator=\",\">
                    <swon:Object let:range=\"{= smf:localRange(?focusNode, ?property) }\">
                        <ui:if ui:condition=\"{= bound(?range) &amp;&amp; (!isBlank(?range)) }\">
                            <swon:Value arg:name=\"id\" arg:value=\"{= ?property }#{= afn:localname(?range) }\"/>
                            <swon:Value arg:name=\"label\" arg:value=\"{= ui:label(smf:localRange(?focusNode, ?property)) }\"/>
                            <swon:Value arg:name=\"alternateId\" arg:value=\"{= ?range }\"/>
                        </ui:if>
                        <ui:else>
                            <swon:Value arg:name=\"id\" arg:value=\"{= ?property }#{= afn:localname(rdfs:Resource) }\"/>
                            <swon:Value arg:name=\"label\" arg:value=\"{= ui:label(rdfs:Resource) }\"/>
                            <swon:Value arg:name=\"alternateId\" arg:value=\"{= rdfs:Resource }\"/>
                        </ui:else>
                        <swon:Value arg:name=\"size\" arg:value=\"40\"/>
                        <ui:if ui:condition=\"{= bound(?range) }\"/>
                        <ui:else/>
                    </swon:Object>
                </ui:forEach>
            </ui:if>
        </swon:Array>
    </swon:Value>
    <swon:Value arg:name=\"edges\">
        <swon:Array>
            <ui:if ui:condition=\"{= spr:rowCount(?parentClasses) &gt; 0 }\">
                <ui:if ui:condition=\"{= spr:rowCount(?parentClasses) &gt; 1 }\">
                    <swon:Object>
                        <swon:Value arg:name=\"id\" arg:value=\"{= rdfs:subClassOf }0\"/>
                        <swon:Value arg:name=\"label\" arg:value=\"{= ui:label(rdfs:subClassOf) }\"/>
                        <swon:Value arg:name=\"source\" arg:value=\"{= ?focusNode }\"/>
                        <swon:Value arg:name=\"target\" arg:value=\"{= rdfs:subClassOf }\"/>
                    </swon:Object>
                    <swon:Comma/>
                    <ui:forEach ui:resultSet=\"{= ?parentClasses }\" ui:separator=\",\">
                        <swon:Object>
                            <swon:Value arg:name=\"id\" arg:value=\"{= rdfs:subClassOf }#{= afn:localname(?parentClass) }\"/>
                            <swon:Value arg:name=\"source\" arg:value=\"{= rdfs:subClassOf }\"/>
                            <swon:Value arg:name=\"target\" arg:value=\"{= ?parentClass }\"/>
                        </swon:Object>
                    </ui:forEach>
                </ui:if>
                <ui:else>
                    <ui:forEach ui:resultSet=\"{= ?parentClasses }\">
                        <swon:Object>
                            <swon:Value arg:name=\"id\" arg:value=\"{= rdfs:subClassOf }0\"/>
                            <swon:Value arg:name=\"label\" arg:value=\"{= ui:label(rdfs:subClassOf) }\"/>
                            <swon:Value arg:name=\"source\" arg:value=\"{= ?focusNode }\"/>
                            <swon:Value arg:name=\"target\" arg:value=\"{= ?parentClass }\"/>
                        </swon:Object>
                    </ui:forEach>
                </ui:else>
            </ui:if>
            <ui:if ui:condition=\"{= spr:rowCount(?properties) &gt; 0 }\">
                <ui:if ui:condition=\"{= spr:rowCount(?parentClasses) &gt; 0 }\">
                    <swon:Comma/>
                </ui:if>
                <ui:forEach ui:resultSet=\"{= ?properties }\" ui:separator=\",\">
                    <swon:Object let:range=\"{= smf:localRange(?focusNode, ?property) }\">
                        <swon:Value arg:name=\"id\" arg:value=\"{= ?property }0\"/>
                        <swon:Value arg:name=\"label\" arg:value=\"{= ui:label(?property) }\"/>
                        <swon:Value arg:name=\"source\" arg:value=\"{= ?focusNode }\"/>
                        <ui:if ui:condition=\"{= bound(?range) &amp;&amp; (!isBlank(?range)) }\">
                            <swon:Value arg:name=\"target\" arg:value=\"{= ?property }#{= afn:localname(?range) }\"/>
                        </ui:if>
                        <ui:else>
                            <swon:Value arg:name=\"target\" arg:value=\"{= ?property }#{= afn:localname(rdfs:Resource) }\"/>
                        </ui:else>
                    </swon:Object>
                </ui:forEach>
            </ui:if>
        </swon:Array>
    </swon:Value>
</swon:Object>
"""^^ui:Literal ;
  rdfs:subClassOf ui:JSONServices ;
.
swa:SigmaNeighborGramInstanceObjectPropertiesDataService
  a ui:JSONService ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:focusNode ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The focus node of the diagram" ;
    ] ;
  ui:prototype """
<swon:Object letrs:properties=\"{#
        SELECT DISTINCT ?property
        WHERE {
            ?focusNode ?property ?anyObject .
            BIND (swa:localRange(?property, ?focusNode) AS ?range) .
            FILTER ((!swa:isDatatypeRange(?range)) &amp;&amp; (?property != rdf:type)) .
            FILTER (!isBlank(?anyObject)) .
            FILTER (!isLiteral(?anyObject)) .
        } }\" letrs:types=\"{#
        SELECT DISTINCT ?type
        WHERE {
            ?focusNode a ?type .
        } }\">
    <swon:Value arg:name=\"nodes\">
        <swon:Array>
            <swon:Object>
                <swon:Value arg:name=\"id\" arg:value=\"{= ?focusNode }\"/>
                <swon:Value arg:name=\"label\" arg:value=\"{= ui:label(?focusNode) }\"/>
                <swon:Value arg:name=\"size\" arg:value=\"40\"/>
            </swon:Object>
            <ui:if ui:condition=\"{= spr:rowCount(?types) &gt; 0 }\">
                <swon:Comma/>
                <swon:Object>
                    <swon:Value arg:name=\"id\" arg:value=\"{= rdf:type }\"/>
                    <swon:Value arg:name=\"size\" arg:value=\"0\"/>
                </swon:Object>
                <swon:Comma/>
                <ui:forEach ui:resultSet=\"{= ?types }\" ui:separator=\",\">
                    <swon:Object>
                        <swon:Value arg:name=\"id\" arg:value=\"{= ?type }\"/>
                        <swon:Value arg:name=\"label\" arg:value=\"{= ui:label(?type) }\"/>
                        <swon:Value arg:name=\"size\" arg:value=\"40\"/>
                        <swon:Value arg:name=\"type\" arg:value=\"Class\"/>
                    </swon:Object>
                </ui:forEach>
            </ui:if>
            <ui:if ui:condition=\"{= spr:rowCount(?properties) &gt; 0 }\">
                <swon:Comma/>
                <ui:forEach ui:resultSet=\"{= ?properties }\" ui:separator=\",\">
                    <ui:group letrs:objects=\"{#
                            SELECT ?object
                            WHERE {
                                ?focusNode ?property ?object .
                            } }\">
                        <swon:Object>
                            <swon:Value arg:name=\"id\" arg:value=\"{= ?property }\"/>
                            <swon:Value arg:name=\"size\" arg:value=\"0\"/>
                        </swon:Object>
                        <swon:Comma/>
                        <ui:forEach ui:resultSet=\"{= ?objects }\" ui:separator=\",\">
                            <swon:Object>
                                <swon:Value arg:name=\"id\" arg:value=\"{= ?property }#{= smf:localName(?object) }\"/>
                                <swon:Value arg:name=\"label\" arg:value=\"{= ui:label(?object) }\"/>
                                <swon:Value arg:name=\"size\" arg:value=\"40\"/>
                                <swon:Value arg:name=\"alternateId\" arg:value=\"{= ?object }\"/>
                            </swon:Object>
                        </ui:forEach>
                    </ui:group>
                </ui:forEach>
            </ui:if>
        </swon:Array>
    </swon:Value>
    <swon:Value arg:name=\"edges\">
        <swon:Array>
            <ui:if ui:condition=\"{= spr:rowCount(?types) &gt; 0 }\">
                <swon:Object>
                    <swon:Value arg:name=\"id\" arg:value=\"{= rdf:type }0\"/>
                    <swon:Value arg:name=\"label\" arg:value=\"type\"/>
                    <swon:Value arg:name=\"source\" arg:value=\"{= ?focusNode }\"/>
                    <swon:Value arg:name=\"target\" arg:value=\"{= rdf:type }\"/>
                </swon:Object>
                <swon:Comma/>
                <ui:forEach ui:resultSet=\"{= ?types }\" ui:separator=\",\">
                    <swon:Object>
                        <swon:Value arg:name=\"id\" arg:value=\"{= rdf:type }#{= smf:localName(?type) }\"/>
                        <swon:Value arg:name=\"source\" arg:value=\"{= rdf:type }\"/>
                        <swon:Value arg:name=\"target\" arg:value=\"{= ?type }\"/>
                    </swon:Object>
                </ui:forEach>
            </ui:if>
            <ui:if ui:condition=\"{= spr:rowCount(?properties) &gt; 0 }\">
                <ui:if ui:condition=\"{= spr:rowCount(?types) &gt; 0 }\">
                    <swon:Comma/>
                </ui:if>
                <ui:forEach ui:resultSet=\"{= ?properties }\" ui:separator=\",\">
                    <ui:group letrs:objects=\"{#
                            SELECT ?object
                            WHERE {
                                ?focusNode ?property ?object .
                            } }\">
                        <swon:Object>
                            <swon:Value arg:name=\"id\" arg:value=\"{= ?property }0\"/>
                            <swon:Value arg:name=\"label\" arg:value=\"{= ui:label(?property) }\"/>
                            <swon:Value arg:name=\"source\" arg:value=\"{= ?focusNode }\"/>
                            <swon:Value arg:name=\"target\" arg:value=\"{= ?property }\"/>
                        </swon:Object>
                        <swon:Comma/>
                        <ui:forEach ui:resultSet=\"{= ?objects }\" ui:separator=\",\">
                            <swon:Object>
                                <swon:Value arg:name=\"id\" arg:value=\"{= ?property }#{= smf:localName(?object) }\"/>
                                <swon:Value arg:name=\"source\" arg:value=\"{= ?property }\"/>
                                <swon:Value arg:name=\"target\" arg:value=\"{= ?property }#{= smf:localName(?object) }\"/>
                            </swon:Object>
                        </ui:forEach>
                    </ui:group>
                </ui:forEach>
            </ui:if>
        </swon:Array>
    </swon:Value>
</swon:Object>
"""^^ui:Literal ;
  rdfs:subClassOf ui:JSONServices ;
.
swa:SimpleDataTableConfig
  a ui:Service ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
    ] ;
  ui:errorPrototype """
<ui:if ui:condition=\"{= !bound(?resourceType) }\">
    <swon:Object>
        <swon:Value arg:name=\"error\" arg:value=\"Resource Type is a required field.\"/>
    </swon:Object>
</ui:if>
"""^^ui:Literal ;
  ui:private true ;
  ui:prototype """
<swon:Object>
    <swon:Value arg:name=\"data\">
        <ui:classView ui:class=\"{= ?resourceType }\" ui:matchIds=\"results-table-config\"/>
    </swon:Value>
</swon:Object>
"""^^ui:Literal ;
  ui:responseType ui:JSON ;
  rdfs:label "Results table config" ;
  rdfs:subClassOf ui:JSONServices ;
.
swa:SimpleDataTableResults
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:createResourceHandler ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:createService ;
      spl:valueType xsd:string ;
      rdfs:comment "The service to use when creating a record in a the table. Used in conjunction with editable config option" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:hasFixedHeader ;
      spl:valueType xsd:boolean ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:hasFixedToolbar ;
      spl:valueType xsd:boolean ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:hasMultiSelect ;
      spl:valueType xsd:boolean ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:hasSelectAll ;
      spl:valueType xsd:boolean ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:hideToolbar ;
      spl:valueType xsd:boolean ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:onlyExportVisibleColumns ;
      spl:valueType xsd:boolean ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:orderedColumn ;
      spl:valueType xsd:integer ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:resourceSelectedEvent ;
      spl:valueType xsd:string ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:frozen ;
      spl:valueType xsd:boolean ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:id ;
      spl:valueType xsd:string ;
    ] ;
  ui:prototype """
<ui:group>
    <div class=\"results datatable-container\" data-create-service=\"{= COALESCE(?createService, swa:CreateResourceDialogBodyForAssetCollection) }\" data-create-service-handler=\"{= COALESCE(?createResourceHandler, swa:CreateResourceHandler) }\" data-editable=\"{= IF(bound(?frozen), (!?frozen), false) }\" data-has-clone-button=\"true\" data-has-exports=\"true\" data-has-filter=\"true\" data-has-fixed-header=\"{= IF(bound(?hasFixedHeader), ?hasFixedHeader, false) }\" data-has-fixed-toolbar=\"{= IF(bound(?hasFixedToolbar), ?hasFixedToolbar, false) }\" data-has-select-all=\"{= COALESCE(?hasSelectAll, true) }\" data-hide-toolbar=\"{= IF(bound(?hideToolbar), ?hideToolbar, false) }\" data-multiselect=\"{= COALESCE(?hasMultiSelect, true) }\" data-only-export-visible-columns=\"{= COALESCE(?onlyExportVisibleColumns, ?nil) }\" data-ordered-column=\"{= COALESCE(?orderedColumn, ?nil) }\" data-resource-selected-event=\"{= COALESCE(?resourceSelectedEvent, ?none) }\" data-viewable-details=\"true\" id=\"{= COALESCE(?id, &quot;tb-results-table&quot;) }\"/>
</ui:group>
"""^^ui:Literal ;
  rdfs:label "Simple data table results" ;
  rdfs:subClassOf swa:GridElements ;
.
swa:SortedInstances
  a spin:SelectTemplate ;
  spin:body [
      a sp:Select ;
      sp:distinct true ;
      sp:orderBy (
          [
            sp:varName "label" ;
          ]
        ) ;
      sp:resultVariables (
          [
            sp:varName "instance" ;
          ]
          [
            sp:varName "label" ;
          ]
        ) ;
      sp:where (
          [
            a sp:TriplePath ;
            sp:object [
                sp:varName "class" ;
              ] ;
            sp:path [
                a sp:ModPath ;
                sp:modMax -2 ;
                sp:modMin 0 ;
                sp:subPath rdfs:subClassOf ;
              ] ;
            sp:subject [
                sp:varName "type" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "type" ;
              ] ;
            sp:predicate rdf:type ;
            sp:subject [
                sp:varName "instance" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a ui:label ;
                sp:arg1 [
                    sp:varName "instance" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "label" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:class ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class to return the instances of." ;
    ] ;
  rdfs:comment "Gets all instances of a given class and its subclasses, ordered by their label." ;
  rdfs:label "Sorted instances" ;
  rdfs:subClassOf spin:SelectTemplates ;
.
swa:SortedObjects
  a spin:SelectTemplate ;
  spin:body [
      a sp:Select ;
      sp:orderBy (
          [
            sp:varName "label" ;
          ]
        ) ;
      sp:resultVariables (
          [
            sp:varName "object" ;
          ]
        ) ;
      sp:where (
          (
            [
              a sp:Filter ;
              sp:expression [
                  a sp:bound ;
                  sp:arg1 [
                      sp:varName "subject" ;
                    ] ;
                ] ;
            ]
          )
          [
            a sp:Union ;
            sp:elements (
                (
                  [
                    sp:object [
                        sp:varName "object" ;
                      ] ;
                    sp:predicate [
                        sp:varName "predicate" ;
                      ] ;
                    sp:subject [
                        sp:varName "subject" ;
                      ] ;
                  ]
                )
                (
                  (
                    [
                      sp:object [
                          sp:varName "predicate" ;
                        ] ;
                      sp:predicate sh:predicate ;
                      sp:subject [
                          sp:varName "rule" ;
                        ] ;
                    ]
                    [
                      sp:object sh:this ;
                      sp:predicate sh:subject ;
                      sp:subject [
                          sp:varName "rule" ;
                        ] ;
                    ]
                    [
                      sp:object [
                          sp:varName "rule" ;
                        ] ;
                      sp:predicate sh:rule ;
                      sp:subject [
                          sp:varName "shape" ;
                        ] ;
                    ]
                    [
                      a sp:Filter ;
                      sp:expression [
                          a sp:notExists ;
                          sp:elements (
                              [
                                sp:object true ;
                                sp:predicate sh:deactivated ;
                                sp:subject [
                                    sp:varName "rule" ;
                                  ] ;
                              ]
                            ) ;
                        ] ;
                    ]
                    [
                      a sp:Filter ;
                      sp:expression [
                          a tosh:isInTargetOf ;
                          sp:arg1 [
                              sp:varName "subject" ;
                            ] ;
                          sp:arg2 [
                              sp:varName "shape" ;
                            ] ;
                        ] ;
                    ]
                    [
                      a sp:Filter ;
                      sp:expression [
                          a sp:notExists ;
                          sp:elements (
                              [
                                sp:object [
                                    sp:varName "condition" ;
                                  ] ;
                                sp:predicate sh:condition ;
                                sp:subject [
                                    sp:varName "rule" ;
                                  ] ;
                              ]
                              [
                                a sp:Filter ;
                                sp:expression [
                                    a sp:not ;
                                    sp:arg1 [
                                        a tosh:hasShape ;
                                        sp:arg1 [
                                            sp:varName "subject" ;
                                          ] ;
                                        sp:arg2 [
                                            sp:varName "condition" ;
                                          ] ;
                                      ] ;
                                  ] ;
                              ]
                            ) ;
                        ] ;
                    ]
                  )
                  [
                    sp:object [
                        sp:varName "expr" ;
                      ] ;
                    sp:predicate sh:object ;
                    sp:subject [
                        sp:varName "rule" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "expr" ;
                      ] ;
                    sp:predicate rdf:first ;
                    sp:subject [
                        sp:varName "?0" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "?1" ;
                      ] ;
                    sp:predicate rdf:rest ;
                    sp:subject [
                        sp:varName "?0" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "subject" ;
                      ] ;
                    sp:predicate rdf:first ;
                    sp:subject [
                        sp:varName "?1" ;
                      ] ;
                  ]
                  [
                    sp:object () ;
                    sp:predicate rdf:rest ;
                    sp:subject [
                        sp:varName "?1" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "object" ;
                      ] ;
                    sp:predicate tosh:evalExpr ;
                    sp:subject [
                        sp:varName "?0" ;
                      ] ;
                  ]
                  [
                    a sp:Filter ;
                    sp:expression [
                        a sp:notExists ;
                        sp:elements (
                            [
                              sp:object [
                                  sp:varName "object" ;
                                ] ;
                              sp:predicate [
                                  sp:varName "predicate" ;
                                ] ;
                              sp:subject [
                                  sp:varName "subject" ;
                                ] ;
                            ]
                          ) ;
                      ] ;
                  ]
                )
              ) ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a ui:label ;
                sp:arg1 [
                    sp:varName "object" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "label" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate to get the objects of." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:subject ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject to get the values of. " ;
    ] ;
  rdfs:comment "Gets all objects of a given subject/predicate combination, ordering the objects by their ui:labels." ;
  rdfs:label "Sorted objects" ;
  rdfs:subClassOf spin:SelectTemplates ;
.
swa:SortedObjectsByLanguage
  a spin:SelectTemplate ;
  spin:body [
      a sp:Select ;
      sp:orderBy (
          [
            sp:varName "langRank" ;
          ]
          [
            sp:varName "lang" ;
          ]
          [
            sp:varName "label" ;
          ]
        ) ;
      sp:resultVariables (
          [
            sp:varName "object" ;
          ]
        ) ;
      sp:where (
          (
            [
              a sp:Filter ;
              sp:expression [
                  a sp:bound ;
                  sp:arg1 [
                      sp:varName "subject" ;
                    ] ;
                ] ;
            ]
          )
          [
            a sp:Union ;
            sp:elements (
                (
                  [
                    sp:object [
                        sp:varName "object" ;
                      ] ;
                    sp:predicate [
                        sp:varName "predicate" ;
                      ] ;
                    sp:subject [
                        sp:varName "subject" ;
                      ] ;
                  ]
                )
                (
                  (
                    [
                      sp:object [
                          sp:varName "predicate" ;
                        ] ;
                      sp:predicate sh:predicate ;
                      sp:subject [
                          sp:varName "rule" ;
                        ] ;
                    ]
                    [
                      sp:object sh:this ;
                      sp:predicate sh:subject ;
                      sp:subject [
                          sp:varName "rule" ;
                        ] ;
                    ]
                    [
                      sp:object [
                          sp:varName "rule" ;
                        ] ;
                      sp:predicate sh:rule ;
                      sp:subject [
                          sp:varName "shape" ;
                        ] ;
                    ]
                    [
                      a sp:Filter ;
                      sp:expression [
                          a sp:notExists ;
                          sp:elements (
                              [
                                sp:object true ;
                                sp:predicate sh:deactivated ;
                                sp:subject [
                                    sp:varName "rule" ;
                                  ] ;
                              ]
                            ) ;
                        ] ;
                    ]
                    [
                      a sp:Filter ;
                      sp:expression [
                          a tosh:isInTargetOf ;
                          sp:arg1 [
                              sp:varName "subject" ;
                            ] ;
                          sp:arg2 [
                              sp:varName "shape" ;
                            ] ;
                        ] ;
                    ]
                    [
                      a sp:Filter ;
                      sp:expression [
                          a sp:notExists ;
                          sp:elements (
                              [
                                sp:object [
                                    sp:varName "condition" ;
                                  ] ;
                                sp:predicate sh:condition ;
                                sp:subject [
                                    sp:varName "rule" ;
                                  ] ;
                              ]
                              [
                                a sp:Filter ;
                                sp:expression [
                                    a sp:not ;
                                    sp:arg1 [
                                        a tosh:hasShape ;
                                        sp:arg1 [
                                            sp:varName "subject" ;
                                          ] ;
                                        sp:arg2 [
                                            sp:varName "condition" ;
                                          ] ;
                                      ] ;
                                  ] ;
                              ]
                            ) ;
                        ] ;
                    ]
                  )
                  [
                    sp:object [
                        sp:varName "expr" ;
                      ] ;
                    sp:predicate sh:object ;
                    sp:subject [
                        sp:varName "rule" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "expr" ;
                      ] ;
                    sp:predicate rdf:first ;
                    sp:subject [
                        sp:varName "?0" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "?1" ;
                      ] ;
                    sp:predicate rdf:rest ;
                    sp:subject [
                        sp:varName "?0" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "subject" ;
                      ] ;
                    sp:predicate rdf:first ;
                    sp:subject [
                        sp:varName "?1" ;
                      ] ;
                  ]
                  [
                    sp:object () ;
                    sp:predicate rdf:rest ;
                    sp:subject [
                        sp:varName "?1" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "object" ;
                      ] ;
                    sp:predicate tosh:evalExpr ;
                    sp:subject [
                        sp:varName "?0" ;
                      ] ;
                  ]
                  [
                    a sp:Filter ;
                    sp:expression [
                        a sp:notExists ;
                        sp:elements (
                            [
                              sp:object [
                                  sp:varName "object" ;
                                ] ;
                              sp:predicate [
                                  sp:varName "predicate" ;
                                ] ;
                              sp:subject [
                                  sp:varName "subject" ;
                                ] ;
                            ]
                          ) ;
                      ] ;
                  ]
                )
              ) ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a ui:label ;
                sp:arg1 [
                    sp:varName "object" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "label" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:coalesce ;
                sp:arg1 [
                    a sp:lang ;
                    sp:arg1 [
                        sp:varName "object" ;
                      ] ;
                  ] ;
                sp:arg2 "" ;
              ] ;
            sp:variable [
                sp:varName "lang" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:coalesce ;
                sp:arg1 [
                    a spif:indexOf ;
                    sp:arg1 [
                        sp:varName "languages" ;
                      ] ;
                    sp:arg2 [
                        sp:varName "lang" ;
                      ] ;
                  ] ;
                sp:arg2 1000 ;
              ] ;
            sp:variable [
                sp:varName "rank" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:if ;
                sp:arg1 [
                    a sp:eq ;
                    sp:arg1 [
                        sp:varName "lang" ;
                      ] ;
                    sp:arg2 [
                        sp:varName "currentLang" ;
                      ] ;
                  ] ;
                sp:arg2 -1 ;
                sp:arg3 [
                    sp:varName "rank" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "langRank" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:currentLang ;
      spl:valueType xsd:string ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:languages ;
      spl:valueType xsd:string ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate to get the objects of." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:subject ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject to get the values of. " ;
    ] ;
  rdfs:comment "Gets all objects of a given subject/predicate combination, ordering the objects by their ui:labels." ;
  rdfs:label "Sorted objects" ;
  rdfs:subClassOf spin:SelectTemplates ;
.
swa:SortedSubjects
  a spin:SelectTemplate ;
  spin:body [
      a sp:Select ;
      sp:orderBy (
          [
            sp:varName "label" ;
          ]
        ) ;
      sp:resultVariables (
          [
            sp:varName "subject" ;
          ]
        ) ;
      sp:where (
          (
            [
              a sp:Filter ;
              sp:expression [
                  a sp:bound ;
                  sp:arg1 [
                      sp:varName "object" ;
                    ] ;
                ] ;
            ]
          )
          [
            sp:object [
                sp:varName "object" ;
              ] ;
            sp:predicate [
                sp:varName "predicate" ;
              ] ;
            sp:subject [
                sp:varName "subject" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a ui:label ;
                sp:arg1 [
                    sp:varName "subject" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "label" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:object ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The object to get the values of. " ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate to get the objects of." ;
    ] ;
  rdfs:comment "Gets all (IRI) subjects of a given predicate/object combination, ordered by ui:labels." ;
  rdfs:label "Sorted subjects" ;
  rdfs:subClassOf spin:SelectTemplates ;
.
swa:SourceCodeEditor
  a swa:ObjectEditorClass ;
  ui:prototype """
<ui:group let:str=\"{= smf:turtleString(?object) }\">
    <div let:rows=\"{= IF(bound(?object), (swa:countStringMatches(?str, &quot;\\n&quot;) + 1), 4) }\">
        <input name=\"sourceCode-{= ?uid }\" type=\"hidden\" value=\"true\"/>
        <textarea class=\"swa-text-area swa-source-code-editor\" id=\"new-{= ?uid }\" name=\"new-{= ?uid }\" rows=\"{= ?rows }\" title=\"Enter a snippet of Turtle source code {= IF((sh:or = ?predicate), &quot;or use syntax such as \\&quot;xsd:string or rdf:langString\\&quot; for unions of multiple datatypes or classes&quot;, ?none) }\">{= ?str }</textarea>
        <script>$(\"#new-{= ?uid }\").bind(\"input propertychange\", function() { {= ui:functionCall(\"swa.updateSourceCodeEditor\", ?uid, swa:CheckSourceCodeService, ?subject, ?predicate) } });</script>
    </div>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "A text area for source code that is validated server-side using the same logic as complex TBC row editors are, i.e. SHACL expressions and RDF lists will be understood." ;
  rdfs:label "Source code editor" ;
  rdfs:subClassOf swa:ObjectEditor ;
.
swa:SourceCodeViewer
  a swa:ObjectViewerClass ;
  ui:prototype """
<div class=\"swa-shifted-label\">
    <pre class=\"swa-source-code-viewer\">{= smf:turtleString(?object) }</pre>
</div>
"""^^ui:Literal ;
  rdfs:comment "A viewer that renders node values as pre-formatted Turtle output, i.e. with line breaks formatted as they would in a text viewer. This is the default viewer for some SHACL blank nodes that are rendered as Turtle." ;
  rdfs:label "Source code viewer" ;
  rdfs:subClassOf swa:ObjectViewer ;
.
swa:Space
  a ui:NodeClass ;
  ui:prototype """
<ui:group>&nbsp;</ui:group>
"""^^ui:Literal ;
  rdfs:comment "A non-breaking space - wrapped into a tag for readability and flexibillity." ;
  rdfs:label "Space" ;
  rdfs:subClassOf swa:LayoutElements ;
.
swa:Spaces
  a ui:NodeClass ;
  ui:prototype """
<ui:group>&nbsp;&nbsp;&nbsp;&nbsp;</ui:group>
"""^^ui:Literal ;
  rdfs:comment "Several non-breaking space - wrapped into a tag for readability and flexibillity." ;
  rdfs:label "Spaces" ;
  rdfs:subClassOf swa:LayoutElements ;
.
swa:SplitCommas
  a spin:SelectTemplate ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "value" ;
          ]
        ) ;
      sp:where (
          (
            [
              a sp:Filter ;
              sp:expression [
                  a sp:bound ;
                  sp:arg1 [
                      sp:varName "string" ;
                    ] ;
                ] ;
            ]
          )
          [
            sp:object [
                sp:varName "?0" ;
              ] ;
            sp:predicate spif:split ;
            sp:subject [
                sp:varName "raw" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "string" ;
              ] ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "?0" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "?1" ;
              ] ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "?0" ;
              ] ;
          ]
          [
            sp:object "," ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "?1" ;
              ] ;
          ]
          [
            sp:object () ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "?1" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a spif:trim ;
                sp:arg1 [
                    sp:varName "raw" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "value" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:string ;
      spl:valueType xsd:string ;
      rdfs:comment "The string to process." ;
    ] ;
  rdfs:comment "Turns a comma-separated string into a result set of individual tokens. This template can be used, among others, to fetch a specific item by index." ;
  rdfs:label "Split commas" ;
  rdfs:subClassOf spin:SelectTemplates ;
.
swa:Subject
  a ui:NodeClass ;
  ui:prototype """
<swa:LabeledSubjects arg:single=\"{= true }\" ui:args=\"*\"/>
"""^^ui:Literal ;
  rdfs:comment "Inserts a widget for a single value of a given (inverse) predicate at the given object. This element should only be used if the property doesn't have a max cardinality of 1 anyway, to overload the default behavior." ;
  rdfs:label "Subject" ;
  rdfs:subClassOf swa:AbstractSubject ;
.
swa:SubjectEditWidgetMiddleColumn
  a swa:SubjectWidgetMiddleColumnClass ;
  ui:prototype """
<td class=\"swa-labeled-objects-icons-td\">
    <div class=\"{= IF(?single, &quot;swa-display-none&quot;, &quot; swa-icon&quot;) } swa-add-button-div\" id=\"error-{= ?predicate }\">
        <a class=\"swa-add-row-button\" href=\"javascript:void(0)\" onclick=\"{= ui:functionCall(&quot;swa.addSubjectEditorRow&quot;, ui:currentQueryGraph(), CONCAT(?uid, &quot;-body&quot;), (?single = true), ?object, ?predicate, COALESCE(swa:appName(), &quot;&quot;), ?editWidget) }\"/>
    </div>
</td>
"""^^ui:Literal ;
  rdfs:label "Subject edit widget middle column" ;
  rdfs:subClassOf swa:SubjectWidgetMiddleColumn ;
.
swa:SubjectEditor
  a swa:SubjectEditorClass ;
  ui:private true ;
  ui:prototype """
<ui:group let:class=\"{= swa:bestSubjectEditorClass(?object, ?predicate, ?subject) }\">
    <ui:if ui:condition=\"{= bound(?class) }\">
        <ui:dynamicView arg:object=\"{= ?object }\" arg:predicate=\"{= ?predicate }\" arg:subject=\"{= ?subject }\" arg:uid=\"{= ?uid }\" ui:class=\"{= ?class }\"/>
    </ui:if>
    <ui:else>
        <b>ERROR: No SubjectEditor found for {= ui:label(?predicate) } at {= ui:label(swa:resourceType(?object)) }</b>
    </ui:else>
</ui:group>
"""^^ui:Literal ;
  rdfs:label "Subject editor" ;
  rdfs:subClassOf swa:SubjectWidget ;
.
swa:SubjectEditorClass
  a rdfs:Class ;
  rdfs:comment "Metaclass of SubjectEditors." ;
  rdfs:label "Subject editor class" ;
  rdfs:subClassOf swa:SubjectWidgetClass ;
.
swa:SubjectEditorHiddenFields
  a swa:ObjectWidgetClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:subject ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject node." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:uid ;
      spl:valueType xsd:string ;
      rdfs:comment "The unique id of this group." ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:group>
    <input class=\"swa-editor-hidden-field\" name=\"{= fn:concat(&quot;resource-&quot;, ?uid) }\" type=\"hidden\" value=\"{= ui:encodeNode(COALESCE(?object, &lt;urn:x-app-edit:root&gt;), true, true) }\"/>
    <input class=\"swa-editor-hidden-field\" name=\"{= fn:concat(&quot;path-&quot;, ?uid) }\" type=\"hidden\" value=\"{= fn:concat(&quot;-&quot;, ui:encodeNode(?predicate, true, true)) }\"/>
    <ui:if ui:condition=\"{= bound(?subject) }\">
        <input class=\"swa-editor-hidden-field\" name=\"{= fn:concat(&quot;old-&quot;, ?uid) }\" type=\"hidden\" value=\"{= ui:encodeNode(?subject, true, true) }\"/>
    </ui:if>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "Inserts the hidden fields needed to link the server with a widget. Note that the fields have a marker class swa.editorHiddenField that is used by delete row operations." ;
  rdfs:label "Subject editor hidden fields" ;
  rdfs:subClassOf swa:SubjectElements ;
.
swa:SubjectEditorRow
  a ui:SubjectWidgetRowClass ;
  ui:private true ;
  ui:prototype """
<ui:group let:uid=\"{= ui:uniqueId() }\">
    <ui:if ui:condition=\"{= ((bound(?subject) &amp;&amp; bound(?object)) &amp;&amp; bound(?predicate)) &amp;&amp; swa:isReadOnlyTriple(?subject, ?predicate, ?object) }\">
        <swa:SubjectViewer ui:args=\"*\"/>
    </ui:if>
    <ui:else>
        <table class=\"swa-object-editor-row-table\" id=\"{= ?uid }\">
            <tr>
                <td class=\"swa-object-row-main-td\">
                    <swa:SubjectEditorHiddenFields ui:args=\"*\"/>
                    <swa:SubjectEditor ui:args=\"*\"/>
                </td>
                <td class=\"swa-object-row-button-td\">
                    <a class=\"swa-icon ui-icon ui-icon-closethick\" href=\"javascript:void(0)\" onclick=\"swa.deleteRow(&quot;{= ?uid }&quot;)\"/>
                </td>
            </tr>
        </table>
    </ui:else>
</ui:group>
"""^^ui:Literal ;
  ui:responseType ui:HTML ;
  rdfs:comment "A row of a SubjectEditor." ;
  rdfs:label "Subject editor row" ;
  rdfs:subClassOf swa:SubjectWidgetRow ;
.
swa:SubjectElements
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:object ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The object (usually the resource of the surrounding form)." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate." ;
    ] ;
  ui:abstract true ;
  ui:private true ;
  rdfs:comment "Abstract base class for elements that operate on subjects of a given predicate/object combination." ;
  rdfs:label "Subject elements" ;
  rdfs:subClassOf swa:FormElements ;
.
swa:SubjectFacet
  a swa:SubjectFacetClass ;
  ui:private true ;
  ui:prototype """
<ui:group let:class=\"{= swa:bestSubjectFacetClass(?predicate, ?subject) }\">
    <ui:if ui:condition=\"{= bound(?class) }\">
        <ui:dynamicView arg:object=\"{= ?object }\" arg:predicate=\"{= ?predicate }\" arg:subject=\"{= ?subject }\" arg:uid=\"{= ?uid }\" ui:class=\"{= ?class }\"/>
    </ui:if>
    <ui:else>
        <b>ERROR: No SubjectFacet found for {= ui:label(?predicate) } at {= ui:label(swa:resourceType(?object)) }</b>
    </ui:else>
</ui:group>
"""^^ui:Literal ;
  rdfs:label "Subject facet" ;
  rdfs:subClassOf swa:SubjectWidget ;
.
swa:SubjectFacetClass
  a rdfs:Class ;
  rdfs:comment "Metaclass of SubjectWidgets." ;
  rdfs:label "Subject facet class" ;
  rdfs:subClassOf swa:SubjectWidgetClass ;
.
swa:SubjectFacetRow
  a ui:SubjectWidgetRowClass ;
  ui:prototype """
<ui:group let:uid=\"{= ui:uniqueId() }\">
    <table>
        <tr>
            <td class=\"swa-widget-span swa-align-top\" id=\"{= ?uid }\">
                <ui:loadable ui:loadId=\"{= ?uid }-loadable\">
                    <input name=\"facet{= ?uid }\" type=\"hidden\" value=\"-{= ui:encodeNode(?predicate, true, true) }\"/>
                    <ui:group let:subjectVarName=\"{= ui:contextValue(&quot;subjectVarName&quot;) }\">
                        <ui:if ui:condition=\"{= bound(?subjectVarName) }\">
                            <input name=\"subject{= ?uid }\" type=\"hidden\" value=\"{= ?subjectVarName }\"/>
                        </ui:if>
                    </ui:group>
                    <ui:if ui:condition=\"{= bound(?selectedWidget) }\">
                        <ui:dynamicView arg:predicate=\"{= ?predicate }\" arg:uid=\"{= ?uid }\" ui:class=\"{= ?selectedWidget }\"/>
                    </ui:if>
                    <ui:else>
                        <swa:SubjectFacet arg:predicate=\"{= ?predicate }\" arg:uid=\"{= ?uid }\"/>
                    </ui:else>
                </ui:loadable>
            </td>
            <td class=\"swa-align-top\" let:buttonId=\"{= ui:uniqueId() }\">
                <div class=\"swa-facet-selector\" id=\"{= ?buttonId }\" onclick=\"{= ui:functionCall(&quot;swa.openFacetSelectionMenu&quot;, ?buttonId, ?uid, swa:resourceType(), ?predicate, true) }\" title=\"Alternative filters\"/>
            </td>
        </tr>
    </table>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "A row of a SubjectFacet." ;
  rdfs:label "Subject facet row" ;
  rdfs:subClassOf swa:SubjectWidgetRow ;
.
swa:SubjectFacetWidgets
  a spin:SelectTemplate ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "actionName" ;
          ]
          [
            sp:varName "actionLocalName" ;
          ]
          [
            sp:varName "onSelect" ;
          ]
          [
            sp:varName "enabled" ;
          ]
          [
            sp:varName "group" ;
          ]
          [
            sp:varName "label" ;
          ]
          [
            sp:varName "iconClass" ;
          ]
        ) ;
      sp:where (
          [
            a sp:NamedGraph ;
            sp:elements (
                [
                  a sp:SubQuery ;
                  sp:query [
                      a sp:Select ;
                      sp:orderBy (
                          [
                            a sp:Desc ;
                            sp:expression [
                                sp:varName "weight" ;
                              ] ;
                          ]
                        ) ;
                      sp:where (
                          [
                            sp:object [
                                sp:varName "label" ;
                              ] ;
                            sp:predicate swa:subjectFacetMenuName ;
                            sp:subject [
                                sp:varName "widgetClass" ;
                              ] ;
                          ]
                          [
                            sp:object [
                                sp:varName "w" ;
                              ] ;
                            sp:predicate swa:subjectWidgetWeight ;
                            sp:subject [
                                sp:varName "widgetClass" ;
                              ] ;
                          ]
                          [
                            sp:object [
                                sp:varName "expression" ;
                              ] ;
                            sp:predicate swa:expression ;
                            sp:subject [
                                sp:varName "w" ;
                              ] ;
                          ]
                          [
                            a sp:Bind ;
                            sp:expression [
                                a sp:coalesce ;
                                sp:arg1 [
                                    a spl:object ;
                                    sp:arg1 [
                                        sp:varName "w" ;
                                      ] ;
                                    sp:arg2 swa:weight ;
                                  ] ;
                                sp:arg2 0 ;
                              ] ;
                            sp:variable [
                                sp:varName "weight" ;
                              ] ;
                          ]
                        ) ;
                    ] ;
                ]
                [
                  a sp:Filter ;
                  sp:expression [
                      a spin:eval ;
                      sp:arg1 [
                          sp:varName "expression" ;
                        ] ;
                      sp:arg2 arg:predicate ;
                      sp:arg3 [
                          sp:varName "predicate" ;
                        ] ;
                      sp:arg4 arg:domain ;
                      sp:arg5 [
                          sp:varName "domain" ;
                        ] ;
                      sp:arg6 arg:resourceType ;
                      sp:arg7 [
                          sp:varName "resourceType" ;
                        ] ;
                    ] ;
                ]
                [
                  a sp:Bind ;
                  sp:expression [
                      sp:varName "widgetClass" ;
                    ] ;
                  sp:variable [
                      sp:varName "actionName" ;
                    ] ;
                ]
                [
                  a sp:Bind ;
                  sp:expression [
                      a afn:localname ;
                      sp:arg1 [
                          sp:varName "widgetClass" ;
                        ] ;
                    ] ;
                  sp:variable [
                      sp:varName "actionLocalName" ;
                    ] ;
                ]
                [
                  a sp:Bind ;
                  sp:expression true ;
                  sp:variable [
                      sp:varName "enabled" ;
                    ] ;
                ]
                [
                  a sp:Bind ;
                  sp:expression [
                      a sp:concat ;
                      sp:arg1 "swa.replaceFacet('" ;
                      sp:arg2 [
                          sp:varName "elementId" ;
                        ] ;
                      sp:arg3 "', '" ;
                      sp:arg4 [
                          a xsd:string ;
                          sp:arg1 [
                              sp:varName "widgetClass" ;
                            ] ;
                        ] ;
                      sp:arg5 "', '" ;
                      sp:arg6 [
                          a xsd:string ;
                          sp:arg1 [
                              sp:varName "resourceType" ;
                            ] ;
                        ] ;
                      sp:arg7 "', '" ;
                      sp:arg8 [
                          a xsd:string ;
                          sp:arg1 [
                              sp:varName "predicate" ;
                            ] ;
                        ] ;
                      sp:arg9 "')" ;
                    ] ;
                  sp:variable [
                      sp:varName "onSelect" ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode ui:graph ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:domain ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The domain of the property." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:elementId ;
      spl:valueType xsd:string ;
      rdfs:comment "The id of the surrounding element that shall have its content replaced." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate to get the widget for." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The resource type on the form." ;
    ] ;
  spin:private true ;
  rdfs:comment "Gets the suitable facet widgets for a drop down menu." ;
  rdfs:label "Subject facet widgets" ;
  rdfs:subClassOf spin:SelectTemplates ;
.
swa:SubjectFacetWidgetsCallback
  a ui:JSONService ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:elementId ;
      spl:valueType xsd:string ;
      rdfs:comment "The id of the div holding the current widget." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate of the widget." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The class on the form." ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:call arg:domain=\"{= swa:localDomain(?none, ?predicate) }\" arg:elementId=\"{= ?elementId }\" arg:predicate=\"{= ?predicate }\" arg:resourceType=\"{= ?resourceType }\" ui:args=\"template\" ui:template=\"{= swa:SubjectFacetWidgets }\">
    <swon:RSObjectArray arg:resultSet=\"{= ?rs }\"/>
</ui:call>
"""^^ui:Literal ;
  rdfs:label "Subject facet widgets callback" ;
  rdfs:subClassOf swa:MenuElements ;
  rdfs:subClassOf ui:JSONServices ;
.
swa:SubjectPredicateSelectionTemplates
  a spin:SelectTemplate ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:object ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The object (the main resource on the form)." ;
    ] ;
  rdfs:label "Subject predicate selection templates" ;
  rdfs:subClassOf spin:SelectTemplates ;
.
swa:SubjectSearchWidgetMiddleColumn
  a swa:SubjectWidgetMiddleColumnClass ;
  ui:prototype """
<td class=\"swa-labeled-objects-icons-td\" let:buttonId=\"{= ui:uniqueId() }\" let:restoreSearch=\"{= ui:contextValue(&quot;swaRestoreSearch&quot;) }\">
    <div class=\"swa-key-property-input {= IF(bound(?restoreSearch), swa:inverseKeyPropertyInputClass(?predicate, ?restoreSearch), &quot;swa-key-property-unchecked&quot;) } {= IF(ui:contextValue(&quot;suppressKeyPropertiesSelection&quot;), &quot;ui-helper-hidden-accessible&quot;, ?none) }\" id=\"{= ?buttonId }\" onclick=\"swa.clickKeyPropertyBox('{= ?buttonId }')\" title=\"Include as search results column (#: column displays number of values)\" value=\"-{= ui:encodeNode(?predicate, true, true) }\"/>
</td>
"""^^ui:Literal ;
  rdfs:comment "The middle column on search forms, containing the check box to include the property as a key property (column in the result set)." ;
  rdfs:label "Subject search widget middle column" ;
  rdfs:subClassOf swa:SubjectWidgetMiddleColumn ;
.
swa:SubjectViewer
  a swa:SubjectViewerClass ;
  ui:private true ;
  ui:prototype """
<div class=\"swa-object-widget\" let:class=\"{= swa:bestSubjectViewerClass(?object, ?predicate, ?subject) }\">
    <ui:dynamicView arg:object=\"{= ?object }\" arg:predicate=\"{= ?predicate }\" arg:subject=\"{= ?subject }\" ui:class=\"{= ?class }\"/>
</div>
"""^^ui:Literal ;
  rdfs:comment "A viewer of subjects. Will be substituted with the most suitable viewer class." ;
  rdfs:label "Subject viewer" ;
  rdfs:subClassOf swa:SubjectWidget ;
.
swa:SubjectViewerClass
  a rdfs:Class ;
  rdfs:comment "Metaclass of SubjectViewers." ;
  rdfs:label "Subject viewer class" ;
  rdfs:subClassOf swa:SubjectWidgetClass ;
.
swa:SubjectViewerRow
  a ui:SubjectWidgetRowClass ;
  ui:private true ;
  ui:prototype """
<ui:group let:uid=\"{= ui:uniqueId() }\">
    <div about=\"{= IF(isIRI(?subject), ?subject, ?noBNodes) }\" class=\"swa-widget-row\" href=\"{= IF(isIRI(?object), ?object, ?no) }\" id=\"{= ?uid }\" rel=\"{= IF(isIRI(?object), ui:encodeNode(?predicate, true, true), ?no) }\" ui:addNamespace=\"{= ?predicate }\">
        <swa:SubjectViewer arg:uid=\"{= ?uid }\" ui:args=\"*\"/>
    </div>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "A row in a SubjectViewer." ;
  rdfs:label "Subject viewer row" ;
  rdfs:subClassOf swa:SubjectWidgetRow ;
.
swa:SubjectWidget
  a swa:SubjectWidgetClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:subject ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject being displayed." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:uid ;
      spl:valueType xsd:string ;
      rdfs:comment "The uid used to identify the triple." ;
    ] ;
  ui:abstract true ;
  ui:private true ;
  rdfs:comment "Superclass of widgets for a given subject." ;
  rdfs:label "Subject widget" ;
  rdfs:subClassOf swa:SubjectElements ;
.
swa:SubjectWidgetClass
  a rdfs:Class ;
  rdfs:comment "The metaclass of SubjectWidgets." ;
  rdfs:label "Subject widget class" ;
  rdfs:subClassOf ui:NodeClass ;
.
swa:SubjectWidgetMiddleColumn
  a swa:SubjectWidgetMiddleColumnClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:editWidget ;
      spl:valueType swa:ObjectEditorClass ;
      rdfs:comment "The preferred widget if in edit mode." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:searchWidget ;
      spl:valueType swa:ObjectFacetClass ;
      rdfs:comment "The preferred facet widget." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:single ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True whether the surrounding widget has at most one value." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:viewWidget ;
      spl:valueType swa:ObjectViewerClass ;
      rdfs:comment "The preferred widget if in view mode." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:uid ;
      spl:valueType xsd:string ;
      rdfs:comment "The uid of the surrounding widget." ;
    ] ;
  ui:abstract true ;
  ui:private true ;
  rdfs:comment "Base class of the elements that can show up as middle column between the label and the actual widgets on a form. The selection of the particular middle column element is made through the mode property swa:subjectWidgetMiddleColumnClass." ;
  rdfs:label "Subject widget middle column" ;
  rdfs:subClassOf swa:SubjectElements ;
.
swa:SubjectWidgetMiddleColumnClass
  a rdfs:Class ;
  rdfs:comment "Metaclass of the various subject widget middle column types." ;
  rdfs:label "Subject widget middle column class" ;
  rdfs:subClassOf ui:NodeClass ;
.
swa:SubjectWidgetRow
  a ui:SubjectWidgetRowClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:subject ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject to display." ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:dynamicView arg:object=\"{= ?object }\" arg:predicate=\"{= ?predicate }\" arg:subject=\"{= ?subject }\" ui:class=\"{= swa:modeProperty(swa:subjectWidgetRowClass) }\"/>
"""^^ui:Literal ;
  rdfs:comment "A row of a SubjectWidget." ;
  rdfs:label "Subject widget row" ;
  rdfs:subClassOf swa:SubjectElements ;
.
swa:Subjects
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:single ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to only allow at most one subject for this component." ;
    ] ;
  ui:prototype """
<swa:LabeledSubjects ui:args=\"*\"/>
"""^^ui:Literal ;
  rdfs:comment "Inserts a widget for a given predicate/object combination, showing the subjects as values. This is typically known as \"Incoming References\"." ;
  rdfs:label "Subjects" ;
  rdfs:subClassOf swa:AbstractSubject ;
.
swa:SubjectsBody
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:single ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to allow at most one value." ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:group>
    <ui:if ui:condition=\"{= bound(?object) }\">
        <ui:call arg:object=\"{= ?object }\" arg:predicate=\"{= ?predicate }\" let:limit=\"{= 2000 }\" ui:template=\"{= swa:SortedSubjects }\">
            <ui:if ui:condition=\"{= spr:rowCount(?rs) = 0 }\">
                <div class=\"swa-object-row\">
                    <swa:SubjectWidgetRow arg:object=\"{= ?object }\" arg:predicate=\"{= ?predicate }\"/>
                </div>
            </ui:if>
            <ui:else>
                <ui:forEach ui:limit=\"{= ?limit }\" ui:resultSet=\"{= ?rs }\">
                    <div class=\"swa-object-row\">
                        <swa:SubjectWidgetRow arg:object=\"{= ?object }\" arg:predicate=\"{= ?predicate }\" arg:subject=\"{= ?subject }\"/>
                    </div>
                </ui:forEach>
                <ui:if ui:condition=\"{= spr:rowCount(?rs) &gt; ?limit }\">
                    <div class=\"swa-overflow\">({= spr:rowCount(?rs) - ?limit } more values not shown)</div>
                </ui:if>
            </ui:else>
        </ui:call>
    </ui:if>
    <ui:else>
        <div class=\"swa-object-row\">
            <swa:SubjectWidgetRow arg:predicate=\"{= ?predicate }\"/>
        </div>
    </ui:else>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "The body of a subjects widget." ;
  rdfs:label "Subjects body" ;
  rdfs:subClassOf swa:SubjectElements ;
.
swa:SubjectsGroup
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:filterFunction ;
      spl:valueType spin:Function ;
      rdfs:comment "An optional filter function that takes a predicate and the object as arguments and returns true for all predicates that should be displayed. Typical value is swa:isNotUsedInInversePath, if the surrounding form already contains an swa:ObjectsPlaceholder." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:label ;
      spl:valueType xsd:string ;
      rdfs:comment "The title label." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:object ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to display. May be unbound if in search mode." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:predicates ;
      spl:valueType sp:Select ;
      rdfs:comment "A result set (e.g., SPARQL SELECT query) that delivers the predicates in this group." ;
    ] ;
  ui:prototype """
<ui:group letrs:rs=\"{#
        SELECT ?predicate
        WHERE {
            ( ?predicates 0 ) spr:colCells ?predicate .
            FILTER ((!bound(?filterFunction)) || spif:invoke(?filterFunction, ?predicate, ?object)) .
            FILTER (!swa:isHiddenProperty(?predicate)) .
        } }\">
    <ui:if ui:condition=\"{= spr:rowCount(?rs) &gt; 0 }\">
        <div class=\"swa-objects-group\">
            <ui:if ui:condition=\"{= bound(?label) }\">
                <div class=\"swa-sub-title\">{= ?label }</div>
            </ui:if>
            <ui:forEach ui:resultSet=\"{= ?rs }\">
                <swa:Subjects arg:object=\"{= ?object }\" arg:predicate=\"{= ?predicate }\"/>
            </ui:forEach>
        </div>
    </ui:if>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "A group of subject widgets." ;
  rdfs:label "Subjects group" ;
  rdfs:subClassOf swa:FormElements ;
.
swa:Subscribe
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:code ;
      spl:valueType xsd:string ;
      rdfs:comment "The code to execute when the event fires. Values must be valid JavaScript snippets." ;
    ] ;
  ui:prototype """
<ui:if ui:condition=\"{= bound(?event) }\">
    <script>swa.registerSubscription(gadgets.Hub.subscribe('{= ?event }', function(event, data) { {= ?code } }),
'{= swa:currentWindowId() }', '{= ?ownerId }');</script>
</ui:if>
"""^^ui:Literal ;
  rdfs:comment """Subscribes a random JavaScript snippet to be executed whenever an event fires. Inside that JavaScript, the variable 'data' will point to the event payload.

This element should only be used inside of windows, and it will make sure that the events registrations are unsubscribed whenever the surrounding window gets reloaded or closed. In other scenarios, the ownerId should be provided, to make sure that the unregistering happens.""" ;
  rdfs:label "Subscribe" ;
  rdfs:subClassOf swa:SubscribeElements ;
.
swa:SubscribeArgument
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:filter ;
      spl:valueType xsd:string ;
      rdfs:comment "A JavaScript expression that shall must evaluate to true to execute the argument change - returning false will bypass any change." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:argumentName ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the argument to set." ;
    ] ;
  ui:prototype """
<ui:group let:reload=\"swa.loadWithResource('{= swa:currentWindowId() }', '{= ?argumentName }', data);\">
    <ui:if ui:condition=\"{= bound(?filter) }\">
        <swa:Subscribe arg:code=\"if({= ?filter }) { {= ?reload } }\" arg:event=\"{= ?event }\" arg:ownerId=\"{= ?ownerId }\"/>
    </ui:if>
    <ui:else>
        <swa:Subscribe arg:code=\"{= ?reload }\" arg:event=\"{= ?event }\" arg:ownerId=\"{= ?ownerId }\"/>
    </ui:else>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment """Subscribes to an event so that a given argument updates whenever the event is triggered. The new value of the argument is derived from the payload data of the event. The surrounding gadget will be reloaded with the new argument.

Currently only works for resource-typed arguments, if the data object is a URI.""" ;
  rdfs:label "Subscribe argument" ;
  rdfs:subClassOf swa:SubscribeElements ;
.
swa:SubscribeElements
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:event ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the event to subscribe to." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:ownerId ;
      spl:valueType xsd:string ;
      rdfs:comment "The id of an HTML DOM element that owns the life cycle of this event. If the owner element gets removed from the DOM tree, then the event will be unregistered too." ;
    ] ;
  ui:abstract true ;
  rdfs:comment "Abstract base class of control logic code that subscribes the surrounding swa:Gadget to an event on the SWA event hub." ;
  rdfs:label "Subscribe elements" ;
  rdfs:subClassOf swa:ScriptElements ;
.
swa:SuitableObjectPredicates
  a spin:SelectTemplate ;
  spin:body [
      a sp:Select ;
      sp:distinct true ;
      sp:orderBy (
          [
            a ui:label ;
            sp:arg1 [
                sp:varName "predicate" ;
              ] ;
          ]
        ) ;
      sp:resultVariables (
          [
            sp:varName "predicate" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Union ;
            sp:elements (
                (
                  (
                    [
                      a sp:Filter ;
                      sp:expression [
                          a sp:bound ;
                          sp:arg1 [
                              sp:varName "subject" ;
                            ] ;
                        ] ;
                    ]
                  )
                  [
                    sp:object [
                        sp:varName "o" ;
                      ] ;
                    sp:predicate [
                        sp:varName "predicate" ;
                      ] ;
                    sp:subject [
                        sp:varName "subject" ;
                      ] ;
                  ]
                )
                (
                  [
                    sp:object [
                        sp:varName "subjectType" ;
                      ] ;
                    sp:predicate swa:resourceTypes ;
                    sp:subject [
                        sp:varName "subject" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "predicate" ;
                      ] ;
                    sp:predicate swa:relevantClassOfProperty ;
                    sp:subject [
                        sp:varName "subjectType" ;
                      ] ;
                  ]
                  [
                    a sp:Filter ;
                    sp:expression [
                        a sp:and ;
                        sp:arg1 [
                            a swa:isNotHiddenProperty ;
                            arg:property [
                                sp:varName "predicate" ;
                              ] ;
                          ] ;
                        sp:arg2 [
                            a sp:not ;
                            sp:arg1 [
                                a spl:instanceOf ;
                                sp:arg1 [
                                    sp:varName "predicate" ;
                                  ] ;
                                sp:arg2 spin:MagicProperty ;
                              ] ;
                          ] ;
                      ] ;
                  ]
                )
              ) ;
          ]
        ) ;
    ] ;
  rdfs:comment "Finds all \"suitable\" predicates for a given subject and/or subject type, looking at domains but also the existing values." ;
  rdfs:label "Suitable object predicates for subject" ;
  rdfs:subClassOf swa:ObjectPredicateSelectionTemplates ;
.
swa:SuitableObjectPredicatesWithMagicProperties
  a spin:SelectTemplate ;
  spin:body [
      a sp:Select ;
      sp:distinct true ;
      sp:orderBy (
          [
            sp:varName "label" ;
          ]
        ) ;
      sp:resultVariables (
          [
            sp:varName "predicate" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Union ;
            sp:elements (
                (
                  (
                    [
                      a sp:Filter ;
                      sp:expression [
                          a sp:bound ;
                          sp:arg1 [
                              sp:varName "subject" ;
                            ] ;
                        ] ;
                    ]
                  )
                  [
                    sp:object [
                        sp:varName "o" ;
                      ] ;
                    sp:predicate [
                        sp:varName "predicate" ;
                      ] ;
                    sp:subject [
                        sp:varName "subject" ;
                      ] ;
                  ]
                )
                (
                  [
                    sp:object [
                        sp:varName "subjectType" ;
                      ] ;
                    sp:predicate swa:resourceTypes ;
                    sp:subject [
                        sp:varName "subject" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "predicate" ;
                      ] ;
                    sp:predicate swa:relevantClassOfProperty ;
                    sp:subject [
                        sp:varName "subjectType" ;
                      ] ;
                  ]
                  [
                    a sp:Filter ;
                    sp:expression [
                        a swa:isNotHiddenProperty ;
                        arg:property [
                            sp:varName "predicate" ;
                          ] ;
                      ] ;
                  ]
                )
              ) ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a ui:label ;
                sp:arg1 [
                    sp:varName "predicate" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "label" ;
              ] ;
          ]
        ) ;
    ] ;
  rdfs:comment "Finds all \"suitable\" predicates for a given subject and/or subject type, looking at domains but also the existing values, including magic properties." ;
  rdfs:subClassOf swa:ObjectPredicateSelectionTemplates ;
.
swa:SuitableSubjectPredicates
  a spin:SelectTemplate ;
  spin:body [
      a sp:Select ;
      sp:distinct true ;
      sp:orderBy (
          [
            a ui:label ;
            sp:arg1 [
                sp:varName "predicate" ;
              ] ;
          ]
        ) ;
      sp:resultVariables (
          [
            sp:varName "predicate" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Union ;
            sp:elements (
                (
                  (
                    [
                      a sp:Filter ;
                      sp:expression [
                          a sp:bound ;
                          sp:arg1 [
                              sp:varName "object" ;
                            ] ;
                        ] ;
                    ]
                  )
                  [
                    sp:object [
                        sp:varName "object" ;
                      ] ;
                    sp:predicate [
                        sp:varName "predicate" ;
                      ] ;
                    sp:subject [
                        sp:varName "subject" ;
                      ] ;
                  ]
                  [
                    a sp:Filter ;
                    sp:expression [
                        a sp:isIRI ;
                        sp:arg1 [
                            sp:varName "subject" ;
                          ] ;
                      ] ;
                  ]
                )
                (
                  [
                    a sp:Bind ;
                    sp:expression [
                        a swa:resourceType ;
                        arg:resource [
                            sp:varName "object" ;
                          ] ;
                      ] ;
                    sp:variable [
                        sp:varName "objectType" ;
                      ] ;
                  ]
                  [
                    a sp:TriplePath ;
                    sp:object [
                        sp:varName "type" ;
                      ] ;
                    sp:path [
                        a sp:ModPath ;
                        sp:modMax -2 ;
                        sp:modMin 0 ;
                        sp:subPath rdfs:subClassOf ;
                      ] ;
                    sp:subject [
                        sp:varName "objectType" ;
                      ] ;
                  ]
                  [
                    a sp:Filter ;
                    sp:expression [
                        a sp:and ;
                        sp:arg1 [
                            a sp:ne ;
                            sp:arg1 [
                                sp:varName "type" ;
                              ] ;
                            sp:arg2 owl:Thing ;
                          ] ;
                        sp:arg2 [
                            a sp:ne ;
                            sp:arg1 [
                                sp:varName "type" ;
                              ] ;
                            sp:arg2 rdfs:Resource ;
                          ] ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "type" ;
                      ] ;
                    sp:predicate rdfs:range ;
                    sp:subject [
                        sp:varName "predicate" ;
                      ] ;
                  ]
                )
              ) ;
          ]
        ) ;
    ] ;
  rdfs:comment "Finds all \"suitable\" predicates for a given object type, looking at ranges." ;
  rdfs:label "Suitable subject predicates" ;
  rdfs:subClassOf swa:SubjectPredicateSelectionTemplates ;
.
swa:SwitchableForm
  a swa:FormClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:allowHistoryMode ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to have a \"Show history\" check box show up in view mode. This mode is currently only supported by the teamwork framework, not general SWA." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:allowLogMessage ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to also show a check box in edit mode, where the user can enter a commit message when pressing Save Changes" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:allowProvenanceMode ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to have a \"Show provenance\" check box show up in view mode. This mode is currently only supported by the Insight product, not general SWA." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:detailsButtonHandler ;
      spl:valueType xsd:string ;
      rdfs:comment "The JS to handle the \"details\" button." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:detailsButtonToolTip ;
      spl:valueType xsd:string ;
      rdfs:comment "The tool tip of the details button, if available." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:editable ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to add an option to allow the user to switch the form to edit mode." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:editing ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to make the form editing by default." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:formId ;
      spl:valueType xsd:string ;
      rdfs:comment "The id of the form if this is in edit mode." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:hideVisualizationsButton ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to hide visualizations button" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:matchIds ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional list of matchIds that shall be tried first when selecting the actual view. This allows users to define multiple forms for the same class, while specific SwitchableForms can pick which one of them they would like to use. If specified, then there should not be any commas at the end, but are allowed between the values." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:matchIdsOnly ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to only use the value of arg:matchIds and not, e.g. \"form\"." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:pagination ;
      spl:valueType xsd:boolean ;
      rdfs:comment "If set to true will add the client side pagination widget." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:reportStorageKey ;
      spl:valueType xsd:string ;
      rdfs:comment "A local storage key to set and activate the reports feature of this form." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to display." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:resourceSelectedEvent ;
      spl:valueType xsd:string ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:showFooter ;
      spl:valueType xsd:boolean ;
      rdfs:comment "If set to true, a footer will always show up, even if ?showResourceActions and ?editable are false." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:showResourceActions ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to also display a button to run ResourceActions." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:showURI ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to display the URI of the resource on the right hand side of the header. Even if left to false (default), the URI will be the tool tip text of the header." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:suppressHeader ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to suppress any header." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:suppressInlineEditing ;
      spl:valueType xsd:boolean ;
      rdfs:comment "If set to true then this deactivates inline editing by setting the context variable \"swa-no-edit-button\"." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:viewModeName ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional name of the mode that shall be activated if the form is in view mode. This can be used to replace the default view with a specialized mode, e.g. history mode in EVN." ;
    ] ;
  ui:prototype """
<ui:setContext let:extraMatchIds=\"{= IF(bound(?matchIds), CONCAT(?matchIds, &quot;,&quot;), ?none) }\" let:fid=\"{= COALESCE(?formId, ui:uniqueId()) }\" let:graphQLService=\"{= IF(isIRI(?resource), swa:graphQLService(ui:currentQueryGraph()), ?none) }\" let:headerLabelFunction=\"{= COALESCE(ui:contextValue(&quot;headerLabelFunction&quot;), swa:DefaultHeaderLabelFunction) }\" ui:varName=\"{= IF(?suppressInlineEditing, &quot;swa-no-edit-button&quot;, ?none) }\" ui:varValue=\"{= true }\">
    <ui:if ui:condition=\"{= (!bound(?suppressHeader)) || (!?suppressHeader) }\">
        <swa:FormHeader arg:label=\"{= spif:invoke(?headerLabelFunction, ?resource) }\" arg:toolTip=\"{= ?resource }\">
            <ui:if ui:condition=\"{= ?showURI }\">
                <span class=\"swa-form-header-uri\">{= ?resource }</span>
            </ui:if>
        </swa:FormHeader>
    </ui:if>
    <ui:if let:ei=\"{= COALESCE(?editing, false) }\" ui:condition=\"{= (?editable || ?showResourceActions) || ?showFooter }\">
        <div class=\"action-bar\">
            <span class=\"{= IF(?ei, ?none, &quot;ui-helper-hidden-accessible&quot;) }\" id=\"{= ?fid }-editModeButtonBar\">
                <ui:if ui:condition=\"{= ?allowLogMessage }\">
                    <input class=\"swa-switchable-form-log-message-checkbox log-message-box\" id=\"log-message-box\" onclick=\"swa.rememberLogMessageBoxStatus()\" type=\"checkbox\"/>
                    <script>swa.restoreLogMessageBoxStatus();</script>
                    <swa:Space/>
                    <label class=\"log-message-box-label swa-base-font\" for=\"log-message-box\">Enter log message</label>
                    <swa:Space/>
                    <swa:Space/>
                </ui:if>
                <button class=\"btn btn-default btn-xs save-button\" data-formid=\"{= ?fid }\" id=\"form-save-button-{= ?fid }\" onclick=\"swa.submitForm('{= ?fid }', null)\">
                    <span aria-hidden=\"true\"/> Save Changes
   				</button>
                <swa:Space/>
                <button class=\"btn btn-default btn-xs cancel-button\" data-formid=\"{= ?fid }\" onclick=\"swa.switchToViewForm('{= ?fid }')\">
                    <span aria-hidden=\"true\"/> Cancel
   				</button>
            </span>
            <span class=\"{= IF(?ei, &quot;ui-helper-hidden-accessible&quot;, ?none) }\" id=\"{= ?fid }-viewModeButtonBar\">
                <ui:if ui:condition=\"{= ?showResourceActions }\">
                    <swa:ResourceActionsButton arg:class=\" btn btn-default btn-xs\" arg:editable=\"{= ?editable }\" arg:id=\"{= ?fid }-actionsButton\" arg:resource=\"{= ?resource }\" arg:resourceSelectedEvent=\"{= ?resourceSelectedEvent }\" arg:toolTip=\"Actions for {= ui:label(?resource) }\"/>
                </ui:if>
                <ui:if ui:condition=\"{= swa:falseOrUnbound(?hideVisualizationsButton) }\">
                    <swa:Space/>
                    <swa:VisualizationActionsButton arg:class=\" btn btn-default btn-xs\" arg:editable=\"{= ?editable }\" arg:id=\"{= ?fid }-visualizationsButton\" arg:resource=\"{= ?resource }\" arg:resourceSelectedEvent=\"{= ?resourceSelectedEvent }\" arg:toolTip=\"Visualization actions for {= ui:label(?resource) }\"/>
                    <swa:Space/>
                </ui:if>
                <ui:if ui:condition=\"{= ?editable }\">
                    <ui:if ui:condition=\"{= bound(?detailsButtonHandler) }\">
                        <button class=\"btn btn-default btn-xs swa-button swa-details-button\" onclick=\"{= ?detailsButtonHandler }\" title=\"{= COALESCE(?detailsButtonToolTip, &quot;Open in new browser tab&quot;) }\">
                            <div class=\"ui-icon ui-icon-newwin\"/>
                        </button>
                        <swa:Space/>
                    </ui:if>
                    <button class=\"btn btn-default btn-xs edit-button\" data-formid=\"{= ?fid }\" id=\"{= ?fid }-edit-button\" onclick=\"swa.switchToEditForm('{= ?fid }')\">
                        <span aria-hidden=\"true\"/>Edit</button>
                    <swa:Space/>
                    <ui:if ui:condition=\"{= ?showResourceActions }\">
                        <ui:if ui:condition=\"{= swa:canDeleteResource(?resource) }\">
                            <button class=\"btn btn-default btn-xs delete-button\" data-formid=\"{= ?fid }\" onclick=\"swa.deleteResource('{= ?resource }')\">
                                <span aria-hidden=\"true\"/>Delete</button>
                            <swa:Space/>
                        </ui:if>
                    </ui:if>
                </ui:if>
                <button class=\"btn btn-default btn-xs print-button\" data-formid=\"{= ?fid }\" onclick=\"swa.printView('{= ?fid }')\">
                    <span aria-hidden=\"true\"/>Print</button>
                <span>
                    <ui:insertionPoint ui:pointId=\"bottomBar\"/>
                </span>
                <swa:Space/>
                <swa:Space/>
                <ui:if ui:condition=\"{= bound(?graphQLService) }\">
                    <a class=\"btn btn-default btn-xs\" id=\"{= ?fid }-tbf-button\" style=\"{= IF(COALESCE(smf:configParam(&quot;enableOptionForSWAForms&quot;), false), ?none, &quot;display: none&quot;) }\" title=\"Use shape-based forms if available\">
                        <div class=\"ui-icon ui-icon-power swa-float-left\"/>
                        <div class=\"swa-float-left\" id=\"{= ?fid }-tbf-button-count\"/>
                    </a>
                    <swa:Space/>
                    <select class=\"swa-tbf-shapes-select\" id=\"{= ?fid }-tbf-shapes-select\" title=\"Available view shapes\"/>
                    <swa:Space/>
                    <swa:Space/>
                    <a class=\"btn btn-default btn-xs\" id=\"{= ?fid }-reveal-button\" title=\"Show the properties that have no values\">
                        <span>Show Properties  &nbsp; </span>
                        <div class=\"swa-float-right\" id=\"{= ?fid }-reveal-button-count\"/>
                    </a>
                    <swa:Space/>
                    <a class=\"btn btn-default btn-xs\" id=\"{= ?fid }-info-button\" title=\"Display descriptions of the properties\">
                        <div class=\"ui-icon ui-icon-info swa-float-left\"/>
                        <div class=\"swa-float-left\" id=\"{= ?fid }-info-button-count\"/>
                    </a>
                    <swa:Space/>
                    <a class=\"btn btn-default btn-xs\" id=\"{= ?fid }-tabbed-button\" title=\"Display form sections as tabs\">
                        <div class=\"ui-icon ui-icon-folder-collapsed swa-float-left\"/>
                    </a>
                    <swa:Space/>
                    <swa:InitTBF arg:resourceSelectedEvent=\"{= ?resourceSelectedEvent }\"/>
                </ui:if>
                <ui:if ui:condition=\"{= bound(?reportStorageKey) }\">
                    <a class=\"btn btn-default btn-xs\" data-key=\"{= ?reportStorageKey }\" id=\"{= ?fid }-report-button\" title=\"Show Problems and Suggestions (may slow down performance)\">
                        <div class=\"ui-icon ui-icon-alert swa-float-left\"/>
                        <div class=\"swa-float-left\" id=\"{= ?fid }-report-button-count\"/>
                    </a>
                    <script>{= ui:functionCall(\"swa.initFormReportButton\", ?fid) }</script>
                    <swa:Space/>
                </ui:if>
                <ui:if ui:condition=\"{= ?allowHistoryMode }\">
                    <span id=\"{= ?fid }-history-mode-box-panel\">
                        <label class=\"swa-history-checkbox \" for=\"history-mode-box\">
                            <input class=\"swa-switchable-form-checkbox history-mode-box\" data-formid=\"{= ?fid }\" id=\"history-mode-box\" onclick=\"swa.switchToViewForm('{= ?fid }')\" type=\"checkbox\"/>&nbsp;Show&nbsp;History</label>
                    </span>
                </ui:if>
                <ui:if ui:condition=\"{= ?allowProvenanceMode }\">
                    <div class=\"checkbox swa-provenance-checkbox  \" id=\"provenance-mode-box\">
                        <input class=\"swa-switchable-form-checkbox provenance-mode-box\" data-formid=\"{= ?fid }\" id=\"provenance-mode-box\" onclick=\"swa.switchToViewForm('{= ?fid }')\" type=\"checkbox\"/>&nbsp;Show&nbsp;Data&nbsp;Sources</div>
                </ui:if>
                <ui:if ui:condition=\"{= ?pagination }\">
                    <swa:DetailsViewPagination/>
                </ui:if>
                <ui:if ui:condition=\"{= bound(?graphQLService) }\">
                    <a class=\"btn btn-default btn-xs\" id=\"{= ?fid }-findsimilar-button\" title=\"Find similar...\">
                        <div class=\"ui-icon ui-icon-circle-plus swa-float-left\"/>
                    </a>
                </ui:if>
                <ui:if ui:condition=\"{= bound(?graphQLService) }\">
                    <script>{= ui:functionCall(\"tbf.initTBFButton\", ?fid, ?graphQLService, str(?resource)) }</script>
                    <script>{= ui:functionCall(\"findsimilar.initButton\", ?fid, ?graphQLService, str(?resource), ui:label(?resource)) }</script>
                </ui:if>
            </span>
        </div>
    </ui:if>
    <ui:loadable class=\"ui-layout-content\" ui:loadId=\"{= ?fid }-loadable\">
        <ui:if ui:condition=\"{= ?showURI &amp;&amp; isIRI(?resource) }\">
            <div class=\"swa-uri\">{= ?resource }</div>
        </ui:if>
        <ui:if ui:condition=\"{= ?editing }\">
            <script>$(\"#{= ?fid }-loadable\").addClass('swa-form-edit')</script>
            <ui:setContext ui:varName=\"mode\" ui:varValue=\"edit\">
                <form autocomplete=\"off\" class=\"swa-form switchable-mode\" data-graph=\"{= ui:currentQueryGraph() }\" id=\"{= ?fid }\" resource=\"{= swa:resourceURIOrBNodeId(?resource) }\">
                    <ui:if ui:condition=\"{= ?editable }\">
                        <input name=\"_base\" type=\"hidden\" value=\"{= ui:currentQueryGraph() }\"/>
                    </ui:if>
                    <ui:if ui:condition=\"{= !bound(?resource) }\">
                        <input name=\"resourceType\" type=\"hidden\" value=\"{= swa:resourceType() }\"/>
                    </ui:if>
                    <div class=\"swa-form-body\">
                        <ui:if ui:condition=\"{= bound(?resource) }\">
                            <ui:resourceView ui:matchIds=\"{= ?extraMatchIds }{= IF(swa:falseOrUnbound(?matchIdsOnly), &quot;edit,form&quot;, ?none) }\" ui:resource=\"{= ?resource }\"/>
                        </ui:if>
                        <ui:else>
                            <ui:classView ui:class=\"{= swa:resourceType() }\" ui:matchIds=\"{= ?extraMatchIds }{= IF(swa:falseOrUnbound(?matchIdsOnly), &quot;edit,form&quot;, ?none) }\"/>
                        </ui:else>
                    </div>
                </form>
            </ui:setContext>
        </ui:if>
        <ui:else>
            <script>$(\"#{= ?fid }-loadable\").removeClass('swa-form-edit')</script>
            <ui:setContext ui:varName=\"mode\" ui:varValue=\"{= COALESCE(?viewModeName, &quot;view&quot;) }\">
                <form class=\"swa-form view-mode swa-form-view\" data-app-name=\"{= swa:appName() }\" id=\"{= ?fid }\" resource=\"{= ?resource }\">
                    <input name=\"_base\" type=\"hidden\" value=\"{= ui:currentQueryGraph() }\"/>
                    <div class=\"swa-form-body\">
                        <ui:setContext ui:varName=\"{= IF(?editable, ?none, &quot;swa-no-edit-button&quot;) }\" ui:varValue=\"{= true }\">
                            <ui:if ui:condition=\"{= bound(?graphQLService) }\">
                                <ui:loadable ui:loadId=\"{= ?fid }-inner\" ui:loadOnDemand=\"{= true }\">
                                    <ui:if ui:condition=\"{= ?tbf }\">
                                        <script>{= ui:functionCall(\"tbf.updateShapes\", ?fid, ?graphQLService, str(?resource)) }</script>
                                    </ui:if>
                                    <ui:else>
                                        <ui:resourceView ui:matchIds=\"{= ?extraMatchIds }{= IF(swa:falseOrUnbound(?matchIdsOnly), &quot;view,form&quot;, ?none) }\" ui:resource=\"{= ?resource }\"/>
                                    </ui:else>
                                    <ui:if ui:condition=\"{= (!bound(?graphQLService)) || (!?tbf) }\">
                                        <script>{= ui:functionCall(\"swa.loadFormReport\", ?fid) }</script>
                                    </ui:if>
                                </ui:loadable>
                                <script>swa.load('{= ?fid }-inner', {tbf: $('#{= ?fid }-tbf-button').hasClass('active')})</script>
                            </ui:if>
                            <ui:else>
                                <ui:resourceView ui:matchIds=\"{= ?extraMatchIds }{= IF(swa:falseOrUnbound(?matchIdsOnly), &quot;view,form&quot;, ?none) }\" ui:resource=\"{= ?resource }\"/>
                            </ui:else>
                            <ui:if ui:condition=\"{= bound(?reportStorageKey) }\">
                                <div class=\"swa-form-report-panel\" data-focus-node=\"{= ui:encodeNode(?resource, true, true) }\" id=\"{= ?fid }-report-panel\"/>
                            </ui:if>
                            <swa:DataViewsSection arg:resource=\"{= ?resource }\"/>
                        </ui:setContext>
                    </div>
                </form>
            </ui:setContext>
        </ui:else>
    </ui:loadable>
    <div>
        <ui:insertionPoint ui:pointId=\"extraFooter\"/>
    </div>
</ui:setContext>
"""^^ui:Literal ;
  rdfs:comment "A form displaying details of a given resource. The form displays a header on top, with label and type of the resource. If arg:editable is set to true, the form will have a button to switch it to edit mode." ;
  rdfs:label "Switchable form" ;
  rdfs:subClassOf swa:Form ;
.
swa:SwitchableFormFooterPlugin
  a rdfs:Class ;
  rdfs:comment "A component that can appear in the lower right corner of a switchable form." ;
  rdfs:label "Switchable form footer plugin" ;
  rdfs:subClassOf ui:NodeClass ;
.
swa:SwitchableFormFooterPlugins
  a swa:SwitchableFormFooterPlugin ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource being displayed." ;
    ] ;
  rdfs:label "Switchable form footer plugins" ;
  rdfs:subClassOf swa:FormElements ;
.
swa:SwitchableFormGadget
  a swa:Gadget ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:allowHistoryMode ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to have a \"Show history\" check box show up in view mode. This mode is currently only supported by the teamwork framework, not general SWA." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:allowLogMessage ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to provide an option to enter a log message when saving changes." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:allowProvenanceMode ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to have a \"Show provenance\" check box show up in view mode. This mode is currently only supported by the Insight product, not general SWA." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:createLinkFunctionOverride ;
      spl:valueType spin:Function ;
      rdfs:comment "An override for the create link function." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:detailsButtonHandler ;
      spl:valueType xsd:string ;
      rdfs:comment "The JS to handle the \"details\" button." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:detailsButtonToolTip ;
      spl:valueType xsd:string ;
      rdfs:comment "The tool tip of the details button, if available." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:editing ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to start in editing mode." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:footerPlugin ;
      spl:valueType swa:SwitchableFormFooterPlugin ;
      rdfs:comment "An optional component to show up in the lower right corner." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:hideVisualizationsButton ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to hide visualizations button" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:matchIds ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional list of matchIds that shall be tried first when selecting the actual view. This allows users to define multiple forms for the same class, while specific gadgets can pick which one of them they would like to use. If specified, then there should not be any commas at the end, but are allowed between the values." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:pagination ;
      spl:valueType xsd:boolean ;
      rdfs:comment "If set to true will add the client side pagination widget." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:readOnly ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to disallow switching to edit mode." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:refreshFilterFunction ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional JavaScript function that is injected into the filter code that ignores reloading on a refresh event." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:reportStorageKey ;
      spl:valueType xsd:string ;
      rdfs:comment "A local storage key to set and activate the reports feature of this form." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to display." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:showResourceActions ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to also display a button to run ResourceActions." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:showType ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to show the type of the resource behind its label." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:showURI ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to include the URI of the resource in the header." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:suppressInlineEditing ;
      spl:valueType xsd:boolean ;
      rdfs:comment "If set to true then this deactivates inline editing by setting the context variable \"swa-no-edit-button\"." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resourceSelectedEvent ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the event to subscribe to so that the window can be reloaded if the resource changes. The event will also be re-published whenever the user follows a hyperlink on the form. The data payload of the event needs to be the URI of a resource." ;
    ] ;
  ui:prototype """
<ui:setContext ui:varName=\"createLinkFunction\" ui:varValue=\"{= COALESCE(?createLinkFunctionOverride, swa:createEventOrNewTabLink) }\">
    <ui:setContext let:formId=\"{= ui:uniqueId() }\" ui:varName=\"createEventLinkEvent\" ui:varValue=\"{= ?resourceSelectedEvent }\">
        <ui:if ui:condition=\"{= bound(?resource) }\">
            <swa:WindowTitleSetter arg:title=\"{= IF(isIRI(?resource), ui:label(?resource), &quot;Selected Resource&quot;) }{= IF(?showType, swa:typeLabelList(?resource), ?none) }\"/>
            <swa:SwitchableForm arg:allowHistoryMode=\"{= ?allowHistoryMode }\" arg:allowLogMessage=\"{= ?allowLogMessage }\" arg:allowProvenanceMode=\"{= ?allowProvenanceMode }\" arg:detailsButtonHandler=\"{= ?detailsButtonHandler }\" arg:detailsButtonToolTip=\"{= ?detailsButtonToolTip }\" arg:editable=\"{= (!bound(?readOnly)) || (!?readOnly) }\" arg:editing=\"{= ?editing }\" arg:formId=\"{= ?formId }\" arg:hideVisualizationsButton=\"{= ?hideVisualizationsButton }\" arg:matchIds=\"{= ?matchIds }\" arg:pagination=\"{= COALESCE(?pagination, false) }\" arg:reportStorageKey=\"{= ?reportStorageKey }\" arg:resource=\"{= ?resource }\" arg:resourceSelectedEvent=\"{= ?resourceSelectedEvent }\" arg:showFooter=\"{= true }\" arg:showResourceActions=\"{= ?showResourceActions }\" arg:showURI=\"{= ?showURI }\" arg:suppressHeader=\"{= true }\" arg:suppressInlineEditing=\"{= ?suppressInlineEditing }\">
                <ui:insert ui:into=\"bottomBar\">
                    <ui:if ui:condition=\"{= bound(?footerPlugin) }\">
                        <swa:Space/>
                        <ui:dynamicView arg:resource=\"{= ?resource }\" ui:class=\"{= ?footerPlugin }\"/>
                    </ui:if>
                </ui:insert>
            </swa:SwitchableForm>
        </ui:if>
        <swa:Subscribe arg:code=\"swa.handleChangeForSwitchableFormGadget(data, '{= ?formId }', '{= swa:currentWindowId() }')\" arg:event=\"org.topbraid.swa.change\"/>
        <swa:SubscribeArgument arg:argumentName=\"resource\" arg:event=\"{= ?resourceSelectedEvent }\" arg:filter=\"swa.getFormResourceURI('{= ?formId }') != data {= IF(bound(?refreshFilterFunction), CONCAT(&quot; &amp;&amp; &quot;, ?refreshFilterFunction, &quot;(data)&quot;), ?none) }\"/>
    </ui:setContext>
</ui:setContext>
"""^^ui:Literal ;
  rdfs:comment "A gadget consisting of a view form that can be switched to edit mode by the user." ;
  rdfs:label "Switchable form gadget" ;
  rdfs:subClassOf swa:Gadgets ;
.
swa:TBFEditors
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:editWidget ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The edit widget to use." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:inverse ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to insert a subjects body." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:focusNode ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The focus node (usually subject)." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate being edited." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:single ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True if at most one value is permitted." ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:setContext ui:varName=\"editWidget\" ui:varValue=\"{= ?editWidget }\">
    <ui:setContext ui:varName=\"mode\" ui:varValue=\"edit\">
        <ui:if ui:condition=\"{= ?inverse }\">
            <swa:SubjectsBody arg:object=\"{= ?focusNode }\" ui:args=\"*\"/>
        </ui:if>
        <ui:else>
            <swa:ObjectsBody arg:subject=\"{= ?focusNode }\" ui:args=\"*\"/>
        </ui:else>
    </ui:setContext>
</ui:setContext>
"""^^ui:Literal ;
  ui:responseType ui:HTML ;
  rdfs:comment "Callback used by the GraphQL-based TBF forms when the user clicks on the Edit button of an individual field." ;
  rdfs:label "TBF editors" ;
  rdfs:subClassOf swa:FormElements ;
.
swa:TBFEditorsJSON
  a ui:Service ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:appName ;
      spl:valueType xsd:string ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:fields ;
      spl:valueType xsd:string ;
      rdfs:comment "A JSON encoded array of field metadata as delivered by the client." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:focusNode ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource (subject) being edited." ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:setContext ui:varName=\"swaAppName\" ui:varValue=\"{= ?appName }\">
    <swon:Object>
        <ui:json ui:str=\"{= ?fields }\" ui:varName=\"fields\">
            <ui:forEach ui:resultSet='{#
                    SELECT *
                    WHERE {
                        ?fields ui:jsonArrayMembers ?object .
                        BIND (IRI(ui:jsonString(ui:jsonValue(?object, \"predicate\"))) AS ?predicate) .
                        BIND (xsd:boolean(ui:jsonString(ui:jsonValue(?object, \"inverse\"))) AS ?inverse) .
                        BIND (ui:jsonString(ui:jsonValue(?object, \"path\")) AS ?path) .
                        BIND (xsd:boolean(ui:jsonString(ui:jsonValue(?object, \"single\"))) AS ?single) .
                        BIND (IRI(ui:jsonString(ui:jsonValue(?object, \"editWidget\"))) AS ?editWidget) .
                    } }'>
                <ui:bind>
                    <ui:stringify ui:varName=\"html\">
                        <ui:setContext ui:varName=\"editWidget\" ui:varValue=\"{= ?editWidget }\">
                            <ui:setContext ui:varName=\"mode\" ui:varValue=\"edit\">
                                <ui:if ui:condition=\"{= ?inverse }\">
                                    <swa:SubjectsBody arg:object=\"{= ?focusNode }\" ui:args=\"*\"/>
                                </ui:if>
                                <ui:else>
                                    <swa:ObjectsBody arg:subject=\"{= ?focusNode }\" ui:args=\"*\"/>
                                </ui:else>
                            </ui:setContext>
                        </ui:setContext>
                    </ui:stringify>
                    <swon:Value arg:name=\"{= ?path }\" arg:value=\"{= ?html }\"/>
                </ui:bind>
            </ui:forEach>
        </ui:json>
    </swon:Object>
</ui:setContext>
"""^^ui:Literal ;
  rdfs:comment "Callback to fetch edit widgets when a whole form is switched to edit mode." ;
  rdfs:label "TBF editors JSON" ;
  rdfs:subClassOf ui:JSONServices ;
.
swa:TBFViewerForGroupGadget
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:inverse ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to insert a subjects body." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:focusNode ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The focus node (usually subject)." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:group ;
      spl:valueType sh:PropertyGroup ;
      rdfs:comment "The property group that defines the viewGadget" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate being edited." ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:dynamicView arg:focusNode=\"{= ?focusNode }\" arg:path=\"{= ?predicate }\" ui:class=\"{= spl:object(?group, tosh:viewGadget) }\"/>
"""^^ui:Literal ;
  ui:responseType ui:HTML ;
  rdfs:comment "Callback used by the GraphQL-based TBF forms when the property group defines a tosh:viewGadget that is not handled client-side." ;
  rdfs:label "TBF viewers for group gadget" ;
  rdfs:subClassOf swa:FormElements ;
.
swa:TBFViewers
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:inverse ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to insert a subjects body." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:focusNode ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The focus node (usually subject)." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate being edited." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:viewWidget ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The view widget to use." ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:setContext ui:varName=\"viewWidget\" ui:varValue=\"{= ?viewWidget }\">
    <ui:setContext ui:varName=\"mode\" ui:varValue=\"view\">
        <ui:if ui:condition=\"{= ?inverse }\">
            <swa:SubjectsBody arg:object=\"{= ?focusNode }\" ui:args=\"*\"/>
        </ui:if>
        <ui:else>
            <swa:ObjectsBody arg:subject=\"{= ?focusNode }\" ui:args=\"*\"/>
        </ui:else>
    </ui:setContext>
</ui:setContext>
"""^^ui:Literal ;
  ui:responseType ui:HTML ;
  rdfs:comment "Callback used by the GraphQL-based TBF forms when the property defines a tosh:viewWidget that is not handled client-side." ;
  rdfs:label "TBF viewers" ;
  rdfs:subClassOf swa:FormElements ;
.
swa:Tab
  a rdfs:Class ;
  rdfs:comment "An SWP element that can be embedded into tabs. The display name of this is derived from the rdfs:label." ;
  rdfs:label "Tab" ;
  rdfs:subClassOf ui:NodeClass ;
.
swa:TabsActivationScript
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:defaultValue "tabs" ;
      spl:optional true ;
      spl:predicate arg:id ;
      spl:valueType xsd:string ;
      rdfs:comment "The id of the tabs div. Defaults to \"tabs\"." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:tabName ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the tab to make the default, e.g. \"#tabs-MetadataProjectTab\"." ;
    ] ;
  ui:prototype """
<script>{= ui:functionCall(\"swa.initTabs\", ?tabName, ?id) }</script>
"""^^ui:Literal ;
  rdfs:comment """A JavaScript snippet that turns a given div into a jQuery UI Tabs folder. Typical markup:

    <div id=\"tabs\" class=\"swa-tabs\">
        <ul>
          <li><a href=\"#tab1\">Tab 1</a></li>
          <li><a href=\"#tab2\">Tab 2</a></li>
        </ul>
        <div id=\"tab1\">A normal tab</div>
        <ui:loadable id=\"tab2\" ui:loadOnDemand=\"true\">A lazy-loaded tab</div>
    </div>
    <swa:TabsActivationScript arg:id=\"tabs\" arg:tabName=\"#tab2\"/>
""" ;
  rdfs:label "Tabs activation script" ;
  rdfs:subClassOf swa:LayoutElements ;
.
swa:TemplateCallDialog
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:resourceSelectedEvent ;
      spl:valueType xsd:string ;
      rdfs:comment "The event to publish if a row has been selected." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:selectedResource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "An optional pre-selected resource that will be attempted to be filled in as one of the arguments." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:title ;
      spl:valueType xsd:string ;
      rdfs:comment "The title of the dialog." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:treeDataProvider ;
      spl:valueType swa:TreeDataProvider ;
      rdfs:comment "The TreeDataProvider used to select the available templates. If left unspecified then the tree selection is not made available." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:loadId ;
      spl:valueType xsd:string ;
      rdfs:comment "A unique loadId string." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:templates ;
      spl:valueType spin:Template ;
      rdfs:comment "A SPIN template delivering all selectable templates with variables ?template and ?templateGraph." ;
    ] ;
  ui:prototype """
<ui:group let:oldQueryGraph=\"{= ui:currentQueryGraph() }\" let:resourceLabel=\"{= IF(bound(?selectedResource), ui:label(?selectedResource), ?none) }\" let:valueType=\"{= IF(bound(?selectedResource), spl:object(?selectedResource, rdf:type), ?none) }\">
    <div class=\"swa-padding-zero\" id=\"div-{= ?loadId }\" title=\"{= COALESCE(?title, &quot;Execute Template Query&quot;) }\">
        <div class=\"swa-search-form-type-switch swa-template-call-dialog-form-type\">
            <swa:LabeledElement arg:class=\"swa-labeled-element-width-onehundred\" arg:label=\"Template:\" let:selectId=\"{= ui:uniqueId() }\">
                <select class=\"form-control swa-template-call-dialog-form-type-control\" id=\"{= ?selectId }\" onchange=\"sel=$(this).val();if(sel){swa.load('{= ?loadId }-form-loadable', {templateInfo: '&quot;' + sel + '&quot;'});}\">
                    <option/>
                    <ui:call ui:template=\"{= ?templates }\">
                        <ui:forEach ui:resultSet=\"{= ?rs }\">
                            <ui:setContext ui:queryGraph=\"{= ?templateGraph }\">
                                <option id=\"option-{= ?template }\" value=\"{= ?template } {= ?templateGraph }\">{= ui:label(?template) }</option>
                            </ui:setContext>
                        </ui:forEach>
                    </ui:call>
                </select>
                <ui:if ui:condition=\"{= bound(?treeDataProvider) }\">
                    <swa:Space/>
                    <swa:Space/>
                    <button class=\"btn btn-default btn-xs\" onclick=\"swa.openTemplateSelectionDialog('{= ?treeDataProvider }', '{= ?selectId }')\" title=\"Select Template Query...\" type=\"button\">...</button>
                </ui:if>
            </swa:LabeledElement>
        </div>
        <ui:loadable ui:loadId=\"{= ?loadId }-form-loadable\">
            <ui:if let:space=\"{= spif:indexOf(?templateInfo, &quot; &quot;) }\" ui:condition=\"{= bound(?templateInfo) }\">
                <ui:group let:template=\"{= IRI(SUBSTR(?templateInfo, 0, (?space + 1))) }\" let:templateGraph=\"{= IRI(SUBSTR(?templateInfo, (?space + 2))) }\">
                    <ui:setContext ui:queryGraph=\"{= ?templateGraph }\">
                        <ui:setContext ui:queryGraph=\"{= ui:graph }\" ui:varName=\"dataGraph\" ui:varValue=\"{= ?oldQueryGraph }\">
                            <swa:CreateForm arg:formId=\"{= ?loadId }-form\" arg:resourceType=\"{= ?template }\" arg:resourceURI=\"urn:x-swa:Dummy\"/>
                            <ui:if ui:condition=\"{= bound(?selectedResource) }\">
                                <ui:group let:predicate=\"{= swa:matchingArgumentPredicate(?template, ?valueType, ?oldQueryGraph) }\">
                                    <ui:if ui:condition=\"{= bound(?predicate) }\">
                                        <script>swa.selectResourceOnForm('{= ?loadId }-form', '{= ?predicate }', '{= ?selectedResource }', \"{= ui:escapeJSON(?resourceLabel) }\")</script>
                                    </ui:if>
                                </ui:group>
                            </ui:if>
                        </ui:setContext>
                        <button class=\"btn btn-default\" onclick=\"swa.executeTemplateCall('{= ?loadId }', '{= ?templateGraph }')\">Execute</button>
                    </ui:setContext>
                </ui:group>
            </ui:if>
        </ui:loadable>
        <ui:loadable class=\"swa-form-body\" ui:loadId=\"{= ?loadId }-results\">
            <ui:if ui:condition=\"{= bound(?template) }\">
                <ui:setContext ui:queryGraph=\"{= IF((ui:graph != ?templateGraph), ui:unionOfGraphs(?oldQueryGraph, ?templateGraph), ?unchanged) }\">
                    <ui:call ui:args=\"template\" ui:template=\"{= ?template }\">
                        <swa:ResultSetGrid arg:exports=\"{= true }\" arg:hiddenColName=\"uri\" arg:resourceSelectedEvent=\"{= ?resourceSelectedEvent }\" arg:resultSet=\"{#
                                SELECT (str(?result) AS ?uri) (ui:label(?result) AS ?label)
                                WHERE {
                                    ?rs spr:rowIndices ?rowIndex .
                                    BIND (spr:cell(?rs, ?rowIndex, 0) AS ?result) .
                                } }\"/>
                    </ui:call>
                </ui:setContext>
            </ui:if>
        </ui:loadable>
    </div>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment """A dialog consisting of three parts:
- a combo box to select the template on top
- a form to enter arguments for the selected template
- a result set grid at the bottom.
When the user click the execute button, the template will executed with those arguments, and the results displayed in the grid. This is a non-modal dialog and users can use it to navigate another application through a callback mechanism.

Optionally, the dialog's arguments can be pre-filled with a given value. For example an application such as EVN may have a currently selected resource. If the selected resource has the same type as one of the arguments, then the form will have that pre-selected.""" ;
  rdfs:label "Template call dialog" ;
  rdfs:subClassOf swa:DialogElements ;
.
swa:TemplateHomeGraph
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "graph" ;
          ]
        ) ;
      sp:where (
          (
            [
              sp:object [
                  sp:varName "?0" ;
                ] ;
              sp:predicate tops:files ;
              sp:subject [
                  sp:varName "file" ;
                ] ;
            ]
            [
              sp:object "/" ;
              sp:predicate rdf:first ;
              sp:subject [
                  sp:varName "?0" ;
                ] ;
            ]
            [
              sp:object [
                  sp:varName "?1" ;
                ] ;
              sp:predicate rdf:rest ;
              sp:subject [
                  sp:varName "?0" ;
                ] ;
            ]
            [
              sp:object true ;
              sp:predicate rdf:first ;
              sp:subject [
                  sp:varName "?1" ;
                ] ;
            ]
            [
              sp:object () ;
              sp:predicate rdf:rest ;
              sp:subject [
                  sp:varName "?1" ;
                ] ;
            ]
            [
              a sp:Filter ;
              sp:expression [
                  a sp:gt ;
                  sp:arg1 [
                      a spif:indexOf ;
                      sp:arg1 [
                          sp:varName "file" ;
                        ] ;
                      sp:arg2 ".spin." ;
                    ] ;
                  sp:arg2 0 ;
                ] ;
            ]
            [
              a sp:Bind ;
              sp:expression [
                  a smf:baseURI ;
                  sp:arg1 [
                      sp:varName "file" ;
                    ] ;
                ] ;
              sp:variable [
                  sp:varName "graph" ;
                ] ;
            ]
          )
          [
            a sp:NamedGraph ;
            sp:elements (
                [
                  a sp:Filter ;
                  sp:expression [
                      a sp:exists ;
                      sp:elements (
                          [
                            sp:object [
                                sp:varName "anyBody" ;
                              ] ;
                            sp:predicate spin:body ;
                            sp:subject [
                                sp:varName "template" ;
                              ] ;
                          ]
                        ) ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode [
                sp:varName "graph" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:template ;
      spl:valueType spin:Template ;
      rdfs:comment "The template to get the graph of." ;
    ] ;
  spin:private true ;
  spin:returnType rdfs:Resource ;
  rdfs:comment "Given a globally registered SPIN template, this function finds the graph (.spin. file) that it has been declared in." ;
  rdfs:label "Template home graph" ;
  rdfs:subClassOf swa:Functions ;
.
swa:TemplateSelectionDialog
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:loadId ;
      spl:valueType xsd:string ;
      rdfs:comment "The load id of the dialog." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:selectId ;
      spl:valueType xsd:string ;
      rdfs:comment "The id of the select element to update when OK is clicked." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:treeDataProvider ;
      spl:valueType swa:TreeDataProvider ;
    ] ;
  ui:prototype """
<div id=\"div-{= ?loadId }\" title=\"Select Template Query\">
    <script>var selectedTemplate = null;</script>
    <div class=\"swa-template-selection-dialog-template-query\">
        <swa:Tree arg:dataProvider=\"{= ?treeDataProvider }\" arg:id=\"templateTree\" arg:onSelect=\"selectedTemplate=null;swa.loadWithResource('templateDetails', 'template', resource)\"/>
    </div>
    <ui:loadable class=\"swa-template-selection-dialog-details-loadable\" ui:loadId=\"templateDetails\">
        <ui:if ui:condition=\"{= bound(?template) }\">
            <ui:group let:graph=\"{= swa:TemplateHomeGraph(?template) }\">
                <ui:if ui:condition=\"{= bound(?graph) }\">
                    <ui:setContext ui:queryGraph=\"{= ?graph }\">
                        <div>{= spl:object(?template, rdfs:comment) }</div>
                    </ui:setContext>
                    <script>selectedTemplate='{= ?template }';</script>
                </ui:if>
            </ui:group>
        </ui:if>
    </ui:loadable>
    <div class=\"swa-dialog-button-bar\">
        <button class=\"btn btn-default btn-xs\" onclick=\" swa.closeDialog('{= ?loadId }');if(selectedTemplate) { swa.updateSelectedTemplate(selectedTemplate, '{= ?selectId }') }\">OK</button>
        <swa:Space/>
        <button class=\"btn btn-default btn-xs\" onclick=\"swa.closeDialog('{= ?loadId }')\">Cancel</button>
    </div>
</div>
"""^^ui:Literal ;
  rdfs:label "Template selection dialog" ;
  rdfs:subClassOf swa:DialogElements ;
.
swa:TextAreaEditor
  a swa:ObjectEditorClass ;
  swa:objectWidgetWeight [
      a swa:WeightedExpression ;
      swa:expression [
          a sp:and ;
          sp:arg1 [
              a sp:and ;
              sp:arg1 [
                  a sp:bound ;
                  sp:arg1 [
                      sp:varName "object" ;
                    ] ;
                ] ;
              sp:arg2 [
                  a sp:isLiteral ;
                  sp:arg1 [
                      sp:varName "object" ;
                    ] ;
                ] ;
            ] ;
          sp:arg2 [
              a sp:gt ;
              sp:arg1 [
                  a spif:indexOf ;
                  sp:arg1 [
                      sp:varName "object" ;
                    ] ;
                  sp:arg2 """
""" ;
                ] ;
              sp:arg2 0 ;
            ] ;
        ] ;
      swa:weight 2 ;
    ] ;
  ui:private true ;
  ui:prototype """
<div class=\"nowrap\" let:datatype=\"{= COALESCE(?range, xsd:string) }\">
    <swa:ObjectEditorHiddenDatatypeField arg:datatype=\"{= ?datatype }\" arg:uid=\"{= ?uid }\"/>
    <table class=\"swa-abstract-text-field-editor-container\">
        <tr>
            <td class=\"swa-width-100\">
                <textarea class=\"form-control swa-text-area {= swa:testClass(?predicate) }\" name=\"new-{= ?uid }\" rows=\"4\">{= ?object }</textarea>
                <ui:group let:shacl=\"{= swa:isFromSHACLDatatypeConstraint(?datatype, ?predicate, ?subject) }\">
                    <ui:if ui:condition=\"{= (?datatype = rdf:langString) || (!?shacl) }\">
                        <td class=\"swa-layout-td\">
                            <swa:LangSelector arg:initialValue=\"{= lang(?object) }\" arg:required=\"{= ?shacl &amp;&amp; (?datatype = rdf:langString) }\" arg:uid=\"{= ?uid }\"/>
                        </td>
                    </ui:if>
                </ui:group>
            </td>
        </tr>
    </table>
</div>
"""^^ui:Literal ;
  rdfs:comment "A multi-line text area to enter string literals. This is the default editor for string literals that contain a line break." ;
  rdfs:label "Text area editor" ;
  rdfs:subClassOf swa:ObjectEditor ;
.
swa:TextAreaInlineEditor
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:class ;
      spl:valueType xsd:string ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:placeholder ;
      spl:valueType xsd:string ;
      rdfs:comment "A placeholder value to show when no value is available." ;
    ] ;
  ui:prototype """
<ui:group let:id=\"{= ui:uniqueId() }\">
    <swa:InlineEditorContainer ui:args=\"*\">
        <textarea class=\"swa-inline-editor-text-area {= ?class }\" id=\"{= ?id }-editor\"/>
        <script>$(\"#{= ?id }-editor\").keydown(function(event) { swa.inlineEditorTextAreaKeyDown('{= ?id }', event) });</script>
    </swa:InlineEditorContainer>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "An inline editor consisting of a text area for a string value." ;
  rdfs:label "Text area inline editor" ;
  rdfs:subClassOf swa:AbstractInlineEditor ;
.
swa:TextFieldEditor
  a swa:ObjectEditorClass ;
  swa:objectWidgetWeight [
      a swa:WeightedExpression ;
      swa:expression [
          a sp:isLiteral ;
          sp:arg1 [
              sp:varName "object" ;
            ] ;
        ] ;
      swa:weight 1 ;
    ] ;
  swa:objectWidgetWeight [
      a swa:WeightedExpression ;
      swa:expression [
          a sp:or ;
          sp:arg1 [
              a sp:eq ;
              sp:arg1 [
                  sp:varName "range" ;
                ] ;
              sp:arg2 rdfs:Literal ;
            ] ;
          sp:arg2 [
              a sp:and ;
              sp:arg1 [
                  a sp:bound ;
                  sp:arg1 [
                      sp:varName "range" ;
                    ] ;
                ] ;
              sp:arg2 [
                  a spl:instanceOf ;
                  sp:arg1 [
                      sp:varName "range" ;
                    ] ;
                  sp:arg2 rdfs:Datatype ;
                ] ;
            ] ;
        ] ;
    ] ;
  ui:private true ;
  ui:prototype """
<swa:AbstractTextFieldEditor arg:datatype=\"{= ?range }\" arg:inputType=\"text\" ui:args=\"*\"/>
"""^^ui:Literal ;
  rdfs:comment "A single-line text editor for literals. This is the default widget for all literals, with a weight of 0." ;
  rdfs:label "Text field editor" ;
  rdfs:subClassOf swa:AbstractTextFieldEditor ;
.
swa:TextFieldEditorWithLang
  a swa:ObjectEditorClass ;
  ui:private true ;
  ui:prototype """
<swa:AbstractTextFieldEditor arg:datatype=\"{= xsd:string }\" arg:inputType=\"text\" ui:args=\"*\"/>
"""^^ui:Literal ;
  rdfs:comment "A single-line text editor for string literals. This will always present a language selection drop down." ;
  rdfs:label "Text field editor with lang" ;
  rdfs:subClassOf swa:AbstractTextFieldEditor ;
.
swa:TextFieldInlineEditor
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:class ;
      spl:valueType xsd:string ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:placeholder ;
      spl:valueType xsd:string ;
      rdfs:comment "Placeholder shown if no value is provided." ;
    ] ;
  ui:prototype """
<ui:group let:id=\"{= ui:uniqueId() }\">
    <swa:InlineEditorContainer ui:args=\"*\">
        <input class=\"{= ?class }\" id=\"{= ?id }-editor\" type=\"text\"/>
        <script>$(\"#{= ?id }-editor\").keydown(function(event) { swa.inlineEditorTextFieldKeyDown('{= ?id }', event) });</script>
    </swa:InlineEditorContainer>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "An inline editor consisting of a text field for a string value." ;
  rdfs:label "Text field inline editor" ;
  rdfs:subClassOf swa:AbstractInlineEditor ;
.
swa:TimeEditor
  a swa:ObjectEditorClass ;
  swa:objectWidgetWeight [
      a swa:WeightedExpression ;
      swa:expression [
          a sp:eq ;
          sp:arg1 [
              a sp:datatype ;
              sp:arg1 [
                  sp:varName "object" ;
                ] ;
            ] ;
          sp:arg2 xsd:time ;
        ] ;
      swa:weight 5 ;
    ] ;
  swa:objectWidgetWeight [
      a swa:WeightedExpression ;
      swa:expression [
          a sp:eq ;
          sp:arg1 [
              sp:varName "range" ;
            ] ;
          sp:arg2 xsd:time ;
        ] ;
      swa:weight 3 ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:group>
    <swa:ObjectEditorHiddenDatatypeField arg:datatype=\"{= xsd:time }\" arg:uid=\"{= ?uid }\"/>
    <input class=\"form-control\" id=\"timeEditor{= ?uid }\" size=\"10\" type=\"text\" value=\"{= ?object }\"/>
    <input id=\"new-{= ?uid }\" name=\"new-{= ?uid }\" type=\"hidden\" value=\"{= ?object }\"/>
    <swa:WidgetInitializer arg:script=\"swa.initTimePicker('{= ?uid }')\"/>
</ui:group>
"""^^ui:Literal ;
  rdfs:label "Time editor" ;
  rdfs:subClassOf swa:ObjectEditor ;
.
swa:TimeRangeFacet
  a swa:ObjectFacetClass ;
  swa:facetSearchType search:RangeFacetValue ;
  swa:objectFacetMenuName "min/max range" ;
  swa:objectWidgetWeight [
      a swa:WeightedExpression ;
      swa:expression [
          a sp:and ;
          sp:arg1 [
              a sp:bound ;
              sp:arg1 [
                  sp:varName "range" ;
                ] ;
            ] ;
          sp:arg2 [
              a sp:eq ;
              sp:arg1 [
                  sp:varName "range" ;
                ] ;
              sp:arg2 xsd:time ;
            ] ;
        ] ;
      swa:weight 5 ;
    ] ;
  ui:prototype """
<span class=\"nowrap\" let:restore=\"{= swa:restoreFacetValue(?predicate) }\">
    <ui:group let:max=\"{= IF(bound(?restore), spl:object(?restore, search:max), ?none) }\" let:min=\"{= IF(bound(?restore), spl:object(?restore, search:min), ?none) }\">
        <input class=\"form-control\" id=\"timeEditor{= ?uid }Min\" size=\"10\" type=\"text\" value=\"{= ?min }\"/>
        <span> - </span>
        <input class=\"form-control\" id=\"timeEditor{= ?uid }Max\" size=\"10\" type=\"text\" value=\"{= ?max }\"/>
        <input id=\"min{= ?uid }\" name=\"min{= ?uid }\" type=\"hidden\" value=\"{= ?min }\"/>
        <input id=\"max{= ?uid }\" name=\"max{= ?uid }\" type=\"hidden\" value=\"{= ?max }\"/>
        <input id=\"datatype{= ?uid }\" name=\"datatype{= ?uid }\" type=\"hidden\" value=\"{= xsd:time }\"/>
        <script>swa.initTimePicker('{= ?uid }Min', 'min{= ?uid }');
		swa.initTimePicker('{= ?uid }Max', 'max{= ?uid }');</script>
    </ui:group>
</span>
"""^^ui:Literal ;
  rdfs:label "Time range facet" ;
  rdfs:subClassOf swa:ObjectFacet ;
.
swa:TimeZonePicker
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:id ;
      spl:valueType xsd:string ;
      rdfs:comment "The id of the select to create." ;
    ] ;
  ui:prototype """
<select class=\"form-control\" id=\"{= ?id }\" title=\"Time zone\">
    <option disabled=\"disabled\" selected=\"selected\">Timezone</option>
    <ui:forEach ui:resultSet='{#
            SELECT ?hour
            WHERE {
                ?num tops:for ( -11 12 ) .
                BIND (IF((abs(?num) &lt; 10), CONCAT(\"0\", str(abs(?num))), str(abs(?num))) AS ?digits) .
                BIND (CONCAT(IF((?num &lt; 0), \"-\", \"+\"), ?digits) AS ?hour) .
            } }'>
        <option value=\"{= ?hour }:00\">{= ?hour }:00</option>
    </ui:forEach>
</select>
"""^^ui:Literal ;
  rdfs:comment "A simple <select> drop down with time zones in steps of hours, ranging from -11:00 to +12:00. Defaults to empty." ;
  rdfs:label "Time zone picker" ;
  rdfs:subClassOf swa:FormElements ;
.
swa:Tip
  a ui:NodeClass ;
  ui:prototype """
<div class=\"admon\">
    <img align=\"left\" alt=\"Tip Icon\" hspace=\"30px\" src=\"{= ui:lib() }/assets/images/icon-tip.jpg\" vspace=\"0px\" width=\"60px\"/>
    <p>
        <ui:insertionPoint ui:pointId=\"body\"/>
    </p>
</div>
"""^^ui:Literal ;
  rdfs:label "Tip" ;
  rdfs:subClassOf swa:DocumentElements ;
.
swa:TitledForm
  a ui:NodeClass ;
  ui:prototype """
<div class=\"swa-titled-form\">
    <div class=\"swa-title\">{= ui:label(?resource) }</div>
    <ui:resourceView ui:matchIds=\"form\" ui:resource=\"{= ?resource }\"/>
</div>
"""^^ui:Literal ;
  rdfs:comment "A wrapper that displays a title (the resource's name) and then the most suitable resource view with match id \"form\". Also includes sections derived from Shapes." ;
  rdfs:label "Titled form" ;
  rdfs:subClassOf swa:FormElements ;
  rdfs:subClassOf ui:ResourceViews ;
.
swa:Tree
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:defaultValue false ;
      spl:optional true ;
      spl:predicate arg:draggable ;
      spl:valueType xsd:boolean ;
      rdfs:comment "If true then the tree acts as drag source, i.e. users can drag resources from the tree to other elements that act as drag targets." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:defaultValue "tree" ;
      spl:optional true ;
      spl:predicate arg:id ;
      spl:valueType xsd:string ;
      rdfs:comment "The id of the HTML element to generate for the tree." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:cache ;
      spl:valueType xsd:boolean ;
      rdfs:comment "Set to true if the tree shall cache its requests. This should only be done for read-only static data." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:checkDropFunction ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of a JavaScript function that shall be called to verify that drag and drop is possible. This takes the same object as jsTree._get_move (http://old.jstree.com/documentation/core.html#_get_move) as its argument." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:filterFunction ;
      spl:valueType spin:Function ;
      rdfs:comment "An optional filter function that is passed into the tree provider so that it can hide certain nodes (such as system classes) from the tree. The function must take a resource as its only argument and return true if the resource shall appear in the tree." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:onDoubleClick ;
      spl:valueType xsd:string ;
      rdfs:comment "A JS expression that shall be evaluated if the user has double-clicked on a tree node. The variable 'resource' will contain the URI of the resource that has been clicked on." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:onLoaded ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional JavaScript snippet that is to be executed after the tree has loaded its roots." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:onSelect ;
      spl:valueType xsd:string ;
      rdfs:comment "JavaScript code that shall be called if a node has been selected in the tree. In this code, the variable 'resource' points to the URI of the selected resource. The variable 'node' holds the selected low-level tree node." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:options ;
      spl:valueType xsd:string ;
      rdfs:comment "JSON expression with custom jsTree options, for example: \"{core: {force_text: true}}\"" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:root ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "A root node that can overload the default root of the data provider. For example, swa:ClassTreeDataProvider starts at rdfs:Resource by default - set arg:root to owl:Thing to start there instead." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:treeMoveHandler ;
      spl:valueType swa:TreeMoveHandlerClass ;
      rdfs:comment "If draggable has been set, then this must point to a subclass of swa:TreeMoveHandlers that implements the server side changes that need to happen." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:dataProvider ;
      spl:valueType swa:TreeDataProvider ;
      rdfs:comment "The TreeDataProvider that is used in the callbacks to fetch the root and child nodes." ;
    ] ;
  ui:prototype """
<ui:createLink arg:filterFunction=\"{= ?filterFunction }\" arg:root=\"{= ?root }\" ui:cache=\"{= ?cache }\" ui:format=\"json\" ui:sendQueryGraph=\"{= true }\" ui:snippet=\"true\" ui:view=\"{= ?dataProvider }\">
    <div id=\"{= ?id }\" treedataprovider=\"{= ?dataProvider }\" treeroot=\"{= ?root }\"/>
    <script>function {= ?id }TreeInitHandler() {
		swa.initTree(\"{= ?id }\", \"{= ?link }&amp;{= ui:encodeContext() }\",<ui:if ui:condition=\"{= bound(?onLoaded) }\">\"{= ?onLoaded }\"</ui:if>
        <ui:else>false</ui:else>, <ui:if ui:condition=\"{= bound(?onSelect) }\">\"{= ?onSelect }\"</ui:if>
        <ui:else>false</ui:else>, <ui:if ui:condition=\"{= bound(?onDoubleClick) }\">\"{= ?onDoubleClick }\"</ui:if>
        <ui:else>false</ui:else>, {= COALESCE(?draggable, false) }, {= COALESCE(?checkDropFunction, false) },<ui:if ui:condition=\"{= bound(?treeMoveHandler) }\">\"{= ?treeMoveHandler }\"</ui:if>
        <ui:else>false</ui:else>, <ui:if ui:condition=\"{= bound(?options) }\">{= ?options }</ui:if>
        <ui:else>null</ui:else>);
  };
  $(document).ready(function() {
{= ?id }TreeInitHandler();
	});</script>
</ui:createLink>
"""^^ui:Literal ;
  rdfs:comment "Inserts a jsTree component into the current page. The jsTree object will get the provided id." ;
  rdfs:label "Tree" ;
  rdfs:subClassOf swa:TreeElements ;
.
swa:TreeAutoCompletePanel
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:treeId ;
      spl:valueType xsd:string ;
      rdfs:comment "The id of the tree (specified using arg:id in the associated swa:Tree)." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:type ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class of nodes in the tree." ;
    ] ;
  ui:prototype """
<div class=\"swa-form-footer\">
    <swa:AutoComplete arg:class=\"swa-tree-autocomplete\" arg:id=\"{= ui:uniqueId() }\" arg:onSelect=\"swa.selectTreeNode(&quot;{= ?treeId }&quot;, resource, &quot;{= ui:currentQueryGraph() }&quot;)\" arg:type=\"{= ?type }\"/>
</div>
"""^^ui:Literal ;
  rdfs:comment "A component that can be placed under an swa:Tree to provide an auto-complete field for the nodes in the tree." ;
  rdfs:label "Tree auto complete panel" ;
  rdfs:subClassOf swa:TreeElements ;
.
swa:TreeChildrenTemplates
  a spin:SelectTemplate ;
  spin:abstract true ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:filterFunction ;
      spl:valueType spin:Function ;
      rdfs:comment "An optional filter function that returns true for those resources that shall be visible. The query should evaluate this function if it exists." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:parent ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The parent node to get the children of." ;
    ] ;
  rdfs:comment "Superclass of SPIN templates used by the Tree component to get the children of a given parent resource. The body of the query needs to assume that ?parent is pre-bound to the parent resource. Should deliver the following variables: ?node (the child resource of ?parent), ?label (the display label of ?node), ?leaf (false if this node has children), ?icon (an optional icon CSS style), and ?movable (true if this node can be dragged under a different parent). Since the tree is being lazy-loaded the ?leaf attribute influences only whether an expansion (+) button will be displayed. Only when the user clicks on that expansion button, the next round of children will be loaded. The SELECT query may return an optional variable ?metadata to store an extra attribute \"metadata\" at the jsTree node level. This metadata can for example be used to determine drag and drop behavior." ;
  rdfs:label "Tree children templates" ;
  rdfs:subClassOf swa:TreeTemplates ;
.
swa:TreeDataProvider
  a ui:JSONService ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:changeHandler ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of a JavaScript function that shall be executed if the tree is part of an editable application in which SWA change objects are passed around via the event hub. The function takes two parameters: the change data and the tree id. See swa:ClassTreeDataProvider for an example." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:treeRootsTemplate ;
      spl:valueType spin:Template ;
      rdfs:comment "A subclass of swa:TreeRootsTemplates that delivers the roots of the tree. Will be bypassed if the tree itself defined an arg:rootResource." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:treeChildrenTemplate ;
      spl:valueType spin:Template ;
      rdfs:comment "The subclass of swa:TreeChildrenTemplates that delivers the children of a given parent node." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:treePathTemplate ;
      spl:valueType spin:Template ;
      rdfs:comment "This SPIN template is called with the variable ?node pre-bound to a node in the tree and ?root possibly pointing to a root resource. The template must return a single result variable containing a path from a root to that node. See spif:shortestObjectsPath for a default implementation. The path must be a space-separated string concatenation of URIs." ;
    ] ;
  ui:prototype """
<ui:group let:id=\"{= ui:param(&quot;id&quot;) }\">
    <ui:if ui:condition=\"{= (?id = &quot;1&quot;) || (!bound(?id)) }\">
        <ui:call arg:root=\"{= ui:param(&quot;root&quot;, rdfs:Resource) }\" ui:template=\"{= ?treeRootsTemplate }\">
            <swa:TreeDataProviderHelper arg:parentId=\"{= ?id }\" ui:resultSet=\"{= ?rs }\"/>
        </ui:call>
    </ui:if>
    <ui:else>
        <ui:call arg:filterFunction=\"{= ui:param(&quot;filterFunction&quot;, rdfs:Resource) }\" arg:parent=\"{= ui:decodeNode(swa:removeUniqueId(?id)) }\" ui:template=\"{= ?treeChildrenTemplate }\">
            <swa:TreeDataProviderHelper arg:parentId=\"{= ?id }\" ui:resultSet=\"{= ?rs }\"/>
        </ui:call>
    </ui:else>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment """Instances of this class are used as server callbacks to drive an swa:Tree.

A TreeDataProvider is backed by a couple of SELECT queries - one to get the roots, and one to get the children of a given node. Optionally, a root resource can be supplied to overload the default root(s).

Another operation that trees should support is finding an expansion path from a root to a given node - this is needed to support navigating to a tree node from auto-complete fields and similar components. To support this, each TreeDataProvider should point to a SPIN template that delivers a path. This typically uses the spif:shortestObjectsPath function.

If the content of the tree is editable, then the TreeDataProvider should implement a JavaScript function to react on SWA change objects. See the tree gadgets bundled with SWA for examples on how to do that.""" ;
  rdfs:label "Tree data provider" ;
  rdfs:subClassOf swa:TreeElements ;
  rdfs:subClassOf ui:JSONServices ;
.
swa:TreeDataProviderHelper
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:parentId ;
      spl:valueType xsd:string ;
      rdfs:comment "The id of the parent node." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate ui:resultSet ;
      spl:valueType sp:Select ;
      rdfs:comment "The query to execute." ;
    ] ;
  ui:private true ;
  ui:prototype """
<swon:Array>
    <ui:forEach ui:indexVar=\"index\" ui:resultSet=\"{= ?resultSet }\">
        <ui:if ui:condition=\"{= ?index &gt; 0 }\">,</ui:if>
        <swon:Object let:e=\"{= ui:encodeNode(?node, true, true) }\">
            <swon:Value arg:name=\"text\" arg:value=\"{= COALESCE(?label, ui:label(?node)) }\"/>
            <swon:Value arg:name=\"id\" arg:value=\"{= ?e }::{= ?parentId }\"/>
            <swon:Value arg:name=\"li_attr\">
                <swon:Object>
                    <swon:Value arg:name=\"data-resource\" arg:value=\"{= IF(fn:starts-with(?e, &quot;&lt;@&quot;), fn:substring(?e, 2, (fn:string-length(?e) - 2)), IRI(?node)) }\"/>
                    <ui:if ui:condition=\"{= bound(?metadata) }\">
                        <swon:Value arg:name=\"data-metadata\" arg:value=\"{= ?metadata }\"/>
                    </ui:if>
                </swon:Object>
            </swon:Value>
            <ui:if ui:condition=\"{= bound(?icon) }\">
                <swon:Value arg:name=\"icon\" arg:value=\"{= ?icon }\"/>
            </ui:if>
            <swon:Value arg:name=\"data\">
                <swon:Object>
                    <swon:Value arg:name=\"resource\" arg:value=\"{= IF(fn:starts-with(?e, &quot;&lt;@&quot;), fn:substring(?e, 2, (fn:string-length(?e) - 2)), IRI(?node)) }\"/>
                    <swon:Value arg:name=\"draggable\" arg:value=\"{= COALESCE(?movable, true) }\"/>
                    <ui:if ui:condition=\"{= bound(?metadata) }\">
                        <swon:Value arg:name=\"metadata\" arg:value=\"{= ?metadata }\"/>
                    </ui:if>
                </swon:Object>
            </swon:Value>
            <swon:Value arg:name=\"state\">
                <swon:Object>
                    <swon:Value arg:name=\"selected\" arg:value=\"{= false }\"/>
                    <swon:Value arg:name=\"opened\" arg:value=\"{= false }\"/>
                    <swon:Value arg:name=\"disabled\" arg:value=\"{= false }\"/>
                </swon:Object>
            </swon:Value>
            <swon:Value arg:name=\"children\" arg:value=\"{= !?leaf }\"/>
        </swon:Object>
    </ui:forEach>
</swon:Array>
"""^^ui:Literal ;
  rdfs:comment "A helper element of TreeDataProvider. Produces JSON from a SELECT query." ;
  rdfs:label "Tree data provider helper" ;
  rdfs:subClassOf swa:TreeElements ;
.
swa:TreeDataProviderHelperWithCounts
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:parentId ;
      spl:valueType xsd:string ;
      rdfs:comment "The id of the parent node." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate ui:resultSet ;
      spl:valueType sp:Select ;
      rdfs:comment "The query to execute." ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:group>
	[
<ui:forEach ui:indexVar=\"index\" ui:resultSet=\"{= ?resultSet }\">
        <ui:if ui:condition=\"{= ?index &lt; 500 }\">
            <ui:if ui:condition=\"{= ?index &gt; 0 }\">,</ui:if>{
			\"data\" : {<ui:if ui:condition=\"{= ?count &gt; 0 }\">\"title\" : \"{= ui:escapeJSON(COALESCE(?countLabel, ui:label(?countLabel))) }\"</ui:if>
            <ui:else>\"title\" : \"{= ui:escapeJSON(COALESCE(?label, ui:label(?label))) }\"</ui:else>
            <ui:if ui:condition=\"{= bound(?icon) }\">,
					\"icon\" : \"{= ?icon }\"</ui:if>},
			\"attr\" : {
				\"id\": \"&lt;{= ?node }&gt;::{= ?parentId }\",
				\"resource\" : \"{= IRI(?node) }\",
				\"movable\" : {= COALESCE(?movable, \"true\") }
			},<ui:if ui:condition=\"{= ?leaf }\">
				\"children\" : []
			</ui:if>
            <ui:else>
				\"state\" : \"closed\"
			</ui:else>
		}</ui:if>
    </ui:forEach>
	]
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "A helper element of TreeDataProvider. Produces JSON from a SELECT query." ;
  rdfs:label "Tree data provider helper with counts" ;
  rdfs:subClassOf swa:TreeElements ;
.
swa:TreeDataProviderWithCounts
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:changeHandler ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of a JavaScript function that shall be executed if the tree is part of an editable application in which SWA change objects are passed around via the event hub. The function takes two parameters: the change data and the tree id. See swa:ClassTreeDataProvider for an example." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:treeRootsTemplate ;
      spl:valueType spin:Template ;
      rdfs:comment "A subclass of swa:TreeRootsTemplates that delivers the roots of the tree. Will be bypassed if the tree itself defined an arg:rootResource." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:treeChildrenTemplate ;
      spl:valueType spin:Template ;
      rdfs:comment "The subclass of swa:TreeChildrenTemplates that delivers the children of a given parent node." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:treePathTemplate ;
      spl:valueType spin:Template ;
      rdfs:comment "This SPIN template is called with the variable ?node pre-bound to a node in the tree and ?root possibly pointing to a root resource. The template must return a single result variable containing a path from a root to that node. See spif:shortestObjectsPath for a default implementation. The path must be a space-separated string concatenation of URIs." ;
    ] ;
  ui:prototype """
<ui:group let:id=\"{= ui:param(&quot;id&quot;) }\">
    <ui:if ui:condition=\"{= (?id = &quot;1&quot;) || (!bound(?id)) }\">
        <ui:call arg:root=\"{= ui:param(&quot;root&quot;, rdfs:Resource) }\" ui:template=\"{= ?treeRootsTemplate }\">
            <swa:TreeDataProviderHelperWithCounts arg:parentId=\"{= ?id }\" ui:resultSet=\"{= ?rs }\"/>
        </ui:call>
    </ui:if>
    <ui:else>
        <ui:call arg:filterFunction=\"{= ui:param(&quot;filterFunction&quot;, rdfs:Resource) }\" arg:parent=\"{= ui:decodeNode(swa:removeUniqueId(?id)) }\" ui:template=\"{= ?treeChildrenTemplate }\">
            <swa:TreeDataProviderHelperWithCounts arg:parentId=\"{= ?id }\" ui:resultSet=\"{= ?rs }\"/>
        </ui:call>
    </ui:else>
</ui:group>
"""^^ui:Literal ;
  ui:responseType ui:JSON ;
  rdfs:comment """Instances of this class are used as server callbacks to drive an swa:Tree.

A TreeDataProvider is backed by two SELECT queries - one to get the roots, and one to get the children of a given node. Optionally, a root resource can be supplied to overload the default root(s).

Another operation that trees must should is finding an expansion path from a root to a given node - this is needed to support navigating to a tree node from auto-complete fields and similar components. To support this, each TreeDataProvider should point to a SPIN template that delivers a path. This typically uses the spif:shortestObjectsPath function.

If the content of the tree is editable, then the TreeDataProvider should implement a JavaScript function to react on SWA change objects.""" ;
  rdfs:label "Tree data provider with counts" ;
  rdfs:subClassOf swa:TreeElements ;
.
swa:TreeElements
  a ui:NodeClass ;
  ui:abstract true ;
  ui:private true ;
  rdfs:comment "Abstract superclass grouping together the tree-related SWA elements." ;
  rdfs:label "Tree elements" ;
  rdfs:subClassOf swa:Elements ;
.
swa:TreeGadgets
  a swa:Gadget ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:treeId ;
      spl:valueType xsd:string ;
      rdfs:comment "The (optional) id of the tree, in case someone needs to access it programmatically." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resourceSelectedEvent ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the event to fire if the selected resource has changed." ;
    ] ;
  ui:abstract true ;
  rdfs:comment "Abstract base class of Gadgets displaying a Tree." ;
  rdfs:label "Tree gadgets" ;
  rdfs:subClassOf swa:Gadgets ;
.
swa:TreeMoveHandlerClass
  a rdfs:Class ;
  rdfs:label "Tree move handler class" ;
  rdfs:subClassOf swa:EditHandlerClass ;
.
swa:TreeMoveHandlers
  a swa:TreeMoveHandlerClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:childIndex ;
      spl:valueType xsd:integer ;
      rdfs:comment "The new index of the child. If unbound, then it shall be added to the end of the list of children." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:child ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The new child resource." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:parent ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The new parent resource." ;
    ] ;
  ui:abstract true ;
  rdfs:comment "Abstract superclass of handlers that react on a drag and drop operation in the tree." ;
  rdfs:label "Tree move handlers" ;
  rdfs:subClassOf swa:EditHandlers ;
.
swa:TreePathTemplates
  a spin:SelectTemplate ;
  spin:abstract true ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:root ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "An optional root resource to stop traversal at." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:node ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The node to start traversal at." ;
    ] ;
  rdfs:comment "An abstract superclass for SPIN templates used by TreeDataProviders to find a path from a node to a root." ;
  rdfs:label "Tree path templates" ;
  rdfs:subClassOf spin:SelectTemplates ;
.
swa:TreeRootsTemplates
  a spin:SelectTemplate ;
  spin:abstract true ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:root ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The node to return as single root - this is bound by the tree if the tree has a dedicated arg:root. Otherwise the node is created by the WHERE clause." ;
    ] ;
  rdfs:comment "Abstract superclass for queries that can deliver the roots of a tree. See TreeChildrenTemplates for a description of result variables, and ClassTreeRoots for an example implementation." ;
  rdfs:label "Tree roots templates" ;
  rdfs:subClassOf swa:TreeTemplates ;
.
swa:TreeShortestPathCallback
  a ui:JSONService ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:root ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The root resource to stop at." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:dataProvider ;
      spl:valueType swa:TreeDataProvider ;
      rdfs:comment "The TreeDataProvider that contains the pathExpression needed to walk to the root." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:node ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The node resource to start traversal at." ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:group let:template=\"{#
        SELECT ?template
        WHERE {
            GRAPH ui:graph {
                ?dataProvider arg:treePathTemplate ?template .
            } .
        } }\">
    <ui:call arg:node=\"{= ?node }\" arg:root=\"{= ?root }\" ui:template=\"{= ?template }\">
        <ui:if ui:condition=\"{= spr:rowCount(?rs) &gt; 0 }\">
            <ui:group let:path=\"{= spr:cell(?rs, 0, 0) }\">
                <ui:if ui:condition=\"{= isLiteral(?path) }\">
                    <swon:RSArray arg:resultSet='{#
                            SELECT ?value
                            WHERE {
                                ?value spif:split ( ?path \" \" ) .
                            } }'/>
                </ui:if>
                <ui:else>{}</ui:else>
            </ui:group>
        </ui:if>
        <ui:else>{}</ui:else>
    </ui:call>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "An element building a JSON array with URIs based on spif:shortestObjectsPath. Called using swp?_viewClass=swa:TreeShortestPathCallback&_format=json&subject=...&dataProvider=..." ;
  rdfs:label "Tree shortest path callback" ;
  rdfs:subClassOf swa:TreeElements ;
  rdfs:subClassOf ui:JSONServices ;
.
swa:TreeTableExporter
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:root ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "An optional root resource, passed into the dataProvider." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:dataProvider ;
      spl:valueType swa:TreeDataProvider ;
      rdfs:comment "The swa:TreeDataProvider, used to determine root and child nodes." ;
    ] ;
  ui:prototype """
<ui:call arg:root=\"{= ?root }\" ui:template=\"{= spl:objectInGraph(?dataProvider, arg:treeRootsTemplate, ui:graph) }\">
    <ui:forEach ui:resultSet=\"{= ?rs }\">
        <ui:task ui:taskName=\"Generating tree table at root {= ?label }\">
            <swa:TreeTableExporterNode arg:dataProvider=\"{= ?dataProvider }\" arg:depth=\"{= 0 }\" arg:resource=\"{= ?node }\"/>
        </ui:task>
    </ui:forEach>
</ui:call>
"""^^ui:Literal ;
  ui:responseType ui:TEXT ;
  rdfs:comment "Generates a tab-separated table structure based on the hierarchy defined by a swa:TreeProvider." ;
  rdfs:label "Tree table exporter" ;
  rdfs:subClassOf swa:TreeElements ;
.
swa:TreeTableExporterNode
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:dataProvider ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The swa:TreeDataProvider" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:depth ;
      spl:valueType xsd:integer ;
      rdfs:comment "The nesting depth." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The current node's resource." ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:subTask let:tab=\"{= fn:concat(&quot;\\t&quot;) }\" ui:subTaskName=\"Node {= ui:label(?resource) } at depth {= ?depth }\">
    <ui:call arg:parent=\"{= ?resource }\" ui:template=\"{= spl:objectInGraph(?dataProvider, arg:treeChildrenTemplate, ui:graph) }\">
        <ui:forEach ui:resultSet=\"{#
                SELECT ?x
                WHERE {
                    ?x tops:for ( 1 ?depth ) .
                } }\">{= ?tab }</ui:forEach>{= ui:label(?resource) }<ui:if ui:condition=\"{#
                ASK 
                WHERE {
                    FILTER (!spr:isEmpty(?rs)) .
                    GRAPH ui:tempGraph {
                        ?resource swa:done true .
                    } .
                } }\">{= fn:concat(\"\\t\") }(Repeated, see above){= fn:concat(\"\\n\") }</ui:if>
        <ui:else>{= fn:concat(\"\\n\") }<ui:update ui:updateQuery=\"{!
                    INSERT {
                        GRAPH ui:tempGraph {
                            ?resource swa:done true .
                        } .
                    }
                    WHERE {
                    } }\"/>
            <ui:forEach ui:resultSet=\"{= ?rs }\">
                <swa:TreeTableExporterNode arg:dataProvider=\"{= ?dataProvider }\" arg:depth=\"{= ?depth + 1 }\" arg:resource=\"{= ?node }\"/>
            </ui:forEach>
        </ui:else>
    </ui:call>
</ui:subTask>
"""^^ui:Literal ;
  rdfs:label "Tree table exporter node" ;
  rdfs:subClassOf swa:TreeElements ;
.
swa:TreeTemplates
  a spin:SelectTemplate ;
  spin:abstract true ;
  rdfs:comment """Base class for SELECT templates that are used to populate trees. There are two kinds of queries:
a) to find all root nodes
b) to find the children of a given parent node.

All SELECT queries in subclass of this must return the following result variables:
SELECT ?node ?label ?leaf ?icon
- ?node: the resource behind the node, e.g. an owl:Class or skos:Concept
- ?label (optional): the label for the resource - if not used, the system will call ui:label(?node)
- ?leaf: true means no children, i.e. the node cannot be expanded
- ?icon (optional): CSS class for the icon""" ;
  rdfs:label "Tree templates" ;
  rdfs:subClassOf spin:SelectTemplates ;
.
swa:URIField
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The type of the (new) resource. This is only used if resourceURI is blank, to generate a suitable URI." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:resourceURI ;
      spl:valueType xsd:string ;
      rdfs:comment "The URI of the resource, as initial value for the input field. Can be left blank in which case the value will be derived from the resourceType." ;
    ] ;
  ui:prototype """
<swa:LabeledElement arg:label=\"Identifier:\">
    <input class=\"form-control swa-uri-field swa-create-resource-with-primary-key-dialog-plugin-identifier\" id=\"uri-input\" type=\"text\" value=\"{= COALESCE(?resourceURI, swa:newResource(?resourceType)) }\"/>
</swa:LabeledElement>
"""^^ui:Literal ;
  rdfs:comment "An input field used on CreateForms to enter the URI of the new resource." ;
  rdfs:label "URI field" ;
  rdfs:subClassOf swa:FormElements ;
.
swa:URIFieldForAssetCollection
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:ignoreURIconfigParameters ;
      spl:valueType xsd:boolean ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The type of the (new) resource. This is only used if resourceURI is blank, to generate a suitable URI." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:resourceURI ;
      spl:valueType xsd:string ;
      rdfs:comment "The URI of the resource, as initial value for the input field. Can be left blank in which case the value will be derived from the resourceType." ;
    ] ;
  ui:prototype """
<ui:group let:projectGraph=\"{= ui:currentQueryGraph() }\">
    <swa:LabeledElement arg:label=\"Identifier:\" let:userCanModifyURI=\"{= IF(swa:falseOrUnbound(?ignoreURIconfigParameters), (!swa:getUserCannotModifyURI()), true) }\">
        <ui:if ui:condition=\"{= ?userCanModifyURI }\">
            <input class=\"form-control swa-uri-field swa-create-resource-with-primary-key-dialog-plugin-identifier\" id=\"uri-input\" type=\"text\" value=\"{= COALESCE(?resourceURI, swa:newResourceForAssetCollection(?resourceType)) }\"/>
        </ui:if>
        <ui:else>
            <input class=\"form-control swa-uri-field swa-create-resource-with-primary-key-dialog-plugin-identifier\" id=\"uri-input\" readonly=\"{= true }\" type=\"text\" value=\"{= COALESCE(?resourceURI, swa:newResourceForAssetCollection(?resourceType)) }\"/>
        </ui:else>
        <swa:Space/>
        <swa:Space/>
        <a data-icon=\"fa-question-circle\" onclick=\"swa.populateModalDialogAskingForBody('edg:IdentifierConstructionRulesHelp', 'Identifier Construction Rules', null, '{= ?projectGraph }')\">
            <i class=\"fa fa-info-circle\" style=\"color: #15428B; cursor: pointer\"/>
        </a>
    </swa:LabeledElement>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "An input field used on CreateForms to enter the URI of the new resource." ;
  rdfs:label "URI field" ;
  rdfs:subClassOf swa:FormElements ;
.
swa:URIResourceEditor
  a swa:ObjectEditorClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:suppressMenu ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to not have a context menu." ;
    ] ;
  swa:objectWidgetWeight [
      a swa:WeightedExpression ;
      swa:expression [
          a sp:and ;
          sp:arg1 [
              a sp:and ;
              sp:arg1 [
                  a sp:and ;
                  sp:arg1 [
                      a sp:bound ;
                      sp:arg1 [
                          sp:varName "range" ;
                        ] ;
                    ] ;
                  sp:arg2 [
                      a sp:not ;
                      sp:arg1 [
                          a spl:instanceOf ;
                          sp:arg1 [
                              sp:varName "range" ;
                            ] ;
                          sp:arg2 rdfs:Datatype ;
                        ] ;
                    ] ;
                ] ;
              sp:arg2 [
                  a sp:ne ;
                  sp:arg1 [
                      sp:varName "range" ;
                    ] ;
                  sp:arg2 rdfs:Literal ;
                ] ;
            ] ;
          sp:arg2 [
              a sp:or ;
              sp:arg1 [
                  a sp:not ;
                  sp:arg1 [
                      a sp:bound ;
                      sp:arg1 [
                          sp:varName "object" ;
                        ] ;
                    ] ;
                ] ;
              sp:arg2 [
                  a sp:isIRI ;
                  sp:arg1 [
                      sp:varName "object" ;
                    ] ;
                ] ;
            ] ;
        ] ;
    ] ;
  swa:objectWidgetWeight [
      a swa:WeightedExpression ;
      swa:expression [
          a sp:isIRI ;
          sp:arg1 [
              sp:varName "object" ;
            ] ;
        ] ;
      swa:weight 2 ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:setContext let:range=\"{= COALESCE(?range, swa:localRange(?predicate, ?subject)) }\" ui:queryGraph=\"{= swa:dataGraph() }\">
    <swa:AutoComplete arg:allowURIs=\"{= true }\" arg:class=\"swa-auto-complete-text {= swa:testClass(?predicate) }\" arg:filterFunction=\"{= swa:isValidObjectForPredicateAtSubject }\" arg:filterFunctionArgument=\"{= ui:encodeNode(?predicate, true, true) }\" arg:filterFunctionArgument2=\"{= ui:encodeNode(?subject, true, true) }\" arg:id=\"new-{= ?uid }\" arg:initialValue=\"{= ?object }\" arg:menuFilterNode=\"{= ?predicate }\" arg:onSelect=\"{= ui:functionCall(&quot;swa.publishEditWidgetChangeEvent&quot;, ?uid, ?subject, ?predicate) }\" arg:placeholder=\"{= IF(bound(?range), CONCAT(&quot;Select &quot;, ui:label(?range)), ?none) }\" arg:type=\"{= ?range }\" arg:withSelectMenu=\"{= swa:falseOrUnbound(?suppressMenu) }\"/>
</ui:setContext>
"""^^ui:Literal ;
  rdfs:comment """The default Editor for resources, consisting of a combo-box with auto-complete.

The auto-complete can apply a model-driven filter to the resources. If the subject has SHACL property constraints for the given predicate, then it will filter out all nodes where one of the shapes specified via sh:not is not fulfilled. Among others, this makes it possible to filter out system namespaces (via tosh:SystemNamespaceShape) or any number of complex conditions.""" ;
  rdfs:label "URI resource editor" ;
  rdfs:subClassOf swa:ObjectEditor ;
.
swa:URIResourceFacet
  a swa:ObjectFacetClass ;
  swa:facetSearchType search:ObjectFacetValue ;
  swa:objectFacetMenuName "equals" ;
  swa:objectWidgetWeight [
      a swa:WeightedExpression ;
      swa:expression [
          a sp:and ;
          sp:arg1 [
              a sp:bound ;
              sp:arg1 [
                  sp:varName "range" ;
                ] ;
            ] ;
          sp:arg2 [
              a sp:not ;
              sp:arg1 [
                  a swa:isDatatypeRange ;
                  arg:range [
                      sp:varName "range" ;
                    ] ;
                ] ;
            ] ;
        ] ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:group let:restore=\"{= swa:restoreFacetValue(?predicate) }\" let:type=\"{= swa:localRangeAtClass(swa:resourceType(), ?predicate) }\">
    <swa:AutoComplete arg:class=\"{= swa:testClass(?predicate) }\" arg:id=\"value{= ?uid }\" arg:initialValue=\"{= IF(bound(?restore), spl:object(?restore, search:object), ?none) }\" arg:onSelect=\"{= ui:functionCall(&quot;swa.publishSearchFacetChangeEvent&quot;, ?uid, swa:resourceType(), ?predicate) }\" arg:placeholder=\"{= IF(isIRI(?type), CONCAT(&quot;Select &quot;, ui:label(?type)), ?none) }\" arg:type=\"{= IF((bound(?type) &amp;&amp; isBlank(?type)), rdfs:Resource, ?type) }\"/>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "A facet for URI resources, displaying an AutoComplete." ;
  rdfs:label "URI resource facet" ;
  rdfs:subClassOf swa:ObjectFacet ;
.
swa:URIResourceSubjectViewer
  a swa:SubjectViewerClass ;
  swa:subjectWidgetWeight [
      a swa:WeightedExpression ;
      swa:expression [
          a sp:isIRI ;
          sp:arg1 [
              sp:varName "subject" ;
            ] ;
        ] ;
    ] ;
  ui:private true ;
  ui:prototype """
<div class=\"swa-shifted-label\">
    <swa:Link arg:resource=\"{= ?subject }\"/>
</div>
"""^^ui:Literal ;
  rdfs:comment "A viewer for URI resources, displaying a hyperlink to that resource." ;
  rdfs:label "URI resource subject viewer" ;
  rdfs:subClassOf swa:SubjectViewer ;
.
swa:URIResourceTextFieldEditor
  a swa:ObjectEditorClass ;
  ui:prototype """
<ui:group let:id=\"{= ui:uniqueId() }\">
    <input class=\"swa-text-field form-control {= swa:testClass(?predicate) }\" id=\"{= ?id }\" onkeyup=\"$('#new-{= ?uid }').val('&lt;' + $('#{= ?id }').val() + '&gt;')\" type=\"text\" value=\"{= ?object }\"/>
    <input id=\"new-{= ?uid }\" name=\"new-{= ?uid }\" type=\"hidden\" value=\"{= ui:encodeNode(?object, true, true) }\"/>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment """A text field for entering arbitrary URIs, with the result being a <...> encoded resource, not a literal.

This is not used as default editor for any resources, but can be used explicitly via arg:editWidget or by adding your own weight expressions.""" ;
  rdfs:label "URI resource text field editor" ;
  rdfs:subClassOf swa:ObjectEditor ;
.
swa:URIResourceViewer
  a swa:ObjectViewerClass ;
  swa:objectWidgetWeight [
      a swa:WeightedExpression ;
      swa:expression [
          a sp:eq ;
          sp:arg1 [
              sp:varName "kind" ;
            ] ;
          sp:arg2 "uri" ;
        ] ;
      swa:weight 10 ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:group let:loadId=\"{= ui:uniqueId() }\">
    <div class=\"swa-shifted-label\" data-uri=\"{= ?object }\" id=\"resource-tool-tip-data-{= ?loadId }\" let:op=\"{= ui:contextValue(&quot;swaOnOpenResource&quot;) }\">
        <swa:Link arg:id=\"resource-tool-tip-{= ?loadId }\" arg:resource=\"{= ?object }\"/>
        <ui:if ui:condition=\"{= bound(?op) }\">
            <a class=\"swa-uri-resource-viewer-menu swa-icon ui-icon ui-icon-arrow-1-e\" href=\"javascript:void(0)\" onclick=\"var resource='{= ui:encodeNode(?object, true, true) }';{= ?op };\" title=\"Open in a new Window\"/>
        </ui:if>
        <script>gadgets.Hub.publish('org.topbraid.swa.resourceTooltip', 'resource-tool-tip-{= ?loadId }');</script>
    </div>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment """The default viewer for URI resources, displaying a hyperlink to that resource.

It is possible to also show a small arrow button behind the resource, to implement a special operation that shall be executed when the user clicks on the arrow. It will appear when the context variable 'swaOnOpenResource' is set. The value of that variable must be a JavaScript snippet that uses the variable 'resource' to query the current resource. In a typical scenario (as implemented in the SWA default application), this opens a new desktop window for that resource, but in principle any other operation would be possible too.""" ;
  rdfs:label "URI resource viewer" ;
  rdfs:subClassOf swa:ObjectViewer ;
.
swa:UnselectAllColumnsAction
  a swa:SearchResultsAction ;
  arg:condition true ;
  arg:onSelect "swa.setAllKeyPropertiesUnchecked(formId)" ;
  rdfs:label "Unselect all columns" ;
.
swa:UsedObjectPredicates
  a spin:SelectTemplate ;
  spin:body [
      a sp:Select ;
      sp:distinct true ;
      sp:orderBy (
          [
            a ui:label ;
            sp:arg1 [
                sp:varName "predicate" ;
              ] ;
          ]
        ) ;
      sp:resultVariables (
          [
            sp:varName "predicate" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Union ;
            sp:elements (
                (
                  [
                    sp:object [
                        sp:varName "o" ;
                      ] ;
                    sp:predicate [
                        sp:varName "predicate" ;
                      ] ;
                    sp:subject [
                        sp:varName "subject" ;
                      ] ;
                  ]
                )
                (
                  [
                    sp:object spin:MagicProperty ;
                    sp:predicate rdf:type ;
                    sp:subject [
                        sp:varName "predicate" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "domain" ;
                      ] ;
                    sp:predicate rdfs:domain ;
                    sp:subject [
                        sp:varName "predicate" ;
                      ] ;
                  ]
                  [
                    a sp:TriplePath ;
                    sp:object [
                        sp:varName "domain" ;
                      ] ;
                    sp:path [
                        a sp:ModPath ;
                        sp:modMax -2 ;
                        sp:modMin 0 ;
                        sp:subPath rdfs:subClassOf ;
                      ] ;
                    sp:subject [
                        sp:varName "type" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "type" ;
                      ] ;
                    sp:predicate rdf:type ;
                    sp:subject [
                        sp:varName "subject" ;
                      ] ;
                  ]
                )
                (
                  [
                    sp:object sh:this ;
                    sp:predicate sh:subject ;
                    sp:subject [
                        sp:varName "rule" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "predicate" ;
                      ] ;
                    sp:predicate sh:predicate ;
                    sp:subject [
                        sp:varName "rule" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "rule" ;
                      ] ;
                    sp:predicate sh:rule ;
                    sp:subject [
                        sp:varName "shape" ;
                      ] ;
                  ]
                  [
                    a sp:Filter ;
                    sp:expression [
                        a sp:notExists ;
                        sp:elements (
                            [
                              sp:object true ;
                              sp:predicate sh:deactivated ;
                              sp:subject [
                                  sp:varName "rule" ;
                                ] ;
                            ]
                          ) ;
                      ] ;
                  ]
                  [
                    a sp:Filter ;
                    sp:expression [
                        a tosh:isInTargetOf ;
                        sp:arg1 [
                            sp:varName "subject" ;
                          ] ;
                        sp:arg2 [
                            sp:varName "shape" ;
                          ] ;
                      ] ;
                  ]
                )
              ) ;
          ]
        ) ;
    ] ;
  rdfs:comment "Gets all predicates where the given subject actually has at least one value for, plus all magic SPIN properties with matching rdfs:domains and suitable properties declared via SHACL triple rules." ;
  rdfs:label "Used object predicates" ;
  rdfs:subClassOf swa:ObjectPredicateSelectionTemplates ;
.
swa:UsedSubjectPredicates
  a spin:SelectTemplate ;
  spin:body [
      a sp:Select ;
      sp:distinct true ;
      sp:orderBy (
          [
            a ui:label ;
            sp:arg1 [
                sp:varName "predicate" ;
              ] ;
          ]
        ) ;
      sp:resultVariables (
          [
            sp:varName "predicate" ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "object" ;
              ] ;
            sp:predicate [
                sp:varName "predicate" ;
              ] ;
            sp:subject [
                sp:varName "subject" ;
              ] ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:isIRI ;
                sp:arg1 [
                    sp:varName "subject" ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  rdfs:comment "Gets all predicates where the given object has at least one value." ;
  rdfs:label "Used subject predicates" ;
  rdfs:subClassOf swa:SubjectPredicateSelectionTemplates ;
.
swa:VendorScripts
  a ui:Script ;
  ui:prototype """
<ui:group>
    <meta content=\"swa:VendorScripts\" name=\"vendor-scripts-start\"/>
    <script src=\"{= ui:lib() }/assets/lib/dagre/dist/dagre.min.js\"/>
    <script src=\"{= ui:lib() }/assets/lib/jquery/jquery.js\"/>
    <script src=\"{= ui:lib() }/assets/lib/bootstrap/js/bootstrap.min.js\"/>
    <script src=\"{= ui:lib() }/assets/lib/bootstrap-tour/js/bootstrap-tour.min.js\"/>
    <script src=\"{= ui:lib() }/assets/lib/bootstrap-select/js/bootstrap-select.min.js\"/>
    <script src=\"{= ui:lib() }/assets/lib/tinymce/tinymce.min.js\"/>
    <script src=\"{= ui:lib() }/assets/lib/jquery-ui/jquery-ui.js\"/>
    <script src=\"{= ui:lib() }/assets/lib/deparam/jquery-deparam.js\"/>
    <script src=\"{= ui:lib() }/assets/lib/jqgrid/js/i18n/grid.locale-en.js\"/>
    <script src=\"{= ui:lib() }/assets/lib/jqgrid/js/jquery.jqGrid.min.js\"/>
    <script src=\"{= ui:lib() }/assets/lib/contextmenu/jquery.contextMenu.js\"/>
    <script src=\"{= ui:lib() }/assets/lib/chosen/chosen.jquery.min.js\"/>
    <script src=\"{= ui:lib() }/assets/lib/datetime-picker/build/jquery.datetimepicker.full.min.js\"/>
    <script src=\"{= ui:lib() }/assets/lib/jquery-cookie/jquery.cookie.js\"/>
    <script src=\"{= ui:lib() }/assets/lib/hotkeys/jquery.hotkeys.js\"/>
    <script src=\"{= ui:lib() }/assets/lib/jquery-layout/jquery.layout.js\"/>
    <script src=\"{= ui:lib() }/assets/lib/jstree/jstree.min.js\"/>
    <script src=\"{= ui:lib() }/assets/lib/jqplot/js/jquery.jqplot.min.js\"/>
    <script src=\"{= ui:lib() }/assets/lib/openajax/OpenAjax.js\"/>
    <script src=\"{= ui:lib() }/assets/lib/slick/slick.js\"/>
    <script src=\"{= ui:lib() }/assets/lib/swiper/dist/js/swiper.jquery.js\"/>
    <script src=\"{= ui:lib() }/assets/lib/jquery-dropdown/jquery.dropdown.js\"/>
    <script src=\"{= ui:lib() }/assets/lib/jquery-form/jquery.form.js\"/>
    <meta content=\"swa:VendorScripts\" name=\"vendor-scripts-end\"/>
</ui:group>
"""^^ui:Literal ;
  rdfs:label "Vendor scripts" ;
  rdfs:subClassOf ui:Scripts ;
.
swa:VendorStyles
  a ui:Script ;
  ui:dependsOn swa:Meta ;
  ui:prototype """
<ui:group>
    <meta content=\"swa:VendorStyles\" name=\"vendor-styles-start\"/>
    <link href=\"{= ui:lib() }/assets/lib/bootstrap/css/bootstrap.min.css\" rel=\"stylesheet\"/>
    <link href=\"{= ui:lib() }/assets/lib/bootstrap-tour/css/bootstrap-tour.min.css\" rel=\"stylesheet\"/>
    <link href=\"{= ui:lib() }/assets/lib/bootstrap-select/css/bootstrap-select.min.css\" rel=\"stylesheet\"/>
    <link href=\"{= ui:lib() }/assets/lib/slick/slick.css\" rel=\"stylesheet\"/>
    <link href=\"{= ui:lib() }/assets/lib/slick/slick-theme.css\" rel=\"stylesheet\"/>
    <link href=\"{= ui:lib() }/assets/lib/jstree/themes/default/style.min.css\" rel=\"stylesheet\"/>
    <link href=\"{= ui:lib() }/assets/lib/jquery-ui/jquery-ui.css\" rel=\"stylesheet\"/>
    <link href=\"{= ui:lib() }/assets/lib/contextmenu/jquery.contextMenu.css\" rel=\"stylesheet\"/>
    <link href=\"{= ui:lib() }/assets/lib/jqgrid/css/ui.jqgrid.css\" rel=\"stylesheet\"/>
    <link href=\"{= ui:lib() }/assets/lib/jqplot/css/jquery.jqplot.min.css\" rel=\"stylesheet\"/>
    <link href=\"{= ui:lib() }/assets/lib/swiper/dist/css/swiper.min.css\" rel=\"stylesheet\"/>
    <link href=\"{= ui:lib() }/assets/lib/chosen/chosen.min.css\" rel=\"stylesheet\"/>
    <link href=\"{= ui:lib() }/assets/lib/datetime-picker/build/jquery.datetimepicker.min.css\" rel=\"stylesheet\"/>
    <link href=\"{= ui:lib() }/assets/lib/jquery-dropdown/jquery.dropdown.css\" rel=\"stylesheet\" type=\"text/css\"/>
    <link href=\"{= ui:lib() }/assets/build/lib/gram-common/rappid.css\" rel=\"stylesheet\" type=\"text/css\"/>
    <meta content=\"swa:VendorStyles\" name=\"vendor-styles-end\"/>
</ui:group>
"""^^ui:Literal ;
  rdfs:label "Vendor styles" ;
  rdfs:subClassOf ui:Scripts ;
.
swa:ViewForm
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:showURI ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to include the URI of the resource in the header." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:showURIEditorLink ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to show a -> button behind the URI, allowing users to navigate to the resource in its dedicated editor." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to display." ;
    ] ;
  ui:prototype """
<ui:setContext ui:varName=\"mode\" ui:varValue=\"view\">
    <form class=\"swa-form view-mode ui-layout-content\">
        <ui:if ui:condition=\"{= ?showURI }\">
            <div class=\"swa-uri\" let:op=\"{= ui:contextValue(&quot;swaOnOpenResource&quot;) }\">
                <ui:if ui:condition=\"{= ?showURIEditorLink &amp;&amp; bound(?op) }\">
                    <a href=\"javascript:void(0)\" onclick=\"var resource='{= ui:encodeNode(?resource, true, true) }';{= ?op };\" title=\"Open in a new Window\">
                        <span>{= ?resource }</span>
                        <span class=\"swa-uri-resource-viewer-menu swa-icon ui-icon ui-icon-arrow-1-e\"/>
                    </a>
                </ui:if>
                <ui:else>
                    <span>{= ?resource }</span>
                </ui:else>
            </div>
        </ui:if>
        <div class=\"swa-form-body\">
            <ui:setContext ui:varName=\"swa-no-edit-button\" ui:varValue=\"{= true }\">
                <ui:resourceView ui:matchIds=\"view,form\" ui:resource=\"{= ?resource }\"/>
                <swa:DataViewsSection arg:resource=\"{= ?resource }\"/>
            </ui:setContext>
        </div>
    </form>
</ui:setContext>
"""^^ui:Literal ;
  ui:responseType ui:HTML ;
  rdfs:comment "A read-only form that can be inserted into an swa:Window to display the details of a given resource." ;
  rdfs:label "View form" ;
  rdfs:subClassOf swa:Form ;
.
swa:ViewFormGadget
  a swa:Gadget ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:fixedResource ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to not have this gadget react on the resourceSelectedEvent. However, when the user clicks on links, it will still publish this event." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to display." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:showType ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to show the type of the resource behind its label." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:showURI ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to include the URI of the resource in the header." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:showURIEditorLink ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to show a -> button behind the URI, allowing users to navigate to the resource in its dedicated editor." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resourceSelectedEvent ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the event to subscribe to so that the window can be reloaded if the resource changes. The event will also be re-published whenever the user follows a hyperlink on the form. The data payload of the event needs to be the URI of a resource." ;
    ] ;
  ui:prototype """
<ui:setContext ui:varName=\"createLinkFunction\" ui:varValue=\"{= swa:createEventOrNewTabLink }\">
    <ui:setContext ui:varName=\"createEventLinkEvent\" ui:varValue=\"{= ?resourceSelectedEvent }\">
        <ui:if ui:condition=\"{= bound(?resource) }\">
            <swa:WindowTitleSetter arg:title=\"{= ui:label(?resource) }{= IF(?showType, CONCAT(&quot; (&quot;, ui:label(spl:object(?resource, rdf:type)), &quot;)&quot;), ?none) }\"/>
            <swa:ViewForm arg:resource=\"{= ?resource }\" arg:showURI=\"{= ?showURI }\" arg:showURIEditorLink=\"{= ?showURIEditorLink }\"/>
        </ui:if>
        <ui:if ui:condition=\"{= swa:falseOrUnbound(?fixedResource) }\">
            <swa:SubscribeArgument arg:argumentName=\"resource\" arg:event=\"{= ?resourceSelectedEvent }\"/>
        </ui:if>
    </ui:setContext>
</ui:setContext>
"""^^ui:Literal ;
  rdfs:comment "A gadget consisting of a viewable form for a given resource. The resource can either be specified statically, or by subscribing to an event." ;
  rdfs:label "View form gadget" ;
  rdfs:subClassOf swa:Gadgets ;
.
swa:ViewFormGadgetWindow
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:fixedResource ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to not have this window react on the resourceSelectedEvent. However, when the user clicks on links, it will still publish this event." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:showType ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to show the type in the header." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:showURI ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to also show the URI of the resource." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to display." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resourceSelectedEvent ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the event to subscribe to so that the window can be reloaded if the resource changes. The event will also be re-published whenever the user follows a hyperlink on the form. The data payload of the event needs to be the URI of a resource." ;
    ] ;
  ui:prototype """
<swa:Window arg:closable=\"{= true }\" arg:title=\"{= ui:label(?resource) }\" ui:args=\"*\">
    <ui:setContext ui:varName=\"inSWADesktopWindow\" ui:varValue=\"{= true }\">
        <swa:ViewFormGadget ui:args=\"*\"/>
    </ui:setContext>
</swa:Window>
"""^^ui:Literal ;
  rdfs:comment "Can be used to dynamically add a new swa:Window containing a ViewFormGadget." ;
  rdfs:label "View form gadget window" ;
  rdfs:subClassOf swa:GadgetWindows ;
.
swa:ViewMode
  a swa:Mode ;
  swa:formClass swa:SwitchableForm ;
  swa:formObjectPredicateSelectionTemplate swa:UsedObjectPredicates ;
  swa:formSubjectPredicateSelectionTemplate swa:UsedSubjectPredicates ;
  swa:isSingleConstant false ;
  swa:modeName "view" ;
  swa:objectWidgetClass swa:ObjectViewer ;
  swa:objectWidgetMiddleColumnClass swa:ViewWidgetMiddleColumn ;
  swa:objectWidgetRowClass swa:ObjectViewerRow ;
  swa:subjectWidgetRowClass swa:SubjectViewerRow ;
  rdfs:label "View mode" ;
.
swa:ViewResourceDialog
  a ui:NodeClass ;
  a owl:DeprecatedClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:title ;
      spl:valueType xsd:string ;
      rdfs:comment "The title of the dialog. If left unbound, this will use the label of the resource." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:loadId ;
      spl:valueType xsd:string ;
      rdfs:comment "The ui:loadId of the ui:loadable that will be placed around the dialog." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to display." ;
    ] ;
  ui:prototype """
<ui:loadable title=\"{= COALESCE(?title, ui:label(?resource)) }\" ui:loadId=\"div-{= ?loadId }\">
    <ui:setContext ui:varName=\"createLinkFunction\" ui:varValue=\"{= swa:createViewDialogLink }\">
        <ui:resourceView ui:resource=\"{= ?resource }\"/>
    </ui:setContext>
    <script>$(\"#div-{= ?loadId }\").attr(\"resource\", \"{= ?resource }\")</script>
</ui:loadable>
"""^^ui:Literal ;
  rdfs:comment "A dialog that shows the default view of a given resource. The JavaScript call swa.openViewResourceDialog() must be called with the provided loadId and the URI of a resource." ;
  rdfs:label "View resource dialog" ;
  rdfs:subClassOf swa:DialogElements ;
.
swa:ViewWidgetMiddleColumn
  a swa:ObjectWidgetMiddleColumnClass ;
  ui:prototype """
<td class=\"swa-labeled-objects-icons-td\">
    <ui:if ui:condition=\"{= ui:contextValue(&quot;swa-no-edit-button&quot;) || EXISTS {
        ?predicate a spin:MagicProperty .
    } }\">
        <div class=\"swa-icon\"/>
    </ui:if>
    <ui:else>
        <button class=\"btn btn-default btn-xs swa-view-widget-edit-button\" title=\"Edit\" type=\"button\"/>
    </ui:else>
</td>
"""^^ui:Literal ;
  rdfs:subClassOf swa:ObjectWidgetMiddleColumn ;
.
swa:VisualizationAction
  a rdfs:Class ;
  rdfs:comment """A Visualization action that can be applied to a given Resource, e.g. the selected node of a tree or the subject on a form. In the executing JavaScript, the variable resourceURI points to the URI of the selected resource from the menu.

Note that when selecting suitable actions, the execution engine will evaluate the condition on the ui:unionGraph, which may include more triples than expected by the engine. The expression may want to switch to the current domain model using ui:currentQueryGraph() instead.""" ;
  rdfs:label "Visualization action" ;
  rdfs:subClassOf swa:Action ;
.
swa:VisualizationActionsButton
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:class ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional CSS class for the button." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:editable ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to include the edit actions." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:id ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional id for the button." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to apply the action(s) on. If left blank, then a getter expression must be provided." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:resourceGetter ;
      spl:valueType xsd:string ;
      rdfs:comment "A JavaScript expression that is evaluated to return the URI of the selected resource." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:toolTip ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional tool tip text to appear on the button." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resourceSelectedEvent ;
      spl:valueType xsd:string ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:group let:id=\"{= COALESCE(?id, ui:uniqueId()) }\">
    <button class=\"swa-button swa-visualization-actions-button {= ?class }\" id=\"{= ?id }\" onclick=\"swa.openResourceActionsMenu('{= ?id }', '{= IF(bound(?resourceGetter), ?resourceGetter, CONCAT(&quot;\\&quot;&quot;, swa:unwrap(ui:encodeNode(?resource, true, true)), &quot;\\&quot;&quot;)) }', '{= ui:currentQueryGraph() }', '{= swa:appName() }', '{= ui:contextValue(&quot;swaCanDeleteResourceFunction&quot;) }', {= IF(bound(?editable), (!?editable), false) }, '{= ?resourceSelectedEvent }')\" title=\"{= ?toolTip }\">
        <div class=\"ui-icon swa-visualization-actions-icon\"/>
    </button>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "A Button displaying a popup menu when pressed, consisting of Visualization Actions for a given resource. The resource is either a constant or delivered dynamically through a (JavaScript) getter expression." ;
  rdfs:label "Visualization actions button" ;
  rdfs:subClassOf swa:MenuElements ;
.
swa:WeightedExpression
  a spin:Template ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate swa:weight ;
      spl:valueType xsd:integer ;
      rdfs:comment "The weight of the widget if the expression is true." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate swa:expression ;
      spl:valueType xsd:boolean ;
      rdfs:comment "A boolean expression that delivers true to accept the associated widget type for the given input variables." ;
    ] ;
  spin:labelTemplate "Select {?expression} with weight {?weight}" ;
  rdfs:comment "Class of objects that are used by the SWA engine to select the most suitable widget for a given context. A weighted expression has a weight that is used to discriminate between multiple matching alternatives - the widget with the highest weight will be picked. The expression is evaluated with certain variables pre-bound, depending on the type of component that is used." ;
  rdfs:label "Weighted expression" ;
.
swa:WidgetDropDownEditor
  a swa:ObjectEditorClass ;
  ui:private true ;
  ui:prototype """
<span let:name=\"new-{= ?uid }\" let:range=\"{= swa:localRangeAtClass(swa:resourceType(?subject), ?predicate) }\">
    <select class=\"form-control\" name=\"{= ?name }\">
        <option/>
        <ui:forEach ui:resultSet=\"{#
                SELECT ?item ?label
                WHERE {
                    GRAPH ui:graph {
                        ?item a ?range .
                        FILTER NOT EXISTS {
                            ?item ui:abstract true .
                        } .
                        FILTER NOT EXISTS {
                            ?item ui:private true .
                        } .
                        BIND (ui:label(?item) AS ?label) .
                    } .
                }
                ORDER BY (?label) }\">
            <option selected=\"{= IF((?object = ?item), &quot;selected&quot;, ?none) }\" value=\"{= ui:encodeNode(?item) }\">{= ?label }</option>
        </ui:forEach>
    </select>
</span>
"""^^ui:Literal ;
  rdfs:label "Widget drop down editor" ;
  rdfs:subClassOf swa:ObjectEditor ;
.
swa:WidgetInitializer
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:script ;
      spl:valueType xsd:string ;
      rdfs:comment "The script that initializes this widget." ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:group>
    <ui:if ui:condition=\"{= ui:contextValue(&quot;widgetPrototype&quot;) }\">
        <span class=\"swa-widget-initializer\" content=\"{= ?script }\"/>
    </ui:if>
    <ui:else>
        <script>{= ?script }</script>
    </ui:else>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "Used by EditWidgets to encapsulate initialization code - JavaScript snippets that need to be executed if a new instance (new row) of this type is created." ;
  rdfs:label "Widget initializer" ;
  rdfs:subClassOf swa:ScriptElements ;
.
swa:WidgetLabel
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate to display" ;
    ] ;
  ui:private true ;
  ui:prototype """
<swa:Label arg:node=\"{= ui:label(?predicate) }: \"/>
"""^^ui:Literal ;
  rdfs:label "Widget label" ;
  rdfs:subClassOf swa:Elements ;
.
swa:Window
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:closable ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to display a close button in the upper right corner." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:headerClass ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional CSS class for the header." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:subTitle ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional text to appear in small letters in the right part of the title bar." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:layoutPanel ;
      spl:valueType xsd:string ;
      rdfs:comment "The position within the surrounding BorderLayout: one of \"east\", \"north\", \"west\", \"south\" or \"center\"." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:title ;
      spl:valueType xsd:string ;
      rdfs:comment "The label in the header." ;
    ] ;
  ui:prototype """
<div class=\"swa-window swa-window-border ui-layout-{= ?layoutPanel }\" id=\"{= ?id }\">
    <div class=\"swa-header {= ?headerClass }\">
        <div class=\"swa-window-header-label swa-header-label\" id=\"{= ?id }-window-title\">{= ?title }</div>
        <div class=\"swa-float-right\">
            <span class=\"swa-window-header-subtitle\" id=\"{= ?id }-window-subtitle\">{= ?subTitle }</span>
            <ui:if ui:condition=\"{= ?closable }\">
                <swa:WindowHeaderButton arg:function=\"swa.closeWindow\" arg:iconClass=\"swa-window-header-button-close\" arg:toolTip=\"Close\" arg:windowId=\"{= ?id }\"/>
            </ui:if>
            <ui:insertionPoint ui:pointId=\"header-buttons\"/>
            <ui:insertionPoint ui:pointId=\"buttons\"/>
        </div>
        <div class=\"swa-clear-both\"/>
    </div>
    <ui:insertionPoint ui:pointId=\"1\"/>
    <ui:insertionPoint ui:pointId=\"2\"/>
    <ui:insertionPoint ui:pointId=\"3\"/>
    <ui:insertionPoint ui:pointId=\"4\"/>
    <ui:insertionPoint ui:pointId=\"5\"/>
</div>
"""^^ui:Literal ;
  ui:responseType ui:HTML ;
  rdfs:comment """A rectangular area with a title bar and an optional button to close itself. Instances of swa:Window can be inserted into a BorderLayout.

Each swa:Window has a number of insertion points, that can be used to define the body and to insert additional buttons into the upper right corner. By default, children of the swa:Window tag are inserted under the header. The main area of the window should have the HTML class \"ui-layout-content\" so that the layout engine will give it the maximum available space and place scroll bars properly. Other children can be placed as secondary header or footer areas. To insert additional buttons, use <ui:insert ui:into=\"buttons><swa:WindowHeaderButton ... /></ui:insert>.

The content of a Window can be reloaded through an Ajax call, using the JavaScript functions swa:load or swa:loadWithResource.""" ;
  rdfs:label "Window" ;
  rdfs:subClassOf swa:AbstractWindow ;
.
swa:WindowHeaderButton
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:function ;
      spl:valueType xsd:string ;
      rdfs:comment "The JS function to call, e.g. \"swa.closeWindow\"." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:id ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional id for the button." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:onClick ;
      spl:valueType xsd:string ;
      rdfs:comment "JavaScript code to execute when the button is clicked - not used if arg:function is specified." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:toolTip ;
      spl:valueType xsd:string ;
      rdfs:comment "The tool tip text to show up above the button." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:iconClass ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the icon class." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:windowId ;
      spl:valueType xsd:string ;
      rdfs:comment "The id of the surrounding window." ;
    ] ;
  ui:private true ;
  ui:prototype """
<div class=\"swa-window-header-button {= ?iconClass }\" id=\"{= ?id }\" onclick=\"{= IF(bound(?function), ui:functionCall(?function, ?windowId), ?onClick) }\" title=\"{= ?toolTip }\"/>
"""^^ui:Literal ;
  rdfs:label "Window header button" ;
  rdfs:subClassOf swa:ApplicationElements ;
.
swa:WindowTitleSetter
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:subTitle ;
      spl:valueType xsd:string ;
      rdfs:comment "The optional sub-title to appear on the right." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:title ;
      spl:valueType xsd:string ;
      rdfs:comment "The new title." ;
    ] ;
  ui:prototype """
<script>{= ui:functionCall(\"swa.setWindowTitle\", swa:currentWindowId(), ?title, ?subTitle) }</script>
"""^^ui:Literal ;
  rdfs:comment "Generates a script tag that will modify the title of the surrounding window." ;
  rdfs:label "Window title setter" ;
  rdfs:subClassOf swa:ScriptElements ;
.
swa:abbreviatedText
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Union ;
            sp:elements (
                (
                  [
                    a sp:Filter ;
                    sp:expression [
                        a sp:le ;
                        sp:arg1 [
                            a fn:string-length ;
                            sp:arg1 [
                                sp:varName "input" ;
                              ] ;
                          ] ;
                        sp:arg2 [
                            sp:varName "maxLength" ;
                          ] ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression [
                        sp:varName "input" ;
                      ] ;
                    sp:variable [
                        sp:varName "result" ;
                      ] ;
                  ]
                )
                (
                  [
                    a sp:Bind ;
                    sp:expression [
                        a sp:coalesce ;
                        sp:arg1 [
                            a spif:lastIndexOf ;
                            sp:arg1 [
                                sp:varName "input" ;
                              ] ;
                            sp:arg2 " " ;
                            sp:arg3 [
                                sp:varName "maxLength" ;
                              ] ;
                          ] ;
                        sp:arg2 [
                            sp:varName "maxLength" ;
                          ] ;
                      ] ;
                    sp:variable [
                        sp:varName "lastSpace" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression [
                        a sp:concat ;
                        sp:arg1 [
                            a fn:substring ;
                            sp:arg1 [
                                sp:varName "input" ;
                              ] ;
                            sp:arg2 0 ;
                            sp:arg3 [
                                a sp:add ;
                                sp:arg1 [
                                    sp:varName "lastSpace" ;
                                  ] ;
                                sp:arg2 1 ;
                              ] ;
                          ] ;
                        sp:arg2 "..." ;
                      ] ;
                    sp:variable [
                        sp:varName "result" ;
                      ] ;
                  ]
                )
              ) ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:input ;
      spl:valueType xsd:string ;
      rdfs:comment "The input string." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:maxLength ;
      spl:valueType xsd:integer ;
      rdfs:comment "The maximum length of the string." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Takes a string and makes sure it is shorter than the given length - using ... if necessary. The algorithm will cut the string off at a suitable location, a space character." ;
  rdfs:label "abbreviated text" ;
  rdfs:subClassOf swa:Functions ;
.
swa:addDefaultValues
  a ui:Method ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The newly created resource." ;
    ] ;
  ui:prototype """
<ui:group>
    <ui:forEach ui:resultSet=\"{#
            SELECT ?plugin
            WHERE {
                GRAPH ui:graph {
                    ?plugin a swa:AddDefaultValuesPlugin .
                } .
            } }\">
        <ui:dynamicView arg:resource=\"{= ?resource }\" ui:class=\"{= ?plugin }\"/>
    </ui:forEach>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment """Calls any swa:AddDefaultValuesPlugin. This should be called as part of each swa:CreateResourceHandler.

Until 6.2 this used to also assert sh:defaultValues, but this is now done through inferences / property value rules.""" ;
  rdfs:label "Add default values" ;
  rdfs:subClassOf ui:Methods ;
.
swa:addTriplesFromCurrentGraph
  a ui:NodeClass ;
  ui:prototype """
<ui:update ui:updateQuery=\"{!
        INSERT {
            GRAPH ?targetGraph {
                ?s ?p ?o .
            } .
        }
        WHERE {
            ?s ?p ?o .
        } }\"/>
"""^^ui:Literal ;
  rdfs:label "add triples from current graph" ;
  rdfs:subClassOf swa:GraphOperations ;
.
swa:addTriplesFromNamedGraph
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:sourceGraph ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The named graph containing the triples to copy." ;
    ] ;
  ui:prototype """
<ui:update ui:updateQuery=\"{!
        INSERT {
            GRAPH ?targetGraph {
                ?s ?p ?o .
            } .
        }
        WHERE {
            GRAPH ?sourceGraph {
                ?s ?p ?o .
            } .
        } }\"/>
"""^^ui:Literal ;
  rdfs:label "add triples from named graph" ;
  rdfs:subClassOf swa:GraphOperations ;
.
swa:anchorId
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            a sp:NamedGraph ;
            sp:elements (
                [
                  a sp:Bind ;
                  sp:expression [
                      a spif:replaceAll ;
                      sp:arg1 [
                          a smf:qname ;
                          sp:arg1 [
                              sp:varName "element" ;
                            ] ;
                        ] ;
                      sp:arg2 ":" ;
                      sp:arg3 "_" ;
                    ] ;
                  sp:variable [
                      sp:varName "result" ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode ui:graph ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:element ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The element to turn into an anchor id." ;
    ] ;
  spin:private true ;
  spin:returnType xsd:string ;
  rdfs:comment "Takes an swa:Element and derives an anchor ID that can be used as target of hyperlinks." ;
  rdfs:label "anchor id" ;
  rdfs:subClassOf swa:Functions ;
.
swa:autoCompleteSearchPlaceholder
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a sp:concat ;
                sp:arg1 "Look up " ;
                sp:arg2 [
                    sp:varName "text" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:text ;
      spl:valueType xsd:string ;
      rdfs:comment "The text to display after \"Search\"." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:label "auto complete search placeholder" ;
  rdfs:subClassOf swa:Functions ;
.
swa:bestCreateResourceDialogPlugin
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "plugin" ;
          ]
        ) ;
      sp:where (
          (
            [
              a sp:NamedGraph ;
              sp:elements (
                  [
                    a sp:SubQuery ;
                    sp:query [
                        a sp:Select ;
                        sp:orderBy (
                            [
                              a sp:Desc ;
                              sp:expression [
                                  sp:varName "weight" ;
                                ] ;
                            ]
                          ) ;
                        sp:where (
                            [
                              sp:object [
                                  sp:varName "w" ;
                                ] ;
                              sp:predicate swa:createResourceDialogPluginWeight ;
                              sp:subject [
                                  sp:varName "plugin" ;
                                ] ;
                            ]
                            [
                              sp:object [
                                  sp:varName "expression" ;
                                ] ;
                              sp:predicate swa:expression ;
                              sp:subject [
                                  sp:varName "w" ;
                                ] ;
                            ]
                            [
                              a sp:Bind ;
                              sp:expression [
                                  a sp:coalesce ;
                                  sp:arg1 [
                                      a spl:object ;
                                      sp:arg1 [
                                          sp:varName "w" ;
                                        ] ;
                                      sp:arg2 swa:weight ;
                                    ] ;
                                  sp:arg2 0 ;
                                ] ;
                              sp:variable [
                                  sp:varName "weight" ;
                                ] ;
                            ]
                          ) ;
                      ] ;
                  ]
                  [
                    a sp:Filter ;
                    sp:expression [
                        a spin:eval ;
                        sp:arg1 [
                            sp:varName "expression" ;
                          ] ;
                        sp:arg2 arg:resourceType ;
                        sp:arg3 [
                            sp:varName "resourceType" ;
                          ] ;
                        sp:arg4 arg:contextResource ;
                        sp:arg5 [
                            sp:varName "contextResource" ;
                          ] ;
                        sp:arg6 arg:appName ;
                        sp:arg7 [
                            a sp:coalesce ;
                            sp:arg1 [
                                a swa:appName ;
                              ] ;
                            sp:arg2 "NONE" ;
                          ] ;
                      ] ;
                  ]
                ) ;
              sp:graphNameNode ui:graph ;
            ]
          )
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:contextResource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The context resource." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The resource type." ;
    ] ;
  spin:private true ;
  spin:returnType swa:CreateResourceDialogPlugin ;
  rdfs:label "best create resource dialog plugin" ;
  rdfs:subClassOf swa:Functions ;
.
swa:bestObjectEditorClass
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:expression [
                a swa:bestObjectWidgetClass ;
                arg:object [
                    sp:varName "object" ;
                  ] ;
                arg:predicate [
                    sp:varName "predicate" ;
                  ] ;
                arg:range [
                    sp:varName "range" ;
                  ] ;
                arg:resourceType [
                    sp:varName "subjectType" ;
                  ] ;
                arg:type swa:ObjectEditorClass ;
                arg:xrange [
                    sp:varName "xrange" ;
                  ] ;
              ] ;
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a swa:resourceType ;
                arg:resource [
                    sp:varName "subject" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "subjectType" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:if ;
                sp:arg1 [
                    a sp:bound ;
                    sp:arg1 [
                        sp:varName "predicate" ;
                      ] ;
                  ] ;
                sp:arg2 [
                    a swa:localRange ;
                    arg:predicate [
                        sp:varName "predicate" ;
                      ] ;
                    arg:subject [
                        sp:varName "subject" ;
                      ] ;
                  ] ;
                sp:arg3 [
                    sp:varName "none" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "xrange" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:coalesce ;
                sp:arg1 [
                    sp:varName "suggestedRange" ;
                  ] ;
                sp:arg2 [
                    a sp:if ;
                    sp:arg1 [
                        a sp:bound ;
                        sp:arg1 [
                            sp:varName "object" ;
                          ] ;
                      ] ;
                    sp:arg2 [
                        a sp:datatype ;
                        sp:arg1 [
                            sp:varName "object" ;
                          ] ;
                      ] ;
                    sp:arg3 [
                        sp:varName "none" ;
                      ] ;
                  ] ;
                sp:arg3 [
                    sp:varName "xrange" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "range" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:object ;
      rdfs:comment "The node of the existing value." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:subject ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:suggestedRange ;
      spl:valueType rdfs:Class ;
      rdfs:comment "A range suggestion that will be used instead of the derived one." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate of the editor." ;
    ] ;
  spin:private true ;
  spin:returnType swa:ObjectEditorClass ;
  rdfs:comment "Find the best suitable ObjectEditor for a given node, predicate, subject, subjectType combination. May return nothing, e.g. for blank nodes." ;
  rdfs:label "node editor class" ;
  rdfs:subClassOf swa:Functions ;
.
swa:bestObjectFacetClass
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "widgetClass" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a swa:restoreFacetValue ;
                arg:property [
                    sp:varName "predicate" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "facetValue" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a swa:resourceType ;
              ] ;
            sp:variable [
                sp:varName "resourceType" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a swa:localRangeAtClass ;
                arg:class [
                    sp:varName "resourceType" ;
                  ] ;
                arg:property [
                    sp:varName "predicate" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "range" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:if ;
                sp:arg1 [
                    a sp:bound ;
                    sp:arg1 [
                        sp:varName "facetValue" ;
                      ] ;
                  ] ;
                sp:arg2 [
                    a swa:bestObjectFacetClassRestored ;
                    arg:facetValue [
                        sp:varName "facetValue" ;
                      ] ;
                    arg:predicate [
                        sp:varName "predicate" ;
                      ] ;
                    arg:range [
                        sp:varName "range" ;
                      ] ;
                    arg:resourceType [
                        sp:varName "resourceType" ;
                      ] ;
                  ] ;
                sp:arg3 [
                    a swa:bestObjectFacetClassHelper ;
                    arg:predicate [
                        sp:varName "predicate" ;
                      ] ;
                    arg:range [
                        sp:varName "range" ;
                      ] ;
                    arg:resourceType [
                        sp:varName "resourceType" ;
                      ] ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "widgetClass" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate of the editor." ;
    ] ;
  spin:private true ;
  spin:returnType swa:ObjectFacetClass ;
  rdfs:comment "Find the best suitable ObjectFacet for a given predicate and resourceType combination. May return nothing, e.g. for blank nodes." ;
  rdfs:label "best object facet class" ;
  rdfs:subClassOf swa:Functions ;
.
swa:bestObjectFacetClassHelper
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "widgetClass" ;
          ]
        ) ;
      sp:where (
          [
            a sp:NamedGraph ;
            sp:elements (
                [
                  a sp:SubQuery ;
                  sp:query [
                      a sp:Select ;
                      sp:orderBy (
                          [
                            a sp:Desc ;
                            sp:expression [
                                sp:varName "weight" ;
                              ] ;
                          ]
                        ) ;
                      sp:resultVariables (
                          [
                            sp:varName "widgetClass" ;
                          ]
                          [
                            sp:varName "expression" ;
                          ]
                        ) ;
                      sp:where (
                          [
                            sp:object swa:ObjectFacetClass ;
                            sp:predicate rdf:type ;
                            sp:subject [
                                sp:varName "widgetClass" ;
                              ] ;
                          ]
                          [
                            sp:object [
                                sp:varName "w" ;
                              ] ;
                            sp:predicate swa:objectWidgetWeight ;
                            sp:subject [
                                sp:varName "widgetClass" ;
                              ] ;
                          ]
                          [
                            sp:object [
                                sp:varName "expression" ;
                              ] ;
                            sp:predicate swa:expression ;
                            sp:subject [
                                sp:varName "w" ;
                              ] ;
                          ]
                          [
                            a sp:Bind ;
                            sp:expression [
                                a sp:coalesce ;
                                sp:arg1 [
                                    a spl:object ;
                                    sp:arg1 [
                                        sp:varName "w" ;
                                      ] ;
                                    sp:arg2 swa:weight ;
                                  ] ;
                                sp:arg2 0 ;
                              ] ;
                            sp:variable [
                                sp:varName "weight" ;
                              ] ;
                          ]
                        ) ;
                    ] ;
                ]
                [
                  a sp:Filter ;
                  sp:expression [
                      a spin:eval ;
                      sp:arg1 [
                          sp:varName "expression" ;
                        ] ;
                      sp:arg2 arg:predicate ;
                      sp:arg3 [
                          sp:varName "predicate" ;
                        ] ;
                      sp:arg4 arg:range ;
                      sp:arg5 [
                          sp:varName "range" ;
                        ] ;
                      sp:arg6 arg:resourceType ;
                      sp:arg7 [
                          sp:varName "resourceType" ;
                        ] ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode ui:graph ;
          ]
        ) ;
    ] ;
  spin:cachable true ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:range ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The range" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The resource type." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property." ;
    ] ;
  spin:returnType swa:ObjectFacetClass ;
  rdfs:label "best object facet class helper" ;
  rdfs:subClassOf swa:Functions ;
.
swa:bestObjectFacetClassRestored
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:orderBy (
          [
            a sp:Desc ;
            sp:expression [
                sp:varName "weight" ;
              ] ;
          ]
        ) ;
      sp:resultVariables (
          [
            sp:varName "widgetClass" ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "facetValueType" ;
              ] ;
            sp:predicate rdf:type ;
            sp:subject [
                sp:varName "facetValue" ;
              ] ;
          ]
          [
            a sp:NamedGraph ;
            sp:elements (
                [
                  sp:object [
                      sp:varName "facetValueType" ;
                    ] ;
                  sp:predicate swa:facetSearchType ;
                  sp:subject [
                      sp:varName "widgetClass" ;
                    ] ;
                ]
                [
                  sp:object [
                      sp:varName "w" ;
                    ] ;
                  sp:predicate swa:objectWidgetWeight ;
                  sp:subject [
                      sp:varName "widgetClass" ;
                    ] ;
                ]
                [
                  sp:object [
                      sp:varName "expression" ;
                    ] ;
                  sp:predicate swa:expression ;
                  sp:subject [
                      sp:varName "w" ;
                    ] ;
                ]
                [
                  a sp:Bind ;
                  sp:expression [
                      a sp:coalesce ;
                      sp:arg1 [
                          a spl:object ;
                          sp:arg1 [
                              sp:varName "w" ;
                            ] ;
                          sp:arg2 swa:weight ;
                        ] ;
                      sp:arg2 0 ;
                    ] ;
                  sp:variable [
                      sp:varName "weight" ;
                    ] ;
                ]
                [
                  a sp:Filter ;
                  sp:expression [
                      a spin:eval ;
                      sp:arg1 [
                          sp:varName "expression" ;
                        ] ;
                      sp:arg2 arg:predicate ;
                      sp:arg3 [
                          sp:varName "predicate" ;
                        ] ;
                      sp:arg4 arg:range ;
                      sp:arg5 [
                          sp:varName "range" ;
                        ] ;
                      sp:arg6 arg:resourceType ;
                      sp:arg7 [
                          sp:varName "resourceType" ;
                        ] ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode ui:graph ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:range ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The range" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The resource type." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:facetValue ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The facet value from the restored search." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property." ;
    ] ;
  spin:returnType swa:ObjectFacetClass ;
  rdfs:label "best object facet class restored" ;
  rdfs:subClassOf swa:Functions ;
.
swa:bestObjectViewerClass
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a sp:if ;
                sp:arg1 [
                    a sp:isBlank ;
                    sp:arg1 [
                        sp:varName "object" ;
                      ] ;
                  ] ;
                sp:arg2 [
                    a sp:if ;
                    sp:arg1 [
                        a sp:exists ;
                        sp:elements (
                            [
                              sp:object [
                                  sp:varName "any" ;
                                ] ;
                              sp:predicate rdf:first ;
                              sp:subject [
                                  sp:varName "object" ;
                                ] ;
                            ]
                          ) ;
                      ] ;
                    sp:arg2 "list" ;
                    sp:arg3 "blank" ;
                  ] ;
                sp:arg3 [
                    a sp:if ;
                    sp:arg1 [
                        a sp:isLiteral ;
                        sp:arg1 [
                            sp:varName "object" ;
                          ] ;
                      ] ;
                    sp:arg2 [
                        a sp:if ;
                        sp:arg1 [
                            a sp:and ;
                            sp:arg1 [
                                a sp:eq ;
                                sp:arg1 [
                                    a sp:datatype ;
                                    sp:arg1 [
                                        sp:varName "object" ;
                                      ] ;
                                  ] ;
                                sp:arg2 xsd:anyURI ;
                              ] ;
                            sp:arg2 [
                                a swa:isImageURL ;
                                arg:url [
                                    a xsd:string ;
                                    sp:arg1 [
                                        sp:varName "object" ;
                                      ] ;
                                  ] ;
                              ] ;
                          ] ;
                        sp:arg2 "image" ;
                        sp:arg3 "literal" ;
                      ] ;
                    sp:arg3 [
                        a sp:if ;
                        sp:arg1 [
                            a swa:isImageURL ;
                            arg:url [
                                a xsd:string ;
                                sp:arg1 [
                                    sp:varName "object" ;
                                  ] ;
                              ] ;
                          ] ;
                        sp:arg2 "image" ;
                        sp:arg3 [
                            a sp:if ;
                            sp:arg1 [
                                a sp:eq ;
                                sp:arg1 [
                                    sp:varName "object" ;
                                  ] ;
                                sp:arg2 () ;
                              ] ;
                            sp:arg2 "list" ;
                            sp:arg3 "uri" ;
                          ] ;
                      ] ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "kind" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:if ;
                sp:arg1 [
                    a sp:isLiteral ;
                    sp:arg1 [
                        sp:varName "object" ;
                      ] ;
                  ] ;
                sp:arg2 [
                    a sp:datatype ;
                    sp:arg1 [
                        sp:varName "object" ;
                      ] ;
                  ] ;
                sp:arg3 [
                    a swa:resourceType ;
                    arg:resource [
                        sp:varName "object" ;
                      ] ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "type" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a swa:bestObjectViewerClassHelper ;
                arg:kind [
                    sp:varName "kind" ;
                  ] ;
                arg:predicate [
                    sp:varName "predicate" ;
                  ] ;
                arg:type [
                    sp:varName "type" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:subject ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:object ;
      rdfs:comment "The node to get the widget type for." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate of the editor." ;
    ] ;
  spin:private true ;
  spin:returnType swa:ObjectViewerClass ;
  rdfs:comment "Walks through all ObjectWidgets that declare a weight and returns the widget class that has the highest weight for a given object, predicate and subject." ;
  rdfs:label "best object viewer class" ;
  rdfs:subClassOf swa:Functions ;
.
swa:bestObjectViewerClassHelper
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "widgetClass" ;
          ]
        ) ;
      sp:where (
          [
            a sp:NamedGraph ;
            sp:elements (
                [
                  a sp:SubQuery ;
                  sp:query [
                      a sp:Select ;
                      sp:orderBy (
                          [
                            a sp:Desc ;
                            sp:expression [
                                sp:varName "weight" ;
                              ] ;
                          ]
                        ) ;
                      sp:where (
                          [
                            sp:object swa:ObjectViewerClass ;
                            sp:predicate rdf:type ;
                            sp:subject [
                                sp:varName "widgetClass" ;
                              ] ;
                          ]
                          [
                            sp:object [
                                sp:varName "w" ;
                              ] ;
                            sp:predicate swa:objectWidgetWeight ;
                            sp:subject [
                                sp:varName "widgetClass" ;
                              ] ;
                          ]
                          [
                            sp:object [
                                sp:varName "expression" ;
                              ] ;
                            sp:predicate swa:expression ;
                            sp:subject [
                                sp:varName "w" ;
                              ] ;
                          ]
                          [
                            a sp:Bind ;
                            sp:expression [
                                a sp:coalesce ;
                                sp:arg1 [
                                    a spl:object ;
                                    sp:arg1 [
                                        sp:varName "w" ;
                                      ] ;
                                    sp:arg2 swa:weight ;
                                  ] ;
                                sp:arg2 0 ;
                              ] ;
                            sp:variable [
                                sp:varName "weight" ;
                              ] ;
                          ]
                        ) ;
                    ] ;
                ]
                [
                  a sp:Filter ;
                  sp:expression [
                      a spin:eval ;
                      sp:arg1 [
                          sp:varName "expression" ;
                        ] ;
                      sp:arg2 arg:kind ;
                      sp:arg3 [
                          sp:varName "kind" ;
                        ] ;
                      sp:arg4 arg:predicate ;
                      sp:arg5 [
                          sp:varName "predicate" ;
                        ] ;
                      sp:arg6 arg:type ;
                      sp:arg7 [
                          sp:varName "type" ;
                        ] ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode ui:graph ;
          ]
        ) ;
    ] ;
  spin:cachable true ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:kind ;
      spl:valueType xsd:string ;
      rdfs:comment "The kind of object: \"blank\", \"image\", \"literal\" or \"uri\"." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property being displayed." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:type ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The datatype or rdf:type of the object." ;
    ] ;
  spin:returnType swa:ObjectViewerClass ;
  rdfs:label "best object viewer class helper" ;
  rdfs:subClassOf swa:Functions ;
.
swa:bestObjectWidgetClass
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "widgetClass" ;
          ]
        ) ;
      sp:where (
          [
            a sp:NamedGraph ;
            sp:elements (
                [
                  sp:object [
                      sp:varName "?0" ;
                    ] ;
                  sp:predicate swa:objectWidgetClassesWithType ;
                  sp:subject [
                      sp:varName "type" ;
                    ] ;
                ]
                [
                  sp:object [
                      sp:varName "widgetClass" ;
                    ] ;
                  sp:predicate rdf:first ;
                  sp:subject [
                      sp:varName "?0" ;
                    ] ;
                ]
                [
                  sp:object [
                      sp:varName "?1" ;
                    ] ;
                  sp:predicate rdf:rest ;
                  sp:subject [
                      sp:varName "?0" ;
                    ] ;
                ]
                [
                  sp:object [
                      sp:varName "expression" ;
                    ] ;
                  sp:predicate rdf:first ;
                  sp:subject [
                      sp:varName "?1" ;
                    ] ;
                ]
                [
                  sp:object () ;
                  sp:predicate rdf:rest ;
                  sp:subject [
                      sp:varName "?1" ;
                    ] ;
                ]
                [
                  a sp:Filter ;
                  sp:expression [
                      a spin:eval ;
                      sp:arg1 [
                          sp:varName "expression" ;
                        ] ;
                      sp:arg10 arg:widgetClass ;
                      sp:arg11 [
                          sp:varName "widgetClass" ;
                        ] ;
                      sp:arg12 arg:xrange ;
                      sp:arg13 [
                          sp:varName "xrange" ;
                        ] ;
                      sp:arg2 arg:object ;
                      sp:arg3 [
                          sp:varName "object" ;
                        ] ;
                      sp:arg4 arg:predicate ;
                      sp:arg5 [
                          sp:varName "predicate" ;
                        ] ;
                      sp:arg6 arg:range ;
                      sp:arg7 [
                          sp:varName "range" ;
                        ] ;
                      sp:arg8 arg:resourceType ;
                      sp:arg9 [
                          sp:varName "resourceType" ;
                        ] ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode ui:graph ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:range ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The range of the predicate at the subject. In some cases (such as called from swa:bestObjectEditorClass, this may be the datatype of the existing literal value)." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:xrange ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The declared range of the property, regardless of the actual value. This is used in the case where the range is the datatype of the actual object, for widgets that prefer to look at the declared range." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:object ;
      rdfs:comment "The object to get the widget type for." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The subject type." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:type ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The type that the widget class must have, e.g. swa:NodeEditorClass" ;
    ] ;
  spin:private true ;
  spin:returnType swa:ObjectWidgetClass ;
  rdfs:comment "Walks through all ObjectWidget classes of a given type (?type) that declare an objectWidgetWeight and returns the ObjectWidget class that has the highest weight for a given node (?node), predicate (?predicate), resource type (?resourceType) and local range (?range). All arguments are optional, but not all will be empty. If the resourceType and predicate are known, then also the ?range will be bound." ;
  rdfs:label "best object widget class" ;
  rdfs:subClassOf swa:Functions ;
.
swa:bestSubPropertyOfRDFSLabel
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:orderBy (
          [
            sp:varName "property" ;
          ]
        ) ;
      sp:resultVariables (
          [
            sp:varName "property" ;
          ]
        ) ;
      sp:where (
          [
            sp:object rdfs:label ;
            sp:predicate rdfs:subPropertyOf ;
            sp:subject [
                sp:varName "property" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "domain" ;
              ] ;
            sp:predicate rdfs:domain ;
            sp:subject [
                sp:varName "property" ;
              ] ;
          ]
          [
            a sp:TriplePath ;
            sp:object [
                sp:varName "domain" ;
              ] ;
            sp:path [
                a sp:ModPath ;
                sp:modMax -2 ;
                sp:modMin 0 ;
                sp:subPath rdfs:subClassOf ;
              ] ;
            sp:subject [
                sp:varName "class" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:class ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class to get the label property for." ;
    ] ;
  spin:private true ;
  spin:returnType rdf:Property ;
  rdfs:comment "For a given class, this gets the \"first\" sub-property of rdfs:label that has the class in its rdfs:domain." ;
  rdfs:label "best sub property of rdfs:label" ;
  rdfs:subClassOf swa:Functions ;
.
swa:bestSubjectEditorClass
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:expression [
                a swa:bestSubjectWidgetClass ;
                arg:objectType [
                    a swa:resourceType ;
                    arg:resource [
                        sp:varName "object" ;
                      ] ;
                  ] ;
                arg:predicate [
                    sp:varName "predicate" ;
                  ] ;
                arg:subject [
                    sp:varName "subject" ;
                  ] ;
                arg:type swa:SubjectEditorClass ;
              ] ;
            sp:varName "result" ;
          ]
        ) ;
      sp:where () ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:subject ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:objectType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The type of the main resource on the form." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate of the editor." ;
    ] ;
  spin:private true ;
  spin:returnType swa:SubjectEditorClass ;
  rdfs:comment "Find the best suitable SubjectEditor for a given object/predicate. May return nothing, e.g. for blank nodes." ;
  rdfs:label "subject editor class" ;
  rdfs:subClassOf swa:Functions ;
.
swa:bestSubjectFacetClass
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:expression [
                a swa:bestSubjectWidgetClass ;
                arg:objectType [
                    a swa:resourceType ;
                    arg:resource [
                        sp:varName "object" ;
                      ] ;
                  ] ;
                arg:predicate [
                    sp:varName "predicate" ;
                  ] ;
                arg:subject [
                    sp:varName "none" ;
                  ] ;
                arg:type swa:SubjectFacetClass ;
              ] ;
            sp:varName "result" ;
          ]
        ) ;
      sp:where () ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:object ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The object." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate of the editor." ;
    ] ;
  spin:private true ;
  spin:returnType swa:SubjectEditorClass ;
  rdfs:comment "Find the best suitable SubjectFacet for a given predicate, object combination. May return nothing, e.g. for blank nodes." ;
  rdfs:label "best node facet class" ;
  rdfs:subClassOf swa:Functions ;
.
swa:bestSubjectViewerClass
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:expression [
                a swa:bestSubjectWidgetClass ;
                arg:objectType [
                    sp:varName "objectType" ;
                  ] ;
                arg:predicate [
                    sp:varName "predicate" ;
                  ] ;
                arg:subject [
                    sp:varName "subject" ;
                  ] ;
                arg:type swa:SubjectViewerClass ;
              ] ;
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a swa:resourceType ;
                arg:resource [
                    sp:varName "object" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "objectType" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:subject ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:object ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The node to get the widget type for." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate of the editor." ;
    ] ;
  spin:private true ;
  spin:returnType swa:SubjectWidgetClass ;
  rdfs:comment "Walks through all SubjectWidgets of a given type (?type) that declare a subjectWidgetWeight and returns the widget class that has the highest weight for a given object, predicate and subject." ;
  rdfs:label "best subject viewer" ;
  rdfs:subClassOf swa:Functions ;
.
swa:bestSubjectWidgetClass
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "widgetClass" ;
          ]
        ) ;
      sp:where (
          (
            [
              a sp:NamedGraph ;
              sp:elements (
                  [
                    a sp:SubQuery ;
                    sp:query [
                        a sp:Select ;
                        sp:orderBy (
                            [
                              a sp:Desc ;
                              sp:expression [
                                  sp:varName "weight" ;
                                ] ;
                            ]
                          ) ;
                        sp:where (
                            [
                              sp:object [
                                  sp:varName "type" ;
                                ] ;
                              sp:predicate rdf:type ;
                              sp:subject [
                                  sp:varName "widgetClass" ;
                                ] ;
                            ]
                            [
                              sp:object [
                                  sp:varName "w" ;
                                ] ;
                              sp:predicate swa:subjectWidgetWeight ;
                              sp:subject [
                                  sp:varName "widgetClass" ;
                                ] ;
                            ]
                            [
                              sp:object [
                                  sp:varName "expression" ;
                                ] ;
                              sp:predicate swa:expression ;
                              sp:subject [
                                  sp:varName "w" ;
                                ] ;
                            ]
                            [
                              a sp:Bind ;
                              sp:expression [
                                  a sp:coalesce ;
                                  sp:arg1 [
                                      a spl:object ;
                                      sp:arg1 [
                                          sp:varName "w" ;
                                        ] ;
                                      sp:arg2 swa:weight ;
                                    ] ;
                                  sp:arg2 0 ;
                                ] ;
                              sp:variable [
                                  sp:varName "weight" ;
                                ] ;
                            ]
                          ) ;
                      ] ;
                  ]
                  [
                    a sp:Filter ;
                    sp:expression [
                        a spin:eval ;
                        sp:arg1 [
                            sp:varName "expression" ;
                          ] ;
                        sp:arg2 arg:objectType ;
                        sp:arg3 [
                            sp:varName "objectType" ;
                          ] ;
                        sp:arg4 arg:predicate ;
                        sp:arg5 [
                            sp:varName "predicate" ;
                          ] ;
                        sp:arg6 arg:subject ;
                        sp:arg7 [
                            sp:varName "subject" ;
                          ] ;
                      ] ;
                  ]
                ) ;
              sp:graphNameNode ui:graph ;
            ]
          )
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:subject ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject value." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:objectType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The object to get the widget type for." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:type ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The type that the widget class must have, e.g. swa:NodeEditorClass" ;
    ] ;
  spin:returnType swa:SubjectWidgetClass ;
  rdfs:comment "Walks through all SubjectWidget classes of a given type (?type) that declare a subjectWidgetWeight and returns the widget class that has the highest weight for a given node (?subject), predicate (?predicate), object type (?objectType). All arguments are optional, but not all will be empty. If the objectType and predicate are known, then also the ?range will be bound." ;
  rdfs:label "best subject widget class" ;
  rdfs:subClassOf swa:Functions ;
.
swa:blankNodeProperty
  a rdf:Property ;
  rdfs:comment "If set to true for a property, then SWA will assume that the values of this property are blank nodes and the life cycle of those nodes depends on the subject. SWA will edit them with swa:NestedObjectEditors." ;
  rdfs:domain rdf:Property ;
  rdfs:label "blank node property" ;
  rdfs:range xsd:boolean ;
  rdfs:subPropertyOf swa:systemProperty ;
.
swa:bnodeId
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a ui:encodeNode ;
                sp:arg1 [
                    sp:varName "bnode" ;
                  ] ;
                sp:arg2 true ;
              ] ;
            sp:variable [
                sp:varName "label" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a afn:substr ;
                sp:arg1 [
                    sp:varName "label" ;
                  ] ;
                sp:arg2 1 ;
                sp:arg3 [
                    a sp:sub ;
                    sp:arg1 [
                        a fn:string-length ;
                        sp:arg1 [
                            sp:varName "label" ;
                          ] ;
                      ] ;
                    sp:arg2 1 ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:bnode ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to get the id of." ;
    ] ;
  spin:private true ;
  spin:returnType xsd:string ;
  rdfs:comment "Gets the internal ID of a bnode, starting with @." ;
  rdfs:label "bnode id" ;
  rdfs:subClassOf swa:Functions ;
.
swa:canDeleteResource
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          (
            [
              a sp:Bind ;
              sp:expression [
                  a ui:currentQueryGraph ;
                ] ;
              sp:variable [
                  sp:varName "g" ;
                ] ;
            ]
          )
          [
            a sp:NamedGraph ;
            sp:elements (
                [
                  a sp:Filter ;
                  sp:expression [
                      a sp:not ;
                      sp:arg1 [
                          a swa:hasReadOnlyTriple ;
                          arg:resource [
                              sp:varName "resource" ;
                            ] ;
                        ] ;
                    ] ;
                ]
                [
                  a sp:Bind ;
                  sp:expression [
                      a ui:contextValue ;
                      sp:arg1 "swaCanDeleteResourceFunction" ;
                    ] ;
                  sp:variable [
                      sp:varName "function" ;
                    ] ;
                ]
                [
                  a sp:Filter ;
                  sp:expression [
                      a sp:or ;
                      sp:arg1 [
                          a sp:not ;
                          sp:arg1 [
                              a sp:bound ;
                              sp:arg1 [
                                  sp:varName "function" ;
                                ] ;
                            ] ;
                        ] ;
                      sp:arg2 [
                          a spif:invoke ;
                          sp:arg1 [
                              sp:varName "function" ;
                            ] ;
                          sp:arg2 [
                              sp:varName "resource" ;
                            ] ;
                        ] ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode [
                sp:varName "g" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to check." ;
    ] ;
  spin:private true ;
  spin:returnType xsd:boolean ;
  rdfs:comment """Checks whether a resource is used in at least one triple as subject or object, and this triple is read-only. This can be used to determine whether a resource can be (completely) deleted.

There is an escape mechanism that can be used to override the default behavior of this function from other SWA applications. Set the SWP context variable \"swaCanDeleteResourceFunction\" to point to a function URI that has the same signature like swa:canDeleteResource. If present, this will be performed as an additional test.""" ;
  rdfs:label "can delete resource" ;
  rdfs:subClassOf swa:Functions ;
.
swa:classHasSubClassOrDirectRelevantProperty
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            a sp:Union ;
            sp:elements (
                (
                  [
                    sp:object [
                        sp:varName "class" ;
                      ] ;
                    sp:predicate rdfs:subClassOf ;
                    sp:subject [
                        sp:varName "anySubClass" ;
                      ] ;
                  ]
                  [
                    a sp:Filter ;
                    sp:expression [
                        a sp:and ;
                        sp:arg1 [
                            a sp:ne ;
                            sp:arg1 [
                                sp:varName "anySubClass" ;
                              ] ;
                            sp:arg2 owl:NamedIndividual ;
                          ] ;
                        sp:arg2 [
                            a sp:ne ;
                            sp:arg1 [
                                sp:varName "anySubClass" ;
                              ] ;
                            sp:arg2 owl:Nothing ;
                          ] ;
                      ] ;
                  ]
                )
                (
                  [
                    sp:object [
                        sp:varName "anyProperty" ;
                      ] ;
                    sp:predicate swa:directRelevantClassOfProperty ;
                    sp:subject [
                        sp:varName "class" ;
                      ] ;
                  ]
                  [
                    a sp:Filter ;
                    sp:expression [
                        a sp:and ;
                        sp:arg1 [
                            a sp:and ;
                            sp:arg1 [
                                a sp:and ;
                                sp:arg1 [
                                    a sp:and ;
                                    sp:arg1 [
                                        a sp:and ;
                                        sp:arg1 [
                                            a sp:ne ;
                                            sp:arg1 [
                                                sp:varName "anyProperty" ;
                                              ] ;
                                            sp:arg2 owl:bottomObjectProperty ;
                                          ] ;
                                        sp:arg2 [
                                            a sp:ne ;
                                            sp:arg1 [
                                                sp:varName "anyProperty" ;
                                              ] ;
                                            sp:arg2 owl:topObjectProperty ;
                                          ] ;
                                      ] ;
                                    sp:arg2 [
                                        a sp:ne ;
                                        sp:arg1 [
                                            sp:varName "anyProperty" ;
                                          ] ;
                                        sp:arg2 owl:topDataProperty ;
                                      ] ;
                                  ] ;
                                sp:arg2 [
                                    a sp:ne ;
                                    sp:arg1 [
                                        sp:varName "anyProperty" ;
                                      ] ;
                                    sp:arg2 owl:bottomDataProperty ;
                                  ] ;
                              ] ;
                            sp:arg2 [
                                a sp:ne ;
                                sp:arg1 [
                                    sp:varName "anyProperty" ;
                                  ] ;
                                sp:arg2 owl:differentFrom ;
                              ] ;
                          ] ;
                        sp:arg2 [
                            a sp:ne ;
                            sp:arg1 [
                                sp:varName "anyProperty" ;
                              ] ;
                            sp:arg2 owl:sameAs ;
                          ] ;
                      ] ;
                  ]
                )
              ) ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:class ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class to check." ;
    ] ;
  spin:private true ;
  spin:returnType xsd:boolean ;
  rdfs:comment "A helper method needed by the Class-Property tree because a Jena bug prevents the use of a magic property within a BIND." ;
  rdfs:label "class has sub class or direct relevant property" ;
  rdfs:subClassOf swa:Functions ;
.
swa:containsCurrentModeName
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a swa:modeProperty ;
                arg:predicate swa:modeName ;
              ] ;
            sp:variable [
                sp:varName "currentModeName" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "?0" ;
              ] ;
            sp:predicate spif:split ;
            sp:subject [
                sp:varName "modeName" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "modeNames" ;
              ] ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "?0" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "?1" ;
              ] ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "?0" ;
              ] ;
          ]
          [
            sp:object "," ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "?1" ;
              ] ;
          ]
          [
            sp:object () ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "?1" ;
              ] ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:eq ;
                sp:arg1 [
                    sp:varName "currentModeName" ;
                  ] ;
                sp:arg2 [
                    sp:varName "modeName" ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:modeNames ;
      spl:valueType xsd:string ;
      rdfs:comment "A comma-separated list of name of the modes to match against." ;
    ] ;
  spin:private true ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether a given string of comma-separate mode names contains the name of the current mode. For example, swa:containsCurrentMode(\"search,edit\") will return true if the current mode is \"edit\"." ;
  rdfs:label "contains current mode name" ;
  rdfs:subClassOf swa:Functions ;
.
swa:contextValueIsTrue
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a ui:contextValue ;
                sp:arg1 [
                    sp:varName "varName" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "value" ;
              ] ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                sp:varName "value" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:varName ;
      spl:valueType xsd:string ;
      rdfs:comment "The variable name." ;
    ] ;
  spin:private true ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether a given context value has the value \"true\"." ;
  rdfs:label "context value is true" ;
  rdfs:subClassOf swa:Functions ;
.
swa:countSpaces
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:expression [
                a sp:Count ;
              ] ;
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "?0" ;
              ] ;
            sp:predicate spif:split ;
            sp:subject [
                sp:varName "s" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "string" ;
              ] ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "?0" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "?1" ;
              ] ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "?0" ;
              ] ;
          ]
          [
            sp:object " " ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "?1" ;
              ] ;
          ]
          [
            sp:object () ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "?1" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:string ;
      spl:valueType xsd:string ;
      rdfs:comment "The input string containing spaces." ;
    ] ;
  spin:private true ;
  spin:returnType xsd:integer ;
  rdfs:label "count spaces" ;
  rdfs:subClassOf spl:StringFunctions ;
.
swa:createDefaultLink
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "link" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a ui:currentQueryGraph ;
              ] ;
            sp:variable [
                sp:varName "baseURI" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a fn:concat ;
                sp:arg1 "swa.navigateTo('" ;
                sp:arg2 [
                    a xsd:string ;
                    sp:arg1 [
                        sp:varName "resource" ;
                      ] ;
                  ] ;
                sp:arg3 "', '" ;
                sp:arg4 [
                    a xsd:string ;
                    sp:arg1 [
                        sp:varName "baseURI" ;
                      ] ;
                  ] ;
                sp:arg5 "')" ;
              ] ;
            sp:variable [
                sp:varName "link" ;
              ] ;
          ]
        ) ;
    ] ;
  rdfs:comment "The default CreateLinkFunction - it simply navigates to the resource with a call of the SWP servlet." ;
  rdfs:label "create default link" ;
  rdfs:subClassOf swa:CreateLinkFunctions ;
.
swa:createEventLink
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          (
            [
              a sp:Bind ;
              sp:expression [
                  a ui:contextValue ;
                  sp:arg1 "createEventLinkEvent" ;
                ] ;
              sp:variable [
                  sp:varName "event" ;
                ] ;
            ]
            [
              a sp:Filter ;
              sp:expression [
                  a sp:bound ;
                  sp:arg1 [
                      sp:varName "event" ;
                    ] ;
                ] ;
            ]
          )
          [
            a sp:Bind ;
            sp:expression [
                a ui:contextValue ;
                sp:arg1 "canLinkBNodeFunction" ;
              ] ;
            sp:variable [
                sp:varName "bnodeFunction" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a swa:publishEvent ;
                arg:data [
                    a sp:concat ;
                    sp:arg1 "\"" ;
                    sp:arg2 [
                        a sp:if ;
                        sp:arg1 [
                            a sp:and ;
                            sp:arg1 [
                                a sp:isBlank ;
                                sp:arg1 [
                                    sp:varName "resource" ;
                                  ] ;
                              ] ;
                            sp:arg2 [
                                a sp:bound ;
                                sp:arg1 [
                                    sp:varName "bnodeFunction" ;
                                  ] ;
                              ] ;
                          ] ;
                        sp:arg2 [
                            a sp:if ;
                            sp:arg1 [
                                a spif:invoke ;
                                sp:arg1 [
                                    sp:varName "bnodeFunction" ;
                                  ] ;
                                sp:arg2 [
                                    sp:varName "resource" ;
                                  ] ;
                              ] ;
                            sp:arg2 [
                                a swa:unwrap ;
                                arg:string [
                                    a ui:encodeNode ;
                                    sp:arg1 [
                                        sp:varName "resource" ;
                                      ] ;
                                    sp:arg2 true ;
                                    sp:arg3 true ;
                                  ] ;
                              ] ;
                            sp:arg3 [
                                sp:varName "none" ;
                              ] ;
                          ] ;
                        sp:arg3 [
                            a sp:str ;
                            sp:arg1 [
                                sp:varName "resource" ;
                              ] ;
                          ] ;
                      ] ;
                    sp:arg3 "\"" ;
                  ] ;
                sp:arg1 [
                    sp:varName "event" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  rdfs:comment "A CreateLinkFunction that publishes the selected resource with an event. The name of the event must be specified in as the context variable \"createEventLinkEvent\"." ;
  rdfs:label "create event link" ;
  rdfs:subClassOf swa:CreateLinkFunctions ;
.
swa:createEventOrNewTabLink
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a sp:if ;
                sp:arg1 [
                    a sp:exists ;
                    sp:elements (
                        [
                          sp:object [
                              sp:varName "anyO" ;
                            ] ;
                          sp:predicate [
                              sp:varName "anyP" ;
                            ] ;
                          sp:subject [
                              sp:varName "resource" ;
                            ] ;
                        ]
                      ) ;
                  ] ;
                sp:arg2 [
                    a swa:createEventLink ;
                    arg:resource [
                        sp:varName "resource" ;
                      ] ;
                  ] ;
                sp:arg3 [
                    a swa:createNewTabLink ;
                    arg:resource [
                        sp:varName "resource" ;
                      ] ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  rdfs:comment "Depending on whether the given resource has any properties, it will either publish an event to navigate to the resource or open a new browser tab with the given URL for external resources." ;
  rdfs:label "create event or new tab link" ;
  rdfs:subClassOf swa:CreateLinkFunctions ;
.
swa:createHRef
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a ui:contextValue ;
                sp:arg1 "createHRefFunction" ;
              ] ;
            sp:variable [
                sp:varName "function" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:if ;
                sp:arg1 [
                    a sp:bound ;
                    sp:arg1 [
                        sp:varName "function" ;
                      ] ;
                  ] ;
                sp:arg2 [
                    a spif:invoke ;
                    sp:arg1 [
                        sp:varName "function" ;
                      ] ;
                    sp:arg2 [
                        sp:varName "resource" ;
                      ] ;
                  ] ;
                sp:arg3 [
                    sp:varName "none" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  rdfs:comment "Creates a URL an <a href=\"...\"> to navigate to another resource (see swa:createLink for use in onclick=\"...\" attributes). The function checks if the context variable \"createHRefFunction\" points to another SPIN function. If so, then it calls that SPIN function with the given resource argument. Otherwise it returns nothing, and surrounding code should fall back swa:createLink to produce an onclick attribute. If you want to replace the default behavior, create your own subclass of swa:CreateHRefFunctions, and then use ui:setContext to activate this function for the contained elements." ;
  rdfs:label "create href" ;
  rdfs:subClassOf swa:CreateHRefFunctions ;
.
swa:createLink
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "link" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a ui:contextValue ;
                sp:arg1 "createLinkFunction" ;
              ] ;
            sp:variable [
                sp:varName "createLinkFunction" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:if ;
                sp:arg1 [
                    a sp:bound ;
                    sp:arg1 [
                        sp:varName "createLinkFunction" ;
                      ] ;
                  ] ;
                sp:arg2 [
                    a spif:invoke ;
                    sp:arg1 [
                        sp:varName "createLinkFunction" ;
                      ] ;
                    sp:arg2 [
                        sp:varName "resource" ;
                      ] ;
                    sp:arg3 [
                        sp:varName "uid" ;
                      ] ;
                  ] ;
                sp:arg3 [
                    a swa:createDefaultLink ;
                    arg:resource [
                        sp:varName "resource" ;
                      ] ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "link" ;
              ] ;
          ]
        ) ;
    ] ;
  rdfs:comment "Creates a line of JavaScript code that can be inserted into an HTML document to produce a hyper link that can be used for onclick events (see swa:createHRef for use in <a href=\"...\" tags). The implementation of this function is very flexible and can be replaced depending on the context. The function checks if the context variable \"createLinkFunction\" points to another SPIN function. If so, then it calls that SPIN function with the given resource and uid arguments. Otherwise, it falls back to the built-in swa:createDefaultLink function that calls swa.navigateTo. If you want to replace the default behavior, create your own subclass of swa:CreateLinkFunctions, and then use ui:setContext to activate this link function for the contained elements." ;
  rdfs:label "create link" ;
  rdfs:subClassOf swa:CreateLinkFunctions ;
.
swa:createLoadSearchFormCall
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:expression [
                a fn:concat ;
                sp:arg1 "swa.loadSearchForm('" ;
                sp:arg10 [
                    a ui:currentQueryGraph ;
                  ] ;
                sp:arg11 "'" ;
                sp:arg12 [
                    sp:varName "nb" ;
                  ] ;
                sp:arg13 ")" ;
                sp:arg2 [
                    sp:varName "oldElementId" ;
                  ] ;
                sp:arg3 "', '" ;
                sp:arg4 [
                    sp:varName "resultsId" ;
                  ] ;
                sp:arg5 "', " ;
                sp:arg6 [
                    sp:varName "resourceTypeCode" ;
                  ] ;
                sp:arg7 ", '" ;
                sp:arg8 [
                    sp:varName "queryGraph" ;
                  ] ;
                sp:arg9 "', '" ;
              ] ;
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a sp:if ;
                sp:arg1 [
                    sp:varName "noBorder" ;
                  ] ;
                sp:arg2 ", true" ;
                sp:arg3 [
                    sp:varName "none" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "nb" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:queryGraph ;
      spl:valueType owl:Ontology ;
      rdfs:comment "The schema graph." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:noBorder ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to set the noBorder flag." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:oldElementId ;
      spl:valueType xsd:string ;
      rdfs:comment "The id of the element to replace." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resourceTypeCode ;
      spl:valueType xsd:string ;
      rdfs:comment "A JavaScript expression that produces the URI of the resource type. When used in a Tree, this would be 'resource', while in other cases it might be a static URI string." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resultsId ;
      spl:valueType xsd:string ;
      rdfs:comment "The results id." ;
    ] ;
  spin:private true ;
  rdfs:label "create load search form call" ;
  rdfs:subClassOf swa:CreateCallFunctions ;
.
swa:createNewTabLink
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a sp:concat ;
                sp:arg1 "window.open('" ;
                sp:arg2 [
                    a xsd:string ;
                    sp:arg1 [
                        sp:varName "resource" ;
                      ] ;
                  ] ;
                sp:arg3 "', '_blank')" ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  rdfs:comment "Creates a link that opens the resource in a new tab or window." ;
  rdfs:label "create new tab link" ;
  rdfs:subClassOf swa:CreateLinkFunctions ;
.
swa:createNoLink
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "nothing" ;
          ]
        ) ;
      sp:where () ;
    ] ;
  rdfs:comment "A dummy function that returns nothing, suppressing any links." ;
  rdfs:label "create no link" ;
  rdfs:subClassOf swa:CreateLinkFunctions ;
.
swa:createPrimaryKeyTriple
  a ui:Operation ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The resource type." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:uri ;
      spl:valueType xsd:string ;
      rdfs:comment "The URI of the new instance." ;
    ] ;
  ui:prototype """
<ui:if ui:condition=\"{= swa:hasPrimaryKey(?resourceType) }\">
    <ui:update ui:updateQuery=\"{!
            INSERT {
                ?resource ?property ?primaryKey .
            }
            WHERE {
                BIND (swa:primaryKeyProperty(?resourceType) AS ?property) .
                BIND (swa:primaryKeyURIStart(?resourceType) AS ?uriStart) .
                BIND (SUBSTR(str(?uri), (STRLEN(?uriStart) + 1)) AS ?encoded) .
                BIND (spif:decodeURL(?encoded) AS ?lex) .
                BIND (swa:localRangeAtClass(?resourceType, ?property) AS ?range) .
                BIND (STRDT(?lex, ?range) AS ?primaryKey) .
                BIND (IRI(str(?uri)) AS ?resource) .
            } }\"/>
</ui:if>
"""^^ui:Literal ;
  rdfs:comment "Implements support swa:CreateHandlers to set the primary key triple if a suitable spl:PrimaryKeyPropertyConstraint exists." ;
  rdfs:label "create primary key triple" ;
  rdfs:subClassOf ui:Operations ;
.
swa:createResourceDialogPluginWeight
  a rdf:Property ;
  rdfs:comment """Points to one or more weighted expressions that are evaluated to find the most suitable plugin for the given context. In the expressions, you can query the following pre-bound variables:
- ?appName: the name of the surrounding application (optional)
- ?resourceType: the type of the resource to create
- ?contextResource: the context resource (optional)""" ;
  rdfs:domain swa:CreateResourceDialogPlugin ;
  rdfs:label "create resource dialog plugin weight" ;
  rdfs:range swa:WeightedExpression ;
.
swa:createViewDialogLink
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a sp:concat ;
                sp:arg1 "swa.closeDialog('swaTheViewResourceDialog');swa.openViewResourceDialog(\"" ;
                sp:arg2 [
                    a sp:str ;
                    sp:arg1 [
                        sp:varName "resource" ;
                      ] ;
                  ] ;
                sp:arg3 "\")" ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  rdfs:comment "Creates a link that opens the resource in a the current view dialog." ;
  rdfs:label "create view dialog link" ;
  rdfs:subClassOf swa:CreateLinkFunctions ;
.
swa:currentWindowId
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "id" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Union ;
            sp:elements (
                (
                  [
                    a sp:NamedGraph ;
                    sp:elements (
                        (
                          (
                            [
                              a sp:Bind ;
                              sp:expression [
                                  a ui:nearestViewWithType ;
                                  arg:type swa:Window ;
                                ] ;
                              sp:variable [
                                  sp:varName "window" ;
                                ] ;
                            ]
                          )
                          [
                            a sp:Filter ;
                            sp:expression [
                                a sp:bound ;
                                sp:arg1 [
                                    sp:varName "window" ;
                                  ] ;
                              ] ;
                          ]
                        )
                        [
                          a sp:Bind ;
                          sp:expression [
                              a spl:object ;
                              sp:arg1 [
                                  sp:varName "window" ;
                                ] ;
                              sp:arg2 arg:id ;
                            ] ;
                          sp:variable [
                              sp:varName "id" ;
                            ] ;
                        ]
                      ) ;
                    sp:graphNameNode ui:graph ;
                  ]
                  [
                    a sp:Filter ;
                    sp:expression [
                        a sp:bound ;
                        sp:arg1 [
                            sp:varName "id" ;
                          ] ;
                      ] ;
                  ]
                )
                (
                  (
                    [
                      a sp:Bind ;
                      sp:expression [
                          a ui:param ;
                          arg:name "id" ;
                        ] ;
                      sp:variable [
                          sp:varName "p" ;
                        ] ;
                    ]
                    [
                      a sp:Filter ;
                      sp:expression [
                          a sp:bound ;
                          sp:arg1 [
                              sp:varName "p" ;
                            ] ;
                        ] ;
                    ]
                  )
                  [
                    a sp:Bind ;
                    sp:expression [
                        a sp:substr ;
                        sp:arg1 [
                            sp:varName "p" ;
                          ] ;
                        sp:arg2 2 ;
                        sp:arg3 [
                            a sp:sub ;
                            sp:arg1 [
                                a sp:strlen ;
                                sp:arg1 [
                                    sp:varName "p" ;
                                  ] ;
                              ] ;
                            sp:arg2 2 ;
                          ] ;
                      ] ;
                    sp:variable [
                        sp:varName "id" ;
                      ] ;
                  ]
                )
              ) ;
          ]
        ) ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "If called within an swa:Window, this gets the id of the surrounding window." ;
  rdfs:label "current window id" ;
  rdfs:subClassOf swa:Functions ;
.
swa:customLanguages
  a rdf:Property ;
  rdfs:comment "Can be used to override the default languages in a TBL installation. Value format is the same as swa:defaultLanguages." ;
  rdfs:domain swa:LangSelector ;
  rdfs:label "custom languages" ;
  rdfs:range xsd:string ;
.
swa:datatypeIcon
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a sp:coalesce ;
                sp:arg1 [
                    a spl:objectInGraph ;
                    sp:arg1 [
                        sp:varName "datatype" ;
                      ] ;
                    sp:arg2 swa:datatypeIconCSS ;
                    sp:arg3 ui:graph ;
                  ] ;
                sp:arg2 "swa-icon-literal" ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:cachable true ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:datatype ;
      spl:valueType rdfs:Datatype ;
      rdfs:comment "The rdfs:Datatype." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Gets the \"most suitable\" icon for a datatype, relying on triples attached to the datatype resource in the ui:graph." ;
  rdfs:label "datatype icon" ;
  rdfs:subClassOf swa:Functions ;
.
swa:datatypeIconCSS
  a rdf:Property ;
  rdfs:comment "Can be attached to datatypes (e.g. xsd:string) to point to the CSS style of an icon representing it. These triples are used by the swa:datatypeIcon function. Note that the swa:datatypeIconCSS triples must be stored in a globally registered SWP graph, ending with .ui.*." ;
  rdfs:domain rdfs:Datatype ;
  rdfs:label "datatype icon CSS" ;
  rdfs:range xsd:string ;
  rdfs:subPropertyOf swa:systemProperty ;
.
swa:defaultLanguages
  a rdf:Property ;
  rdfs:comment "Contains the list of default languages to be used in the lang selector." ;
  rdfs:label "default languages" ;
  rdfs:range xsd:string ;
.
swa:delete
  a rdf:Property ;
  rdfs:label "delete" ;
  rdfs:subPropertyOf swa:systemProperty ;
.
swa:deleteTriplesFromNamedGraph
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:sourceGraph ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The named graph containing the triples to delete." ;
    ] ;
  ui:prototype """
<ui:update ui:updateQuery=\"{!
        DELETE {
            GRAPH ?targetGraph {
                ?s ?p ?o .
            } .
        }
        WHERE {
            GRAPH ?sourceGraph {
                ?s ?p ?o .
            } .
        } }\"/>
"""^^ui:Literal ;
  rdfs:label "delete triples from named graph" ;
  rdfs:subClassOf swa:GraphOperations ;
.
swa:description
  a rdf:Property ;
  rdfs:comment "Serves as super-property of properties containing a description or summary of the subject resource." ;
  rdfs:label "description" ;
  rdfs:range xsd:string ;
.
swa:dynamicEnumRangeTriggerPropertiesList
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:orderBy (
          [
            sp:varName "label" ;
          ]
        ) ;
      sp:resultVariables (
          [
            sp:expression [
                a sp:GroupConcat ;
                sp:expression [
                    sp:varName "uri" ;
                  ] ;
                sp:separator " " ;
              ] ;
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "trigger" ;
              ] ;
            sp:predicate spl:dynamicEnumRangeTrigger ;
            sp:subject [
                sp:varName "property" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a xsd:string ;
                sp:arg1 [
                    sp:varName "trigger" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "uri" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property that has the dynamicEnumRange." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Builds a space-separated list of all known trigger properties of a given dynamic enum range property." ;
  rdfs:label "dynamic enum range trigger properties list" ;
  rdfs:subClassOf swa:Functions ;
.
swa:expression
  a rdf:Property ;
  rdfs:domain swa:WeightedExpression ;
  rdfs:label "expression" ;
  rdfs:range xsd:boolean ;
  rdfs:subPropertyOf swa:systemProperty ;
.
swa:facetSearchType
  a rdf:Property ;
  rdfs:comment "The sub-type(s) of search:FacetValue that this facet class is suitable for. For example swa:AnyObjectFacet is responsible for search:AnyFacetValue." ;
  rdfs:domain swa:ObjectFacetClass ;
  rdfs:label "facet search type" ;
  rdfs:range rdfs:Class ;
  rdfs:subPropertyOf swa:systemProperty ;
.
swa:filterAllSystemResources
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            a sp:Filter ;
            sp:expression [
                a sp:isIRI ;
                sp:arg1 [
                    sp:varName "node" ;
                  ] ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a afn:namespace ;
                sp:arg1 [
                    sp:varName "node" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "ns" ;
              ] ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:and ;
                sp:arg1 [
                    a sp:and ;
                    sp:arg1 [
                        a sp:and ;
                        sp:arg1 [
                            a sp:and ;
                            sp:arg1 [
                                a sp:and ;
                                sp:arg1 [
                                    a sp:and ;
                                    sp:arg1 [
                                        a sp:and ;
                                        sp:arg1 [
                                            a sp:and ;
                                            sp:arg1 [
                                                a sp:and ;
                                                sp:arg1 [
                                                    a sp:ne ;
                                                    sp:arg1 [
                                                        sp:varName "ns" ;
                                                      ] ;
                                                    sp:arg2 "http://www.w3.org/2000/01/rdf-schema#" ;
                                                  ] ;
                                                sp:arg2 [
                                                    a sp:ne ;
                                                    sp:arg1 [
                                                        sp:varName "ns" ;
                                                      ] ;
                                                    sp:arg2 "http://www.w3.org/1999/02/22-rdf-syntax-ns#" ;
                                                  ] ;
                                              ] ;
                                            sp:arg2 [
                                                a sp:ne ;
                                                sp:arg1 [
                                                    sp:varName "ns" ;
                                                  ] ;
                                                sp:arg2 "http://www.w3.org/2002/07/owl#" ;
                                              ] ;
                                          ] ;
                                        sp:arg2 [
                                            a sp:ne ;
                                            sp:arg1 [
                                                sp:varName "ns" ;
                                              ] ;
                                            sp:arg2 "http://www.w3.org/2001/XMLSchema#" ;
                                          ] ;
                                      ] ;
                                    sp:arg2 [
                                        a sp:ne ;
                                        sp:arg1 [
                                            sp:varName "ns" ;
                                          ] ;
                                        sp:arg2 "http://www.w3.org/ns/shacl#" ;
                                      ] ;
                                  ] ;
                                sp:arg2 [
                                    a sp:ne ;
                                    sp:arg1 [
                                        sp:varName "ns" ;
                                      ] ;
                                    sp:arg2 "http://spinrdf.org/sp#" ;
                                  ] ;
                              ] ;
                            sp:arg2 [
                                a sp:ne ;
                                sp:arg1 [
                                    sp:varName "ns" ;
                                  ] ;
                                sp:arg2 "http://spinrdf.org/spin#" ;
                              ] ;
                          ] ;
                        sp:arg2 [
                            a sp:ne ;
                            sp:arg1 [
                                sp:varName "ns" ;
                              ] ;
                            sp:arg2 "http://topbraid.org/imported#" ;
                          ] ;
                      ] ;
                    sp:arg2 [
                        a sp:ne ;
                        sp:arg1 [
                            sp:varName "ns" ;
                          ] ;
                        sp:arg2 "http://topbraid.org/tosh#" ;
                      ] ;
                  ] ;
                sp:arg2 [
                    a sp:ne ;
                    sp:arg1 [
                        sp:varName "ns" ;
                      ] ;
                    sp:arg2 "http://datashapes.org/dash#" ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  rdfs:comment "Filters out all resources from the RDF, RDFS, OWL, XSD, SHACL, SP, SPIN , TOSH, DASH and IMPORTED namespaces." ;
  rdfs:label "filter all system resources" ;
  rdfs:subClassOf swa:FilterFunctions ;
.
swa:filterClassesWithoutInstances
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            a sp:TriplePath ;
            sp:object [
                sp:varName "node" ;
              ] ;
            sp:path [
                a sp:ModPath ;
                sp:modMax -2 ;
                sp:modMin 0 ;
                sp:subPath rdfs:subClassOf ;
              ] ;
            sp:subject [
                sp:varName "type" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "type" ;
              ] ;
            sp:predicate rdf:type ;
            sp:subject [
                sp:varName "someInstance" ;
              ] ;
          ]
        ) ;
    ] ;
  rdfs:comment "Filters out any resource that is not the object of at least one rdf:type triple (or has a subclass with instances)." ;
  rdfs:label "filter classes without instances" ;
  rdfs:subClassOf swa:FilterFunctions ;
.
swa:filterSubclassesOfRoot
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            a sp:TriplePath ;
            sp:object [
                sp:varName "root" ;
              ] ;
            sp:path [
                a sp:ModPath ;
                sp:modMax -2 ;
                sp:modMin 0 ;
                sp:subPath rdfs:subClassOf ;
              ] ;
            sp:subject [
                sp:varName "node" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:root ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The root of the class tree." ;
    ] ;
  rdfs:label "filter subclasses of root" ;
  rdfs:subClassOf swa:FilterFunctions ;
.
swa:filterSubclassesOfRootAndExcludeViewpointClasses
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            a sp:TriplePath ;
            sp:object [
                sp:varName "root" ;
              ] ;
            sp:path [
                a sp:ModPath ;
                sp:modMax -2 ;
                sp:modMin 0 ;
                sp:subPath rdfs:subClassOf ;
              ] ;
            sp:subject [
                sp:varName "node" ;
              ] ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:notExists ;
                sp:elements (
                    [
                      sp:object edg:ViewpointClass ;
                      sp:predicate rdf:type ;
                      sp:subject [
                          sp:varName "node" ;
                        ] ;
                    ]
                  ) ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:root ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The root of the class tree." ;
    ] ;
  rdfs:label "filter subclasses of root and exclude viewpoint classes" ;
  rdfs:subClassOf swa:FilterFunctions ;
.
swa:filterSystemResources
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            a sp:Filter ;
            sp:expression [
                a sp:isIRI ;
                sp:arg1 [
                    sp:varName "node" ;
                  ] ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a afn:namespace ;
                sp:arg1 [
                    sp:varName "node" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "ns" ;
              ] ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:and ;
                sp:arg1 [
                    a sp:and ;
                    sp:arg1 [
                        a sp:and ;
                        sp:arg1 [
                            a sp:ne ;
                            sp:arg1 [
                                sp:varName "ns" ;
                              ] ;
                            sp:arg2 "http://www.w3.org/2000/01/rdf-schema#" ;
                          ] ;
                        sp:arg2 [
                            a sp:ne ;
                            sp:arg1 [
                                sp:varName "ns" ;
                              ] ;
                            sp:arg2 "http://www.w3.org/1999/02/22-rdf-syntax-ns#" ;
                          ] ;
                      ] ;
                    sp:arg2 [
                        a sp:ne ;
                        sp:arg1 [
                            sp:varName "ns" ;
                          ] ;
                        sp:arg2 "http://www.w3.org/2002/07/owl#" ;
                      ] ;
                  ] ;
                sp:arg2 [
                    a sp:ne ;
                    sp:arg1 [
                        sp:varName "ns" ;
                      ] ;
                    sp:arg2 "http://www.w3.org/2001/XMLSchema#" ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  rdfs:comment "Filters out any resources from the RDF, RDFS, OWL or XSD namespaces." ;
  rdfs:label "filter system resources" ;
  rdfs:subClassOf swa:FilterFunctions ;
.
swa:formClass
  a rdf:Property ;
  rdfs:comment "Links a mode with a form class." ;
  rdfs:domain swa:Mode ;
  rdfs:label "form class" ;
  rdfs:range swa:FormClass ;
  rdfs:subPropertyOf swa:systemProperty ;
.
swa:formObjectPredicateSelectionTemplate
  a rdf:Property ;
  rdfs:comment "The SPIN template that delivers the predicates that shall be displayed on a (default) form in this mode. For example, in editing mode this will include all suitable predicates, while in viewing mode this may only include the used predicates for the given subject." ;
  rdfs:domain swa:Mode ;
  rdfs:label "form object predicate selection template" ;
  rdfs:range spin:Template ;
  rdfs:subPropertyOf swa:systemProperty ;
.
swa:formSubjectPredicateSelectionTemplate
  a rdf:Property ;
  rdfs:comment "The SPIN template that delivers the predicates that shall be displayed on a (default) form in this mode. For example, in editing mode this will include all suitable predicates, while in viewing mode this may only include the used predicates for the given subject." ;
  rdfs:domain swa:Mode ;
  rdfs:label "form subject predicate selection template" ;
  rdfs:range spin:Template ;
  rdfs:subPropertyOf swa:systemProperty ;
.
swa:fullTextSearchPropertiesConcat
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:orderBy (
          [
            sp:varName "property" ;
          ]
        ) ;
      sp:resultVariables (
          [
            sp:expression [
                a sp:GroupConcat ;
                sp:expression [
                    sp:varName "str" ;
                  ] ;
              ] ;
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            a sp:TriplePath ;
            sp:object [
                sp:varName "type" ;
              ] ;
            sp:path [
                a sp:ModPath ;
                sp:modMax -2 ;
                sp:modMin 0 ;
                sp:subPath rdfs:subClassOf ;
              ] ;
            sp:subject [
                sp:varName "subClass" ;
              ] ;
          ]
          [
            a sp:NamedGraph ;
            sp:elements (
                [
                  sp:object [
                      sp:varName "property" ;
                    ] ;
                  sp:predicate swa:fullTextSearchProperty ;
                  sp:subject [
                      sp:varName "type" ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode ui:graph ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:concat ;
                sp:arg1 "<" ;
                sp:arg2 [
                    a xsd:string ;
                    sp:arg1 [
                        sp:varName "property" ;
                      ] ;
                  ] ;
                sp:arg3 "> " ;
              ] ;
            sp:variable [
                sp:varName "str" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:private true ;
  spin:returnType xsd:string ;
  rdfs:label "full text search properties concat" ;
  rdfs:subClassOf swa:FullTextSearchFunctions ;
.
swa:fullTextSearchProperty
  a rdf:Property ;
  rdfs:comment "Links a class with one or more properties that shall be searched in full text mode. If the class shown on a SearchForm (or one of its superclasses) define at least one fullTextSearchProperty then a special full text search section will appear on top of the search form. When sent off to the server, this will be regex'ed by the search engine across all the mentioned properties. Usually, the values of this property are (datatype) properties with xsd:string or rdf:HTML as their range." ;
  rdfs:domain rdfs:Class ;
  rdfs:label "full text search properties" ;
  rdfs:range rdf:Property ;
  rdfs:subPropertyOf swa:systemProperty ;
.
swa:genericTreeChild
  a spin:MagicProperty ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "child" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Union ;
            sp:elements (
                (
                  (
                    (
                      [
                        a sp:Bind ;
                        sp:expression [
                            a ui:contextValue ;
                            sp:arg1 "swaGenericTreeProperty" ;
                          ] ;
                        sp:variable [
                            sp:varName "property" ;
                          ] ;
                      ]
                      [
                        a sp:Bind ;
                        sp:expression [
                            a sp:coalesce ;
                            sp:arg1 [
                                a ui:contextValue ;
                                sp:arg1 "swaGenericTreeInverse" ;
                              ] ;
                            sp:arg2 false ;
                          ] ;
                        sp:variable [
                            sp:varName "inverse" ;
                          ] ;
                      ]
                    )
                    [
                      a sp:Filter ;
                      sp:expression [
                          a sp:not ;
                          sp:arg1 [
                              sp:varName "inverse" ;
                            ] ;
                        ] ;
                    ]
                  )
                  [
                    sp:object spin:_arg1 ;
                    sp:predicate rdf:first ;
                    sp:subject [
                        sp:varName "?0" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "?1" ;
                      ] ;
                    sp:predicate rdf:rest ;
                    sp:subject [
                        sp:varName "?0" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "property" ;
                      ] ;
                    sp:predicate rdf:first ;
                    sp:subject [
                        sp:varName "?1" ;
                      ] ;
                  ]
                  [
                    sp:object () ;
                    sp:predicate rdf:rest ;
                    sp:subject [
                        sp:varName "?1" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "child" ;
                      ] ;
                    sp:predicate spif:evalPath ;
                    sp:subject [
                        sp:varName "?0" ;
                      ] ;
                  ]
                )
                (
                  (
                    (
                      [
                        a sp:Bind ;
                        sp:expression [
                            a ui:contextValue ;
                            sp:arg1 "swaGenericTreeProperty" ;
                          ] ;
                        sp:variable [
                            sp:varName "property" ;
                          ] ;
                      ]
                      [
                        a sp:Bind ;
                        sp:expression [
                            a sp:coalesce ;
                            sp:arg1 [
                                a ui:contextValue ;
                                sp:arg1 "swaGenericTreeInverse" ;
                              ] ;
                            sp:arg2 false ;
                          ] ;
                        sp:variable [
                            sp:varName "inverse" ;
                          ] ;
                      ]
                    )
                    [
                      a sp:Filter ;
                      sp:expression [
                          sp:varName "inverse" ;
                        ] ;
                    ]
                  )
                  [
                    sp:object [
                        sp:varName "child" ;
                      ] ;
                    sp:predicate rdf:first ;
                    sp:subject [
                        sp:varName "?2" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "?3" ;
                      ] ;
                    sp:predicate rdf:rest ;
                    sp:subject [
                        sp:varName "?2" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "property" ;
                      ] ;
                    sp:predicate rdf:first ;
                    sp:subject [
                        sp:varName "?3" ;
                      ] ;
                  ]
                  [
                    sp:object () ;
                    sp:predicate rdf:rest ;
                    sp:subject [
                        sp:varName "?3" ;
                      ] ;
                  ]
                  [
                    sp:object spin:_arg1 ;
                    sp:predicate spif:evalPath ;
                    sp:subject [
                        sp:varName "?2" ;
                      ] ;
                  ]
                )
              ) ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The node to get the children of." ;
    ] ;
  spin:private true ;
  spin:returnType rdfs:Resource ;
  rdfs:comment """Gets the children of a given node (left side) in a generic tree, based on context variables. Can also be used in the other direction, with the child given and the parent node as variable.

Note that this magic property uses spif:evalPath because this also supports magic properties to fetch the values.""" ;
  rdfs:label "generic tree child" ;
  rdfs:subClassOf spin:MagicProperties ;
.
swa:getGadgetFromLabel
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "gadget" ;
          ]
        ) ;
      sp:where (
          [
            a sp:NamedGraph ;
            sp:elements (
                [
                  sp:object swa:Gadget ;
                  sp:predicate rdf:type ;
                  sp:subject [
                      sp:varName "gadget" ;
                    ] ;
                ]
                [
                  sp:object [
                      sp:varName "gadgetLabel" ;
                    ] ;
                  sp:predicate rdfs:label ;
                  sp:subject [
                      sp:varName "gadget" ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode ui:graph ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:gadgetLabel ;
      spl:valueType xsd:string ;
      rdfs:comment "rdfs:label for gadget" ;
    ] ;
  spin:private true ;
  spin:returnType swa:Gadget ;
  rdfs:label "Gadget from Label" ;
  rdfs:subClassOf swa:Functions ;
.
swa:getKeyProperties
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "keyProperties" ;
          ]
        ) ;
      sp:where (
          [
            a sp:NamedGraph ;
            sp:elements (
                [
                  a sp:Bind ;
                  sp:expression [
                      a spif:walkObjects ;
                      sp:arg1 [
                          sp:varName "class" ;
                        ] ;
                      sp:arg2 rdfs:subClassOf ;
                      sp:arg3 swa:keyPropertiesFunctor ;
                    ] ;
                  sp:variable [
                      sp:varName "keyProperties" ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode ui:unionGraph ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:class ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class to start traversal at." ;
    ] ;
  spin:private true ;
  spin:returnType rdf:List ;
  rdfs:comment "Gets the key properties of a given class, by walking up the superclasses until it finds a class with declared swa:keyProperties." ;
  rdfs:label "get key properties" ;
  rdfs:subClassOf swa:Functions ;
.
swa:getLanguagesList
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "langs" ;
          ]
        ) ;
      sp:where (
          [
            a sp:NamedGraph ;
            sp:elements (
                [
                  a sp:Bind ;
                  sp:expression [
                      a sp:coalesce ;
                      sp:arg1 [
                          a spl:object ;
                          sp:arg1 swa:LangSelector ;
                          sp:arg2 swa:customLanguages ;
                        ] ;
                      sp:arg2 [
                          a spl:object ;
                          sp:arg1 swa:LangSelector ;
                          sp:arg2 swa:defaultLanguages ;
                        ] ;
                    ] ;
                  sp:variable [
                      sp:varName "langs" ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode ui:graph ;
          ]
        ) ;
    ] ;
  spin:private true ;
  spin:returnType xsd:string ;
  rdfs:label "get languages list" ;
  rdfs:subClassOf swa:Functions ;
.
swa:getThumbnail
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            a sp:NamedGraph ;
            sp:elements (
                [
                  a sp:TriplePath ;
                  sp:object swa:thumbnail ;
                  sp:path [
                      a sp:ModPath ;
                      sp:modMax -2 ;
                      sp:modMin 0 ;
                      sp:subPath rdfs:subPropertyOf ;
                    ] ;
                  sp:subject [
                      sp:varName "property" ;
                    ] ;
                ]
                [
                  sp:object [
                      sp:varName "image" ;
                    ] ;
                  sp:predicate [
                      sp:varName "property" ;
                    ] ;
                  sp:subject [
                      sp:varName "resource" ;
                    ] ;
                ]
                [
                  a sp:Filter ;
                  sp:expression [
                      a sp:not ;
                      sp:arg1 [
                          a sp:isBlank ;
                          sp:arg1 [
                              sp:varName "image" ;
                            ] ;
                        ] ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode ui:unionGraph ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:if ;
                sp:arg1 [
                    a sp:isIRI ;
                    sp:arg1 [
                        sp:varName "image" ;
                      ] ;
                  ] ;
                sp:arg2 [
                    sp:varName "image" ;
                  ] ;
                sp:arg3 [
                    a sp:iri ;
                    sp:arg1 [
                        sp:varName "image" ;
                      ] ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to get the image for." ;
    ] ;
  spin:returnType rdfs:Resource ;
  rdfs:comment "Gets the \"summary image\" for a given resource. This will try to find a value for one of the sub-properties of swa:thumbnail." ;
  rdfs:label "get thumbnail" ;
  rdfs:subClassOf swa:Functions ;
.
swa:hasExcludedAppName
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            a sp:Filter ;
            sp:expression [
                a sp:bound ;
                sp:arg1 [
                    sp:varName "appName" ;
                  ] ;
              ] ;
          ]
          [
            a sp:NamedGraph ;
            sp:elements (
                [
                  sp:object [
                      sp:varName "appName" ;
                    ] ;
                  sp:predicate arg:excludedAppName ;
                  sp:subject [
                      sp:varName "action" ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode ui:graph ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:appName ;
      spl:valueType xsd:string ;
      rdfs:comment "The appName to test (may be unbound)." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:action ;
      spl:valueType swa:Action ;
      rdfs:comment "The swa:Action to check." ;
    ] ;
  spin:private true ;
  spin:returnType xsd:boolean ;
  rdfs:label "has excluded app name" ;
  rdfs:subClassOf swa:Functions ;
.
swa:hasFullTextSearchProperty
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            a sp:TriplePath ;
            sp:object [
                sp:varName "type" ;
              ] ;
            sp:path [
                a sp:ModPath ;
                sp:modMax -2 ;
                sp:modMin 0 ;
                sp:subPath rdfs:subClassOf ;
              ] ;
            sp:subject [
                sp:varName "subClass" ;
              ] ;
          ]
          [
            a sp:NamedGraph ;
            sp:elements (
                [
                  sp:object [
                      sp:varName "any" ;
                    ] ;
                  sp:predicate swa:fullTextSearchProperty ;
                  sp:subject [
                      sp:varName "type" ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode ui:graph ;
          ]
        ) ;
    ] ;
  spin:private true ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether a given class or its superclasses have declared any values of swa:fullTextSearchProperty." ;
  rdfs:label "has full text search property" ;
  rdfs:subClassOf swa:FullTextSearchFunctions ;
.
swa:hasKeyProperty
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          (
            [
              a sp:Bind ;
              sp:expression [
                  a swa:getKeyProperties ;
                  arg:class [
                      sp:varName "class" ;
                    ] ;
                ] ;
              sp:variable [
                  sp:varName "k" ;
                ] ;
            ]
            [
              a sp:Filter ;
              sp:expression [
                  a sp:bound ;
                  sp:arg1 [
                      sp:varName "k" ;
                    ] ;
                ] ;
            ]
          )
          [
            a sp:NamedGraph ;
            sp:elements (
                [
                  sp:object [
                      sp:varName "property" ;
                    ] ;
                  sp:predicate list:member ;
                  sp:subject [
                      sp:varName "k" ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode ui:unionGraph ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:class ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class to check." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property to check." ;
    ] ;
  spin:private true ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks if a given property is a key property of a given class." ;
  rdfs:label "has key property" ;
  rdfs:subClassOf swa:Functions ;
.
swa:hasMatchingInverseRestoreFacetValue
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a swa:restoreInverseFacetValue ;
                arg:property [
                    sp:varName "property" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "facetValue" ;
              ] ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:or ;
                sp:arg1 [
                    a sp:not ;
                    sp:arg1 [
                        a sp:bound ;
                        sp:arg1 [
                            sp:varName "facetValue" ;
                          ] ;
                      ] ;
                  ] ;
                sp:arg2 [
                    a sp:exists ;
                    sp:elements (
                        (
                          [
                            sp:object [
                                sp:varName "facetValueType" ;
                              ] ;
                            sp:predicate rdf:type ;
                            sp:subject [
                                sp:varName "facetValue" ;
                              ] ;
                          ]
                        )
                        [
                          a sp:NamedGraph ;
                          sp:elements (
                              [
                                sp:object [
                                    sp:varName "facetValueType" ;
                                  ] ;
                                sp:predicate swa:facetSearchType ;
                                sp:subject [
                                    sp:varName "facetClass" ;
                                  ] ;
                              ]
                            ) ;
                          sp:graphNameNode ui:graph ;
                        ]
                      ) ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:facetClass ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The facet class, e.g. swa:AnyObjectFacet." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property to check for." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks if the swa:facetSearchType declared for a given facet type (?facetClass) is compatible with the search:FacetValue of the current search that is being restored. Will return true if no Search is being restored." ;
  rdfs:label "has matching inverse restore facet value" ;
  rdfs:subClassOf swa:Functions ;
.
swa:hasMatchingRestoreFacetValue
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a swa:restoreFacetValue ;
                arg:property [
                    sp:varName "property" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "facetValue" ;
              ] ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:or ;
                sp:arg1 [
                    a sp:not ;
                    sp:arg1 [
                        a sp:bound ;
                        sp:arg1 [
                            sp:varName "facetValue" ;
                          ] ;
                      ] ;
                  ] ;
                sp:arg2 [
                    a sp:exists ;
                    sp:elements (
                        (
                          [
                            sp:object [
                                sp:varName "facetValueType" ;
                              ] ;
                            sp:predicate rdf:type ;
                            sp:subject [
                                sp:varName "facetValue" ;
                              ] ;
                          ]
                        )
                        [
                          a sp:NamedGraph ;
                          sp:elements (
                              [
                                sp:object [
                                    sp:varName "facetValueType" ;
                                  ] ;
                                sp:predicate swa:facetSearchType ;
                                sp:subject [
                                    sp:varName "facetClass" ;
                                  ] ;
                              ]
                            ) ;
                          sp:graphNameNode ui:graph ;
                        ]
                      ) ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:facetClass ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The facet class, e.g. swa:AnyObjectFacet." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property to check for." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks if the swa:facetSearchType declared for a given facet type (?facetClass) is compatible with the search:FacetValue of the current search that is being restored. Will return true if no Search is being restored." ;
  rdfs:label "has matching restore facet value" ;
  rdfs:subClassOf swa:Functions ;
.
swa:hasNoColWidth
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            sp:object [
                sp:varName "index" ;
              ] ;
            sp:predicate spr:colIndices ;
            sp:subject [
                sp:varName "resultSet" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a spr:colWidth ;
                sp:arg1 [
                    sp:varName "resultSet" ;
                  ] ;
                sp:arg2 [
                    sp:varName "index" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "width" ;
              ] ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:not ;
                sp:arg1 [
                    a sp:bound ;
                    sp:arg1 [
                        sp:varName "width" ;
                      ] ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resultSet ;
      spl:valueType sp:Select ;
      rdfs:comment "The result set to test." ;
    ] ;
  spin:private true ;
  spin:returnType xsd:boolean ;
  rdfs:label "has no col width" ;
  rdfs:subClassOf spr:Functions ;
.
swa:hasOtherArgument
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            a sp:TriplePath ;
            sp:object [
                sp:varName "superClass" ;
              ] ;
            sp:path [
                a sp:ModPath ;
                sp:modMax -2 ;
                sp:modMin 0 ;
                sp:subPath rdfs:subClassOf ;
              ] ;
            sp:subject [
                sp:varName "class" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "con" ;
              ] ;
            sp:predicate spin:constraint ;
            sp:subject [
                sp:varName "superClass" ;
              ] ;
          ]
          [
            sp:object spl:Argument ;
            sp:predicate rdf:type ;
            sp:subject [
                sp:varName "con" ;
              ] ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:notExists ;
                sp:elements (
                    [
                      sp:object arg:resource ;
                      sp:predicate spl:predicate ;
                      sp:subject [
                          sp:varName "con" ;
                        ] ;
                    ]
                  ) ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate spl:class ;
      spl:valueType spin:Module ;
      rdfs:comment "The module class to check." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks if a given module class (?module) has at least one declared spl:Argument other than arg:resource." ;
  rdfs:label "has other argument" ;
  rdfs:subClassOf spl:BooleanFunctions ;
.
swa:hasReadOnlyTriple
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            a sp:Union ;
            sp:elements (
                (
                  [
                    sp:object [
                        sp:varName "resource" ;
                      ] ;
                    sp:predicate [
                        sp:varName "p" ;
                      ] ;
                    sp:subject [
                        sp:varName "s" ;
                      ] ;
                  ]
                  [
                    a sp:Filter ;
                    sp:expression [
                        a swa:isReadOnlyTriple ;
                        sp:arg1 [
                            sp:varName "s" ;
                          ] ;
                        sp:arg2 [
                            sp:varName "p" ;
                          ] ;
                        sp:arg3 [
                            sp:varName "resource" ;
                          ] ;
                      ] ;
                  ]
                )
                (
                  [
                    sp:object [
                        sp:varName "o" ;
                      ] ;
                    sp:predicate [
                        sp:varName "p" ;
                      ] ;
                    sp:subject [
                        sp:varName "resource" ;
                      ] ;
                  ]
                  [
                    a sp:Filter ;
                    sp:expression [
                        a swa:isReadOnlyTriple ;
                        sp:arg1 [
                            sp:varName "resource" ;
                          ] ;
                        sp:arg2 [
                            sp:varName "p" ;
                          ] ;
                        sp:arg3 [
                            sp:varName "o" ;
                          ] ;
                      ] ;
                  ]
                )
              ) ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to check." ;
    ] ;
  spin:private true ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether a resource is used in at least one triple as subject or object, and this triple is read-only. This can be used to determine whether a resource can be (completely) deleted." ;
  rdfs:label "has read-only triple" ;
  rdfs:subClassOf swa:Functions ;
.
swa:hasRelationshipTreeProperties
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            a sp:Union ;
            sp:elements (
                (
                  [
                    sp:object [
                        sp:varName "class" ;
                      ] ;
                    sp:predicate rdf:type ;
                    sp:subject [
                        sp:varName "resource" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "property" ;
                      ] ;
                    sp:predicate swa:relevantClassOfProperty ;
                    sp:subject [
                        sp:varName "class" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "property" ;
                      ] ;
                    sp:predicate sh:path ;
                    sp:subject [
                        sp:varName "propertyShape" ;
                      ] ;
                  ]
                  [
                    a sp:Filter ;
                    sp:expression [
                        a sp:exists ;
                        sp:elements (
                            [
                              sp:object [
                                  sp:varName "rangeClass" ;
                                ] ;
                              sp:predicate sh:class ;
                              sp:subject [
                                  sp:varName "propertyShape" ;
                                ] ;
                            ]
                          ) ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression false ;
                    sp:variable [
                        sp:varName "inverse" ;
                      ] ;
                  ]
                )
                (
                  [
                    sp:object [
                        sp:varName "class" ;
                      ] ;
                    sp:predicate rdf:type ;
                    sp:subject [
                        sp:varName "resource" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "property" ;
                      ] ;
                    sp:predicate swa:directRelevantClassOfInverseProperty ;
                    sp:subject [
                        sp:varName "class" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression true ;
                    sp:variable [
                        sp:varName "inverse" ;
                      ] ;
                  ]
                )
              ) ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The root of the relationship tree" ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:seeAlso swa:GetRelationshipTreeProperties ;
  rdfs:subClassOf swa:Functions ;
.
swa:hiddenProperty
  a rdf:Property ;
  rdfs:comment """Can be used to mark a property \"hidden\" so that it does not show up on forms unless explicitly enumerated. Possible values are:
- true: the property is always hidden
- \"if no object exists\": the property is hidden unless it has values
- false or none: not specified
By default, most system properties that have owl:Thing or rdfs:Resource are marked as hidden unless they have values. Some of those system properties are always hidden, so check for any triples assigned to them in the SWA file.""" ;
  rdfs:domain rdf:Property ;
  rdfs:label "hidden property" ;
  rdfs:range [
      a rdfs:Datatype ;
      owl:oneOf (
          true
          "if no object exists"
        ) ;
    ] ;
.
swa:instancesHaveRandomURI
  a owl:DatatypeProperty ;
  rdfs:isDefinedBy <http://topbraid.org/swa> ;
  rdfs:label "instances have random URI" ;
  rdfs:range xsd:boolean ;
.
swa:internalFalseOrTrue
  a spin:MagicProperty ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Union ;
            sp:elements (
                (
                  [
                    a sp:Bind ;
                    sp:expression false ;
                    sp:variable [
                        sp:varName "result" ;
                      ] ;
                  ]
                )
                (
                  [
                    a sp:Filter ;
                    sp:expression spin:_arg1 ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression true ;
                    sp:variable [
                        sp:varName "result" ;
                      ] ;
                  ]
                )
              ) ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to also produce a true binding." ;
    ] ;
  spin:private true ;
  spin:returnType xsd:boolean ;
  rdfs:subClassOf spin:MagicProperties ;
.
swa:internalGenericTreeReadOnlyHelper
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          (
            [
              sp:object [
                  sp:varName "rowIndex" ;
                ] ;
              sp:predicate spr:rowIndices ;
              sp:subject [
                  sp:varName "rs" ;
                ] ;
            ]
            [
              a sp:Bind ;
              sp:expression [
                  a spr:cell ;
                  sp:arg1 [
                      sp:varName "rs" ;
                    ] ;
                  sp:arg2 [
                      sp:varName "rowIndex" ;
                    ] ;
                  sp:arg3 0 ;
                ] ;
              sp:variable [
                  sp:varName "p" ;
                ] ;
            ]
            [
              a sp:Filter ;
              sp:expression [
                  a sp:eq ;
                  sp:arg1 [
                      sp:varName "p" ;
                    ] ;
                  sp:arg2 [
                      sp:varName "property" ;
                    ] ;
                ] ;
            ]
          )
          [
            a sp:Bind ;
            sp:expression [
                a spr:cell ;
                sp:arg1 [
                    sp:varName "rs" ;
                  ] ;
                sp:arg2 [
                    sp:varName "rowIndex" ;
                  ] ;
                sp:arg3 2 ;
              ] ;
            sp:variable [
                sp:varName "readOnly" ;
              ] ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                sp:varName "readOnly" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The property to look for in the result set." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:rs ;
      spl:valueType sp:Select ;
      rdfs:comment "The result set" ;
    ] ;
  spin:private true ;
  spin:returnType xsd:boolean ;
  rdfs:label "internal generic tree read only helper" ;
  rdfs:subClassOf swa:Functions ;
.
swa:inverseKeyPropertyInputClass
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a sp:if ;
                sp:arg1 [
                    a search:hasInverseKeyProperty ;
                    arg:property [
                        sp:varName "property" ;
                      ] ;
                    arg:search [
                        sp:varName "search" ;
                      ] ;
                  ] ;
                sp:arg2 [
                    a sp:if ;
                    sp:arg1 [
                        a search:isCountInverseKeyProperty ;
                        arg:property [
                            sp:varName "property" ;
                          ] ;
                        arg:search [
                            sp:varName "search" ;
                          ] ;
                      ] ;
                    sp:arg2 "swa-key-property-count" ;
                    sp:arg3 "swa-key-property-checked" ;
                  ] ;
                sp:arg3 "swa-key-property-unchecked" ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property to get the class of." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:search ;
      spl:valueType search:Search ;
      rdfs:comment "The search:Search to check." ;
    ] ;
  spin:private true ;
  spin:returnType xsd:string ;
  rdfs:label "inverse key property input class" ;
  rdfs:subClassOf swa:Functions ;
.
swa:invokeBooleanFunctionService
  a ui:Service ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sp:arg1 ;
      rdfs:comment "The first argument." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sp:arg2 ;
      rdfs:comment "The second argument." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sp:arg3 ;
      rdfs:comment "The third argument." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:function ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The URI of the SPARQL function." ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:group let:result=\"{= spif:invoke(?function, ?arg1, ?arg2, ?arg3) }\">
    <ui:if ui:condition=\"{= ?result }\">true</ui:if>
    <ui:else>false</ui:else>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "Invokes a given SPARQL function and returns its boolean result." ;
  rdfs:label "invoke boolean function service" ;
  rdfs:subClassOf ui:JSONServices ;
.
swa:isBlankNodeProperty
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            a sp:NamedGraph ;
            sp:elements (
                [
                  sp:object true ;
                  sp:predicate swa:blankNodeProperty ;
                  sp:subject [
                      sp:varName "property" ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode ui:graph ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property to check." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether a given property has been marked to have blank nodes via swa:blankNodeProperty=true in the ui:graph." ;
  rdfs:label "is blank node property" ;
  rdfs:subClassOf swa:Functions ;
.
swa:isEditMode
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            a sp:Filter ;
            sp:expression [
                a sp:eq ;
                sp:arg1 [
                    a swa:mode ;
                  ] ;
                sp:arg2 swa:EditMode ;
              ] ;
          ]
        ) ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether the SWP engine is currently in edit mode, i.e. has the swa:mode set to swa:EditMode." ;
  rdfs:label "is edit mode" ;
  rdfs:subClassOf swa:Functions ;
.
swa:isGenericTreeTripleReadOnly
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            a sp:Union ;
            sp:elements (
                (
                  (
                    (
                      [
                        a sp:Bind ;
                        sp:expression [
                            a ui:contextValue ;
                            sp:arg1 "swaGenericTreeProperty" ;
                          ] ;
                        sp:variable [
                            sp:varName "property" ;
                          ] ;
                      ]
                      [
                        a sp:Bind ;
                        sp:expression [
                            a sp:coalesce ;
                            sp:arg1 [
                                a ui:contextValue ;
                                sp:arg1 "swaGenericTreeInverse" ;
                              ] ;
                            sp:arg2 false ;
                          ] ;
                        sp:variable [
                            sp:varName "inverse" ;
                          ] ;
                      ]
                    )
                    [
                      a sp:Filter ;
                      sp:expression [
                          a sp:not ;
                          sp:arg1 [
                              sp:varName "inverse" ;
                            ] ;
                        ] ;
                    ]
                  )
                  [
                    a sp:Filter ;
                    sp:expression [
                        a sp:or ;
                        sp:arg1 [
                            a spl:instanceOf ;
                            sp:arg1 [
                                sp:varName "property" ;
                              ] ;
                            sp:arg2 spin:MagicProperty ;
                          ] ;
                        sp:arg2 [
                            a swa:isReadOnlyTriple ;
                            sp:arg1 [
                                sp:varName "parent" ;
                              ] ;
                            sp:arg2 [
                                sp:varName "property" ;
                              ] ;
                            sp:arg3 [
                                sp:varName "child" ;
                              ] ;
                          ] ;
                      ] ;
                  ]
                )
                (
                  (
                    (
                      [
                        a sp:Bind ;
                        sp:expression [
                            a ui:contextValue ;
                            sp:arg1 "swaGenericTreeProperty" ;
                          ] ;
                        sp:variable [
                            sp:varName "property" ;
                          ] ;
                      ]
                      [
                        a sp:Bind ;
                        sp:expression [
                            a sp:coalesce ;
                            sp:arg1 [
                                a ui:contextValue ;
                                sp:arg1 "swaGenericTreeInverse" ;
                              ] ;
                            sp:arg2 false ;
                          ] ;
                        sp:variable [
                            sp:varName "inverse" ;
                          ] ;
                      ]
                    )
                    [
                      a sp:Filter ;
                      sp:expression [
                          sp:varName "inverse" ;
                        ] ;
                    ]
                  )
                  [
                    a sp:Filter ;
                    sp:expression [
                        a sp:or ;
                        sp:arg1 [
                            a spl:instanceOf ;
                            sp:arg1 [
                                sp:varName "property" ;
                              ] ;
                            sp:arg2 spin:MagicProperty ;
                          ] ;
                        sp:arg2 [
                            a swa:isReadOnlyTriple ;
                            sp:arg1 [
                                sp:varName "child" ;
                              ] ;
                            sp:arg2 [
                                sp:varName "property" ;
                              ] ;
                            sp:arg3 [
                                sp:varName "parent" ;
                              ] ;
                          ] ;
                      ] ;
                  ]
                )
              ) ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:child ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The child node." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:parent ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The parent node." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:label "is generic tree triple read only" ;
  rdfs:subClassOf swa:Functions ;
.
swa:isHiddenObjectWidget
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a ui:contextValue ;
                sp:arg1 "isHiddenObjectWidgetFunction" ;
              ] ;
            sp:variable [
                sp:varName "function" ;
              ] ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:bound ;
                sp:arg1 [
                    sp:varName "function" ;
                  ] ;
              ] ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a spif:invoke ;
                sp:arg1 [
                    sp:varName "function" ;
                  ] ;
                sp:arg2 [
                    sp:varName "focusNode" ;
                  ] ;
                sp:arg3 [
                    sp:varName "predicate" ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:focusNode ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The focus node (subject)." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate to check." ;
    ] ;
  spin:private true ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks if the widget of a given predicate should be hidden for a given subject. Delegates to a function from the context variable \"isHiddenObjectWidgetFunction\" if that exists, defaulting to false." ;
  rdfs:label "is hidden object widget" ;
  rdfs:subClassOf spin:Functions ;
.
swa:isHiddenProperty
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:text """ASK {
	GRAPH ui:unionGraph {
		?property swa:hiddenProperty true .
	}
}""" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The property to check." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether a given property has been marked as \"hidden\". To count as hidden, a property needs to have an annotation swa:hiddenProperty true in a globally registered .ui. graph or the current query graph." ;
  rdfs:label "is hidden property" ;
  rdfs:subClassOf swa:Functions ;
.
swa:isHiddenPropertyAtSubject
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            a sp:NamedGraph ;
            sp:elements (
                [
                  a sp:Union ;
                  sp:elements (
                      (
                        [
                          sp:object true ;
                          sp:predicate swa:hiddenProperty ;
                          sp:subject [
                              sp:varName "property" ;
                            ] ;
                        ]
                      )
                      (
                        (
                          [
                            a sp:Filter ;
                            sp:expression [
                                a sp:bound ;
                                sp:arg1 [
                                    sp:varName "subject" ;
                                  ] ;
                              ] ;
                          ]
                        )
                        [
                          sp:object "if no object exists" ;
                          sp:predicate swa:hiddenProperty ;
                          sp:subject [
                              sp:varName "property" ;
                            ] ;
                        ]
                        [
                          a sp:Filter ;
                          sp:expression [
                              a sp:notExists ;
                              sp:elements (
                                  [
                                    sp:object [
                                        sp:varName "any" ;
                                      ] ;
                                    sp:predicate [
                                        sp:varName "property" ;
                                      ] ;
                                    sp:subject [
                                        sp:varName "subject" ;
                                      ] ;
                                  ]
                                ) ;
                            ] ;
                        ]
                      )
                    ) ;
                ]
              ) ;
            sp:graphNameNode ui:unionGraph ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:subject ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject to check the status at." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The property to check." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether a given property has been marked as \"hidden\" for a given subject. To count as hidden, a property needs to have an annotation swa:hiddenProperty true in a globally registered .ui. graph or the current query graph. If the value of swa:hiddenProperty is \"if no object exists\" then the property will be treated as hidden if it has no values for the given subject." ;
  rdfs:label "is hidden property at subject" ;
  rdfs:subClassOf swa:Functions ;
.
swa:isHiddenSubjectWidget
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a ui:contextValue ;
                sp:arg1 "isHiddenSubjectWidgetFunction" ;
              ] ;
            sp:variable [
                sp:varName "function" ;
              ] ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:bound ;
                sp:arg1 [
                    sp:varName "function" ;
                  ] ;
              ] ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a spif:invoke ;
                sp:arg1 [
                    sp:varName "function" ;
                  ] ;
                sp:arg2 [
                    sp:varName "focusNode" ;
                  ] ;
                sp:arg3 [
                    sp:varName "predicate" ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:focusNode ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The focus node (subject)." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate to check." ;
    ] ;
  spin:private true ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks if the widget of a given inverse predicate should be hidden for a given object. Delegates to a function from the context variable \"isHiddenSubjectWidgetFunction\" if that exists, defaulting to false." ;
  rdfs:label "is hidden subject widget" ;
  rdfs:subClassOf spin:Functions ;
.
swa:isNotHiddenProperty
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            a sp:NamedGraph ;
            sp:elements (
                [
                  a sp:Bind ;
                  sp:expression [
                      a spl:object ;
                      sp:arg1 [
                          sp:varName "property" ;
                        ] ;
                      sp:arg2 swa:hiddenProperty ;
                    ] ;
                  sp:variable [
                      sp:varName "value" ;
                    ] ;
                ]
                [
                  a sp:Filter ;
                  sp:expression [
                      a sp:or ;
                      sp:arg1 [
                          a sp:not ;
                          sp:arg1 [
                              a sp:bound ;
                              sp:arg1 [
                                  sp:varName "value" ;
                                ] ;
                            ] ;
                        ] ;
                      sp:arg2 [
                          a sp:not ;
                          sp:arg1 [
                              sp:varName "value" ;
                            ] ;
                        ] ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode ui:unionGraph ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The property to check." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether a given property has not been marked as \"hidden\". To count as hidden, a property needs to have an annotation swa:hiddenProperty true or \"if no object exists\" in a globally registered .ui. graph or the current query graph." ;
  rdfs:label "is not hidden property" ;
  rdfs:subClassOf swa:Functions ;
.
swa:isNullOrFalse
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            a sp:Filter ;
            sp:expression [
                a sp:or ;
                sp:arg1 [
                    a sp:or ;
                    sp:arg1 [
                        a sp:not ;
                        sp:arg1 [
                            a sp:bound ;
                            sp:arg1 [
                                sp:varName "value" ;
                              ] ;
                          ] ;
                      ] ;
                    sp:arg2 [
                        a sp:eq ;
                        sp:arg1 [
                            a fn:lower-case ;
                            sp:arg1 [
                                sp:varName "value" ;
                              ] ;
                          ] ;
                        sp:arg2 false ;
                      ] ;
                  ] ;
                sp:arg2 [
                    a sp:not ;
                    sp:arg1 [
                        sp:varName "value" ;
                      ] ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  rdfs:label "is null or false" ;
  rdfs:subClassOf swa:Functions ;
.
swa:isPrimaryKeyProperty
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            sp:object [
                sp:varName "type" ;
              ] ;
            sp:predicate rdf:type ;
            sp:subject [
                sp:varName "resource" ;
              ] ;
          ]
          [
            a sp:TriplePath ;
            sp:object [
                sp:varName "class" ;
              ] ;
            sp:path [
                a sp:ModPath ;
                sp:modMax -2 ;
                sp:modMin 0 ;
                sp:subPath rdfs:subClassOf ;
              ] ;
            sp:subject [
                sp:varName "type" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a swa:primaryKeyProperty ;
                arg:class [
                    sp:varName "class" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "pk" ;
              ] ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:eq ;
                sp:arg1 [
                    sp:varName "pk" ;
                  ] ;
                sp:arg2 [
                    sp:varName "property" ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property to check." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to check the property for." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks if a given property is the declared primary key for a given resource (instance). The function will check for any spl:PrimaryKeyPropertyConstraint defined for the type of the resource, or its superclasses." ;
  rdfs:label "is primary key property" ;
  rdfs:subClassOf swa:Functions ;
.
swa:isSearchMode
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            a sp:Filter ;
            sp:expression [
                a sp:eq ;
                sp:arg1 [
                    a swa:mode ;
                  ] ;
                sp:arg2 swa:SearchMode ;
              ] ;
          ]
        ) ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether the SWP engine is currently in search mode, i.e. has the swa:mode set to swa:SearchMode." ;
  rdfs:label "is search mode" ;
  rdfs:subClassOf swa:Functions ;
.
swa:isSingleConstant
  a rdf:Property ;
  rdfs:domain swa:Mode ;
  rdfs:label "is single constant" ;
  rdfs:range xsd:boolean ;
  rdfs:subPropertyOf swa:systemProperty ;
.
swa:isSingleFunction
  a rdf:Property ;
  rdfs:domain swa:Mode ;
  rdfs:label "is single function" ;
  rdfs:range spin:Function ;
  rdfs:subPropertyOf swa:systemProperty ;
.
swa:isViewMode
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            a sp:Filter ;
            sp:expression [
                a sp:eq ;
                sp:arg1 [
                    a swa:mode ;
                  ] ;
                sp:arg2 swa:ViewMode ;
              ] ;
          ]
        ) ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether the SWP engine is currently in view mode, i.e. has the swa:mode set to swa:ViewMode." ;
  rdfs:label "is view mode" ;
  rdfs:subClassOf swa:Functions ;
.
swa:keep
  a rdf:Property ;
  rdfs:label "keep" ;
  rdfs:subPropertyOf swa:systemProperty ;
.
swa:keyProperties
  a rdf:Property ;
  rdfs:comment "Links a class with an rdf:List of properties that deliver the values that shall be displayed as columns if the user searches for instances of the class, or its sub-classes." ;
  rdfs:domain rdfs:Class ;
  rdfs:label "key properties" ;
  rdfs:range rdf:List ;
  rdfs:subPropertyOf swa:systemProperty ;
.
swa:keyPropertiesFromList
  a spin:MagicProperty ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
          [
            sp:varName "inverse" ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "?0" ;
              ] ;
            sp:predicate spif:split ;
            sp:subject [
                sp:varName "str" ;
              ] ;
          ]
          [
            sp:object spin:_arg1 ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "?0" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "?1" ;
              ] ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "?0" ;
              ] ;
          ]
          [
            sp:object " " ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "?1" ;
              ] ;
          ]
          [
            sp:object () ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "?1" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a fn:starts-with ;
                sp:arg1 [
                    sp:varName "str" ;
                  ] ;
                sp:arg2 "-" ;
              ] ;
            sp:variable [
                sp:varName "inverse" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a ui:decodeNode ;
                sp:arg1 [
                    a sp:if ;
                    sp:arg1 [
                        sp:varName "inverse" ;
                      ] ;
                    sp:arg2 [
                        a fn:substring ;
                        sp:arg1 [
                            sp:varName "str" ;
                          ] ;
                        sp:arg2 2 ;
                      ] ;
                    sp:arg3 [
                        sp:varName "str" ;
                      ] ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The space-separated list of encoded key properties." ;
    ] ;
  spin:private true ;
  spin:returnType rdf:Property ;
  rdfs:label "key properties from list" ;
  rdfs:subClassOf spin:MagicProperties ;
.
swa:keyPropertiesFunctor
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "keyProperties" ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "keyProperties" ;
              ] ;
            sp:predicate swa:keyProperties ;
            sp:subject [
                sp:varName "class" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:private true ;
  spin:returnType rdf:List ;
  rdfs:label "key properties functor" ;
  rdfs:subClassOf swa:ClassFunctorFunctions ;
.
swa:keyPropertyInputClass
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a sp:if ;
                sp:arg1 [
                    a search:hasKeyProperty ;
                    arg:property [
                        sp:varName "property" ;
                      ] ;
                    arg:search [
                        sp:varName "search" ;
                      ] ;
                  ] ;
                sp:arg2 [
                    a sp:if ;
                    sp:arg1 [
                        a search:isCountKeyProperty ;
                        arg:property [
                            sp:varName "property" ;
                          ] ;
                        arg:search [
                            sp:varName "search" ;
                          ] ;
                      ] ;
                    sp:arg2 "swa-key-property-count" ;
                    sp:arg3 "swa-key-property-checked" ;
                  ] ;
                sp:arg3 "swa-key-property-unchecked" ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property to get the class of." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:search ;
      spl:valueType search:Search ;
      rdfs:comment "The search:Search to check." ;
    ] ;
  spin:private true ;
  spin:returnType xsd:string ;
  rdfs:label "key property input class" ;
  rdfs:subClassOf swa:Functions ;
.
swa:labelProperty
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a sp:if ;
                sp:arg1 [
                    a sp:or ;
                    sp:arg1 [
                        a sp:eq ;
                        sp:arg1 [
                            sp:varName "resourceType" ;
                          ] ;
                        sp:arg2 skos:Concept ;
                      ] ;
                    sp:arg2 [
                        a spl:subClassOf ;
                        sp:arg1 [
                            sp:varName "resourceType" ;
                          ] ;
                        sp:arg2 skos:Concept ;
                      ] ;
                  ] ;
                sp:arg2 skos:prefLabel ;
                sp:arg3 [
                    a sp:if ;
                    sp:arg1 [
                        a sp:eq ;
                        sp:arg1 [
                            sp:varName "resourceType" ;
                          ] ;
                        sp:arg2 skosxl:Label ;
                      ] ;
                    sp:arg2 skosxl:literalForm ;
                    sp:arg3 [
                        a sp:coalesce ;
                        sp:arg1 [
                            a swa:bestSubPropertyOfRDFSLabel ;
                            arg:class [
                                sp:varName "resourceType" ;
                              ] ;
                          ] ;
                        sp:arg2 rdfs:label ;
                      ] ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class to get the label property for." ;
    ] ;
  spin:returnType rdf:Property ;
  rdfs:comment "Gets the property that shall be used to represent the (preferred) label for an instance of a given class. For skos:Concept or any subclass of it, this will be skos:prefLabel. For SKOS-XL labels this will be skosxl:Label. For all other classes, it will be rdfs:label or a sub-property of rdfs:label that has matching domains." ;
  rdfs:label "label property" ;
  rdfs:subClassOf swa:Functions ;
.
swa:langImage
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:expression [
                a fn:concat ;
                sp:arg1 "lib/assets/images/flags/" ;
                sp:arg2 [
                    sp:varName "countryCode" ;
                  ] ;
                sp:arg3 ".gif" ;
              ] ;
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a swa:countryCodeForLang ;
                arg:lang [
                    sp:varName "lang" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "countryCode" ;
              ] ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:bound ;
                sp:arg1 [
                    sp:varName "countryCode" ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:lang ;
      spl:valueType xsd:string ;
      rdfs:comment "The language tag to get the image for." ;
    ] ;
  spin:private true ;
  spin:returnType xsd:string ;
  rdfs:comment "Gets the URL to an image for a given language tag (either 2 or 5 letter encoding)." ;
  rdfs:label "lang image" ;
  rdfs:subClassOf swa:Functions ;
.
swa:listMemberTypeForIn
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            a sp:TriplePath ;
            sp:object [
                sp:varName "result" ;
              ] ;
            sp:path [
                a sp:AltPath ;
                sp:path1 sh:class ;
                sp:path2 sh:datatype ;
              ] ;
            sp:subject [
                sp:varName "shape" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:shape ;
      spl:valueType sh:Shape ;
      rdfs:comment "The context shape that may also hold the sh:datatype or sh:class triple." ;
    ] ;
  spin:private true ;
  spin:returnType rdfs:Class ;
  rdfs:subClassOf swa:Functions ;
.
swa:mode
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:expression [
                a sp:if ;
                sp:arg1 [
                    a sp:bound ;
                    sp:arg1 [
                        sp:varName "modeName" ;
                      ] ;
                  ] ;
                sp:arg2 [
                    a sp:if ;
                    sp:arg1 [
                        a sp:eq ;
                        sp:arg1 "view" ;
                        sp:arg2 [
                            sp:varName "modeName" ;
                          ] ;
                      ] ;
                    sp:arg2 swa:ViewMode ;
                    sp:arg3 [
                        a sp:if ;
                        sp:arg1 [
                            a sp:eq ;
                            sp:arg1 "edit" ;
                            sp:arg2 [
                                sp:varName "modeName" ;
                              ] ;
                          ] ;
                        sp:arg2 swa:EditMode ;
                        sp:arg3 [
                            a swa:modeByName ;
                            arg:modeName [
                                sp:varName "modeName" ;
                              ] ;
                          ] ;
                      ] ;
                  ] ;
                sp:arg3 swa:ViewMode ;
              ] ;
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a ui:contextValue ;
                sp:arg1 "mode" ;
              ] ;
            sp:variable [
                sp:varName "modeName" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:returnType swa:Mode ;
  rdfs:comment "Gets the current swa:Mode from the context variable \"mode\", defaulting to swa:ViewMode if nothing else has been specified. Note that this function has been natively optimized within TopBraid because it is called frequently, which means that its body is never executed directly." ;
  rdfs:label "mode" ;
  rdfs:subClassOf swa:Functions ;
.
swa:modeByName
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "mode" ;
          ]
        ) ;
      sp:where (
          [
            a sp:NamedGraph ;
            sp:elements (
                [
                  a sp:Filter ;
                  sp:expression [
                      a sp:bound ;
                      sp:arg1 [
                          sp:varName "modeName" ;
                        ] ;
                    ] ;
                ]
                [
                  sp:object [
                      sp:varName "modeName" ;
                    ] ;
                  sp:predicate swa:modeName ;
                  sp:subject [
                      sp:varName "mode" ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode ui:graph ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:modeName ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the mode to get." ;
    ] ;
  spin:returnType swa:Mode ;
  rdfs:comment "Gets the swa:Mode with a given name." ;
  rdfs:label "mode by name" ;
  rdfs:subClassOf swa:Functions ;
.
swa:modeLabel
  a rdf:Property ;
  rdfs:domain swa:Mode ;
  rdfs:label "mode label" ;
  rdfs:range xsd:string ;
  rdfs:subPropertyOf swa:systemProperty ;
.
swa:modeName
  a rdf:Property ;
  rdfs:domain swa:Mode ;
  rdfs:label "mode name" ;
  rdfs:range xsd:string ;
  rdfs:subPropertyOf swa:systemProperty ;
.
swa:modeProperty
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            a sp:NamedGraph ;
            sp:elements (
                [
                  a sp:Bind ;
                  sp:expression [
                      a swa:mode ;
                    ] ;
                  sp:variable [
                      sp:varName "mode" ;
                    ] ;
                ]
                [
                  sp:object [
                      sp:varName "result" ;
                    ] ;
                  sp:predicate [
                      sp:varName "predicate" ;
                    ] ;
                  sp:subject [
                      sp:varName "mode" ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode ui:graph ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property to get the object of." ;
    ] ;
  rdfs:comment "Gets a property associated with the current mode. Note that this function has been natively optimized within TopBraid because it is called frequently, which means that its body is never executed directly." ;
  rdfs:label "mode property" ;
  rdfs:subClassOf swa:Functions ;
.
swa:newUUIDresourceForAssetCollection
  a ui:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The type of the new resource." ;
    ] ;
  spin:private true ;
  spin:returnType rdfs:Resource ;
  ui:prototype """
<ui:group>
    <!--ui:dumpScope ui:message=\"AAA1: swa:newUUIDresourceForAssetCollection\"/-->
    <ui:return ui:result=\"{= swa:newResourceByUUIDForAssetCollection(?resourceType) }\"/>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "Produces a URI for a new resource in an asset collection using a UUID." ;
  rdfs:label "new UUID resource for asset collection" ;
  rdfs:subClassOf ui:Functions ;
.
swa:nodeIcon
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a sp:if ;
                sp:arg1 [
                    a sp:isLiteral ;
                    sp:arg1 [
                        sp:varName "node" ;
                      ] ;
                  ] ;
                sp:arg2 [
                    a swa:datatypeIcon ;
                    arg:datatype [
                        a sp:datatype ;
                        sp:arg1 [
                            sp:varName "node" ;
                          ] ;
                      ] ;
                  ] ;
                sp:arg3 [
                    a sp:coalesce ;
                    sp:arg1 [
                        a swa:resourceIcon ;
                        arg:resource [
                            sp:varName "node" ;
                          ] ;
                      ] ;
                    sp:arg2 "swa-icon-untyped" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:node ;
      rdfs:comment "The RDF node to get the icon for." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Gets the \"most suitable\" icon to display a given RDF node." ;
  rdfs:label "node icon" ;
  rdfs:subClassOf swa:Functions ;
.
swa:nodeIconInGraph
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            a sp:NamedGraph ;
            sp:elements (
                [
                  a sp:Bind ;
                  sp:expression [
                      a swa:nodeIcon ;
                      arg:node [
                          sp:varName "node" ;
                        ] ;
                    ] ;
                  sp:variable [
                      sp:varName "result" ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode [
                sp:varName "useGraph" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:node ;
      rdfs:comment "The RDF node to get the icon for." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:useGraph ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The Graph to switch to." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Gets the \"most suitable\" icon to display a given RDF node, using data from a given graph." ;
  rdfs:label "node icon in graph" ;
  rdfs:subClassOf swa:Functions ;
.
swa:objectFacetMenuName
  a rdf:Property ;
  rdfs:comment "Links a facet with a display name for drop down menus." ;
  rdfs:domain swa:ObjectFacetClass ;
  rdfs:label "object facet menu name" ;
  rdfs:range xsd:string ;
  rdfs:subPropertyOf swa:systemProperty ;
.
swa:objectHasSubjectFromEnum
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            sp:object [
                sp:varName "predicate" ;
              ] ;
            sp:predicate swa:predicatesOfSubjects ;
            sp:subject [
                sp:varName "view" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "object" ;
              ] ;
            sp:predicate [
                sp:varName "predicate" ;
              ] ;
            sp:subject [
                sp:varName "any" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:object ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The object to check." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:view ;
      spl:valueType swa:ObjectsEnum ;
      rdfs:comment "The view (usually instance of swa:ObjectsEnum)." ;
    ] ;
  spin:private true ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks if a given object has at least one subject for any of the swa:Subjects under the given root element." ;
  rdfs:label "object has subject from enum" ;
  rdfs:subClassOf swa:Functions ;
.
swa:objectWidgetClass
  a rdf:Property ;
  rdfs:domain swa:Mode ;
  rdfs:label "object widget class" ;
  rdfs:range swa:ObjectWidgetClass ;
  rdfs:subPropertyOf swa:systemProperty ;
.
swa:objectWidgetClassesWithType
  a spin:MagicProperty ;
  spin:body [
      a sp:Select ;
      sp:orderBy (
          [
            a sp:Desc ;
            sp:expression [
                sp:varName "weight" ;
              ] ;
          ]
        ) ;
      sp:resultVariables (
          [
            sp:varName "widgetClass" ;
          ]
          [
            sp:varName "expression" ;
          ]
        ) ;
      sp:where (
          [
            sp:object spin:_arg1 ;
            sp:predicate rdf:type ;
            sp:subject [
                sp:varName "widgetClass" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "w" ;
              ] ;
            sp:predicate swa:objectWidgetWeight ;
            sp:subject [
                sp:varName "widgetClass" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "expression" ;
              ] ;
            sp:predicate swa:expression ;
            sp:subject [
                sp:varName "w" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:coalesce ;
                sp:arg1 [
                    a spl:object ;
                    sp:arg1 [
                        sp:varName "w" ;
                      ] ;
                    sp:arg2 swa:weight ;
                  ] ;
                sp:arg2 0 ;
              ] ;
            sp:variable [
                sp:varName "weight" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The rdf:type (widget class), e.g. swa:ObjectViewerClass." ;
    ] ;
  spin:private true ;
  rdfs:comment "Just a helper magic property to return all widgets of a given type ordered by their weight." ;
  rdfs:label "object widget classes with type" ;
  rdfs:subClassOf spin:MagicProperties ;
.
swa:objectWidgetMiddleColumnClass
  a rdf:Property ;
  rdfs:domain swa:Mode ;
  rdfs:label "object widget middle column class" ;
  rdfs:range swa:ObjectWidgetMiddleColumnClass ;
  rdfs:subPropertyOf swa:systemProperty ;
.
swa:objectWidgetRowClass
  a rdf:Property ;
  rdfs:domain swa:Mode ;
  rdfs:label "object widget row class" ;
  rdfs:range swa:ObjectWidgetRowClass ;
  rdfs:subPropertyOf swa:systemProperty ;
.
swa:objectWidgetWeight
  a rdf:Property ;
  rdfs:comment """An expression that computes the suitability of an ObjectWidget for a given object (?object) at a given predicate (?predicate) and type class (?subjectType) and range (?range). The larger the number the better. Returning unbound or false means not suitable, and returning true means a weight of 1.

This expression is called if a node and a predicate/subject type combination is present.""" ;
  rdfs:domain swa:ObjectWidgetClass ;
  rdfs:label "object widget weight" ;
  rdfs:range swa:WeightedExpression ;
  rdfs:subPropertyOf swa:systemProperty ;
.
swa:objectsBodyClass
  a rdf:Property ;
  rdfs:domain swa:Mode ;
  rdfs:label "objects body class" ;
  rdfs:range swa:ObjectWidgetClass ;
  rdfs:subPropertyOf swa:systemProperty ;
.
swa:objectsEnumPropertiesHaveType
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            a sp:Filter ;
            sp:expression [
                a sp:notExists ;
                sp:elements (
                    [
                      sp:object [
                          sp:varName "predicate" ;
                        ] ;
                      sp:predicate swa:predicatesOfObjects ;
                      sp:subject [
                          sp:varName "view" ;
                        ] ;
                    ]
                    [
                      a sp:Filter ;
                      sp:expression [
                          a sp:notExists ;
                          sp:elements (
                              [
                                sp:object [
                                    sp:varName "any" ;
                                  ] ;
                                sp:predicate rdf:type ;
                                sp:subject [
                                    sp:varName "predicate" ;
                                  ] ;
                              ]
                            ) ;
                        ] ;
                    ]
                  ) ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:view ;
      spl:valueType swa:ObjectsEnum ;
      rdfs:comment "The view (usually instance of swa:ObjectsEnum)." ;
    ] ;
  spin:private true ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks if all predicates from the the swa:Objects under the given root element have an rdf:type. This can be used to automatically hide sections for which property definitions are missing, in edit mode." ;
  rdfs:subClassOf swa:Functions ;
.
swa:openViewFormGadgetWindow
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a sp:concat ;
                sp:arg1 "swa.openGadgetWindow('swa:ViewFormGadgetWindow', { fixedResource: true, resourceSelectedEvent: '" ;
                sp:arg2 [
                    sp:varName "resourceSelectedEvent" ;
                  ] ;
                sp:arg3 "', resource: resource, showType: true, showURI: true }, 'east')" ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resourceSelectedEvent ;
      spl:valueType xsd:string ;
      rdfs:comment "The event to fire on resource selection." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "A convenience method that produces a JavaScript snippet to be used as context value of swaOnOpenResource." ;
  rdfs:label "open view form gadget window" ;
  rdfs:subClassOf swa:Functions ;
.
swa:owlMinCardinality
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "c" ;
          ]
        ) ;
      sp:where (
          [
            a sp:TriplePath ;
            sp:object [
                sp:varName "superClass" ;
              ] ;
            sp:path [
                a sp:ModPath ;
                sp:modMax -2 ;
                sp:modMin 0 ;
                sp:subPath rdfs:subClassOf ;
              ] ;
            sp:subject [
                sp:varName "class" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "property" ;
              ] ;
            sp:predicate owl:onProperty ;
            sp:subject [
                sp:varName "superClass" ;
              ] ;
          ]
          [
            a sp:TriplePath ;
            sp:object [
                sp:varName "c" ;
              ] ;
            sp:path [
                a sp:AltPath ;
                sp:path1 [
                    a sp:AltPath ;
                    sp:path1 owl:cardinality ;
                    sp:path2 owl:minCardinality ;
                  ] ;
                sp:path2 owl:qualifiedCardinality ;
              ] ;
            sp:subject [
                sp:varName "superClass" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:class ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class to get cardinality at." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property to get the cardinality of." ;
    ] ;
  spin:returnType xsd:integer ;
  rdfs:comment "Walks up the class tree to find the closest owl:minCardinality or owl:cardinality restriction on a given property." ;
  rdfs:label "owl min cardinality" ;
  rdfs:subClassOf swa:Functions ;
.
swa:predicatesOfObjects
  a spin:MagicProperty ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "predicate" ;
          ]
        ) ;
      sp:where (
          [
            a sp:NamedGraph ;
            sp:elements (
                [
                  a sp:TriplePath ;
                  sp:object [
                      sp:varName "view" ;
                    ] ;
                  sp:path [
                      a sp:ModPath ;
                      sp:modMax -2 ;
                      sp:modMin 0 ;
                      sp:subPath ui:child ;
                    ] ;
                  sp:subject spin:_arg1 ;
                ]
                [
                  sp:object [
                      sp:varName "predicate" ;
                    ] ;
                  sp:predicate arg:predicate ;
                  sp:subject [
                      sp:varName "view" ;
                    ] ;
                ]
                [
                  sp:object [
                      sp:varName "type" ;
                    ] ;
                  sp:predicate rdf:type ;
                  sp:subject [
                      sp:varName "view" ;
                    ] ;
                ]
                [
                  a sp:Filter ;
                  sp:expression [
                      a sp:or ;
                      sp:arg1 [
                          a sp:eq ;
                          sp:arg1 [
                              sp:varName "type" ;
                            ] ;
                          sp:arg2 swa:Object ;
                        ] ;
                      sp:arg2 [
                          a sp:eq ;
                          sp:arg1 [
                              sp:varName "type" ;
                            ] ;
                          sp:arg2 swa:Objects ;
                        ] ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode ui:graph ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType ui:Element ;
      rdfs:comment "The root view." ;
    ] ;
  spin:private true ;
  spin:returnType rdf:Property ;
  rdfs:comment "Gets all arg:predicates associated with swa:Object or swa:Objects underneath a given root view." ;
  rdfs:label "predicates of objects" ;
  rdfs:subClassOf spin:MagicProperties ;
.
swa:predicatesOfSubjects
  a spin:MagicProperty ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "predicate" ;
          ]
        ) ;
      sp:where (
          [
            a sp:NamedGraph ;
            sp:elements (
                [
                  a sp:TriplePath ;
                  sp:object [
                      sp:varName "view" ;
                    ] ;
                  sp:path [
                      a sp:ModPath ;
                      sp:modMax -2 ;
                      sp:modMin 0 ;
                      sp:subPath ui:child ;
                    ] ;
                  sp:subject spin:_arg1 ;
                ]
                [
                  sp:object [
                      sp:varName "predicate" ;
                    ] ;
                  sp:predicate arg:predicate ;
                  sp:subject [
                      sp:varName "view" ;
                    ] ;
                ]
                [
                  sp:object [
                      sp:varName "type" ;
                    ] ;
                  sp:predicate rdf:type ;
                  sp:subject [
                      sp:varName "view" ;
                    ] ;
                ]
                [
                  a sp:Filter ;
                  sp:expression [
                      a sp:or ;
                      sp:arg1 [
                          a sp:eq ;
                          sp:arg1 [
                              sp:varName "type" ;
                            ] ;
                          sp:arg2 swa:Subject ;
                        ] ;
                      sp:arg2 [
                          a sp:eq ;
                          sp:arg1 [
                              sp:varName "type" ;
                            ] ;
                          sp:arg2 swa:Subjects ;
                        ] ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode ui:graph ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType ui:Element ;
      rdfs:comment "The root view." ;
    ] ;
  spin:private true ;
  spin:returnType rdf:Property ;
  rdfs:comment "Gets all arg:predicates associated with swa:Subject or swa:Subjects underneath a given root view." ;
  rdfs:label "predicates of subjects" ;
  rdfs:subClassOf spin:MagicProperties ;
.
swa:propertyLabelAtClassOrShapeInGraph
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            a sp:NamedGraph ;
            sp:elements (
                [
                  a sp:Bind ;
                  sp:expression [
                      a swa:propertyLabelAtClassOrShape ;
                      arg:property [
                          sp:varName "property" ;
                        ] ;
                      arg:theClassOrShape [
                          sp:varName "theClassOrShape" ;
                        ] ;
                    ] ;
                  sp:variable [
                      sp:varName "result" ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode [
                sp:varName "theGraph" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdfs:Property ;
      rdfs:comment "The property to get the label of." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:theClassOrShape ;
      rdfs:comment "The class/shape for the context." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:theGraph ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The query graph" ;
    ] ;
  spin:private true ;
  spin:returnType xsd:string ;
  rdfs:subClassOf swa:Functions ;
.
swa:publishEvent
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Filter ;
            sp:expression [
                a sp:bound ;
                sp:arg1 spin:_arg1 ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:concat ;
                sp:arg1 "gadgets.Hub.publish('" ;
                sp:arg2 spin:_arg1 ;
                sp:arg3 "', " ;
                sp:arg4 [
                    sp:varName "data" ;
                  ] ;
                sp:arg5 ");" ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The event (sometimes called topic) that is being published. Should be formed according to http://www.openajax.org/member/wiki/OpenAjax_Hub_2.0_Specification_Topic_Names with names such as org.example.myapplication.myEvent. If left blank, the function returns nothing." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:data ;
      spl:valueType xsd:string ;
      rdfs:comment "A valid JavaScript expression that is passed around as data payload into the event bus." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Creates a JavaScript expression that publishes an event to the event hub used by SWA." ;
  rdfs:label "publish event" ;
  rdfs:subClassOf swa:Functions ;
.
swa:randomInstance
  a ui:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:class ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The class to get an instance of." ;
    ] ;
  spin:returnType rdfs:Resource ;
  ui:prototype """
<ui:group letrs:rs=\"{#
        SELECT DISTINCT ?instance
        WHERE {
            ?type (rdfs:subClassOf)* ?class .
            ?instance a ?type .
        } }\">
    <ui:if ui:condition=\"{= !spr:isEmpty(?rs) }\">
        <ui:return ui:result=\"{= spr:cell(?rs, spif:cast(fn:floor((RAND() * spr:rowCount(?rs))), xsd:integer), 0) }\"/>
    </ui:if>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "Selects a random instance of a given class or its subclasses. Can be used to generate random triples." ;
  rdfs:label "random instance" ;
  rdfs:subClassOf ui:Functions ;
.
swa:randomInteger
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a spif:cast ;
                arg:datatype xsd:integer ;
                sp:arg1 [
                    a fn:floor ;
                    sp:arg1 [
                        a sp:mul ;
                        sp:arg1 [
                            a sp:rand ;
                          ] ;
                        sp:arg2 [
                            sp:varName "max" ;
                          ] ;
                      ] ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:max ;
      spl:valueType xsd:integer ;
      rdfs:comment "The max value." ;
    ] ;
  spin:returnType xsd:integer ;
  rdfs:comment "Returns a random integer between 0 and the provided argument." ;
  rdfs:label "random integer" ;
  rdfs:subClassOf spl:MathematicalFunctions ;
.
swa:randomNode
  a ui:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:range ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The range of the property to create a node for." ;
    ] ;
  ui:prototype """
<ui:group>
    <ui:if ui:condition=\"{= swa:isDatatypeRange(?range) }\">
        <ui:if ui:condition=\"{= xsd:boolean = ?range }\">
            <ui:return ui:result=\"{= RAND() &lt; 0.5 }\"/>
        </ui:if>
        <ui:elseif ui:condition=\"{= swa:isNumericDatatype(?range) }\">
            <ui:return ui:result=\"{= spif:cast(swa:randomInteger(1000), ?range) }\"/>
        </ui:elseif>
        <ui:elseif ui:condition=\"{= xsd:date = ?range }\">
            <ui:return ui:result=\"{= xsd:date(CONCAT(xsd:string((1900 + swa:randomInteger(200))), &quot;-0&quot;, xsd:string((swa:randomInteger(9) + 1)), &quot;-&quot;, xsd:string((swa:randomInteger(18) + 11)))) }\"/>
        </ui:elseif>
        <ui:elseif ui:condition=\"{= xsd:dateTime = ?range }\">
            <ui:return ui:result=\"{= xsd:dateTime(CONCAT(xsd:string(swa:randomNode(xsd:date)), &quot;T&quot;, xsd:string((10 + swa:randomInteger(14))), &quot;:&quot;, xsd:string((10 + swa:randomInteger(50))), &quot;:&quot;, xsd:string((10 + swa:randomInteger(50))))) }\"/>
        </ui:elseif>
        <ui:else>
            <ui:return ui:result=\"{= spif:cast(CONCAT(&quot;Value &quot;, xsd:string(RAND())), ?range) }\"/>
        </ui:else>
    </ui:if>
    <ui:else>
        <ui:return ui:result=\"{= swa:randomInstance(?range) }\"/>
    </ui:else>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "Returns a random node that matches a given range. Can be used to generate random triples." ;
  rdfs:label "random node" ;
  rdfs:subClassOf ui:Functions ;
.
swa:readOnly
  a rdf:Property ;
  rdfs:comment "Can be used to mark actions that are only doing read-only operations. This is used to determine whether an action should show up for people with only viewer permissions." ;
  rdfs:domain swa:ResourceAction ;
  rdfs:label "read only" ;
  rdfs:range xsd:boolean ;
.
swa:relationshipTreeProperty-DEPRECATED
  a spin:MagicProperty ;
  spin:body [
      a sp:Select ;
      sp:distinct true ;
      sp:resultVariables (
          [
            sp:varName "property" ;
          ]
        ) ;
      sp:where (
          (
            [
              sp:object [
                  sp:varName "type" ;
                ] ;
              sp:predicate rdf:type ;
              sp:subject spin:_arg1 ;
            ]
            [
              a sp:TriplePath ;
              sp:object [
                  sp:varName "class" ;
                ] ;
              sp:path [
                  a sp:ModPath ;
                  sp:modMax -2 ;
                  sp:modMin 0 ;
                  sp:subPath rdfs:subClassOf ;
                ] ;
              sp:subject [
                  sp:varName "type" ;
                ] ;
            ]
            [
              sp:object [
                  sp:varName "property" ;
                ] ;
              sp:predicate swa:relevantClassOfProperty ;
              sp:subject [
                  sp:varName "class" ;
                ] ;
            ]
            [
              a sp:Filter ;
              sp:expression [
                  a swa:filterAllSystemResources ;
                  arg:node [
                      sp:varName "property" ;
                    ] ;
                ] ;
            ]
          )
          [
            a sp:Bind ;
            sp:expression [
                a swa:localRangeAtClass ;
                arg:class [
                    sp:varName "type" ;
                  ] ;
                arg:property [
                    sp:varName "property" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "range" ;
              ] ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:not ;
                sp:arg1 [
                    a swa:isDatatypeRange ;
                    arg:range [
                        sp:varName "range" ;
                      ] ;
                  ] ;
              ] ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:exists ;
                sp:elements (
                    [
                      sp:object [
                          sp:varName "anyObject" ;
                        ] ;
                      sp:predicate [
                          sp:varName "property" ;
                        ] ;
                      sp:subject spin:_arg1 ;
                    ]
                  ) ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The root of the tree" ;
    ] ;
  spin:private true ;
  spin:returnType rdf:Property ;
  rdfs:subClassOf spin:MagicProperties ;
.
swa:removeUniqueId
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a spif:indexOf ;
                sp:arg1 spin:_arg1 ;
                sp:arg2 "::" ;
              ] ;
            sp:variable [
                sp:varName "index" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a fn:substring ;
                sp:arg1 spin:_arg1 ;
                sp:arg2 1 ;
                sp:arg3 [
                    sp:varName "index" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The string to convert." ;
    ] ;
  spin:private true ;
  spin:returnType xsd:string ;
  rdfs:comment "Takes a string and removes everything after the :: (including the :: itself). This is needed to de-code tree node ids." ;
  rdfs:label "remove unique id" ;
  rdfs:subClassOf swa:Functions ;
.
swa:replaceURIInGraph
  a ui:Method ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:graph ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The target graph." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:new ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The new resource URI." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:old ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The old URI resource." ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:setContext ui:queryGraph=\"{= ?graph }\">
    <ui:group letrs:olds=\"{#
            SELECT DISTINCT ?s ?p ?o
            WHERE {
                {
                    ?s ?p ?old .
                    BIND (?old AS ?o) .
                }
                UNION
                {
                    ?s ?old ?o .
                    BIND (?old AS ?p) .
                }
                UNION
                {
                    ?old ?p ?o .
                    BIND (?old AS ?s) .
                } .
            } }\">
        <ui:if ui:condition=\"{= !spr:isEmpty(?olds) }\">
            <ui:transaction ui:logMessage=\"Replace URI {= ?old } with {= ?new }\">
                <ui:forEach ui:resultSet=\"{= ?olds }\">
                    <ui:update ui:updateQuery=\"{!
                            DELETE {
                                ?s ?p ?o .
                            }
                            INSERT {
                                ?newS ?newP ?newO .
                            }
                            WHERE {
                                BIND (IF((?s = ?old), ?new, ?s) AS ?newS) .
                                BIND (IF((?p = ?old), ?new, ?p) AS ?newP) .
                                BIND (IF((?o = ?old), ?new, ?o) AS ?newO) .
                            } }\"/>
                </ui:forEach>
            </ui:transaction>
        </ui:if>
    </ui:group>
</ui:setContext>
"""^^ui:Literal ;
  rdfs:comment """Replaces a given URI resource in a given graph. This first collects all usages and then - if any such usage exists - creates a transaction for the actual update.

In teamwork products this is used for actions that rename or merge a given resource.""" ;
  rdfs:subClassOf ui:Methods ;
.
swa:resourceIcon
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:orderBy (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "type" ;
              ] ;
            sp:predicate swa:typesWithoutSuperclasses ;
            sp:subject [
                sp:varName "resource" ;
              ] ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:ne ;
                sp:arg1 [
                    sp:varName "type" ;
                  ] ;
                sp:arg2 owl:FunctionalProperty ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a spif:walkObjects ;
                sp:arg1 [
                    sp:varName "type" ;
                  ] ;
                sp:arg2 rdfs:subClassOf ;
                sp:arg3 swa:typeIconFunctor ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to get the icon of." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Gets the most suitable icon for a given resource (instance). It takes the \"first\" rdf:type of the instance and then walks up the hierarchy of classes until it finds a class that has swa:typeIcon attached to it. Note that this swa:typeIcon triple must be stored in a globally registered SWP graph, ending with .ui.*." ;
  rdfs:label "resource icon" ;
  rdfs:subClassOf swa:Functions ;
.
swa:resourceIsSubjectOrObject
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a sp:if ;
                sp:arg1 [
                    sp:varName "inverse" ;
                  ] ;
                sp:arg2 [
                    a sp:exists ;
                    sp:elements (
                        [
                          sp:object [
                              sp:varName "resource" ;
                            ] ;
                          sp:predicate [
                              sp:varName "property" ;
                            ] ;
                          sp:subject [
                              sp:varName "someOtherResource" ;
                            ] ;
                        ]
                      ) ;
                  ] ;
                sp:arg3 [
                    a sp:exists ;
                    sp:elements (
                        [
                          sp:object [
                              sp:varName "someValue" ;
                            ] ;
                          sp:predicate [
                              sp:varName "property" ;
                            ] ;
                          sp:subject [
                              sp:varName "resource" ;
                            ] ;
                        ]
                      ) ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:inverse ;
      spl:valueType xsd:boolean ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdf:Property ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether a given resource is a subject or object for given property The oaraneter 'inverse' determinse which direction is checked." ;
  rdfs:label "resource is subject or object" ;
  rdfs:subClassOf spin:Functions ;
.
swa:resourceTypeIcon
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a spif:walkObjects ;
                sp:arg1 [
                    sp:varName "resourceType" ;
                  ] ;
                sp:arg2 rdfs:subClassOf ;
                sp:arg3 swa:typeIconFunctor ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdf:Property ;
      rdfs:comment "The type to get the icon of." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Gets the most suitable icon for a given resource type (class). It walks up the hierarchy of classes until it finds a class that has swa:typeIcon attached to it." ;
  rdfs:label "resource type icon" ;
  rdfs:subClassOf swa:Functions ;
.
swa:resourceURIOrBNodeId
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Union ;
            sp:elements (
                (
                  [
                    a sp:Filter ;
                    sp:expression [
                        a sp:isIRI ;
                        sp:arg1 [
                            sp:varName "resource" ;
                          ] ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression [
                        a xsd:string ;
                        sp:arg1 [
                            sp:varName "resource" ;
                          ] ;
                      ] ;
                    sp:variable [
                        sp:varName "result" ;
                      ] ;
                  ]
                )
                (
                  [
                    a sp:Filter ;
                    sp:expression [
                        a sp:isBlank ;
                        sp:arg1 [
                            sp:varName "resource" ;
                          ] ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression [
                        a ui:encodeNode ;
                        sp:arg1 [
                            sp:varName "resource" ;
                          ] ;
                        sp:arg2 true ;
                      ] ;
                    sp:variable [
                        sp:varName "encoded" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression [
                        a fn:substring ;
                        sp:arg1 [
                            sp:varName "encoded" ;
                          ] ;
                        sp:arg2 2 ;
                        sp:arg3 [
                            a sp:sub ;
                            sp:arg1 [
                                a fn:string-length ;
                                sp:arg1 [
                                    sp:varName "encoded" ;
                                  ] ;
                              ] ;
                            sp:arg2 2 ;
                          ] ;
                      ] ;
                    sp:variable [
                        sp:varName "result" ;
                      ] ;
                  ]
                )
              ) ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to get the id of." ;
    ] ;
  spin:private true ;
  spin:returnType xsd:string ;
  rdfs:comment "Get the URI or bnode id (starting with @) of the given resource." ;
  rdfs:label "resource URI or BNode id" ;
  rdfs:subClassOf swa:Functions ;
.
swa:restoreFacetValue
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "facetValue" ;
          ]
        ) ;
      sp:where (
          (
            (
              [
                a sp:Bind ;
                sp:expression [
                    a ui:contextValue ;
                    sp:arg1 "swaRestoreSearch" ;
                  ] ;
                sp:variable [
                    sp:varName "search" ;
                  ] ;
              ]
            )
            [
              a sp:Bind ;
              sp:expression [
                  a sp:coalesce ;
                  sp:arg1 [
                      a ui:contextValue ;
                      sp:arg1 "subjectVarName" ;
                    ] ;
                  sp:arg2 "result" ;
                ] ;
              sp:variable [
                  sp:varName "subjectVarName" ;
                ] ;
            ]
            [
              a sp:Filter ;
              sp:expression [
                  a sp:bound ;
                  sp:arg1 [
                      sp:varName "search" ;
                    ] ;
                ] ;
            ]
          )
          [
            sp:object [
                sp:varName "property" ;
              ] ;
            sp:predicate search:property ;
            sp:subject [
                sp:varName "facet" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "subjectVarName" ;
              ] ;
            sp:predicate search:subjectVarName ;
            sp:subject [
                sp:varName "facet" ;
              ] ;
          ]
          [
            sp:object search:PropertyFacet ;
            sp:predicate rdf:type ;
            sp:subject [
                sp:varName "facet" ;
              ] ;
          ]
          [
            a sp:Union ;
            sp:elements (
                (
                  [
                    sp:object [
                        sp:varName "facetValue" ;
                      ] ;
                    sp:predicate search:facetValue ;
                    sp:subject [
                        sp:varName "facet" ;
                      ] ;
                  ]
                  [
                    a sp:TriplePath ;
                    sp:object [
                        sp:varName "facet" ;
                      ] ;
                    sp:path [
                        a sp:SeqPath ;
                        sp:path1 search:facet ;
                        sp:path2 [
                            a sp:ModPath ;
                            sp:modMax -2 ;
                            sp:modMin 0 ;
                            sp:subPath [
                                a sp:SeqPath ;
                                sp:path1 search:facetValue ;
                                sp:path2 search:facet ;
                              ] ;
                          ] ;
                      ] ;
                    sp:subject [
                        sp:varName "search" ;
                      ] ;
                  ]
                )
                (
                  [
                    sp:object [
                        sp:varName "facetValue" ;
                      ] ;
                    sp:predicate search:facetValue ;
                    sp:subject [
                        sp:varName "search" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "facet" ;
                      ] ;
                    sp:predicate search:facet ;
                    sp:subject [
                        sp:varName "facetValue" ;
                      ] ;
                  ]
                )
              ) ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property to get the FacetValue of." ;
    ] ;
  spin:returnType search:FacetValue ;
  rdfs:comment """Tries to find a Search to restore using the context value \"swaRestoreSearch\", and then it's facet value for a given property.

Note this also handles legacy Search instances where search:facet and search:facetValue had different domains (see the lower union branch).""" ;
  rdfs:label "restore facet value" ;
  rdfs:subClassOf swa:Functions ;
.
swa:restoreInverseFacetValue
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "facetValue" ;
          ]
        ) ;
      sp:where (
          (
            (
              [
                a sp:Bind ;
                sp:expression [
                    a ui:contextValue ;
                    sp:arg1 "swaRestoreSearch" ;
                  ] ;
                sp:variable [
                    sp:varName "search" ;
                  ] ;
              ]
            )
            [
              a sp:Bind ;
              sp:expression [
                  a sp:coalesce ;
                  sp:arg1 [
                      a ui:contextValue ;
                      sp:arg1 "subjectVarName" ;
                    ] ;
                  sp:arg2 "result" ;
                ] ;
              sp:variable [
                  sp:varName "subjectVarName" ;
                ] ;
            ]
            [
              a sp:Filter ;
              sp:expression [
                  a sp:bound ;
                  sp:arg1 [
                      sp:varName "search" ;
                    ] ;
                ] ;
            ]
          )
          [
            sp:object [
                sp:varName "property" ;
              ] ;
            sp:predicate search:property ;
            sp:subject [
                sp:varName "facet" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "subjectVarName" ;
              ] ;
            sp:predicate search:subjectVarName ;
            sp:subject [
                sp:varName "facet" ;
              ] ;
          ]
          [
            sp:object search:InversePropertyFacet ;
            sp:predicate rdf:type ;
            sp:subject [
                sp:varName "facet" ;
              ] ;
          ]
          [
            a sp:Union ;
            sp:elements (
                (
                  [
                    sp:object [
                        sp:varName "facetValue" ;
                      ] ;
                    sp:predicate search:facetValue ;
                    sp:subject [
                        sp:varName "facet" ;
                      ] ;
                  ]
                  [
                    a sp:TriplePath ;
                    sp:object [
                        sp:varName "facet" ;
                      ] ;
                    sp:path [
                        a sp:SeqPath ;
                        sp:path1 search:facet ;
                        sp:path2 [
                            a sp:ModPath ;
                            sp:modMax -2 ;
                            sp:modMin 0 ;
                            sp:subPath [
                                a sp:SeqPath ;
                                sp:path1 search:facetValue ;
                                sp:path2 search:facet ;
                              ] ;
                          ] ;
                      ] ;
                    sp:subject [
                        sp:varName "search" ;
                      ] ;
                  ]
                )
                (
                  [
                    sp:object [
                        sp:varName "facetValue" ;
                      ] ;
                    sp:predicate search:facetValue ;
                    sp:subject [
                        sp:varName "search" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "facet" ;
                      ] ;
                    sp:predicate search:facet ;
                    sp:subject [
                        sp:varName "facetValue" ;
                      ] ;
                  ]
                )
              ) ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property to get the FacetValue of." ;
    ] ;
  spin:returnType search:FacetValue ;
  rdfs:comment "Tries to find a Search to restore using the context value \"swaRestoreSearch\", and then its facet value for a given inverse property." ;
  rdfs:label "restore inverse facet value" ;
  rdfs:subClassOf swa:Functions ;
.
swa:restoreSearch
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Union ;
            sp:elements (
                (
                  (
                    (
                      [
                        a sp:Bind ;
                        sp:expression [
                            a ui:contextValue ;
                            sp:arg1 "swaRestoreSearch" ;
                          ] ;
                        sp:variable [
                            sp:varName "rootSearch" ;
                          ] ;
                      ]
                      [
                        a sp:Bind ;
                        sp:expression [
                            a sp:coalesce ;
                            sp:arg1 [
                                a ui:contextValue ;
                                sp:arg1 "subjectVarName" ;
                              ] ;
                            sp:arg2 "result" ;
                          ] ;
                        sp:variable [
                            sp:varName "subjectVarName" ;
                          ] ;
                      ]
                    )
                    [
                      a sp:Filter ;
                      sp:expression [
                          a sp:and ;
                          sp:arg1 [
                              a sp:bound ;
                              sp:arg1 [
                                  sp:varName "rootSearch" ;
                                ] ;
                            ] ;
                          sp:arg2 [
                              a sp:bound ;
                              sp:arg1 [
                                  sp:varName "subjectVarName" ;
                                ] ;
                            ] ;
                        ] ;
                    ]
                  )
                  [
                    a sp:TriplePath ;
                    sp:object [
                        sp:varName "result" ;
                      ] ;
                    sp:path [
                        a sp:ModPath ;
                        sp:modMax -2 ;
                        sp:modMin 0 ;
                        sp:subPath [
                            a sp:SeqPath ;
                            sp:path1 search:facet ;
                            sp:path2 search:facetValue ;
                          ] ;
                      ] ;
                    sp:subject [
                        sp:varName "rootSearch" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "subjectVarName" ;
                      ] ;
                    sp:predicate search:nestedSubjectVarName ;
                    sp:subject [
                        sp:varName "result" ;
                      ] ;
                  ]
                )
                (
                  [
                    a sp:Bind ;
                    sp:expression [
                        a ui:contextValue ;
                        sp:arg1 "swaRestoreSearch" ;
                      ] ;
                    sp:variable [
                        sp:varName "result" ;
                      ] ;
                  ]
                )
              ) ;
          ]
        ) ;
    ] ;
  spin:private true ;
  spin:returnType search:Search ;
  rdfs:comment "Tries to find a Search to restore using the context value \"swaRestoreSearch\" and the current \"subjectVarName\". Defaults to the current root search." ;
  rdfs:label "restore search" ;
  rdfs:subClassOf swa:Functions ;
.
swa:restoreSearchLocal
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          (
            (
              [
                a sp:Bind ;
                sp:expression [
                    a ui:contextValue ;
                    sp:arg1 "swaRestoreSearch" ;
                  ] ;
                sp:variable [
                    sp:varName "search" ;
                  ] ;
              ]
            )
            [
              a sp:Filter ;
              sp:expression [
                  a sp:bound ;
                  sp:arg1 [
                      sp:varName "search" ;
                    ] ;
                ] ;
            ]
          )
          [
            sp:object true ;
            sp:predicate search:local ;
            sp:subject [
                sp:varName "search" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Tries to find a Search to restore using the context value \"swaRestoreSearch\", and then its \"local\" value." ;
  rdfs:subClassOf swa:Functions ;
.
swa:restoreSearchString
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "string" ;
          ]
        ) ;
      sp:where (
          (
            (
              [
                a sp:Bind ;
                sp:expression [
                    a ui:contextValue ;
                    sp:arg1 "swaRestoreSearch" ;
                  ] ;
                sp:variable [
                    sp:varName "search" ;
                  ] ;
              ]
            )
            [
              a sp:Filter ;
              sp:expression [
                  a sp:bound ;
                  sp:arg1 [
                      sp:varName "search" ;
                    ] ;
                ] ;
            ]
          )
          [
            sp:object [
                sp:varName "string" ;
              ] ;
            sp:predicate search:string ;
            sp:subject [
                sp:varName "search" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Tries to find a Search to restore using the context value \"swaRestoreSearch\", and then it's string value (full text search)." ;
  rdfs:subClassOf swa:Functions ;
.
swa:restoreSearchStringCaseSensitive
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          (
            (
              [
                a sp:Bind ;
                sp:expression [
                    a ui:contextValue ;
                    sp:arg1 "swaRestoreSearch" ;
                  ] ;
                sp:variable [
                    sp:varName "search" ;
                  ] ;
              ]
            )
            [
              a sp:Filter ;
              sp:expression [
                  a sp:bound ;
                  sp:arg1 [
                      sp:varName "search" ;
                    ] ;
                ] ;
            ]
          )
          [
            a sp:Bind ;
            sp:expression [
                a sp:exists ;
                sp:elements (
                    [
                      sp:object true ;
                      sp:predicate search:stringCaseSensitive ;
                      sp:subject [
                          sp:varName "search" ;
                        ] ;
                    ]
                  ) ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Tries to find a Search to restore using the context value \"swaRestoreSearch\", and then it's string case sensitivity value." ;
  rdfs:subClassOf swa:Functions ;
.
swa:resultSetDataTable
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:additionalClasses ;
      spl:valueType xsd:string ;
      rdfs:comment "Any additional classes to apply to the table's container element" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:columnsService ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:createResourceHandler ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:createService ;
      spl:valueType xsd:string ;
      rdfs:comment "The service to use when creating a record in a the table. Used in conjunction with editable config option" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:dtType ;
      spl:valueType xsd:string ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:editable ;
      spl:valueType xsd:boolean ;
      rdfs:comment "Specifies if the table should have editing capabilities" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:exports ;
      spl:valueType xsd:boolean ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:filter ;
      spl:valueType xsd:boolean ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:hideIfEmpty ;
      spl:valueType xsd:boolean ;
      rdfs:comment """Hides the table if no data is returned. If you are setting this to true you need a sibling <div> element next to the data table with the class \"ui-helper-hidden-accessbile\" with whatever message you want to display.
for example:

<div class=\"ui-helper-hidden-accessible\">None</div>""" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:id ;
      spl:valueType xsd:string ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:pageLength ;
      spl:valueType xsd:integer ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:resourceSelectedEvent ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of an event to publish when the user clicks on a result. The data payload of this event is the URI of the resource." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "Specifies the \"type\" when creating an entry in the table. Used in conjunction with editable config option" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:searchGraph ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:selectAll ;
      spl:valueType xsd:boolean ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:suppressLabelColumn ;
      spl:valueType xsd:boolean ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:dataEndpoint ;
      spl:valueType xsd:string ;
      rdfs:comment "The JSON service (viewClass) that provides the columns definition for the table" ;
    ] ;
  ui:prototype """
<div class=\"table-container {= ?additionalClasses }\" data-columns-endpoint=\"{= COALESCE(?columnsService, swa:DataTableSearchColumns) }\" data-create-service=\"{= COALESCE(?createService, swa:DefaultCreateResourceDialogPluginForAssetCollection) }\" data-create-service-handler=\"{= COALESCE(?createResourceHandler, swa:CreateResourceHandler) }\" data-datatable=\"true\" data-datatable-type=\"{= COALESCE(?dtType, &quot;resultSet&quot;) }\" data-editable=\"{= COALESCE(?editable, false) }\" data-endpoint=\"{= COALESCE(?dataEndpoint, swa:DataTableSearchResultsCallback) }\" data-has-exports=\"{= COALESCE(?exports, ?nil) }\" data-has-filter=\"{= COALESCE(?filter, ?nil) }\" data-has-select-all=\"{= COALESCE(?selectAll, ?nil) }\" data-hide-if-empty=\"{= COALESCE(?hideIfEmpty, ?nil) }\" data-page-length=\"{= COALESCE(?pageLength, ?nil) }\" data-resource-selected-event=\"{= COALESCE(?resourceSelectedEvent, ?nil) }\" data-resource-type=\"{= COALESCE(?resourceType, ?nil) }\" data-search-graph=\"{= COALESCE(?searchGraph, ?nil) }\" data-suppress-label-column=\"{= COALESCE(?suppressLabelColumn, ?nil) }\" id=\"{= COALESCE(?id, ui:uniqueId()) }\"/>
"""^^ui:Literal ;
  rdfs:comment """A standard DataTable usage:

<swa:DataTable
    arg:additionalClasses=\"my-custom-table\"
    arg:dataColumnsEndpoint=\"saf:getSearchColumnsService\"
    arg:dataEndpoint=\"saf:getSearchResultsService\"
    arg:editable=\"true\"
    arg:hasViewableDetails=\"true\"
    arg:createService=\"http://topbraid.org/swa#CreateResourceDialogJSON\"
    arg:hasSelectAll=\"true\"
    arg:resourceSelectedEvent=\"org.datasetapp.instanceSelected\"
    arg:resourceType=\"http://edg.topbraid.solutions/model/GlossaryViewpoint\"
    arg:searchGraph=\"urn:x-swp-session:2ad4720f-bb8e-4030-b48d-6b3b2b6ead9e\"
    arg:hasScrollCollapse=\"true\"/>""" ;
  rdfs:subClassOf swa:Elements ;
.
swa:searchCompletedEvent
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a sp:coalesce ;
                sp:arg1 [
                    sp:varName "event" ;
                  ] ;
                sp:arg2 "org.topbraid.swa.searchCompleted" ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:event ;
      spl:valueType xsd:string ;
      rdfs:comment "The event name or null to fall back to the default one." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Gets the name of a search completion event, falling back to a default one (org.topbraid.swa.searchCompleted) if the one provided is unbound." ;
  rdfs:label "search event" ;
  rdfs:subClassOf swa:Functions ;
.
swa:searchEvent
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a sp:coalesce ;
                sp:arg1 [
                    sp:varName "event" ;
                  ] ;
                sp:arg2 "org.topbraid.swa.search" ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:event ;
      spl:valueType xsd:string ;
      rdfs:comment "The event name or null to fall back to the default one." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Gets the name of a search event, falling back to a default one (org.topbraid.swa.search) if the one provided is unbound." ;
  rdfs:label "search event" ;
  rdfs:subClassOf swa:Functions ;
.
swa:setDomain
  a ui:Method ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:domain ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The domain class." ;
    ] ;
  ui:prototype """
<ui:update ui:updateQuery=\"{!
        INSERT {
            ?this rdfs:domain ?domain .
        }
        WHERE {
        } }\"/>
"""^^ui:Literal ;
  rdfs:label "set domain" ;
  rdfs:subClassOf ui:Methods ;
.
swa:shapeProperties
  a spin:MagicProperty ;
  spin:body [
      a sp:Select ;
      sp:distinct true ;
      sp:resultVariables (
          [
            sp:varName "predicate" ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "shape" ;
              ] ;
            sp:predicate swa:shapesForType ;
            sp:subject spin:_arg1 ;
          ]
          [
            a sp:TriplePath ;
            sp:object [
                sp:varName "propertyShape" ;
              ] ;
            sp:path [
                a sp:AltPath ;
                sp:path1 sh:property ;
                sp:path2 sh:parameter ;
              ] ;
            sp:subject [
                sp:varName "shape" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "predicate" ;
              ] ;
            sp:predicate sh:path ;
            sp:subject [
                sp:varName "propertyShape" ;
              ] ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:and ;
                sp:arg1 [
                    a sp:isIRI ;
                    sp:arg1 [
                        sp:varName "predicate" ;
                      ] ;
                  ] ;
                sp:arg2 [
                    a sp:exists ;
                    sp:elements (
                        [
                          sp:object [
                              sp:varName "group" ;
                            ] ;
                          sp:predicate sh:group ;
                          sp:subject [
                              sp:varName "propertyShape" ;
                            ] ;
                        ]
                      ) ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class to get the shape properties for." ;
    ] ;
  spin:private true ;
  spin:returnType rdf:Property ;
  rdfs:comment "Finds all predicates (in forward direction) that would be included into a swa:ResourceShapeFormSection or a swa:ClassShapeFormSection." ;
  rdfs:label "shape properties" ;
  rdfs:subClassOf spin:MagicProperties ;
.
swa:shapePropertiesOnForm
  a spin:MagicProperty ;
  spin:body [
      a sp:Select ;
      sp:distinct true ;
      sp:resultVariables (
          [
            sp:varName "predicate" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Union ;
            sp:elements (
                (
                  (
                    [
                      a sp:Filter ;
                      sp:expression [
                          a sp:bound ;
                          sp:arg1 spin:_arg1 ;
                        ] ;
                    ]
                  )
                  [
                    sp:object [
                        sp:varName "type" ;
                      ] ;
                    sp:predicate rdf:type ;
                    sp:subject spin:_arg1 ;
                  ]
                  [
                    sp:object [
                        sp:varName "predicate" ;
                      ] ;
                    sp:predicate swa:shapeProperties ;
                    sp:subject [
                        sp:varName "type" ;
                      ] ;
                  ]
                )
                (
                  (
                    (
                      [
                        a sp:Filter ;
                        sp:expression [
                            a sp:not ;
                            sp:arg1 [
                                a sp:bound ;
                                sp:arg1 spin:_arg1 ;
                              ] ;
                          ] ;
                      ]
                      [
                        a sp:Bind ;
                        sp:expression [
                            a swa:resourceType ;
                          ] ;
                        sp:variable [
                            sp:varName "type" ;
                          ] ;
                      ]
                    )
                    [
                      a sp:Filter ;
                      sp:expression [
                          a sp:bound ;
                          sp:arg1 [
                              sp:varName "type" ;
                            ] ;
                        ] ;
                    ]
                  )
                  [
                    sp:object [
                        sp:varName "predicate" ;
                      ] ;
                    sp:predicate swa:shapeProperties ;
                    sp:subject [
                        sp:varName "type" ;
                      ] ;
                  ]
                )
              ) ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject resource, or unbound to fall back to swa:resourceType()." ;
    ] ;
  spin:private true ;
  rdfs:label "shape properties on form" ;
  rdfs:subClassOf spin:MagicProperties ;
.
swa:shortestClassPropertyConstraintTreePath
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          (
            [
              sp:object [
                  sp:varName "constraint" ;
                ] ;
              sp:predicate sh:property ;
              sp:subject [
                  sp:varName "class" ;
                ] ;
            ]
            [
              sp:object [
                  sp:varName "predicate" ;
                ] ;
              sp:predicate sh:path ;
              sp:subject [
                  sp:varName "constraint" ;
                ] ;
            ]
            [
              a sp:Filter ;
              sp:expression [
                  a sp:isIRI ;
                  sp:arg1 [
                      sp:varName "predicate" ;
                    ] ;
                ] ;
            ]
          )
          [
            a sp:Bind ;
            sp:expression [
                a spif:shortestObjectsPath ;
                sp:arg1 [
                    sp:varName "class" ;
                  ] ;
                sp:arg2 rdfs:subClassOf ;
                sp:arg3 [
                    sp:varName "root" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "path" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:concat ;
                sp:arg1 [
                    sp:varName "path" ;
                  ] ;
                sp:arg2 " " ;
                sp:arg3 [
                    a sp:str ;
                    sp:arg1 [
                        sp:varName "predicate" ;
                      ] ;
                  ] ;
                sp:arg4 " " ;
                sp:arg5 [
                    a sp:if ;
                    sp:arg1 [
                        a sp:isIRI ;
                        sp:arg1 [
                            sp:varName "constraint" ;
                          ] ;
                      ] ;
                    sp:arg2 [
                        a sp:str ;
                        sp:arg1 [
                            sp:varName "constraint" ;
                          ] ;
                      ] ;
                    sp:arg3 [
                        a swa:bnodeId ;
                        arg:bnode [
                            sp:varName "constraint" ;
                          ] ;
                      ] ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:root ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The (optional) root of the tree." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:constraint ;
      spl:valueType sh:PropertyShape ;
      rdfs:comment "The property constraint to start at." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "A helper function used to find the shortest path from a property constraint to a root class. The property constraint needs to be connected to a class in the tree via sh:property." ;
  rdfs:label "shortest class property constraint tree path" ;
  rdfs:subClassOf swa:Functions ;
.
swa:shortestClassPropertyTreePath
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "class" ;
              ] ;
            sp:predicate swa:directRelevantPropertyOfClass ;
            sp:subject [
                sp:varName "property" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a spif:shortestObjectsPath ;
                sp:arg1 [
                    sp:varName "class" ;
                  ] ;
                sp:arg2 rdfs:subClassOf ;
                sp:arg3 [
                    sp:varName "root" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "path" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:concat ;
                sp:arg1 [
                    sp:varName "path" ;
                  ] ;
                sp:arg2 " " ;
                sp:arg3 [
                    a sp:str ;
                    sp:arg1 [
                        sp:varName "property" ;
                      ] ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:root ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The (optional) root of the tree." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property to start at." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "A helper function used to find the shortest path from a property to a root class. The property needs to be connected to a class in the tree via rdfs:domain." ;
  rdfs:label "shortest class property tree path" ;
  rdfs:subClassOf swa:Functions ;
.
swa:specialAddButtonFunction
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "functionName" ;
          ]
        ) ;
      sp:where (
          [
            a sp:NamedGraph ;
            sp:elements (
                [
                  sp:object [
                      sp:varName "functionName" ;
                    ] ;
                  sp:predicate swa:specialAddButtonFunctionName ;
                  sp:subject [
                      sp:varName "predicate" ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode ui:graph ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate being edited." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:subject ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject being edited." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Used by SWA edit widgets to determine whether the add button shall be redirected to a different JavaScript function call than the default behavior." ;
  rdfs:label "special add button function" ;
  rdfs:subClassOf swa:Functions ;
.
swa:specialAddButtonFunctionName
  a rdf:Property ;
  rdfs:comment "Can be used to specify that values of the associated property shall be added with the given JavaScript function. Used by the SPIN function swa:specialAddButtonFunction." ;
  rdfs:domain rdf:Property ;
  rdfs:label "special add button function name" ;
  rdfs:range xsd:string ;
  rdfs:subPropertyOf swa:systemProperty ;
.
swa:subjectFacetMenuName
  a rdf:Property ;
  rdfs:comment "Links a facet with a display name for drop down menus." ;
  rdfs:domain swa:SubjectFacetClass ;
  rdfs:label "subject facet menu name" ;
  rdfs:range xsd:string ;
  rdfs:subPropertyOf swa:systemProperty ;
.
swa:subjectHasObjectFromEnum
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            sp:object [
                sp:varName "predicate" ;
              ] ;
            sp:predicate swa:predicatesOfObjects ;
            sp:subject [
                sp:varName "view" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "any" ;
              ] ;
            sp:predicate [
                sp:varName "predicate" ;
              ] ;
            sp:subject [
                sp:varName "subject" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:subject ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject to check." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:view ;
      spl:valueType swa:ObjectsEnum ;
      rdfs:comment "The view (usually instance of swa:ObjectsEnum)." ;
    ] ;
  spin:private true ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks if a given subject has at least one object for any of the swa:Objects under the given root element." ;
  rdfs:label "subject has object from enum" ;
  rdfs:subClassOf swa:Functions ;
.
swa:subjectWidgetMiddleColumnClass
  a rdf:Property ;
  rdfs:domain swa:Mode ;
  rdfs:label "subject widget middle column class" ;
  rdfs:range swa:SubjectWidgetMiddleColumnClass ;
  rdfs:subPropertyOf swa:systemProperty ;
.
swa:subjectWidgetRowClass
  a rdf:Property ;
  rdfs:domain swa:Mode ;
  rdfs:label "object widget row class" ;
  rdfs:range swa:ObjectWidgetRowClass ;
  rdfs:subPropertyOf swa:systemProperty ;
.
swa:subjectWidgetWeight
  a rdf:Property ;
  rdfs:domain swa:SubjectWidgetClass ;
  rdfs:label "subject widget weight" ;
  rdfs:range swa:WeightedExpression ;
  rdfs:subPropertyOf swa:systemProperty ;
.
swa:superClassOfLimited
  a spin:MagicProperty ;
  spin:body [
      a sp:Select ;
      sp:limit "5000"^^xsd:long ;
      sp:resultVariables (
          [
            sp:varName "subClass" ;
          ]
        ) ;
      sp:where (
          [
            sp:object spin:_arg1 ;
            sp:predicate rdfs:subClassOf ;
            sp:subject [
                sp:varName "subClass" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The superclass." ;
    ] ;
  spin:private true ;
  spin:returnType rdfs:Class ;
  rdfs:comment "Gets the direct subclasses of a given class (arg1), but with a (random) LIMIT of 1000." ;
  rdfs:subClassOf spin:MagicProperties ;
.
swa:tabIndex
  a rdf:Property ;
  rdfs:comment "The index of a tab within its container. The lowest values (usually starting at 0) are further on the left." ;
  rdfs:domain swa:Tab ;
  rdfs:label "tab index" ;
  rdfs:range xsd:integer ;
.
swa:testClass
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "name" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a sp:concat ;
                sp:arg1 "test-" ;
                sp:arg2 [
                    a afn:localname ;
                    sp:arg1 [
                        sp:varName "resource" ;
                      ] ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "name" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The URI resource to encode." ;
    ] ;
  spin:private true ;
  spin:returnType xsd:string ;
  rdfs:comment "Generates a CSS class name that can be attached to input fields etc to make it easier for test cases to identify them." ;
  rdfs:label "test class" ;
  rdfs:subClassOf swa:Functions ;
.
swa:thumbnail
  a rdf:Property ;
  rdfs:comment "Links a resource with a thumbnail image that shall be used in summary views. Also serves as super-property of frequently used properties." ;
  rdfs:label "thumbnail" ;
  rdfs:range rdfs:Resource ;
.
swa:typeIcon
  a rdf:Property ;
  rdfs:comment "Can be attached to classes (e.g. owl:ObjectProperty) to point to the CSS style of an icon representing instances of that class. Among others, this info is used by SWA tree components. Note that the swa:typeIcon triples must be stored in a globally registered SWP graph, ending with .ui.*." ;
  rdfs:domain rdfs:Class ;
  rdfs:label "type icon" ;
  rdfs:range xsd:string ;
  rdfs:subPropertyOf swa:systemProperty ;
.
swa:typeIconFunctor
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            a sp:NamedGraph ;
            sp:elements (
                [
                  sp:object [
                      sp:varName "result" ;
                    ] ;
                  sp:predicate swa:typeIcon ;
                  sp:subject [
                      sp:varName "class" ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode ui:graph ;
          ]
        ) ;
    ] ;
  spin:private true ;
  spin:returnType xsd:string ;
  rdfs:comment "A functor that can be used to find the most specialized icon for a class and its superclasses." ;
  rdfs:label "type icon functor" ;
  rdfs:subClassOf swa:ClassFunctorFunctions ;
.
swa:typeLabelList
  a ui:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to get the types of." ;
    ] ;
  spin:private true ;
  spin:returnType xsd:string ;
  ui:prototype """
<ui:if ui:condition=\"{= EXISTS {
    ?resource a ?any .
} }\">
    <ui:group> (</ui:group>
    <ui:forEach ui:resultSet=\"{#
            SELECT ?label
            WHERE {
                ?resource a ?type .
                BIND (ui:label(?type) AS ?label) .
            }
            ORDER BY (?label) }\" ui:separator=\", \">{= ?label }</ui:forEach>
    <ui:group>)</ui:group>
</ui:if>
"""^^ui:Literal ;
  rdfs:comment "Creates a comma-separated list of the labels of the declared rdf:types of a given resource, wrapped by (...). Returns an empty string if the resource has no type." ;
  rdfs:label "type label list" ;
  rdfs:subClassOf ui:Functions ;
.
swa:updateSecureStorage
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:value ;
      spl:valueType xsd:string ;
      rdfs:comment "The value to store for the key." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:key ;
      spl:valueType xsd:string ;
      rdfs:comment "The key." ;
    ] ;
  ui:private true ;
  rdfs:comment "Updates a key/value pair in TopBraid's secure storage." ;
  rdfs:label "update secure storage" ;
  rdfs:subClassOf ui:ControlElement ;
.
swa:used
  a rdf:Property ;
  rdfs:comment "Internal system property used by some algorithm(s) to mark that certain properties have been used on a form." ;
  rdfs:label "used" ;
  rdfs:subPropertyOf swa:systemProperty ;
.
swa:visited
  a rdf:Property ;
  rdfs:comment "Used by swa:ResourceDestructor to remember which resources it has alread \"seen\"." ;
  rdfs:label "visited" ;
  rdfs:range rdfs:Resource ;
  rdfs:subPropertyOf swa:systemProperty ;
.
swa:weight
  a rdf:Property ;
  rdfs:domain swa:WeightedExpression ;
  rdfs:label "weight" ;
  rdfs:range xsd:integer ;
  rdfs:subPropertyOf swa:systemProperty ;
.
html:blanknodeid
  a html:Attribute ;
  rdfs:label "blanknodeid" ;
  rdfs:subPropertyOf html:attributes ;
.
html:layoutfunction
  a html:Attribute ;
  rdfs:label "layout function" ;
  rdfs:subPropertyOf html:attributes ;
.
html:searchGraph
  a html:Attribute ;
  rdfs:label "search graph" ;
  rdfs:subPropertyOf html:attributes ;
.
html:swacontext
  a html:Attribute ;
  rdfs:subPropertyOf html:attributes ;
.
html:treedataprovider
  a html:Attribute ;
  rdfs:label "tree data provider" ;
  rdfs:subPropertyOf html:attributes ;
.
html:treeroot
  a html:Attribute ;
  rdfs:label "tree root" ;
  rdfs:subPropertyOf html:attributes ;
.
html:uicontext
  a html:Attribute ;
  rdfs:label "uicontext" ;
  rdfs:subPropertyOf html:attributes ;
.
html:updatelink
  a html:Attribute ;
  rdfs:label "updatelink" ;
  rdfs:subPropertyOf html:attributes ;
.
ui:Element
  ui:instanceView """
<swa:ArgumentsFormBody arg:resource=\"{= ?this }\" ui:id=\"form\"/>
"""^^ui:Literal ;
.
ui:SubjectWidgetRowClass
  a rdfs:Class ;
  rdfs:label "Subject widget row class" ;
  rdfs:subClassOf ui:NodeClass ;
.
ui:view
  swa:hiddenProperty "if no object exists" ;
.
rdf:HTML
  swa:datatypeIconCSS "swa-icon-literal-html" ;
.
rdf:Property
  swa:typeIcon "swa-icon-property" ;
  ui:instanceView """
<swa:PropertyFormBody arg:resource=\"{= ?this }\" ui:id=\"form\" ui:priority=\"{= -9 }\"/>
"""^^ui:Literal ;
.
rdf:value
  swa:hiddenProperty "if no object exists" ;
.
rdfs:Class
  swa:typeIcon "swa-icon-class" ;
  ui:instanceView """
<swa:ClassDestructor arg:resource=\"{= ?this }\" ui:id=\"destructor\"/>
"""^^ui:Literal ;
  ui:instanceView """
<swa:ClassFormBody arg:resource=\"{= ?this }\" ui:id=\"form\" ui:priority=\"{= -9 }\"/>
"""^^ui:Literal ;
  ui:instanceView """
<ui:group ui:id=\"datatables-results\" ui:priority=\"{= -9 }\">
    <swa:SimpleDataTableResults arg:frozen=\"{= ?frozen }\" ui:args=\"*\"/>
</ui:group>
"""^^ui:Literal ;
.
rdfs:Resource
  search:facetedSearch search:DefaultSearch ;
  swa:typeIcon "swa-icon-resource" ;
  ui:instanceView """
<swa:DefaultDestructor arg:resource=\"{= ?this }\" ui:id=\"destructor\"/>
"""^^ui:Literal ;
  ui:instanceView """
<swa:ResourceFormBody arg:resource=\"{= ?this }\" ui:id=\"form\" ui:priority=\"{= -9 }\"/>
"""^^ui:Literal ;
  ui:instanceView """
<swa:TitledForm arg:resource=\"{= ?this }\" ui:priority=\"{= -9 }\"/>
"""^^ui:Literal ;
  ui:instanceView """
<ui:group ui:id=\"datatables-results\" ui:priority=\"{= -9 }\">
    <swa:SimpleDataTableResults arg:frozen=\"{= ?frozen }\" ui:args=\"*\"/>
</ui:group>
"""^^ui:Literal ;
  ui:instanceView """
<ui:group ui:id=\"label\" ui:priority=\"{= -5 }\">{= ui:label(?this) }</ui:group>
"""^^ui:Literal ;
  ui:instanceView """
<ui:group ui:id=\"results-table-config\" ui:priority=\"{= -9 }\">
    <swon:Array>
        <swon:Object>
            <swon:Value arg:name=\"createService\" arg:value=\"{= swa:CreateResourceDialogBodyForAssetCollection }\"/>
            <swon:Value arg:name=\"createResourceHandler\" arg:value=\"{= swa:CreateResourceHandler }\"/>
            <swon:Value arg:name=\"isDefault\">
                <swon:Literal arg:value=\"{= true }\"/>
            </swon:Value>
        </swon:Object>
    </swon:Array>
</ui:group>
"""^^ui:Literal ;
.
rdfs:comment
  swa:hiddenProperty "if no object exists" ;
  rdfs:subPropertyOf swa:description ;
.
rdfs:isDefinedBy
  swa:hiddenProperty "if no object exists" ;
.
rdfs:label
  swa:hiddenProperty "if no object exists" ;
.
rdfs:member
  swa:hiddenProperty true ;
.
rdfs:seeAlso
  swa:hiddenProperty "if no object exists" ;
.
xsd:boolean
  swa:datatypeIconCSS "swa-icon-literal-boolean" ;
.
xsd:date
  swa:datatypeIconCSS "swa-icon-literal-date" ;
.
xsd:dateTime
  swa:datatypeIconCSS "swa-icon-literal-dateTime" ;
.
xsd:double
  swa:datatypeIconCSS "swa-icon-literal-double" ;
.
xsd:float
  swa:datatypeIconCSS "swa-icon-literal-float" ;
.
xsd:integer
  swa:datatypeIconCSS "swa-icon-literal-integer" ;
.
xsd:string
  swa:datatypeIconCSS "swa-icon-literal-string" ;
.
owl:DatatypeProperty
  swa:typeIcon "swa-icon-datatype-property" ;
.
owl:ObjectProperty
  swa:typeIcon "swa-icon-object-property" ;
.
owl:annotatedProperty
  swa:hiddenProperty true ;
.
owl:annotatedSource
  swa:hiddenProperty true ;
.
owl:annotatedTarget
  swa:hiddenProperty true ;
.
owl:bottomDataProperty
  swa:hiddenProperty true ;
.
owl:bottomObjectProperty
  swa:hiddenProperty true ;
.
owl:deprecated
  swa:hiddenProperty "if no object exists" ;
.
owl:differentFrom
  swa:hiddenProperty "if no object exists" ;
.
owl:members
  swa:hiddenProperty true ;
.
owl:sameAs
  swa:hiddenProperty "if no object exists" ;
.
owl:topDataProperty
  swa:hiddenProperty true ;
.
owl:topObjectProperty
  swa:hiddenProperty true ;
.
owl:versionInfo
  swa:hiddenProperty "if no object exists" ;
.
skos:Concept
  swa:typeIcon "swa-icon-concept" ;
.
skos:definition
  rdfs:subPropertyOf swa:description ;
.
skos:semanticRelation
  swa:hiddenProperty true ;
.
sh:PropertyShape
  ui:instanceView """
<swa:PropertyShapeFormBody arg:resource=\"{= ?this }\" ui:id=\"form\"/>
"""^^ui:Literal ;
.
foaf:depiction
  a rdf:Property ;
  rdfs:label "depiction" ;
  rdfs:subPropertyOf swa:thumbnail ;
.
