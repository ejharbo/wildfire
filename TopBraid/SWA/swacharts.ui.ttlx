# baseURI: http://topbraid.org/swacharts
# imports: http://topbraid.org/swa

@prefix adminguide: <http://server.topbraidlive.org/doc/adminguide#> .
@prefix afn: <http://jena.hpl.hp.com/ARQ/function#> .
@prefix arg: <http://spinrdf.org/arg#> .
@prefix cfg: <http://server.topbraidlive.org/web/2009/config#> .
@prefix charts: <http://uispin.org/charts#> .
@prefix composite: <http://www.topbraid.org/2007/05/composite.owl#> .
@prefix css: <http://uispin.org/css#> .
@prefix daml: <http://www.daml.org/2001/03/daml+oil#> .
@prefix dash: <http://datashapes.org/dash#> .
@prefix dc: <http://purl.org/dc/elements/1.1/> .
@prefix dcterms: <http://purl.org/dc/terms/> .
@prefix default: <http://uispin.org/default#> .
@prefix email: <http://topbraid.org/email#> .
@prefix fn: <http://www.w3.org/2005/xpath-functions#> .
@prefix foaf: <http://xmlns.com/foaf/0.1/> .
@prefix geo: <http://www.w3.org/2003/01/geo/wgs84_pos#> .
@prefix graphql: <http://datashapes.org/graphql#> .
@prefix html: <http://uispin.org/html#> .
@prefix imported: <http://topbraid.org/imported#> .
@prefix json: <http://topbraid.org/json#> .
@prefix let: <http://uispin.org/let#> .
@prefix letrs: <http://uispin.org/letrs#> .
@prefix list: <http://jena.hpl.hp.com/ARQ/list#> .
@prefix metadata: <http://topbraid.org/metadata#> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix raci: <http://topbraid.org/raci#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix sd: <http://www.w3.org/ns/sparql-service-description#> .
@prefix search: <http://topbraid.org/search#> .
@prefix search.spin: <http://topbraid.org/search.spin#> .
@prefix sh: <http://www.w3.org/ns/shacl#> .
@prefix sioc: <http://rdfs.org/sioc/ns#> .
@prefix skos: <http://www.w3.org/2004/02/skos/core#> .
@prefix skosapp: <http://evn.topbraidlive.org/uiplugins#> .
@prefix skostemplate: <http://topbraid.org/spin/skostemplates#> .
@prefix skosxl: <http://www.w3.org/2008/05/skos-xl#> .
@prefix sm: <http://topbraid.org/sparqlmotion#> .
@prefix smf: <http://topbraid.org/sparqlmotionfunctions#> .
@prefix sml: <http://topbraid.org/sparqlmotionlib#> .
@prefix solr: <http://topbraid.org/solr#> .
@prefix sp: <http://spinrdf.org/sp#> .
@prefix sparqlmotionlib-swp: <http://topbraid.org/sparqlmotionlib-swp#> .
@prefix sparqlmotionlib-tbc: <http://topbraid.org/sparqlmotionlib-tbc#> .
@prefix spell: <http://topbraid.org/spellcheckresults#> .
@prefix spif: <http://spinrdf.org/spif#> .
@prefix spin: <http://spinrdf.org/spin#> .
@prefix spl: <http://spinrdf.org/spl#> .
@prefix spl-dynamic-ranges: <http://spinrdf.org/spl-dynamic-ranges#> .
@prefix spr: <http://spinrdf.org/spr#> .
@prefix spra: <http://spinrdf.org/spra#> .
@prefix style: <http://uispin.org/style#> .
@prefix svg: <http://uispin.org/svg#> .
@prefix swa: <http://topbraid.org/swa#> .
@prefix swaclasses: <http://topbraid.org/swaclasses#> .
@prefix swaeditor: <http://topbraid.org/swaeditor#> .
@prefix swaowl: <http://topbraid.org/swaowl#> .
@prefix swashacl: <http://topbraid.org/swashacl#> .
@prefix swauml: <http://topbraid.org/swauml#> .
@prefix swon: <http://uispin.org/swon#> .
@prefix sxml: <http://topbraid.org/sxml#> .
@prefix tables: <http://topbraid.org/tables#> .
@prefix task: <http://topbraid.org/task#> .
@prefix tasks: <http://topbraid.org/tasks#> .
@prefix tbl: <http://topbraidlive.org/functions#> .
@prefix teamwork: <http://topbraid.org/teamwork#> .
@prefix tops: <http://www.topbraid.org/tops#> .
@prefix tosh: <http://topbraid.org/tosh#> .
@prefix tosh.ui: <http://topbraid.org/tosh.ui#> .
@prefix ui: <http://uispin.org/ui#> .
@prefix uix: <http://topbraidlive.org/uix#> .
@prefix vs: <http://www.w3.org/2003/06/sw-vocab-status/ns#> .
@prefix wot: <http://xmlns.com/wot/0.1/> .
@prefix xlink: <http://www.w3.org/1999/xlink#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

arg:colIndex
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:colName
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:dataLabels
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:data_endpoint
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:diameter
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:horizontal
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:inputQueryString
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:jsLibrary
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:maxTime
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:maxXValue
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:minTime
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:minValue
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:minXValue
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:noFractions
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:onDataClick
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:placement
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:queryString
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:renderer
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:rs
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:seriesColors
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:seriesLabels
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:showLegend
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:sliceMargin
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:stackedSeries
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:subjectArea
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:xaxisLabel
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:yaxisLabel
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
swa:AbstractAxialChart
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:minValue ;
      rdfs:comment "An optional minimum value for the value axis." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:noFractions ;
      spl:valueType xsd:boolean ;
      rdfs:comment "If true then numbers will be printed without fractions, e.g. \"4.2\" becomes \"4\"." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:onDataClick ;
      spl:valueType xsd:string ;
      rdfs:comment "A JavaScript snippet that shall be called when the user clicks on a section of the chart that represents some data. In this snippet, the JavaScript variable \"value\" contains the numeric value and the variable \"resource\" will contain the value of the ?resource column, if present. The variable \"series\" contains the series index, i.e. 1 for the first value (?value1), 2 for the second (?value2) etc." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:seriesLabels ;
      spl:valueType xsd:string ;
      rdfs:comment "A comma-separated list of labels for the series, used by the legend. For example, \"A, B\" would mean that ?value1 represents \"A\" and ?value2 represents \"B\"." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:xaxisLabel ;
      spl:valueType xsd:string ;
      rdfs:comment "The label of the x axis." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:yaxisLabel ;
      spl:valueType xsd:string ;
      rdfs:comment "The label of the y axis." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resultSet ;
      spl:valueType sp:Select ;
      rdfs:comment "The result set (SPARQL SELECT query) delivering the data. The result variable ?value must contain the numeric values.  The second, optional, result variable ?label may contain the label for each row. The optional third column ?resource may point to a context resource that can later be queried by events. It is also possible to display multiple series, if the variables are called ?value1, ?value2, ..." ;
    ] ;
  ui:abstract true ;
  rdfs:comment "Base class of chart types that align with the x or y axis." ;
  rdfs:label "Abstract axial chart" ;
  rdfs:subClassOf swa:AbstractChart ;
.
swa:AbstractChart
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:height ;
      spl:valueType xsd:integer ;
      rdfs:comment "The height of the chart in pixels." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:seriesColors ;
      spl:valueType xsd:string ;
      rdfs:comment """An optional JS array of colors in a syntax such as

['#85802b', '#00749F', '#73C774', '#C7754C', '#17BDB8']""" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:showLegend ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to display a legend that explains the color coding with the labels from the result set." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:title ;
      spl:valueType xsd:string ;
      rdfs:comment "An (optional) title of the chart." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:width ;
      spl:valueType xsd:integer ;
      rdfs:comment "The width of the chart in pixels." ;
    ] ;
  ui:abstract true ;
  rdfs:comment "Abstract base class for the main chart elements. This base class defines shared arguments such as width and height." ;
  rdfs:label "Abstract chart" ;
  rdfs:subClassOf swa:ChartElements ;
.
swa:AbstractPieChart
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:dataLabels ;
      spl:valueType xsd:string ;
      rdfs:comment """Defines what text goes into each slice. Valid options include:
\"label\": Show the slice labels from the result set
\"value\": Show the numeric value from the result set
\"percent\": Show the value with a % sign behind it.

If left empty, no text will be displayed.""" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:diameter ;
      spl:valueType xsd:integer ;
      rdfs:comment "The diameter of the chart in pixels. If left empty, a suitable default will be used." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:onDataClick ;
      spl:valueType xsd:string ;
      rdfs:comment "A JavaScript snippet that shall be called when the user clicks on a slice. In this snippet, the JavaScript variable \"value\" contains the numeric value and (if present) the variable \"label\" will contain the label. If present in the result set, the variable \"resource\" will contain the value of the ?resource column." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resultSet ;
      spl:valueType sp:Select ;
      rdfs:comment "The result set (SPARQL SELECT query) delivering the data. Each row of that result set represents one slice of the chart. The result variable (column) ?value (or the first column) must contain the numeric size of each slice.  The numeric values must not be negative, but do not necessarily have to add up to 100. The result variable ?label (or the second column) must contain the label of each slice. The optional column ?resource (or third column) may point to a context resource that can later be queried by events using the JavaScript variable resource. For donut charts with multiple rings, use ?value1, ?value2 etc." ;
    ] ;
  ui:abstract true ;
  rdfs:comment "Shared base class of Pie and Donut charts." ;
  rdfs:label "Abstract pie chart" ;
  rdfs:subClassOf swa:AbstractChart ;
.
swa:AbstractPieChartImpl
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:sliceMargin ;
      spl:valueType xsd:integer ;
      rdfs:comment "The optional sliceMargin." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:jsLibrary ;
      spl:valueType xsd:string ;
      rdfs:comment "The required JS library." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:renderer ;
      spl:valueType xsd:string ;
      rdfs:comment "The renderer class." ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:group let:id=\"{= ui:uniqueId() }\">
    <swa:RequireChartPlugin arg:name=\"{= ?jsLibrary }\"/>
    <swa:RequireChartPlugin arg:name=\"pointLabels\"/>
    <swa:ChartPlaceholderDiv ui:args=\"*\"/>
    <script>$.jqplot(\"{= ?id }\",<swon:Array>
            <swa:PieChartDataArrays arg:resultSet=\"{= ?resultSet }\"/>
        </swon:Array>,<swon:Object>
            <swa:ChartTitleSetter arg:title=\"{= ?title }\"/>
            <swa:ChartColorsSetter arg:seriesColors=\"{= ?seriesColors }\"/>
            <swon:Value arg:name=\"seriesDefaults\">
                <swon:Object>
                    <swon:Value arg:name=\"renderer\">{= ?renderer }</swon:Value>
                    <swon:Value arg:name=\"rendererOptions\">
                        <swon:Object>
                            <ui:if ui:condition=\"{= bound(?dataLabels) }\">
                                <swon:Value arg:name=\"showDataLabels\" arg:value=\"true\"/>
                                <swon:Value arg:name=\"dataLabels\" arg:value=\"{= ?dataLabels }\"/>
                            </ui:if>
                            <ui:if ui:condition=\"{= bound(?diameter) }\">
                                <swon:Value arg:name=\"diameter\" arg:value=\"{= ?diameter }\"/>
                            </ui:if>
                            <ui:if ui:condition=\"{= bound(?sliceMargin) }\">
                                <swon:Value arg:name=\"sliceMargin\" arg:value=\"{= ?sliceMargin }\"/>
                            </ui:if>
                        </swon:Object>
                    </swon:Value>
                </swon:Object>
            </swon:Value>
            <swa:ChartLegend ui:args=\"*\"/>
        </swon:Object>);
		<ui:if ui:condition=\"{= bound(?onDataClick) }\">$(\"#{= ?id }\").bind(\"jqplotDataClick\", function(event, series, pointIndex, data) { var label = data[0]; var value = data.length &gt; 1 ? data[1] : null; var resource = data.length &gt; 2 ? data[2] : null; {= ?onDataClick } });</ui:if>
    </script>
</ui:group>
"""^^ui:Literal ;
  rdfs:label "Abstract pie chart impl" ;
  rdfs:subClassOf swa:AbstractPieChart ;
.
swa:AbstractVictoryChart
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:data_endpoint ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:subjectArea ;
      spl:valueType rdfs:Resource ;
    ] ;
  rdfs:subClassOf swa:VictoryChartElements ;
.
swa:BarChart
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:horizontal ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to display the bars side to side (default is vertical)." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:stackedSeries ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to have the series (?value1, ?value2, ...) stacked on top of each other instead of (default) side by side." ;
    ] ;
  ui:prototype """
<ui:group let:id=\"{= ui:uniqueId() }\">
    <swa:RequireChartPlugin arg:name=\"barRenderer\"/>
    <swa:RequireChartPlugin arg:name=\"categoryAxisRenderer\"/>
    <swa:RequireChartPlugin arg:name=\"pointLabels\"/>
    <swa:ChartPlaceholderDiv ui:args=\"*\"/>
    <script>$.jqplot(\"{= ?id }\",<swon:Array>
            <swa:ValueColumnArrays arg:resultSet=\"{= ?resultSet }\"/>
        </swon:Array>,<swon:Object>
            <swa:ChartTitleSetter arg:title=\"{= ?title }\"/>
            <swa:ChartColorsSetter arg:seriesColors=\"{= ?seriesColors }\"/>
            <ui:if ui:condition=\"{= ?stackedSeries }\">
                <swon:Value arg:name=\"stackSeries\">true</swon:Value>
            </ui:if>
            <swon:Value arg:name=\"seriesDefaults\">
                <swon:Object>
                    <swon:Value arg:name=\"renderer\">$.jqplot.BarRenderer</swon:Value>
                    <swon:Value arg:name=\"pointLabels\">
                        <swon:Object>
                            <swon:Value arg:name=\"show\">true</swon:Value>
                            <ui:if ui:condition=\"{= ?noFractions }\">
                                <swon:Value arg:name=\"formatString\" arg:value=\"%d\"/>
                            </ui:if>
                        </swon:Object>
                    </swon:Value>
                    <swon:Value arg:name=\"rendererOptions\">
                        <swon:Object>
                            <ui:if ui:condition=\"{= ?horizontal }\">
                                <swon:Value arg:name=\"barDirection\" arg:value=\"horizontal\"/>
                            </ui:if>
                        </swon:Object>
                    </swon:Value>
                </swon:Object>
            </swon:Value>
            <swa:ChartAxes ui:args=\"*\"/>
            <swa:ChartSeriesLabels ui:args=\"*\"/>
            <swa:ChartLegend arg:placement=\"outsideGrid\" ui:args=\"*\"/>
        </swon:Object>);
		<swa:ChartOnDataClickHandler ui:args=\"*\"/>
    </script>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "Displays a bar chart where each bar represents one row of a given result set." ;
  rdfs:label "Bar chart" ;
  rdfs:subClassOf swa:AbstractAxialChart ;
.
swa:ChartAxes
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:horizontal ;
      spl:valueType xsd:boolean ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:maxXValue ;
      rdfs:comment "The maximum value of the X axis." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:minValue ;
      rdfs:comment "An optional minimum value for the value axis." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:minXValue ;
      rdfs:comment "The minimum value on the X axis." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:renderer ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional jqPlot renderer name." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:xaxisLabel ;
      spl:valueType xsd:string ;
      rdfs:comment "The label of the x axis." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:yaxisLabel ;
      spl:valueType xsd:string ;
      rdfs:comment "The label of the y axis." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resultSet ;
      spl:valueType sp:Select ;
    ] ;
  ui:private true ;
  ui:prototype """
<swon:Value arg:name=\"axes\" let:h=\"{= bound(?horizontal) &amp;&amp; ?horizontal }\">
    <swon:Object let:raLabel=\"{= IF(?h, ?yaxisLabel, ?xaxisLabel) }\" let:vaLabel=\"{= IF(?h, ?xaxisLabel, ?yaxisLabel) }\">
        <swon:Value arg:name=\"{= IF(?h, &quot;yaxis&quot;, &quot;xaxis&quot;) }\">
            <swon:Object>
                <swon:Value arg:name=\"renderer\">$.jqplot.{= COALESCE(?renderer, \"CategoryAxisRenderer\") }</swon:Value>
                <ui:if ui:condition=\"{= bound(?raLabel) }\">
                    <swon:Value arg:name=\"label\" arg:value=\"{= ?raLabel }\"/>
                </ui:if>
                <ui:if ui:condition=\"{= swa:hasLabelColumn(?resultSet) }\">
                    <swon:Value arg:name=\"ticks\">
                        <swa:LabelColumnArray arg:resultSet=\"{= ?resultSet }\"/>
                    </swon:Value>
                </ui:if>
                <ui:if ui:condition=\"{= bound(?minXValue) }\">
                    <swon:Value arg:name=\"min\" arg:value=\"{= ?minXValue }\"/>
                </ui:if>
                <ui:if ui:condition=\"{= bound(?maxXValue) }\">
                    <swon:Value arg:name=\"max\" arg:value=\"{= ?maxXValue }\"/>
                </ui:if>
            </swon:Object>
        </swon:Value>
        <ui:if ui:condition=\"{= bound(?vaLabel) || bound(?minValue) }\">
            <swon:Value arg:name=\"{= IF(?h, &quot;xaxis&quot;, &quot;yaxis&quot;) }\">
                <swon:Object>
                    <ui:if ui:condition=\"{= bound(?vaLabel) }\">
                        <swon:Value arg:name=\"label\" arg:value=\"{= ?vaLabel }\"/>
                    </ui:if>
                    <swon:Value arg:name=\"min\" arg:value=\"{= ?minValue }\"/>
                </swon:Object>
            </swon:Value>
        </ui:if>
    </swon:Object>
</swon:Value>
"""^^ui:Literal ;
  rdfs:subClassOf swa:InternalChartElements ;
.
swa:ChartBuilderDialog
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:loadId ;
      spl:valueType xsd:string ;
      rdfs:comment "The load id." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:queryString ;
      spl:valueType xsd:string ;
      rdfs:comment "The base SELECT query." ;
    ] ;
  ui:prototype """
<ui:group>
    <div class=\"swa-padding-zero\" id=\"div-{= ?loadId }\" title=\"Chart Builder\">
        <swa:ChartBuilderPanel arg:inputQueryString=\"{= ?queryString }\"/>
    </div>
</ui:group>
"""^^ui:Literal ;
  rdfs:label "Chart builder dialog" ;
  rdfs:subClassOf swa:DialogElements ;
  rdfs:subClassOf swa:InternalChartElements ;
.
swa:ChartBuilderGadgetWindow
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:resourceSelectedEvent ;
      spl:valueType xsd:string ;
      rdfs:comment "The event to fire if the user clicks on a resource on the chart." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:queryString ;
      spl:valueType xsd:string ;
      rdfs:comment "The query string, e.g. produces by a search form." ;
    ] ;
  ui:prototype """
<swa:Window arg:closable=\"{= true }\" arg:title=\"Chart Builder\" ui:args=\"*\">
    <swa:ChartBuilderPanel arg:inputQueryString=\"{= ?queryString }\" arg:resourceSelectedEvent=\"{= ?resourceSelectedEvent }\"/>
</swa:Window>
"""^^ui:Literal ;
  rdfs:comment "A Window that can be dynamically loaded into an existing application." ;
  rdfs:label "Chart builder gadget window" ;
  rdfs:subClassOf swa:GadgetWindows ;
.
swa:ChartBuilderPanel
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:resourceSelectedEvent ;
      spl:valueType xsd:string ;
      rdfs:comment "The event to fire when the user clicks on a resource's area of the chart." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:inputQueryString ;
      spl:valueType xsd:string ;
      rdfs:comment "The original SPARQL query string." ;
    ] ;
  ui:private true ;
  ui:prototype """
<div class=\"ui-layout-content\" let:id=\"{= ui:uniqueId() }\">
    <script>var queryString{= ?id } = null; // Possibly changed by edit dialog</script>
    <div class=\"swa-chart-builder-panel-padding-eight\">
        <span>Chart Type: </span>
        <select class=\"form-control\" id=\"select{= ?id }\" onchange=\"swa.reloadChartPanel('{= ?id }', queryString{= ?id } ? queryString{= ?id } : &quot;{= ui:escapeJSON(swa:htmlEscapeAngularBrackets(?inputQueryString)) }&quot;)\">
            <option>Select...</option>
            <ui:forEach ui:resultSet=\"{#
                    SELECT ?chartClass ?label
                    WHERE {
                        GRAPH ui:graph {
                            ?chartClass (rdfs:subClassOf)* swa:AbstractChart .
                            FILTER NOT EXISTS {
                                ?chartClass ui:abstract true .
                            } .
                            FILTER NOT EXISTS {
                                ?chartClass ui:private true .
                            } .
                            FILTER (?chartClass NOT IN (swa:TimelineChart)) .
                            BIND (ui:label(?chartClass) AS ?label) .
                        } .
                    }
                    ORDER BY (?label) }\">
                <option selected=\"{= IF((?chartClass = ?defaultChartClass), &quot;selected&quot;, ?none) }\" value=\"{= ?chartClass }\">{= ?label }</option>
            </ui:forEach>
        </select>
        <swa:Space/>
        <swa:Space/>
        <swa:Space/>
        <button class=\"btn btn-default btn-xs\" onclick=\"swa.openChartQueryEditorDialog('{= ?id }', queryString{= ?id } ? queryString{= ?id } : &quot;{= ui:escapeJSON(swa:htmlEscapeAngularBrackets(?inputQueryString)) }&quot;)\">Edit Query...</button>
    </div>
    <ui:loadable class=\"swa-chart-builder-panel-padding-eight\" ui:loadId=\"load{= ?id }\">
        <ui:if ui:condition=\"{= bound(?chartClass) }\">
            <ui:call ui:queryString=\"{= ?queryString }\">
                <ui:if ui:condition=\"{= smf:isBound(spr:colWithName(?rs, &quot;value1&quot;)) }\">
                    <ui:dynamicView arg:dataLabels=\"value\" arg:height=\"400\" arg:onDataClick=\"{= IF(bound(?resourceSelectedEvent), swa:publishEvent(?resourceSelectedEvent, &quot;resource&quot;), ?none) }\" arg:resultSet=\"{= ?rs }\" arg:showLegend=\"true\" arg:width=\"620\" ui:class=\"{= ?chartClass }\"/>
                </ui:if>
                <ui:else>
                    <div class=\"swa-error\">
                        <p>Error: Query needs to define a result column called ?value1.</p>
                        <p>If this query has been generated from the search form, make sure you select at least one (numeric) property with a checkbox.</p>
                    </div>
                </ui:else>
            </ui:call>
        </ui:if>
        <ui:else>
            <div class=\"swa-chart-builder-panel-height-one-hundred\"/>
        </ui:else>
    </ui:loadable>
</div>
"""^^ui:Literal ;
  rdfs:label "Chart builder panel" ;
  rdfs:subClassOf swa:InternalChartElements ;
.
swa:ChartColorsSetter
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:seriesColors ;
      spl:valueType xsd:string ;
      rdfs:comment """An optional JS array of colors in a syntax such as

['#85802b', '#00749F', '#73C774', '#C7754C', '#17BDB8']""" ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:if ui:condition=\"{= bound(?seriesColors) }\">
    <swon:Value arg:name=\"seriesColors\">{= ?seriesColors }</swon:Value>
</ui:if>
"""^^ui:Literal ;
  rdfs:subClassOf swa:InternalChartElements ;
.
swa:ChartDataElements
  a ui:NodeClass ;
  ui:abstract true ;
  ui:private true ;
  rdfs:comment "Abstract base class for SWP elements that produce a data array consumable by the SWA chart components (jqPlot)." ;
  rdfs:subClassOf swa:InternalChartElements ;
.
swa:ChartElements
  a ui:NodeClass ;
  ui:abstract true ;
  rdfs:comment "Abstract base class of all SWA Charts components." ;
  rdfs:subClassOf swa:Elements ;
.
swa:ChartFunctions
  a spin:Function ;
  spin:abstract true ;
  rdfs:label "Chart functions" ;
  rdfs:subClassOf swa:Functions ;
.
swa:ChartLegend
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:placement ;
      spl:valueType xsd:string ;
      rdfs:comment "The placement value used by the jqPlot API." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:showLegend ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to show the legend." ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:if ui:condition=\"{= ?showLegend }\">
    <swon:Value arg:name=\"legend\">
        <swon:Object>
            <swon:Value arg:name=\"show\" arg:value=\"true\"/>
            <swon:Value arg:name=\"location\" arg:value=\"e\"/>
            <ui:if ui:condition=\"{= bound(?placement) }\">
                <swon:Value arg:name=\"placement\" arg:value=\"{= ?placement }\"/>
            </ui:if>
        </swon:Object>
    </swon:Value>
</ui:if>
"""^^ui:Literal ;
  rdfs:label "Chart legend" ;
  rdfs:subClassOf swa:InternalChartElements ;
.
swa:ChartOnDataClickHandler
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:onDataClick ;
      spl:valueType xsd:string ;
      rdfs:comment "The JS snippet to execute (if bound)." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:id ;
      spl:valueType xsd:string ;
      rdfs:comment "The id of the placeholder div." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resultSet ;
      spl:valueType sp:Select ;
      rdfs:comment "The result set to operate on." ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:if ui:condition=\"{= bound(?onDataClick) }\">
    <ui:if ui:condition=\"{= swa:hasResourceColumn(?resultSet) }\">var resources{= ?id }=<swa:ResourceColumnArray arg:resultSet=\"{= ?resultSet }\"/>;</ui:if>$(\"#{= ?id }\").bind(\"jqplotDataClick\", function(event, seriesIndex, pointIndex, data) {<ui:if ui:condition=\"{= swa:hasResourceColumn(?resultSet) }\">var resource = resources{= ?id }[data[0] - 1];</ui:if>var value = data[1];var series = seriesIndex + 1;{= ?onDataClick } });</ui:if>
"""^^ui:Literal ;
  rdfs:label "Chart on data click handler" ;
  rdfs:subClassOf swa:InternalChartElements ;
.
swa:ChartPlaceholderDiv
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:height ;
      spl:valueType xsd:integer ;
      rdfs:comment "The height in pixels." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:width ;
      spl:valueType xsd:integer ;
      rdfs:comment "The width in pixels." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:id ;
      spl:valueType xsd:string ;
      rdfs:comment "The id of the div." ;
    ] ;
  ui:private true ;
  ui:prototype """
<div id=\"{= ?id }\" style=\"{= IF(bound(?width), CONCAT(&quot;width:&quot;, xsd:string(?width), &quot;px;&quot;), ?none) }{= IF(bound(?height), CONCAT(&quot;height:&quot;, xsd:string(?height), &quot;px;&quot;), ?none) }\"/>
"""^^ui:Literal ;
  rdfs:subClassOf swa:InternalChartElements ;
.
swa:ChartQueryEditorDialog
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:id ;
      spl:valueType xsd:string ;
      rdfs:comment "The id used by the surrounding dialog." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:loadId ;
      spl:valueType xsd:string ;
      rdfs:comment "The load id." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:queryString ;
      spl:valueType xsd:string ;
      rdfs:comment "The current SELECT query." ;
    ] ;
  ui:prototype """
<div class=\"swa-chart-builder-panel-padding-eight\" id=\"div-{= ?loadId }\" title=\"Chart Query Editor\">
    <div>SPARQL Query:</div>
    <textarea class=\"form-control swa-chart-query-editor-dialog-textarea\" id=\"textarea{= ?id }\" rows=\"10\">{= ?queryString }</textarea>
    <div class=\"swa-color-grey\">Use <b>?value1, ?value2</b> for the value column(s), <b>?label</b> for the display labels, and <b>?resource</b> (optional) for the click-through resources.</div>
    <div>
        <div class=\"swa-float-right\">
            <button class=\"btn btn-default btn-xs\" onclick=\"queryString{= ?id } = $('#textarea{= ?id }').val();swa.closeDialog('{= ?loadId }');swa.reloadChartPanel('{= ?id }', queryString{= ?id });\">OK</button>
        </div>
    </div>
</div>
"""^^ui:Literal ;
  rdfs:label "Chart query editor dialog" ;
  rdfs:subClassOf swa:DialogElements ;
  rdfs:subClassOf swa:InternalChartElements ;
.
swa:ChartSeriesLabels
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:seriesLabels ;
      spl:valueType xsd:string ;
      rdfs:comment "The comma-separated list of labels." ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:if ui:condition=\"{= bound(?seriesLabels) }\">
    <swon:Value arg:name=\"series\">
        <swon:Array>
            <ui:forEach ui:resultSet='{#
                    SELECT ?label
                    WHERE {
                        ?label spif:split ( ?seriesLabels \",\" ) .
                    } }' ui:separator=\",\">
                <swon:Object>
                    <swon:Value arg:name=\"label\" arg:value=\"{= ?label }\"/>
                </swon:Object>
            </ui:forEach>
        </swon:Array>
    </swon:Value>
</ui:if>
"""^^ui:Literal ;
  rdfs:label "Chart series labels" ;
  rdfs:subClassOf swa:InternalChartElements ;
.
swa:ChartTitleSetter
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:title ;
      spl:valueType xsd:string ;
      rdfs:comment "The title to render or unbound." ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:if ui:condition=\"{= bound(?title) }\">
    <swon:Value arg:name=\"title\" arg:value=\"{= ?title }\"/>
</ui:if>
"""^^ui:Literal ;
  rdfs:subClassOf swa:InternalChartElements ;
.
swa:DisplayChartSearchResultsAction
  a swa:SearchResultsAction ;
  arg:condition true ;
  arg:onSelect "swa.displayChartFromSearch(formId)" ;
  rdfs:label "Display chart of search results..." ;
.
swa:DonutChart
  a ui:NodeClass ;
  ui:prototype """
<swa:AbstractPieChartImpl arg:jsLibrary=\"donutRenderer\" arg:renderer=\"$.jqplot.DonutRenderer\" arg:sliceMargin=\"{= 3 }\" ui:args=\"*\"/>
"""^^ui:Literal ;
  rdfs:comment "Displays a donut chart based on a given result set." ;
  rdfs:label "Donut chart" ;
  rdfs:subClassOf swa:AbstractPieChart ;
.
swa:FilledAreaChart
  a ui:NodeClass ;
  ui:prototype """
<ui:group let:id=\"{= ui:uniqueId() }\">
    <swa:RequireChartPlugin arg:name=\"categoryAxisRenderer\"/>
    <swa:RequireChartPlugin arg:name=\"highlighter\"/>
    <swa:RequireChartPlugin arg:name=\"canvasTextRenderer\"/>
    <swa:RequireChartPlugin arg:name=\"canvasAxisTickRenderer\"/>
    <swa:ChartPlaceholderDiv ui:args=\"*\"/>
    <script>$.jqplot(\"{= ?id }\",<swon:Array>
            <swa:ValueColumnArrays arg:resultSet=\"{= ?resultSet }\"/>
        </swon:Array>,<swon:Object>
            <swa:ChartTitleSetter arg:title=\"{= ?title }\"/>
            <swa:ChartColorsSetter arg:seriesColors=\"{= ?seriesColors }\"/>
            <swon:Value arg:name=\"showMarker\" arg:value=\"{= false }\"/>
            <swon:Value arg:name=\"stackSeries\" arg:value=\"{= true }\"/>
            <swon:Value arg:name=\"seriesDefaults\">
                <swon:Object>
                    <swon:Value arg:name=\"fill\" arg:value=\"{= true }\"/>
                    <swon:Value arg:name=\"pointLabels\">
                        <swon:Object>
                            <swon:Value arg:name=\"show\">true</swon:Value>
                            <ui:if ui:condition=\"{= ?noFractions }\">
                                <swon:Value arg:name=\"formatString\" arg:value=\"%d\"/>
                            </ui:if>
                        </swon:Object>
                    </swon:Value>
                </swon:Object>
            </swon:Value>
            <swa:ChartAxes ui:args=\"*\"/>
            <swa:ChartSeriesLabels ui:args=\"*\"/>
            <swa:ChartLegend arg:placement=\"outsideGrid\" ui:args=\"*\"/>
        </swon:Object>);
		<swa:ChartOnDataClickHandler ui:args=\"*\"/>
    </script>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "Displays a filled area chart in which values are \"stacked\" on top of each other." ;
  rdfs:label "Filled area chart" ;
  rdfs:subClassOf swa:AbstractAxialChart ;
.
swa:InternalChartElements
  a ui:NodeClass ;
  ui:abstract true ;
  ui:private true ;
  rdfs:subClassOf swa:ChartElements ;
.
swa:LabelColumnArray
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resultSet ;
      spl:valueType sp:Select ;
      rdfs:comment "The input result set - the values from the second column will be turned into an array." ;
    ] ;
  ui:private true ;
  ui:prototype """
<swon:Array let:colIndex=\"{= swa:labelColIndex(?resultSet) }\">
    <ui:forEach ui:resultSet=\"{#
            SELECT ?rowIndex
            WHERE {
                ?resultSet spr:rowIndices ?rowIndex .
            } }\" ui:separator=\",\">\"{= ui:escapeJSON(spr:cell(?resultSet, ?rowIndex, ?colIndex)) }\"</ui:forEach>
</swon:Array>
"""^^ui:Literal ;
  rdfs:subClassOf swa:ChartDataElements ;
.
swa:LineChart
  a ui:NodeClass ;
  ui:prototype """
<ui:group let:id=\"{= ui:uniqueId() }\">
    <swa:RequireChartPlugin arg:name=\"categoryAxisRenderer\"/>
    <swa:RequireChartPlugin arg:name=\"highlighter\"/>
    <swa:RequireChartPlugin arg:name=\"canvasTextRenderer\"/>
    <swa:RequireChartPlugin arg:name=\"canvasAxisTickRenderer\"/>
    <swa:ChartPlaceholderDiv ui:args=\"*\"/>
    <script>$.jqplot(\"{= ?id }\",<swon:Array>
            <swa:ValueColumnArrays arg:resultSet=\"{= ?resultSet }\"/>
        </swon:Array>,<swon:Object>
            <swa:ChartTitleSetter arg:title=\"{= ?title }\"/>
            <swa:ChartColorsSetter arg:seriesColors=\"{= ?seriesColors }\"/>
            <swon:Value arg:name=\"seriesDefaults\">
                <swon:Object>
                    <swon:Value arg:name=\"pointLabels\">
                        <swon:Object>
                            <swon:Value arg:name=\"show\">true</swon:Value>
                            <ui:if ui:condition=\"{= ?noFractions }\">
                                <swon:Value arg:name=\"formatString\" arg:value=\"%d\"/>
                            </ui:if>
                        </swon:Object>
                    </swon:Value>
                </swon:Object>
            </swon:Value>
            <swa:ChartAxes ui:args=\"*\"/>
            <swa:ChartSeriesLabels ui:args=\"*\"/>
            <swa:ChartLegend arg:placement=\"outsideGrid\" ui:args=\"*\"/>
        </swon:Object>);
		<swa:ChartOnDataClickHandler ui:args=\"*\"/>
    </script>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "Displays a line chart." ;
  rdfs:label "Line chart" ;
  rdfs:subClassOf swa:AbstractAxialChart ;
.
swa:PieChart
  a ui:NodeClass ;
  ui:prototype """
<swa:AbstractPieChartImpl arg:jsLibrary=\"pieRenderer\" arg:renderer=\"$.jqplot.PieRenderer\" ui:args=\"*\"/>
"""^^ui:Literal ;
  rdfs:comment "Displays a pie chart where each slice represents one row of a given result set." ;
  rdfs:label "Pie chart" ;
  rdfs:subClassOf swa:AbstractPieChart ;
.
swa:PieChartDataArray
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:colName ;
      spl:valueType xsd:string ;
      rdfs:comment "The column name, defaulting to \"value\"." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resultSet ;
      spl:valueType sp:Select ;
      rdfs:comment "The input result set." ;
    ] ;
  ui:private true ;
  ui:prototype """
<swon:Array let:labelColIndex=\"{= swa:labelColIndex(?resultSet) }\" let:resourceColIndex=\"{= swa:resourceColIndex(?resultSet) }\" let:valueColIndex=\"{= spr:colWithName(?resultSet, COALESCE(?colName, &quot;value&quot;)) }\">
    <ui:forEach ui:resultSet=\"{#
            SELECT ?rowIndex
            WHERE {
                ?resultSet spr:rowIndices ?rowIndex .
            } }\" ui:separator=\",\">
        <swon:Array>\"{= ui:escapeJSON(spr:cell(?resultSet, ?rowIndex, ?labelColIndex)) }\", {= spr:cell(?resultSet, ?rowIndex, ?valueColIndex) }<ui:if ui:condition=\"{= bound(?resourceColIndex) }\">,\"{= spr:cell(?resultSet, ?rowIndex, ?resourceColIndex) }\"</ui:if>
        </swon:Array>
    </ui:forEach>
</swon:Array>
"""^^ui:Literal ;
  rdfs:subClassOf swa:ChartDataElements ;
.
swa:PieChartDataArrays
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resultSet ;
      spl:valueType sp:Select ;
      rdfs:comment "The input result set - the values from the first column will be turned into an array." ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:group let:colIndex=\"{= spr:colWithName(?resultSet, &quot;value1&quot;) }\">
    <ui:if ui:condition=\"{= bound(?colIndex) }\">
        <swa:PieChartDataArraysHelper arg:index=\"{= 1 }\" arg:resultSet=\"{= ?resultSet }\"/>
    </ui:if>
    <ui:else>
        <swa:PieChartDataArray arg:resultSet=\"{= ?resultSet }\"/>
    </ui:else>
</ui:group>
"""^^ui:Literal ;
  rdfs:subClassOf swa:ChartDataElements ;
.
swa:PieChartDataArraysHelper
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:index ;
      spl:valueType xsd:integer ;
      rdfs:comment "The index, starting with 1." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resultSet ;
      spl:valueType sp:Select ;
      rdfs:comment "The input result set - the values from the first column will be turned into an array." ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:group let:nextColIndex=\"{= spr:colWithName(?resultSet, CONCAT(&quot;value&quot;, xsd:string((?index + 1)))) }\">
    <swa:PieChartDataArray arg:colName=\"{= CONCAT(&quot;value&quot;, xsd:string(?index)) }\" arg:resultSet=\"{= ?resultSet }\"/>
    <ui:if ui:condition=\"{= bound(?nextColIndex) }\">,<swa:PieChartDataArraysHelper arg:index=\"{= ?index + 1 }\" arg:resultSet=\"{= ?resultSet }\"/>
    </ui:if>
</ui:group>
"""^^ui:Literal ;
  rdfs:subClassOf swa:ChartDataElements ;
.
swa:PieChartDataView
  a ui:ViewElement ;
  ui:prototype """
<ui:call arg:this=\"{= ?this }\" ui:template=\"{= ?dataProvider }\">
    <swa:PieChart arg:dataLabels=\"percent\" arg:resultSet=\"{= ?rs }\" arg:showLegend=\"{= true }\"/>
</ui:call>
"""^^ui:Literal ;
  rdfs:comment "A DataView displaying a pie chart." ;
  rdfs:label "Pie chart data view" ;
  rdfs:subClassOf ui:DataViews ;
.
swa:RequireChartPlugin
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:name ;
      spl:valueType xsd:string ;
      rdfs:comment "The local name of the file to import." ;
    ] ;
  ui:private true ;
  ui:prototype """
<swa:RequireJSLibrary arg:path=\"assets/lib/jqplot/js/jqplot-plugins/jqplot.{= ?name }.min.js\"/>
"""^^ui:Literal ;
  rdfs:label "Require chart plugin" ;
  rdfs:subClassOf swa:InternalChartElements ;
.
swa:ResourceColumnArray
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resultSet ;
      spl:valueType sp:Select ;
      rdfs:comment "The input result set - the values from the second column will be turned into an array." ;
    ] ;
  ui:private true ;
  ui:prototype """
<swon:Array let:colIndex=\"{= swa:resourceColIndex(?resultSet) }\">
    <ui:forEach ui:resultSet=\"{#
            SELECT ?rowIndex
            WHERE {
                ?resultSet spr:rowIndices ?rowIndex .
            } }\" ui:separator=\",\">\"{= ui:escapeJSON(xsd:string(spr:cell(?resultSet, ?rowIndex, ?colIndex))) }\"</ui:forEach>
</swon:Array>
"""^^ui:Literal ;
  rdfs:subClassOf swa:ChartDataElements ;
.
swa:TimelineChart
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:maxTime ;
      spl:valueType xsd:dateTime ;
      rdfs:comment "An optional maximum for the time axis." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:minTime ;
      spl:valueType xsd:dateTime ;
      rdfs:comment "An optional minimum for the time axis." ;
    ] ;
  ui:prototype """
<ui:group let:id=\"{= ui:uniqueId() }\">
    <swa:RequireChartPlugin arg:name=\"categoryAxisRenderer\"/>
    <swa:RequireChartPlugin arg:name=\"highlighter\"/>
    <swa:RequireChartPlugin arg:name=\"canvasTextRenderer\"/>
    <swa:RequireChartPlugin arg:name=\"canvasAxisTickRenderer\"/>
    <swa:RequireChartPlugin arg:name=\"dateAxisRenderer\"/>
    <swa:ChartPlaceholderDiv ui:args=\"*\"/>
    <script>$.jqplot(\"{= ?id }\",<swon:Array>
            <swa:ValueTimeColumnArraysHelper arg:index=\"{= 1 }\" arg:resultSet=\"{= ?resultSet }\"/>
        </swon:Array>
        <swon:Comma/>
        <swon:Object>
            <swa:ChartTitleSetter arg:title=\"{= ?title }\"/>
            <swa:ChartColorsSetter arg:seriesColors=\"{= ?seriesColors }\"/>
            <swon:Value arg:name=\"seriesDefaults\">
                <swon:Object>
                    <swon:Value arg:name=\"pointLabels\">
                        <swon:Object>
                            <swon:Value arg:name=\"show\">true</swon:Value>
                            <ui:if ui:condition=\"{= ?noFractions }\">
                                <swon:Value arg:name=\"formatString\" arg:value=\"%d\"/>
                            </ui:if>
                        </swon:Object>
                    </swon:Value>
                </swon:Object>
            </swon:Value>
            <swa:ChartAxes arg:maxXValue=\"{= spif:timeMillis(?maxTime) }\" arg:minXValue=\"{= spif:timeMillis(?minTime) }\" arg:renderer=\"DateAxisRenderer\" ui:args=\"*\"/>
            <swa:ChartSeriesLabels ui:args=\"*\"/>
            <swa:ChartLegend arg:placement=\"outsideGrid\" ui:args=\"*\"/>
        </swon:Object>);
		<swa:ChartOnDataClickHandler ui:args=\"*\"/>
    </script>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "Displays a timeline chart - a variation of swa:LineChart in which the X axis represents times (xsd:dataTime) and the Y axis some numeric values. The SPARQL queries that feed this chart must produce pairs of bindings for ?value1/?time1 etc." ;
  rdfs:label "Timeline chart" ;
  rdfs:subClassOf swa:AbstractAxialChart ;
.
swa:ValueColumnArray
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:colName ;
      spl:valueType xsd:string ;
      rdfs:comment "The column name, defaulting to \"value\"." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resultSet ;
      spl:valueType sp:Select ;
      rdfs:comment "The input result set - the values from the first column will be turned into an array." ;
    ] ;
  ui:private true ;
  ui:prototype """
<swon:Array let:colIndex=\"{= spr:colWithName(?resultSet, COALESCE(?colName, &quot;value&quot;)) }\">
    <ui:forEach ui:resultSet=\"{#
            SELECT ?rowIndex
            WHERE {
                ?resultSet spr:rowIndices ?rowIndex .
            } }\" ui:separator=\",\">
        <ui:group let:value=\"{= spr:cell(?resultSet, ?rowIndex, ?colIndex) }\">
            <ui:group let:num=\"{= xsd:float(?value) }\">
                <ui:if ui:condition=\"{= bound(?num) }\">{= ?num }</ui:if>
                <ui:else>\"{= ui:escapeJSON(?value) }\"</ui:else>
            </ui:group>
        </ui:group>
    </ui:forEach>
</swon:Array>
"""^^ui:Literal ;
  rdfs:subClassOf swa:ChartDataElements ;
.
swa:ValueColumnArrays
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resultSet ;
      spl:valueType sp:Select ;
      rdfs:comment "The input result set - the values from the first column will be turned into an array." ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:group let:colIndex=\"{= spr:colWithName(?resultSet, &quot;value1&quot;) }\">
    <ui:if ui:condition=\"{= bound(?colIndex) }\">
        <swa:ValueColumnArraysHelper arg:index=\"{= 1 }\" arg:resultSet=\"{= ?resultSet }\"/>
    </ui:if>
    <ui:else>
        <swa:ValueColumnArray arg:resultSet=\"{= ?resultSet }\"/>
    </ui:else>
</ui:group>
"""^^ui:Literal ;
  rdfs:subClassOf swa:ChartDataElements ;
.
swa:ValueColumnArraysHelper
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:index ;
      spl:valueType xsd:integer ;
      rdfs:comment "The index, starting with 1." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resultSet ;
      spl:valueType sp:Select ;
      rdfs:comment "The input result set - the values from the first column will be turned into an array." ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:group let:nextColIndex=\"{= spr:colWithName(?resultSet, CONCAT(&quot;value&quot;, xsd:string((?index + 1)))) }\">
    <swa:ValueColumnArray arg:colName=\"{= CONCAT(&quot;value&quot;, xsd:string(?index)) }\" arg:resultSet=\"{= ?resultSet }\"/>
    <ui:if ui:condition=\"{= bound(?nextColIndex) }\">
        <swon:Comma/>
        <swa:ValueColumnArraysHelper arg:index=\"{= ?index + 1 }\" arg:resultSet=\"{= ?resultSet }\"/>
    </ui:if>
</ui:group>
"""^^ui:Literal ;
  rdfs:subClassOf swa:ChartDataElements ;
.
swa:ValueTimeColumnArray
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:colIndex ;
      spl:valueType xsd:integer ;
      rdfs:comment "The column index starting at 1, will be converted to ?value1 and ?time1." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resultSet ;
      spl:valueType sp:Select ;
      rdfs:comment "The input result set - the values from the first column will be turned into an array." ;
    ] ;
  ui:private true ;
  ui:prototype """
<swon:Array let:timeColIndex=\"{= spr:colWithName(?resultSet, CONCAT(&quot;time&quot;, str(?colIndex))) }\" let:valueColIndex=\"{= spr:colWithName(?resultSet, CONCAT(&quot;value&quot;, str(?colIndex))) }\">
    <ui:forEach ui:resultSet=\"{#
            SELECT ?rowIndex
            WHERE {
                ?resultSet spr:rowIndices ?rowIndex .
            } }\" ui:separator=\",\">
        <ui:group let:value=\"{= spr:cell(?resultSet, ?rowIndex, ?valueColIndex) }\">
            <swon:Array let:num=\"{= xsd:float(?value) }\">{= spif:timeMillis(spr:cell(?resultSet, ?rowIndex, ?timeColIndex)) }<swon:Comma/>
                <ui:if ui:condition=\"{= bound(?num) }\">{= ?num }</ui:if>
                <ui:else>\"{= ui:escapeJSON(?value) }\"</ui:else>
            </swon:Array>
        </ui:group>
    </ui:forEach>
</swon:Array>
"""^^ui:Literal ;
  rdfs:subClassOf swa:ChartDataElements ;
.
swa:ValueTimeColumnArraysHelper
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:index ;
      spl:valueType xsd:integer ;
      rdfs:comment "The index, starting with 1." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resultSet ;
      spl:valueType sp:Select ;
      rdfs:comment "The input result set - the values from the first column will be turned into an array." ;
    ] ;
  ui:private true ;
  ui:prototype """
<ui:group let:nextColIndex=\"{= spr:colWithName(?resultSet, CONCAT(&quot;value&quot;, xsd:string((?index + 1)))) }\">
    <swa:ValueTimeColumnArray arg:colIndex=\"{= ?index }\" arg:resultSet=\"{= ?resultSet }\"/>
    <ui:if ui:condition=\"{= bound(?nextColIndex) }\">
        <swon:Comma/>
        <swa:ValueTimeColumnArraysHelper arg:index=\"{= ?index + 1 }\" arg:resultSet=\"{= ?resultSet }\"/>
    </ui:if>
</ui:group>
"""^^ui:Literal ;
  rdfs:subClassOf swa:ChartDataElements ;
.
swa:VictoryAbstractAxialChart
  a ui:NodeClass ;
  rdfs:subClassOf swa:AbstractVictoryChart ;
.
swa:VictoryAbstractAxialChartImpl
  a ui:NodeClass ;
  ui:prototype """
<ui:group let:chartId=\"stack_{= ui:uniqueId() }\">
    <div data-chart=\"stack\" data-endpoint=\"{= xsd:string(?data_endpoint) }\" data-height=\"{= COALESCE(?height, ?nil) }\" data-subjectArea=\"{= str(?subjectArea) }\" data-width=\"{= COALESCE(?width, ?nil) }\" id=\"{= ?chartId }\"/>
    <script>(function(){{= swa:publishEvent(\"swa.victory.chart.stack.loaded\", CONCAT(\"'\", ?chartId, \"'\")) }})()</script>
</ui:group>
"""^^ui:Literal ;
  rdfs:subClassOf swa:VictoryAbstractAxialChart ;
.
swa:VictoryAbstractPieChart
  a ui:NodeClass ;
  ui:abstract true ;
  rdfs:subClassOf swa:AbstractVictoryChart ;
.
swa:VictoryAbstractPieChartImpl
  a ui:NodeClass ;
  ui:prototype """
<ui:group let:chartId=\"donut_{= ui:uniqueId() }\">
    <div data-chart=\"donut\" data-endpoint=\"{= xsd:string(?data_endpoint) }\" data-subjectArea=\"{= str(?subjectArea) }\" id=\"{= ?chartId }\"/>
    <script>(function(){{= swa:publishEvent(\"swa.victory.chart.donut.loaded\", CONCAT(\"'\", ?chartId, \"'\")) }})()</script>
</ui:group>
"""^^ui:Literal ;
  rdfs:subClassOf swa:VictoryAbstractPieChart ;
.
swa:VictoryChartElements
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:height ;
      spl:valueType xsd:integer ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:width ;
      spl:valueType xsd:integer ;
    ] ;
  rdfs:subClassOf swa:ChartElements ;
.
swa:VictoryDonutChart
  a ui:NodeClass ;
  ui:prototype """
<swa:VictoryAbstractPieChartImpl ui:args=\"*\"/>
"""^^ui:Literal ;
  rdfs:subClassOf swa:VictoryAbstractPieChart ;
.
swa:VictoryStackChart
  a ui:NodeClass ;
  ui:prototype """
<swa:VictoryAbstractAxialChartImpl ui:args=\"*\"/>
"""^^ui:Literal ;
  rdfs:subClassOf swa:VictoryAbstractAxialChart ;
.
swa:hasLabelColumn
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a swa:labelColIndex ;
                arg:resultSet [
                    sp:varName "rs" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "colIndex" ;
              ] ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:bound ;
                sp:arg1 [
                    sp:varName "colIndex" ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:rs ;
      spl:valueType sp:Select ;
      rdfs:comment "The result set to check." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks if a given result set (?rs) has at least two columns, and the second column has a value in the first row." ;
  rdfs:label "has label column" ;
  rdfs:subClassOf swa:ChartFunctions ;
.
swa:hasResourceColumn
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a swa:resourceColIndex ;
                arg:resultSet [
                    sp:varName "rs" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "colIndex" ;
              ] ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:bound ;
                sp:arg1 [
                    sp:varName "colIndex" ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:rs ;
      spl:valueType sp:Select ;
      rdfs:comment "The result set to check." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks if a given result set (?rs) has at least three columns." ;
  rdfs:label "has resource column" ;
  rdfs:subClassOf swa:ChartFunctions ;
.
swa:htmlEscapeAngularBrackets
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a smf:replaceAll ;
                sp:arg1 [
                    a smf:replaceAll ;
                    sp:arg1 [
                        sp:varName "queryString" ;
                      ] ;
                    sp:arg2 "<" ;
                    sp:arg3 "&lt;" ;
                  ] ;
                sp:arg2 ">" ;
                sp:arg3 "&gt;" ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:queryString ;
      spl:valueType xsd:string ;
      rdfs:comment "The input query string." ;
    ] ;
  spin:private true ;
  spin:returnType xsd:string ;
  rdfs:label "html escape angular brackets" ;
  rdfs:subClassOf spin:Functions ;
.
swa:labelColIndex
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "colIndex" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a spr:colWithName ;
                sp:arg1 [
                    sp:varName "resultSet" ;
                  ] ;
                sp:arg2 "label" ;
              ] ;
            sp:variable [
                sp:varName "colIndex" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resultSet ;
      spl:valueType sp:Select ;
      rdfs:comment "The result set." ;
    ] ;
  spin:returnType xsd:integer ;
  rdfs:comment "Gets the index of the label column (usually 1)." ;
  rdfs:label "label col index" ;
  rdfs:subClassOf swa:ChartFunctions ;
.
swa:resourceColIndex
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "colIndex" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a sp:coalesce ;
                sp:arg1 [
                    a spr:colWithName ;
                    sp:arg1 [
                        sp:varName "resultSet" ;
                      ] ;
                    sp:arg2 "resource" ;
                  ] ;
                sp:arg2 [
                    a sp:if ;
                    sp:arg1 [
                        a sp:gt ;
                        sp:arg1 [
                            a spr:colCount ;
                            sp:arg1 [
                                sp:varName "resultSet" ;
                              ] ;
                          ] ;
                        sp:arg2 2 ;
                      ] ;
                    sp:arg2 2 ;
                    sp:arg3 [
                        sp:varName "none" ;
                      ] ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "colIndex" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resultSet ;
      spl:valueType sp:Select ;
      rdfs:comment "The result set." ;
    ] ;
  spin:returnType xsd:integer ;
  rdfs:comment "Gets the index of the resource column (usually 2)." ;
  rdfs:label "resource col index" ;
  rdfs:subClassOf swa:ChartFunctions ;
.
swa:valueColIndex
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "colIndex" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a sp:coalesce ;
                sp:arg1 [
                    a spr:colWithName ;
                    sp:arg1 [
                        sp:varName "resultSet" ;
                      ] ;
                    sp:arg2 "value" ;
                  ] ;
                sp:arg2 [
                    a spr:colWithName ;
                    sp:arg1 [
                        sp:varName "resultSet" ;
                      ] ;
                    sp:arg2 "value1" ;
                  ] ;
                sp:arg3 0 ;
              ] ;
            sp:variable [
                sp:varName "colIndex" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resultSet ;
      spl:valueType sp:Select ;
      rdfs:comment "The result set." ;
    ] ;
  spin:returnType xsd:integer ;
  rdfs:comment "Gets the index of the value column. The first preference for this is the column named \"value\", second choice \"value1\". If none of those are present, then it is assumed to be column index 0." ;
  rdfs:label "value col index" ;
  rdfs:subClassOf swa:ChartFunctions ;
.
<http://topbraid.org/swacharts>
  a owl:Ontology ;
  owl:imports <http://topbraid.org/swa> ;
.
