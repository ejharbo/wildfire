# baseURI: http://topbraid.org/swa.spin
# imports: http://datashapes.org/dash
# imports: http://spinrdf.org/spl
# imports: http://uispin.org/ui

@prefix afn: <http://jena.hpl.hp.com/ARQ/function#> .
@prefix arg: <http://spinrdf.org/arg#> .
@prefix dash: <http://datashapes.org/dash#> .
@prefix edg: <http://edg.topbraid.solutions/model/> .
@prefix fn: <http://www.w3.org/2005/xpath-functions#> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix sh: <http://www.w3.org/ns/shacl#> .
@prefix smf: <http://topbraid.org/sparqlmotionfunctions#> .
@prefix sp: <http://spinrdf.org/sp#> .
@prefix spif: <http://spinrdf.org/spif#> .
@prefix spin: <http://spinrdf.org/spin#> .
@prefix spl: <http://spinrdf.org/spl#> .
@prefix swa: <http://topbraid.org/swa#> .
@prefix teamwork: <http://topbraid.org/teamwork#> .
@prefix tosh: <http://topbraid.org/tosh#> .
@prefix ui: <http://uispin.org/ui#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

arg:appName
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:class
  a rdf:Property ;
  rdfs:label "class" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:component
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:datatype
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:focusNode
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:graph
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:index
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:lang
  a rdf:Property ;
  rdfs:label "lang" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:letter
  a rdf:Property ;
  rdfs:label "letter" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:module
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:node
  a rdf:Property ;
  rdfs:label "node" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:object
  a rdf:Property ;
  rdfs:label "object" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:parameter
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:predicate
  a rdf:Property ;
  rdfs:label "predicate" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:property
  a rdf:Property ;
  rdfs:label "property" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:propertyShape
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:range
  a rdf:Property ;
  rdfs:label "range" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:regex
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:resource
  a rdf:Property ;
  rdfs:label "resource" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:resourceGraph
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:resourceType
  a rdf:Property ;
  rdfs:label "resource type" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:shape
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:shapeOrConstraint
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:string
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:subString
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:subject
  a rdf:Property ;
  rdfs:label "subject" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:text
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:url
  a rdf:Property ;
  rdfs:label "url" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:valueType
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:valueTypeGraph
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:zindex
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
swa:CategoryFunctions
  a spin:Function ;
  spin:abstract true ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to categorize." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Abstract base class of categorization functions (used by swa:AutoComplete)." ;
  rdfs:label "Category functions" ;
  rdfs:subClassOf swa:Functions ;
.
swa:ClassAxiomProperty
  a rdfs:Class ;
  rdfs:comment "A marker type to distinguish class axiom properties from others." ;
  rdfs:label "Class axiom property" ;
  rdfs:subClassOf rdf:Property ;
.
swa:ClassFunctorFunctions
  a spin:Function ;
  spin:abstract true ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:class ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class to start traversal at." ;
    ] ;
  rdfs:comment "Abstract superclass that groups together various functors on classes." ;
  rdfs:label "Class functor functions" ;
  rdfs:subClassOf swa:Functions ;
.
swa:Country
  a rdfs:Class ;
  rdfs:comment "A class that is used to link languages with locales (countries). The library contains instances for the most frequently needed countries." ;
  rdfs:label "Country" ;
.
swa:Country-al
  a swa:Country ;
  swa:countryCode "al" ;
  swa:languageCode "sq" ;
.
swa:Country-bg
  a swa:Country ;
  swa:countryCode "bg" ;
  swa:languageCode "bg" ;
.
swa:Country-by
  a swa:Country ;
  swa:countryCode "by" ;
  swa:languageCode "be" ;
.
swa:Country-cn
  a swa:Country ;
  swa:countryCode "cn" ;
  swa:languageCode "zh" ;
.
swa:Country-cz
  a swa:Country ;
  swa:countryCode "cz" ;
  swa:languageCode "cs" ;
.
swa:Country-de
  a swa:Country ;
  swa:countryCode "de" ;
  swa:languageCode "de" ;
.
swa:Country-dk
  a swa:Country ;
  swa:countryCode "dk" ;
  swa:languageCode "da" ;
.
swa:Country-ee
  a swa:Country ;
  swa:countryCode "ee" ;
  swa:languageCode "et" ;
.
swa:Country-es
  a swa:Country ;
  swa:countryCode "es" ;
  swa:languageCode "ca" ;
  swa:languageCode "es" ;
.
swa:Country-fi
  a swa:Country ;
  swa:countryCode "fi" ;
  swa:languageCode "fi" ;
.
swa:Country-fr
  a swa:Country ;
  swa:countryCode "fr" ;
  swa:languageCode "fr" ;
.
swa:Country-gb
  a swa:Country ;
  swa:countryCode "gb" ;
  swa:languageCode "en" ;
.
swa:Country-gr
  a swa:Country ;
  swa:countryCode "gr" ;
  swa:languageCode "el" ;
.
swa:Country-hr
  a swa:Country ;
  swa:countryCode "hr" ;
  swa:languageCode "hr" ;
.
swa:Country-hu
  a swa:Country ;
  swa:countryCode "hu" ;
  swa:languageCode "hu" ;
.
swa:Country-id
  a swa:Country ;
  swa:countryCode "id" ;
  swa:languageCode "in" ;
.
swa:Country-ie
  a swa:Country ;
  swa:countryCode "ie" ;
  swa:languageCode "ga" ;
.
swa:Country-il
  a swa:Country ;
  swa:countryCode "il" ;
  swa:languageCode "iw" ;
.
swa:Country-in
  a swa:Country ;
  swa:countryCode "in" ;
  swa:languageCode "hi" ;
.
swa:Country-is
  a swa:Country ;
  swa:countryCode "is" ;
  swa:languageCode "is" ;
.
swa:Country-it
  a swa:Country ;
  swa:countryCode "it" ;
  swa:languageCode "it" ;
.
swa:Country-jp
  a swa:Country ;
  swa:countryCode "jp" ;
  swa:languageCode "ja" ;
.
swa:Country-kr
  a swa:Country ;
  swa:countryCode "kr" ;
  swa:languageCode "ko" ;
.
swa:Country-lt
  a swa:Country ;
  swa:countryCode "lt" ;
  swa:languageCode "lt" ;
.
swa:Country-lv
  a swa:Country ;
  swa:countryCode "lv" ;
  swa:languageCode "lv" ;
.
swa:Country-me
  a swa:Country ;
  swa:countryCode "me" ;
  swa:languageCode "sr" ;
.
swa:Country-mk
  a swa:Country ;
  swa:countryCode "mk" ;
  swa:languageCode "mk" ;
.
swa:Country-mt
  a swa:Country ;
  swa:countryCode "mt" ;
  swa:languageCode "mt" ;
.
swa:Country-my
  a swa:Country ;
  swa:countryCode "my" ;
  swa:languageCode "ms" ;
.
swa:Country-nl
  a swa:Country ;
  swa:countryCode "nl" ;
  swa:languageCode "nl" ;
.
swa:Country-no
  a swa:Country ;
  swa:countryCode "no" ;
  swa:languageCode "no" ;
.
swa:Country-pl
  a swa:Country ;
  swa:countryCode "pl" ;
  swa:languageCode "pl" ;
.
swa:Country-pt
  a swa:Country ;
  swa:countryCode "pt" ;
  swa:languageCode "pt" ;
.
swa:Country-ro
  a swa:Country ;
  swa:countryCode "ro" ;
  swa:languageCode "ro" ;
.
swa:Country-ru
  a swa:Country ;
  swa:countryCode "ru" ;
  swa:languageCode "ru" ;
.
swa:Country-sa
  a swa:Country ;
  swa:countryCode "sa" ;
  swa:languageCode "ar" ;
.
swa:Country-se
  a swa:Country ;
  swa:countryCode "se" ;
  swa:languageCode "sv" ;
.
swa:Country-si
  a swa:Country ;
  swa:countryCode "si" ;
  swa:languageCode "sl" ;
.
swa:Country-sk
  a swa:Country ;
  swa:countryCode "sk" ;
  swa:languageCode "sk" ;
.
swa:Country-th
  a swa:Country ;
  swa:countryCode "th" ;
  swa:languageCode "th" ;
.
swa:Country-tr
  a swa:Country ;
  swa:countryCode "tr" ;
  swa:languageCode "tr" ;
.
swa:Country-ua
  a swa:Country ;
  swa:countryCode "ua" ;
  swa:languageCode "uk" ;
.
swa:Country-va
  a swa:Country ;
  swa:countryCode "va" ;
  swa:languageCode "la" ;
.
swa:Country-vn
  a swa:Country ;
  swa:countryCode "vn" ;
  swa:languageCode "vi" ;
.
swa:Functions
  a spin:Function ;
  spin:abstract true ;
  rdfs:comment "Just an abstract superclass to group together the various functions from this namespace in tree viewers." ;
  rdfs:label "Functions" ;
  rdfs:subClassOf spin:Functions ;
.
swa:GetLabel
  a spin:SelectTemplate ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "label" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a ui:label ;
                sp:arg1 [
                    sp:varName "resource" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "label" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to get the label of." ;
    ] ;
  spin:private true ;
  rdfs:comment "A simple SPIN template that can be used by Ajax clients to retrieve the ui:label of a given resource from the server." ;
  rdfs:label "Get label" ;
  rdfs:subClassOf spin:SelectTemplates ;
.
swa:GetRelevantPropertiesOfClass
  a spin:SelectTemplate ;
  spin:body [
      a sp:Select ;
      sp:orderBy (
          [
            sp:varName "propertyLabel" ;
          ]
        ) ;
      sp:resultVariables (
          [
            sp:varName "propertyURI" ;
          ]
          [
            sp:varName "propertyLabel" ;
          ]
          [
            sp:varName "rangeURI" ;
          ]
        ) ;
      sp:where (
          (
            [
              sp:object [
                  sp:varName "class" ;
                ] ;
              sp:predicate spl:relevantPropertyAtClass ;
              sp:subject [
                  sp:varName "property" ;
                ] ;
            ]
          )
          [
            a sp:Bind ;
            sp:expression [
                a xsd:string ;
                sp:arg1 [
                    sp:varName "property" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "propertyURI" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a ui:label ;
                sp:arg1 [
                    sp:varName "property" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "propertyLabel" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a xsd:string ;
                sp:arg1 [
                    a swa:localRangeAtClass ;
                    arg:class [
                        sp:varName "class" ;
                      ] ;
                    arg:property [
                        sp:varName "property" ;
                      ] ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "rangeURI" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:class ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class to get the relevant properties of." ;
    ] ;
  spin:private true ;
  rdfs:comment """Gets all relevant properties for a given class. This template can be used as a web service by arbitrary web components, ideally with json-simple mime type.

Result values:

- propertyURI: the URI of the property
- propertyLabel: the display label of the property
- rangeURI: the URI of the range of the property""" ;
  rdfs:label "Get relevant properties of class" ;
  rdfs:subClassOf spin:SelectTemplates ;
.
swa:GetResourceValues
  a spin:SelectTemplate ;
  spin:body [
      a sp:Select ;
      sp:orderBy (
          [
            sp:varName "property" ;
          ]
          [
            sp:varName "objectLabel" ;
          ]
        ) ;
      sp:resultVariables (
          [
            sp:varName "propertyURI" ;
          ]
          [
            sp:varName "propertyLabel" ;
          ]
          [
            sp:varName "objectLabel" ;
          ]
          [
            sp:varName "objectURI" ;
          ]
          [
            sp:varName "objectDatatypeURI" ;
          ]
          [
            sp:varName "objectLang" ;
          ]
          [
            sp:varName "objectEncoded" ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "object" ;
              ] ;
            sp:predicate [
                sp:varName "property" ;
              ] ;
            sp:subject [
                sp:varName "resource" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a xsd:string ;
                sp:arg1 [
                    sp:varName "property" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "propertyURI" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a ui:label ;
                sp:arg1 [
                    sp:varName "property" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "propertyLabel" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a ui:label ;
                sp:arg1 [
                    sp:varName "object" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "objectLabel" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:if ;
                sp:arg1 [
                    a sp:isIRI ;
                    sp:arg1 [
                        sp:varName "object" ;
                      ] ;
                  ] ;
                sp:arg2 [
                    a xsd:string ;
                    sp:arg1 [
                        sp:varName "object" ;
                      ] ;
                  ] ;
                sp:arg3 [
                    sp:varName "none" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "objectURI" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:if ;
                sp:arg1 [
                    a sp:isLiteral ;
                    sp:arg1 [
                        sp:varName "object" ;
                      ] ;
                  ] ;
                sp:arg2 [
                    a xsd:string ;
                    sp:arg1 [
                        a sp:datatype ;
                        sp:arg1 [
                            sp:varName "object" ;
                          ] ;
                      ] ;
                  ] ;
                sp:arg3 [
                    sp:varName "none" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "objectDatatypeURI" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:lang ;
                sp:arg1 [
                    sp:varName "object" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "objectLang" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a ui:encodeNode ;
                sp:arg1 [
                    sp:varName "object" ;
                  ] ;
                sp:arg2 true ;
                sp:arg3 true ;
              ] ;
            sp:variable [
                sp:varName "objectEncoded" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:property ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property to get - leave empty for all properties." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to get the values of." ;
    ] ;
  spin:private true ;
  rdfs:comment """Gets all property values (objects) for a given resource (subject). For each value, it returns information about the property and the datatype. This template can be used as a web service by arbitrary web components, ideally with json-simple mime type.

The property argument is optional: leave empty to return all properties.

Result values:

- propertyURI: the URI of the property
- propertyLabel: the display label of the property
- objectLabel: the display label of the value
- objectURI: the URI of the value, if it is a URI resource
- objectDatatypeURI: the URI of the datatype if the value is a literal
- objectLang: the language code of the datatype if the value is a string
- objectEncoded: the SPARQL-encoded serialization of the value""" ;
  rdfs:label "Get resource values" ;
  rdfs:subClassOf spin:SelectTemplates ;
.
swa:NumericDatatype
  a rdfs:Class ;
  rdfs:comment "A marker class for all numeric datatypes." ;
  rdfs:label "Numeric datatype" ;
  rdfs:subClassOf rdfs:Datatype ;
.
swa:PropertyAxiomProperty
  a rdfs:Class ;
  rdfs:comment "A marker type to distinguish property axiom properties from others." ;
  rdfs:label "Property axiom property" ;
  rdfs:subClassOf rdf:Property ;
.
swa:PropertyWidgetGroupFilterFunctions
  a spin:Function ;
  spin:abstract true ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:subject ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject resource (optional)." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate to check." ;
    ] ;
  spin:private true ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Abstract superclass for the various kinds of filter functions that can be used to select properties for widget groups." ;
  rdfs:label "Property widget group filter functions" ;
  rdfs:subClassOf swa:Functions ;
.
swa:ResourcesWithLetter
  a spin:SelectTemplate ;
  spin:body [
      a sp:Select ;
      sp:distinct true ;
      sp:orderBy (
          [
            a fn:lower-case ;
            sp:arg1 [
                sp:varName "label" ;
              ] ;
          ]
        ) ;
      sp:resultVariables (
          [
            sp:varName "resource" ;
          ]
        ) ;
      sp:where (
          [
            a sp:TriplePath ;
            sp:object [
                sp:varName "resourceType" ;
              ] ;
            sp:path [
                a sp:ModPath ;
                sp:modMax -2 ;
                sp:modMin 0 ;
                sp:subPath rdfs:subClassOf ;
              ] ;
            sp:subject [
                sp:varName "type" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "type" ;
              ] ;
            sp:predicate rdf:type ;
            sp:subject [
                sp:varName "resource" ;
              ] ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:isIRI ;
                sp:arg1 [
                    sp:varName "resource" ;
                  ] ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a ui:label ;
                sp:arg1 [
                    sp:varName "resource" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "label" ;
              ] ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a fn:starts-with ;
                sp:arg1 [
                    a fn:upper-case ;
                    sp:arg1 [
                        sp:varName "label" ;
                      ] ;
                  ] ;
                sp:arg2 [
                    sp:varName "letter" ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:letter ;
      spl:valueType xsd:string ;
      rdfs:comment "The (uppercase) letter to match." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The resource type." ;
    ] ;
  spin:private true ;
  rdfs:comment "Gets an ordered list of all instances of a given class that start with a given letter." ;
  rdfs:label "Resources with letter" ;
  rdfs:subClassOf spin:SelectTemplates ;
.
swa:ResourcesWithNonLetter
  a spin:SelectTemplate ;
  spin:body [
      a sp:Select ;
      sp:distinct true ;
      sp:orderBy (
          [
            a fn:lower-case ;
            sp:arg1 [
                sp:varName "label" ;
              ] ;
          ]
        ) ;
      sp:resultVariables (
          [
            sp:varName "resource" ;
          ]
        ) ;
      sp:where (
          [
            a sp:TriplePath ;
            sp:object [
                sp:varName "resourceType" ;
              ] ;
            sp:path [
                a sp:ModPath ;
                sp:modMax -2 ;
                sp:modMin 0 ;
                sp:subPath rdfs:subClassOf ;
              ] ;
            sp:subject [
                sp:varName "type" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "type" ;
              ] ;
            sp:predicate rdf:type ;
            sp:subject [
                sp:varName "resource" ;
              ] ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:isIRI ;
                sp:arg1 [
                    sp:varName "resource" ;
                  ] ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a ui:label ;
                sp:arg1 [
                    sp:varName "resource" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "label" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a fn:upper-case ;
                sp:arg1 [
                    a fn:substring ;
                    sp:arg1 [
                        sp:varName "label" ;
                      ] ;
                    sp:arg2 1 ;
                    sp:arg3 1 ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "first" ;
              ] ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:not ;
                sp:arg1 [
                    a fn:contains ;
                    sp:arg1 "ABCDEFGHIJKLMNOPQRSTUVWXYZ" ;
                    sp:arg2 [
                        sp:varName "first" ;
                      ] ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The type of resources to match (will include subclasses of the type)." ;
    ] ;
  spin:private true ;
  rdfs:comment "Gets an ordered list of all instances of a given type that do not start with a letter from A-Z." ;
  rdfs:label "Resources with non letter" ;
  rdfs:subClassOf spin:SelectTemplates ;
.
swa:TypeHasSubClass
  a spin:AskTemplate ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            sp:object [
                sp:varName "resource" ;
              ] ;
            sp:predicate rdfs:subClassOf ;
            sp:subject [
                sp:varName "o" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to get the values of." ;
    ] ;
  rdfs:comment "Checks whether the passed in resourceType has any subclasses" ;
  rdfs:label "Type has sub class" ;
  rdfs:subClassOf spin:AskTemplates ;
.
swa:TypeIsRelatedEntity
  a spin:AskTemplate ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            sp:object [
                sp:varName "resource" ;
              ] ;
            sp:predicate teamwork:relatedClass ;
            sp:subject [
                sp:varName "o" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to get the values of." ;
    ] ;
  rdfs:comment "Checks whether the passed in resourceType is classified as a related entity/graphql:protectedClass within the project we're working with" ;
  rdfs:label "Type is related entity" ;
  rdfs:subClassOf spin:AskTemplates ;
.
swa:TypesHaveSuperClass
  a spin:AskTemplate ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            sp:object [
                sp:varName "?0" ;
              ] ;
            sp:predicate spif:split ;
            sp:subject [
                sp:varName "uri" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "typesList" ;
              ] ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "?0" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "?1" ;
              ] ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "?0" ;
              ] ;
          ]
          [
            sp:object " " ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "?1" ;
              ] ;
          ]
          [
            sp:object () ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "?1" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:iri ;
                sp:arg1 [
                    sp:varName "uri" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "type" ;
              ] ;
          ]
          [
            a sp:TriplePath ;
            sp:object [
                sp:varName "resourceType" ;
              ] ;
            sp:path [
                a sp:ModPath ;
                sp:modMax -2 ;
                sp:modMin 0 ;
                sp:subPath rdfs:subClassOf ;
              ] ;
            sp:subject [
                sp:varName "type" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The type to match against." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:typesList ;
      spl:valueType xsd:string ;
      rdfs:comment "The list of URIs separated by spaces containing the types to check." ;
    ] ;
  rdfs:comment "Checks whether any of the types defined in a space-separated list of URIs has a given type as its superclass." ;
  rdfs:label "Types have super class" ;
  rdfs:subClassOf spin:AskTemplates ;
.
swa:URIExistsPreCondition
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Filter ;
            sp:expression [
                a sp:or ;
                sp:arg1 [
                    a sp:not ;
                    sp:arg1 [
                        a sp:bound ;
                        sp:arg1 spin:_arg1 ;
                      ] ;
                  ] ;
                sp:arg2 [
                    a sp:eq ;
                    sp:arg1 [
                        a fn:string-length ;
                        sp:arg1 spin:_arg1 ;
                      ] ;
                    sp:arg2 0 ;
                  ] ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression "Missing URI." ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The input string." ;
    ] ;
  spin:private true ;
  spin:returnType xsd:string ;
  rdfs:comment "Can be used in ui:preCondition to check whether a given URI exists and is not empty." ;
  rdfs:label "uri exists pre condition" ;
  rdfs:subClassOf swa:Functions ;
.
swa:ViewsContainingText
  a spin:SelectTemplate ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "rootView" ;
          ]
          [
            sp:varName "element" ;
          ]
        ) ;
      sp:where (
          (
            [
              sp:object [
                  sp:varName "o" ;
                ] ;
              sp:predicate [
                  sp:varName "p" ;
                ] ;
              sp:subject [
                  sp:varName "s" ;
                ] ;
            ]
            [
              a sp:Filter ;
              sp:expression [
                  a sp:regex ;
                  sp:arg1 [
                      sp:varName "o" ;
                    ] ;
                  sp:arg2 [
                      sp:varName "regex" ;
                    ] ;
                ] ;
            ]
            [
              a sp:Filter ;
              sp:expression [
                  a spl:instanceOf ;
                  sp:arg1 [
                      sp:varName "s" ;
                    ] ;
                  sp:arg2 ui:Element ;
                ] ;
            ]
          )
          [
            a sp:Bind ;
            sp:expression [
                a swa:rootView ;
                arg:view [
                    sp:varName "s" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "rootView" ;
              ] ;
          ]
          [
            a sp:Optional ;
            sp:elements (
                [
                  sp:object [
                      sp:varName "rootView" ;
                    ] ;
                  sp:predicate ui:prototype ;
                  sp:subject [
                      sp:varName "element" ;
                    ] ;
                ]
              ) ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:regex ;
      spl:valueType xsd:string ;
      rdfs:comment "The regular expression to search for." ;
    ] ;
  spin:private true ;
  rdfs:comment "Finds all SWP views that contain a given regular expression. Returns the root SWP element and, if available, the named element that has this root element as its ui:prototype." ;
  rdfs:label "Views containing text" ;
  rdfs:subClassOf spin:SelectTemplates ;
.
swa:allValuesFromFunctor
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "allValuesFrom" ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "allValuesFrom" ;
              ] ;
            sp:predicate owl:allValuesFrom ;
            sp:subject [
                sp:varName "class" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "property" ;
              ] ;
            sp:predicate owl:onProperty ;
            sp:subject [
                sp:varName "class" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property to look for." ;
    ] ;
  spin:private true ;
  spin:returnType rdfs:Class ;
  rdfs:comment "Can be used in conjunction with spif:walkObjects to get the \"first\" declared owl:allValuesFrom restriction of a given property (?property) at a given class (?class)." ;
  rdfs:label "all values from functor" ;
  rdfs:subClassOf swa:ClassFunctorFunctions ;
.
swa:appName
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:expression [
                a ui:contextValue ;
                sp:arg1 "swaAppName" ;
              ] ;
            sp:varName "result" ;
          ]
        ) ;
      sp:where () ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Gets the current SWA application name. This can be set in as context variable \"swaAppName\"." ;
  rdfs:label "app name" ;
  rdfs:subClassOf swa:Functions ;
.
swa:canEditResource
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a spl:object ;
                sp:arg1 [
                    sp:varName "resource" ;
                  ] ;
                sp:arg2 rdf:type ;
              ] ;
            sp:variable [
                sp:varName "type" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:if ;
                sp:arg1 [
                    a sp:bound ;
                    sp:arg1 [
                        sp:varName "type" ;
                      ] ;
                  ] ;
                sp:arg2 [
                    a sp:not ;
                    sp:arg1 [
                        a swa:isReadOnlyTriple ;
                        sp:arg1 [
                            sp:varName "resource" ;
                          ] ;
                        sp:arg2 rdf:type ;
                        sp:arg3 [
                            sp:varName "type" ;
                          ] ;
                      ] ;
                  ] ;
                sp:arg3 true ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to edit." ;
    ] ;
  spin:private true ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether the currently logged in user has the privilege to edit a given resource. The default implementation of this always returns true unless the rdf:type of the resource is a read-only triple, but this behavior can be overloaded for specific platforms." ;
  rdfs:label "can edit resource" ;
  rdfs:subClassOf swa:Functions ;
.
swa:categoryByNamespace
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "label" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a afn:namespace ;
                sp:arg1 [
                    sp:varName "resource" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "ns" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:iri ;
                sp:arg1 [
                    a sp:if ;
                    sp:arg1 [
                        a sp:strends ;
                        sp:arg1 [
                            sp:varName "ns" ;
                          ] ;
                        sp:arg2 "#" ;
                      ] ;
                    sp:arg2 [
                        a sp:substr ;
                        sp:arg1 [
                            sp:varName "ns" ;
                          ] ;
                        sp:arg2 1 ;
                        sp:arg3 [
                            a sp:sub ;
                            sp:arg1 [
                                a sp:strlen ;
                                sp:arg1 [
                                    sp:varName "ns" ;
                                  ] ;
                              ] ;
                            sp:arg2 1 ;
                          ] ;
                      ] ;
                    sp:arg3 [
                        sp:varName "ns" ;
                      ] ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "graphURI" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:coalesce ;
                sp:arg1 [
                    a swa:graphLabel ;
                    arg:graph [
                        a sp:iri ;
                        sp:arg1 [
                            sp:varName "ns" ;
                          ] ;
                      ] ;
                  ] ;
                sp:arg2 [
                    a swa:graphLabel ;
                    arg:graph [
                        sp:varName "graphURI" ;
                      ] ;
                  ] ;
                sp:arg3 [
                    a sp:concat ;
                    sp:arg1 "<" ;
                    sp:arg2 [
                        sp:varName "ns" ;
                      ] ;
                    sp:arg3 ">" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "label" ;
              ] ;
          ]
        ) ;
    ] ;
  rdfs:label "category by namespace" ;
  rdfs:subClassOf swa:CategoryFunctions ;
.
swa:checkPathSyntax
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:string ;
      spl:valueType xsd:string ;
      rdfs:comment "The string to check." ;
    ] ;
  spin:private true ;
  spin:returnType xsd:string ;
  rdfs:comment "Checks whether a given string can be parsed into a SPARQL path, using the prefixes of the current query graph. Returns unbound if OK, or an error message string." ;
  rdfs:label "check path syntax" ;
  rdfs:subClassOf swa:Functions ;
.
swa:columnLabel
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "label" ;
          ]
        ) ;
      sp:where (
          (
            [
              a sp:Filter ;
              sp:expression [
                  a sp:bound ;
                  sp:arg1 [
                      sp:varName "dataProvider" ;
                    ] ;
                ] ;
            ]
          )
          [
            a sp:NamedGraph ;
            sp:elements (
                [
                  sp:object [
                      sp:varName "column" ;
                    ] ;
                  sp:predicate spin:column ;
                  sp:subject [
                      sp:varName "dataProvider" ;
                    ] ;
                ]
                [
                  sp:object [
                      sp:varName "index" ;
                    ] ;
                  sp:predicate spin:columnIndex ;
                  sp:subject [
                      sp:varName "column" ;
                    ] ;
                ]
                [
                  sp:object [
                      sp:varName "label" ;
                    ] ;
                  sp:predicate rdfs:label ;
                  sp:subject [
                      sp:varName "column" ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode ui:unionGraph ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:dataProvider ;
      spl:valueType spin:TableDataProvider ;
      rdfs:comment "The data provider - may be null in which case the function returns unbound too." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:index ;
      spl:valueType xsd:integer ;
    ] ;
  rdfs:comment "Gets a column label based on a given spin:TableDataProvider. Tries to find the rdfs:label of a spin:Column with the provided index." ;
  rdfs:label "column label" ;
  rdfs:subClassOf swa:Functions ;
.
swa:configGraph
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression <http://server.topbraidlive.org/dynamic/uiconfig> ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:cachable true ;
  spin:returnType rdfs:Resource ;
  rdfs:comment "Gets the global UI config graph - <http://server.topbraidlive.org/dynamic/uiconfig>" ;
  rdfs:label "config graph" ;
  rdfs:subClassOf swa:Functions ;
.
swa:constraint
  a spin:MagicProperty ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "component" ;
          ]
          [
            sp:varName "value" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Union ;
            sp:elements (
                (
                  (
                    [
                      sp:object [
                          sp:varName "component" ;
                        ] ;
                      sp:predicate swa:constraintComponent ;
                      sp:subject spin:_arg1 ;
                    ]
                    [
                      a sp:Bind ;
                      sp:expression [
                          a swa:singleParameter ;
                          arg:component [
                              sp:varName "component" ;
                            ] ;
                        ] ;
                      sp:variable [
                          sp:varName "predicate" ;
                        ] ;
                    ]
                    [
                      a sp:Filter ;
                      sp:expression [
                          a sp:bound ;
                          sp:arg1 [
                              sp:varName "predicate" ;
                            ] ;
                        ] ;
                    ]
                  )
                  [
                    sp:object [
                        sp:varName "value" ;
                      ] ;
                    sp:predicate [
                        sp:varName "predicate" ;
                      ] ;
                    sp:subject spin:_arg1 ;
                  ]
                )
                (
                  [
                    sp:object [
                        sp:varName "component" ;
                      ] ;
                    sp:predicate swa:constraintComponent ;
                    sp:subject spin:_arg1 ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression [
                        a swa:singleParameter ;
                        arg:component [
                            sp:varName "component" ;
                          ] ;
                      ] ;
                    sp:variable [
                        sp:varName "predicate" ;
                      ] ;
                  ]
                  [
                    a sp:Filter ;
                    sp:expression [
                        a sp:not ;
                        sp:arg1 [
                            a sp:bound ;
                            sp:arg1 [
                                sp:varName "predicate" ;
                              ] ;
                          ] ;
                      ] ;
                  ]
                )
              ) ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The shape to get the constraints of." ;
    ] ;
  rdfs:comment """For a given shape, gets all declared constraints, identified by their constraint component and (if applicable) their parameter value.

Example usage: ?shape swa:constraint ( ?component ?value ) .""" ;
  rdfs:label "constraint" ;
  rdfs:subClassOf spin:MagicProperties ;
.
swa:constraintComponent
  a spin:MagicProperty ;
  spin:body [
      a sp:Select ;
      sp:distinct true ;
      sp:resultVariables (
          [
            sp:varName "component" ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "value" ;
              ] ;
            sp:predicate [
                sp:varName "predicate" ;
              ] ;
            sp:subject spin:_arg1 ;
          ]
          [
            sp:object [
                sp:varName "predicate" ;
              ] ;
            sp:predicate sh:path ;
            sp:subject [
                sp:varName "parameter" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "parameter" ;
              ] ;
            sp:predicate sh:parameter ;
            sp:subject [
                sp:varName "component" ;
              ] ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a spl:instanceOf ;
                sp:arg1 [
                    sp:varName "component" ;
                  ] ;
                sp:arg2 sh:ConstraintComponent ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The shape to get the constraints of." ;
    ] ;
  spin:returnType sh:ConstraintComponent ;
  rdfs:comment """For a given shape, gets the constraint components of all declared constraints.

Example usage: ?shape swa:constraintComponent ?component .""" ;
  rdfs:label "constraint component" ;
  rdfs:subClassOf spin:MagicProperties ;
.
swa:constraintLabel
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:parameter ;
      rdfs:comment "The (single) parameter value in cases such as sh:class, where multiple values may be present." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:component ;
      spl:valueType sh:ConstraintComponent ;
      rdfs:comment "The sh:ConstraintComponent." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:shape ;
      spl:valueType sh:Shape ;
      rdfs:comment "The shape defining the constraint." ;
    ] ;
  rdfs:comment "Gets a display label for a constraint at a shape, using any declared sh:labelTemplate where possible." ;
  rdfs:label "constraint label" ;
  rdfs:subClassOf swa:Functions ;
.
swa:constructPreambleForURI
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "preamble" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a swa:getURIClassPrefix ;
              ] ;
            sp:variable [
                sp:varName "classPrefix" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a swa:getURIPrefixSeparator ;
              ] ;
            sp:variable [
                sp:varName "separator" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a spl:object ;
                sp:arg1 [
                    sp:varName "resourceType" ;
                  ] ;
                sp:arg2 edg:acronym ;
              ] ;
            sp:variable [
                sp:varName "maybeAcronym" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a fn:upper-case ;
                sp:arg1 [
                    a afn:localname ;
                    sp:arg1 [
                        sp:varName "resourceType" ;
                      ] ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "className" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:if ;
                sp:arg1 [
                    a sp:eq ;
                    sp:arg1 [
                        sp:varName "classPrefix" ;
                      ] ;
                    sp:arg2 "name" ;
                  ] ;
                sp:arg2 [
                    a sp:add ;
                    sp:arg1 [
                        sp:varName "className" ;
                      ] ;
                    sp:arg2 [
                        sp:varName "separator" ;
                      ] ;
                  ] ;
                sp:arg3 [
                    a sp:if ;
                    sp:arg1 [
                        a sp:eq ;
                        sp:arg1 [
                            sp:varName "classPrefix" ;
                          ] ;
                        sp:arg2 "acronym" ;
                      ] ;
                    sp:arg2 [
                        a sp:if ;
                        sp:arg1 [
                            a sp:bound ;
                            sp:arg1 [
                                sp:varName "maybeAcronym" ;
                              ] ;
                          ] ;
                        sp:arg2 [
                            a sp:add ;
                            sp:arg1 [
                                sp:varName "maybeAcronym" ;
                              ] ;
                            sp:arg2 [
                                sp:varName "separator" ;
                              ] ;
                          ] ;
                        sp:arg3 [
                            a sp:add ;
                            sp:arg1 [
                                sp:varName "className" ;
                              ] ;
                            sp:arg2 [
                                sp:varName "separator" ;
                              ] ;
                          ] ;
                      ] ;
                    sp:arg3 "" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "preamble" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The type of the new resource." ;
    ] ;
  spin:private true ;
  spin:returnType rdfs:Resource ;
  rdfs:comment """Produces a preamble that will be used as the start of the local name of a new resource.

** Using non imported resourced edg:acronym, could move to config param for acronym property. **""" ;
  rdfs:label "construct preamble for URI" ;
  rdfs:subClassOf swa:Functions ;
.
swa:countStringMatches
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:string ;
      spl:valueType xsd:string ;
      rdfs:comment "The string to search in." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:subString ;
      spl:valueType xsd:string ;
      rdfs:comment "The sub-string that is expected to be part of the other string." ;
    ] ;
  spin:returnType xsd:integer ;
  rdfs:comment "Counts how many times the substring appears in the larger string." ;
  rdfs:label "count string matches" ;
  rdfs:subClassOf swa:Functions ;
.
swa:countryCode
  a rdf:Property ;
  rdfs:comment "The two-letter country code for a Country." ;
  rdfs:domain swa:Country ;
  rdfs:label "country code" ;
  rdfs:range xsd:string ;
  rdfs:subPropertyOf swa:systemProperty ;
.
swa:countryCodeForLang
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "code" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a sp:if ;
                sp:arg1 [
                    a sp:eq ;
                    sp:arg1 [
                        a fn:string-length ;
                        sp:arg1 [
                            sp:varName "lang" ;
                          ] ;
                      ] ;
                    sp:arg2 2 ;
                  ] ;
                sp:arg2 [
                    a swa:defaultCountryCodeForLanguageCode ;
                    arg:lang [
                        sp:varName "lang" ;
                      ] ;
                  ] ;
                sp:arg3 [
                    a spif:lowerCase ;
                    sp:arg1 [
                        a fn:substring ;
                        sp:arg1 [
                            sp:varName "lang" ;
                          ] ;
                        sp:arg2 4 ;
                      ] ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "code" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:lang ;
      spl:valueType xsd:string ;
      rdfs:comment "The lang code, either with 2 or 5 letters." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Takes the lang of a given literal and picks a suitable country code for it. If it's a two-letter code then it tries to find the default one associated with the language using swa:defaultCountryCodeForLanguageCode. For 5-letter codes such as en-UK it simply returns the second part lower-cased." ;
  rdfs:label "country code for lang" ;
  rdfs:subClassOf swa:Functions ;
.
swa:createPropertyShapeURI
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a sp:concat ;
                sp:arg1 [
                    a sp:str ;
                    sp:arg1 [
                        sp:varName "shape" ;
                      ] ;
                  ] ;
                sp:arg2 "-" ;
                sp:arg3 [
                    a afn:localname ;
                    sp:arg1 [
                        sp:varName "predicate" ;
                      ] ;
                  ] ;
                sp:arg4 [
                    a sp:if ;
                    sp:arg1 [
                        sp:varName "inverse" ;
                      ] ;
                    sp:arg2 "-inverse" ;
                    sp:arg3 "" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "base" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:iri ;
                sp:arg1 [
                    a sp:if ;
                    sp:arg1 [
                        a sp:bound ;
                        sp:arg1 [
                            sp:varName "zindex" ;
                          ] ;
                      ] ;
                    sp:arg2 [
                        a sp:concat ;
                        sp:arg1 [
                            sp:varName "base" ;
                          ] ;
                        sp:arg2 "-" ;
                        sp:arg3 [
                            a sp:str ;
                            sp:arg1 [
                                sp:varName "zindex" ;
                              ] ;
                          ] ;
                      ] ;
                    sp:arg3 [
                        sp:varName "base" ;
                      ] ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "iri" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:if ;
                sp:arg1 [
                    a sp:exists ;
                    sp:elements (
                        [
                          sp:object [
                              sp:varName "anyO" ;
                            ] ;
                          sp:predicate [
                              sp:varName "anyP" ;
                            ] ;
                          sp:subject [
                              sp:varName "iri" ;
                            ] ;
                        ]
                      ) ;
                  ] ;
                sp:arg2 [
                    a swa:createPropertyShapeURI ;
                    arg:inverse [
                        sp:varName "inverse" ;
                      ] ;
                    arg:predicate [
                        sp:varName "predicate" ;
                      ] ;
                    arg:shape [
                        sp:varName "shape" ;
                      ] ;
                    arg:zindex [
                        a sp:coalesce ;
                        sp:arg1 [
                            a sp:add ;
                            sp:arg1 [
                                sp:varName "zindex" ;
                              ] ;
                            sp:arg2 1 ;
                          ] ;
                        sp:arg2 0 ;
                      ] ;
                  ] ;
                sp:arg3 [
                    sp:varName "iri" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:zindex ;
      spl:valueType xsd:integer ;
      rdfs:comment "An optional index that will be used in recursive calls." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:inverse ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to create an inverse." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate to create a constraint for." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:shape ;
      spl:valueType sh:Shape ;
      rdfs:comment "The shape to add the constraint to (must be a URI)." ;
    ] ;
  spin:returnType rdfs:Resource ;
  rdfs:comment "Produces a \"suggested\" URI for a property shape at a given shape for a given predicate. Results will be of the form [SHAPE-URI]-[PREDICATE-LOCAL-NAME][-\"inverse], possibly with \"-0\", \"-1\" etc appended to make them unique." ;
  rdfs:label "create property shape URI" ;
  rdfs:subClassOf swa:Functions ;
.
swa:dataGraph
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:expression [
                a sp:coalesce ;
                sp:arg1 [
                    a ui:contextValue ;
                    sp:arg1 "dataGraph" ;
                  ] ;
                sp:arg2 [
                    a ui:currentQueryGraph ;
                  ] ;
              ] ;
            sp:varName "result" ;
          ]
        ) ;
      sp:where () ;
    ] ;
  spin:returnType rdfs:Resource ;
  rdfs:comment "Gets the current data graph. By default this is simply the current query graph. Can be set to some other value using the context variable \"dataGraph\". This is used by the SWA form mechanism: a form may switch to a different query graph to collect schema information (properties, ranges etc), but some widgets need to return to the domain/instances model in call-backs (such as auto-complete)." ;
  rdfs:label "data graph" ;
  rdfs:subClassOf swa:Functions ;
.
swa:defaultCountryCodeForLanguageCode
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "countryCode" ;
          ]
        ) ;
      sp:where (
          [
            a sp:NamedGraph ;
            sp:elements (
                [
                  sp:object [
                      sp:varName "lang" ;
                    ] ;
                  sp:predicate swa:languageCode ;
                  sp:subject [
                      sp:varName "country" ;
                    ] ;
                ]
                [
                  sp:object [
                      sp:varName "countryCode" ;
                    ] ;
                  sp:predicate swa:countryCode ;
                  sp:subject [
                      sp:varName "country" ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode <http://topbraid.org/swa.spin> ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:lang ;
      spl:valueType xsd:string ;
      rdfs:comment "The language code." ;
    ] ;
  spin:private true ;
  spin:returnType xsd:string ;
  rdfs:comment "Looks up a country code for a given two-letter language code, based on the instances of swa:Country." ;
  rdfs:label "default country code for language code" ;
  rdfs:subClassOf swa:Functions ;
.
swa:defaultNamespace
  a rdf:Property ;
  rdfs:comment "Can be used to specify a default namespace for new resources." ;
  rdfs:domain owl:Ontology ;
  rdfs:label "default namespace" ;
  rdfs:range xsd:string ;
  rdfs:subPropertyOf swa:systemProperty ;
.
swa:defaultOntology
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:expression [
                a sp:coalesce ;
                sp:arg1 [
                    sp:varName "ontology" ;
                  ] ;
                sp:arg2 [
                    a ui:currentQueryGraph ;
                  ] ;
                sp:arg3 <urn:x-error:no-ontology-found> ;
              ] ;
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Optional ;
            sp:elements (
                [
                  sp:object owl:Ontology ;
                  sp:predicate rdf:type ;
                  sp:subject [
                      sp:varName "ontology" ;
                    ] ;
                ]
              ) ;
          ]
        ) ;
    ] ;
  spin:returnType owl:Ontology ;
  rdfs:comment "Gets the \"default\" owl:Ontology in the current query graph. This is simply returning the first that it finds, so the context should make sure that only one exists or - at least - that the graph is a MultiUnion where the most relevant match is in the base graph that will be queried first. If no owl:Ontology is found, it uses ui:currentQueryGraph() and if that's not bound either then it's making up a URI." ;
  rdfs:label "default ontology" ;
  rdfs:subClassOf swa:Functions ;
.
swa:defaultPropertyShape
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a sp:iri ;
                sp:arg1 [
                    a sp:concat ;
                    sp:arg1 [
                        a sp:str ;
                        sp:arg1 [
                            sp:varName "shape" ;
                          ] ;
                      ] ;
                    sp:arg2 "-" ;
                    sp:arg3 [
                        a afn:localname ;
                        sp:arg1 [
                            sp:varName "property" ;
                          ] ;
                      ] ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdf:Property ;
      rdfs:comment "The path property." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:shape ;
      spl:valueType sh:NodeShape ;
      rdfs:comment "The shape or class to create the property shape for." ;
    ] ;
  spin:returnType rdfs:Resource ;
  rdfs:comment "Gets the default property shape URI for a given shape/property combination. This is the URI of the shape + \"-\" + the local name of the property." ;
  rdfs:label "default property shape" ;
  rdfs:subClassOf swa:Functions ;
.
swa:defaultRange
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:expression [
                a sp:if ;
                sp:arg1 [
                    a sp:or ;
                    sp:arg1 [
                        a spl:instanceOf ;
                        sp:arg1 [
                            sp:varName "property" ;
                          ] ;
                        sp:arg2 owl:DatatypeProperty ;
                      ] ;
                    sp:arg2 [
                        a spl:instanceOf ;
                        sp:arg1 [
                            sp:varName "property" ;
                          ] ;
                        sp:arg2 owl:AnnotationProperty ;
                      ] ;
                  ] ;
                sp:arg2 xsd:string ;
                sp:arg3 rdfs:Resource ;
              ] ;
            sp:varName "result" ;
          ]
        ) ;
      sp:where () ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property to get the default range of." ;
    ] ;
  spin:private true ;
  spin:returnType rdfs:Resource ;
  rdfs:comment "Gets the default range for a given property. owl:DatatypeProperties and owl:AnnotationProperties get xsd:string, all others get rdfs:Resource." ;
  rdfs:label "default range" ;
  rdfs:subClassOf swa:Functions ;
.
swa:directCompositeChild
  a spin:MagicProperty ;
  spin:body [
      a sp:Select ;
      sp:distinct true ;
      sp:resultVariables (
          [
            sp:varName "child" ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "shape" ;
              ] ;
            sp:predicate swa:shapesForNode ;
            sp:subject spin:_arg1 ;
          ]
          [
            sp:object [
                sp:varName "propertyShape" ;
              ] ;
            sp:predicate sh:property ;
            sp:subject [
                sp:varName "shape" ;
              ] ;
          ]
          [
            sp:object true ;
            sp:predicate dash:composite ;
            sp:subject [
                sp:varName "propertyShape" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "path" ;
              ] ;
            sp:predicate sh:path ;
            sp:subject [
                sp:varName "propertyShape" ;
              ] ;
          ]
          [
            a sp:Union ;
            sp:elements (
                (
                  [
                    a sp:Filter ;
                    sp:expression [
                        a sp:isIRI ;
                        sp:arg1 [
                            sp:varName "path" ;
                          ] ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "child" ;
                      ] ;
                    sp:predicate [
                        sp:varName "path" ;
                      ] ;
                    sp:subject spin:_arg1 ;
                  ]
                )
                (
                  (
                    [
                      sp:object [
                          sp:varName "inverse" ;
                        ] ;
                      sp:predicate sh:inversePath ;
                      sp:subject [
                          sp:varName "path" ;
                        ] ;
                    ]
                    [
                      a sp:Filter ;
                      sp:expression [
                          a sp:isIRI ;
                          sp:arg1 [
                              sp:varName "inverse" ;
                            ] ;
                        ] ;
                    ]
                  )
                  [
                    sp:object spin:_arg1 ;
                    sp:predicate [
                        sp:varName "inverse" ;
                      ] ;
                    sp:subject [
                        sp:varName "child" ;
                      ] ;
                  ]
                )
              ) ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The parent resource." ;
    ] ;
  spin:returnType rdfs:Resource ;
  rdfs:comment "For a given parent resource (left hand side) this magic property delivers all \"depending\" objects declared via dash:composite. The right hand side of this magic property must be an unbound variable. Works only for sh:path expressions that are either IRIs or consist of a single inverse path with a named predicate, not arbitrary sh:paths." ;
  rdfs:label "direct composite child" ;
  rdfs:subClassOf spin:MagicProperties ;
.
swa:directForm
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "form" ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "form" ;
              ] ;
            sp:predicate ui:instanceView ;
            sp:subject [
                sp:varName "class" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "ids" ;
              ] ;
            sp:predicate ui:id ;
            sp:subject [
                sp:varName "form" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "?0" ;
              ] ;
            sp:predicate spif:split ;
            sp:subject [
                sp:varName "id" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "ids" ;
              ] ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "?0" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "?1" ;
              ] ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "?0" ;
              ] ;
          ]
          [
            sp:object " " ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "?1" ;
              ] ;
          ]
          [
            sp:object () ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "?1" ;
              ] ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:eq ;
                sp:arg1 [
                    sp:varName "id" ;
                  ] ;
                sp:arg2 "form" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:class ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class that the form is attached to." ;
    ] ;
  spin:returnType ui:Element ;
  rdfs:comment "Gets a ui:instanceView of a class that has been marked to match id \"form\". This function needs to be called from within the ui:graph." ;
  rdfs:label "direct form" ;
  rdfs:subClassOf swa:Functions ;
.
swa:directFormInConfigGraph
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "form" ;
          ]
        ) ;
      sp:where (
          (
            [
              a sp:Bind ;
              sp:expression [
                  a swa:configGraph ;
                ] ;
              sp:variable [
                  sp:varName "config" ;
                ] ;
            ]
          )
          [
            a sp:NamedGraph ;
            sp:elements (
                [
                  a sp:Bind ;
                  sp:expression [
                      a swa:directForm ;
                      arg:class [
                          sp:varName "class" ;
                        ] ;
                    ] ;
                  sp:variable [
                      sp:varName "form" ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode [
                sp:varName "config" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:class ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class that the form is attached to." ;
    ] ;
  spin:returnType ui:Element ;
  rdfs:comment "Gets a ui:instanceView of a class that has been marked to match id \"form\" in the ui:configGraph()." ;
  rdfs:label "direct form in config graph" ;
  rdfs:subClassOf swa:Functions ;
.
swa:directRelevantClassOfInverseProperty
  a spin:MagicProperty ;
  spin:body [
      a sp:Select ;
      sp:distinct true ;
      sp:resultVariables (
          [
            sp:varName "property" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Union ;
            sp:elements (
                (
                  [
                    a sp:TriplePath ;
                    sp:object [
                        sp:varName "parentClass" ;
                      ] ;
                    sp:path [
                        a sp:ModPath ;
                        sp:modMax -2 ;
                        sp:modMin 0 ;
                        sp:subPath rdfs:subClassOf ;
                      ] ;
                    sp:subject spin:_arg1 ;
                  ]
                  [
                    sp:object [
                        sp:varName "parentClass" ;
                      ] ;
                    sp:predicate rdfs:range ;
                    sp:subject [
                        sp:varName "property" ;
                      ] ;
                  ]
                  [
                    a sp:Filter ;
                    sp:expression [
                        a swa:filterAllSystemResources ;
                        sp:arg1 [
                            sp:varName "property" ;
                          ] ;
                      ] ;
                  ]
                )
                (
                  [
                    a sp:TriplePath ;
                    sp:object [
                        sp:varName "parentClass" ;
                      ] ;
                    sp:path [
                        a sp:ModPath ;
                        sp:modMax -2 ;
                        sp:modMin 0 ;
                        sp:subPath rdfs:subClassOf ;
                      ] ;
                    sp:subject spin:_arg1 ;
                  ]
                  [
                    sp:object [
                        sp:varName "parentClass" ;
                      ] ;
                    sp:predicate owl:onClass ;
                    sp:subject [
                        sp:varName "restriction" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "property" ;
                      ] ;
                    sp:predicate owl:onProperty ;
                    sp:subject [
                        sp:varName "restriction" ;
                      ] ;
                  ]
                  [
                    a sp:Filter ;
                    sp:expression [
                        a swa:filterAllSystemResources ;
                        sp:arg1 [
                            sp:varName "property" ;
                          ] ;
                      ] ;
                  ]
                )
                (
                  [
                    a sp:TriplePath ;
                    sp:object [
                        sp:varName "parentClass" ;
                      ] ;
                    sp:path [
                        a sp:ModPath ;
                        sp:modMax -2 ;
                        sp:modMin 0 ;
                        sp:subPath rdfs:subClassOf ;
                      ] ;
                    sp:subject spin:_arg1 ;
                  ]
                  [
                    a sp:TriplePath ;
                    sp:object [
                        sp:varName "property" ;
                      ] ;
                    sp:path [
                        a sp:SeqPath ;
                        sp:path1 sh:path ;
                        sp:path2 sh:inversePath ;
                      ] ;
                    sp:subject [
                        sp:varName "propertyShape" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "propertyShape" ;
                      ] ;
                    sp:predicate sh:property ;
                    sp:subject [
                        sp:varName "parentClass" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "rangeClass" ;
                      ] ;
                    sp:predicate sh:class ;
                    sp:subject [
                        sp:varName "propertyShape" ;
                      ] ;
                  ]
                  [
                    a sp:Filter ;
                    sp:expression [
                        a swa:filterAllSystemResources ;
                        sp:arg1 [
                            sp:varName "property" ;
                          ] ;
                      ] ;
                  ]
                  [
                    a sp:Filter ;
                    sp:expression [
                        a sp:isIRI ;
                        sp:arg1 [
                            sp:varName "property" ;
                          ] ;
                      ] ;
                  ]
                )
              ) ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:isIRI ;
                sp:arg1 spin:_arg1 ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class to get the properties of." ;
    ] ;
  spin:returnType rdf:Property ;
  rdfs:comment "Finds the properties that refer to a given class" ;
  rdfs:label "direct relevant class of inverse property" ;
  rdfs:seeAlso swa:directRelevantClassOfProperty ;
  rdfs:seeAlso swa:relevantClassOfProperty ;
  rdfs:subClassOf spin:MagicProperties ;
.
swa:directRelevantClassOfProperty
  a spin:MagicProperty ;
  spin:body [
      a sp:Select ;
      sp:distinct true ;
      sp:resultVariables (
          [
            sp:varName "property" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Union ;
            sp:elements (
                (
                  [
                    sp:object spin:_arg1 ;
                    sp:predicate rdfs:domain ;
                    sp:subject [
                        sp:varName "property" ;
                      ] ;
                  ]
                )
                (
                  [
                    sp:object [
                        sp:varName "restriction" ;
                      ] ;
                    sp:predicate rdfs:subClassOf ;
                    sp:subject spin:_arg1 ;
                  ]
                  [
                    sp:object [
                        sp:varName "property" ;
                      ] ;
                    sp:predicate owl:onProperty ;
                    sp:subject [
                        sp:varName "restriction" ;
                      ] ;
                  ]
                )
                (
                  (
                    [
                      sp:object [
                          sp:varName "shape" ;
                        ] ;
                      sp:predicate swa:directShapesForType ;
                      sp:subject spin:_arg1 ;
                    ]
                    [
                      a sp:TriplePath ;
                      sp:object [
                          sp:varName "propertyShape" ;
                        ] ;
                      sp:path [
                          a sp:AltPath ;
                          sp:path1 sh:property ;
                          sp:path2 sh:parameter ;
                        ] ;
                      sp:subject [
                          sp:varName "shape" ;
                        ] ;
                    ]
                    [
                      a sp:Filter ;
                      sp:expression [
                          a sp:not ;
                          sp:arg1 [
                              a dash:isDeactivated ;
                              sp:arg1 [
                                  sp:varName "propertyShape" ;
                                ] ;
                            ] ;
                        ] ;
                    ]
                  )
                  [
                    sp:object [
                        sp:varName "property" ;
                      ] ;
                    sp:predicate sh:path ;
                    sp:subject [
                        sp:varName "propertyShape" ;
                      ] ;
                  ]
                  [
                    a sp:Filter ;
                    sp:expression [
                        a sp:isIRI ;
                        sp:arg1 [
                            sp:varName "property" ;
                          ] ;
                      ] ;
                  ]
                )
              ) ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:isIRI ;
                sp:arg1 spin:_arg1 ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class to get the properties of." ;
    ] ;
  spin:returnType rdf:Property ;
  rdfs:comment """Finds the properties that are directly attached to a given class.

Note that this magic property should only be used if the class (left hand side) is given and the property (right hand side) is a variable. For the inverse operation, use swa:directRelevantPropertyOfClass.""" ;
  rdfs:label "direct relevant class of property" ;
  rdfs:seeAlso swa:directRelevantClassOfInverseProperty ;
  rdfs:subClassOf spin:MagicProperties ;
.
swa:directRelevantPropertyOfClass
  a spin:MagicProperty ;
  spin:body [
      a sp:Select ;
      sp:distinct true ;
      sp:resultVariables (
          [
            sp:varName "class" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Union ;
            sp:elements (
                (
                  [
                    sp:object [
                        sp:varName "class" ;
                      ] ;
                    sp:predicate rdfs:domain ;
                    sp:subject spin:_arg1 ;
                  ]
                )
                (
                  [
                    sp:object spin:_arg1 ;
                    sp:predicate owl:onProperty ;
                    sp:subject [
                        sp:varName "restriction" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "restriction" ;
                      ] ;
                    sp:predicate rdfs:subClassOf ;
                    sp:subject [
                        sp:varName "class" ;
                      ] ;
                  ]
                )
                (
                  (
                    [
                      sp:object spin:_arg1 ;
                      sp:predicate sh:path ;
                      sp:subject [
                          sp:varName "propertyShape" ;
                        ] ;
                    ]
                    [
                      a sp:TriplePath ;
                      sp:object [
                          sp:varName "propertyShape" ;
                        ] ;
                      sp:path [
                          a sp:AltPath ;
                          sp:path1 sh:property ;
                          sp:path2 sh:parameter ;
                        ] ;
                      sp:subject [
                          sp:varName "shape" ;
                        ] ;
                    ]
                    [
                      a sp:Filter ;
                      sp:expression [
                          a sp:not ;
                          sp:arg1 [
                              a dash:isDeactivated ;
                              sp:arg1 [
                                  sp:varName "propertyShape" ;
                                ] ;
                            ] ;
                        ] ;
                    ]
                  )
                  [
                    sp:object [
                        sp:varName "shape" ;
                      ] ;
                    sp:predicate swa:directShapesForType ;
                    sp:subject [
                        sp:varName "class" ;
                      ] ;
                  ]
                )
              ) ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:isIRI ;
                sp:arg1 [
                    sp:varName "class" ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property to get the classes of." ;
    ] ;
  spin:returnType rdf:Property ;
  rdfs:comment """Finds the classes that are directly attached to a given property. In SWA this is used by the class/property tree.

Note that this magic property should only be used if the property (left hand side) is given. For the inverse operation, use swa:directRelevantClassOfProperty.""" ;
  rdfs:label "direct relevant property of class" ;
  rdfs:subClassOf spin:MagicProperties ;
.
swa:directShapesForType
  a spin:MagicProperty ;
  spin:body [
      a sp:Select ;
      sp:distinct true ;
      sp:resultVariables (
          [
            sp:varName "shape" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Union ;
            sp:elements (
                (
                  [
                    sp:object spin:_arg1 ;
                    sp:predicate sh:targetClass ;
                    sp:subject [
                        sp:varName "shape" ;
                      ] ;
                  ]
                )
                (
                  [
                    a sp:Filter ;
                    sp:expression [
                        a sp:and ;
                        sp:arg1 [
                            a sp:bound ;
                            sp:arg1 spin:_arg1 ;
                          ] ;
                        sp:arg2 [
                            a spl:instanceOf ;
                            sp:arg1 spin:_arg1 ;
                            sp:arg2 sh:Shape ;
                          ] ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression spin:_arg1 ;
                    sp:variable [
                        sp:varName "shape" ;
                      ] ;
                  ]
                )
                (
                  [
                    a sp:Filter ;
                    sp:expression [
                        a sp:and ;
                        sp:arg1 [
                            a sp:and ;
                            sp:arg1 [
                                a sp:bound ;
                                sp:arg1 [
                                    sp:varName "shape" ;
                                  ] ;
                              ] ;
                            sp:arg2 [
                                a spl:instanceOf ;
                                sp:arg1 [
                                    sp:varName "shape" ;
                                  ] ;
                                sp:arg2 rdfs:Class ;
                              ] ;
                          ] ;
                        sp:arg2 [
                            a spl:instanceOf ;
                            sp:arg1 [
                                sp:varName "shape" ;
                              ] ;
                            sp:arg2 sh:Shape ;
                          ] ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression [
                        sp:varName "shape" ;
                      ] ;
                    sp:variable spin:_arg1 ;
                  ]
                )
              ) ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The type to get the property groups for." ;
    ] ;
  spin:returnType sh:Shape ;
  rdfs:comment """Gets all sh:Shapes associated with a given type. This is not walking up the class hierarchy but collects all classes that are also instances of sh:Shape, and any shapes declared using sh:targetClass.

This magic property can be used in both directions, i.e. if either the class or the shape are given.""" ;
  rdfs:subClassOf spin:MagicProperties ;
.
swa:editingProhibited
  a owl:ObjectProperty ;
  rdfs:isDefinedBy <http://edg.topbraid.solutions/1.0/schema/core> ;
  rdfs:label "editing prohibited" ;
  rdfs:range xsd:boolean ;
.
swa:ensureURIIsNotUsed
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            a sp:NotExists ;
            sp:elements (
                [
                  sp:object [
                      sp:varName "anyType" ;
                    ] ;
                  sp:predicate rdf:type ;
                  sp:subject [
                      sp:varName "uri" ;
                    ] ;
                ]
              ) ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:uri ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:private true ;
  spin:returnType xsd:boolean ;
  rdfs:comment "determines whether the uri being proposed by the uri generator exists already, used for counter" ;
  rdfs:label "determines whether the uri being proposed by the uri generator exists already, used for counter" ;
  rdfs:subClassOf swa:Functions ;
.
swa:falseOrUnbound
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            a sp:Filter ;
            sp:expression [
                a sp:or ;
                sp:arg1 [
                    a sp:not ;
                    sp:arg1 [
                        a sp:bound ;
                        sp:arg1 [
                            sp:varName "value" ;
                          ] ;
                      ] ;
                  ] ;
                sp:arg2 [
                    a sp:not ;
                    sp:arg1 [
                        sp:varName "value" ;
                      ] ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:value ;
      spl:valueType xsd:boolean ;
      rdfs:comment "The input value." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether the provided argument is unbound or false." ;
  rdfs:label "false or unbound" ;
  rdfs:subClassOf swa:Functions ;
.
swa:genericTreeInverseProperties
  a spin:MagicProperty ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "property" ;
          ]
          [
            sp:varName "editable" ;
          ]
        ) ;
      sp:where (
          [
            a sp:SubQuery ;
            sp:query [
                a sp:Select ;
                sp:groupBy (
                    [
                      sp:varName "property" ;
                    ]
                  ) ;
                sp:resultVariables (
                    [
                      sp:varName "property" ;
                    ]
                    [
                      sp:expression [
                          a sp:Min ;
                          sp:expression [
                              sp:varName "editableL" ;
                            ] ;
                        ] ;
                      sp:varName "editable" ;
                    ]
                  ) ;
                sp:where (
                    [
                      a sp:Union ;
                      sp:elements (
                          (
                            (
                              [
                                a sp:TriplePath ;
                                sp:object [
                                    sp:varName "type" ;
                                  ] ;
                                sp:path [
                                    a sp:ModPath ;
                                    sp:modMax -2 ;
                                    sp:modMin 0 ;
                                    sp:subPath rdfs:subClassOf ;
                                  ] ;
                                sp:subject spin:_arg1 ;
                              ]
                              [
                                sp:object [
                                    sp:varName "type" ;
                                  ] ;
                                sp:predicate rdfs:range ;
                                sp:subject [
                                    sp:varName "superProperty" ;
                                  ] ;
                              ]
                              [
                                a sp:TriplePath ;
                                sp:object [
                                    sp:varName "superProperty" ;
                                  ] ;
                                sp:path [
                                    a sp:ModPath ;
                                    sp:modMax -2 ;
                                    sp:modMin 0 ;
                                    sp:subPath rdfs:subPropertyOf ;
                                  ] ;
                                sp:subject [
                                    sp:varName "property" ;
                                  ] ;
                              ]
                              [
                                sp:object [
                                    sp:varName "domain" ;
                                  ] ;
                                sp:predicate rdfs:domain ;
                                sp:subject [
                                    sp:varName "superProperty" ;
                                  ] ;
                              ]
                              [
                                a sp:Filter ;
                                sp:expression [
                                    a swa:filterSystemResources ;
                                    sp:arg1 [
                                        sp:varName "property" ;
                                      ] ;
                                  ] ;
                              ]
                              [
                                a sp:Filter ;
                                sp:expression [
                                    a swa:filterSystemResources ;
                                    sp:arg1 [
                                        sp:varName "type" ;
                                      ] ;
                                  ] ;
                              ]
                            )
                            [
                              a sp:Bind ;
                              sp:expression [
                                  a sp:and ;
                                  sp:arg1 [
                                      a sp:eq ;
                                      sp:arg1 [
                                          sp:varName "domain" ;
                                        ] ;
                                      sp:arg2 [
                                          sp:varName "type" ;
                                        ] ;
                                    ] ;
                                  sp:arg2 [
                                      a sp:not ;
                                      sp:arg1 [
                                          a spl:instanceOf ;
                                          sp:arg1 [
                                              sp:varName "property" ;
                                            ] ;
                                          sp:arg2 spin:MagicProperty ;
                                        ] ;
                                    ] ;
                                ] ;
                              sp:variable [
                                  sp:varName "editableL" ;
                                ] ;
                            ]
                          )
                          (
                            [
                              a sp:TriplePath ;
                              sp:object [
                                  sp:varName "type" ;
                                ] ;
                              sp:path [
                                  a sp:ModPath ;
                                  sp:modMax -2 ;
                                  sp:modMin 0 ;
                                  sp:subPath rdfs:subClassOf ;
                                ] ;
                              sp:subject spin:_arg1 ;
                            ]
                            [
                              sp:object [
                                  sp:varName "type" ;
                                ] ;
                              sp:predicate sh:class ;
                              sp:subject [
                                  sp:varName "ps" ;
                                ] ;
                            ]
                            [
                              sp:object [
                                  sp:varName "property" ;
                                ] ;
                              sp:predicate sh:path ;
                              sp:subject [
                                  sp:varName "ps" ;
                                ] ;
                            ]
                            [
                              sp:object [
                                  sp:varName "ps" ;
                                ] ;
                              sp:predicate sh:property ;
                              sp:subject [
                                  sp:varName "domain" ;
                                ] ;
                            ]
                            [
                              a sp:Filter ;
                              sp:expression [
                                  a sp:isIRI ;
                                  sp:arg1 [
                                      sp:varName "property" ;
                                    ] ;
                                ] ;
                            ]
                            [
                              a sp:Filter ;
                              sp:expression [
                                  a swa:filterSystemResources ;
                                  sp:arg1 [
                                      sp:varName "type" ;
                                    ] ;
                                ] ;
                            ]
                            [
                              a sp:Bind ;
                              sp:expression [
                                  a sp:and ;
                                  sp:arg1 [
                                      a sp:eq ;
                                      sp:arg1 [
                                          sp:varName "domain" ;
                                        ] ;
                                      sp:arg2 [
                                          sp:varName "type" ;
                                        ] ;
                                    ] ;
                                  sp:arg2 [
                                      a sp:not ;
                                      sp:arg1 [
                                          a spl:instanceOf ;
                                          sp:arg1 [
                                              sp:varName "property" ;
                                            ] ;
                                          sp:arg2 spin:MagicProperty ;
                                        ] ;
                                    ] ;
                                ] ;
                              sp:variable [
                                  sp:varName "editableL" ;
                                ] ;
                            ]
                          )
                        ) ;
                    ]
                  ) ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The resource type." ;
    ] ;
  spin:private true ;
  rdfs:label "generic tree inverse properties" ;
  rdfs:subClassOf spin:MagicProperties ;
.
swa:genericTreeProperties
  a spin:MagicProperty ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "property" ;
          ]
          [
            sp:varName "editable" ;
          ]
        ) ;
      sp:where (
          [
            a sp:SubQuery ;
            sp:query [
                a sp:Select ;
                sp:groupBy (
                    [
                      sp:varName "property" ;
                    ]
                  ) ;
                sp:resultVariables (
                    [
                      sp:varName "property" ;
                    ]
                    [
                      sp:expression [
                          a sp:Min ;
                          sp:expression [
                              sp:varName "editableL" ;
                            ] ;
                        ] ;
                      sp:varName "editable" ;
                    ]
                  ) ;
                sp:where (
                    [
                      a sp:Union ;
                      sp:elements (
                          (
                            (
                              (
                                [
                                  a sp:TriplePath ;
                                  sp:object [
                                      sp:varName "type" ;
                                    ] ;
                                  sp:path [
                                      a sp:ModPath ;
                                      sp:modMax -2 ;
                                      sp:modMin 0 ;
                                      sp:subPath rdfs:subClassOf ;
                                    ] ;
                                  sp:subject spin:_arg1 ;
                                ]
                                [
                                  sp:object [
                                      sp:varName "type" ;
                                    ] ;
                                  sp:predicate rdfs:domain ;
                                  sp:subject [
                                      sp:varName "superProperty" ;
                                    ] ;
                                ]
                                [
                                  a sp:TriplePath ;
                                  sp:object [
                                      sp:varName "superProperty" ;
                                    ] ;
                                  sp:path [
                                      a sp:ModPath ;
                                      sp:modMax -2 ;
                                      sp:modMin 0 ;
                                      sp:subPath rdfs:subPropertyOf ;
                                    ] ;
                                  sp:subject [
                                      sp:varName "property" ;
                                    ] ;
                                ]
                                [
                                  a sp:Filter ;
                                  sp:expression [
                                      a swa:filterSystemResources ;
                                      sp:arg1 [
                                          sp:varName "property" ;
                                        ] ;
                                    ] ;
                                ]
                                [
                                  a sp:Filter ;
                                  sp:expression [
                                      a sp:or ;
                                      sp:arg1 [
                                          a sp:eq ;
                                          sp:arg1 [
                                              sp:varName "property" ;
                                            ] ;
                                          sp:arg2 [
                                              sp:varName "superProperty" ;
                                            ] ;
                                        ] ;
                                      sp:arg2 [
                                          a sp:notExists ;
                                          sp:elements (
                                              [
                                                sp:object [
                                                    sp:varName "ownDomain" ;
                                                  ] ;
                                                sp:predicate rdfs:domain ;
                                                sp:subject [
                                                    sp:varName "property" ;
                                                  ] ;
                                              ]
                                            ) ;
                                        ] ;
                                    ] ;
                                ]
                              )
                              [
                                a sp:Bind ;
                                sp:expression [
                                    a swa:localRangeAtClass ;
                                    arg:class [
                                        sp:varName "type" ;
                                      ] ;
                                    arg:property [
                                        sp:varName "property" ;
                                      ] ;
                                  ] ;
                                sp:variable [
                                    sp:varName "range" ;
                                  ] ;
                              ]
                            )
                            [
                              a sp:Filter ;
                              sp:expression [
                                  a sp:exists ;
                                  sp:elements (
                                      [
                                        a sp:TriplePath ;
                                        sp:object owl:Thing ;
                                        sp:path [
                                            a sp:ModPath ;
                                            sp:modMax -2 ;
                                            sp:modMin 0 ;
                                            sp:subPath rdfs:subClassOf ;
                                          ] ;
                                        sp:subject [
                                            sp:varName "range" ;
                                          ] ;
                                      ]
                                    ) ;
                                ] ;
                            ]
                            [
                              a sp:Bind ;
                              sp:expression [
                                  a sp:and ;
                                  sp:arg1 [
                                      a sp:eq ;
                                      sp:arg1 [
                                          sp:varName "range" ;
                                        ] ;
                                      sp:arg2 [
                                          sp:varName "type" ;
                                        ] ;
                                    ] ;
                                  sp:arg2 [
                                      a sp:not ;
                                      sp:arg1 [
                                          a spl:instanceOf ;
                                          sp:arg1 [
                                              sp:varName "property" ;
                                            ] ;
                                          sp:arg2 spin:MagicProperty ;
                                        ] ;
                                    ] ;
                                ] ;
                              sp:variable [
                                  sp:varName "editableL" ;
                                ] ;
                            ]
                          )
                          (
                            (
                              (
                                [
                                  a sp:TriplePath ;
                                  sp:object [
                                      sp:varName "type" ;
                                    ] ;
                                  sp:path [
                                      a sp:ModPath ;
                                      sp:modMax -2 ;
                                      sp:modMin 0 ;
                                      sp:subPath rdfs:subClassOf ;
                                    ] ;
                                  sp:subject spin:_arg1 ;
                                ]
                                [
                                  a sp:TriplePath ;
                                  sp:object [
                                      sp:varName "property" ;
                                    ] ;
                                  sp:path [
                                      a sp:SeqPath ;
                                      sp:path1 sh:property ;
                                      sp:path2 sh:path ;
                                    ] ;
                                  sp:subject [
                                      sp:varName "type" ;
                                    ] ;
                                ]
                                [
                                  a sp:Filter ;
                                  sp:expression [
                                      a sp:isIRI ;
                                      sp:arg1 [
                                          sp:varName "property" ;
                                        ] ;
                                    ] ;
                                ]
                                [
                                  a sp:Filter ;
                                  sp:expression [
                                      a swa:filterSystemResources ;
                                      sp:arg1 [
                                          sp:varName "property" ;
                                        ] ;
                                    ] ;
                                ]
                              )
                              [
                                a sp:Bind ;
                                sp:expression [
                                    a swa:localRangeAtClass ;
                                    arg:class [
                                        sp:varName "type" ;
                                      ] ;
                                    arg:property [
                                        sp:varName "property" ;
                                      ] ;
                                  ] ;
                                sp:variable [
                                    sp:varName "range" ;
                                  ] ;
                              ]
                            )
                            [
                              a sp:Filter ;
                              sp:expression [
                                  a sp:exists ;
                                  sp:elements (
                                      [
                                        a sp:TriplePath ;
                                        sp:object owl:Thing ;
                                        sp:path [
                                            a sp:ModPath ;
                                            sp:modMax -2 ;
                                            sp:modMin 0 ;
                                            sp:subPath rdfs:subClassOf ;
                                          ] ;
                                        sp:subject [
                                            sp:varName "range" ;
                                          ] ;
                                      ]
                                    ) ;
                                ] ;
                            ]
                            [
                              a sp:Bind ;
                              sp:expression [
                                  a sp:and ;
                                  sp:arg1 [
                                      a sp:eq ;
                                      sp:arg1 [
                                          sp:varName "range" ;
                                        ] ;
                                      sp:arg2 [
                                          sp:varName "type" ;
                                        ] ;
                                    ] ;
                                  sp:arg2 [
                                      a sp:not ;
                                      sp:arg1 [
                                          a spl:instanceOf ;
                                          sp:arg1 [
                                              sp:varName "property" ;
                                            ] ;
                                          sp:arg2 spin:MagicProperty ;
                                        ] ;
                                    ] ;
                                ] ;
                              sp:variable [
                                  sp:varName "editableL" ;
                                ] ;
                            ]
                          )
                        ) ;
                    ]
                  ) ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The resource type." ;
    ] ;
  rdfs:label "generic tree properties" ;
  rdfs:subClassOf spin:MagicProperties ;
.
swa:getClassPropertyValue
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:limit "1"^^xsd:long ;
      sp:resultVariables (
          [
            sp:varName "value" ;
          ]
        ) ;
      sp:where (
          [
            a sp:TriplePath ;
            sp:object [
                sp:varName "parentClass" ;
              ] ;
            sp:path [
                a sp:ModPath ;
                sp:modMax -2 ;
                sp:modMin 0 ;
                sp:subPath rdfs:subClassOf ;
              ] ;
            sp:subject spin:_arg1 ;
          ]
          [
            sp:object [
                sp:varName "value" ;
              ] ;
            sp:predicate spin:_arg2 ;
            sp:subject [
                sp:varName "parentClass" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "Current subclass" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdf:Property ;
    ] ;
  rdfs:comment "Finds nearest parent class for given property" ;
  rdfs:label "class property value" ;
  rdfs:subClassOf swa:Functions ;
.
swa:getDefaultNamespace
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a swa:defaultOntology ;
              ] ;
            sp:variable [
                sp:varName "ontology" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a spl:object ;
                sp:arg1 [
                    sp:varName "ontology" ;
                  ] ;
                sp:arg2 swa:defaultNamespace ;
              ] ;
            sp:variable [
                sp:varName "default" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:coalesce ;
                sp:arg1 [
                    sp:varName "default" ;
                  ] ;
                sp:arg2 [
                    a sp:concat ;
                    sp:arg1 [
                        a xsd:string ;
                        sp:arg1 [
                            sp:varName "ontology" ;
                          ] ;
                      ] ;
                    sp:arg2 "/" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Picks a default namespace for new resources. This uses swa:defaultOntology to get hold of the default ontology. If this has a swa:defaultNamespace, then this will be used. Otherwise, the base URI + '/' of the default ontology is used." ;
  rdfs:label "get default namespace" ;
  rdfs:subClassOf swa:Functions ;
.
swa:getDescription
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to get the image for." ;
    ] ;
  spin:returnType rdfs:Literal ;
  rdfs:comment "Gets the \"description\" for a given resource. This will try to find a suitable value for one of the sub-properties of swa:description, based on the languages requested by the user. The function is natively implemented due to the complications of comparing languages and performance. The result might be any literal including rdf:HTML where applicable." ;
  rdfs:label "get description" ;
  rdfs:subClassOf swa:Functions ;
.
swa:getEditorTextError
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:focusNode ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject node." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate being edited." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:text ;
      spl:valueType xsd:string ;
      rdfs:comment "The text to check." ;
    ] ;
  spin:private true ;
  spin:returnType xsd:string ;
  rdfs:comment "Attempts to parse a string as an expression for a given subject/predicate combination. This uses the logic from the built-in editing widgets of TopBraid Composer including the Turtle-based SHACL shape editors. Returns nothing if the provided text string is valid, or an error message." ;
  rdfs:label "get editor text error" ;
  rdfs:subClassOf swa:Functions ;
.
swa:getNextUnusedURIForCounter
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a sp:iri ;
                sp:arg1 [
                    a sp:concat ;
                    sp:arg1 [
                        sp:varName "base" ;
                      ] ;
                    sp:arg2 [
                        sp:varName "preamble" ;
                      ] ;
                    sp:arg3 [
                        a xsd:string ;
                        sp:arg1 [
                            a sp:add ;
                            sp:arg1 [
                                sp:varName "offset" ;
                              ] ;
                            sp:arg2 1 ;
                          ] ;
                      ] ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "uri" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a swa:ensureURIIsNotUsed ;
                arg:uri [
                    sp:varName "uri" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "notUsed" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:if ;
                sp:arg1 [
                    sp:varName "notUsed" ;
                  ] ;
                sp:arg2 [
                    sp:varName "uri" ;
                  ] ;
                sp:arg3 [
                    a swa:getNextUnusedURIForCounter ;
                    arg:base [
                        sp:varName "base" ;
                      ] ;
                    arg:offset [
                        a sp:add ;
                        sp:arg1 [
                            sp:varName "offset" ;
                          ] ;
                        sp:arg2 1 ;
                      ] ;
                    arg:preamble [
                        sp:varName "preamble" ;
                      ] ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:base ;
      spl:valueType xsd:string ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:offset ;
      spl:valueType xsd:integer ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:preamble ;
      spl:valueType xsd:string ;
    ] ;
  spin:private true ;
  spin:returnType rdfs:Resource ;
  rdfs:comment "Gets the next unused uri for a counter if a uri already exists for the current uri offset value" ;
  rdfs:label "Get next unused URI For counter" ;
  rdfs:subClassOf swa:Functions ;
.
swa:getURIClassPrefix
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a teamwork:currentTeamGraph ;
              ] ;
            sp:variable [
                sp:varName "teamGraph" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a smf:configParam ;
                arg:param "edgURIClassPrefix" ;
              ] ;
            sp:variable [
                sp:varName "configParam" ;
              ] ;
          ]
          [
            a sp:NamedGraph ;
            sp:elements (
                [
                  a sp:Optional ;
                  sp:elements (
                      [
                        sp:object [
                            sp:varName "result1" ;
                          ] ;
                        sp:predicate teamwork:URIClassPrefix ;
                        sp:subject [
                            sp:varName "teamGraph" ;
                          ] ;
                      ]
                    ) ;
                ]
              ) ;
            sp:graphNameNode [
                sp:varName "teamGraph" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:coalesce ;
                sp:arg1 [
                    sp:varName "result1" ;
                  ] ;
                sp:arg2 [
                    sp:varName "configParam" ;
                  ] ;
                sp:arg3 false ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:private true ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks if new instance URIs should include the local name of their class, or the acronym of their class. " ;
  rdfs:label "get new instances class prefix" ;
  rdfs:subClassOf swa:Functions ;
.
swa:getURIConstructMethod
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a teamwork:currentTeamGraph ;
              ] ;
            sp:variable [
                sp:varName "teamGraph" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a smf:configParam ;
                sp:arg1 "edgURIConstructMethod" ;
              ] ;
            sp:variable [
                sp:varName "configParam" ;
              ] ;
          ]
          [
            a sp:Optional ;
            sp:elements (
                [
                  a sp:NamedGraph ;
                  sp:elements (
                      [
                        sp:object [
                            sp:varName "result1" ;
                          ] ;
                        sp:predicate teamwork:URIConstructMethod ;
                        sp:subject [
                            sp:varName "s" ;
                          ] ;
                      ]
                    ) ;
                  sp:graphNameNode [
                      sp:varName "teamGraph" ;
                    ] ;
                ]
              ) ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:coalesce ;
                sp:arg1 [
                    sp:varName "result1" ;
                  ] ;
                sp:arg2 [
                    sp:varName "configParam" ;
                  ] ;
                sp:arg3 false ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:private true ;
  spin:returnType xsd:string ;
  rdfs:comment "Gets the name of the method used to construct new instances. Currently this relies on a corresponding parameter in the EDG configuration but future versions may support different options depending on the current query graph." ;
  rdfs:label "get new instances construct method" ;
  rdfs:subClassOf swa:Functions ;
.
swa:getURICounterOffset
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a swa:getDefaultNamespace ;
              ] ;
            sp:variable [
                sp:varName "defaultNamespace" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a teamwork:currentTeamGraph ;
              ] ;
            sp:variable [
                sp:varName "teamGraph" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a smf:configParam ;
                sp:arg1 "edgURICounterOffset" ;
              ] ;
            sp:variable [
                sp:varName "configParam" ;
              ] ;
          ]
          [
            a sp:NamedGraph ;
            sp:elements (
                [
                  a sp:Optional ;
                  sp:elements (
                      [
                        sp:object [
                            sp:varName "result1" ;
                          ] ;
                        sp:predicate teamwork:URICounterOffset ;
                        sp:subject [
                            sp:varName "teamGraph" ;
                          ] ;
                      ]
                    ) ;
                ]
                [
                  a sp:Optional ;
                  sp:elements (
                      [
                        sp:object [
                            sp:varName "result2" ;
                          ] ;
                        sp:predicate teamwork:URICounterOffset ;
                        sp:subject [
                            sp:varName "resourceType" ;
                          ] ;
                      ]
                    ) ;
                ]
              ) ;
            sp:graphNameNode [
                sp:varName "teamGraph" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a swa:getURICounterOffsetForIdenticalNamespace ;
                arg:defaultNamespace [
                    sp:varName "defaultNamespace" ;
                  ] ;
                arg:resourceType [
                    sp:varName "resourceType" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "otherOffset" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:if ;
                sp:arg1 [
                    a sp:and ;
                    sp:arg1 [
                        a sp:and ;
                        sp:arg1 [
                            a sp:bound ;
                            sp:arg1 [
                                sp:varName "result2" ;
                              ] ;
                          ] ;
                        sp:arg2 [
                            a sp:bound ;
                            sp:arg1 [
                                sp:varName "result1" ;
                              ] ;
                          ] ;
                      ] ;
                    sp:arg2 [
                        a sp:gt ;
                        sp:arg1 [
                            a xsd:int ;
                            sp:arg1 [
                                sp:varName "result2" ;
                              ] ;
                          ] ;
                        sp:arg2 [
                            a xsd:int ;
                            sp:arg1 [
                                sp:varName "result1" ;
                              ] ;
                          ] ;
                      ] ;
                  ] ;
                sp:arg2 [
                    sp:varName "result2" ;
                  ] ;
                sp:arg3 [
                    sp:varName "result1" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "higherResult" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:if ;
                sp:arg1 [
                    a sp:and ;
                    sp:arg1 [
                        a sp:and ;
                        sp:arg1 [
                            a sp:bound ;
                            sp:arg1 [
                                sp:varName "otherOffset" ;
                              ] ;
                          ] ;
                        sp:arg2 [
                            a sp:bound ;
                            sp:arg1 [
                                sp:varName "higherResult" ;
                              ] ;
                          ] ;
                      ] ;
                    sp:arg2 [
                        a sp:gt ;
                        sp:arg1 [
                            a xsd:int ;
                            sp:arg1 [
                                sp:varName "higherResult" ;
                              ] ;
                          ] ;
                        sp:arg2 [
                            a xsd:int ;
                            sp:arg1 [
                                sp:varName "otherOffset" ;
                              ] ;
                          ] ;
                      ] ;
                  ] ;
                sp:arg2 [
                    sp:varName "higherResult" ;
                  ] ;
                sp:arg3 [
                    sp:varName "otherOffset" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "best" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:coalesce ;
                sp:arg1 [
                    sp:varName "best" ;
                  ] ;
                sp:arg2 [
                    sp:varName "result2" ;
                  ] ;
                sp:arg3 [
                    sp:varName "result1" ;
                  ] ;
                sp:arg4 [
                    sp:varName "configParam" ;
                  ] ;
                sp:arg5 0 ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:private true ;
  spin:returnType xsd:integer ;
  rdfs:comment "Gets the current value of the counter offset to determine what the next counter value will be" ;
  rdfs:label "get the current value of the counter offset, to determine what the next counter value will be " ;
  rdfs:subClassOf swa:Functions ;
.
swa:getURICounterOffsetForIdenticalNamespace
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            a sp:Max ;
            sp:expression [
                sp:varName "offset" ;
              ] ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a swa:getURIClassPrefix ;
              ] ;
            sp:variable [
                sp:varName "classPrefix" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "?0" ;
              ] ;
            sp:predicate teamwork:readableGraphsUnderTeamControl ;
            sp:subject () ;
          ]
          [
            sp:object [
                sp:varName "projectGraph" ;
              ] ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "?0" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "?1" ;
              ] ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "?0" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "teamGraph" ;
              ] ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "?1" ;
              ] ;
          ]
          [
            sp:object () ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "?1" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a spl:objectInGraph ;
                sp:arg1 [
                    sp:varName "projectGraph" ;
                  ] ;
                sp:arg2 swa:defaultNamespace ;
                sp:arg3 [
                    sp:varName "projectGraph" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "dns" ;
              ] ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:eq ;
                sp:arg1 [
                    sp:varName "dns" ;
                  ] ;
                sp:arg2 [
                    a xsd:string ;
                    sp:arg1 [
                        sp:varName "defaultNamespace" ;
                      ] ;
                  ] ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a xsd:int ;
                sp:arg1 [
                    a spl:objectInGraph ;
                    sp:arg1 [
                        a sp:if ;
                        sp:arg1 [
                            a sp:or ;
                            sp:arg1 [
                                a sp:eq ;
                                sp:arg1 [
                                    sp:varName "classPrefix" ;
                                  ] ;
                                sp:arg2 "Default" ;
                              ] ;
                            sp:arg2 [
                                a sp:eq ;
                                sp:arg1 [
                                    sp:varName "classPrefix" ;
                                  ] ;
                                sp:arg2 "" ;
                              ] ;
                          ] ;
                        sp:arg2 [
                            sp:varName "teamGraph" ;
                          ] ;
                        sp:arg3 [
                            sp:varName "resourceType" ;
                          ] ;
                      ] ;
                    sp:arg2 teamwork:URICounterOffset ;
                    sp:arg3 [
                        sp:varName "teamGraph" ;
                      ] ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "offset" ;
              ] ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:bound ;
                sp:arg1 [
                    sp:varName "offset" ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:defaultNamespace ;
      spl:valueType xsd:string ;
    ] ;
  spin:private true ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks to see if there are any other graphs with the same default namespace, and takes the highest offset value between them" ;
  rdfs:label "Checks to see if there are any other graphs with the same default namespace, and takes the highest offset value between them" ;
  rdfs:subClassOf swa:Functions ;
.
swa:getURIPrefixSeparator
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a teamwork:currentTeamGraph ;
              ] ;
            sp:variable [
                sp:varName "teamGraph" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a smf:configParam ;
                arg:param "edgURIPrefixSeparator" ;
              ] ;
            sp:variable [
                sp:varName "configParam" ;
              ] ;
          ]
          [
            a sp:NamedGraph ;
            sp:elements (
                [
                  a sp:Optional ;
                  sp:elements (
                      [
                        sp:object [
                            sp:varName "result1" ;
                          ] ;
                        sp:predicate teamwork:URIPrefixSeparator ;
                        sp:subject [
                            sp:varName "teamGraph" ;
                          ] ;
                      ]
                    ) ;
                ]
              ) ;
            sp:graphNameNode [
                sp:varName "teamGraph" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:coalesce ;
                sp:arg1 [
                    sp:varName "result1" ;
                  ] ;
                sp:arg2 [
                    sp:varName "configParam" ;
                  ] ;
                sp:arg3 "-" ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:private true ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks if the user has set a custom separator to put between the class name/acronym and the uuid/counter value, defaults to \"-\"" ;
  rdfs:label "Get URI prefix separator" ;
  rdfs:subClassOf swa:Functions ;
.
swa:getUserCannotModifyURI
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a teamwork:currentTeamGraph ;
              ] ;
            sp:variable [
                sp:varName "teamGraph" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a smf:configParam ;
                sp:arg1 "edgUserCannotModifyURI" ;
              ] ;
            sp:variable [
                sp:varName "configParam" ;
              ] ;
          ]
          [
            a sp:NamedGraph ;
            sp:elements (
                [
                  a sp:Optional ;
                  sp:elements (
                      [
                        sp:object [
                            sp:varName "result1" ;
                          ] ;
                        sp:predicate teamwork:userCannotModifyURI ;
                        sp:subject [
                            sp:varName "teamGraph" ;
                          ] ;
                      ]
                    ) ;
                ]
              ) ;
            sp:graphNameNode [
                sp:varName "teamGraph" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a xsd:boolean ;
                sp:arg1 [
                    a sp:coalesce ;
                    sp:arg1 [
                        sp:varName "result1" ;
                      ] ;
                    sp:arg2 [
                        sp:varName "configParam" ;
                      ] ;
                    sp:arg3 false ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:private true ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks if new instance URIs should be unmodifiable to the user. Currently this relies on a corresponding parameter in the EDG configuration but future versions may support different options depending on the current query graph." ;
  rdfs:label "get new instances user cannot modify URI" ;
  rdfs:subClassOf swa:Functions ;
.
swa:globalRange
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "range" ;
          ]
        ) ;
      sp:where (
          [
            a sp:TriplePath ;
            sp:object [
                sp:varName "p" ;
              ] ;
            sp:path [
                a sp:ModPath ;
                sp:modMax -2 ;
                sp:modMin 0 ;
                sp:subPath rdfs:subPropertyOf ;
              ] ;
            sp:subject [
                sp:varName "property" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "range" ;
              ] ;
            sp:predicate rdfs:range ;
            sp:subject [
                sp:varName "p" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property to get the range of." ;
    ] ;
  spin:returnType rdfs:Class ;
  rdfs:comment "Gets the global range (rdfs:range) of a property. If none is provided, it will walk up super-properties." ;
  rdfs:label "global range" ;
  rdfs:subClassOf swa:Functions ;
.
swa:googleMapsAPIKey
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:expression [
                a ui:systemPreference ;
                sp:arg1 "GoogleMapsAPIKey" ;
              ] ;
            sp:varName "result" ;
          ]
        ) ;
      sp:where () ;
    ] ;
  spin:private true ;
  spin:returnType xsd:string ;
  rdfs:comment "Gets the currently registered Google Maps API key." ;
  rdfs:label "Google Maps API key" ;
  rdfs:subClassOf swa:Functions ;
.
swa:graphIsEmpty
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            a sp:Filter ;
            sp:expression [
                a sp:notExists ;
                sp:elements (
                    [
                      a sp:NamedGraph ;
                      sp:elements (
                          [
                            sp:object [
                                sp:varName "o" ;
                              ] ;
                            sp:predicate [
                                sp:varName "p" ;
                              ] ;
                            sp:subject [
                                sp:varName "s" ;
                              ] ;
                          ]
                        ) ;
                      sp:graphNameNode [
                          sp:varName "graph" ;
                        ] ;
                    ]
                  ) ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:graph ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The graph to test." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether a given graph is empty." ;
  rdfs:label "graph is empty" ;
  rdfs:subClassOf swa:Functions ;
.
swa:graphLabel
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Union ;
            sp:elements (
                (
                  [
                    sp:object [
                        sp:varName "result" ;
                      ] ;
                    sp:predicate rdfs:label ;
                    sp:subject [
                        sp:varName "graph" ;
                      ] ;
                  ]
                )
                (
                  [
                    a sp:NamedGraph ;
                    sp:elements (
                        [
                          sp:object [
                              sp:varName "result" ;
                            ] ;
                          sp:predicate rdfs:label ;
                          sp:subject [
                              sp:varName "graph" ;
                            ] ;
                        ]
                      ) ;
                    sp:graphNameNode ui:graph ;
                  ]
                )
              ) ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:graph ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The graph to get the label for." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Gets the display label of a given graph, with special handling of certain system namespaces." ;
  rdfs:label "graph label" ;
  rdfs:subClassOf swa:Functions ;
.
swa:graphQLService
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:graph ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The URI of the graph to get the GraphQL service for." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Gets the URL of the GraphQL service for a given graph. Returns nothing for graphs that do not provide a GraphQL service." ;
  rdfs:label "GraphQL service" ;
  rdfs:subClassOf swa:Functions ;
.
swa:hasAppName
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          (
            [
              a sp:Filter ;
              sp:expression [
                  a sp:and ;
                  sp:arg1 [
                      a sp:bound ;
                      sp:arg1 spin:_arg1 ;
                    ] ;
                  sp:arg2 [
                      a sp:bound ;
                      sp:arg1 spin:_arg2 ;
                    ] ;
                ] ;
            ]
          )
          [
            sp:object [
                sp:varName "?0" ;
              ] ;
            sp:predicate spif:split ;
            sp:subject [
                sp:varName "sub1" ;
              ] ;
          ]
          [
            sp:object spin:_arg1 ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "?0" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "?1" ;
              ] ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "?0" ;
              ] ;
          ]
          [
            sp:object "," ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "?1" ;
              ] ;
          ]
          [
            sp:object () ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "?1" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "?2" ;
              ] ;
            sp:predicate spif:split ;
            sp:subject [
                sp:varName "sub2" ;
              ] ;
          ]
          [
            sp:object spin:_arg2 ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "?2" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "?3" ;
              ] ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "?2" ;
              ] ;
          ]
          [
            sp:object "," ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "?3" ;
              ] ;
          ]
          [
            sp:object () ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "?3" ;
              ] ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:eq ;
                sp:arg1 [
                    sp:varName "sub1" ;
                  ] ;
                sp:arg2 [
                    sp:varName "sub2" ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The string to check - may contain a comma-separated list of app names." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:string ;
      rdfs:comment "The name to match against, e.g. \"EVN\"." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks if a given string contains a given app name." ;
  rdfs:label "has app name" ;
  rdfs:subClassOf swa:Functions ;
.
swa:hasCurrentAppName
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            a sp:Filter ;
            sp:expression [
                a swa:hasAppName ;
                sp:arg1 [
                    a ui:contextValue ;
                    sp:arg1 "swaAppName" ;
                  ] ;
                sp:arg2 [
                    sp:varName "appName" ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:appName ;
      spl:valueType xsd:string ;
      rdfs:comment "The name to match against, e.g. \"EVN\"." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks if the current context is in a given application, as identified by the context variable \"swaAppName\"." ;
  rdfs:label "has current app name" ;
  rdfs:subClassOf swa:Functions ;
.
swa:hasDirectForm
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            a sp:NamedGraph ;
            sp:elements (
                [
                  a sp:Bind ;
                  sp:expression [
                      a swa:directForm ;
                      arg:class [
                          sp:varName "class" ;
                        ] ;
                    ] ;
                  sp:variable [
                      sp:varName "form" ;
                    ] ;
                ]
                [
                  a sp:Filter ;
                  sp:expression [
                      a sp:bound ;
                      sp:arg1 [
                          sp:varName "form" ;
                        ] ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode ui:graph ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:class ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class to check for a form." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether there is a direct form attached to a given class." ;
  rdfs:label "has direct form" ;
  rdfs:subClassOf swa:Functions ;
.
swa:hasDirectFormOutsideConfigGraph
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            a sp:NamedGraph ;
            sp:elements (
                (
                  (
                    [
                      sp:object [
                          sp:varName "form" ;
                        ] ;
                      sp:predicate ui:instanceView ;
                      sp:subject [
                          sp:varName "class" ;
                        ] ;
                    ]
                    [
                      a sp:Bind ;
                      sp:expression [
                          a swa:directFormInConfigGraph ;
                          arg:class [
                              sp:varName "class" ;
                            ] ;
                        ] ;
                      sp:variable [
                          sp:varName "configForm" ;
                        ] ;
                    ]
                  )
                  [
                    a sp:Filter ;
                    sp:expression [
                        a sp:or ;
                        sp:arg1 [
                            a sp:not ;
                            sp:arg1 [
                                a sp:bound ;
                                sp:arg1 [
                                    sp:varName "configForm" ;
                                  ] ;
                              ] ;
                          ] ;
                        sp:arg2 [
                            a sp:ne ;
                            sp:arg1 [
                                sp:varName "form" ;
                              ] ;
                            sp:arg2 [
                                sp:varName "configForm" ;
                              ] ;
                          ] ;
                      ] ;
                  ]
                )
                [
                  sp:object [
                      sp:varName "ids" ;
                    ] ;
                  sp:predicate ui:id ;
                  sp:subject [
                      sp:varName "form" ;
                    ] ;
                ]
                [
                  sp:object [
                      sp:varName "?0" ;
                    ] ;
                  sp:predicate spif:split ;
                  sp:subject [
                      sp:varName "id" ;
                    ] ;
                ]
                [
                  sp:object [
                      sp:varName "ids" ;
                    ] ;
                  sp:predicate rdf:first ;
                  sp:subject [
                      sp:varName "?0" ;
                    ] ;
                ]
                [
                  sp:object [
                      sp:varName "?1" ;
                    ] ;
                  sp:predicate rdf:rest ;
                  sp:subject [
                      sp:varName "?0" ;
                    ] ;
                ]
                [
                  sp:object " " ;
                  sp:predicate rdf:first ;
                  sp:subject [
                      sp:varName "?1" ;
                    ] ;
                ]
                [
                  sp:object () ;
                  sp:predicate rdf:rest ;
                  sp:subject [
                      sp:varName "?1" ;
                    ] ;
                ]
                [
                  a sp:Filter ;
                  sp:expression [
                      a sp:eq ;
                      sp:arg1 [
                          sp:varName "id" ;
                        ] ;
                      sp:arg2 "form" ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode ui:graph ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:class ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class to check." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether a given class has a direct form attached to it, outside of the swa:configGraph(). Only classes that return false here can be edited by end users." ;
  rdfs:label "has direct form outside config graph" ;
  rdfs:subClassOf swa:Functions ;
.
swa:hasPrefix
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a afn:namespace ;
                sp:arg1 [
                    sp:varName "resource" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "namespace" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "prefix" ;
              ] ;
            sp:predicate spif:prefix ;
            sp:subject [
                sp:varName "namespace" ;
              ] ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:bound ;
                sp:arg1 [
                    sp:varName "prefix" ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to check for a prefix." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks if the current query model defines a prefix for a given URI resource." ;
  rdfs:label "has prefix" ;
  rdfs:subClassOf swa:Functions ;
.
swa:hasPrimaryKey
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a swa:primaryKeyProperty ;
                arg:class [
                    sp:varName "class" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "property" ;
              ] ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:bound ;
                sp:arg1 [
                    sp:varName "property" ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:class ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class to check for the primary key." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:label "has primary key" ;
  rdfs:subClassOf swa:Functions ;
.
swa:hasPropertyGroupValue
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            sp:object [
                sp:varName "shape" ;
              ] ;
            sp:predicate swa:shapesForNodeFiltered ;
            sp:subject [
                sp:varName "focusNode" ;
              ] ;
          ]
          [
            a sp:TriplePath ;
            sp:object [
                sp:varName "propertyShape" ;
              ] ;
            sp:path [
                a sp:AltPath ;
                sp:path1 sh:property ;
                sp:path2 sh:parameter ;
              ] ;
            sp:subject [
                sp:varName "shape" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "group" ;
              ] ;
            sp:predicate sh:group ;
            sp:subject [
                sp:varName "propertyShape" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "path" ;
              ] ;
            sp:predicate sh:path ;
            sp:subject [
                sp:varName "propertyShape" ;
              ] ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:or ;
                sp:arg1 [
                    a sp:and ;
                    sp:arg1 [
                        a sp:isIRI ;
                        sp:arg1 [
                            sp:varName "path" ;
                          ] ;
                      ] ;
                    sp:arg2 [
                        a sp:exists ;
                        sp:elements (
                            [
                              sp:object [
                                  sp:varName "any" ;
                                ] ;
                              sp:predicate [
                                  sp:varName "path" ;
                                ] ;
                              sp:subject [
                                  sp:varName "focusNode" ;
                                ] ;
                            ]
                          ) ;
                      ] ;
                  ] ;
                sp:arg2 [
                    a sp:and ;
                    sp:arg1 [
                        a sp:isBlank ;
                        sp:arg1 [
                            sp:varName "path" ;
                          ] ;
                      ] ;
                    sp:arg2 [
                        a sp:exists ;
                        sp:elements (
                            [
                              sp:object [
                                  sp:varName "inverse" ;
                                ] ;
                              sp:predicate sh:inversePath ;
                              sp:subject [
                                  sp:varName "path" ;
                                ] ;
                            ]
                            [
                              sp:object [
                                  sp:varName "focusNode" ;
                                ] ;
                              sp:predicate [
                                  sp:varName "inverse" ;
                                ] ;
                              sp:subject [
                                  sp:varName "any" ;
                                ] ;
                            ]
                          ) ;
                      ] ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:focusNode ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The node to test." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:group ;
      spl:valueType sh:PropertyGroup ;
      rdfs:comment "The property group." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks if a given focus node has a value for any property (or inverse properties) enumerated by a given sh:PropertyGroup." ;
  rdfs:label "has property group value" ;
  rdfs:subClassOf swa:Functions ;
.
swa:imageURLSuffix
  a rdf:Property ;
  rdfs:comment "Lists the registered file suffixes that are regarded to be image files." ;
  rdfs:label "image URLSuffix" ;
  rdfs:range xsd:string ;
  rdfs:subPropertyOf swa:systemProperty ;
.
swa:inversePropertyShapePropertyAtClass
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "value" ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "shape" ;
              ] ;
            sp:predicate swa:shapesForType ;
            sp:subject [
                sp:varName "resourceType" ;
              ] ;
          ]
          [
            a sp:TriplePath ;
            sp:object [
                sp:varName "propertyShape" ;
              ] ;
            sp:path [
                a sp:AltPath ;
                sp:path1 sh:property ;
                sp:path2 sh:parameter ;
              ] ;
            sp:subject [
                sp:varName "shape" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "path" ;
              ] ;
            sp:predicate sh:path ;
            sp:subject [
                sp:varName "propertyShape" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "predicate" ;
              ] ;
            sp:predicate sh:inversePath ;
            sp:subject [
                sp:varName "path" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "value" ;
              ] ;
            sp:predicate [
                sp:varName "property" ;
              ] ;
            sp:subject [
                sp:varName "propertyShape" ;
              ] ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:isBlank ;
                sp:arg1 [
                    sp:varName "path" ;
                  ] ;
              ] ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:notExists ;
                sp:elements (
                    [
                      sp:object true ;
                      sp:predicate sh:deactivated ;
                      sp:subject [
                          sp:varName "propertyShape" ;
                        ] ;
                    ]
                  ) ;
              ] ;
          ]
        ) ;
    ] ;
  spin:cachableForOntologies true ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The constrained inverse property (value of sh:path/sh:inversePath)." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property to get, e.g. sh:order." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class." ;
    ] ;
  rdfs:comment "Gets the \"first\" value of a given property (such as sh:name) from inverse property constraints from all shapes associated with a given shape or class." ;
  rdfs:subClassOf swa:Functions ;
.
swa:inversePropertyShapePropertyAtNode
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "value" ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "shape" ;
              ] ;
            sp:predicate swa:shapesForNode ;
            sp:subject [
                sp:varName "resource" ;
              ] ;
          ]
          [
            a sp:TriplePath ;
            sp:object [
                sp:varName "propertyShape" ;
              ] ;
            sp:path [
                a sp:AltPath ;
                sp:path1 sh:property ;
                sp:path2 sh:parameter ;
              ] ;
            sp:subject [
                sp:varName "shape" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "path" ;
              ] ;
            sp:predicate sh:path ;
            sp:subject [
                sp:varName "propertyShape" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "predicate" ;
              ] ;
            sp:predicate sh:inversePath ;
            sp:subject [
                sp:varName "path" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "value" ;
              ] ;
            sp:predicate [
                sp:varName "property" ;
              ] ;
            sp:subject [
                sp:varName "propertyShape" ;
              ] ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:isBlank ;
                sp:arg1 [
                    sp:varName "path" ;
                  ] ;
              ] ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:notExists ;
                sp:elements (
                    [
                      sp:object true ;
                      sp:predicate sh:deactivated ;
                      sp:subject [
                          sp:varName "propertyShape" ;
                        ] ;
                    ]
                  ) ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The focus node or unbound." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The constrained inverse property (value of sh:path/sh:inversePath)." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property to get, e.g. sh:order." ;
    ] ;
  rdfs:comment "Gets the \"first\" value of a given property (such as sh:name) from all property shapes on an inverse predicate associated with a given focus node. If the focus node is unbound (e.g. in search forms), this falls back to the swa:resourceTypes." ;
  rdfs:subClassOf swa:Functions ;
.
swa:isAbstractClass
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            a sp:TriplePath ;
            sp:object true ;
            sp:path [
                a sp:AltPath ;
                sp:path1 [
                    a sp:AltPath ;
                    sp:path1 dash:abstract ;
                    sp:path2 spin:abstract ;
                  ] ;
                sp:path2 ui:abstract ;
              ] ;
            sp:subject [
                sp:varName "class" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:class ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The class to check." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether a given class is \"abstract\" which means that it should not have any direct instances. The is true if the class either has dash:abstract, spin:abstract or ui:abstract set to true." ;
  rdfs:label "is abstract class" ;
  rdfs:subClassOf swa:Functions ;
.
swa:isAnnotationProperty
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:expression [
                a spl:instanceOf ;
                sp:arg1 [
                    sp:varName "predicate" ;
                  ] ;
                sp:arg2 owl:AnnotationProperty ;
              ] ;
            sp:varName "result" ;
          ]
        ) ;
      sp:where () ;
    ] ;
  spin:private true ;
  rdfs:comment "Checks whether a given property is an annotation property." ;
  rdfs:label "is annotation property" ;
  rdfs:subClassOf swa:PropertyWidgetGroupFilterFunctions ;
.
swa:isAutoAddRowProperty
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            a sp:Filter ;
            sp:expression [
                a sp:notIn ;
                sp:arg1 [
                    sp:varName "property" ;
                  ] ;
                sp:arg2 sh:property ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The property to check." ;
    ] ;
  spin:private true ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks if a widget for a given property will automatically add a new row when it has no values. This is currently true for all properties except some SHACL ones." ;
  rdfs:label "is auto add row property" ;
  rdfs:subClassOf swa:Functions ;
.
swa:isClassAxiomProperty
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            a sp:Filter ;
            sp:expression [
                a sp:exists ;
                sp:elements (
                    [
                      a sp:NamedGraph ;
                      sp:elements (
                          [
                            sp:object swa:ClassAxiomProperty ;
                            sp:predicate rdf:type ;
                            sp:subject [
                                sp:varName "predicate" ;
                              ] ;
                          ]
                        ) ;
                      sp:graphNameNode ui:graph ;
                    ]
                  ) ;
              ] ;
          ]
        ) ;
    ] ;
  spin:private true ;
  rdfs:comment "Checks whether a given property has been marked as swa:ClassAxiomProperty." ;
  rdfs:label "is class axiom property" ;
  rdfs:subClassOf swa:PropertyWidgetGroupFilterFunctions ;
.
swa:isDatatypeEnumeration
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            sp:object [
                sp:varName "list" ;
              ] ;
            sp:predicate owl:oneOf ;
            sp:subject [
                sp:varName "resource" ;
              ] ;
          ]
          [
            sp:object rdfs:Datatype ;
            sp:predicate rdf:type ;
            sp:subject [
                sp:varName "resource" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The node to test." ;
    ] ;
  spin:private true ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Tests if a given range is a data range with a owl:oneOf." ;
  rdfs:label "is datatype enumeration" ;
  rdfs:subClassOf swa:Functions ;
.
swa:isDatatypeRange
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            a sp:Filter ;
            sp:expression [
                a sp:bound ;
                sp:arg1 [
                    sp:varName "range" ;
                  ] ;
              ] ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:or ;
                sp:arg1 [
                    a sp:eq ;
                    sp:arg1 [
                        sp:varName "range" ;
                      ] ;
                    sp:arg2 rdfs:Literal ;
                  ] ;
                sp:arg2 [
                    a sp:exists ;
                    sp:elements (
                        [
                          sp:object rdfs:Datatype ;
                          sp:predicate rdf:type ;
                          sp:subject [
                              sp:varName "range" ;
                            ] ;
                        ]
                      ) ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:range ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The range to check." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether a given resource (typically the range of a property) is a datatype. It must either be equal to rdfs:Literal or an instance of rdfs:Datatype." ;
  rdfs:label "is datatype range" ;
  rdfs:subClassOf swa:Functions ;
.
swa:isFromSHACLDatatypeConstraint
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            sp:object [
                sp:varName "shape" ;
              ] ;
            sp:predicate swa:shapesForNodeFiltered ;
            sp:subject [
                sp:varName "subject" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "property" ;
              ] ;
            sp:predicate sh:property ;
            sp:subject [
                sp:varName "shape" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "predicate" ;
              ] ;
            sp:predicate sh:path ;
            sp:subject [
                sp:varName "property" ;
              ] ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:or ;
                sp:arg1 [
                    a sp:exists ;
                    sp:elements (
                        [
                          sp:object [
                              sp:varName "datatype" ;
                            ] ;
                          sp:predicate sh:datatype ;
                          sp:subject [
                              sp:varName "property" ;
                            ] ;
                        ]
                      ) ;
                  ] ;
                sp:arg2 [
                    a sp:exists ;
                    sp:elements (
                        [
                          sp:object [
                              sp:varName "list" ;
                            ] ;
                          sp:predicate sh:or ;
                          sp:subject [
                              sp:varName "property" ;
                            ] ;
                        ]
                        [
                          a sp:TriplePath ;
                          sp:object [
                              sp:varName "datatype" ;
                            ] ;
                          sp:path [
                              a sp:SeqPath ;
                              sp:path1 [
                                  a sp:SeqPath ;
                                  sp:path1 [
                                      a sp:ModPath ;
                                      sp:modMax -2 ;
                                      sp:modMin 0 ;
                                      sp:subPath rdf:rest ;
                                    ] ;
                                  sp:path2 rdf:first ;
                                ] ;
                              sp:path2 sh:datatype ;
                            ] ;
                          sp:subject [
                              sp:varName "list" ;
                            ] ;
                        ]
                        [
                          a sp:Filter ;
                          sp:expression [
                              a sp:notExists ;
                              sp:elements (
                                  [
                                    a sp:TriplePath ;
                                    sp:object xsd:string ;
                                    sp:path [
                                        a sp:SeqPath ;
                                        sp:path1 rdf:first ;
                                        sp:path2 sh:datatype ;
                                      ] ;
                                    sp:subject [
                                        sp:varName "list" ;
                                      ] ;
                                  ]
                                  [
                                    a sp:TriplePath ;
                                    sp:object rdf:langString ;
                                    sp:path [
                                        a sp:SeqPath ;
                                        sp:path1 [
                                            a sp:SeqPath ;
                                            sp:path1 rdf:rest ;
                                            sp:path2 rdf:first ;
                                          ] ;
                                        sp:path2 sh:datatype ;
                                      ] ;
                                    sp:subject [
                                        sp:varName "list" ;
                                      ] ;
                                  ]
                                  [
                                    a sp:TriplePath ;
                                    sp:object () ;
                                    sp:path [
                                        a sp:SeqPath ;
                                        sp:path1 rdf:rest ;
                                        sp:path2 rdf:rest ;
                                      ] ;
                                    sp:subject [
                                        sp:varName "list" ;
                                      ] ;
                                  ]
                                ) ;
                            ] ;
                        ]
                      ) ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:datatype ;
      spl:valueType rdfs:Datatype ;
      rdfs:comment "The rdfs:Datatype to look for." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:subject ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject resource." ;
    ] ;
  spin:private true ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether a given datatype has been declared as sh:datatype in a shape relevant to a given subject/predicate combination. This also looks into sh:datatypes from sh:or lists." ;
  rdfs:label "is from SHACL datatype constraint" ;
  rdfs:subClassOf swa:Functions ;
.
swa:isImageURL
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            a sp:NamedGraph ;
            sp:elements (
                [
                  a sp:Bind ;
                  sp:expression [
                      a spif:lastIndexOf ;
                      sp:arg1 [
                          sp:varName "url" ;
                        ] ;
                      sp:arg2 "." ;
                    ] ;
                  sp:variable [
                      sp:varName "lastDot" ;
                    ] ;
                ]
                [
                  a sp:Filter ;
                  sp:expression [
                      a sp:gt ;
                      sp:arg1 [
                          sp:varName "lastDot" ;
                        ] ;
                      sp:arg2 0 ;
                    ] ;
                ]
                [
                  a sp:Bind ;
                  sp:expression [
                      a spif:lowerCase ;
                      sp:arg1 [
                          a fn:substring ;
                          sp:arg1 [
                              sp:varName "url" ;
                            ] ;
                          sp:arg2 [
                              a sp:add ;
                              sp:arg1 [
                                  sp:varName "lastDot" ;
                                ] ;
                              sp:arg2 1 ;
                            ] ;
                        ] ;
                    ] ;
                  sp:variable [
                      sp:varName "suffix" ;
                    ] ;
                ]
                [
                  a sp:Filter ;
                  sp:expression [
                      a sp:exists ;
                      sp:elements (
                          [
                            sp:object [
                                sp:varName "suffix" ;
                              ] ;
                            sp:predicate swa:imageURLSuffix ;
                            sp:subject [
                                sp:varName "someSubject" ;
                              ] ;
                          ]
                        ) ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode ui:graph ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:url ;
      spl:valueType xsd:string ;
      rdfs:comment "The URL to check." ;
    ] ;
  spin:private true ;
  spin:returnType xsd:boolean ;
  swa:imageURLSuffix ".gif" ;
  swa:imageURLSuffix ".jpg" ;
  swa:imageURLSuffix ".png" ;
  rdfs:comment "Checks whether a given URL represents an image based on its suffix (.jpg, .gif or .png are recognized by default, but others can be added by putting an imageURLSuffix triple into a globally registered SWP file)." ;
  rdfs:label "is image URL" ;
  rdfs:subClassOf swa:Functions ;
.
swa:isImportedResource
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to check." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether a given resource is \"imported\", which is defined to be true if the resource has at least one rdf:type triple that is read-only." ;
  rdfs:label "is imported resource" ;
  rdfs:subClassOf swa:Functions ;
.
swa:isInferredProperty
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            sp:object [
                sp:varName "predicate" ;
              ] ;
            sp:predicate sh:predicate ;
            sp:subject [
                sp:varName "rule" ;
              ] ;
          ]
          [
            sp:object sh:this ;
            sp:predicate sh:subject ;
            sp:subject [
                sp:varName "rule" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "rule" ;
              ] ;
            sp:predicate sh:rule ;
            sp:subject [
                sp:varName "shape" ;
              ] ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:notExists ;
                sp:elements (
                    [
                      sp:object true ;
                      sp:predicate sh:deactivated ;
                      sp:subject [
                          sp:varName "rule" ;
                        ] ;
                    ]
                  ) ;
              ] ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a tosh:isInTargetOf ;
                sp:arg1 [
                    sp:varName "subject" ;
                  ] ;
                sp:arg2 [
                    sp:varName "shape" ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property to check." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:subject ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject resource." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether a given property is being computed by inference (from SHACL triple rules) for a given subject." ;
  rdfs:label "is inferred property" ;
  rdfs:subClassOf swa:Functions ;
.
swa:isMandatory
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            a sp:Filter ;
            sp:expression [
                a sp:or ;
                sp:arg1 [
                    a swa:isMandatoryInOWL ;
                    arg:property [
                        sp:varName "property" ;
                      ] ;
                    arg:subject [
                        sp:varName "subject" ;
                      ] ;
                  ] ;
                sp:arg2 [
                    a swa:isMandatoryInSHACL ;
                    arg:property [
                        sp:varName "property" ;
                      ] ;
                    arg:subject [
                        sp:varName "subject" ;
                      ] ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:subject ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject - may be unbound to fall back to the subjectType." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property to check." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether a given subject/predicate combination requires at least one value, according to the ontology. This checks for owl:minCardinality|owl:cardinality|owl:qualifiedCardinality restrictions and sh:minCount constraints." ;
  rdfs:label "is mandatory" ;
  rdfs:subClassOf swa:Functions ;
.
swa:isMandatoryInOWL
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            sp:object [
                sp:varName "class" ;
              ] ;
            sp:predicate swa:resourceTypes ;
            sp:subject [
                sp:varName "subject" ;
              ] ;
          ]
          [
            a sp:TriplePath ;
            sp:object [
                sp:varName "restriction" ;
              ] ;
            sp:path [
                a sp:ModPath ;
                sp:modMax -2 ;
                sp:modMin 0 ;
                sp:subPath rdfs:subClassOf ;
              ] ;
            sp:subject [
                sp:varName "class" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "property" ;
              ] ;
            sp:predicate owl:onProperty ;
            sp:subject [
                sp:varName "restriction" ;
              ] ;
          ]
          [
            a sp:TriplePath ;
            sp:object [
                sp:varName "minOWL" ;
              ] ;
            sp:path [
                a sp:AltPath ;
                sp:path1 [
                    a sp:AltPath ;
                    sp:path1 owl:minCardinality ;
                    sp:path2 owl:cardinality ;
                  ] ;
                sp:path2 owl:qualifiedCardinality ;
              ] ;
            sp:subject [
                sp:varName "restriction" ;
              ] ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:gt ;
                sp:arg1 [
                    sp:varName "minOWL" ;
                  ] ;
                sp:arg2 0 ;
              ] ;
          ]
        ) ;
    ] ;
  spin:private true ;
  rdfs:label "is mandatory in OWL" ;
  rdfs:subClassOf swa:isMandatory ;
.
swa:isMandatoryInSHACL
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            sp:object [
                sp:varName "shape" ;
              ] ;
            sp:predicate swa:shapesForNodeFiltered ;
            sp:subject [
                sp:varName "subject" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "propertyShape" ;
              ] ;
            sp:predicate sh:property ;
            sp:subject [
                sp:varName "shape" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "property" ;
              ] ;
            sp:predicate sh:path ;
            sp:subject [
                sp:varName "propertyShape" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "minCount" ;
              ] ;
            sp:predicate sh:minCount ;
            sp:subject [
                sp:varName "propertyShape" ;
              ] ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:gt ;
                sp:arg1 [
                    sp:varName "minCount" ;
                  ] ;
                sp:arg2 0 ;
              ] ;
          ]
        ) ;
    ] ;
  rdfs:label "is mandatory SHACL" ;
  rdfs:subClassOf swa:isMandatory ;
.
swa:isMulti
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            a sp:Filter ;
            sp:expression [
                a sp:notExists ;
                sp:elements (
                    [
                      sp:object owl:FunctionalProperty ;
                      sp:predicate rdf:type ;
                      sp:subject [
                          sp:varName "property" ;
                        ] ;
                    ]
                  ) ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a swa:resourceType ;
                arg:resource [
                    sp:varName "subject" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "class" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a swa:owlMaxCardinality ;
                arg:class [
                    sp:varName "class" ;
                  ] ;
                arg:property [
                    sp:varName "property" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "max" ;
              ] ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:or ;
                sp:arg1 [
                    a sp:not ;
                    sp:arg1 [
                        a sp:bound ;
                        sp:arg1 [
                            sp:varName "max" ;
                          ] ;
                      ] ;
                  ] ;
                sp:arg2 [
                    a sp:gt ;
                    sp:arg1 [
                        sp:varName "max" ;
                      ] ;
                    sp:arg2 1 ;
                  ] ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a swa:splArgumentOnProperty ;
                arg:class [
                    sp:varName "class" ;
                  ] ;
                arg:property [
                    sp:varName "property" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "arg" ;
              ] ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:not ;
                sp:arg1 [
                    a sp:bound ;
                    sp:arg1 [
                        sp:varName "arg" ;
                      ] ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:subject ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject - may be unbound to fall back to the subjectType." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property to check." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment """Checks whether a given subject/predicate combination can have multiple values, according to the ontology. This checks for owl:maxCardinality restrictions, existing spl:Argument constraints and whether the property is functional.

Note that TopBraid Suite uses a native (optimized) implementation of this function, i.e. the SPIN body is never called when used inside of TopBraid Suite.""" ;
  rdfs:label "is multi" ;
  rdfs:subClassOf swa:Functions ;
.
swa:isNonAnnotationProperty
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:expression [
                a sp:not ;
                sp:arg1 [
                    a spl:instanceOf ;
                    sp:arg1 [
                        sp:varName "predicate" ;
                      ] ;
                    sp:arg2 owl:AnnotationProperty ;
                  ] ;
              ] ;
            sp:varName "result" ;
          ]
        ) ;
      sp:where () ;
    ] ;
  spin:private true ;
  rdfs:comment "Checks whether a property is not an annotation property." ;
  rdfs:label "is non annotation property" ;
  rdfs:subClassOf swa:PropertyWidgetGroupFilterFunctions ;
.
swa:isNonClassAxiomProperty
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            a sp:Filter ;
            sp:expression [
                a sp:and ;
                sp:arg1 [
                    a sp:not ;
                    sp:arg1 [
                        a swa:isClassAxiomProperty ;
                        arg:predicate [
                            sp:varName "predicate" ;
                          ] ;
                      ] ;
                  ] ;
                sp:arg2 [
                    a sp:not ;
                    sp:arg1 [
                        a swa:isAnnotationProperty ;
                        arg:predicate [
                            sp:varName "predicate" ;
                          ] ;
                      ] ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:private true ;
  rdfs:comment "Checks whether a property is neither a class axiom property nor annotation property." ;
  rdfs:label "is non class axiom property" ;
  rdfs:subClassOf swa:PropertyWidgetGroupFilterFunctions ;
.
swa:isNonPropertyAxiomProperty
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            a sp:Filter ;
            sp:expression [
                a sp:and ;
                sp:arg1 [
                    a sp:not ;
                    sp:arg1 [
                        a swa:isPropertyAxiomProperty ;
                        arg:predicate [
                            sp:varName "predicate" ;
                          ] ;
                      ] ;
                  ] ;
                sp:arg2 [
                    a sp:not ;
                    sp:arg1 [
                        a swa:isAnnotationProperty ;
                        arg:predicate [
                            sp:varName "predicate" ;
                          ] ;
                      ] ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:private true ;
  rdfs:comment "Checks whether a property is neither a property axiom property nor annotation property." ;
  rdfs:label "is non property axiom property" ;
  rdfs:subClassOf swa:PropertyWidgetGroupFilterFunctions ;
.
swa:isNotUsedInInversePath
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            a sp:Filter ;
            sp:expression [
                a sp:notExists ;
                sp:elements (
                    [
                      sp:object [
                          sp:varName "shape" ;
                        ] ;
                      sp:predicate swa:shapesForNodeFiltered ;
                      sp:subject [
                          sp:varName "resource" ;
                        ] ;
                    ]
                    [
                      sp:object [
                          sp:varName "ps" ;
                        ] ;
                      sp:predicate sh:property ;
                      sp:subject [
                          sp:varName "shape" ;
                        ] ;
                    ]
                    [
                      sp:object [
                          sp:varName "inversePath" ;
                        ] ;
                      sp:predicate sh:path ;
                      sp:subject [
                          sp:varName "ps" ;
                        ] ;
                    ]
                    [
                      a sp:Filter ;
                      sp:expression [
                          a sp:isBlank ;
                          sp:arg1 [
                              sp:varName "inversePath" ;
                            ] ;
                        ] ;
                    ]
                    [
                      a sp:Filter ;
                      sp:expression [
                          a sp:exists ;
                          sp:elements (
                              [
                                sp:object [
                                    sp:varName "anyGroup" ;
                                  ] ;
                                sp:predicate sh:group ;
                                sp:subject [
                                    sp:varName "ps" ;
                                  ] ;
                              ]
                            ) ;
                        ] ;
                    ]
                    [
                      sp:object [
                          sp:varName "predicate" ;
                        ] ;
                      sp:predicate sh:inversePath ;
                      sp:subject [
                          sp:varName "inversePath" ;
                        ] ;
                    ]
                  ) ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate to look for." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The (object) resource." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Can be used as filter function in swa:SubjectsGroup to suppress an \"Incoming References\" widget for properties already inserted via SHACL property groups." ;
  rdfs:label "is not used in inverse path" ;
  rdfs:subClassOf swa:Functions ;
.
swa:isNumericDatatype
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            a sp:NamedGraph ;
            sp:elements (
                [
                  sp:object swa:NumericDatatype ;
                  sp:predicate rdf:type ;
                  sp:subject [
                      sp:varName "node" ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode ui:graph ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:node ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The node to check." ;
    ] ;
  spin:private true ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether a given node is a numeric datatype. The numeric types are marked with the class swa:NumericDatatype in the UI graph." ;
  rdfs:label "is numeric datatype" ;
  rdfs:subClassOf swa:Functions ;
.
swa:isOntologyResource
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            a sp:Filter ;
            sp:expression [
                a sp:or ;
                sp:arg1 [
                    a sp:or ;
                    sp:arg1 [
                        a spl:instanceOf ;
                        sp:arg1 [
                            sp:varName "resource" ;
                          ] ;
                        sp:arg2 rdfs:Class ;
                      ] ;
                    sp:arg2 [
                        a spl:instanceOf ;
                        sp:arg1 [
                            sp:varName "resource" ;
                          ] ;
                        sp:arg2 rdf:Property ;
                      ] ;
                  ] ;
                sp:arg2 [
                    a spl:instanceOf ;
                    sp:arg1 [
                        sp:varName "resource" ;
                      ] ;
                    sp:arg2 sh:Shape ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to check." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether a given resource is an \"ontology resource\", which is either a class, property or shape. This can be used to determine whether a resource should become editable on a form, depending on whether the current vocabulary is supposed to only contain individuals." ;
  rdfs:label "is ontology resource" ;
  rdfs:subClassOf swa:Functions ;
.
swa:isPropertyAxiomProperty
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            a sp:Filter ;
            sp:expression [
                a sp:exists ;
                sp:elements (
                    [
                      a sp:NamedGraph ;
                      sp:elements (
                          [
                            sp:object swa:PropertyAxiomProperty ;
                            sp:predicate rdf:type ;
                            sp:subject [
                                sp:varName "predicate" ;
                              ] ;
                          ]
                        ) ;
                      sp:graphNameNode ui:graph ;
                    ]
                  ) ;
              ] ;
          ]
        ) ;
    ] ;
  spin:private true ;
  rdfs:comment "Checks whether a given property has been marked as swa:PropertyAxiomProperty." ;
  rdfs:label "is property axiom property" ;
  rdfs:subClassOf swa:PropertyWidgetGroupFilterFunctions ;
.
swa:isReadOnlyTriple
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:expression [
                a spif:isReadOnlyTriple ;
                sp:arg1 spin:_arg1 ;
                sp:arg2 spin:_arg2 ;
                sp:arg3 spin:_arg3 ;
              ] ;
            sp:varName "result" ;
          ]
        ) ;
      sp:where () ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg3 ;
      rdfs:comment "The object." ;
    ] ;
  spin:private true ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether a given subject/predicate/object combination is a read-only triple. All parameters must be present, i.e. no wild-card matching is supported. For the current framework, triples are marked as read-only by the corresponding spif:isReadOnlyTriple function (that in turn may look at the local installation, workspace etc)." ;
  rdfs:label "is read only triple" ;
  rdfs:subClassOf swa:Functions ;
.
swa:isResourceEnumeration
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            sp:object [
                sp:varName "list" ;
              ] ;
            sp:predicate owl:oneOf ;
            sp:subject [
                sp:varName "resource" ;
              ] ;
          ]
          [
            sp:object owl:Class ;
            sp:predicate rdf:type ;
            sp:subject [
                sp:varName "resource" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The node to test." ;
    ] ;
  spin:private true ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Tests if a given range is a class with an owl:oneOf enumeration." ;
  rdfs:label "is resource enumeration" ;
  rdfs:subClassOf swa:Functions ;
.
swa:isSingle
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            a sp:Filter ;
            sp:expression [
                a sp:not ;
                sp:arg1 [
                    a swa:isMulti ;
                    arg:property [
                        sp:varName "predicate" ;
                      ] ;
                    arg:subject [
                        sp:varName "subject" ;
                      ] ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:subject ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject - may be unbound to fall back to the subjectType." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate to get the local range of." ;
    ] ;
  spin:private true ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether a given subject/predicate combination can have at most one value, according to the ontology. If subject isn't given then this function falls back to a provided subjectType class. The function will return true if the property is owl:FunctionalProperty, or if the maxCardinality is 1 or if it has an spl:Argument." ;
  rdfs:label "is single" ;
  rdfs:subClassOf swa:Functions ;
.
swa:isSingleInverse
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            sp:object [
                sp:varName "shape" ;
              ] ;
            sp:predicate swa:shapesForNodeFiltered ;
            sp:subject [
                sp:varName "object" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "ps" ;
              ] ;
            sp:predicate sh:property ;
            sp:subject [
                sp:varName "shape" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "path" ;
              ] ;
            sp:predicate sh:path ;
            sp:subject [
                sp:varName "ps" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "predicate" ;
              ] ;
            sp:predicate sh:inversePath ;
            sp:subject [
                sp:varName "path" ;
              ] ;
          ]
          [
            sp:object 1 ;
            sp:predicate sh:maxCount ;
            sp:subject [
                sp:varName "ps" ;
              ] ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:isBlank ;
                sp:arg1 [
                    sp:varName "path" ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:object ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The object (resource)." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate to check." ;
    ] ;
  spin:private true ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Similar to swa:isSingle but for an inverse property and only based on sh:maxCount 1." ;
  rdfs:label "is single inverse" ;
  rdfs:subClassOf swa:Functions ;
.
swa:isValidObjectForPredicateAtSubject
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            a sp:Filter ;
            sp:expression [
                a sp:notExists ;
                sp:elements (
                    [
                      sp:object [
                          sp:varName "shape" ;
                        ] ;
                      sp:predicate swa:shapesForNodeFiltered ;
                      sp:subject [
                          sp:varName "subject" ;
                        ] ;
                    ]
                    [
                      sp:object [
                          sp:varName "propertyShape" ;
                        ] ;
                      sp:predicate sh:property ;
                      sp:subject [
                          sp:varName "shape" ;
                        ] ;
                    ]
                    [
                      sp:object [
                          sp:varName "predicate" ;
                        ] ;
                      sp:predicate sh:path ;
                      sp:subject [
                          sp:varName "propertyShape" ;
                        ] ;
                    ]
                    [
                      sp:object [
                          sp:varName "not" ;
                        ] ;
                      sp:predicate sh:not ;
                      sp:subject [
                          sp:varName "propertyShape" ;
                        ] ;
                    ]
                    [
                      a sp:Filter ;
                      sp:expression [
                          a tosh:hasShape ;
                          sp:arg1 [
                              sp:varName "object" ;
                            ] ;
                          sp:arg2 [
                              sp:varName "not" ;
                            ] ;
                        ] ;
                    ]
                  ) ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:object ;
      rdfs:comment "The object to check." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The predicate to check." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:subject ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject to check at." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether a given node would be a valid object for a given subject/predicate combination, based on SHACL constraints. This will walk through all applicable property constraints at shapes that have the subject in its target. From those, it will currently only look for sh:not shapes." ;
  rdfs:label "is valid object for predicate at subject" ;
  rdfs:subClassOf swa:Functions ;
.
swa:labelExistsPreCondition
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Filter ;
            sp:expression [
                a sp:or ;
                sp:arg1 [
                    a sp:not ;
                    sp:arg1 [
                        a sp:bound ;
                        sp:arg1 spin:_arg1 ;
                      ] ;
                  ] ;
                sp:arg2 [
                    a sp:eq ;
                    sp:arg1 [
                        a fn:string-length ;
                        sp:arg1 spin:_arg1 ;
                      ] ;
                    sp:arg2 0 ;
                  ] ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression "Missing label." ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The input string." ;
    ] ;
  spin:private true ;
  spin:returnType xsd:string ;
  rdfs:comment "Can be used in ui:preCondition to check whether a given input string exists and is not empty." ;
  rdfs:label "label exists pre condition" ;
  rdfs:subClassOf swa:Functions ;
.
swa:labelInGraph
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "label" ;
          ]
        ) ;
      sp:where (
          [
            a sp:NamedGraph ;
            sp:elements (
                [
                  a sp:Bind ;
                  sp:expression [
                      a ui:label ;
                      sp:arg1 [
                          sp:varName "resource" ;
                        ] ;
                    ] ;
                  sp:variable [
                      sp:varName "label" ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode [
                sp:varName "resourceGraph" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resourceGraph ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The graph to operate on." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Calls ui:label in the context of a given graph." ;
  rdfs:label "label in graph" ;
  rdfs:subClassOf swa:Functions ;
.
swa:languageCode
  a rdf:Property ;
  rdfs:comment "The two-letter language code for a language associated with a Country." ;
  rdfs:domain swa:Country ;
  rdfs:label "language code" ;
  rdfs:range xsd:string ;
  rdfs:subPropertyOf swa:systemProperty ;
.
swa:letters
  a spin:MagicProperty ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "letter" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression "ABCDEFGHIJKLMNOPQRSTUVWXYZ" ;
            sp:variable [
                sp:varName "str" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a fn:string-length ;
                sp:arg1 [
                    sp:varName "str" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "length" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "?0" ;
              ] ;
            sp:predicate spif:for ;
            sp:subject [
                sp:varName "x" ;
              ] ;
          ]
          [
            sp:object 1 ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "?0" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "?1" ;
              ] ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "?0" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "length" ;
              ] ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "?1" ;
              ] ;
          ]
          [
            sp:object () ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "?1" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a fn:substring ;
                sp:arg1 [
                    sp:varName "str" ;
                  ] ;
                sp:arg2 [
                    sp:varName "x" ;
                  ] ;
                sp:arg3 1 ;
              ] ;
            sp:variable [
                sp:varName "letter" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Binds the variable on the left with all letters from A-Z." ;
  rdfs:label "letters" ;
  rdfs:subClassOf spin:MagicProperties ;
.
swa:lineBreak
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression """
""" ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Produces a line break (\\n) character." ;
  rdfs:label "line break" ;
  rdfs:subClassOf swa:Functions ;
.
swa:listMemberShape
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "result" ;
              ] ;
            sp:predicate sh:property ;
            sp:subject [
                sp:varName "propertyShape" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "list" ;
              ] ;
            sp:predicate sh:path ;
            sp:subject [
                sp:varName "result" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "zeroOrMore" ;
              ] ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "list" ;
              ] ;
          ]
          [
            sp:object rdf:rest ;
            sp:predicate sh:zeroOrMorePath ;
            sp:subject [
                sp:varName "zeroOrMore" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "first" ;
              ] ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "list" ;
              ] ;
          ]
          [
            sp:object rdf:first ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "first" ;
              ] ;
          ]
          [
            sp:object () ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "first" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:propertyShape ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The property shape to get the list member shape of." ;
    ] ;
  spin:private true ;
  spin:returnType sh:PropertyShape ;
  rdfs:comment "For a given property shape, this function returns a nested sh:property shape on rdf:rest*/rdf:first if such a thing exists." ;
  rdfs:label "list member shape" ;
  rdfs:subClassOf swa:Functions ;
.
swa:listMemberType
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "shape" ;
              ] ;
            sp:predicate swa:shapesForNodeFiltered ;
            sp:subject [
                sp:varName "subject" ;
              ] ;
          ]
          [
            a sp:TriplePath ;
            sp:object [
                sp:varName "propertyShape" ;
              ] ;
            sp:path [
                a sp:AltPath ;
                sp:path1 sh:property ;
                sp:path2 sh:parameter ;
              ] ;
            sp:subject [
                sp:varName "shape" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "property" ;
              ] ;
            sp:predicate sh:path ;
            sp:subject [
                sp:varName "propertyShape" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "nested" ;
              ] ;
            sp:predicate sh:property ;
            sp:subject [
                sp:varName "propertyShape" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "sequence" ;
              ] ;
            sp:predicate sh:path ;
            sp:subject [
                sp:varName "nested" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "first" ;
              ] ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "sequence" ;
              ] ;
          ]
          [
            sp:object rdf:rest ;
            sp:predicate sh:zeroOrMorePath ;
            sp:subject [
                sp:varName "first" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "rest" ;
              ] ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "sequence" ;
              ] ;
          ]
          [
            sp:object rdf:first ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "rest" ;
              ] ;
          ]
          [
            a sp:TriplePath ;
            sp:object [
                sp:varName "result" ;
              ] ;
            sp:path [
                a sp:AltPath ;
                sp:path1 sh:datatype ;
                sp:path2 sh:class ;
              ] ;
            sp:subject [
                sp:varName "nested" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdf:Property ;
      rdfs:comment "The rdf:List-valued property." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:subject ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject to get the member type of." ;
    ] ;
  spin:returnType rdfs:Resource ;
  rdfs:comment "Gets the declared type of list members for a given rdf:List-valued property at a given subject. This looks for SHACL patterns, currently limited to sh:property rdf:rest*/rdf:first combined with sh:datatype or sh:class." ;
  rdfs:label "list member type" ;
  rdfs:subClassOf swa:Functions ;
.
swa:localDomain
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "domain" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Union ;
            sp:elements (
                (
                  [
                    sp:object [
                        sp:varName "shape" ;
                      ] ;
                    sp:predicate swa:shapesForNodeFiltered ;
                    sp:subject [
                        sp:varName "object" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "ps" ;
                      ] ;
                    sp:predicate sh:property ;
                    sp:subject [
                        sp:varName "shape" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "path" ;
                      ] ;
                    sp:predicate sh:path ;
                    sp:subject [
                        sp:varName "ps" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "predicate" ;
                      ] ;
                    sp:predicate sh:inversePath ;
                    sp:subject [
                        sp:varName "path" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "domain" ;
                      ] ;
                    sp:predicate sh:class ;
                    sp:subject [
                        sp:varName "ps" ;
                      ] ;
                  ]
                )
                (
                  [
                    a sp:TriplePath ;
                    sp:object [
                        sp:varName "p" ;
                      ] ;
                    sp:path [
                        a sp:ModPath ;
                        sp:modMax -2 ;
                        sp:modMin 0 ;
                        sp:subPath rdfs:subPropertyOf ;
                      ] ;
                    sp:subject [
                        sp:varName "predicate" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "domain" ;
                      ] ;
                    sp:predicate rdfs:domain ;
                    sp:subject [
                        sp:varName "p" ;
                      ] ;
                  ]
                )
                (
                  [
                    a sp:Bind ;
                    sp:expression rdfs:Resource ;
                    sp:variable [
                        sp:varName "domain" ;
                      ] ;
                  ]
                )
              ) ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:object ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The object resource." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate to get the domain of." ;
    ] ;
  spin:private true ;
  spin:returnType rdfs:Class ;
  rdfs:comment "Gets the \"domain\" of a property at an object. This is used to narrow down the Subjects widgets at edit time. Currently only uses rdfs:domain of the property and, if present, the sh:class at a property shape that has the given predicate as its sh:inversePath." ;
  rdfs:label "local domain" ;
  rdfs:subClassOf swa:Functions ;
.
swa:localRange
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a swa:resourceType ;
                arg:resource [
                    sp:varName "subject" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "subjectType" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a swa:localRangeAtClass ;
                arg:class [
                    sp:varName "subjectType" ;
                  ] ;
                arg:property [
                    sp:varName "predicate" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "raw" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:if ;
                sp:arg1 [
                    a sp:or ;
                    sp:arg1 [
                        a sp:or ;
                        sp:arg1 [
                            a sp:isIRI ;
                            sp:arg1 [
                                sp:varName "raw" ;
                              ] ;
                          ] ;
                        sp:arg2 [
                            a swa:isDatatypeEnumeration ;
                            arg:resource [
                                sp:varName "raw" ;
                              ] ;
                          ] ;
                      ] ;
                    sp:arg2 [
                        a swa:isResourceEnumeration ;
                        arg:resource [
                            sp:varName "raw" ;
                          ] ;
                      ] ;
                  ] ;
                sp:arg2 [
                    sp:varName "raw" ;
                  ] ;
                sp:arg3 rdfs:Resource ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:subject ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject - may be unbound to fall back to the subjectType." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate to get the local range of." ;
    ] ;
  spin:private true ;
  spin:returnType rdfs:Resource ;
  rdfs:comment "Computes the local range of a property at a given subject. This uses swa:localRangeAtClass for the actual work, but falls back to rdfs:Resource if needed. In other words, this function will always return a result. Blank node ranges are only supported if they are enumerations, but owl:unionOf ranges are mapped to rdfs:Resource." ;
  rdfs:label "local range" ;
  rdfs:subClassOf swa:Functions ;
.
swa:localRangeAtClass
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:expression [
                a sp:coalesce ;
                sp:arg1 [
                    a spif:walkObjects ;
                    sp:arg1 [
                        sp:varName "class" ;
                      ] ;
                    sp:arg2 rdfs:subClassOf ;
                    sp:arg3 swa:allValuesFromFunctor ;
                    sp:arg4 [
                        sp:varName "property" ;
                      ] ;
                  ] ;
                sp:arg2 [
                    a spif:walkObjects ;
                    sp:arg1 [
                        sp:varName "class" ;
                      ] ;
                    sp:arg2 rdfs:subClassOf ;
                    sp:arg3 swa:splValueTypeFunctor ;
                    sp:arg4 [
                        sp:varName "property" ;
                      ] ;
                  ] ;
                sp:arg3 [
                    a swa:globalRange ;
                    arg:property [
                        sp:varName "property" ;
                      ] ;
                  ] ;
                sp:arg4 [
                    a swa:defaultRange ;
                    arg:property [
                        sp:varName "property" ;
                      ] ;
                  ] ;
              ] ;
            sp:varName "result" ;
          ]
        ) ;
      sp:where () ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:class ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class to start traversal at." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property to get the local range of." ;
    ] ;
  spin:private true ;
  spin:returnType rdfs:Resource ;
  rdfs:comment """Checks (in that order) for declared SHACL sh:class/sh:datatype constraints (including those from sh:or and sh:node dash:ListShape for rdf:Lists), owl:allValuesFrom restrictions in superclasses, spl:valueType in SPIN constraints (spl:Argument and spl:Attribute) and finally rdfs:range at the property. It falls back to swa:defaultRange if nothing else is found.

Note that TopBraid Suite uses a native (optimized) implementation of this function, i.e. the SPIN body is never called when used inside of TopBraid Suite and the SPIN body has a slightly different behavior.""" ;
  rdfs:label "local range at class" ;
  rdfs:subClassOf swa:Functions ;
.
swa:localUnionRangeAtClass
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:class ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class to start traversal at." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property to get the local range of." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks if a given class has multiple \"ranges\" for a given property, defined via sh:or constraints at the nearest shape, and returns that sh:or if it does. Otherwise, returns nothing." ;
  rdfs:label "local union range at class" ;
  rdfs:subClassOf swa:Functions ;
.
swa:matchingArgumentPredicate
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:orderBy (
          [
            sp:varName "predicate" ;
          ]
        ) ;
      sp:resultVariables (
          [
            sp:varName "predicate" ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "arg" ;
              ] ;
            sp:predicate spin:constraint ;
            sp:subject [
                sp:varName "module" ;
              ] ;
          ]
          [
            sp:object spl:Argument ;
            sp:predicate rdf:type ;
            sp:subject [
                sp:varName "arg" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "argValueType" ;
              ] ;
            sp:predicate spl:valueType ;
            sp:subject [
                sp:varName "arg" ;
              ] ;
          ]
          [
            a sp:NamedGraph ;
            sp:elements (
                [
                  a sp:TriplePath ;
                  sp:object [
                      sp:varName "argValueType" ;
                    ] ;
                  sp:path [
                      a sp:ModPath ;
                      sp:modMax -2 ;
                      sp:modMin 0 ;
                      sp:subPath rdfs:subClassOf ;
                    ] ;
                  sp:subject [
                      sp:varName "valueType" ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode [
                sp:varName "valueTypeGraph" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "predicate" ;
              ] ;
            sp:predicate spl:predicate ;
            sp:subject [
                sp:varName "arg" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:module ;
      spl:valueType spin:Module ;
      rdfs:comment "The SPIN module to query." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:valueType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The value type to match." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:valueTypeGraph ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The graph containing the type declaration of the valueType, e.g. subclasses of skos:Concept." ;
    ] ;
  spin:private true ;
  spin:returnType rdf:Property ;
  rdfs:comment "Walks through all declared arguments of a given SPIN module (e.g. SPIN Template or SM function) and compares the value type with a given type. The function returns the first argument where the type could be used as value." ;
  rdfs:label "matching argument predicate" ;
  rdfs:subClassOf swa:Functions ;
.
swa:newResource
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:expression [
                a sp:coalesce ;
                sp:arg1 [
                    a swa:newResourceByIndex ;
                    arg:resourceType [
                        sp:varName "resourceType" ;
                      ] ;
                  ] ;
                sp:arg2 [
                    a swa:newResourceByUUID ;
                    arg:resourceType [
                        sp:varName "resourceType" ;
                      ] ;
                  ] ;
              ] ;
            sp:varName "result" ;
          ]
        ) ;
      sp:where () ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The type of the new resource." ;
    ] ;
  spin:private true ;
  spin:returnType rdfs:Resource ;
  rdfs:comment "Produces a suggestion for a URI for a new resource. This first tries to produce a unique URI by appending a number behind a base URI. If that fails, it uses a UUID." ;
  rdfs:label "new resource" ;
  rdfs:subClassOf swa:Functions ;
.
swa:newResourceByIndex
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a swa:getDefaultNamespace ;
              ] ;
            sp:variable [
                sp:varName "base" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a afn:localname ;
                sp:arg1 [
                    sp:varName "resourceType" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "name" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "?0" ;
              ] ;
            sp:predicate spif:for ;
            sp:subject [
                sp:varName "index" ;
              ] ;
          ]
          [
            sp:object 0 ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "?0" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "?1" ;
              ] ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "?0" ;
              ] ;
          ]
          [
            sp:object 9999 ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "?1" ;
              ] ;
          ]
          [
            sp:object () ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "?1" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:iri ;
                sp:arg1 [
                    a fn:concat ;
                    sp:arg1 [
                        a xsd:string ;
                        sp:arg1 [
                            sp:varName "base" ;
                          ] ;
                      ] ;
                    sp:arg2 [
                        sp:varName "name" ;
                      ] ;
                    sp:arg3 "_" ;
                    sp:arg4 [
                        sp:varName "index" ;
                      ] ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:notExists ;
                sp:elements (
                    [
                      sp:object [
                          sp:varName "anyType" ;
                        ] ;
                      sp:predicate rdf:type ;
                      sp:subject [
                          sp:varName "result" ;
                        ] ;
                    ]
                  ) ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The type of the new resource." ;
    ] ;
  spin:private true ;
  spin:returnType rdfs:Resource ;
  rdfs:comment "Produces a suggestion for a URI for a new resource. This uses the declared default namespace as base, and then adds the type local name and then a running number. The function makes sure that the URI is not used in the current model yet." ;
  rdfs:label "new resource by index" ;
  rdfs:subClassOf swa:Functions ;
.
swa:newResourceByIndexForAssetCollection
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a swa:getDefaultNamespace ;
              ] ;
            sp:variable [
                sp:varName "base" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a swa:getURICounterOffset ;
                arg:resourceType [
                    sp:varName "resourceType" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "offset" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a swa:constructPreambleForURI ;
                arg:resourceType [
                    sp:varName "resourceType" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "preamble" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a afn:localname ;
                sp:arg1 [
                    sp:varName "resourceType" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "name" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:iri ;
                sp:arg1 [
                    a sp:concat ;
                    sp:arg1 [
                        sp:varName "base" ;
                      ] ;
                    sp:arg2 [
                        sp:varName "preamble" ;
                      ] ;
                    sp:arg3 [
                        a xsd:string ;
                        sp:arg1 [
                            sp:varName "offset" ;
                          ] ;
                      ] ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "uri" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a swa:ensureURIIsNotUsed ;
                arg:uri [
                    sp:varName "uri" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "notUsed" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:if ;
                sp:arg1 [
                    sp:varName "notUsed" ;
                  ] ;
                sp:arg2 [
                    sp:varName "uri" ;
                  ] ;
                sp:arg3 [
                    a swa:getNextUnusedURIForCounter ;
                    arg:base [
                        sp:varName "base" ;
                      ] ;
                    arg:offset [
                        sp:varName "offset" ;
                      ] ;
                    arg:preamble [
                        sp:varName "preamble" ;
                      ] ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The type of the new resource." ;
    ] ;
  spin:private true ;
  spin:returnType rdfs:Resource ;
  rdfs:comment """Produces a suggestion for a URI for a new resource. This uses the declared default namespace as base, and then adds the type local name and then a running number. The function makes sure that the URI is not used in the current model yet.

**May need revisted to avoid iteration of 10,000 attempts.**""" ;
  rdfs:label "new resource by index for asset collection" ;
  rdfs:subClassOf swa:Functions ;
.
swa:newResourceByLabel
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          (
            [
              a sp:Bind ;
              sp:expression [
                  a swa:getDefaultNamespace ;
                ] ;
              sp:variable [
                  sp:varName "base" ;
                ] ;
            ]
            [
              a sp:Filter ;
              sp:expression [
                  a sp:bound ;
                  sp:arg1 [
                      sp:varName "base" ;
                    ] ;
                ] ;
            ]
          )
          [
            a sp:Bind ;
            sp:expression [
                a sp:concat ;
                sp:arg1 [
                    a sp:str ;
                    sp:arg1 [
                        sp:varName "base" ;
                      ] ;
                  ] ;
                sp:arg2 [
                    a sp:encode_for_uri ;
                    sp:arg1 [
                        sp:varName "label" ;
                      ] ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "name" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "?0" ;
              ] ;
            sp:predicate spif:for ;
            sp:subject [
                sp:varName "index" ;
              ] ;
          ]
          [
            sp:object 0 ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "?0" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "?1" ;
              ] ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "?0" ;
              ] ;
          ]
          [
            sp:object 9999 ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "?1" ;
              ] ;
          ]
          [
            sp:object () ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "?1" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:iri ;
                sp:arg1 [
                    a sp:if ;
                    sp:arg1 [
                        a sp:eq ;
                        sp:arg1 [
                            sp:varName "index" ;
                          ] ;
                        sp:arg2 0 ;
                      ] ;
                    sp:arg2 [
                        sp:varName "name" ;
                      ] ;
                    sp:arg3 [
                        a sp:concat ;
                        sp:arg1 [
                            sp:varName "name" ;
                          ] ;
                        sp:arg2 "_" ;
                        sp:arg3 [
                            a sp:str ;
                            sp:arg1 [
                                sp:varName "index" ;
                              ] ;
                          ] ;
                      ] ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:notExists ;
                sp:elements (
                    [
                      sp:object [
                          sp:varName "anyType" ;
                        ] ;
                      sp:predicate rdf:type ;
                      sp:subject [
                          sp:varName "result" ;
                        ] ;
                    ]
                  ) ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:label ;
      spl:valueType xsd:string ;
      rdfs:comment "The label as entered by a user." ;
    ] ;
  spin:private true ;
  spin:returnType rdfs:Resource ;
  rdfs:comment "Produces a suggestion for a URI for a new resource. This uses the default namespace as base, and then adds a URI-encoded label and then a running number. The function makes sure that the URI is not used in the current model yet." ;
  rdfs:label "new resource by label" ;
  rdfs:subClassOf swa:Functions ;
.
swa:newResourceByUUID
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a swa:getDefaultNamespace ;
              ] ;
            sp:variable [
                sp:varName "base" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:coalesce ;
                sp:arg1 [
                    a afn:localname ;
                    sp:arg1 [
                        sp:varName "resourceType" ;
                      ] ;
                  ] ;
                sp:arg2 "Thing" ;
              ] ;
            sp:variable [
                sp:varName "name" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:iri ;
                sp:arg1 [
                    a sp:concat ;
                    sp:arg1 [
                        a sp:str ;
                        sp:arg1 [
                            sp:varName "base" ;
                          ] ;
                      ] ;
                    sp:arg2 [
                        sp:varName "name" ;
                      ] ;
                    sp:arg3 "_" ;
                    sp:arg4 [
                        a spif:generateUUID ;
                      ] ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The type of the new resource." ;
    ] ;
  spin:private true ;
  spin:returnType rdfs:Resource ;
  rdfs:comment "Produces a suggestion for a URI for a new resource. This uses the URI of the main owl:Ontology as base, and then adds the type local name and then a UUID." ;
  rdfs:label "new resource by UUID" ;
  rdfs:subClassOf swa:Functions ;
.
swa:newResourceByUUIDForAssetCollection
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a swa:getDefaultNamespace ;
              ] ;
            sp:variable [
                sp:varName "base" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a swa:constructPreambleForURI ;
                arg:resourceType [
                    sp:varName "resourceType" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "preamble" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:iri ;
                sp:arg1 [
                    a sp:concat ;
                    sp:arg1 [
                        a sp:str ;
                        sp:arg1 [
                            sp:varName "base" ;
                          ] ;
                      ] ;
                    sp:arg2 [
                        sp:varName "preamble" ;
                      ] ;
                    sp:arg3 [
                        a spif:generateUUID ;
                      ] ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The type of the new resource." ;
    ] ;
  spin:private true ;
  spin:returnType rdfs:Resource ;
  rdfs:comment "Produces a suggestion for a URI for a new resource. This uses the URI of the main owl:Ontology as base, and then adds the type local name and then a UUID." ;
  rdfs:label "new resource by UUID for asset collection" ;
  rdfs:subClassOf swa:Functions ;
.
swa:newResourceForAssetCollection
  a ui:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The type of the new resource." ;
    ] ;
  spin:private true ;
  spin:returnType rdfs:Resource ;
  ui:prototype [
      a ui:group ;
      <http://uispin.org/let#useConstructMethod> [
          a swa:getURIConstructMethod ;
        ] ;
      ui:child [
          a ui:CommentNode ;
          ui:childIndex 0 ;
          rdfs:comment "ui:dumpScope ui:message=\"AAA1: swa:newResource\"/" ;
        ] ;
      ui:child [
          a ui:else ;
          ui:child [
              a ui:return ;
              ui:childIndex 0 ;
              ui:result [
                  a swa:newResourceByIndexForAssetCollection ;
                  arg:resourceType [
                      sp:varName "resourceType" ;
                    ] ;
                ] ;
            ] ;
          ui:childIndex 3 ;
        ] ;
      ui:child [
          a ui:elseif ;
          ui:child [
              a ui:group ;
              <http://uispin.org/let#uri> [
                  a swa:newResourceUsingLabelForAssetCollection ;
                  arg:resourceType [
                      sp:varName "resourceType" ;
                    ] ;
                ] ;
              ui:child [
                  a ui:return ;
                  ui:childIndex 0 ;
                  ui:result [
                      sp:varName "uri" ;
                    ] ;
                ] ;
              ui:childIndex 0 ;
            ] ;
          ui:childIndex 2 ;
          ui:condition [
              a sp:eq ;
              sp:arg1 [
                  sp:varName "useConstructMethod" ;
                ] ;
              sp:arg2 "label" ;
            ] ;
        ] ;
      ui:child [
          a ui:if ;
          ui:child [
              a ui:return ;
              ui:childIndex 0 ;
              ui:result [
                  a swa:newResourceByUUIDForAssetCollection ;
                  arg:resourceType [
                      sp:varName "resourceType" ;
                    ] ;
                ] ;
            ] ;
          ui:childIndex 1 ;
          ui:condition [
              a sp:eq ;
              sp:arg1 [
                  sp:varName "useConstructMethod" ;
                ] ;
              sp:arg2 "uuid" ;
            ] ;
        ] ;
    ] ;
  rdfs:comment "Produces a suggestion for a URI for a new resource in an asset collection.  This is controlled by configuration parameters, if these parameters are not set it first tries to produce a unique URI by appending a number behind a base URI. If that fails, it uses a UUID." ;
  rdfs:label "new resource for asset collection" ;
  rdfs:subClassOf ui:Functions ;
.
swa:newResourceUsingLabelForAssetCollection
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a swa:getDefaultNamespace ;
              ] ;
            sp:variable [
                sp:varName "base" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a swa:constructPreambleForURI ;
                arg:resourceType [
                    sp:varName "resourceType" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "preamble" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:iri ;
                sp:arg1 [
                    a sp:concat ;
                    sp:arg1 [
                        a sp:str ;
                        sp:arg1 [
                            sp:varName "base" ;
                          ] ;
                      ] ;
                    sp:arg2 [
                        sp:varName "preamble" ;
                      ] ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:private true ;
  spin:returnType rdfs:Resource ;
  rdfs:comment "Uses the label field for the URI" ;
  rdfs:label "new resource using label for asset collection" ;
  rdfs:subClassOf swa:Functions ;
.
swa:nonAbstractClassPreCondition
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Filter ;
            sp:expression [
                a swa:isAbstractClass ;
                arg:class spin:_arg1 ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression "Cannot create instance of abstract class." ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The type of the new resource" ;
    ] ;
  spin:private true ;
  spin:returnType xsd:string ;
  rdfs:comment "Can be used in ui:preCondition to check whether a given class is not abstract." ;
  rdfs:label "non abstract class pre condition" ;
  rdfs:subClassOf swa:Functions ;
.
swa:nonEmptyPrimaryKeyPreCondition
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          (
            [
              a sp:Filter ;
              sp:expression [
                  a swa:hasPrimaryKey ;
                  arg:class [
                      sp:varName "resourceType" ;
                    ] ;
                ] ;
            ]
          )
          [
            a sp:Bind ;
            sp:expression [
                a swa:primaryKeyURIStart ;
                arg:class [
                    sp:varName "resourceType" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "uriStart" ;
              ] ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:eq ;
                sp:arg1 [
                    a sp:str ;
                    sp:arg1 [
                        sp:varName "uri" ;
                      ] ;
                  ] ;
                sp:arg2 [
                    sp:varName "uriStart" ;
                  ] ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression "Missing primary key value" ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The type of the resource." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:uri ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The URI to check." ;
    ] ;
  spin:private true ;
  spin:returnType xsd:string ;
  rdfs:comment "Can be used in ui:preCondition to check whether a given URI is different from the uri start (if a primary key has been set)." ;
  rdfs:subClassOf swa:Functions ;
.
swa:object
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:expression [
                a sp:if ;
                sp:arg1 [
                    a sp:bound ;
                    sp:arg1 spin:_arg1 ;
                  ] ;
                sp:arg2 [
                    a spl:object ;
                    sp:arg1 spin:_arg1 ;
                    sp:arg2 [
                        sp:varName "predicate" ;
                      ] ;
                  ] ;
                sp:arg3 [
                    sp:varName "nothing" ;
                  ] ;
              ] ;
            sp:varName "result" ;
          ]
        ) ;
      sp:where () ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate." ;
    ] ;
  spin:private true ;
  rdfs:comment "Gets the best matching object for a given subject/predicate combination. Returns nothing if the subject (?arg1) is unbound." ;
  rdfs:label "object" ;
  rdfs:subClassOf swa:Functions ;
.
swa:objectsList
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject to get the objects of." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate to get the objects of." ;
    ] ;
  rdfs:comment "Collects all values (objects) of a given subject/predicate combination into a single string list, separated by commas. If there is just a single literal value, then return that value in the original data type. Used by SWA search forms to display optional (key) columns." ;
  rdfs:label "objects list" ;
  rdfs:subClassOf swa:Functions ;
  owl:versionInfo """An approximate implementation of this is

SELECT ((GROUP_CONCAT(?label; SEPARATOR=', ')) AS ?result)
WHERE {
    ( ?arg1 ?arg2 ) swa:orderedObjectLabels ?label .
}
ORDER BY (?label)

but it needs to return the original datatype (not a string) if there is just a single value.""" ;
.
swa:orderedObjectLabels
  a spin:MagicProperty ;
  spin:body [
      a sp:Select ;
      sp:orderBy (
          [
            sp:varName "label" ;
          ]
        ) ;
      sp:resultVariables (
          [
            sp:varName "label" ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "value" ;
              ] ;
            sp:predicate spin:_arg2 ;
            sp:subject spin:_arg1 ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a ui:label ;
                sp:arg1 [
                    sp:varName "value" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "label" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject to get the objects of." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate" ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Produces an ordered iterator over the ui:labels of the objects of a given subject/predicate combination. This is required by swa:objectsList because the GROUP_CONCAT is applied before ORDER BY (probably a Jena bug)." ;
  rdfs:label "ordered object labels" ;
  rdfs:subClassOf spin:MagicProperties ;
.
swa:orderedSubjectLabels
  a spin:MagicProperty ;
  spin:body [
      a sp:Select ;
      sp:orderBy (
          [
            sp:varName "label" ;
          ]
        ) ;
      sp:resultVariables (
          [
            sp:varName "label" ;
          ]
        ) ;
      sp:where (
          [
            sp:object spin:_arg1 ;
            sp:predicate spin:_arg2 ;
            sp:subject [
                sp:varName "value" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a ui:label ;
                sp:arg1 [
                    sp:varName "value" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "label" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The object to get the subjects of." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate" ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Produces an ordered iterator over the ui:labels of the subjects of a given object/predicate combination. This is required by swa:subjectsList because the GROUP_CONCAT is applied before ORDER BY (probably a Jena bug)." ;
  rdfs:label "ordered subject labels" ;
  rdfs:subClassOf spin:MagicProperties ;
.
swa:owlMaxCardinality
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "c" ;
          ]
        ) ;
      sp:where (
          [
            a sp:TriplePath ;
            sp:object [
                sp:varName "superClass" ;
              ] ;
            sp:path [
                a sp:ModPath ;
                sp:modMax -2 ;
                sp:modMin 0 ;
                sp:subPath rdfs:subClassOf ;
              ] ;
            sp:subject [
                sp:varName "class" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "property" ;
              ] ;
            sp:predicate owl:onProperty ;
            sp:subject [
                sp:varName "superClass" ;
              ] ;
          ]
          [
            a sp:TriplePath ;
            sp:object [
                sp:varName "c" ;
              ] ;
            sp:path [
                a sp:AltPath ;
                sp:path1 owl:cardinality ;
                sp:path2 owl:maxCardinality ;
              ] ;
            sp:subject [
                sp:varName "superClass" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:class ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class to get cardinality at." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property to get the cardinality of." ;
    ] ;
  spin:returnType xsd:integer ;
  rdfs:comment "Walks up the class tree to find the closest owl:maxCardinality or owl:cardinality restriction on a given property." ;
  rdfs:label "owl max cardinality" ;
  rdfs:subClassOf swa:Functions ;
.
swa:predicatesInGroup
  a spin:MagicProperty ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sp:arg2 ;
      rdfs:comment "The focus node or unbound." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType sh:PropertyGroup ;
      rdfs:comment "The property group to get the predicate of." ;
    ] ;
  rdfs:comment """Gets all predicates that are in a given group (?arg1) at a given focus node (?arg2). If no focus node is given, it will use the context variable that is also used by swa:resourceType(). The right hand side must be a list of three unbound variables - the first will contain the predicate, the second the predicate's label and the third is a boolean that is true if the path was walked in inverse direction.

This magic property is implemented natively by TopBraid for performance reasons.""" ;
  rdfs:label "predicates in group" ;
  rdfs:subClassOf spin:MagicProperties ;
.
swa:primaryKeyProperty
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "property" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Union ;
            sp:elements (
                (
                  [
                    a sp:TriplePath ;
                    sp:object [
                        sp:varName "type" ;
                      ] ;
                    sp:path [
                        a sp:ModPath ;
                        sp:modMax -2 ;
                        sp:modMin 0 ;
                        sp:subPath rdfs:subClassOf ;
                      ] ;
                    sp:subject [
                        sp:varName "class" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "constraint" ;
                      ] ;
                    sp:predicate spin:constraint ;
                    sp:subject [
                        sp:varName "type" ;
                      ] ;
                  ]
                  [
                    sp:object spl:PrimaryKeyPropertyConstraint ;
                    sp:predicate rdf:type ;
                    sp:subject [
                        sp:varName "constraint" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "property" ;
                      ] ;
                    sp:predicate arg:property ;
                    sp:subject [
                        sp:varName "constraint" ;
                      ] ;
                  ]
                )
                (
                  [
                    a sp:TriplePath ;
                    sp:object [
                        sp:varName "type" ;
                      ] ;
                    sp:path [
                        a sp:ModPath ;
                        sp:modMax -2 ;
                        sp:modMin 0 ;
                        sp:subPath rdfs:subClassOf ;
                      ] ;
                    sp:subject [
                        sp:varName "class" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "ps" ;
                      ] ;
                    sp:predicate sh:property ;
                    sp:subject [
                        sp:varName "type" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "uriStart" ;
                      ] ;
                    sp:predicate dash:uriStart ;
                    sp:subject [
                        sp:varName "ps" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "property" ;
                      ] ;
                    sp:predicate sh:path ;
                    sp:subject [
                        sp:varName "ps" ;
                      ] ;
                  ]
                  [
                    a sp:Filter ;
                    sp:expression [
                        a sp:isIRI ;
                        sp:arg1 [
                            sp:varName "property" ;
                          ] ;
                      ] ;
                  ]
                )
              ) ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:class ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class to get the primary key of." ;
    ] ;
  spin:returnType rdf:Property ;
  rdfs:comment "Gets the primary key property for a given class or its superclasses - either defined using SPIN or DASH." ;
  rdfs:label "primary key property" ;
  rdfs:subClassOf swa:Functions ;
.
swa:primaryKeyPropertyInGraph
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "property" ;
          ]
        ) ;
      sp:where (
          [
            a sp:NamedGraph ;
            sp:elements (
                [
                  a sp:Bind ;
                  sp:expression [
                      a swa:primaryKeyProperty ;
                      arg:class [
                          sp:varName "class" ;
                        ] ;
                    ] ;
                  sp:variable [
                      sp:varName "property" ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode [
                sp:varName "graph" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:class ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class to get the primary key of." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:graph ;
      spl:valueType rdfs:Resource ;
    ] ;
  spin:returnType rdf:Property ;
  rdfs:comment "Gets the primary key property for a given class or its superclasses - either defined using SPIN or DASH." ;
  rdfs:label "primary key property" ;
  rdfs:subClassOf swa:Functions ;
.
swa:primaryKeyURIStart
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "uriStart" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Union ;
            sp:elements (
                (
                  [
                    a sp:TriplePath ;
                    sp:object [
                        sp:varName "type" ;
                      ] ;
                    sp:path [
                        a sp:ModPath ;
                        sp:modMax -2 ;
                        sp:modMin 0 ;
                        sp:subPath rdfs:subClassOf ;
                      ] ;
                    sp:subject [
                        sp:varName "class" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "constraint" ;
                      ] ;
                    sp:predicate spin:constraint ;
                    sp:subject [
                        sp:varName "type" ;
                      ] ;
                  ]
                  [
                    sp:object spl:PrimaryKeyPropertyConstraint ;
                    sp:predicate rdf:type ;
                    sp:subject [
                        sp:varName "constraint" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "uriStart" ;
                      ] ;
                    sp:predicate arg:uriStart ;
                    sp:subject [
                        sp:varName "constraint" ;
                      ] ;
                  ]
                )
                (
                  [
                    a sp:TriplePath ;
                    sp:object [
                        sp:varName "type" ;
                      ] ;
                    sp:path [
                        a sp:ModPath ;
                        sp:modMax -2 ;
                        sp:modMin 0 ;
                        sp:subPath rdfs:subClassOf ;
                      ] ;
                    sp:subject [
                        sp:varName "class" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "ps" ;
                      ] ;
                    sp:predicate sh:property ;
                    sp:subject [
                        sp:varName "type" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "uriStart" ;
                      ] ;
                    sp:predicate dash:uriStart ;
                    sp:subject [
                        sp:varName "ps" ;
                      ] ;
                  ]
                )
              ) ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:class ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class to get the primary key of." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Gets the URI start of the primary key for a given class or its superclasses - either defined using SPIN or DASH." ;
  rdfs:label "primary key URI start" ;
  rdfs:subClassOf swa:Functions ;
.
swa:propertyCommentAtNode
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property to get the comment of." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:type ;
      rdfs:comment "The node for the context." ;
    ] ;
  rdfs:comment "Gets the display comment of a property in the context of a given node, falling back to swa:resourceType() if no node is provided. This is usually the rdfs:comment of the property but may be the sh:description if a suitable shape exists. This function is natively implemented for performance reasons." ;
  rdfs:label "property comment at class or shape" ;
  rdfs:subClassOf swa:Functions ;
.
swa:propertyEditWidget
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a swa:propertyShapePropertyAtNode ;
                arg:predicate [
                    sp:varName "property" ;
                  ] ;
                arg:property tosh:editWidget ;
                arg:resource [
                    sp:varName "focusNode" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:focusNode ;
      rdfs:comment "The focus node." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate to get the widget for." ;
    ] ;
  rdfs:comment "Gets a tosh:editWidget defined for a given property at a given focus node." ;
  rdfs:label "property edit widget" ;
  rdfs:subClassOf swa:Functions ;
.
swa:propertyGroupsForNode
  a spin:MagicProperty ;
  spin:body [
      a sp:Select ;
      sp:distinct true ;
      sp:resultVariables (
          [
            sp:varName "group" ;
          ]
        ) ;
      sp:where (
          (
            [
              sp:object [
                  sp:varName "shape" ;
                ] ;
              sp:predicate swa:shapesForNodeFiltered ;
              sp:subject spin:_arg1 ;
            ]
            [
              a sp:TriplePath ;
              sp:object [
                  sp:varName "propertyShape" ;
                ] ;
              sp:path [
                  a sp:AltPath ;
                  sp:path1 sh:property ;
                  sp:path2 sh:parameter ;
                ] ;
              sp:subject [
                  sp:varName "shape" ;
                ] ;
            ]
          )
          [
            sp:object [
                sp:varName "group" ;
              ] ;
            sp:predicate sh:group ;
            sp:subject [
                sp:varName "propertyShape" ;
              ] ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:not ;
                sp:arg1 [
                    a dash:isDeactivated ;
                    sp:arg1 [
                        sp:varName "propertyShape" ;
                      ] ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to get the property groups for." ;
    ] ;
  spin:returnType sh:PropertyGroup ;
  rdfs:comment "Gets all sh:PropertyGroups associated with a given node via property constraints, falling back to swa:resourceType() if no node is provided. This is walking up the class hierarchy for any shapes that are in target, then walks the property constraint and parameter declarations of these shapes to find sh:groups." ;
  rdfs:subClassOf spin:MagicProperties ;
.
swa:propertyLabelAtClassOrShape
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdfs:Property ;
      rdfs:comment "The property to get the label of." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:theClassOrShape ;
      rdfs:comment "The class/shape for the context." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Gets the display label of a property in the context of a given class or shape. This is usually the rdfs:label of the property but may be the sh:name if a suitable shape exists. This function is natively implemented for performance reasons." ;
  rdfs:subClassOf swa:Functions ;
.
swa:propertyLabelAtNode
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      rdfs:comment "The focus node, for context." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Gets the display label of a property in the context of a given node, falling back to swa:resourceType() if no node is given. This is usually the rdfs:label of the property but may be the sh:name if a suitable shape exists. This function is natively implemented for performance reasons." ;
  rdfs:subClassOf swa:Functions ;
.
swa:propertyShapePropertyAtClass
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "value" ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "shape" ;
              ] ;
            sp:predicate swa:shapesForType ;
            sp:subject [
                sp:varName "resourceType" ;
              ] ;
          ]
          [
            a sp:TriplePath ;
            sp:object [
                sp:varName "propertyShape" ;
              ] ;
            sp:path [
                a sp:AltPath ;
                sp:path1 sh:property ;
                sp:path2 sh:parameter ;
              ] ;
            sp:subject [
                sp:varName "shape" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "predicate" ;
              ] ;
            sp:predicate sh:path ;
            sp:subject [
                sp:varName "propertyShape" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "value" ;
              ] ;
            sp:predicate [
                sp:varName "property" ;
              ] ;
            sp:subject [
                sp:varName "propertyShape" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:cachableForOntologies true ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The constrained property (value of sh:path)." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property to get, e.g. sh:order." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class." ;
    ] ;
  rdfs:comment "Gets the \"first\" value of a given property (such as sh:name) from all shapes associated with a given shape or class." ;
  rdfs:subClassOf swa:Functions ;
.
swa:propertyShapePropertyAtClassInversePath
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "value" ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "shape" ;
              ] ;
            sp:predicate swa:shapesForType ;
            sp:subject [
                sp:varName "resourceType" ;
              ] ;
          ]
          [
            a sp:TriplePath ;
            sp:object [
                sp:varName "propertyShape" ;
              ] ;
            sp:path [
                a sp:AltPath ;
                sp:path1 sh:property ;
                sp:path2 sh:parameter ;
              ] ;
            sp:subject [
                sp:varName "shape" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "path" ;
              ] ;
            sp:predicate sh:path ;
            sp:subject [
                sp:varName "propertyShape" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "predicate" ;
              ] ;
            sp:predicate sh:inversePath ;
            sp:subject [
                sp:varName "path" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "value" ;
              ] ;
            sp:predicate [
                sp:varName "property" ;
              ] ;
            sp:subject [
                sp:varName "propertyShape" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:cachableForOntologies true ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The constrained property (value of sh:path)." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property to get, e.g. sh:order." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class." ;
    ] ;
  rdfs:comment "Gets the \"first\" value of a given property (such as sh:name) from all shapes associated with a given shape or class, for a given inverse predicate." ;
  rdfs:subClassOf swa:Functions ;
.
swa:propertyShapePropertyAtNode
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "value" ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "shape" ;
              ] ;
            sp:predicate swa:shapesForNode ;
            sp:subject [
                sp:varName "resource" ;
              ] ;
          ]
          [
            a sp:TriplePath ;
            sp:object [
                sp:varName "propertyShape" ;
              ] ;
            sp:path [
                a sp:AltPath ;
                sp:path1 sh:property ;
                sp:path2 sh:parameter ;
              ] ;
            sp:subject [
                sp:varName "shape" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "predicate" ;
              ] ;
            sp:predicate sh:path ;
            sp:subject [
                sp:varName "propertyShape" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "value" ;
              ] ;
            sp:predicate [
                sp:varName "property" ;
              ] ;
            sp:subject [
                sp:varName "propertyShape" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The focus node or unbound." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The constrained property (value of sh:path)." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property to get, e.g. sh:order." ;
    ] ;
  rdfs:comment "Gets the \"first\" value of a given property (such as sh:name) from all shapes associated with a given focus node. If the focus node is unbound (e.g. in search forms), this falls back to the swa:resourceTypes." ;
  rdfs:subClassOf swa:Functions ;
.
swa:propertyViewWidget
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a swa:propertyShapePropertyAtNode ;
                arg:predicate [
                    sp:varName "property" ;
                  ] ;
                arg:property tosh:viewWidget ;
                arg:resource [
                    sp:varName "focusNode" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:focusNode ;
      rdfs:comment "The focus node." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate to get the widget for." ;
    ] ;
  rdfs:comment "Gets a tosh:viewWidget defined for a given property at a given focus node." ;
  rdfs:label "property view widget" ;
  rdfs:subClassOf swa:Functions ;
.
swa:relevantClassOfProperty
  a spin:MagicProperty ;
  spin:body [
      a sp:Select ;
      sp:distinct true ;
      sp:resultVariables (
          [
            sp:varName "property" ;
          ]
        ) ;
      sp:where (
          [
            a sp:TriplePath ;
            sp:object [
                sp:varName "cls" ;
              ] ;
            sp:path [
                a sp:ModPath ;
                sp:modMax -2 ;
                sp:modMin 0 ;
                sp:subPath rdfs:subClassOf ;
              ] ;
            sp:subject spin:_arg1 ;
          ]
          [
            sp:object [
                sp:varName "property" ;
              ] ;
            sp:predicate swa:directRelevantClassOfProperty ;
            sp:subject [
                sp:varName "cls" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class to get the properties of." ;
    ] ;
  spin:returnType rdf:Property ;
  rdfs:comment "Finds the properties that are attached to a given class or its superclasses." ;
  rdfs:label "relevant class of property" ;
  rdfs:subClassOf spin:MagicProperties ;
.
swa:resourceType
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a sp:coalesce ;
                sp:arg1 [
                    a ui:contextValue ;
                    sp:arg1 "resourceType" ;
                  ] ;
                sp:arg2 [
                    a sp:if ;
                    sp:arg1 [
                        a sp:bound ;
                        sp:arg1 [
                            sp:varName "resource" ;
                          ] ;
                      ] ;
                    sp:arg2 [
                        a sp:coalesce ;
                        sp:arg1 [
                            a spl:object ;
                            sp:arg1 [
                                sp:varName "resource" ;
                              ] ;
                            sp:arg2 rdf:type ;
                          ] ;
                        sp:arg2 rdfs:Resource ;
                      ] ;
                    sp:arg3 rdfs:Resource ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource (may be unbound)." ;
    ] ;
  spin:private true ;
  spin:returnType rdfs:Class ;
  rdfs:comment "Gets a valid rdf:type for a given resource. If the context variable 'resourceType' is bound, then return that. Otherwise return the 'first' rdf:type of ?resource. As a fall-back, always use rdfs:Resource." ;
  rdfs:label "resource type" ;
  rdfs:subClassOf swa:Functions ;
.
swa:resourceTypes
  a spin:MagicProperty ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Union ;
            sp:elements (
                (
                  (
                    [
                      a sp:Filter ;
                      sp:expression [
                          a sp:and ;
                          sp:arg1 [
                              a sp:bound ;
                              sp:arg1 spin:_arg1 ;
                            ] ;
                          sp:arg2 [
                              a sp:exists ;
                              sp:elements (
                                  [
                                    sp:object [
                                        sp:varName "any" ;
                                      ] ;
                                    sp:predicate rdf:type ;
                                    sp:subject spin:_arg1 ;
                                  ]
                                ) ;
                            ] ;
                        ] ;
                    ]
                  )
                  [
                    sp:object [
                        sp:varName "result" ;
                      ] ;
                    sp:predicate rdf:type ;
                    sp:subject spin:_arg1 ;
                  ]
                )
                (
                  [
                    a sp:Filter ;
                    sp:expression [
                        a sp:or ;
                        sp:arg1 [
                            a sp:not ;
                            sp:arg1 [
                                a sp:bound ;
                                sp:arg1 spin:_arg1 ;
                              ] ;
                          ] ;
                        sp:arg2 [
                            a sp:notExists ;
                            sp:elements (
                                [
                                  sp:object [
                                      sp:varName "any" ;
                                    ] ;
                                  sp:predicate rdf:type ;
                                  sp:subject spin:_arg1 ;
                                ]
                              ) ;
                          ] ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression [
                        a sp:coalesce ;
                        sp:arg1 [
                            a ui:contextValue ;
                            sp:arg1 "resourceType" ;
                          ] ;
                        sp:arg2 rdfs:Resource ;
                      ] ;
                    sp:variable [
                        sp:varName "result" ;
                      ] ;
                  ]
                )
              ) ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to get the types of, or unbound to fall back to the context value." ;
    ] ;
  spin:returnType rdfs:Class ;
  rdfs:comment "Gets all rdf:types of a resource. The resource may actually not be given (e.g. when we are populating a Search form), in which case it will try to find the value of the context variable \"resourceType\", which is set by the surrounding form. If none of these are present, it falls back to rdfs:Resource." ;
  rdfs:label "resource types" ;
  rdfs:subClassOf spin:MagicProperties ;
.
swa:resourceURIconstructorFunction
  a rdf:Property ;
  rdfs:label "resource URIconstructor function" ;
.
swa:rootView
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "parent" ;
          ]
        ) ;
      sp:where (
          [
            a sp:NamedGraph ;
            sp:elements (
                [
                  a sp:TriplePath ;
                  sp:object [
                      sp:varName "view" ;
                    ] ;
                  sp:path [
                      a sp:ModPath ;
                      sp:modMax -2 ;
                      sp:modMin 0 ;
                      sp:subPath ui:child ;
                    ] ;
                  sp:subject [
                      sp:varName "parent" ;
                    ] ;
                ]
                [
                  a sp:Filter ;
                  sp:expression [
                      a sp:notExists ;
                      sp:elements (
                          [
                            sp:object [
                                sp:varName "parent" ;
                              ] ;
                            sp:predicate ui:child ;
                            sp:subject [
                                sp:varName "another" ;
                              ] ;
                          ]
                        ) ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode ui:graph ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:view ;
      spl:valueType ui:Element ;
      rdfs:comment "The view to get the root of." ;
    ] ;
  spin:private true ;
  spin:returnType ui:Element ;
  rdfs:comment "Walks up the child hierarchy of SWP nodes in the ui:graph until it finds no further parent for the provided view." ;
  rdfs:label "root view" ;
  rdfs:subClassOf swa:Functions ;
.
swa:shapesForNode
  a spin:MagicProperty ;
  spin:body [
      a sp:Select ;
      sp:distinct true ;
      sp:resultVariables (
          [
            sp:varName "shape" ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "type" ;
              ] ;
            sp:predicate swa:resourceTypes ;
            sp:subject spin:_arg1 ;
          ]
          [
            sp:object [
                sp:varName "shape" ;
              ] ;
            sp:predicate swa:shapesForType ;
            sp:subject [
                sp:varName "type" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The focus node." ;
    ] ;
  spin:returnType sh:Shape ;
  rdfs:comment "Gets all sh:Shapes associated with a given (focus) node. This is looking at the swa:resourceTypes of the node and then walks up the class hierarchy and collects all classes that are also instances of sh:Shape, and any shapes declared using sh:targetClass. Future versions will also be looking for sh:targetObjectsOf triples." ;
  rdfs:subClassOf spin:MagicProperties ;
.
swa:shapesForNodeFiltered
  a spin:MagicProperty ;
  spin:body [
      a sp:Select ;
      sp:distinct true ;
      sp:resultVariables (
          [
            sp:varName "shape" ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "shape" ;
              ] ;
            sp:predicate swa:shapesForNode ;
            sp:subject spin:_arg1 ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:not ;
                sp:arg1 [
                    a dash:isDeactivated ;
                    sp:arg1 [
                        sp:varName "shape" ;
                      ] ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The focus node." ;
    ] ;
  spin:returnType sh:Shape ;
  rdfs:comment "Same as swa:shapesForNode but only returning the non-deactivated shapes." ;
  rdfs:subClassOf spin:MagicProperties ;
.
swa:shapesForType
  a spin:MagicProperty ;
  spin:body [
      a sp:Select ;
      sp:distinct true ;
      sp:resultVariables (
          [
            sp:varName "shape" ;
          ]
        ) ;
      sp:where (
          [
            a sp:TriplePath ;
            sp:object [
                sp:varName "type" ;
              ] ;
            sp:path [
                a sp:ModPath ;
                sp:modMax -2 ;
                sp:modMin 0 ;
                sp:subPath rdfs:subClassOf ;
              ] ;
            sp:subject spin:_arg1 ;
          ]
          [
            a sp:Union ;
            sp:elements (
                (
                  [
                    sp:object [
                        sp:varName "type" ;
                      ] ;
                    sp:predicate sh:targetClass ;
                    sp:subject [
                        sp:varName "shape" ;
                      ] ;
                  ]
                )
                (
                  [
                    a sp:Filter ;
                    sp:expression [
                        a spl:instanceOf ;
                        sp:arg1 [
                            sp:varName "type" ;
                          ] ;
                        sp:arg2 sh:Shape ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression [
                        sp:varName "type" ;
                      ] ;
                    sp:variable [
                        sp:varName "shape" ;
                      ] ;
                  ]
                )
              ) ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The type to get the shapes for." ;
    ] ;
  spin:returnType sh:Shape ;
  rdfs:comment """Gets all sh:Shapes associated with a given type. This is walking up the class hierarchy and collects all classes that are also instances of sh:Shape, and any shapes declared using sh:targetClass.

In TopBraid, this magic property is implemented as a native Java function for performance reasons.""" ;
  rdfs:subClassOf spin:MagicProperties ;
.
swa:shortestPathsBetweenNodes
  a spin:MagicProperty ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sp:arg3 ;
      spl:valueType xsd:integer ;
      rdfs:comment "The maximum number of results to return. Defaults to 1." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sp:arg4 ;
      spl:valueType xsd:integer ;
      rdfs:comment "The maximum length/depth of traversal, defaults to 5." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      rdfs:comment "The start node (must be concrete)." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      rdfs:comment "The end node (must be concrete)." ;
    ] ;
  rdfs:comment """Attempts to find one or more shortests paths between two given RDF nodes in the current query graph. A path is a chain of triples, walked in either direction from a start node to an end node. It is strongly advised that the algorithm is limited by path length to prevent potential complete graph traversals.

Syntax:
 
 	( ?start ?end ?maxCount ?maxLength [?pred1 ?pred2...] ) swa:shortestPathsBetweenNodes ( ?value ?predicate ?inverse ?stepIndex ?pathIndex )
 
 Input values (left hand side):
 	?start - the start node (must be bound)
 	?end - the end node (must be bound)
 	?maxCount - the maximum number of paths to return (optional, defaults to 1)
 	?maxLength - the maximum length/depth of traversal (optional, defaults to 5)
 	?predX - the predicates to use, or none for any predicate
 
 Output values (all unbound variables on the right hand side, each result row represents one step in a path):
 	?value - the value node that was reached from the previous node
 	?predicate - the predicate that was used to reach ?value from the previous node
 	?inverse - true if ?predicate was walked from object to subject, false for subject to object (optional)
 	?stepIndex - the index of the step within its path (optional, starting at 0)
 	?pathIndex - the index of the path for cases where multiple paths are returned (optional, starting at 0)""" ;
  rdfs:label "shortest paths between nodes" ;
  rdfs:subClassOf spin:MagicProperties ;
.
swa:singleParameter
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "predicate" ;
          ]
        ) ;
      sp:where (
          [
            a sp:TriplePath ;
            sp:object [
                sp:varName "predicate" ;
              ] ;
            sp:path [
                a sp:SeqPath ;
                sp:path1 sh:parameter ;
                sp:path2 sh:path ;
              ] ;
            sp:subject [
                sp:varName "component" ;
              ] ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:and ;
                sp:arg1 [
                    a sp:isIRI ;
                    sp:arg1 [
                        sp:varName "predicate" ;
                      ] ;
                  ] ;
                sp:arg2 [
                    a sp:notExists ;
                    sp:elements (
                        [
                          a sp:TriplePath ;
                          sp:object [
                              sp:varName "other" ;
                            ] ;
                          sp:path [
                              a sp:SeqPath ;
                              sp:path1 sh:parameter ;
                              sp:path2 sh:path ;
                            ] ;
                          sp:subject [
                              sp:varName "component" ;
                            ] ;
                        ]
                        [
                          a sp:Filter ;
                          sp:expression [
                              a sp:ne ;
                              sp:arg1 [
                                  sp:varName "other" ;
                                ] ;
                              sp:arg2 [
                                  sp:varName "predicate" ;
                                ] ;
                            ] ;
                        ]
                      ) ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:component ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The constraint component." ;
    ] ;
  spin:returnType rdf:Property ;
  rdfs:comment "Gets the predicate of the parameter if a constraint component has exactly one parameter." ;
  rdfs:label "single parameter" ;
  rdfs:subClassOf swa:Functions ;
.
swa:splArgumentOnProperty
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "arg" ;
          ]
        ) ;
      sp:where (
          [
            a sp:TriplePath ;
            sp:object [
                sp:varName "superClass" ;
              ] ;
            sp:path [
                a sp:ModPath ;
                sp:modMax -2 ;
                sp:modMin 0 ;
                sp:subPath rdfs:subClassOf ;
              ] ;
            sp:subject [
                sp:varName "class" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "arg" ;
              ] ;
            sp:predicate spin:constraint ;
            sp:subject [
                sp:varName "superClass" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "property" ;
              ] ;
            sp:predicate spl:predicate ;
            sp:subject [
                sp:varName "arg" ;
              ] ;
          ]
          [
            sp:object spl:Argument ;
            sp:predicate rdf:type ;
            sp:subject [
                sp:varName "arg" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:class ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class to start traversal at." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property to look for." ;
    ] ;
  spin:private true ;
  spin:returnType spl:Argument ;
  rdfs:comment "Walks up the class hierarchy to look for spl:Arguments on the property." ;
  rdfs:label "spl:Argument on property" ;
  rdfs:subClassOf swa:Functions ;
.
swa:splValueTypeFunctor
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "valueType" ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "constraint" ;
              ] ;
            sp:predicate spin:constraint ;
            sp:subject [
                sp:varName "class" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "property" ;
              ] ;
            sp:predicate spl:predicate ;
            sp:subject [
                sp:varName "constraint" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "valueType" ;
              ] ;
            sp:predicate spl:valueType ;
            sp:subject [
                sp:varName "constraint" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property to look for." ;
    ] ;
  spin:private true ;
  spin:returnType rdfs:Class ;
  rdfs:comment "Can be used in conjunction with spif:walkObjects to get the \"first\" declared spin:constraint with an spl:valueType on a given spl:predicate (?property) at a given class (?class)." ;
  rdfs:label "spl:valueType functor" ;
  rdfs:subClassOf swa:ClassFunctorFunctions ;
.
swa:subjectsList
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:orderBy (
          [
            sp:varName "label" ;
          ]
        ) ;
      sp:resultVariables (
          [
            sp:expression [
                a sp:GroupConcat ;
                sp:expression [
                    sp:varName "label" ;
                  ] ;
                sp:separator ", " ;
              ] ;
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            sp:object spin:_arg1 ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "?0" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "?1" ;
              ] ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "?0" ;
              ] ;
          ]
          [
            sp:object spin:_arg2 ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "?1" ;
              ] ;
          ]
          [
            sp:object () ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "?1" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "label" ;
              ] ;
            sp:predicate swa:orderedSubjectLabels ;
            sp:subject [
                sp:varName "?0" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The object to get the subjects of." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate to get the objects of." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Collects all subjects of a given object/predicate combination into a single string list, separated by commas. Used by SWA search forms to display optional (key) columns." ;
  rdfs:label "subjects list" ;
  rdfs:subClassOf swa:Functions ;
.
swa:systemProperty
  a rdf:Property ;
  rdfs:label "system property" ;
.
swa:typesWithoutSuperclasses
  a spin:MagicProperty ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "type" ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "type" ;
              ] ;
            sp:predicate rdf:type ;
            sp:subject spin:_arg1 ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:notExists ;
                sp:elements (
                    [
                      sp:object [
                          sp:varName "otherType" ;
                        ] ;
                      sp:predicate rdf:type ;
                      sp:subject spin:_arg1 ;
                    ]
                    [
                      a sp:Filter ;
                      sp:expression [
                          a sp:ne ;
                          sp:arg1 [
                              sp:varName "type" ;
                            ] ;
                          sp:arg2 [
                              sp:varName "otherType" ;
                            ] ;
                        ] ;
                    ]
                    [
                      a sp:TriplePath ;
                      sp:object [
                          sp:varName "type" ;
                        ] ;
                      sp:path [
                          a sp:ModPath ;
                          sp:modMax -2 ;
                          sp:modMin 1 ;
                          sp:subPath rdfs:subClassOf ;
                        ] ;
                      sp:subject [
                          sp:varName "otherType" ;
                        ] ;
                    ]
                  ) ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject resource." ;
    ] ;
  rdfs:comment "For a given resource (left hand side), this returns all direct rdf:types (right hand side), dropping any types that are superclasses of these direct types. For example, if a property has rdf:types owl:AnnotationProperty and rdf:Property, then the rdf:Property triple will not be returned because rdf:Property is a super-property of owl:AnnotationProperty." ;
  rdfs:label "types without superclasses" ;
  rdfs:subClassOf spin:MagicProperties ;
.
swa:uiObject
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "object" ;
          ]
        ) ;
      sp:where (
          [
            a sp:NamedGraph ;
            sp:elements (
                [
                  a sp:Bind ;
                  sp:expression [
                      a spl:object ;
                      sp:arg1 spin:_arg1 ;
                      sp:arg2 spin:_arg2 ;
                    ] ;
                  sp:variable [
                      sp:varName "object" ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode ui:graph ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate." ;
    ] ;
  rdfs:comment "Similar to spl:object, but executed within the ui:graph." ;
  rdfs:label "ui object" ;
  rdfs:subClassOf swa:Functions ;
.
swa:unusedURIPreCondition
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "message" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Filter ;
            sp:expression [
                a sp:or ;
                sp:arg1 [
                    a sp:exists ;
                    sp:elements (
                        [
                          sp:object [
                              sp:varName "o" ;
                            ] ;
                          sp:predicate [
                              sp:varName "p" ;
                            ] ;
                          sp:subject [
                              sp:varName "resource" ;
                            ] ;
                        ]
                      ) ;
                  ] ;
                sp:arg2 [
                    a sp:exists ;
                    sp:elements (
                        [
                          sp:object [
                              sp:varName "resource" ;
                            ] ;
                          sp:predicate [
                              sp:varName "p" ;
                            ] ;
                          sp:subject [
                              sp:varName "s" ;
                            ] ;
                        ]
                      ) ;
                  ] ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a fn:concat ;
                sp:arg1 "The URI " ;
                sp:arg2 [
                    a xsd:string ;
                    sp:arg1 [
                        sp:varName "resource" ;
                      ] ;
                  ] ;
                sp:arg3 " is already used." ;
              ] ;
            sp:variable [
                sp:varName "message" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to check." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Can be used in conjunction with ui:preCondition to check whether a given URI has already been used in the current query graph." ;
  rdfs:label "unused URIPre condition" ;
  rdfs:subClassOf swa:Functions ;
.
swa:unwrap
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a sp:substr ;
                sp:arg1 [
                    sp:varName "string" ;
                  ] ;
                sp:arg2 2 ;
                sp:arg3 [
                    a sp:sub ;
                    sp:arg1 [
                        a sp:strlen ;
                        sp:arg1 [
                            sp:varName "string" ;
                          ] ;
                      ] ;
                    sp:arg2 2 ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:string ;
      spl:valueType xsd:string ;
      rdfs:comment "The input string." ;
    ] ;
  spin:private true ;
  spin:returnType xsd:string ;
  rdfs:comment "Takes a string such as <http://example.org> and returns the substring between the first and the last character, e.g. http://example.org" ;
  rdfs:label "unwrap" ;
  rdfs:subClassOf swa:Functions ;
.
swa:validURIPreCondition
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Filter ;
            sp:expression [
                a sp:not ;
                sp:arg1 [
                    a spif:isValidURI ;
                    sp:arg1 spin:_arg1 ;
                  ] ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a fn:concat ;
                sp:arg1 "Not a well-formed absolute URI: " ;
                sp:arg2 spin:_arg1 ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The argument string." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Can be used with ui:preCondition to check whether a given string is a valid URI." ;
  rdfs:label "valid URI pre-condition" ;
  rdfs:subClassOf swa:Functions ;
.
<http://topbraid.org/swa.spin>
  a owl:Ontology ;
  rdfs:comment "A collection of SPIN functions and auxiliary definitions to support building interactive web applications." ;
  rdfs:label "SWA SPIN Modules" ;
  owl:imports <http://datashapes.org/dash> ;
  owl:imports <http://spinrdf.org/spl> ;
  owl:imports <http://uispin.org/ui> ;
.
rdf:
  rdfs:label "RDF" ;
.
rdfs:
  rdfs:label "RDF Schema" ;
.
rdfs:domain
  a swa:PropertyAxiomProperty ;
.
rdfs:range
  a swa:PropertyAxiomProperty ;
.
rdfs:subClassOf
  a swa:ClassAxiomProperty ;
.
rdfs:subPropertyOf
  a swa:PropertyAxiomProperty ;
.
xsd:
  rdfs:label "XML Schema" ;
.
xsd:byte
  a swa:NumericDatatype ;
.
xsd:decimal
  a swa:NumericDatatype ;
.
xsd:double
  a swa:NumericDatatype ;
.
xsd:float
  a swa:NumericDatatype ;
.
xsd:int
  a swa:NumericDatatype ;
.
xsd:integer
  a swa:NumericDatatype ;
.
xsd:long
  a swa:NumericDatatype ;
.
xsd:negativeInteger
  a swa:NumericDatatype ;
.
xsd:nonNegativeInteger
  a swa:NumericDatatype ;
.
xsd:nonPositiveInteger
  a swa:NumericDatatype ;
.
xsd:positiveInteger
  a swa:NumericDatatype ;
.
xsd:short
  a swa:NumericDatatype ;
.
xsd:unsignedByte
  a swa:NumericDatatype ;
.
xsd:unsignedInt
  a swa:NumericDatatype ;
.
xsd:unsignedLong
  a swa:NumericDatatype ;
.
xsd:unsignedShort
  a swa:NumericDatatype ;
.
owl:
  rdfs:label "Web Ontology Language (OWL)" ;
.
owl:complementOf
  a swa:ClassAxiomProperty ;
.
owl:disjointUnionOf
  a swa:ClassAxiomProperty ;
.
owl:disjointWith
  a swa:ClassAxiomProperty ;
.
owl:equivalentClass
  a swa:ClassAxiomProperty ;
.
owl:equivalentProperty
  a swa:PropertyAxiomProperty ;
.
owl:hasKey
  a swa:ClassAxiomProperty ;
.
owl:intersectionOf
  a swa:ClassAxiomProperty ;
.
owl:inverseOf
  a swa:PropertyAxiomProperty ;
.
owl:oneOf
  a swa:ClassAxiomProperty ;
.
owl:propertyChainAxiom
  a swa:PropertyAxiomProperty ;
.
owl:propertyDisjointWith
  a swa:PropertyAxiomProperty ;
.
owl:unionOf
  a swa:ClassAxiomProperty ;
.
